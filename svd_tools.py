import xml.etree.ElementTree as ElementTree
import sys
import os

cpu_name_table = {
    "CM0+": "cortex-m0plus",
    "CM0": "cortex-m0",
    "CM0PLUS": "cortex-m0plus",
    "CM1": "cortex-m1",
    "CM3": "cortex-m3",
    "CM4": "cortex-m4",
    "CM7": "cortex-m7"
}

cpu_enum_table = {
    "cortex-m0": "CortexM0" ,
    "cortex-m0plus": "CortexM0Plus",
    "cortex-m3": "CortexM3",
    "cortex-m4": "CortexM4",
    "cortex-m7": "CortexM7"
}

cpu_interrupts = {
    "cortex-m0": {
        "NMI": -14,
        "HardFault": -13,
        "SVCall": -5,
        "PendSV": -2,
        "SysTick": -1
    },
    "cortex-m3": {
        "MemoryManagementFault": -12,
        "BusFault": -11,
        "UsageFault": -10,
    },
    "cortex-m4": {},
    "cortex-m7": {}
}

cpu_interrupts["cortex-m0plus"] = cpu_interrupts["cortex-m0"]
cpu_interrupts["cortex-m3"].update(cpu_interrupts["cortex-m0"])
cpu_interrupts["cortex-m4"] = cpu_interrupts["cortex-m3"]
cpu_interrupts["cortex-m7"] = cpu_interrupts["cortex-m4"]

def create_svd_cmake(svd_file, output_dir):
    tree = ElementTree.parse(svd_file)
    root = tree.getroot()
    device_name = tree.find("name").text
    file_path = "{}/{}.cmake".format(output_dir, device_name)

    # create cmake file
    with open(file_path, 'w') as f:
        cpu = root.find("cpu")
        if cpu is not None:
            name = cpu.find("name")
            if name is not None:
                text = name.text
                f.write("set(SVD_CPU {})\n".format(cpu_name_table[text]))

            endian = cpu.find("endian")
            if endian is not None:
                text = endian.text
                f.write("set(SVD_ENDIAN {})\n".format(text))

            fpu_present = cpu.find("fpu_present")
            if fpu_present is not None:
                text = fpu_present.text
                value = ""
                if text == "false" or text == "0":
                    value = "soft"
                elif text == "true" or text == "1":
                    value = "hard"

                if value != "":
                    f.write("set(SVD_FLOAT_ABI {})\n".format(value))

def create_svd_header(svd_file, output_dir):
    tree = ElementTree.parse(svd_file)
    root = tree.getroot()
    device_name = tree.find("name").text
    file_path = "{}/{}.hpp".format(output_dir, device_name)

    # create header file
    with open(file_path, 'w') as f:
        interrupts = {}
        print(device_name)
        cpu = root.find("cpu").find("name");
        if cpu is not None:
            cpu_name = cpu_name_table[cpu.text]

        f.write("// This is a file generated by svd-alias.\n\n")
        f.write("#pragma once\n\n")
        f.write("#include \"svd-alias/bit-field.hpp\"\n")
        f.write("#include \"svd-alias/register.hpp\"\n\n")
        f.write('struct %s {\n' % device_name)
        if cpu_name is not None:
            f.write('    static auto const cpu = Svd::Cpu::{};'.format(cpu_enum_table[cpu_name]))
        for peripheral in root.iter("peripheral"):
            peripheral_name = peripheral.find("name").text
            base_address = int(peripheral.find("base_address").text, 16)

            for interrupt in peripheral.iter("interrupt"):
                interrupts[interrupt.find("value").text] = interrupt.find("name").text

            if peripheral.attrib and peripheral.attrib["derivedFrom"]:
                for tmp in root.iter("peripheral"):
                    if peripheral.attrib["derivedFrom"] == tmp.find("name").text:
                        peripheral = tmp
                        break

            if peripheral.find("description") is not None:
                peripheral_description = peripheral.find("description").text
                f.write('    // %s\n' % ' '.join(peripheral_description.replace('\n', ' ').replace('\r', '').split()))
            f.write("    struct %s {\n" % peripheral_name)
            f.write("        using Mcu = %s;\n\n" % device_name)
            for register in peripheral.iter("register"):
                register_name = register.find("name").text
                address_offset = int(register.find("address_offset").text, 16)
                register_access = register.find("access")
                access = ""
                if register.find("description") is not None:
                    register_description = register.find("description").text
                    f.write('        // %s\n' % ' '.join(register_description.replace('\n', ' ').replace('\r', '').split()))

                if register_access is not None:
                    value = register_access.text
                    if value == "read-only":
                        access = "ReadOnly"
                    elif value == "write-only" or value == "write-once":
                        access = "WriteOnly"

                if "[%s]" in register_name:
                    for i in range(0, int(register.find("dim").text, 16)):
                        create_register(f, register,
                                register_name.replace("[%s]", str(i)), access,
                                hex(base_address + address_offset + (i * int(register.find("dimIncrement").text, 16))))
                elif "%s" in register_name:
                    print("Register list not implemented yet")
                    exit()
                else:
                    create_register(f, register, register_name, access, hex(base_address + address_offset))

            f.write('    };\n\n')

        max = 0
        for number in interrupts:
            value = int(number)
            max = value if value > max else max

        int_list = [""] * (max + 1)

        for number, interrupt in interrupts.items():
            int_list[int(number)] = interrupt

        f.write('    static std::uint32_t const numInterrupts = {};\n\n'.format(len(int_list)))
        f.write('    enum class Interrupts: std::uint32_t {\n')
        for index, interrupt in enumerate(int_list):
            if interrupt != "":
                f.write('        {} = {},\n'.format(interrupt, index))

        f.write('    };\n\n')
        f.write('};\n')
    return file_path

def indent(depth):
    return ''.join(['    '] * depth)

def create_register(file, register, name, access, address):
    file.write('%sstruct %s : public Register%s<%s> {\n' % (indent(2), name, access, address))
    for field in register.iter("field"):
        field_description = field.find("description");
        field_name = field.find("name").text

        bit_width = field.find("bit_width")
        bit_offset = field.find("bit_offset")
        lsb = field.find("lsb")
        msb = field.find("msb")
        bit_range = field.find("bit_range")
        if bit_width is not None and bit_offset is not None:
            width = bit_width.text
            offset = bit_offset.text
        elif lsb is not None and msb is not None:
            offset = lsb.text
            width = str(int(msb.text) - int(lsb.text) + 1)
        elif bit_range is not None:
            print("bit_range not implemented yet")
            exit()
        else:
            print("failed to find field position")
            exit()

        file.write('%susing %s = Field<%s, %s>;' % (indent(3), field_name if field_name != name else "Field", offset, width))
        if field_description is not None:
            file.write('    // %s' % ' '.join(field_description.text.replace('\n', ' ').replace('\r', '').split()))

        file.write('\n')

    file.write('%s};\n\n' % indent(2))
