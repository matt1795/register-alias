import xml.etree.ElementTree as ElementTree
import sys
import os

cpuNameTable = {
    "CM0+": "cortex-m0plus",
    "CM0": "cortex-m0",
    "CM0PLUS": "cortex-mplus",
    "CM1": "cortex-m1",
    "CM3": "cortex-m3",
    "CM4": "cortex-m4",
    "CM7": "cortex-m7"
}

def create_register_alias_cmake(svd_file, output_dir):
    tree = ElementTree.parse(svd_file)
    root = tree.getroot()
    deviceName = tree.find("name").text
    file_path = "{}/{}.cmake".format(output_dir, deviceName)

    # create cmake file
    with open(file_path, 'w') as f:
        cpu = root.find("cpu")
        if cpu is not None:
            name = cpu.find("name")
            if name is not None:
                text = name.text
                f.write("set(SVD_CPU {})\n".format(cpuNameTable[text]))

            endian = cpu.find("endian")
            if endian is not None:
                text = endian.text
                f.write("set(SVD_ENDIAN {})\n".format(text))

            fpuPresent = cpu.find("fpuPresent")
            if fpuPresent is not None:
                text = fpuPresent.text
                value = ""
                if text == "false" or text == "0":
                    value = "soft"
                elif text == "true" or text == "1":
                    value = "hard"

                if value != "":
                    f.write("set(SVD_FLOAT_ABI {})\n".format(value))

def create_register_alias_header(svd_file, output_dir):
    tree = ElementTree.parse(svd_file)
    root = tree.getroot()
    deviceName = tree.find("name").text
    file_path = "{}/{}.hpp".format(output_dir, deviceName)

    # create header file
    with open(file_path, 'w') as f:
        interrupts = {}
        print(deviceName)
        f.write("// This is a file generated by register-alias.\n\n")
        f.write("#pragma once\n\n")
        f.write("#include \"register-alias/bit-field.hpp\"\n")
        f.write("#include \"register-alias/register.hpp\"\n\n")
        f.write('struct %s {\n' % deviceName)
        for peripheral in root.iter("peripheral"):
            peripheralName = peripheral.find("name").text
            baseAddress = int(peripheral.find("baseAddress").text, 16)

            for interrupt in peripheral.iter("interrupt"):
                interrupts[interrupt.find("value").text] = interrupt.find("name").text

            if peripheral.attrib and peripheral.attrib["derivedFrom"]:
                for tmp in root.iter("peripheral"):
                    if peripheral.attrib["derivedFrom"] == tmp.find("name").text:
                        peripheral = tmp
                        break

            if peripheral.find("description") is not None:
                peripheralDescription = peripheral.find("description").text
                f.write('    // %s\n' % ' '.join(peripheralDescription.replace('\n', ' ').replace('\r', '').split()))

            f.write("    struct %s {\n" % peripheralName)
            f.write("        using Mcu = %s;\n\n" % deviceName)
            for register in peripheral.iter("register"):
                registerName = register.find("name").text
                addressOffset = int(register.find("addressOffset").text, 16)
                registerAccess = register.find("access") 
                access = ""
                if register.find("description") is not None:
                    registerDescription = register.find("description").text
                    f.write('        // %s\n' % ' '.join(registerDescription.replace('\n', ' ').replace('\r', '').split()))

                if registerAccess is not None:
                    value = registerAccess.text
                    if value == "read-only":
                        access = "ReadOnly"
                    elif value == "write-only" or value == "write-once":
                        access = "WriteOnly"

                if "[%s]" in registerName:
                    for i in range(0, int(register.find("dim").text, 16)):
                        create_register(f, register,
                                registerName.replace("[%s]", str(i)), access,
                                hex(baseAddress + addressOffset + (i * int(register.find("dimIncrement").text, 16))))
                elif "%s" in registerName:
                    print("Register list not implemented yet")
                    exit()
                else:
                    create_register(f, register, registerName, access, hex(baseAddress + addressOffset))

            f.write('    };\n\n')

        max = 0
        for number in interrupts:
            value = int(number)
            max = value if value > max else max

        intList = [""] * (max + 1)

        for number, interrupt in interrupts.items():
            intList[int(number)] = interrupt

        f.write('    static std::uint32_t const numInterrupts = {};\n\n'.format(len(intList)))
        f.write('    enum class Interrupts: std::uint32_t {\n')
        for index, interrupt in enumerate(intList):
            if interrupt != "":
                f.write('        {} = {},\n'.format(interrupt, index))

        f.write('    };\n\n')
        f.write('};\n')
    return file_path

def indent(depth):
    return ''.join(['    '] * depth)

def create_register(file, register, name, access, address):
    file.write('%sstruct %s : public Register%s<%s> {\n' % (indent(2), name, access, address))
    for field in register.iter("field"):
        fieldDescription = field.find("description");
        fieldName = field.find("name").text

        bitWidth = field.find("bitWidth")
        bitOffset = field.find("bitOffset")
        lsb = field.find("lsb")
        msb = field.find("msb")
        bitRange = field.find("bitRange")
        if bitWidth is not None and bitOffset is not None:
            width = bitWidth.text
            offset = bitOffset.text
        elif lsb is not None and msb is not None:
            offset = lsb.text
            width = str(int(msb.text) - int(lsb.text) + 1)
        elif bitRange is not None:
            print("bitRange not implemented yet")
            exit()
        else:
            print("failed to find field position")
            exit()

        file.write('%susing %s = Field<%s, %s>;' % (indent(3), fieldName if fieldName != name else "Field", offset, width))
        if fieldDescription is not None:
            file.write('    // %s' % ' '.join(fieldDescription.text.replace('\n', ' ').replace('\r', '').split()))

        file.write('\n')

    file.write('%s};\n\n' % indent(2))
