// This is a file generated by svd-alias.

#pragma once

#include "svd-alias/bit-field.hpp"
#include "svd-alias/register.hpp"

struct STM32L162 {
    // Advanced encrytion standard hardware accelerator
    struct AES {
        // control register
        struct CR : public Register<0x50060000> {
            using DMAOUTEN = Field<12, 1>;    // Enable DMA management of data output phase
            using DMAINEN = Field<11, 1>;    // Enable DMA management of data input phase
            using ERRIE = Field<10, 1>;    // Error interrupt enable
            using CCFIE = Field<9, 1>;    // CCF flag interrupt enable
            using ERRC = Field<8, 1>;    // Error clear
            using CCFC = Field<7, 1>;    // Computation Complete Flag Clear
            using CHMOD = Field<5, 2>;    // AES chaining mode
            using MODE = Field<3, 2>;    // AES operating mode
            using DATATYPE = Field<1, 2>;    // Data type selection
            using EN = Field<0, 1>;    // AES enable
        };

        // Status register
        struct SR : public Register<0x50060004> {
            using WRERR = Field<2, 1>;    // Write error flag
            using RDERR = Field<1, 1>;    // Read error flag
            using CCF = Field<0, 1>;    // Computation complete flag
        };

        // Data input register
        struct DINR : public Register<0x50060008> {
            using Field = Field<0, 32>;    // Data input
        };

        // Data output register
        struct DOUTR : public Register<0x5006000c> {
            using Field = Field<0, 32>;    // Data output
        };

        // AES Key register 0
        struct KEYR0 : public Register<0x50060010> {
            using Field = Field<0, 32>;    // AES key
        };

        // AES Key register 1
        struct KEYR1 : public Register<0x50060014> {
            using Field = Field<0, 32>;    // AES key
        };

        // AES Key register 2
        struct KEYR2 : public Register<0x50060018> {
            using Field = Field<0, 32>;    // AES key
        };

        // AES Key register 3
        struct KEYR3 : public Register<0x5006001c> {
            using Field = Field<0, 32>;    // AES key
        };

        // Initialization Vector Register 0
        struct IVR0 : public Register<0x50060020> {
            using Field = Field<0, 32>;    // Initialization Vector Register
        };

        // Initialization Vector Register 1
        struct IVR1 : public Register<0x50060024> {
            using Field = Field<0, 32>;    // Initialization Vector Register
        };

        // Initialization Vector Register 2
        struct IVR2 : public Register<0x50060028> {
            using Field = Field<0, 32>;    // Initialization Vector Register
        };

        // Initialization Vector Register 3
        struct IVR3 : public Register<0x5006002c> {
            using Field = Field<0, 32>;    // Initialization Vector Register
        };

    };

    // Comparators
    struct COMP {
        // comparator control and status register
        struct CSR : public Register<0x40007c00> {
            using TSUSP = Field<31, 1>;    // Suspend Timer Mode
            using CAIF = Field<30, 1>;    // Channel acquisition interrupt flag
            using CAIE = Field<29, 1>;    // Channel Acquisition Interrupt Enable / Clear
            using RCH13 = Field<28, 1>;    // Select GPIO port PC3 as re-routed ADC input channel CH13.
            using FCH8 = Field<27, 1>;    // Select GPIO port PB0 as fast ADC input channel CH8.
            using FCH3 = Field<26, 1>;    // Select GPIO port PA3 as fast ADC input channel CH3.
            using OUTSEL = Field<21, 3>;    // Comparator 2 output selection
            using INSEL = Field<18, 3>;    // Inverted input selection
            using WNDWE = Field<17, 1>;    // Window mode enable
            using VREFOUTEN = Field<16, 1>;    // VREFINT output enable
            using CMP2OUT = Field<13, 1>;    // Comparator 2 output
            using SPEED = Field<12, 1>;    // Comparator 2 speed mode
            using CMP1OUT = Field<7, 1>;    // Comparator 1 output
            using SW1 = Field<5, 1>;    // SW1 analog switch enable
            using CMP1EN = Field<4, 1>;    // Comparator 1 enable
            using PD400K = Field<3, 1>;    // 400 kO pull-down resistor
            using PD10K = Field<2, 1>;    // 10 kO pull-down resistor
            using PU400K = Field<1, 1>;    // 400 kO pull-up resistor
            using PU10K = Field<0, 1>;    // 10 kO pull-up resistor
        };

    };

    // CRC calculation unit
    struct CRC {
        // Data register
        struct DR : public Register<0x40023000> {
            using Data_register = Field<0, 32>;    // Data Register
        };

        // Independent data register
        struct IDR : public Register<0x40023004> {
            using Independent_data_register = Field<0, 7>;    // Independent data register
        };

        // Control register
        struct CR : public Register<0x40023008> {
            using RESET = Field<0, 1>;    // RESET
        };

    };

    // Digital-to-analog converter
    struct DAC {
        // control register
        struct CR : public Register<0x40007400> {
            using DMAUDRIE2 = Field<29, 1>;    // DAC channel2 DMA underrun interrupt enable
            using DMAEN2 = Field<28, 1>;    // DAC channel2 DMA enable
            using MAMP2 = Field<24, 4>;    // DAC channel2 mask/amplitude selector
            using WAVE2 = Field<22, 2>;    // DAC channel2 noise/triangle wave generation enable
            using TSEL2 = Field<19, 3>;    // DAC channel2 trigger selection
            using TEN2 = Field<18, 1>;    // DAC channel2 trigger enable
            using BOFF2 = Field<17, 1>;    // DAC channel2 output buffer disable
            using EN2 = Field<16, 1>;    // DAC channel2 enable
            using DMAUDRIE1 = Field<13, 1>;    // DAC channel1 DMA Underrun Interrupt enable
            using DMAEN1 = Field<12, 1>;    // DAC channel1 DMA enable
            using MAMP1 = Field<8, 4>;    // DAC channel1 mask/amplitude selector
            using WAVE1 = Field<6, 2>;    // DAC channel1 noise/triangle wave generation enable
            using TSEL1 = Field<3, 3>;    // DAC channel1 trigger selection
            using TEN1 = Field<2, 1>;    // DAC channel1 trigger enable
            using BOFF1 = Field<1, 1>;    // DAC channel1 output buffer disable
            using EN1 = Field<0, 1>;    // DAC channel1 enable
        };

        // software trigger register
        struct SWTRIGR : public Register<0x40007404> {
            using SWTRIG2 = Field<1, 1>;    // DAC channel2 software trigger
            using SWTRIG1 = Field<0, 1>;    // DAC channel1 software trigger
        };

        // channel1 12-bit right-aligned data holding register
        struct DHR12R1 : public Register<0x40007408> {
            using DACC1DHR = Field<0, 12>;    // DAC channel1 12-bit right-aligned data
        };

        // channel1 12-bit left aligned data holding register
        struct DHR12L1 : public Register<0x4000740c> {
            using DACC1DHR = Field<4, 12>;    // DAC channel1 12-bit left-aligned data
        };

        // channel1 8-bit right aligned data holding register
        struct DHR8R1 : public Register<0x40007410> {
            using DACC1DHR = Field<0, 8>;    // DAC channel1 8-bit right-aligned data
        };

        // channel2 12-bit right aligned data holding register
        struct DHR12R2 : public Register<0x40007414> {
            using DACC2DHR = Field<0, 12>;    // DAC channel2 12-bit right-aligned data
        };

        // channel2 12-bit left aligned data holding register
        struct DHR12L2 : public Register<0x40007418> {
            using DACC2DHR = Field<4, 12>;    // DAC channel2 12-bit left-aligned data
        };

        // channel2 8-bit right-aligned data holding register
        struct DHR8R2 : public Register<0x4000741c> {
            using DACC2DHR = Field<0, 8>;    // DAC channel2 8-bit right-aligned data
        };

        // Dual DAC 12-bit right-aligned data holding register
        struct DHR12RD : public Register<0x40007420> {
            using DACC2DHR = Field<16, 12>;    // DAC channel2 12-bit right-aligned data
            using DACC1DHR = Field<0, 12>;    // DAC channel1 12-bit right-aligned data
        };

        // DUAL DAC 12-bit left aligned data holding register
        struct DHR12LD : public Register<0x40007424> {
            using DACC2DHR = Field<20, 12>;    // DAC channel2 12-bit left-aligned data
            using DACC1DHR = Field<4, 12>;    // DAC channel1 12-bit left-aligned data
        };

        // DUAL DAC 8-bit right aligned data holding register
        struct DHR8RD : public Register<0x40007428> {
            using DACC2DHR = Field<8, 8>;    // DAC channel2 8-bit right-aligned data
            using DACC1DHR = Field<0, 8>;    // DAC channel1 8-bit right-aligned data
        };

        // channel1 data output register
        struct DOR1 : public Register<0x4000742c> {
            using DACC1DOR = Field<0, 12>;    // DAC channel1 data output
        };

        // channel2 data output register
        struct DOR2 : public Register<0x40007430> {
            using DACC2DOR = Field<0, 12>;    // DAC channel2 data output
        };

        // status register
        struct SR : public Register<0x40007434> {
            using DMAUDR2 = Field<29, 1>;    // DAC channel2 DMA underrun flag
            using DMAUDR1 = Field<13, 1>;    // DAC channel1 DMA underrun flag
        };

    };

    // Direct memory access controller
    struct DMA1 {
        // interrupt status register
        struct ISR : public Register<0x40026000> {
            using TEIF7 = Field<27, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF7 = Field<26, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF7 = Field<25, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF7 = Field<24, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF6 = Field<23, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF6 = Field<22, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF6 = Field<21, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF6 = Field<20, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF5 = Field<19, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF5 = Field<18, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF5 = Field<17, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF5 = Field<16, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF4 = Field<15, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF4 = Field<14, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF4 = Field<13, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF4 = Field<12, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF3 = Field<11, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF3 = Field<10, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF3 = Field<9, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF3 = Field<8, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF2 = Field<7, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF2 = Field<6, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF2 = Field<5, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF2 = Field<4, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF1 = Field<3, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF1 = Field<2, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF1 = Field<1, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF1 = Field<0, 1>;    // Channel x global interrupt flag (x = 1 ..7)
        };

        // interrupt flag clear register
        struct IFCR : public Register<0x40026004> {
            using CTEIF7 = Field<27, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF7 = Field<26, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF7 = Field<25, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF7 = Field<24, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF6 = Field<23, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF6 = Field<22, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF6 = Field<21, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF6 = Field<20, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF5 = Field<19, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF5 = Field<18, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF5 = Field<17, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF5 = Field<16, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF4 = Field<15, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF4 = Field<14, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF4 = Field<13, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF4 = Field<12, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF3 = Field<11, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF3 = Field<10, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF3 = Field<9, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF3 = Field<8, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF2 = Field<7, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF2 = Field<6, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF2 = Field<5, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF2 = Field<4, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF1 = Field<3, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF1 = Field<2, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF1 = Field<1, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF1 = Field<0, 1>;    // Channel x global interrupt clear (x = 1 ..7)
        };

        // channel x configuration register
        struct CCR1 : public Register<0x40026008> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR1 : public Register<0x4002600c> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR1 : public Register<0x40026010> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR1 : public Register<0x40026014> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR2 : public Register<0x4002601c> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR2 : public Register<0x40026020> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR2 : public Register<0x40026024> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR2 : public Register<0x40026028> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR3 : public Register<0x40026030> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR3 : public Register<0x40026034> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR3 : public Register<0x40026038> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR3 : public Register<0x4002603c> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR4 : public Register<0x40026044> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR4 : public Register<0x40026048> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR4 : public Register<0x4002604c> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR4 : public Register<0x40026050> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR5 : public Register<0x40026058> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR5 : public Register<0x4002605c> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR5 : public Register<0x40026060> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR5 : public Register<0x40026064> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR6 : public Register<0x4002606c> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR6 : public Register<0x40026070> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR6 : public Register<0x40026074> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR6 : public Register<0x40026078> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR7 : public Register<0x40026080> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR7 : public Register<0x40026084> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR7 : public Register<0x40026088> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR7 : public Register<0x4002608c> {
            using MA = Field<0, 32>;    // Memory address
        };

    };

    // Direct memory access controller
    struct DMA2 {
        // interrupt status register
        struct ISR : public Register<0x40026400> {
            using TEIF7 = Field<27, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF7 = Field<26, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF7 = Field<25, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF7 = Field<24, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF6 = Field<23, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF6 = Field<22, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF6 = Field<21, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF6 = Field<20, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF5 = Field<19, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF5 = Field<18, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF5 = Field<17, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF5 = Field<16, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF4 = Field<15, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF4 = Field<14, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF4 = Field<13, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF4 = Field<12, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF3 = Field<11, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF3 = Field<10, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF3 = Field<9, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF3 = Field<8, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF2 = Field<7, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF2 = Field<6, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF2 = Field<5, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF2 = Field<4, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF1 = Field<3, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF1 = Field<2, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF1 = Field<1, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF1 = Field<0, 1>;    // Channel x global interrupt flag (x = 1 ..7)
        };

        // interrupt flag clear register
        struct IFCR : public Register<0x40026404> {
            using CTEIF7 = Field<27, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF7 = Field<26, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF7 = Field<25, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF7 = Field<24, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF6 = Field<23, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF6 = Field<22, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF6 = Field<21, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF6 = Field<20, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF5 = Field<19, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF5 = Field<18, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF5 = Field<17, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF5 = Field<16, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF4 = Field<15, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF4 = Field<14, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF4 = Field<13, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF4 = Field<12, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF3 = Field<11, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF3 = Field<10, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF3 = Field<9, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF3 = Field<8, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF2 = Field<7, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF2 = Field<6, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF2 = Field<5, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF2 = Field<4, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF1 = Field<3, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF1 = Field<2, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF1 = Field<1, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF1 = Field<0, 1>;    // Channel x global interrupt clear (x = 1 ..7)
        };

        // channel x configuration register
        struct CCR1 : public Register<0x40026408> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR1 : public Register<0x4002640c> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR1 : public Register<0x40026410> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR1 : public Register<0x40026414> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR2 : public Register<0x4002641c> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR2 : public Register<0x40026420> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR2 : public Register<0x40026424> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR2 : public Register<0x40026428> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR3 : public Register<0x40026430> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR3 : public Register<0x40026434> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR3 : public Register<0x40026438> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR3 : public Register<0x4002643c> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR4 : public Register<0x40026444> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR4 : public Register<0x40026448> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR4 : public Register<0x4002644c> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR4 : public Register<0x40026450> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR5 : public Register<0x40026458> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR5 : public Register<0x4002645c> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR5 : public Register<0x40026460> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR5 : public Register<0x40026464> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR6 : public Register<0x4002646c> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR6 : public Register<0x40026470> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR6 : public Register<0x40026474> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR6 : public Register<0x40026478> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR7 : public Register<0x40026480> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR7 : public Register<0x40026484> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR7 : public Register<0x40026488> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR7 : public Register<0x4002648c> {
            using MA = Field<0, 32>;    // Memory address
        };

    };

    // External interrupt/event controller
    struct EXTI {
        // IMR
        struct IMR : public Register<0x40010400> {
            using MR = Field<0, 23>;    // Interrupt mask on line x
        };

        // EMR
        struct EMR : public Register<0x40010404> {
            using MR = Field<0, 23>;    // Event mask on line x
        };

        // RTSR
        struct RTSR : public Register<0x40010408> {
            using TR = Field<0, 23>;    // Rising edge trigger event configuration bit of line x
        };

        // FTSR
        struct FTSR : public Register<0x4001040c> {
            using TR = Field<0, 23>;    // Falling edge trigger event configuration bit of line x
        };

        // SWIER
        struct SWIER : public Register<0x40010410> {
            using Field = Field<0, 23>;    // Software interrupt on line x
        };

        // PR
        struct PR : public Register<0x40010414> {
            using Field = Field<0, 23>;    // Pending bit
        };

    };

    // Flash
    struct Flash {
        // Access control register
        struct ACR : public Register<0x40023c00> {
            using LATENCY = Field<0, 1>;    // Latency
            using PRFTEN = Field<1, 1>;    // Prefetch enable
            using ACC64 = Field<2, 1>;    // 64-bit access
            using SLEEP_PD = Field<3, 1>;    // Flash mode during Sleep
            using RUN_PD = Field<4, 1>;    // Flash mode during Run
        };

        // Program/erase control register
        struct PECR : public Register<0x40023c04> {
            using PELOCK = Field<0, 1>;    // FLASH_PECR and data EEPROM lock
            using PRGLOCK = Field<1, 1>;    // Program memory lock
            using OPTLOCK = Field<2, 1>;    // Option bytes block lock
            using PROG = Field<3, 1>;    // Program memory selection
            using DATA = Field<4, 1>;    // Data EEPROM selection
            using FTDW = Field<8, 1>;    // Fixed time data write for Byte, Half Word and Word programming
            using ERASE = Field<9, 1>;    // Page or Double Word erase mode
            using FPRG = Field<10, 1>;    // Half Page/Double Word programming mode
            using PARALLELBANK = Field<15, 1>;    // Parallel bank mode
            using EOPIE = Field<16, 1>;    // End of programming interrupt enable
            using ERRIE = Field<17, 1>;    // Error interrupt enable
            using OBL_LAUNCH = Field<18, 1>;    // Launch the option byte loading
        };

        // Power down key register
        struct PDKEYR : public Register<0x40023c08> {
            using Field = Field<0, 32>;    // RUN_PD in FLASH_ACR key
        };

        // Program/erase key register
        struct PEKEYR : public Register<0x40023c0c> {
            using Field = Field<0, 32>;    // FLASH_PEC and data EEPROM key
        };

        // Program memory key register
        struct PRGKEYR : public Register<0x40023c10> {
            using Field = Field<0, 32>;    // Program memory key
        };

        // Option byte key register
        struct OPTKEYR : public Register<0x40023c14> {
            using Field = Field<0, 32>;    // Option byte key
        };

        // Status register
        struct SR : public Register<0x40023c18> {
            using BSY = Field<0, 1>;    // Write/erase operations in progress
            using EOP = Field<1, 1>;    // End of operation
            using ENDHV = Field<2, 1>;    // End of high voltage
            using READY = Field<3, 1>;    // Flash memory module ready after low power mode
            using WRPERR = Field<8, 1>;    // Write protected error
            using PGAERR = Field<9, 1>;    // Programming alignment error
            using SIZERR = Field<10, 1>;    // Size error
            using OPTVERR = Field<11, 1>;    // Option validity error
            using OPTVERRUSR = Field<12, 1>;    // Option UserValidity Error
        };

        // Option byte register
        struct OBR : public Register<0x40023c1c> {
            using RDPRT = Field<0, 8>;    // Read protection
            using BOR_LEV = Field<16, 4>;    // BOR_LEV
            using IWDG_SW = Field<20, 1>;    // IWDG_SW
            using nRTS_STOP = Field<21, 1>;    // nRTS_STOP
            using nRST_STDBY = Field<22, 1>;    // nRST_STDBY
            using BFB2 = Field<23, 1>;    // Boot From Bank 2
        };

        // Write protection register
        struct WRPR1 : public Register<0x40023c20> {
            using WRP1 = Field<0, 32>;    // Write protection
        };

        // Write protection register
        struct WRPR2 : public Register<0x40023c80> {
            using WRP2 = Field<0, 32>;    // WRP2
        };

        // Write protection register
        struct WRPR3 : public Register<0x40023c84> {
            using WRP3 = Field<0, 32>;    // WRP3
        };

    };

    // Flexible static memory controller
    struct FSMC {
        // BCR1
        struct BCR1 : public Register<0xa0000000> {
            using CBURSTRW = Field<19, 1>;    // CBURSTRW
            using ASYNCWAIT = Field<15, 1>;    // ASYNCWAIT
            using EXTMOD = Field<14, 1>;    // EXTMOD
            using WAITEN = Field<13, 1>;    // WAITEN
            using WREN = Field<12, 1>;    // WREN
            using WAITCFG = Field<11, 1>;    // WAITCFG
            using WRAPMOD = Field<10, 1>;    // WRAPMOD
            using WAITPOL = Field<9, 1>;    // WAITPOL
            using BURSTEN = Field<8, 1>;    // BURSTEN
            using FACCEN = Field<6, 1>;    // FACCEN
            using MWID = Field<4, 2>;    // MWID
            using MTYP = Field<2, 2>;    // MTYP
            using MUXEN = Field<1, 1>;    // MUXEN
            using MBKEN = Field<0, 1>;    // MBKEN
        };

        // BTR1
        struct BTR1 : public Register<0xa0000004> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // BCR2
        struct BCR2 : public Register<0xa0000008> {
            using CBURSTRW = Field<19, 1>;    // CBURSTRW
            using ASYNCWAIT = Field<15, 1>;    // ASYNCWAIT
            using EXTMOD = Field<14, 1>;    // EXTMOD
            using WAITEN = Field<13, 1>;    // WAITEN
            using WREN = Field<12, 1>;    // WREN
            using WAITCFG = Field<11, 1>;    // WAITCFG
            using WRAPMOD = Field<10, 1>;    // WRAPMOD
            using WAITPOL = Field<9, 1>;    // WAITPOL
            using BURSTEN = Field<8, 1>;    // BURSTEN
            using FACCEN = Field<6, 1>;    // FACCEN
            using MWID = Field<4, 2>;    // MWID
            using MTYP = Field<2, 2>;    // MTYP
            using MUXEN = Field<1, 1>;    // MUXEN
            using MBKEN = Field<0, 1>;    // MBKEN
        };

        // BTR2
        struct BTR2 : public Register<0xa000000c> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // BCR3
        struct BCR3 : public Register<0xa0000010> {
            using CBURSTRW = Field<19, 1>;    // CBURSTRW
            using ASYNCWAIT = Field<15, 1>;    // ASYNCWAIT
            using EXTMOD = Field<14, 1>;    // EXTMOD
            using WAITEN = Field<13, 1>;    // WAITEN
            using WREN = Field<12, 1>;    // WREN
            using WAITCFG = Field<11, 1>;    // WAITCFG
            using WRAPMOD = Field<10, 1>;    // WRAPMOD
            using WAITPOL = Field<9, 1>;    // WAITPOL
            using BURSTEN = Field<8, 1>;    // BURSTEN
            using FACCEN = Field<6, 1>;    // FACCEN
            using MWID = Field<4, 2>;    // MWID
            using MTYP = Field<2, 2>;    // MTYP
            using MUXEN = Field<1, 1>;    // MUXEN
            using MBKEN = Field<0, 1>;    // MBKEN
        };

        // BTR3
        struct BTR3 : public Register<0xa0000014> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // BCR4
        struct BCR4 : public Register<0xa0000018> {
            using CBURSTRW = Field<19, 1>;    // CBURSTRW
            using ASYNCWAIT = Field<15, 1>;    // ASYNCWAIT
            using EXTMOD = Field<14, 1>;    // EXTMOD
            using WAITEN = Field<13, 1>;    // WAITEN
            using WREN = Field<12, 1>;    // WREN
            using WAITCFG = Field<11, 1>;    // WAITCFG
            using WRAPMOD = Field<10, 1>;    // WRAPMOD
            using WAITPOL = Field<9, 1>;    // WAITPOL
            using BURSTEN = Field<8, 1>;    // BURSTEN
            using FACCEN = Field<6, 1>;    // FACCEN
            using MWID = Field<4, 2>;    // MWID
            using MTYP = Field<2, 2>;    // MTYP
            using MUXEN = Field<1, 1>;    // MUXEN
            using MBKEN = Field<0, 1>;    // MBKEN
        };

        // BTR4
        struct BTR4 : public Register<0xa000001c> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // BWTR1
        struct BWTR1 : public Register<0xa0000104> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // BWTR2
        struct BWTR2 : public Register<0xa000010c> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // BWTR3
        struct BWTR3 : public Register<0xa0000114> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // BWTR4
        struct BWTR4 : public Register<0xa000011c> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

    };

    // General-purpose I/Os
    struct GPIOA {
        // GPIO port mode register
        struct MODER : public Register<0x40020000> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x40020004> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDER : public Register<0x40020008> {
            using OSPEEDR15 = Field<30, 2>;    // OSPEEDR15
            using OSPEEDR14 = Field<28, 2>;    // OSPEEDR14
            using OSPEEDR13 = Field<26, 2>;    // OSPEEDR13
            using OSPEEDR12 = Field<24, 2>;    // OSPEEDR12
            using OSPEEDR11 = Field<22, 2>;    // OSPEEDR11
            using OSPEEDR10 = Field<20, 2>;    // OSPEEDR10
            using OSPEEDR9 = Field<18, 2>;    // OSPEEDR9
            using OSPEEDR8 = Field<16, 2>;    // OSPEEDR8
            using OSPEEDR7 = Field<14, 2>;    // OSPEEDR7
            using OSPEEDR6 = Field<12, 2>;    // OSPEEDR6
            using OSPEEDR5 = Field<10, 2>;    // OSPEEDR5
            using OSPEEDR4 = Field<8, 2>;    // OSPEEDR4
            using OSPEEDR3 = Field<6, 2>;    // OSPEEDR3
            using OSPEEDR2 = Field<4, 2>;    // OSPEEDR2
            using OSPEEDR1 = Field<2, 2>;    // OSPEEDR1
            using OSPEEDR0 = Field<0, 2>;    // OSPEEDR0
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4002000c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x40020010> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x40020014> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x40020018> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4002001c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // AFRL
        struct AFRL : public Register<0x40020020> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x40020024> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

    };

    // General-purpose I/Os
    struct GPIOB {
        // GPIO port mode register
        struct MODER : public Register<0x40020400> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x40020404> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDER : public Register<0x40020408> {
            using OSPEEDR15 = Field<30, 2>;    // OSPEEDR15
            using OSPEEDR14 = Field<28, 2>;    // OSPEEDR14
            using OSPEEDR13 = Field<26, 2>;    // OSPEEDR13
            using OSPEEDR12 = Field<24, 2>;    // OSPEEDR12
            using OSPEEDR11 = Field<22, 2>;    // OSPEEDR11
            using OSPEEDR10 = Field<20, 2>;    // OSPEEDR10
            using OSPEEDR9 = Field<18, 2>;    // OSPEEDR9
            using OSPEEDR8 = Field<16, 2>;    // OSPEEDR8
            using OSPEEDR7 = Field<14, 2>;    // OSPEEDR7
            using OSPEEDR6 = Field<12, 2>;    // OSPEEDR6
            using OSPEEDR5 = Field<10, 2>;    // OSPEEDR5
            using OSPEEDR4 = Field<8, 2>;    // OSPEEDR4
            using OSPEEDR3 = Field<6, 2>;    // OSPEEDR3
            using OSPEEDR2 = Field<4, 2>;    // OSPEEDR2
            using OSPEEDR1 = Field<2, 2>;    // OSPEEDR1
            using OSPEEDR0 = Field<0, 2>;    // OSPEEDR0
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4002040c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x40020410> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x40020414> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x40020418> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4002041c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // AFRL
        struct AFRL : public Register<0x40020420> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x40020424> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

    };

    // General-purpose I/Os
    struct GPIOC {
        // GPIO port mode register
        struct MODER : public Register<0x40020800> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x40020804> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDER : public Register<0x40020808> {
            using OSPEEDR15 = Field<30, 2>;    // OSPEEDR15
            using OSPEEDR14 = Field<28, 2>;    // OSPEEDR14
            using OSPEEDR13 = Field<26, 2>;    // OSPEEDR13
            using OSPEEDR12 = Field<24, 2>;    // OSPEEDR12
            using OSPEEDR11 = Field<22, 2>;    // OSPEEDR11
            using OSPEEDR10 = Field<20, 2>;    // OSPEEDR10
            using OSPEEDR9 = Field<18, 2>;    // OSPEEDR9
            using OSPEEDR8 = Field<16, 2>;    // OSPEEDR8
            using OSPEEDR7 = Field<14, 2>;    // OSPEEDR7
            using OSPEEDR6 = Field<12, 2>;    // OSPEEDR6
            using OSPEEDR5 = Field<10, 2>;    // OSPEEDR5
            using OSPEEDR4 = Field<8, 2>;    // OSPEEDR4
            using OSPEEDR3 = Field<6, 2>;    // OSPEEDR3
            using OSPEEDR2 = Field<4, 2>;    // OSPEEDR2
            using OSPEEDR1 = Field<2, 2>;    // OSPEEDR1
            using OSPEEDR0 = Field<0, 2>;    // OSPEEDR0
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4002080c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x40020810> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x40020814> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x40020818> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4002081c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // AFRL
        struct AFRL : public Register<0x40020820> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x40020824> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

    };

    // General-purpose I/Os
    struct GPIOD {
        // GPIO port mode register
        struct MODER : public Register<0x40020c00> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x40020c04> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDER : public Register<0x40020c08> {
            using OSPEEDR15 = Field<30, 2>;    // OSPEEDR15
            using OSPEEDR14 = Field<28, 2>;    // OSPEEDR14
            using OSPEEDR13 = Field<26, 2>;    // OSPEEDR13
            using OSPEEDR12 = Field<24, 2>;    // OSPEEDR12
            using OSPEEDR11 = Field<22, 2>;    // OSPEEDR11
            using OSPEEDR10 = Field<20, 2>;    // OSPEEDR10
            using OSPEEDR9 = Field<18, 2>;    // OSPEEDR9
            using OSPEEDR8 = Field<16, 2>;    // OSPEEDR8
            using OSPEEDR7 = Field<14, 2>;    // OSPEEDR7
            using OSPEEDR6 = Field<12, 2>;    // OSPEEDR6
            using OSPEEDR5 = Field<10, 2>;    // OSPEEDR5
            using OSPEEDR4 = Field<8, 2>;    // OSPEEDR4
            using OSPEEDR3 = Field<6, 2>;    // OSPEEDR3
            using OSPEEDR2 = Field<4, 2>;    // OSPEEDR2
            using OSPEEDR1 = Field<2, 2>;    // OSPEEDR1
            using OSPEEDR0 = Field<0, 2>;    // OSPEEDR0
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x40020c0c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x40020c10> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x40020c14> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x40020c18> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x40020c1c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // AFRL
        struct AFRL : public Register<0x40020c20> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x40020c24> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

    };

    // General-purpose I/Os
    struct GPIOE {
        // GPIO port mode register
        struct MODER : public Register<0x40021000> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x40021004> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDER : public Register<0x40021008> {
            using OSPEEDR15 = Field<30, 2>;    // OSPEEDR15
            using OSPEEDR14 = Field<28, 2>;    // OSPEEDR14
            using OSPEEDR13 = Field<26, 2>;    // OSPEEDR13
            using OSPEEDR12 = Field<24, 2>;    // OSPEEDR12
            using OSPEEDR11 = Field<22, 2>;    // OSPEEDR11
            using OSPEEDR10 = Field<20, 2>;    // OSPEEDR10
            using OSPEEDR9 = Field<18, 2>;    // OSPEEDR9
            using OSPEEDR8 = Field<16, 2>;    // OSPEEDR8
            using OSPEEDR7 = Field<14, 2>;    // OSPEEDR7
            using OSPEEDR6 = Field<12, 2>;    // OSPEEDR6
            using OSPEEDR5 = Field<10, 2>;    // OSPEEDR5
            using OSPEEDR4 = Field<8, 2>;    // OSPEEDR4
            using OSPEEDR3 = Field<6, 2>;    // OSPEEDR3
            using OSPEEDR2 = Field<4, 2>;    // OSPEEDR2
            using OSPEEDR1 = Field<2, 2>;    // OSPEEDR1
            using OSPEEDR0 = Field<0, 2>;    // OSPEEDR0
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4002100c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x40021010> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x40021014> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x40021018> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4002101c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // AFRL
        struct AFRL : public Register<0x40021020> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x40021024> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

    };

    // General-purpose I/Os
    struct GPIOF {
        // GPIO port mode register
        struct MODER : public Register<0x40021800> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x40021804> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDER : public Register<0x40021808> {
            using OSPEEDR15 = Field<30, 2>;    // OSPEEDR15
            using OSPEEDR14 = Field<28, 2>;    // OSPEEDR14
            using OSPEEDR13 = Field<26, 2>;    // OSPEEDR13
            using OSPEEDR12 = Field<24, 2>;    // OSPEEDR12
            using OSPEEDR11 = Field<22, 2>;    // OSPEEDR11
            using OSPEEDR10 = Field<20, 2>;    // OSPEEDR10
            using OSPEEDR9 = Field<18, 2>;    // OSPEEDR9
            using OSPEEDR8 = Field<16, 2>;    // OSPEEDR8
            using OSPEEDR7 = Field<14, 2>;    // OSPEEDR7
            using OSPEEDR6 = Field<12, 2>;    // OSPEEDR6
            using OSPEEDR5 = Field<10, 2>;    // OSPEEDR5
            using OSPEEDR4 = Field<8, 2>;    // OSPEEDR4
            using OSPEEDR3 = Field<6, 2>;    // OSPEEDR3
            using OSPEEDR2 = Field<4, 2>;    // OSPEEDR2
            using OSPEEDR1 = Field<2, 2>;    // OSPEEDR1
            using OSPEEDR0 = Field<0, 2>;    // OSPEEDR0
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4002180c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x40021810> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x40021814> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x40021818> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4002181c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // AFRL
        struct AFRL : public Register<0x40021820> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x40021824> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

    };

    // General-purpose I/Os
    struct GPIOG {
        // GPIO port mode register
        struct MODER : public Register<0x40021c00> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x40021c04> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDER : public Register<0x40021c08> {
            using OSPEEDR15 = Field<30, 2>;    // OSPEEDR15
            using OSPEEDR14 = Field<28, 2>;    // OSPEEDR14
            using OSPEEDR13 = Field<26, 2>;    // OSPEEDR13
            using OSPEEDR12 = Field<24, 2>;    // OSPEEDR12
            using OSPEEDR11 = Field<22, 2>;    // OSPEEDR11
            using OSPEEDR10 = Field<20, 2>;    // OSPEEDR10
            using OSPEEDR9 = Field<18, 2>;    // OSPEEDR9
            using OSPEEDR8 = Field<16, 2>;    // OSPEEDR8
            using OSPEEDR7 = Field<14, 2>;    // OSPEEDR7
            using OSPEEDR6 = Field<12, 2>;    // OSPEEDR6
            using OSPEEDR5 = Field<10, 2>;    // OSPEEDR5
            using OSPEEDR4 = Field<8, 2>;    // OSPEEDR4
            using OSPEEDR3 = Field<6, 2>;    // OSPEEDR3
            using OSPEEDR2 = Field<4, 2>;    // OSPEEDR2
            using OSPEEDR1 = Field<2, 2>;    // OSPEEDR1
            using OSPEEDR0 = Field<0, 2>;    // OSPEEDR0
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x40021c0c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x40021c10> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x40021c14> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x40021c18> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x40021c1c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // AFRL
        struct AFRL : public Register<0x40021c20> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x40021c24> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

    };

    // General-purpose I/Os
    struct GPIOH {
        // GPIO port mode register
        struct MODER : public Register<0x40021400> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x40021404> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDER : public Register<0x40021408> {
            using OSPEEDR15 = Field<30, 2>;    // OSPEEDR15
            using OSPEEDR14 = Field<28, 2>;    // OSPEEDR14
            using OSPEEDR13 = Field<26, 2>;    // OSPEEDR13
            using OSPEEDR12 = Field<24, 2>;    // OSPEEDR12
            using OSPEEDR11 = Field<22, 2>;    // OSPEEDR11
            using OSPEEDR10 = Field<20, 2>;    // OSPEEDR10
            using OSPEEDR9 = Field<18, 2>;    // OSPEEDR9
            using OSPEEDR8 = Field<16, 2>;    // OSPEEDR8
            using OSPEEDR7 = Field<14, 2>;    // OSPEEDR7
            using OSPEEDR6 = Field<12, 2>;    // OSPEEDR6
            using OSPEEDR5 = Field<10, 2>;    // OSPEEDR5
            using OSPEEDR4 = Field<8, 2>;    // OSPEEDR4
            using OSPEEDR3 = Field<6, 2>;    // OSPEEDR3
            using OSPEEDR2 = Field<4, 2>;    // OSPEEDR2
            using OSPEEDR1 = Field<2, 2>;    // OSPEEDR1
            using OSPEEDR0 = Field<0, 2>;    // OSPEEDR0
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4002140c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x40021410> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x40021414> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x40021418> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4002141c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // AFRL
        struct AFRL : public Register<0x40021420> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x40021424> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

    };

    // Inter-integrated circuit
    struct I2C1 {
        // CR1
        struct CR1 : public Register<0x40005400> {
            using SWRST = Field<15, 1>;    // Software reset
            using ALERT = Field<13, 1>;    // SMBus alert
            using PEC = Field<12, 1>;    // Packet error checking
            using POS = Field<11, 1>;    // Acknowledge/PEC Position (for data reception)
            using ACK = Field<10, 1>;    // Acknowledge enable
            using STOP = Field<9, 1>;    // Stop generation
            using START = Field<8, 1>;    // Start generation
            using NOSTRETCH = Field<7, 1>;    // Clock stretching disable (Slave mode)
            using ENGC = Field<6, 1>;    // General call enable
            using ENPEC = Field<5, 1>;    // PEC enable
            using ENARP = Field<4, 1>;    // ARP enable
            using SMBTYPE = Field<3, 1>;    // SMBus type
            using SMBUS = Field<1, 1>;    // SMBus mode
            using PE = Field<0, 1>;    // Peripheral enable
        };

        // CR2
        struct CR2 : public Register<0x40005404> {
            using LAST = Field<12, 1>;    // DMA last transfer
            using DMAEN = Field<11, 1>;    // DMA requests enable
            using ITBUFEN = Field<10, 1>;    // Buffer interrupt enable
            using ITEVTEN = Field<9, 1>;    // Event interrupt enable
            using ITERREN = Field<8, 1>;    // Error interrupt enable
            using FREQ = Field<0, 6>;    // Peripheral clock frequency
        };

        // OAR1
        struct OAR1 : public Register<0x40005408> {
            using ADDMODE = Field<15, 1>;    // ADDMODE
            using ADD_8_9 = Field<8, 2>;    // Interface address
            using ADD_1_7 = Field<1, 7>;    // Interface address
            using ADD_0 = Field<0, 1>;    // Interface address
        };

        // OAR2
        struct OAR2 : public Register<0x4000540c> {
            using ADD2 = Field<1, 7>;    // Interface address
            using ENDUAL = Field<0, 1>;    // Dual addressing mode enable
        };

        // DR
        struct DR : public Register<0x40005410> {
            using Field = Field<0, 8>;    // -bit data register
        };

        // SR1
        struct SR1 : public Register<0x40005414> {
            using SMBALERT = Field<15, 1>;    // SMBus alert
            using TIMEOUT = Field<14, 1>;    // Timeout or Tlow error
            using PECERR = Field<12, 1>;    // PEC Error in reception
            using OVR = Field<11, 1>;    // Overrun/Underrun
            using AF = Field<10, 1>;    // Acknowledge failure
            using ARLO = Field<9, 1>;    // Arbitration lost (master mode)
            using BERR = Field<8, 1>;    // Bus error
            using TxE = Field<7, 1>;    // Data register empty (transmitters)
            using RxNE = Field<6, 1>;    // Data register not empty (receivers)
            using STOPF = Field<4, 1>;    // Stop detection (slave mode)
            using ADD10 = Field<3, 1>;    // 10-bit header sent (Master mode)
            using BTF = Field<2, 1>;    // Byte transfer finished
            using ADDR = Field<1, 1>;    // Address sent (master mode)/matched (slave mode)
            using SB = Field<0, 1>;    // Start bit (Master mode)
        };

        // SR2
        struct SR2 : public Register<0x40005418> {
            using PEC = Field<8, 8>;    // acket error checking register
            using DUALF = Field<7, 1>;    // Dual flag (Slave mode)
            using SMBHOST = Field<6, 1>;    // SMBus host header (Slave mode)
            using SMBDEFAULT = Field<5, 1>;    // SMBus device default address (Slave mode)
            using GENCALL = Field<4, 1>;    // General call address (Slave mode)
            using TRA = Field<2, 1>;    // Transmitter/receiver
            using BUSY = Field<1, 1>;    // Bus busy
            using MSL = Field<0, 1>;    // Master/slave
        };

        // CCR
        struct CCR : public Register<0x4000541c> {
            using F_S = Field<15, 1>;    // I2C master mode selection
            using DUTY = Field<14, 1>;    // Fast mode duty cycle
            using Field = Field<0, 12>;    // Clock control register in Fast/Standard mode (Master mode)
        };

        // TRISE
        struct TRISE : public Register<0x40005420> {
            using Field = Field<0, 6>;    // Maximum rise time in Fast/Standard mode (Master mode)
        };

    };

    // Inter-integrated circuit
    struct I2C2 {
        // CR1
        struct CR1 : public Register<0x40005800> {
            using SWRST = Field<15, 1>;    // Software reset
            using ALERT = Field<13, 1>;    // SMBus alert
            using PEC = Field<12, 1>;    // Packet error checking
            using POS = Field<11, 1>;    // Acknowledge/PEC Position (for data reception)
            using ACK = Field<10, 1>;    // Acknowledge enable
            using STOP = Field<9, 1>;    // Stop generation
            using START = Field<8, 1>;    // Start generation
            using NOSTRETCH = Field<7, 1>;    // Clock stretching disable (Slave mode)
            using ENGC = Field<6, 1>;    // General call enable
            using ENPEC = Field<5, 1>;    // PEC enable
            using ENARP = Field<4, 1>;    // ARP enable
            using SMBTYPE = Field<3, 1>;    // SMBus type
            using SMBUS = Field<1, 1>;    // SMBus mode
            using PE = Field<0, 1>;    // Peripheral enable
        };

        // CR2
        struct CR2 : public Register<0x40005804> {
            using LAST = Field<12, 1>;    // DMA last transfer
            using DMAEN = Field<11, 1>;    // DMA requests enable
            using ITBUFEN = Field<10, 1>;    // Buffer interrupt enable
            using ITEVTEN = Field<9, 1>;    // Event interrupt enable
            using ITERREN = Field<8, 1>;    // Error interrupt enable
            using FREQ = Field<0, 6>;    // Peripheral clock frequency
        };

        // OAR1
        struct OAR1 : public Register<0x40005808> {
            using ADDMODE = Field<15, 1>;    // ADDMODE
            using ADD_8_9 = Field<8, 2>;    // Interface address
            using ADD_1_7 = Field<1, 7>;    // Interface address
            using ADD_0 = Field<0, 1>;    // Interface address
        };

        // OAR2
        struct OAR2 : public Register<0x4000580c> {
            using ADD2 = Field<1, 7>;    // Interface address
            using ENDUAL = Field<0, 1>;    // Dual addressing mode enable
        };

        // DR
        struct DR : public Register<0x40005810> {
            using Field = Field<0, 8>;    // -bit data register
        };

        // SR1
        struct SR1 : public Register<0x40005814> {
            using SMBALERT = Field<15, 1>;    // SMBus alert
            using TIMEOUT = Field<14, 1>;    // Timeout or Tlow error
            using PECERR = Field<12, 1>;    // PEC Error in reception
            using OVR = Field<11, 1>;    // Overrun/Underrun
            using AF = Field<10, 1>;    // Acknowledge failure
            using ARLO = Field<9, 1>;    // Arbitration lost (master mode)
            using BERR = Field<8, 1>;    // Bus error
            using TxE = Field<7, 1>;    // Data register empty (transmitters)
            using RxNE = Field<6, 1>;    // Data register not empty (receivers)
            using STOPF = Field<4, 1>;    // Stop detection (slave mode)
            using ADD10 = Field<3, 1>;    // 10-bit header sent (Master mode)
            using BTF = Field<2, 1>;    // Byte transfer finished
            using ADDR = Field<1, 1>;    // Address sent (master mode)/matched (slave mode)
            using SB = Field<0, 1>;    // Start bit (Master mode)
        };

        // SR2
        struct SR2 : public Register<0x40005818> {
            using PEC = Field<8, 8>;    // acket error checking register
            using DUALF = Field<7, 1>;    // Dual flag (Slave mode)
            using SMBHOST = Field<6, 1>;    // SMBus host header (Slave mode)
            using SMBDEFAULT = Field<5, 1>;    // SMBus device default address (Slave mode)
            using GENCALL = Field<4, 1>;    // General call address (Slave mode)
            using TRA = Field<2, 1>;    // Transmitter/receiver
            using BUSY = Field<1, 1>;    // Bus busy
            using MSL = Field<0, 1>;    // Master/slave
        };

        // CCR
        struct CCR : public Register<0x4000581c> {
            using F_S = Field<15, 1>;    // I2C master mode selection
            using DUTY = Field<14, 1>;    // Fast mode duty cycle
            using Field = Field<0, 12>;    // Clock control register in Fast/Standard mode (Master mode)
        };

        // TRISE
        struct TRISE : public Register<0x40005820> {
            using Field = Field<0, 6>;    // Maximum rise time in Fast/Standard mode (Master mode)
        };

    };

    // Independent watchdog
    struct IWDG {
        // Key register
        struct KR : public Register<0x40003000> {
            using KEY = Field<0, 16>;    // Key value (write only, read 0000h)
        };

        // Prescaler register
        struct PR : public Register<0x40003004> {
            using Field = Field<0, 3>;    // Prescaler divider
        };

        // Reload register
        struct RLR : public Register<0x40003008> {
            using RL = Field<0, 12>;    // Watchdog counter reload value
        };

        // Status register
        struct SR : public Register<0x4000300c> {
            using RVU = Field<1, 1>;    // Watchdog counter reload value update
            using PVU = Field<0, 1>;    // Watchdog prescaler value update
        };

    };

    // Liquid crystal display controller
    struct LCD {
        // control register
        struct CR : public Register<0x40002400> {
            using MUX_SEG = Field<7, 1>;    // Mux segment enable
            using BIAS = Field<5, 2>;    // Bias selector
            using DUTY = Field<2, 3>;    // Duty selection
            using VSEL = Field<1, 1>;    // Voltage source selection
            using LCDEN = Field<0, 1>;    // LCD controller enable
        };

        // frame control register
        struct FCR : public Register<0x40002404> {
            using PS = Field<22, 4>;    // PS 16-bit prescaler
            using DIV = Field<18, 4>;    // DIV clock divider
            using BLINK = Field<16, 2>;    // Blink mode selection
            using BLINKF = Field<13, 3>;    // Blink frequency selection
            using CC = Field<10, 3>;    // Contrast control
            using DEAD = Field<7, 3>;    // Dead time duration
            using PON = Field<4, 3>;    // Pulse ON duration
            using UDDIE = Field<3, 1>;    // Update display done interrupt enable
            using SOFIE = Field<1, 1>;    // Start of frame interrupt enable
            using HD = Field<0, 1>;    // High drive enable
        };

        // status register
        struct SR : public Register<0x40002408> {
            using FCRSF = Field<5, 1>;    // LCD Frame Control Register Synchronization flag
            using RDY = Field<4, 1>;    // Ready flag
            using UDD = Field<3, 1>;    // Update Display Done
            using UDR = Field<2, 1>;    // Update display request
            using SOF = Field<1, 1>;    // Start of frame flag
            using ENS = Field<0, 1>;    // LCD enabled status
        };

        // clear register
        struct CLR : public Register<0x4000240c> {
            using UDDC = Field<3, 1>;    // Update display done clear
            using SOFC = Field<1, 1>;    // Start of frame flag clear
        };

        // display memory
        struct RAM_COM0 : public Register<0x40002414> {
            using S31 = Field<31, 1>;    // S31
            using S30 = Field<30, 1>;    // S30
            using S29 = Field<29, 1>;    // S29
            using S28 = Field<28, 1>;    // S28
            using S27 = Field<27, 1>;    // S27
            using S26 = Field<26, 1>;    // S26
            using S25 = Field<25, 1>;    // S25
            using S24 = Field<24, 1>;    // S24
            using S23 = Field<23, 1>;    // S23
            using S22 = Field<22, 1>;    // S22
            using S21 = Field<21, 1>;    // S21
            using S20 = Field<20, 1>;    // S20
            using S19 = Field<19, 1>;    // S19
            using S18 = Field<18, 1>;    // S18
            using S17 = Field<17, 1>;    // S17
            using S16 = Field<16, 1>;    // S16
            using S15 = Field<15, 1>;    // S15
            using S14 = Field<14, 1>;    // S14
            using S13 = Field<13, 1>;    // S13
            using S12 = Field<12, 1>;    // S12
            using S11 = Field<11, 1>;    // S11
            using S10 = Field<10, 1>;    // S10
            using S09 = Field<9, 1>;    // S09
            using S08 = Field<8, 1>;    // S08
            using S07 = Field<7, 1>;    // S07
            using S06 = Field<6, 1>;    // S06
            using S05 = Field<5, 1>;    // S05
            using S04 = Field<4, 1>;    // S04
            using S03 = Field<3, 1>;    // S03
            using S02 = Field<2, 1>;    // S02
            using S01 = Field<1, 1>;    // S01
            using S00 = Field<0, 1>;    // S00
        };

        // display memory
        struct RAM_COM1 : public Register<0x4000241c> {
            using S31 = Field<31, 1>;    // S31
            using S30 = Field<30, 1>;    // S30
            using S29 = Field<29, 1>;    // S29
            using S28 = Field<28, 1>;    // S28
            using S27 = Field<27, 1>;    // S27
            using S26 = Field<26, 1>;    // S26
            using S25 = Field<25, 1>;    // S25
            using S24 = Field<24, 1>;    // S24
            using S23 = Field<23, 1>;    // S23
            using S22 = Field<22, 1>;    // S22
            using S21 = Field<21, 1>;    // S21
            using S20 = Field<20, 1>;    // S20
            using S19 = Field<19, 1>;    // S19
            using S18 = Field<18, 1>;    // S18
            using S17 = Field<17, 1>;    // S17
            using S16 = Field<16, 1>;    // S16
            using S15 = Field<15, 1>;    // S15
            using S14 = Field<14, 1>;    // S14
            using S13 = Field<13, 1>;    // S13
            using S12 = Field<12, 1>;    // S12
            using S11 = Field<11, 1>;    // S11
            using S10 = Field<10, 1>;    // S10
            using S09 = Field<9, 1>;    // S09
            using S08 = Field<8, 1>;    // S08
            using S07 = Field<7, 1>;    // S07
            using S06 = Field<6, 1>;    // S06
            using S05 = Field<5, 1>;    // S05
            using S04 = Field<4, 1>;    // S04
            using S03 = Field<3, 1>;    // S03
            using S02 = Field<2, 1>;    // S02
            using S01 = Field<1, 1>;    // S01
            using S00 = Field<0, 1>;    // S00
        };

        // display memory
        struct RAM_COM2 : public Register<0x40002424> {
            using S31 = Field<31, 1>;    // S31
            using S30 = Field<30, 1>;    // S30
            using S29 = Field<29, 1>;    // S29
            using S28 = Field<28, 1>;    // S28
            using S27 = Field<27, 1>;    // S27
            using S26 = Field<26, 1>;    // S26
            using S25 = Field<25, 1>;    // S25
            using S24 = Field<24, 1>;    // S24
            using S23 = Field<23, 1>;    // S23
            using S22 = Field<22, 1>;    // S22
            using S21 = Field<21, 1>;    // S21
            using S20 = Field<20, 1>;    // S20
            using S19 = Field<19, 1>;    // S19
            using S18 = Field<18, 1>;    // S18
            using S17 = Field<17, 1>;    // S17
            using S16 = Field<16, 1>;    // S16
            using S15 = Field<15, 1>;    // S15
            using S14 = Field<14, 1>;    // S14
            using S13 = Field<13, 1>;    // S13
            using S12 = Field<12, 1>;    // S12
            using S11 = Field<11, 1>;    // S11
            using S10 = Field<10, 1>;    // S10
            using S09 = Field<9, 1>;    // S09
            using S08 = Field<8, 1>;    // S08
            using S07 = Field<7, 1>;    // S07
            using S06 = Field<6, 1>;    // S06
            using S05 = Field<5, 1>;    // S05
            using S04 = Field<4, 1>;    // S04
            using S03 = Field<3, 1>;    // S03
            using S02 = Field<2, 1>;    // S02
            using S01 = Field<1, 1>;    // S01
            using S00 = Field<0, 1>;    // S00
        };

        // display memory
        struct RAM_COM3 : public Register<0x4000242c> {
            using S31 = Field<31, 1>;    // S31
            using S30 = Field<30, 1>;    // S30
            using S29 = Field<29, 1>;    // S29
            using S28 = Field<28, 1>;    // S28
            using S27 = Field<27, 1>;    // S27
            using S26 = Field<26, 1>;    // S26
            using S25 = Field<25, 1>;    // S25
            using S24 = Field<24, 1>;    // S24
            using S23 = Field<23, 1>;    // S23
            using S22 = Field<22, 1>;    // S22
            using S21 = Field<21, 1>;    // S21
            using S20 = Field<20, 1>;    // S20
            using S19 = Field<19, 1>;    // S19
            using S18 = Field<18, 1>;    // S18
            using S17 = Field<17, 1>;    // S17
            using S16 = Field<16, 1>;    // S16
            using S15 = Field<15, 1>;    // S15
            using S14 = Field<14, 1>;    // S14
            using S13 = Field<13, 1>;    // S13
            using S12 = Field<12, 1>;    // S12
            using S11 = Field<11, 1>;    // S11
            using S10 = Field<10, 1>;    // S10
            using S09 = Field<9, 1>;    // S09
            using S08 = Field<8, 1>;    // S08
            using S07 = Field<7, 1>;    // S07
            using S06 = Field<6, 1>;    // S06
            using S05 = Field<5, 1>;    // S05
            using S04 = Field<4, 1>;    // S04
            using S03 = Field<3, 1>;    // S03
            using S02 = Field<2, 1>;    // S02
            using S01 = Field<1, 1>;    // S01
            using S00 = Field<0, 1>;    // S00
        };

        // display memory
        struct RAM_COM4 : public Register<0x40002434> {
            using S31 = Field<31, 1>;    // S31
            using S30 = Field<30, 1>;    // S30
            using S29 = Field<29, 1>;    // S29
            using S28 = Field<28, 1>;    // S28
            using S27 = Field<27, 1>;    // S27
            using S26 = Field<26, 1>;    // S26
            using S25 = Field<25, 1>;    // S25
            using S24 = Field<24, 1>;    // S24
            using S23 = Field<23, 1>;    // S23
            using S22 = Field<22, 1>;    // S22
            using S21 = Field<21, 1>;    // S21
            using S20 = Field<20, 1>;    // S20
            using S19 = Field<19, 1>;    // S19
            using S18 = Field<18, 1>;    // S18
            using S17 = Field<17, 1>;    // S17
            using S16 = Field<16, 1>;    // S16
            using S15 = Field<15, 1>;    // S15
            using S14 = Field<14, 1>;    // S14
            using S13 = Field<13, 1>;    // S13
            using S12 = Field<12, 1>;    // S12
            using S11 = Field<11, 1>;    // S11
            using S10 = Field<10, 1>;    // S10
            using S09 = Field<9, 1>;    // S09
            using S08 = Field<8, 1>;    // S08
            using S07 = Field<7, 1>;    // S07
            using S06 = Field<6, 1>;    // S06
            using S05 = Field<5, 1>;    // S05
            using S04 = Field<4, 1>;    // S04
            using S03 = Field<3, 1>;    // S03
            using S02 = Field<2, 1>;    // S02
            using S01 = Field<1, 1>;    // S01
            using S00 = Field<0, 1>;    // S00
        };

        // display memory
        struct RAM_COM5 : public Register<0x4000243c> {
            using S31 = Field<31, 1>;    // S31
            using S30 = Field<30, 1>;    // S30
            using S29 = Field<29, 1>;    // S29
            using S28 = Field<28, 1>;    // S28
            using S27 = Field<27, 1>;    // S27
            using S26 = Field<26, 1>;    // S26
            using S25 = Field<25, 1>;    // S25
            using S24 = Field<24, 1>;    // S24
            using S23 = Field<23, 1>;    // S23
            using S22 = Field<22, 1>;    // S22
            using S21 = Field<21, 1>;    // S21
            using S20 = Field<20, 1>;    // S20
            using S19 = Field<19, 1>;    // S19
            using S18 = Field<18, 1>;    // S18
            using S17 = Field<17, 1>;    // S17
            using S16 = Field<16, 1>;    // S16
            using S15 = Field<15, 1>;    // S15
            using S14 = Field<14, 1>;    // S14
            using S13 = Field<13, 1>;    // S13
            using S12 = Field<12, 1>;    // S12
            using S11 = Field<11, 1>;    // S11
            using S10 = Field<10, 1>;    // S10
            using S09 = Field<9, 1>;    // S09
            using S08 = Field<8, 1>;    // S08
            using S07 = Field<7, 1>;    // S07
            using S06 = Field<6, 1>;    // S06
            using S05 = Field<5, 1>;    // S05
            using S04 = Field<4, 1>;    // S04
            using S03 = Field<3, 1>;    // S03
            using S02 = Field<2, 1>;    // S02
            using S01 = Field<1, 1>;    // S01
            using S00 = Field<0, 1>;    // S00
        };

        // display memory
        struct RAM_COM6 : public Register<0x40002444> {
            using S31 = Field<31, 1>;    // S31
            using S30 = Field<30, 1>;    // S30
            using S29 = Field<29, 1>;    // S29
            using S28 = Field<28, 1>;    // S28
            using S27 = Field<27, 1>;    // S27
            using S26 = Field<26, 1>;    // S26
            using S25 = Field<25, 1>;    // S25
            using S24 = Field<24, 1>;    // S24
            using S23 = Field<23, 1>;    // S23
            using S22 = Field<22, 1>;    // S22
            using S21 = Field<21, 1>;    // S21
            using S20 = Field<20, 1>;    // S20
            using S19 = Field<19, 1>;    // S19
            using S18 = Field<18, 1>;    // S18
            using S17 = Field<17, 1>;    // S17
            using S16 = Field<16, 1>;    // S16
            using S15 = Field<15, 1>;    // S15
            using S14 = Field<14, 1>;    // S14
            using S13 = Field<13, 1>;    // S13
            using S12 = Field<12, 1>;    // S12
            using S11 = Field<11, 1>;    // S11
            using S10 = Field<10, 1>;    // S10
            using S09 = Field<9, 1>;    // S09
            using S08 = Field<8, 1>;    // S08
            using S07 = Field<7, 1>;    // S07
            using S06 = Field<6, 1>;    // S06
            using S05 = Field<5, 1>;    // S05
            using S04 = Field<4, 1>;    // S04
            using S03 = Field<3, 1>;    // S03
            using S02 = Field<2, 1>;    // S02
            using S01 = Field<1, 1>;    // S01
            using S00 = Field<0, 1>;    // S00
        };

        // display memory
        struct RAM_COM7 : public Register<0x4000244c> {
            using S31 = Field<31, 1>;    // S31
            using S30 = Field<30, 1>;    // S30
            using S29 = Field<29, 1>;    // S29
            using S28 = Field<28, 1>;    // S28
            using S27 = Field<27, 1>;    // S27
            using S26 = Field<26, 1>;    // S26
            using S25 = Field<25, 1>;    // S25
            using S24 = Field<24, 1>;    // S24
            using S23 = Field<23, 1>;    // S23
            using S22 = Field<22, 1>;    // S22
            using S21 = Field<21, 1>;    // S21
            using S20 = Field<20, 1>;    // S20
            using S19 = Field<19, 1>;    // S19
            using S18 = Field<18, 1>;    // S18
            using S17 = Field<17, 1>;    // S17
            using S16 = Field<16, 1>;    // S16
            using S15 = Field<15, 1>;    // S15
            using S14 = Field<14, 1>;    // S14
            using S13 = Field<13, 1>;    // S13
            using S12 = Field<12, 1>;    // S12
            using S11 = Field<11, 1>;    // S11
            using S10 = Field<10, 1>;    // S10
            using S09 = Field<9, 1>;    // S09
            using S08 = Field<8, 1>;    // S08
            using S07 = Field<7, 1>;    // S07
            using S06 = Field<6, 1>;    // S06
            using S05 = Field<5, 1>;    // S05
            using S04 = Field<4, 1>;    // S04
            using S03 = Field<3, 1>;    // S03
            using S02 = Field<2, 1>;    // S02
            using S01 = Field<1, 1>;    // S01
            using S00 = Field<0, 1>;    // S00
        };

    };

    // Operational amplifiers
    struct OPAMP {
        // control/status register
        struct CSR : public Register<0x40007c5c> {
            using OPA3CALOUT = Field<31, 1>;    // OPAMP3 calibration output
            using OPA2CALOUT = Field<30, 1>;    // OPAMP2 calibration output
            using OPA1CALOUT = Field<29, 1>;    // OPAMP1 calibration output
            using AOP_RANGE = Field<28, 1>;    // Power range selection
            using S7SEL2 = Field<27, 1>;    // Switch 7 for OPAMP2 enable
            using ANAWSEL3 = Field<26, 1>;    // Switch SanA enable for OPAMP3
            using ANAWSEL2 = Field<25, 1>;    // Switch SanA enable for OPAMP2
            using ANAWSEL1 = Field<24, 1>;    // Switch SanA enable for OPAMP1
            using OPA3LPM = Field<23, 1>;    // OPAMP3 low power mode
            using OPA3CAL_H = Field<22, 1>;    // OPAMP3 offset calibration for N differential pair
            using OPA3CAL_L = Field<21, 1>;    // OPAMP3 offset Calibration for P differential pair
            using S6SEL3 = Field<20, 1>;    // Switch 6 for OPAMP3 enable
            using S5SEL3 = Field<19, 1>;    // Switch 5 for OPAMP3 enable
            using S4SEL3 = Field<18, 1>;    // Switch 4 for OPAMP3 enable
            using S3SEL3 = Field<17, 1>;    // Switch 3 for OPAMP3 Enable
            using OPA3PD = Field<16, 1>;    // OPAMP3 power down
            using OPA2LPM = Field<15, 1>;    // OPAMP2 low power mode
            using OPA2CAL_H = Field<14, 1>;    // OPAMP2 offset calibration for N differential pair
            using OPA2CAL_L = Field<13, 1>;    // OPAMP2 offset Calibration for P differential pair
            using S6SEL2 = Field<12, 1>;    // Switch 6 for OPAMP2 enable
            using S5SEL2 = Field<11, 1>;    // Switch 5 for OPAMP2 enable
            using S4SEL2 = Field<10, 1>;    // Switch 4 for OPAMP2 enable
            using S3SEL2 = Field<9, 1>;    // Switch 3 for OPAMP2 enable
            using OPA2PD = Field<8, 1>;    // OPAMP2 power down
            using OPA1LPM = Field<7, 1>;    // OPAMP1 low power mode
            using OPA1CAL_H = Field<6, 1>;    // OPAMP1 offset calibration for N differential pair
            using OPA1CAL_L = Field<5, 1>;    // OPAMP1 offset calibration for P differential pair
            using S6SEL1 = Field<4, 1>;    // Switch 6 for OPAMP1 enable
            using S5SEL1 = Field<3, 1>;    // Switch 5 for OPAMP1 enable
            using S4SEL1 = Field<2, 1>;    // Switch 4 for OPAMP1 enable
            using S3SEL1 = Field<1, 1>;    // Switch 3 for OPAMP1 enable
            using OPA1PD = Field<0, 1>;    // OPAMP1 power down
        };

        // offset trimming register for normal mode
        struct OTR : public Register<0x40007c60> {
            using OT_USER = Field<31, 1>;    // Select user or factory trimming value
            using AO3_OPT_OFFSET_TRIM = Field<20, 10>;    // OPAMP3, 10-bit offset trim value for normal mode
            using AO2_OPT_OFFSET_TRIM = Field<10, 10>;    // OPAMP2, 10-bit offset trim value for normal mode
            using AO1_OPT_OFFSET_TRIM = Field<0, 10>;    // OPAMP1, 10-bit offset trim value for normal mode
        };

        // OPAMP offset trimming register for low power mode
        struct LPOTR : public Register<0x40007c64> {
            using AO3_OPT_OFFSET_TRIM_LP = Field<20, 10>;    // OPAMP3, 10-bit offset trim value for low power mode
            using AO2_OPT_OFFSET_TRIM_LP = Field<10, 10>;    // OPAMP2, 10-bit offset trim value for low power mode
            using AO1_OPT_OFFSET_TRIM_LP = Field<0, 10>;    // OPAMP1, 10-bit offset trim value for low power mode
        };

    };

    // Power control
    struct PWR {
        // power control register
        struct CR : public Register<0x40007000> {
            using LPRUN = Field<14, 1>;    // Low power run mode
            using VOS = Field<11, 2>;    // Voltage scaling range selection
            using FWU = Field<10, 1>;    // Fast wakeup
            using ULP = Field<9, 1>;    // Ultralow power mode
            using DBP = Field<8, 1>;    // Disable backup domain write protection
            using PLS = Field<5, 3>;    // PVD level selection
            using PVDE = Field<4, 1>;    // Power voltage detector enable
            using CSBF = Field<3, 1>;    // Clear standby flag
            using CWUF = Field<2, 1>;    // Clear wakeup flag
            using PDDS = Field<1, 1>;    // Power down deepsleep
            using LPSDSR = Field<0, 1>;    // Low-power deep sleep
        };

        // power control/status register
        struct CSR : public Register<0x40007004> {
            using EWUP3 = Field<10, 1>;    // Enable WKUP pin 3
            using EWUP2 = Field<9, 1>;    // Enable WKUP pin 2
            using EWUP1 = Field<8, 1>;    // Enable WKUP pin 1
            using REGLPF = Field<5, 1>;    // Regulator LP flag
            using VOSF = Field<4, 1>;    // Voltage Scaling select flag
            using VREFINTRDYF = Field<3, 1>;    // Internal voltage reference (VREFINT) ready flag
            using PVDO = Field<2, 1>;    // PVD output
            using SBF = Field<1, 1>;    // Standby flag
            using WUF = Field<0, 1>;    // Wakeup flag
        };

    };

    // Reset and clock control
    struct RCC {
        // Clock control register
        struct CR : public Register<0x40023800> {
            using RTCPRE1 = Field<30, 1>;    // TC/LCD prescaler
            using RTCPRE0 = Field<29, 1>;    // RTCPRE0
            using CSSON = Field<28, 1>;    // Clock security system enable
            using PLLRDY = Field<25, 1>;    // PLL clock ready flag
            using PLLON = Field<24, 1>;    // PLL enable
            using HSEBYP = Field<18, 1>;    // HSE clock bypass
            using HSERDY = Field<17, 1>;    // HSE clock ready flag
            using HSEON = Field<16, 1>;    // HSE clock enable
            using MSIRDY = Field<9, 1>;    // MSI clock ready flag
            using MSION = Field<8, 1>;    // MSI clock enable
            using HSIRDY = Field<1, 1>;    // Internal high-speed clock ready flag
            using HSION = Field<0, 1>;    // Internal high-speed clock enable
        };

        // Internal clock sources calibration register
        struct ICSCR : public Register<0x40023804> {
            using MSITRIM = Field<24, 8>;    // MSI clock trimming
            using MSICAL = Field<16, 8>;    // MSI clock calibration
            using MSIRANGE = Field<13, 3>;    // MSI clock ranges
            using HSITRIM = Field<8, 5>;    // High speed internal clock trimming
            using HSICAL = Field<0, 8>;    // nternal high speed clock calibration
        };

        // Clock configuration register
        struct CFGR : public Register<0x40023808> {
            using MCOPRE = Field<28, 3>;    // Microcontroller clock output prescaler
            using MCOSEL = Field<24, 3>;    // Microcontroller clock output selection
            using PLLDIV = Field<22, 2>;    // PLL output division
            using PLLMUL = Field<18, 4>;    // PLL multiplication factor
            using PLLSRC = Field<16, 1>;    // PLL entry clock source
            using PPRE2 = Field<11, 3>;    // APB high-speed prescaler (APB2)
            using PPRE1 = Field<8, 3>;    // APB low-speed prescaler (APB1)
            using HPRE = Field<4, 4>;    // AHB prescaler
            using SWS = Field<2, 2>;    // System clock switch status
            using SW = Field<0, 2>;    // System clock switch
        };

        // Clock interrupt register
        struct CIR : public Register<0x4002380c> {
            using CSSC = Field<23, 1>;    // Clock security system interrupt clear
            using MSIRDYC = Field<21, 1>;    // MSI ready interrupt clear
            using PLLRDYC = Field<20, 1>;    // PLL ready interrupt clear
            using HSERDYC = Field<19, 1>;    // HSE ready interrupt clear
            using HSIRDYC = Field<18, 1>;    // HSI ready interrupt clear
            using LSERDYC = Field<17, 1>;    // LSE ready interrupt clear
            using LSIRDYC = Field<16, 1>;    // LSI ready interrupt clear
            using MSIRDYIE = Field<13, 1>;    // MSI ready interrupt enable
            using PLLRDYIE = Field<12, 1>;    // PLL ready interrupt enable
            using HSERDYIE = Field<11, 1>;    // HSE ready interrupt enable
            using HSIRDYIE = Field<10, 1>;    // HSI ready interrupt enable
            using LSERDYIE = Field<9, 1>;    // LSE ready interrupt enable
            using LSIRDYIE = Field<8, 1>;    // LSI ready interrupt enable
            using CSSF = Field<7, 1>;    // Clock security system interrupt flag
            using MSIRDYF = Field<5, 1>;    // MSI ready interrupt flag
            using PLLRDYF = Field<4, 1>;    // PLL ready interrupt flag
            using HSERDYF = Field<3, 1>;    // HSE ready interrupt flag
            using HSIRDYF = Field<2, 1>;    // HSI ready interrupt flag
            using LSERDYF = Field<1, 1>;    // LSE ready interrupt flag
            using LSIRDYF = Field<0, 1>;    // LSI ready interrupt flag
        };

        // AHB peripheral reset register
        struct AHBRSTR : public Register<0x40023810> {
            using FSMCRST = Field<30, 1>;    // FSMC reset
            using DMA2RST = Field<25, 1>;    // DMA2 reset
            using DMA1RST = Field<24, 1>;    // DMA1 reset
            using FLITFRST = Field<15, 1>;    // FLITF reset
            using CRCRST = Field<12, 1>;    // CRC reset
            using GPIOGRST = Field<7, 1>;    // IO port G reset
            using GPIOFRST = Field<6, 1>;    // IO port F reset
            using GPIOHRST = Field<5, 1>;    // IO port H reset
            using GPIOERST = Field<4, 1>;    // IO port E reset
            using GPIODRST = Field<3, 1>;    // IO port D reset
            using GPIOCRST = Field<2, 1>;    // IO port C reset
            using GPIOBRST = Field<1, 1>;    // IO port B reset
            using GPIOARST = Field<0, 1>;    // IO port A reset
        };

        // APB2 peripheral reset register
        struct APB2RSTR : public Register<0x40023814> {
            using USART1RST = Field<14, 1>;    // USART1RST
            using SPI1RST = Field<12, 1>;    // SPI1RST
            using SDIORST = Field<11, 1>;    // SDIORST
            using ADC1RST = Field<9, 1>;    // ADC1RST
            using TM11RST = Field<4, 1>;    // TM11RST
            using TM10RST = Field<3, 1>;    // TM10RST
            using TIM9RST = Field<2, 1>;    // TIM9RST
            using SYSCFGRST = Field<0, 1>;    // SYSCFGRST
        };

        // APB1 peripheral reset register
        struct APB1RSTR : public Register<0x40023818> {
            using COMPRST = Field<31, 1>;    // COMP interface reset
            using DACRST = Field<29, 1>;    // DAC interface reset
            using PWRRST = Field<28, 1>;    // Power interface reset
            using USBRST = Field<23, 1>;    // USB reset
            using I2C2RST = Field<22, 1>;    // I2C 2 reset
            using I2C1RST = Field<21, 1>;    // I2C 1 reset
            using UART5RST = Field<20, 1>;    // UART 5 reset
            using UART4RST = Field<19, 1>;    // UART 4 reset
            using USART3RST = Field<18, 1>;    // USART 3 reset
            using USART2RST = Field<17, 1>;    // USART 2 reset
            using SPI3RST = Field<15, 1>;    // SPI 3 reset
            using SPI2RST = Field<14, 1>;    // SPI 2 reset
            using WWDRST = Field<11, 1>;    // Window watchdog reset
            using LCDRST = Field<9, 1>;    // LCD reset
            using TIM7RST = Field<5, 1>;    // Timer 7 reset
            using TIM6RST = Field<4, 1>;    // Timer 6reset
            using TIM5RST = Field<3, 1>;    // Timer 5 reset
            using TIM4RST = Field<2, 1>;    // Timer 4 reset
            using TIM3RST = Field<1, 1>;    // Timer 3 reset
            using TIM2RST = Field<0, 1>;    // Timer 2 reset
        };

        // AHB peripheral clock enable register
        struct AHBENR : public Register<0x4002381c> {
            using FSMCEN = Field<30, 1>;    // FSMCEN
            using DMA2EN = Field<25, 1>;    // DMA2 clock enable
            using DMA1EN = Field<24, 1>;    // DMA1 clock enable
            using FLITFEN = Field<15, 1>;    // FLITF clock enable
            using CRCEN = Field<12, 1>;    // CRC clock enable
            using GPIOPGEN = Field<7, 1>;    // IO port G clock enable
            using GPIOPFEN = Field<6, 1>;    // IO port F clock enable
            using GPIOPHEN = Field<5, 1>;    // IO port H clock enable
            using GPIOPEEN = Field<4, 1>;    // IO port E clock enable
            using GPIOPDEN = Field<3, 1>;    // IO port D clock enable
            using GPIOPCEN = Field<2, 1>;    // IO port C clock enable
            using GPIOPBEN = Field<1, 1>;    // IO port B clock enable
            using GPIOPAEN = Field<0, 1>;    // IO port A clock enable
        };

        // APB2 peripheral clock enable register
        struct APB2ENR : public Register<0x40023820> {
            using USART1EN = Field<14, 1>;    // USART1 clock enable
            using SPI1EN = Field<12, 1>;    // SPI 1 clock enable
            using SDIOEN = Field<11, 1>;    // SDIO clock enable
            using ADC1EN = Field<9, 1>;    // ADC1 interface clock enable
            using TIM11EN = Field<4, 1>;    // TIM11 timer clock enable
            using TIM10EN = Field<3, 1>;    // TIM10 timer clock enable
            using TIM9EN = Field<2, 1>;    // TIM9 timer clock enable
            using SYSCFGEN = Field<0, 1>;    // System configuration controller clock enable
        };

        // APB1 peripheral clock enable register
        struct APB1ENR : public Register<0x40023824> {
            using COMPEN = Field<31, 1>;    // COMP interface clock enable
            using DACEN = Field<29, 1>;    // DAC interface clock enable
            using PWREN = Field<28, 1>;    // Power interface clock enable
            using USBEN = Field<23, 1>;    // USB clock enable
            using I2C2EN = Field<22, 1>;    // I2C 2 clock enable
            using I2C1EN = Field<21, 1>;    // I2C 1 clock enable
            using USART5EN = Field<20, 1>;    // UART 5 clock enable
            using USART4EN = Field<19, 1>;    // UART 4 clock enable
            using USART3EN = Field<18, 1>;    // USART 3 clock enable
            using USART2EN = Field<17, 1>;    // USART 2 clock enable
            using SPI3EN = Field<15, 1>;    // SPI 3 clock enable
            using SPI2EN = Field<14, 1>;    // SPI 2 clock enable
            using WWDGEN = Field<11, 1>;    // Window watchdog clock enable
            using LCDEN = Field<9, 1>;    // LCD clock enable
            using TIM7EN = Field<5, 1>;    // Timer 7 clock enable
            using TIM6EN = Field<4, 1>;    // Timer 6 clock enable
            using TIM5EN = Field<3, 1>;    // Timer 5 clock enable
            using TIM4EN = Field<2, 1>;    // Timer 4 clock enable
            using TIM3EN = Field<1, 1>;    // Timer 3 clock enable
            using TIM2EN = Field<0, 1>;    // Timer 2 clock enable
        };

        // AHB peripheral clock enable in low power mode register
        struct AHBLPENR : public Register<0x40023828> {
            using DMA2LPEN = Field<25, 1>;    // DMA2 clock enable during Sleep mode
            using DMA1LPEN = Field<24, 1>;    // DMA1 clock enable during Sleep mode
            using SRAMLPEN = Field<16, 1>;    // SRAM clock enable during Sleep mode
            using FLITFLPEN = Field<15, 1>;    // FLITF clock enable during Sleep mode
            using CRCLPEN = Field<12, 1>;    // CRC clock enable during Sleep mode
            using GPIOGLPEN = Field<7, 1>;    // IO port G clock enable during Sleep mode
            using GPIOFLPEN = Field<6, 1>;    // IO port F clock enable during Sleep mode
            using GPIOHLPEN = Field<5, 1>;    // IO port H clock enable during Sleep mode
            using GPIOELPEN = Field<4, 1>;    // IO port E clock enable during Sleep mode
            using GPIODLPEN = Field<3, 1>;    // IO port D clock enable during Sleep mode
            using GPIOCLPEN = Field<2, 1>;    // IO port C clock enable during Sleep mode
            using GPIOBLPEN = Field<1, 1>;    // IO port B clock enable during Sleep mode
            using GPIOALPEN = Field<0, 1>;    // IO port A clock enable during Sleep mode
        };

        // APB2 peripheral clock enable in low power mode register
        struct APB2LPENR : public Register<0x4002382c> {
            using USART1LPEN = Field<14, 1>;    // USART1 clock enable during Sleep mode
            using SPI1LPEN = Field<12, 1>;    // SPI 1 clock enable during Sleep mode
            using SDIOLPEN = Field<11, 1>;    // SDIO clock enable during Sleep mode
            using ADC1LPEN = Field<9, 1>;    // ADC1 interface clock enable during Sleep mode
            using TIM11LPEN = Field<4, 1>;    // TIM11 timer clock enable during Sleep mode
            using TIM10LPEN = Field<3, 1>;    // TIM10 timer clock enable during Sleep mode
            using TIM9LPEN = Field<2, 1>;    // TIM9 timer clock enable during Sleep mode
            using SYSCFGLPEN = Field<0, 1>;    // System configuration controller clock enable during Sleep mode
        };

        // APB1 peripheral clock enable in low power mode register
        struct APB1LPENR : public Register<0x40023830> {
            using COMPLPEN = Field<31, 1>;    // COMP interface clock enable during Sleep mode
            using DACLPEN = Field<29, 1>;    // DAC interface clock enable during Sleep mode
            using PWRLPEN = Field<28, 1>;    // Power interface clock enable during Sleep mode
            using USBLPEN = Field<23, 1>;    // USB clock enable during Sleep mode
            using I2C2LPEN = Field<22, 1>;    // I2C 2 clock enable during Sleep mode
            using I2C1LPEN = Field<21, 1>;    // I2C 1 clock enable during Sleep mode
            using USART3LPEN = Field<18, 1>;    // USART 3 clock enable during Sleep mode
            using USART2LPEN = Field<17, 1>;    // USART 2 clock enable during Sleep mode
            using SPI2LPEN = Field<14, 1>;    // SPI 2 clock enable during Sleep mode
            using WWDGLPEN = Field<11, 1>;    // Window watchdog clock enable during Sleep mode
            using LCDLPEN = Field<9, 1>;    // LCD clock enable during Sleep mode
            using TIM7LPEN = Field<5, 1>;    // Timer 7 clock enable during Sleep mode
            using TIM6LPEN = Field<4, 1>;    // Timer 6 clock enable during Sleep mode
            using TIM4LPEN = Field<2, 1>;    // Timer 4 clock enable during Sleep mode
            using TIM3LPEN = Field<1, 1>;    // Timer 3 clock enable during Sleep mode
            using TIM2LPEN = Field<0, 1>;    // Timer 2 clock enable during Sleep mode
        };

        // Control/status register
        struct CSR : public Register<0x40023834> {
            using LPWRSTF = Field<31, 1>;    // Low-power reset flag
            using WWDGRSTF = Field<30, 1>;    // Window watchdog reset flag
            using IWDGRSTF = Field<29, 1>;    // Independent watchdog reset flag
            using SFTRSTF = Field<28, 1>;    // Software reset flag
            using PORRSTF = Field<27, 1>;    // POR/PDR reset flag
            using PINRSTF = Field<26, 1>;    // PIN reset flag
            using RMVF = Field<24, 1>;    // Remove reset flag
            using RTCRST = Field<23, 1>;    // RTC software reset
            using RTCEN = Field<22, 1>;    // RTC clock enable
            using RTCSEL = Field<16, 2>;    // RTC and LCD clock source selection
            using LSEBYP = Field<10, 1>;    // External low-speed oscillator bypass
            using LSERDY = Field<9, 1>;    // External low-speed oscillator ready
            using LSEON = Field<8, 1>;    // External low-speed oscillator enable
            using LSIRDY = Field<1, 1>;    // Internal low-speed oscillator ready
            using LSION = Field<0, 1>;    // Internal low-speed oscillator enable
        };

    };

    // Routing interface
    struct RI {
        // RI input capture register
        struct ICR : public Register<0x40007c08> {
            using IC4 = Field<21, 1>;    // IC4
            using IC3 = Field<20, 1>;    // IC3
            using IC2 = Field<19, 1>;    // IC2
            using IC1 = Field<18, 1>;    // IC1
            using TIM = Field<16, 2>;    // Timer select bits
            using IC4IOS = Field<12, 4>;    // Input capture 4 select bits
            using IC3IOS = Field<8, 4>;    // Input capture 3 select bits
            using IC2IOS = Field<4, 4>;    // Input capture 2 select bits
            using IC1IOS = Field<0, 4>;    // Input capture 1 select bits
        };

        // RI analog switches control register 1
        struct ASCR1 : public Register<0x40007c0c> {
            using SCM = Field<31, 1>;    // Switch control mode
            using CH30GR11_4 = Field<30, 1>;    // Analog switch control
            using CH29GR11_3 = Field<29, 1>;    // Analog switch control
            using CH28GR11_2 = Field<28, 1>;    // Analog switch control
            using CH27GR11_1 = Field<27, 1>;    // Analog switch control
            using VCOMP = Field<26, 1>;    // ADC analog switch selection for internal node to comparator 1
            using CH25 = Field<25, 1>;    // Analog I/O switch control of channel CH25
            using CH24 = Field<24, 1>;    // Analog I/O switch control of channel CH24
            using CH23 = Field<23, 1>;    // Analog I/O switch control of channel CH23
            using CH22 = Field<22, 1>;    // Analog I/O switch control of channel CH22
            using CH21GR7_4 = Field<21, 1>;    // Analog switch control
            using CH20GR7_3 = Field<20, 1>;    // Analog switch control
            using CH19GR7_2 = Field<19, 1>;    // Analog switch control
            using CH18GR7_1 = Field<18, 1>;    // Analog switch control
            using CH31GR7_1 = Field<16, 1>;    // Analog switch control
            using CH15GR9_2 = Field<15, 1>;    // Analog switch control
            using CH14GR9_1 = Field<14, 1>;    // Analog switch control
            using CH13GR8_4 = Field<13, 1>;    // Analog switch control
            using CH12GR8_3 = Field<12, 1>;    // Analog switch control
            using CH11GR8_2 = Field<11, 1>;    // Analog switch control
            using CH10GR8_1 = Field<10, 1>;    // Analog switch control
            using CH9GR3_2 = Field<9, 1>;    // Analog switch control
            using CH8GR3_1 = Field<8, 1>;    // Analog switch control
            using CH7GR2_2 = Field<7, 1>;    // Analog switch control
            using CH6GR2_1 = Field<6, 1>;    // Analog switch control
            using COMP1_SW1 = Field<5, 1>;    // Comparator 1 analog switch
            using CH31GR11_5 = Field<4, 1>;    // Analog switch control
            using CH3GR1_4 = Field<3, 1>;    // Analog switch control
            using CH2GR1_3 = Field<2, 1>;    // Analog switch control
            using CH1GR1_2 = Field<1, 1>;    // Analog switch control
            using CH0GR1_1 = Field<0, 1>;    // Analog switch control
        };

        // RI analog switches control register 2
        struct ASCR2 : public Register<0x40007c10> {
            using GR5_4 = Field<29, 1>;    // GR5_4 analog switch control
            using GR6_4 = Field<28, 1>;    // GR6_4 analog switch control
            using GR6_3 = Field<27, 1>;    // GR6_3 analog switch control
            using GR7_7 = Field<26, 1>;    // GR7_7 analog switch control
            using GR7_6 = Field<25, 1>;    // GR7_6 analog switch control
            using GR7_5 = Field<24, 1>;    // GR7_5 analog switch control
            using GR2_5 = Field<23, 1>;    // GR2_5 analog switch control
            using GR2_4 = Field<22, 1>;    // GR2_4 analog switch control
            using GR2_3 = Field<21, 1>;    // GR2_3 analog switch control
            using GR9_4 = Field<20, 1>;    // GR9_4 analog switch control
            using GR9_3 = Field<19, 1>;    // GR9_3 analog switch control
            using GR3_5 = Field<18, 1>;    // GR3_5 analog switch control
            using GR3_4 = Field<17, 1>;    // GR3_4 analog switch control
            using GR3_3 = Field<16, 1>;    // GR3_3 analog switch control
            using GR4_3 = Field<11, 1>;    // GR4_3 analog switch control
            using GR4_2 = Field<10, 1>;    // GR4_2 analog switch control
            using GR4_1 = Field<9, 1>;    // GR4_1 analog switch control
            using GR5_3 = Field<8, 1>;    // GR5_3 analog switch control
            using GR5_2 = Field<7, 1>;    // GR5_2 analog switch control
            using GR5_1 = Field<6, 1>;    // GR5_1 analog switch control
            using GR6_2 = Field<5, 1>;    // GR6_2 analog switch control
            using GR6_1 = Field<4, 1>;    // GR6_1 analog switch control
            using GR10_4 = Field<3, 1>;    // GR10_4 analog switch control
            using GR10_3 = Field<2, 1>;    // GR10_3 analog switch control
            using GR10_2 = Field<1, 1>;    // GR10_2 analog switch control
            using GR10_1 = Field<0, 1>;    // GR10_1 analog switch control
        };

        // RI hysteresis control register 1
        struct HYSCR1 : public Register<0x40007c14> {
            using PB = Field<16, 16>;    // Port B hysteresis control on/off
            using PA = Field<0, 16>;    // Port A hysteresis control on/off
        };

        // RI hysteresis control register 2
        struct HYSCR2 : public Register<0x40007c18> {
            using PD = Field<16, 16>;    // Port D hysteresis control on/off
            using PC = Field<0, 16>;    // Port C hysteresis control on/off
        };

        // RI hysteresis control register 3
        struct HYSCR3 : public Register<0x40007c1c> {
            using PF = Field<16, 16>;    // Port F hysteresis control on/off
            using PE = Field<0, 16>;    // Port E hysteresis control on/off
        };

        // Hysteresis control register
        struct HYSCR4 : public Register<0x40007c20> {
            using PG = Field<0, 16>;    // Port G hysteresis control on/off
        };

    };

    // Real-time clock
    struct RTC {
        // time register
        struct TR : public Register<0x40002800> {
            using PM = Field<22, 1>;    // AM/PM notation
            using HT = Field<20, 2>;    // Hour tens in BCD format
            using HU = Field<16, 4>;    // Hour units in BCD format
            using MNT = Field<12, 3>;    // Minute tens in BCD format
            using MNU = Field<8, 4>;    // Minute units in BCD format
            using ST = Field<4, 3>;    // Second tens in BCD format
            using SU = Field<0, 4>;    // Second units in BCD format
        };

        // date register
        struct DR : public Register<0x40002804> {
            using YT = Field<20, 4>;    // Year tens in BCD format
            using YU = Field<16, 4>;    // Year units in BCD format
            using WDU = Field<13, 3>;    // Week day units
            using MT = Field<12, 1>;    // Month tens in BCD format
            using MU = Field<8, 4>;    // Month units in BCD format
            using DT = Field<4, 2>;    // Date tens in BCD format
            using DU = Field<0, 4>;    // Date units in BCD format
        };

        // control register
        struct CR : public Register<0x40002808> {
            using COE = Field<23, 1>;    // Calibration output enable
            using OSEL = Field<21, 2>;    // Output selection
            using POL = Field<20, 1>;    // Output polarity
            using COSEL = Field<19, 1>;    // Calibration output selection
            using BKP = Field<18, 1>;    // Backup
            using SUB1H = Field<17, 1>;    // Subtract 1 hour
            using ADD1H = Field<16, 1>;    // Add 1 hour
            using TSIE = Field<15, 1>;    // Time-stamp interrupt enable
            using WUTIE = Field<14, 1>;    // Wakeup timer interrupt enable
            using ALRBIE = Field<13, 1>;    // Alarm B interrupt enable
            using ALRAIE = Field<12, 1>;    // Alarm A interrupt enable
            using TSE = Field<11, 1>;    // Time stamp enable
            using WUTE = Field<10, 1>;    // Wakeup timer enable
            using ALRBE = Field<9, 1>;    // Alarm B enable
            using ALRAE = Field<8, 1>;    // Alarm A enable
            using DCE = Field<7, 1>;    // Coarse digital calibration enable
            using FMT = Field<6, 1>;    // Hour format
            using BYPSHAD = Field<5, 1>;    // Bypass the shadow registers
            using REFCKON = Field<4, 1>;    // Reference clock detection enable
            using TSEDGE = Field<3, 1>;    // Time-stamp event active edge
            using WCKSEL = Field<0, 3>;    // WCKSEL
        };

        // initialization and status register
        struct ISR : public Register<0x4000280c> {
            using RECALPF = Field<16, 1>;    // Recalibration pending Flag
            using TAMP3F = Field<15, 1>;    // TAMPER3 detection flag
            using TAMP2F = Field<14, 1>;    // TAMPER2 detection flag
            using TAMP1F = Field<13, 1>;    // Tamper detection flag
            using TSOVF = Field<12, 1>;    // Timestamp overflow flag
            using TSF = Field<11, 1>;    // Timestamp flag
            using WUTF = Field<10, 1>;    // Wakeup timer flag
            using ALRBF = Field<9, 1>;    // Alarm B flag
            using ALRAF = Field<8, 1>;    // Alarm A flag
            using INIT = Field<7, 1>;    // Initialization mode
            using INITF = Field<6, 1>;    // Initialization flag
            using RSF = Field<5, 1>;    // Registers synchronization flag
            using INITS = Field<4, 1>;    // Initialization status flag
            using SHPF = Field<3, 1>;    // Shift operation pending
            using WUTWF = Field<2, 1>;    // Wakeup timer write flag
            using ALRBWF = Field<1, 1>;    // Alarm B write flag
            using ALRAWF = Field<0, 1>;    // Alarm A write flag
        };

        // prescaler register
        struct PRER : public Register<0x40002810> {
            using PREDIV_A = Field<16, 7>;    // Asynchronous prescaler factor
            using PREDIV_S = Field<0, 15>;    // Synchronous prescaler factor
        };

        // wakeup timer register
        struct WUTR : public Register<0x40002814> {
            using WUT = Field<0, 16>;    // Wakeup auto-reload value bits
        };

        // calibration register
        struct CALIBR : public Register<0x40002818> {
            using DCS = Field<7, 1>;    // Digital calibration sign
            using DC = Field<0, 5>;    // Digital calibration
        };

        // alarm A register
        struct ALRMAR : public Register<0x4000281c> {
            using MSK4 = Field<31, 1>;    // Alarm A date mask
            using WDSEL = Field<30, 1>;    // Week day selection
            using DT = Field<28, 2>;    // Date tens in BCD format.
            using DU = Field<24, 4>;    // Date units or day in BCD format.
            using MSK3 = Field<23, 1>;    // Alarm A hours mask
            using PM = Field<22, 1>;    // AM/PM notation
            using HT = Field<20, 2>;    // Hour tens in BCD format.
            using HU = Field<16, 4>;    // Hour units in BCD format.
            using MSK2 = Field<15, 1>;    // Alarm A minutes mask
            using MNT = Field<12, 3>;    // Minute tens in BCD format.
            using MNU = Field<8, 4>;    // Minute units in BCD format.
            using MSK1 = Field<7, 1>;    // Alarm A seconds mask
            using ST = Field<4, 3>;    // Second tens in BCD format.
            using SU = Field<0, 4>;    // Second units in BCD format.
        };

        // alarm B register
        struct ALRMBR : public Register<0x40002820> {
            using MSK4 = Field<31, 1>;    // Alarm B date mask
            using WDSEL = Field<30, 1>;    // Week day selection
            using DT = Field<28, 2>;    // Date tens in BCD format
            using DU = Field<24, 4>;    // Date units or day in BCD format
            using MSK3 = Field<23, 1>;    // Alarm B hours mask
            using PM = Field<22, 1>;    // AM/PM notation
            using HT = Field<20, 2>;    // Hour tens in BCD format
            using HU = Field<16, 4>;    // Hour units in BCD format
            using MSK2 = Field<15, 1>;    // Alarm B minutes mask
            using MNT = Field<12, 3>;    // Minute tens in BCD format
            using MNU = Field<8, 4>;    // Minute units in BCD format
            using MSK1 = Field<7, 1>;    // Alarm B seconds mask
            using ST = Field<4, 3>;    // Second tens in BCD format
            using SU = Field<0, 4>;    // Second units in BCD format
        };

        // write protection register
        struct WPR : public Register<0x40002824> {
            using KEY = Field<0, 8>;    // Write protection key
        };

        // sub second register
        struct SSR : public Register<0x40002828> {
            using SS = Field<0, 16>;    // Sub second value
        };

        // shift control register
        struct SHIFTR : public Register<0x4000282c> {
            using ADD1S = Field<31, 1>;    // ADD1S
            using SUBFS = Field<0, 15>;    // Subtract a fraction of a second
        };

        // TSTR
        struct TSTR : public Register<0x40002830> {
            using PM = Field<22, 1>;    // AM/PM notation
            using HT = Field<20, 2>;    // Hour tens in BCD format.
            using HU = Field<16, 4>;    // Hour units in BCD format.
            using MNT = Field<12, 3>;    // Minute tens in BCD format.
            using MNU = Field<8, 4>;    // Minute units in BCD format.
            using ST = Field<4, 3>;    // Second tens in BCD format.
            using SU = Field<0, 4>;    // Second units in BCD format.
        };

        // time stamp date register
        struct TSDR : public Register<0x40002834> {
            using WDU = Field<13, 3>;    // Week day units
            using MT = Field<12, 1>;    // Month tens in BCD format
            using MU = Field<8, 4>;    // Month units in BCD format
            using DT = Field<4, 2>;    // Date tens in BCD format
            using DU = Field<0, 4>;    // Date units in BCD format
        };

        // timestamp sub second register
        struct TSSSR : public Register<0x40002838> {
            using SS = Field<0, 16>;    // RTC timestamp subsecond field
        };

        // calibration register
        struct CALR : public Register<0x4000283c> {
            using CALP = Field<15, 1>;    // Use an 8-second calibration cycle period
            using CALW8 = Field<14, 1>;    // Use a 16-second calibration cycle period
            using CALW16 = Field<13, 1>;    // CALW16
            using CALM = Field<0, 9>;    // Calibration minus
        };

        // tamper and alternate function configuration register
        struct TAFCR : public Register<0x40002840> {
            using ALARMOUTTYPE = Field<18, 1>;    // AFO_ALARM output type
            using TAMPPUDIS = Field<15, 1>;    // TAMPER pull-up disable
            using TAMPPRCH = Field<13, 2>;    // Tamper precharge duration
            using TAMPFLT = Field<11, 2>;    // Tamper filter count
            using TAMPFREQ = Field<8, 3>;    // Tamper sampling frequency
            using TAMPTS = Field<7, 1>;    // Activate timestamp on tamper detection event
            using TAMP3TRG = Field<6, 1>;    // TAMPER1 mapping
            using TAMP3E = Field<5, 1>;    // TIMESTAMP mapping
            using TAMP2TRG = Field<4, 1>;    // Active level for tamper 2
            using TAMP2E = Field<3, 1>;    // Tamper 2 detection enable
            using TAMPIE = Field<2, 1>;    // Tamper interrupt enable
            using TAMP1ETRG = Field<1, 1>;    // Active level for tamper 1
            using TAMP1E = Field<0, 1>;    // Tamper 1 detection enable
        };

        // alarm A sub second register
        struct ALRMASSR : public Register<0x40002844> {
            using MASKSS = Field<24, 4>;    // Mask the most-significant bits starting at this bit
            using SS = Field<0, 15>;    // Sub seconds value
        };

        // alarm B sub second register
        struct ALRMBSSR : public Register<0x40002848> {
            using MASKSS = Field<24, 4>;    // Mask the most-significant bits starting at this bit
            using SS = Field<0, 15>;    // Sub seconds value
        };

        // backup register
        struct BKP0R : public Register<0x40002850> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP1R : public Register<0x40002854> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP2R : public Register<0x40002858> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP3R : public Register<0x4000285c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP4R : public Register<0x40002860> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP5R : public Register<0x40002864> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP6R : public Register<0x40002868> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP7R : public Register<0x4000286c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP8R : public Register<0x40002870> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP9R : public Register<0x40002874> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP10R : public Register<0x40002878> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP11R : public Register<0x4000287c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP12R : public Register<0x40002880> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP13R : public Register<0x40002884> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP14R : public Register<0x40002888> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP15R : public Register<0x4000288c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP16R : public Register<0x40002890> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP17R : public Register<0x40002894> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP18R : public Register<0x40002898> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP19R : public Register<0x4000289c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP20R : public Register<0x400028a0> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP21R : public Register<0x400028a4> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP22R : public Register<0x400028a8> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP23R : public Register<0x400028ac> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP24R : public Register<0x400028b0> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP25R : public Register<0x400028b4> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP26R : public Register<0x400028b8> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP27R : public Register<0x400028bc> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP28R : public Register<0x400028c0> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP29R : public Register<0x400028c4> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP30R : public Register<0x400028c8> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP31R : public Register<0x400028cc> {
            using BKP = Field<0, 32>;    // BKP
        };

    };

    // Secure digital input/output interface
    struct SDIO {
        // power control register
        struct POWER : public Register<0x40012c00> {
            using PWRCTRL = Field<0, 2>;    // Power supply control bits.
        };

        // SDI clock control register
        struct CLKCR : public Register<0x40012c04> {
            using HWFC_EN = Field<14, 1>;    // HW Flow Control enable
            using NEGEDGE = Field<13, 1>;    // SDIO_CK dephasing selection bit
            using WIDBUS = Field<11, 2>;    // Wide bus mode enable bit
            using BYPASS = Field<10, 1>;    // Clock divider bypass enable bit
            using PWRSAV = Field<9, 1>;    // Power saving configuration bit
            using CLKEN = Field<8, 1>;    // Clock enable bit
            using CLKDIV = Field<0, 8>;    // Clock divide factor
        };

        // argument register
        struct ARG : public Register<0x40012c08> {
            using CMDARG = Field<0, 32>;    // Command argument
        };

        // command register
        struct CMD : public Register<0x40012c0c> {
            using CE_ATACMD = Field<14, 1>;    // CE-ATA command
            using nIEN = Field<13, 1>;    // not Interrupt Enable
            using ENCMDcompl = Field<12, 1>;    // Enable CMD completion
            using SDIOSuspend = Field<11, 1>;    // SD I/O suspend command
            using CPSMEN = Field<10, 1>;    // Command path state machine (CPSM) Enable bit
            using WAITPEND = Field<9, 1>;    // CPSM Waits for ends of data transfer (CmdPend internal signal).
            using WAITINT = Field<8, 1>;    // CPSM waits for interrupt request
            using WAITRESP = Field<6, 2>;    // Wait for response bits
            using CMDINDEX = Field<0, 6>;    // Command index
        };

        // command response register
        struct RESPCMD : public Register<0x40012c10> {
            using Field = Field<0, 6>;    // Response command index
        };

        // response 1..4 register
        struct RESP1 : public Register<0x40012c14> {
            using CARDSTATUS1 = Field<0, 32>;    // see Table 133.
        };

        // response 1..4 register
        struct RESP2 : public Register<0x40012c18> {
            using CARDSTATUS2 = Field<0, 32>;    // see Table 133.
        };

        // response 1..4 register
        struct RESP3 : public Register<0x40012c1c> {
            using CARDSTATUS3 = Field<0, 32>;    // see Table 133.
        };

        // response 1..4 register
        struct RESP4 : public Register<0x40012c20> {
            using CARDSTATUS4 = Field<0, 32>;    // see Table 133.
        };

        // data timer register
        struct DTIMER : public Register<0x40012c24> {
            using DATATIME = Field<0, 32>;    // Data timeout period
        };

        // data length register
        struct DLEN : public Register<0x40012c28> {
            using DATALENGTH = Field<0, 25>;    // Data length value
        };

        // data control register
        struct DCTRL : public Register<0x40012c2c> {
            using SDIOEN = Field<11, 1>;    // SD I/O enable functions
            using RWMOD = Field<10, 1>;    // Read wait mode
            using RWSTOP = Field<9, 1>;    // Read wait stop
            using RWSTART = Field<8, 1>;    // Read wait start
            using DBLOCKSIZE = Field<4, 4>;    // Data block size
            using DMAEN = Field<3, 1>;    // DMA enable bit
            using DTMODE = Field<2, 1>;    // Data transfer mode selection 1: Stream or SDIO multibyte data transfer.
            using DTDIR = Field<1, 1>;    // Data transfer direction selection
            using DTEN = Field<0, 1>;    // Data transfer enabled bit
        };

        // data counter register
        struct DCOUNT : public Register<0x40012c30> {
            using DATACOUNT = Field<0, 25>;    // Data count value
        };

        // status register
        struct STA : public Register<0x40012c34> {
            using CEATAEND = Field<23, 1>;    // CE-ATA command completion signal received for CMD61
            using SDIOIT = Field<22, 1>;    // SDIO interrupt received
            using RXDAVL = Field<21, 1>;    // Data available in receive FIFO
            using TXDAVL = Field<20, 1>;    // Data available in transmit FIFO
            using RXFIFOE = Field<19, 1>;    // Receive FIFO empty
            using TXFIFOE = Field<18, 1>;    // Transmit FIFO empty
            using RXFIFOF = Field<17, 1>;    // Receive FIFO full
            using TXFIFOF = Field<16, 1>;    // Transmit FIFO full
            using RXFIFOHF = Field<15, 1>;    // Receive FIFO half full: there are at least 8 words in the FIFO
            using TXFIFOHE = Field<14, 1>;    // Transmit FIFO half empty: at least 8 words can be written into the FIFO
            using RXACT = Field<13, 1>;    // Data receive in progress
            using TXACT = Field<12, 1>;    // Data transmit in progress
            using CMDACT = Field<11, 1>;    // Command transfer in progress
            using DBCKEND = Field<10, 1>;    // Data block sent/received (CRC check passed)
            using STBITERR = Field<9, 1>;    // Start bit not detected on all data signals in wide bus mode
            using DATAEND = Field<8, 1>;    // Data end (data counter, SDIDCOUNT, is zero)
            using CMDSENT = Field<7, 1>;    // Command sent (no response required)
            using CMDREND = Field<6, 1>;    // Command response received (CRC check passed)
            using RXOVERR = Field<5, 1>;    // Received FIFO overrun error
            using TXUNDERR = Field<4, 1>;    // Transmit FIFO underrun error
            using DTIMEOUT = Field<3, 1>;    // Data timeout
            using CTIMEOUT = Field<2, 1>;    // Command response timeout
            using DCRCFAIL = Field<1, 1>;    // Data block sent/received (CRC check failed)
            using CCRCFAIL = Field<0, 1>;    // Command response received (CRC check failed)
        };

        // interrupt clear register
        struct ICR : public Register<0x40012c38> {
            using CEATAENDC = Field<23, 1>;    // CEATAEND flag clear bit
            using SDIOITC = Field<22, 1>;    // SDIOIT flag clear bit
            using DBCKENDC = Field<10, 1>;    // DBCKEND flag clear bit
            using STBITERRC = Field<9, 1>;    // STBITERR flag clear bit
            using DATAENDC = Field<8, 1>;    // DATAEND flag clear bit
            using CMDSENTC = Field<7, 1>;    // CMDSENT flag clear bit
            using CMDRENDC = Field<6, 1>;    // CMDREND flag clear bit
            using RXOVERRC = Field<5, 1>;    // RXOVERR flag clear bit
            using TXUNDERRC = Field<4, 1>;    // TXUNDERR flag clear bit
            using DTIMEOUTC = Field<3, 1>;    // DTIMEOUT flag clear bit
            using CTIMEOUTC = Field<2, 1>;    // CTIMEOUT flag clear bit
            using DCRCFAILC = Field<1, 1>;    // DCRCFAIL flag clear bit
            using CCRCFAILC = Field<0, 1>;    // CCRCFAIL flag clear bit
        };

        // mask register
        struct MASK : public Register<0x40012c3c> {
            using CEATAENDIE = Field<23, 1>;    // CE-ATA command completion signal received interrupt enable
            using SDIOITIE = Field<22, 1>;    // SDIO mode interrupt received interrupt enable
            using RXDAVLIE = Field<21, 1>;    // Data available in Rx FIFO interrupt enable
            using TXDAVLIE = Field<20, 1>;    // Data available in Tx FIFO interrupt enable
            using RXFIFOEIE = Field<19, 1>;    // Rx FIFO empty interrupt enable
            using TXFIFOEIE = Field<18, 1>;    // Tx FIFO empty interrupt enable
            using RXFIFOFIE = Field<17, 1>;    // Rx FIFO full interrupt enable
            using TXFIFOFIE = Field<16, 1>;    // Tx FIFO full interrupt enable
            using RXFIFOHFIE = Field<15, 1>;    // Rx FIFO half full interrupt enable
            using TXFIFOHEIE = Field<14, 1>;    // Tx FIFO half empty interrupt enable
            using RXACTIE = Field<13, 1>;    // Data receive acting interrupt enable
            using TXACTIE = Field<12, 1>;    // Data transmit acting interrupt enable
            using CMDACTIE = Field<11, 1>;    // Command acting interrupt enable
            using DBCKENDIE = Field<10, 1>;    // Data block end interrupt enable
            using STBITERRIE = Field<9, 1>;    // Start bit error interrupt enable
            using DATAENDIE = Field<8, 1>;    // Data end interrupt enable
            using CMDSENTIE = Field<7, 1>;    // Command sent interrupt enable
            using CMDRENDIE = Field<6, 1>;    // Command response received interrupt enable
            using RXOVERRIE = Field<5, 1>;    // Rx FIFO overrun error interrupt enable
            using TXUNDERRIE = Field<4, 1>;    // Tx FIFO underrun error interrupt enable
            using DTIMEOUTIE = Field<3, 1>;    // Data timeout interrupt enable
            using CTIMEOUTIE = Field<2, 1>;    // Command timeout interrupt enable
            using DCRCFAILIE = Field<1, 1>;    // Data CRC fail interrupt enable
            using CCRCFAILIE = Field<0, 1>;    // Command CRC fail interrupt enable
        };

        // FIFO counter register
        struct FIFOCNT : public Register<0x40012c48> {
            using FIFOCOUNT = Field<0, 24>;    // Remaining number of words to be written to or read from the FIFO.
        };

        // data FIFO register
        struct FIFO : public Register<0x40012c80> {
            using FIF0Data = Field<0, 32>;    // FIF0Data
        };

    };

    // Serial peripheral interface
    struct SPI1 {
        // control register 1
        struct CR1 : public Register<0x40013000> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using DFF = Field<11, 1>;    // Data frame format
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40013004> {
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using FRF = Field<4, 1>;    // Frame format
            using SSOE = Field<2, 1>;    // SS output enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
        };

        // status register
        struct SR : public Register<0x40013008> {
            using TIFRFE = Field<8, 1>;    // TI frame format error
            using BSY = Field<7, 1>;    // Busy flag
            using OVR = Field<6, 1>;    // Overrun flag
            using MODF = Field<5, 1>;    // Mode fault
            using CRCERR = Field<4, 1>;    // CRC error flag
            using UDR = Field<3, 1>;    // Underrun flag
            using CHSIDE = Field<2, 1>;    // Channel side
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using RXNE = Field<0, 1>;    // Receive buffer not empty
        };

        // data register
        struct DR : public Register<0x4001300c> {
            using Field = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40013010> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public Register<0x40013014> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public Register<0x40013018> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

        // I2S configuration register
        struct I2SCFGR : public Register<0x4001301c> {
            using I2SMOD = Field<11, 1>;    // I2S mode selection
            using I2SE = Field<10, 1>;    // I2S Enable
            using I2SCFG = Field<8, 2>;    // I2S configuration mode
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using CKPOL = Field<3, 1>;    // Steady state clock polarity
            using DATLEN = Field<1, 2>;    // Data length to be transferred
            using CHLEN = Field<0, 1>;    // Channel length (number of bits per audio channel)
        };

        // I2S prescaler register
        struct I2SPR : public Register<0x40013020> {
            using MCKOE = Field<9, 1>;    // Master clock output enable
            using ODD = Field<8, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<0, 8>;    // I2S Linear prescaler
        };

    };

    // Serial peripheral interface
    struct SPI2 {
        // control register 1
        struct CR1 : public Register<0x40003800> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using DFF = Field<11, 1>;    // Data frame format
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40003804> {
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using FRF = Field<4, 1>;    // Frame format
            using SSOE = Field<2, 1>;    // SS output enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
        };

        // status register
        struct SR : public Register<0x40003808> {
            using TIFRFE = Field<8, 1>;    // TI frame format error
            using BSY = Field<7, 1>;    // Busy flag
            using OVR = Field<6, 1>;    // Overrun flag
            using MODF = Field<5, 1>;    // Mode fault
            using CRCERR = Field<4, 1>;    // CRC error flag
            using UDR = Field<3, 1>;    // Underrun flag
            using CHSIDE = Field<2, 1>;    // Channel side
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using RXNE = Field<0, 1>;    // Receive buffer not empty
        };

        // data register
        struct DR : public Register<0x4000380c> {
            using Field = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40003810> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public Register<0x40003814> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public Register<0x40003818> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

        // I2S configuration register
        struct I2SCFGR : public Register<0x4000381c> {
            using I2SMOD = Field<11, 1>;    // I2S mode selection
            using I2SE = Field<10, 1>;    // I2S Enable
            using I2SCFG = Field<8, 2>;    // I2S configuration mode
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using CKPOL = Field<3, 1>;    // Steady state clock polarity
            using DATLEN = Field<1, 2>;    // Data length to be transferred
            using CHLEN = Field<0, 1>;    // Channel length (number of bits per audio channel)
        };

        // I2S prescaler register
        struct I2SPR : public Register<0x40003820> {
            using MCKOE = Field<9, 1>;    // Master clock output enable
            using ODD = Field<8, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<0, 8>;    // I2S Linear prescaler
        };

    };

    // Serial peripheral interface
    struct SPI3 {
        // control register 1
        struct CR1 : public Register<0x40003c00> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using DFF = Field<11, 1>;    // Data frame format
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40003c04> {
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using FRF = Field<4, 1>;    // Frame format
            using SSOE = Field<2, 1>;    // SS output enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
        };

        // status register
        struct SR : public Register<0x40003c08> {
            using TIFRFE = Field<8, 1>;    // TI frame format error
            using BSY = Field<7, 1>;    // Busy flag
            using OVR = Field<6, 1>;    // Overrun flag
            using MODF = Field<5, 1>;    // Mode fault
            using CRCERR = Field<4, 1>;    // CRC error flag
            using UDR = Field<3, 1>;    // Underrun flag
            using CHSIDE = Field<2, 1>;    // Channel side
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using RXNE = Field<0, 1>;    // Receive buffer not empty
        };

        // data register
        struct DR : public Register<0x40003c0c> {
            using Field = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40003c10> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public Register<0x40003c14> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public Register<0x40003c18> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

        // I2S configuration register
        struct I2SCFGR : public Register<0x40003c1c> {
            using I2SMOD = Field<11, 1>;    // I2S mode selection
            using I2SE = Field<10, 1>;    // I2S Enable
            using I2SCFG = Field<8, 2>;    // I2S configuration mode
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using CKPOL = Field<3, 1>;    // Steady state clock polarity
            using DATLEN = Field<1, 2>;    // Data length to be transferred
            using CHLEN = Field<0, 1>;    // Channel length (number of bits per audio channel)
        };

        // I2S prescaler register
        struct I2SPR : public Register<0x40003c20> {
            using MCKOE = Field<9, 1>;    // Master clock output enable
            using ODD = Field<8, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<0, 8>;    // I2S Linear prescaler
        };

    };

    // System configuration controller
    struct SYSCFG {
        // memory remap register
        struct MEMRMP : public Register<0x40010000> {
            using MEM_MODE = Field<0, 2>;    // MEM_MODE
            using BOOT_MODE = Field<8, 2>;    // BOOT_MODE
        };

        // peripheral mode configuration register
        struct PMC : public Register<0x40010004> {
            using USB_PU = Field<0, 1>;    // USB pull-up
            using LCD_CAPA = Field<1, 5>;    // decoupling capacitance connection
        };

        // external interrupt configuration register 1
        struct EXTICR1 : public Register<0x40010008> {
            using EXTI3 = Field<12, 4>;    // EXTI x configuration (x = 0 to 3)
            using EXTI2 = Field<8, 4>;    // EXTI x configuration (x = 0 to 3)
            using EXTI1 = Field<4, 4>;    // EXTI x configuration (x = 0 to 3)
            using EXTI0 = Field<0, 4>;    // EXTI x configuration (x = 0 to 3)
        };

        // external interrupt configuration register 2
        struct EXTICR2 : public Register<0x4001000c> {
            using EXTI7 = Field<12, 4>;    // EXTI x configuration (x = 4 to 7)
            using EXTI6 = Field<8, 4>;    // EXTI x configuration (x = 4 to 7)
            using EXTI5 = Field<4, 4>;    // EXTI x configuration (x = 4 to 7)
            using EXTI4 = Field<0, 4>;    // EXTI x configuration (x = 4 to 7)
        };

        // external interrupt configuration register 3
        struct EXTICR3 : public Register<0x40010010> {
            using EXTI11 = Field<12, 4>;    // EXTI x configuration (x = 8 to 11)
            using EXTI10 = Field<8, 4>;    // EXTI10
            using EXTI9 = Field<4, 4>;    // EXTI x configuration (x = 8 to 11)
            using EXTI8 = Field<0, 4>;    // EXTI x configuration (x = 8 to 11)
        };

        // external interrupt configuration register 4
        struct EXTICR4 : public Register<0x40010014> {
            using EXTI15 = Field<12, 4>;    // EXTI x configuration (x = 12 to 15)
            using EXTI14 = Field<8, 4>;    // EXTI14
            using EXTI13 = Field<4, 4>;    // EXTI13
            using EXTI12 = Field<0, 4>;    // EXTI12
        };

    };

    // General-purpose timers
    struct TIM10 {
        // control register 1
        struct CR1 : public Register<0x40010c00> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // Interrupt enable register
        struct DIER : public Register<0x40010c0c> {
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40010c10> {
            using CC1OF = Field<9, 1>;    // Capture/compare 1 overcapture flag
            using CC1IF = Field<1, 1>;    // Capture/Compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40010c14> {
            using CC1G = Field<1, 1>;    // Capture/Compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register
        struct CCMR1_Output : public Register<0x40010c18> {
            using OC1M = Field<4, 3>;    // Output compare 1 mode
            using OC1PE = Field<3, 1>;    // Output compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40010c18> {
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40010c20> {
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 complementary output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40010c24> {
            using Field = Field<0, 16>;    // TIM10 counter
        };

        // prescaler
        struct PSC : public Register<0x40010c28> {
            using Field = Field<0, 16>;    // TIM9 prescaler
        };

        // auto-reload register
        struct ARR : public Register<0x40010c2c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40010c34> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // option register
        struct OR : public Register<0x40010c50> {
            using TI1_RMP = Field<0, 2>;    // TIM11 Input 1 remapping capability
        };

    };

    // General-purpose timers
    struct TIM11 {
        // control register 1
        struct CR1 : public Register<0x40011000> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // Interrupt enable register
        struct DIER : public Register<0x4001100c> {
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40011010> {
            using CC1OF = Field<9, 1>;    // Capture/compare 1 overcapture flag
            using CC1IF = Field<1, 1>;    // Capture/Compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40011014> {
            using CC1G = Field<1, 1>;    // Capture/Compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register
        struct CCMR1_Output : public Register<0x40011018> {
            using OC1M = Field<4, 3>;    // Output compare 1 mode
            using OC1PE = Field<3, 1>;    // Output compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40011018> {
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40011020> {
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 complementary output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40011024> {
            using Field = Field<0, 16>;    // TIM10 counter
        };

        // prescaler
        struct PSC : public Register<0x40011028> {
            using Field = Field<0, 16>;    // TIM9 prescaler
        };

        // auto-reload register
        struct ARR : public Register<0x4001102c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40011034> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // option register
        struct OR : public Register<0x40011050> {
            using TI1_RMP = Field<0, 2>;    // TIM11 Input 1 remapping capability
        };

    };

    // General-purpose timers
    struct TIM2 {
        // control register 1
        struct CR1 : public Register<0x40000000> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000004> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000008> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using OCCS = Field<3, 1>;    // OCREF clear selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // Interrupt enable register
        struct DIER : public Register<0x4000000c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000010> {
            using CC4OF = Field<12, 1>;    // Capture/compare 1 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/Compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40000014> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1
        struct CCMR1_Output : public Register<0x40000018> {
            using OC2CE = Field<15, 1>;    // Output compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output compare 2 mode
            using OC2PE = Field<11, 1>;    // Output compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output compare 2 fast enable
            using CC2S = Field<8, 1>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output compare 1 mode
            using OC1PE = Field<3, 1>;    // Output compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000018> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2
        struct CCMR2_Output : public Register<0x4000001c> {
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 1>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000001c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000020> {
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 output Polarity
            using CC4P = Field<13, 1>;    // Capture/Compare 4 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 complementary output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000024> {
            using Field = Field<0, 16>;    // TIM2 counter
        };

        // prescaler
        struct PSC : public Register<0x40000028> {
            using Field = Field<0, 16>;    // TIM2 prescaler
        };

        // auto-reload register
        struct ARR : public Register<0x4000002c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000034> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 1
        struct CCR2 : public Register<0x40000038> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // capture/compare register 1
        struct CCR3 : public Register<0x4000003c> {
            using CCR1 = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 1
        struct CCR4 : public Register<0x40000040> {
            using Field = Field<0, 16>;    // Capture/Compare 4 value
        };

        // DMA control register
        struct DCR : public Register<0x40000048> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4000004c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

    };

    // General-purpose timers
    struct TIM3 {
        // control register 1
        struct CR1 : public Register<0x40000400> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000404> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000408> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using OCCS = Field<3, 1>;    // OCREF clear selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // Interrupt enable register
        struct DIER : public Register<0x4000040c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000410> {
            using CC4OF = Field<12, 1>;    // Capture/compare 1 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/Compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40000414> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1
        struct CCMR1_Output : public Register<0x40000418> {
            using OC2CE = Field<15, 1>;    // Output compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output compare 2 mode
            using OC2PE = Field<11, 1>;    // Output compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output compare 2 fast enable
            using CC2S = Field<8, 1>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output compare 1 mode
            using OC1PE = Field<3, 1>;    // Output compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000418> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2
        struct CCMR2_Output : public Register<0x4000041c> {
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 1>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000041c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000420> {
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 output Polarity
            using CC4P = Field<13, 1>;    // Capture/Compare 4 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 complementary output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000424> {
            using Field = Field<0, 16>;    // TIM2 counter
        };

        // prescaler
        struct PSC : public Register<0x40000428> {
            using Field = Field<0, 16>;    // TIM2 prescaler
        };

        // auto-reload register
        struct ARR : public Register<0x4000042c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000434> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 1
        struct CCR2 : public Register<0x40000438> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // capture/compare register 1
        struct CCR3 : public Register<0x4000043c> {
            using CCR1 = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 1
        struct CCR4 : public Register<0x40000440> {
            using Field = Field<0, 16>;    // Capture/Compare 4 value
        };

        // DMA control register
        struct DCR : public Register<0x40000448> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4000044c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

    };

    // General-purpose timers
    struct TIM4 {
        // control register 1
        struct CR1 : public Register<0x40000800> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000804> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000808> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using OCCS = Field<3, 1>;    // OCREF clear selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // Interrupt enable register
        struct DIER : public Register<0x4000080c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000810> {
            using CC4OF = Field<12, 1>;    // Capture/compare 1 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/Compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40000814> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1
        struct CCMR1_Output : public Register<0x40000818> {
            using OC2CE = Field<15, 1>;    // Output compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output compare 2 mode
            using OC2PE = Field<11, 1>;    // Output compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output compare 2 fast enable
            using CC2S = Field<8, 1>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output compare 1 mode
            using OC1PE = Field<3, 1>;    // Output compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000818> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2
        struct CCMR2_Output : public Register<0x4000081c> {
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 1>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000081c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000820> {
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 output Polarity
            using CC4P = Field<13, 1>;    // Capture/Compare 4 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 complementary output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000824> {
            using Field = Field<0, 16>;    // TIM2 counter
        };

        // prescaler
        struct PSC : public Register<0x40000828> {
            using Field = Field<0, 16>;    // TIM2 prescaler
        };

        // auto-reload register
        struct ARR : public Register<0x4000082c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000834> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 1
        struct CCR2 : public Register<0x40000838> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // capture/compare register 1
        struct CCR3 : public Register<0x4000083c> {
            using CCR1 = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 1
        struct CCR4 : public Register<0x40000840> {
            using Field = Field<0, 16>;    // Capture/Compare 4 value
        };

        // DMA control register
        struct DCR : public Register<0x40000848> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4000084c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

    };

    // General-purpose timers
    struct TIM5 {
        // control register 1
        struct CR1 : public Register<0x40000c00> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000c04> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000c08> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using OCCS = Field<3, 1>;    // OCREF clear selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // Interrupt enable register
        struct DIER : public Register<0x40000c0c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000c10> {
            using CC4OF = Field<12, 1>;    // Capture/compare 1 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/Compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40000c14> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1
        struct CCMR1_Output : public Register<0x40000c18> {
            using OC2CE = Field<15, 1>;    // Output compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output compare 2 mode
            using OC2PE = Field<11, 1>;    // Output compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output compare 2 fast enable
            using CC2S = Field<8, 1>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output compare 1 mode
            using OC1PE = Field<3, 1>;    // Output compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000c18> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2
        struct CCMR2_Output : public Register<0x40000c1c> {
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 1>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x40000c1c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000c20> {
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 output Polarity
            using CC4P = Field<13, 1>;    // Capture/Compare 4 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 complementary output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000c24> {
            using Field = Field<0, 16>;    // TIM2 counter
        };

        // prescaler
        struct PSC : public Register<0x40000c28> {
            using Field = Field<0, 16>;    // TIM2 prescaler
        };

        // auto-reload register
        struct ARR : public Register<0x40000c2c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000c34> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 1
        struct CCR2 : public Register<0x40000c38> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // capture/compare register 1
        struct CCR3 : public Register<0x40000c3c> {
            using CCR1 = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 1
        struct CCR4 : public Register<0x40000c40> {
            using Field = Field<0, 16>;    // Capture/Compare 4 value
        };

        // DMA control register
        struct DCR : public Register<0x40000c48> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x40000c4c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

    };

    // Basic timers
    struct TIM6 {
        // TIM6 control register 1
        struct CR1 : public Register<0x40001000> {
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // TIM6 control register 2
        struct CR2 : public Register<0x40001004> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // TIM6 DMA/Interrupt enable register
        struct DIER : public Register<0x4000100c> {
            using UDE = Field<8, 1>;    // Update DMA request enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // TIM6 status register
        struct SR : public Register<0x40001010> {
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // TIM6 event generation register
        struct EGR : public Register<0x40001014> {
            using UG = Field<0, 1>;    // Update generation
        };

        // TIM6 counter
        struct CNT : public Register<0x40001024> {
            using Field = Field<0, 16>;    // CNT
        };

        // TIM6 prescaler
        struct PSC : public Register<0x40001028> {
            using Field = Field<0, 16>;    // Prescaler valueThe counter clock frequency CK_CNT is equal to fCK_PSC / (PSC[15:0] + 1).
        };

        // TIM6 auto-reload register
        struct ARR : public Register<0x4000102c> {
            using Field = Field<0, 16>;    // Prescaler value
        };

    };

    // Basic timers
    struct TIM7 {
        // TIM6 control register 1
        struct CR1 : public Register<0x40001400> {
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // TIM6 control register 2
        struct CR2 : public Register<0x40001404> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // TIM6 DMA/Interrupt enable register
        struct DIER : public Register<0x4000140c> {
            using UDE = Field<8, 1>;    // Update DMA request enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // TIM6 status register
        struct SR : public Register<0x40001410> {
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // TIM6 event generation register
        struct EGR : public Register<0x40001414> {
            using UG = Field<0, 1>;    // Update generation
        };

        // TIM6 counter
        struct CNT : public Register<0x40001424> {
            using Field = Field<0, 16>;    // CNT
        };

        // TIM6 prescaler
        struct PSC : public Register<0x40001428> {
            using Field = Field<0, 16>;    // Prescaler valueThe counter clock frequency CK_CNT is equal to fCK_PSC / (PSC[15:0] + 1).
        };

        // TIM6 auto-reload register
        struct ARR : public Register<0x4000142c> {
            using Field = Field<0, 16>;    // Prescaler value
        };

    };

    // General-purpose timers
    struct TIM9 {
        // control register 1
        struct CR1 : public Register<0x40010800> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using OMP = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40010804> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40010808> {
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // Interrupt enable register
        struct DIER : public Register<0x4001080c> {
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40010810> {
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/Compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40010814> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC2G = Field<2, 1>;    // Capture/Compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/Compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1
        struct CCMR1_Output : public Register<0x40010818> {
            using OC2CE = Field<15, 1>;    // Output compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output compare 2 mode
            using OC2PE = Field<11, 1>;    // Output compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output compare 2 fast enable
            using CC2S = Field<8, 1>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output compare 1 mode
            using OC1PE = Field<3, 1>;    // Output compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40010818> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // counter
        struct CNT : public Register<0x40010824> {
            using Field = Field<0, 16>;    // TIM9 counter
        };

        // prescaler
        struct PSC : public Register<0x40010828> {
            using Field = Field<0, 16>;    // TIM9 prescaler
        };

        // auto-reload register
        struct ARR : public Register<0x4001082c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40010834> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40010838> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // option register
        struct OR : public Register<0x40010850> {
            using TI1_RMP = Field<0, 2>;    // TIM9 Input 1 remapping capability
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART1 {
        // Status register
        struct SR : public Register<0x40013800> {
            using CTS = Field<9, 1>;    // CTS flag
            using LBD = Field<8, 1>;    // LIN break detection flag
            using TXE = Field<7, 1>;    // Transmit data register empty
            using TC = Field<6, 1>;    // Transmission complete
            using RXNE = Field<5, 1>;    // Read data register not empty
            using IDLE = Field<4, 1>;    // IDLE line detected
            using ORE = Field<3, 1>;    // Overrun error
            using NF = Field<2, 1>;    // Noise detected flag
            using FE = Field<1, 1>;    // Framing error
            using PE = Field<0, 1>;    // Parity error
        };

        // Data register
        struct DR : public Register<0x40013804> {
            using Field = Field<0, 9>;    // Data value
        };

        // Baud rate register
        struct BRR : public Register<0x40013808> {
            using DIV_Mantissa = Field<4, 12>;    // mantissa of USARTDIV
            using DIV_Fraction = Field<0, 4>;    // fraction of USARTDIV
        };

        // Control register 1
        struct CR1 : public Register<0x4001380c> {
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using UE = Field<13, 1>;    // USART enable
            using M = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // TXE interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using RWU = Field<1, 1>;    // Receiver wakeup
            using SBK = Field<0, 1>;    // Send break
        };

        // Control register 2
        struct CR2 : public Register<0x40013810> {
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // lin break detection length
            using ADD = Field<0, 4>;    // Address of the USART node
        };

        // Control register 3
        struct CR3 : public Register<0x40013814> {
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // IrDA low-power
            using IREN = Field<1, 1>;    // IrDA mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40013818> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART2 {
        // Status register
        struct SR : public Register<0x40004400> {
            using CTS = Field<9, 1>;    // CTS flag
            using LBD = Field<8, 1>;    // LIN break detection flag
            using TXE = Field<7, 1>;    // Transmit data register empty
            using TC = Field<6, 1>;    // Transmission complete
            using RXNE = Field<5, 1>;    // Read data register not empty
            using IDLE = Field<4, 1>;    // IDLE line detected
            using ORE = Field<3, 1>;    // Overrun error
            using NF = Field<2, 1>;    // Noise detected flag
            using FE = Field<1, 1>;    // Framing error
            using PE = Field<0, 1>;    // Parity error
        };

        // Data register
        struct DR : public Register<0x40004404> {
            using Field = Field<0, 9>;    // Data value
        };

        // Baud rate register
        struct BRR : public Register<0x40004408> {
            using DIV_Mantissa = Field<4, 12>;    // mantissa of USARTDIV
            using DIV_Fraction = Field<0, 4>;    // fraction of USARTDIV
        };

        // Control register 1
        struct CR1 : public Register<0x4000440c> {
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using UE = Field<13, 1>;    // USART enable
            using M = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // TXE interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using RWU = Field<1, 1>;    // Receiver wakeup
            using SBK = Field<0, 1>;    // Send break
        };

        // Control register 2
        struct CR2 : public Register<0x40004410> {
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // lin break detection length
            using ADD = Field<0, 4>;    // Address of the USART node
        };

        // Control register 3
        struct CR3 : public Register<0x40004414> {
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // IrDA low-power
            using IREN = Field<1, 1>;    // IrDA mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40004418> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART3 {
        // Status register
        struct SR : public Register<0x40004800> {
            using CTS = Field<9, 1>;    // CTS flag
            using LBD = Field<8, 1>;    // LIN break detection flag
            using TXE = Field<7, 1>;    // Transmit data register empty
            using TC = Field<6, 1>;    // Transmission complete
            using RXNE = Field<5, 1>;    // Read data register not empty
            using IDLE = Field<4, 1>;    // IDLE line detected
            using ORE = Field<3, 1>;    // Overrun error
            using NF = Field<2, 1>;    // Noise detected flag
            using FE = Field<1, 1>;    // Framing error
            using PE = Field<0, 1>;    // Parity error
        };

        // Data register
        struct DR : public Register<0x40004804> {
            using Field = Field<0, 9>;    // Data value
        };

        // Baud rate register
        struct BRR : public Register<0x40004808> {
            using DIV_Mantissa = Field<4, 12>;    // mantissa of USARTDIV
            using DIV_Fraction = Field<0, 4>;    // fraction of USARTDIV
        };

        // Control register 1
        struct CR1 : public Register<0x4000480c> {
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using UE = Field<13, 1>;    // USART enable
            using M = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // TXE interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using RWU = Field<1, 1>;    // Receiver wakeup
            using SBK = Field<0, 1>;    // Send break
        };

        // Control register 2
        struct CR2 : public Register<0x40004810> {
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // lin break detection length
            using ADD = Field<0, 4>;    // Address of the USART node
        };

        // Control register 3
        struct CR3 : public Register<0x40004814> {
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // IrDA low-power
            using IREN = Field<1, 1>;    // IrDA mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40004818> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct UART4 {
        // Status register
        struct SR : public Register<0x40004c00> {
            using CTS = Field<9, 1>;    // CTS flag
            using LBD = Field<8, 1>;    // LIN break detection flag
            using TXE = Field<7, 1>;    // Transmit data register empty
            using TC = Field<6, 1>;    // Transmission complete
            using RXNE = Field<5, 1>;    // Read data register not empty
            using IDLE = Field<4, 1>;    // IDLE line detected
            using ORE = Field<3, 1>;    // Overrun error
            using NF = Field<2, 1>;    // Noise detected flag
            using FE = Field<1, 1>;    // Framing error
            using PE = Field<0, 1>;    // Parity error
        };

        // Data register
        struct DR : public Register<0x40004c04> {
            using Field = Field<0, 9>;    // Data value
        };

        // Baud rate register
        struct BRR : public Register<0x40004c08> {
            using DIV_Mantissa = Field<4, 12>;    // mantissa of USARTDIV
            using DIV_Fraction = Field<0, 4>;    // fraction of USARTDIV
        };

        // Control register 1
        struct CR1 : public Register<0x40004c0c> {
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using UE = Field<13, 1>;    // USART enable
            using M = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // TXE interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using RWU = Field<1, 1>;    // Receiver wakeup
            using SBK = Field<0, 1>;    // Send break
        };

        // Control register 2
        struct CR2 : public Register<0x40004c10> {
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // lin break detection length
            using ADD = Field<0, 4>;    // Address of the USART node
        };

        // Control register 3
        struct CR3 : public Register<0x40004c14> {
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // IrDA low-power
            using IREN = Field<1, 1>;    // IrDA mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40004c18> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct UART5 {
        // Status register
        struct SR : public Register<0x40005000> {
            using CTS = Field<9, 1>;    // CTS flag
            using LBD = Field<8, 1>;    // LIN break detection flag
            using TXE = Field<7, 1>;    // Transmit data register empty
            using TC = Field<6, 1>;    // Transmission complete
            using RXNE = Field<5, 1>;    // Read data register not empty
            using IDLE = Field<4, 1>;    // IDLE line detected
            using ORE = Field<3, 1>;    // Overrun error
            using NF = Field<2, 1>;    // Noise detected flag
            using FE = Field<1, 1>;    // Framing error
            using PE = Field<0, 1>;    // Parity error
        };

        // Data register
        struct DR : public Register<0x40005004> {
            using Field = Field<0, 9>;    // Data value
        };

        // Baud rate register
        struct BRR : public Register<0x40005008> {
            using DIV_Mantissa = Field<4, 12>;    // mantissa of USARTDIV
            using DIV_Fraction = Field<0, 4>;    // fraction of USARTDIV
        };

        // Control register 1
        struct CR1 : public Register<0x4000500c> {
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using UE = Field<13, 1>;    // USART enable
            using M = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // TXE interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using RWU = Field<1, 1>;    // Receiver wakeup
            using SBK = Field<0, 1>;    // Send break
        };

        // Control register 2
        struct CR2 : public Register<0x40005010> {
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // lin break detection length
            using ADD = Field<0, 4>;    // Address of the USART node
        };

        // Control register 3
        struct CR3 : public Register<0x40005014> {
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // IrDA low-power
            using IREN = Field<1, 1>;    // IrDA mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40005018> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

    };

    // Universal serial bus full-speed device interface
    struct USB {
        // endpoint 0 register
        struct USB_EP0R : public Register<0x40005c00> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // endpoint 1 register
        struct USB_EP1R : public Register<0x40005c04> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // endpoint 2 register
        struct USB_EP2R : public Register<0x40005c08> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // endpoint 3 register
        struct USB_EP3R : public Register<0x40005c0c> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // endpoint 4 register
        struct USB_EP4R : public Register<0x40005c10> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // endpoint 5 register
        struct USB_EP5R : public Register<0x40005c14> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // endpoint 6 register
        struct USB_EP6R : public Register<0x40005c18> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // endpoint 7 register
        struct USB_EP7R : public Register<0x40005c1c> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // control register
        struct USB_CNTR : public Register<0x40005c40> {
            using FRES = Field<0, 1>;    // Force USB Reset
            using PDWN = Field<1, 1>;    // Power down
            using LPMODE = Field<2, 1>;    // Low-power mode
            using FSUSP = Field<3, 1>;    // Force suspend
            using RESUME = Field<4, 1>;    // Resume request
            using ESOFM = Field<8, 1>;    // Expected start of frame interrupt mask
            using SOFM = Field<9, 1>;    // Start of frame interrupt mask
            using RESETM = Field<10, 1>;    // USB reset interrupt mask
            using SUSPM = Field<11, 1>;    // Suspend mode interrupt mask
            using WKUPM = Field<12, 1>;    // Wakeup interrupt mask
            using ERRM = Field<13, 1>;    // Error interrupt mask
            using PMAOVRM = Field<14, 1>;    // Packet memory area over / underrun interrupt mask
            using CTRM = Field<15, 1>;    // Correct transfer interrupt mask
        };

        // interrupt status register
        struct ISTR : public Register<0x40005c44> {
            using EP_ID = Field<0, 4>;    // Endpoint Identifier
            using DIR = Field<4, 1>;    // Direction of transaction
            using ESOF = Field<8, 1>;    // Expected start frame
            using SOF = Field<9, 1>;    // start of frame
            using RESET = Field<10, 1>;    // reset request
            using SUSP = Field<11, 1>;    // Suspend mode request
            using WKUP = Field<12, 1>;    // Wakeup
            using ERR = Field<13, 1>;    // Error
            using PMAOVR = Field<14, 1>;    // Packet memory area over / underrun
            using CTR = Field<15, 1>;    // Correct transfer
        };

        // frame number register
        struct FNR : public Register<0x40005c48> {
            using FN = Field<0, 11>;    // Frame number
            using LSOF = Field<11, 2>;    // Lost SOF
            using LCK = Field<13, 1>;    // Locked
            using RXDM = Field<14, 1>;    // Receive data - line status
            using RXDP = Field<15, 1>;    // Receive data + line status
        };

        // device address
        struct DADDR : public Register<0x40005c4c> {
            using ADD = Field<0, 7>;    // Device address
            using EF = Field<7, 1>;    // Enable function
        };

        // Buffer table address
        struct BTABLE : public Register<0x40005c50> {
            using Field = Field<3, 13>;    // Buffer table
        };

    };

    // Universal serial bus full-speed device interface
    struct USB_SRAM {
        // endpoint 0 register
        struct USB_EP0R : public Register<0x40006000> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // endpoint 1 register
        struct USB_EP1R : public Register<0x40006004> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // endpoint 2 register
        struct USB_EP2R : public Register<0x40006008> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // endpoint 3 register
        struct USB_EP3R : public Register<0x4000600c> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // endpoint 4 register
        struct USB_EP4R : public Register<0x40006010> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // endpoint 5 register
        struct USB_EP5R : public Register<0x40006014> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // endpoint 6 register
        struct USB_EP6R : public Register<0x40006018> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // endpoint 7 register
        struct USB_EP7R : public Register<0x4000601c> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // control register
        struct USB_CNTR : public Register<0x40006040> {
            using FRES = Field<0, 1>;    // Force USB Reset
            using PDWN = Field<1, 1>;    // Power down
            using LPMODE = Field<2, 1>;    // Low-power mode
            using FSUSP = Field<3, 1>;    // Force suspend
            using RESUME = Field<4, 1>;    // Resume request
            using ESOFM = Field<8, 1>;    // Expected start of frame interrupt mask
            using SOFM = Field<9, 1>;    // Start of frame interrupt mask
            using RESETM = Field<10, 1>;    // USB reset interrupt mask
            using SUSPM = Field<11, 1>;    // Suspend mode interrupt mask
            using WKUPM = Field<12, 1>;    // Wakeup interrupt mask
            using ERRM = Field<13, 1>;    // Error interrupt mask
            using PMAOVRM = Field<14, 1>;    // Packet memory area over / underrun interrupt mask
            using CTRM = Field<15, 1>;    // Correct transfer interrupt mask
        };

        // interrupt status register
        struct ISTR : public Register<0x40006044> {
            using EP_ID = Field<0, 4>;    // Endpoint Identifier
            using DIR = Field<4, 1>;    // Direction of transaction
            using ESOF = Field<8, 1>;    // Expected start frame
            using SOF = Field<9, 1>;    // start of frame
            using RESET = Field<10, 1>;    // reset request
            using SUSP = Field<11, 1>;    // Suspend mode request
            using WKUP = Field<12, 1>;    // Wakeup
            using ERR = Field<13, 1>;    // Error
            using PMAOVR = Field<14, 1>;    // Packet memory area over / underrun
            using CTR = Field<15, 1>;    // Correct transfer
        };

        // frame number register
        struct FNR : public Register<0x40006048> {
            using FN = Field<0, 11>;    // Frame number
            using LSOF = Field<11, 2>;    // Lost SOF
            using LCK = Field<13, 1>;    // Locked
            using RXDM = Field<14, 1>;    // Receive data - line status
            using RXDP = Field<15, 1>;    // Receive data + line status
        };

        // device address
        struct DADDR : public Register<0x4000604c> {
            using ADD = Field<0, 7>;    // Device address
            using EF = Field<7, 1>;    // Enable function
        };

        // Buffer table address
        struct BTABLE : public Register<0x40006050> {
            using Field = Field<3, 13>;    // Buffer table
        };

    };

    // Window watchdog
    struct WWDG {
        // Control register
        struct CR : public Register<0x40002c00> {
            using WDGA = Field<7, 1>;    // Activation bit
            using T = Field<0, 7>;    // 7-bit counter (MSB to LSB)
        };

        // Configuration register
        struct CFR : public Register<0x40002c04> {
            using EWI = Field<9, 1>;    // Early wakeup interrupt
            using WDGTB1 = Field<8, 1>;    // Timer base
            using WDGTB0 = Field<7, 1>;    // WDGTB0
            using W = Field<0, 7>;    // 7-bit window value
        };

        // SR
        struct SR : public Register<0x40002c08> {
            using EWIF = Field<0, 1>;    // EWIF
        };

    };

    // Analog-to-digital converter
    struct ADC {
        // status register
        struct SR : public Register<0x40012400> {
            using JCNR = Field<9, 1>;    // Injected channel not ready
            using RCNR = Field<8, 1>;    // Regular channel not ready
            using ADONS = Field<6, 1>;    // ADC ON status
            using OVR = Field<5, 1>;    // Overrun
            using STRT = Field<4, 1>;    // Regular channel start flag
            using JSTRT = Field<3, 1>;    // Injected channel start flag
            using JEOC = Field<2, 1>;    // Injected channel end of conversion
            using EOC = Field<1, 1>;    // Regular channel end of conversion
            using AWD = Field<0, 1>;    // Analog watchdog flag
        };

        // control register 1
        struct CR1 : public Register<0x40012404> {
            using OVRIE = Field<26, 1>;    // Overrun interrupt enable
            using RES = Field<24, 2>;    // Resolution
            using AWDEN = Field<23, 1>;    // Analog watchdog enable on regular channels
            using JAWDEN = Field<22, 1>;    // Analog watchdog enable on injected channels
            using PDI = Field<17, 1>;    // Power down during the idle phase
            using PDD = Field<16, 1>;    // Power down during the delay phase
            using DISCNUM = Field<13, 3>;    // Discontinuous mode channel count
            using JDISCEN = Field<12, 1>;    // Discontinuous mode on injected channels
            using DISCEN = Field<11, 1>;    // Discontinuous mode on regular channels
            using JAUTO = Field<10, 1>;    // Automatic injected group conversion
            using AWDSGL = Field<9, 1>;    // Enable the watchdog on a single channel in scan mode
            using SCAN = Field<8, 1>;    // Scan mode
            using JEOCIE = Field<7, 1>;    // Interrupt enable for injected channels
            using AWDIE = Field<6, 1>;    // Analog watchdog interrupt enable
            using EOCIE = Field<5, 1>;    // Interrupt enable for EOC
            using AWDCH = Field<0, 5>;    // Analog watchdog channel select bits
        };

        // control register 2
        struct CR2 : public Register<0x40012408> {
            using SWSTART = Field<30, 1>;    // Start conversion of regular channels
            using EXTEN = Field<28, 2>;    // External trigger enable for regular channels
            using EXTSEL = Field<24, 4>;    // External event select for regular group
            using JSWSTART = Field<22, 1>;    // Start conversion of injected channels
            using JEXTEN = Field<20, 2>;    // External trigger enable for injected channels
            using JEXTSEL = Field<16, 4>;    // External event select for injected group
            using ALIGN = Field<11, 1>;    // Data alignment
            using EOCS = Field<10, 1>;    // End of conversion selection
            using DDS = Field<9, 1>;    // DMA disable selection
            using DMA = Field<8, 1>;    // Direct memory access mode
            using DELS = Field<4, 3>;    // Delay selection
            using ADC_CFG = Field<2, 1>;    // ADC configuration
            using CONT = Field<1, 1>;    // Continuous conversion
            using ADON = Field<0, 1>;    // A/D Converter ON / OFF
        };

        // sample time register 1
        struct SMPR1 : public Register<0x4001240c> {
            using SMP = Field<0, 30>;    // Channel sampling time selection
        };

        // sample time register 2
        struct SMPR2 : public Register<0x40012410> {
            using SMP = Field<0, 30>;    // Channel sampling time selection
        };

        // sample time register 3
        struct SMPR3 : public Register<0x40012414> {
            using SMP = Field<0, 30>;    // Channel Sample time selection
        };

        // injected channel data offset register x
        struct JOFR1 : public Register<0x40012418> {
            using JOFFSET1 = Field<0, 12>;    // Data offset for injected channel x
        };

        // injected channel data offset register x
        struct JOFR2 : public Register<0x4001241c> {
            using JOFFSET2 = Field<0, 12>;    // Data offset for injected channel x
        };

        // injected channel data offset register x
        struct JOFR3 : public Register<0x40012420> {
            using JOFFSET3 = Field<0, 12>;    // Data offset for injected channel x
        };

        // injected channel data offset register x
        struct JOFR4 : public Register<0x40012424> {
            using JOFFSET4 = Field<0, 12>;    // Data offset for injected channel x
        };

        // watchdog higher threshold register
        struct HTR : public Register<0x40012428> {
            using HT = Field<0, 12>;    // Analog watchdog higher threshold
        };

        // watchdog lower threshold register
        struct LTR : public Register<0x4001242c> {
            using LT = Field<0, 12>;    // Analog watchdog lower threshold
        };

        // regular sequence register 1
        struct SQR1 : public Register<0x40012430> {
            using L = Field<20, 4>;    // Regular channel sequence length
            using SQ28 = Field<15, 5>;    // 28th conversion in regular sequence
            using SQ27 = Field<10, 5>;    // 27th conversion in regular sequence
            using SQ26 = Field<5, 5>;    // 26th conversion in regular sequence
            using SQ25 = Field<0, 5>;    // 25th conversion in regular sequence
        };

        // regular sequence register 2
        struct SQR2 : public Register<0x40012434> {
            using SQ24 = Field<25, 5>;    // 24th conversion in regular sequence
            using SQ23 = Field<20, 5>;    // 23rd conversion in regular sequence
            using SQ22 = Field<15, 5>;    // 22nd conversion in regular sequence
            using SQ21 = Field<10, 5>;    // 21st conversion in regular sequence
            using SQ20 = Field<5, 5>;    // 20th conversion in regular sequence
            using SQ19 = Field<0, 5>;    // 19th conversion in regular sequence
        };

        // regular sequence register 3
        struct SQR3 : public Register<0x40012438> {
            using SQ18 = Field<25, 5>;    // 18th conversion in regular sequence
            using SQ17 = Field<20, 5>;    // 17th conversion in regular sequence
            using SQ16 = Field<15, 5>;    // 16th conversion in regular sequence
            using SQ15 = Field<10, 5>;    // 15th conversion in regular sequence
            using SQ14 = Field<5, 5>;    // 14th conversion in regular sequence
            using SQ13 = Field<0, 5>;    // 13th conversion in regular sequence
        };

        // regular sequence register 4
        struct SQR4 : public Register<0x4001243c> {
            using SQ12 = Field<25, 5>;    // 12th conversion in regular sequence
            using SQ11 = Field<20, 5>;    // 11th conversion in regular sequence
            using SQ10 = Field<15, 5>;    // 10th conversion in regular sequence
            using SQ9 = Field<10, 5>;    // 9th conversion in regular sequence
            using SQ8 = Field<5, 5>;    // 8th conversion in regular sequence
            using SQ7 = Field<0, 5>;    // 7th conversion in regular sequence
        };

        // regular sequence register 5
        struct SQR5 : public Register<0x40012440> {
            using SQ6 = Field<25, 5>;    // 6th conversion in regular sequence
            using SQ5 = Field<20, 5>;    // 5th conversion in regular sequence
            using SQ4 = Field<15, 5>;    // 4th conversion in regular sequence
            using SQ3 = Field<10, 5>;    // 3rd conversion in regular sequence
            using SQ2 = Field<5, 5>;    // 2nd conversion in regular sequence
            using SQ1 = Field<0, 5>;    // 1st conversion in regular sequence
        };

        // injected sequence register
        struct JSQR : public Register<0x40012444> {
            using JL = Field<20, 2>;    // Injected sequence length
            using JSQ4 = Field<15, 5>;    // 4th conversion in injected sequence
            using JSQ3 = Field<10, 5>;    // 3rd conversion in injected sequence
            using JSQ2 = Field<5, 5>;    // 2nd conversion in injected sequence
            using JSQ1 = Field<0, 5>;    // 1st conversion in injected sequence
        };

        // injected data register x
        struct JDR1 : public Register<0x40012448> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // injected data register x
        struct JDR2 : public Register<0x4001244c> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // injected data register x
        struct JDR3 : public Register<0x40012450> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // injected data register x
        struct JDR4 : public Register<0x40012454> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // regular data register
        struct DR : public Register<0x40012458> {
            using RegularDATA = Field<0, 16>;    // Regular data
        };

        // sample time register 0
        struct SMPR0 : public Register<0x4001245c> {
            using SMP = Field<0, 6>;    // Channel Sample time selection
        };

        // ADC common status register
        struct CSR : public Register<0x40012700> {
            using AWD1 = Field<0, 1>;    // Analog watchdog flag of the ADC
            using EOC1 = Field<1, 1>;    // End of conversion of the ADC
            using JEOC1 = Field<2, 1>;    // Injected channel end of conversion of the ADC
            using JSTRT1 = Field<3, 1>;    // Injected channel Start flag of the ADC
            using STRT1 = Field<4, 1>;    // Regular channel Start flag of the ADC
            using OVR1 = Field<5, 1>;    // Overrun flag of the ADC
            using ADONS1 = Field<6, 1>;    // ADON Status of ADC1
        };

        // ADC common control register
        struct CCR : public Register<0x40012704> {
            using ADCPRE = Field<16, 2>;    // ADC prescaler
            using TSVREFE = Field<23, 1>;    // Temperature sensor and VREFINT enable
        };

    };

    // Nested Vectored Interrupt Controller
    struct NVIC {
        // Interrupt Set-Enable Register
        struct ISER0 : public Register<0xe000e100> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Set-Enable Register
        struct ISER1 : public Register<0xe000e104> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Clear-Enable Register
        struct ICER0 : public Register<0xe000e180> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Clear-Enable Register
        struct ICER1 : public Register<0xe000e184> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Set-Pending Register
        struct ISPR0 : public Register<0xe000e200> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Set-Pending Register
        struct ISPR1 : public Register<0xe000e204> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR0 : public Register<0xe000e280> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR1 : public Register<0xe000e284> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Active Bit Register
        struct IABR0 : public Register<0xe000e300> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Active Bit Register
        struct IABR1 : public Register<0xe000e304> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Priority Register
        struct IPR0 : public Register<0xe000e400> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR1 : public Register<0xe000e404> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR2 : public Register<0xe000e408> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR3 : public Register<0xe000e40c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR4 : public Register<0xe000e410> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR5 : public Register<0xe000e414> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR6 : public Register<0xe000e418> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR7 : public Register<0xe000e41c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR8 : public Register<0xe000e420> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR9 : public Register<0xe000e424> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR10 : public Register<0xe000e428> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR11 : public Register<0xe000e42c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR12 : public Register<0xe000e430> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR13 : public Register<0xe000e434> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

    };

    // debug support
    struct DBGMCU {
        // DBGMCU_IDCODE
        struct IDCODE : public Register<0xe0042000> {
            using DEV_ID = Field<0, 12>;    // Device identifier
            using REV_ID = Field<16, 16>;    // Revision identifie
        };

        // Debug MCU configuration register
        struct CR : public Register<0xe0042004> {
            using DBG_SLEEP = Field<0, 1>;    // Debug Sleep mode
            using DBG_STOP = Field<1, 1>;    // Debug Stop mode
            using DBG_STANDBY = Field<2, 1>;    // Debug Standby mode
            using TRACE_IOEN = Field<5, 1>;    // Trace pin assignment control
            using TRACE_MODE = Field<6, 2>;    // Trace pin assignment control
        };

        // Debug MCU APB1 freeze register1
        struct APB1_FZ : public Register<0xe0042008> {
            using DBG_TIM2_STOP = Field<0, 1>;    // TIM2 counter stopped when core is halted
            using DBG_TIM3_STOP = Field<1, 1>;    // TIM3 counter stopped when core is halted
            using DBG_TIM4_STOP = Field<2, 1>;    // TIM4 counter stopped when core is halted
            using DBG_TIM5_STOP = Field<3, 1>;    // TIM5 counter stopped when core is halted
            using DBG_TIM6_STOP = Field<4, 1>;    // TIM6 counter stopped when core is halted
            using DBG_TIM7_STOP = Field<5, 1>;    // TIM7 counter stopped when core is halted
            using DBG_RTC_STOP = Field<10, 1>;    // Debug RTC stopped when core is halted
            using DBG_WWDG_STOP = Field<11, 1>;    // Debug window watchdog stopped when core is halted
            using DBG_IWDG_STOP = Field<12, 1>;    // Debug independent watchdog stopped when core is halted
            using DBG_I2C1_SMBUS_TIMEOUT = Field<21, 1>;    // SMBUS timeout mode stopped when core is halted
            using DBG_I2C2_SMBUS_TIMEOUT = Field<22, 1>;    // SMBUS timeout mode stopped when core is halted
        };

        // Debug MCU APB1 freeze register 2
        struct APB2_FZ : public Register<0xe004200c> {
            using DBG_TIM9_STOP = Field<2, 1>;    // TIM counter stopped when core is halted
            using DBG_TIM10_STOP = Field<3, 1>;    // TIM counter stopped when core is halted
            using DBG_TIM11_STOP = Field<4, 1>;    // TIM counter stopped when core is halted
        };

    };

    // Memory protection unit
    struct MPU {
        // MPU type register
        struct MPU_TYPER : public Register<0xe000ed90> {
            using SEPARATE = Field<0, 1>;    // Separate flag
            using DREGION = Field<8, 8>;    // Number of MPU data regions
            using IREGION = Field<16, 8>;    // Number of MPU instruction regions
        };

        // MPU control register
        struct MPU_CTRL : public Register<0xe000ed94> {
            using ENABLE = Field<0, 1>;    // Enables the MPU
            using HFNMIENA = Field<1, 1>;    // Enables the operation of MPU during hard fault
            using PRIVDEFENA = Field<2, 1>;    // Enable priviliged software access to default memory map
        };

        // MPU region number register
        struct MPU_RNR : public Register<0xe000ed98> {
            using REGION = Field<0, 8>;    // MPU region
        };

        // MPU region base address register
        struct MPU_RBAR : public Register<0xe000ed9c> {
            using REGION = Field<0, 4>;    // MPU region field
            using VALID = Field<4, 1>;    // MPU region number valid
            using ADDR = Field<5, 27>;    // Region base address field
        };

        // MPU region attribute and size register
        struct MPU_RASR : public Register<0xe000eda0> {
            using ENABLE = Field<0, 1>;    // Region enable bit.
            using SIZE = Field<1, 5>;    // Size of the MPU protection region
            using SRD = Field<8, 8>;    // Subregion disable bits
            using B = Field<16, 1>;    // memory attribute
            using C = Field<17, 1>;    // memory attribute
            using S = Field<18, 1>;    // Shareable memory attribute
            using TEX = Field<19, 3>;    // memory attribute
            using AP = Field<24, 3>;    // Access permission
            using XN = Field<28, 1>;    // Instruction access disable bit
        };

    };

    // System control block ACTLR
    struct SCB_ACTRL {
        // Auxiliary control register
        struct ACTRL : public Register<0xe000e008> {
            using DISFOLD = Field<2, 1>;    // DISFOLD
            using FPEXCODIS = Field<10, 1>;    // FPEXCODIS
            using DISRAMODE = Field<11, 1>;    // DISRAMODE
            using DISITMATBFLUSH = Field<12, 1>;    // DISITMATBFLUSH
        };

    };

    // Nested vectored interrupt controller
    struct NVIC_STIR {
        // Software trigger interrupt register
        struct STIR : public Register<0xe000ef00> {
            using INTID = Field<0, 9>;    // Software generated interrupt ID
        };

    };

    // System control block
    struct SCB {
        // CPUID base register
        struct CPUID : public Register<0xe000ed00> {
            using Revision = Field<0, 4>;    // Revision number
            using PartNo = Field<4, 12>;    // Part number of the processor
            using Constant = Field<16, 4>;    // Reads as 0xF
            using Variant = Field<20, 4>;    // Variant number
            using Implementer = Field<24, 8>;    // Implementer code
        };

        // Interrupt control and state register
        struct ICSR : public Register<0xe000ed04> {
            using VECTACTIVE = Field<0, 9>;    // Active vector
            using RETTOBASE = Field<11, 1>;    // Return to base level
            using VECTPENDING = Field<12, 7>;    // Pending vector
            using ISRPENDING = Field<22, 1>;    // Interrupt pending flag
            using PENDSTCLR = Field<25, 1>;    // SysTick exception clear-pending bit
            using PENDSTSET = Field<26, 1>;    // SysTick exception set-pending bit
            using PENDSVCLR = Field<27, 1>;    // PendSV clear-pending bit
            using PENDSVSET = Field<28, 1>;    // PendSV set-pending bit
            using NMIPENDSET = Field<31, 1>;    // NMI set-pending bit.
        };

        // Vector table offset register
        struct VTOR : public Register<0xe000ed08> {
            using TBLOFF = Field<9, 21>;    // Vector table base offset field
        };

        // Application interrupt and reset control register
        struct AIRCR : public Register<0xe000ed0c> {
            using VECTRESET = Field<0, 1>;    // VECTRESET
            using VECTCLRACTIVE = Field<1, 1>;    // VECTCLRACTIVE
            using SYSRESETREQ = Field<2, 1>;    // SYSRESETREQ
            using PRIGROUP = Field<8, 3>;    // PRIGROUP
            using ENDIANESS = Field<15, 1>;    // ENDIANESS
            using VECTKEYSTAT = Field<16, 16>;    // Register key
        };

        // System control register
        struct SCR : public Register<0xe000ed10> {
            using SLEEPONEXIT = Field<1, 1>;    // SLEEPONEXIT
            using SLEEPDEEP = Field<2, 1>;    // SLEEPDEEP
            using SEVEONPEND = Field<4, 1>;    // Send Event on Pending bit
        };

        // Configuration and control register
        struct CCR : public Register<0xe000ed14> {
            using NONBASETHRDENA = Field<0, 1>;    // Configures how the processor enters Thread mode
            using USERSETMPEND = Field<1, 1>;    // USERSETMPEND
            using UNALIGN__TRP = Field<3, 1>;    // UNALIGN_ TRP
            using DIV_0_TRP = Field<4, 1>;    // DIV_0_TRP
            using BFHFNMIGN = Field<8, 1>;    // BFHFNMIGN
            using STKALIGN = Field<9, 1>;    // STKALIGN
        };

        // System handler priority registers
        struct SHPR1 : public Register<0xe000ed18> {
            using PRI_4 = Field<0, 8>;    // Priority of system handler 4
            using PRI_5 = Field<8, 8>;    // Priority of system handler 5
            using PRI_6 = Field<16, 8>;    // Priority of system handler 6
        };

        // System handler priority registers
        struct SHPR2 : public Register<0xe000ed1c> {
            using PRI_11 = Field<24, 8>;    // Priority of system handler 11
        };

        // System handler priority registers
        struct SHPR3 : public Register<0xe000ed20> {
            using PRI_14 = Field<16, 8>;    // Priority of system handler 14
            using PRI_15 = Field<24, 8>;    // Priority of system handler 15
        };

        // System handler control and state register
        struct SHCRS : public Register<0xe000ed24> {
            using MEMFAULTACT = Field<0, 1>;    // Memory management fault exception active bit
            using BUSFAULTACT = Field<1, 1>;    // Bus fault exception active bit
            using USGFAULTACT = Field<3, 1>;    // Usage fault exception active bit
            using SVCALLACT = Field<7, 1>;    // SVC call active bit
            using MONITORACT = Field<8, 1>;    // Debug monitor active bit
            using PENDSVACT = Field<10, 1>;    // PendSV exception active bit
            using SYSTICKACT = Field<11, 1>;    // SysTick exception active bit
            using USGFAULTPENDED = Field<12, 1>;    // Usage fault exception pending bit
            using MEMFAULTPENDED = Field<13, 1>;    // Memory management fault exception pending bit
            using BUSFAULTPENDED = Field<14, 1>;    // Bus fault exception pending bit
            using SVCALLPENDED = Field<15, 1>;    // SVC call pending bit
            using MEMFAULTENA = Field<16, 1>;    // Memory management fault enable bit
            using BUSFAULTENA = Field<17, 1>;    // Bus fault enable bit
            using USGFAULTENA = Field<18, 1>;    // Usage fault enable bit
        };

        // Configurable fault status register
        struct CFSR_UFSR_BFSR_MMFSR : public Register<0xe000ed28> {
            using IACCVIOL = Field<0, 1>;    // IACCVIOL
            using DACCVIOL = Field<1, 1>;    // DACCVIOL
            using MUNSTKERR = Field<3, 1>;    // MUNSTKERR
            using MSTKERR = Field<4, 1>;    // MSTKERR
            using MLSPERR = Field<5, 1>;    // MLSPERR
            using MMARVALID = Field<7, 1>;    // MMARVALID
            using IBUSERR = Field<8, 1>;    // Instruction bus error
            using PRECISERR = Field<9, 1>;    // Precise data bus error
            using IMPRECISERR = Field<10, 1>;    // Imprecise data bus error
            using UNSTKERR = Field<11, 1>;    // Bus fault on unstacking for a return from exception
            using STKERR = Field<12, 1>;    // Bus fault on stacking for exception entry
            using LSPERR = Field<13, 1>;    // Bus fault on floating-point lazy state preservation
            using BFARVALID = Field<15, 1>;    // Bus Fault Address Register (BFAR) valid flag
            using UNDEFINSTR = Field<16, 1>;    // Undefined instruction usage fault
            using INVSTATE = Field<17, 1>;    // Invalid state usage fault
            using INVPC = Field<18, 1>;    // Invalid PC load usage fault
            using NOCP = Field<19, 1>;    // No coprocessor usage fault.
            using UNALIGNED = Field<24, 1>;    // Unaligned access usage fault
            using DIVBYZERO = Field<25, 1>;    // Divide by zero usage fault
        };

        // Hard fault status register
        struct HFSR : public Register<0xe000ed2c> {
            using VECTTBL = Field<1, 1>;    // Vector table hard fault
            using FORCED = Field<30, 1>;    // Forced hard fault
            using DEBUG_VT = Field<31, 1>;    // Reserved for Debug use
        };

        // Memory management fault address register
        struct MMFAR : public Register<0xe000ed34> {
            using Field = Field<0, 32>;    // Memory management fault address
        };

        // Bus fault address register
        struct BFAR : public Register<0xe000ed38> {
            using Field = Field<0, 32>;    // Bus fault address
        };

    };

    // SysTick timer
    struct STK {
        // SysTick control and status register
        struct CTRL : public Register<0xe000e010> {
            using ENABLE = Field<0, 1>;    // Counter enable
            using TICKINT = Field<1, 1>;    // SysTick exception request enable
            using CLKSOURCE = Field<2, 1>;    // Clock source selection
            using COUNTFLAG = Field<16, 1>;    // COUNTFLAG
        };

        // SysTick reload value register
        struct LOAD_ : public Register<0xe000e014> {
            using RELOAD = Field<0, 24>;    // RELOAD value
        };

        // SysTick current value register
        struct VAL : public Register<0xe000e018> {
            using CURRENT = Field<0, 24>;    // Current counter value
        };

        // SysTick calibration value register
        struct CALIB : public Register<0xe000e01c> {
            using TENMS = Field<0, 24>;    // Calibration value
        };

    };

};
