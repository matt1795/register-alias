// This is a file generated by svd-alias.

#pragma once

#include "svd-alias/bit-field.hpp"
#include "svd-alias/register.hpp"

struct STM32F3x4 {
    // General-purpose I/Os
    struct GPIOA {
        // GPIO port mode register
        struct MODER : public Register<0x48000000> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y =0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x48000004> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x48000008> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4800000c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x48000010> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x48000014> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x48000018> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4800001c> {
            using LCKK = Field<16, 1>;    // Lok Key
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x48000020> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x48000024> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // Port bit reset register
        struct BRR : public Register<0x48000028> {
            using BR0 = Field<0, 1>;    // Port x Reset bit y
            using BR1 = Field<1, 1>;    // Port x Reset bit y
            using BR2 = Field<2, 1>;    // Port x Reset bit y
            using BR3 = Field<3, 1>;    // Port x Reset bit y
            using BR4 = Field<4, 1>;    // Port x Reset bit y
            using BR5 = Field<5, 1>;    // Port x Reset bit y
            using BR6 = Field<6, 1>;    // Port x Reset bit y
            using BR7 = Field<7, 1>;    // Port x Reset bit y
            using BR8 = Field<8, 1>;    // Port x Reset bit y
            using BR9 = Field<9, 1>;    // Port x Reset bit y
            using BR10 = Field<10, 1>;    // Port x Reset bit y
            using BR11 = Field<11, 1>;    // Port x Reset bit y
            using BR12 = Field<12, 1>;    // Port x Reset bit y
            using BR13 = Field<13, 1>;    // Port x Reset bit y
            using BR14 = Field<14, 1>;    // Port x Reset bit y
            using BR15 = Field<15, 1>;    // Port x Reset bit y
        };

    };

    // General-purpose I/Os
    struct GPIOB {
        // GPIO port mode register
        struct MODER : public Register<0x48000400> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x48000404> {
            using OT15 = Field<15, 1>;    // Port x configuration bit 15
            using OT14 = Field<14, 1>;    // Port x configuration bit 14
            using OT13 = Field<13, 1>;    // Port x configuration bit 13
            using OT12 = Field<12, 1>;    // Port x configuration bit 12
            using OT11 = Field<11, 1>;    // Port x configuration bit 11
            using OT10 = Field<10, 1>;    // Port x configuration bit 10
            using OT9 = Field<9, 1>;    // Port x configuration bit 9
            using OT8 = Field<8, 1>;    // Port x configuration bit 8
            using OT7 = Field<7, 1>;    // Port x configuration bit 7
            using OT6 = Field<6, 1>;    // Port x configuration bit 6
            using OT5 = Field<5, 1>;    // Port x configuration bit 5
            using OT4 = Field<4, 1>;    // Port x configuration bit 4
            using OT3 = Field<3, 1>;    // Port x configuration bit 3
            using OT2 = Field<2, 1>;    // Port x configuration bit 2
            using OT1 = Field<1, 1>;    // Port x configuration bit 1
            using OT0 = Field<0, 1>;    // Port x configuration bit 0
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x48000408> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4800040c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x48000410> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x48000414> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x48000418> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4800041c> {
            using LCKK = Field<16, 1>;    // Lok Key
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x48000420> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x48000424> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // Port bit reset register
        struct BRR : public Register<0x48000428> {
            using BR0 = Field<0, 1>;    // Port x Reset bit y
            using BR1 = Field<1, 1>;    // Port x Reset bit y
            using BR2 = Field<2, 1>;    // Port x Reset bit y
            using BR3 = Field<3, 1>;    // Port x Reset bit y
            using BR4 = Field<4, 1>;    // Port x Reset bit y
            using BR5 = Field<5, 1>;    // Port x Reset bit y
            using BR6 = Field<6, 1>;    // Port x Reset bit y
            using BR7 = Field<7, 1>;    // Port x Reset bit y
            using BR8 = Field<8, 1>;    // Port x Reset bit y
            using BR9 = Field<9, 1>;    // Port x Reset bit y
            using BR10 = Field<10, 1>;    // Port x Reset bit y
            using BR11 = Field<11, 1>;    // Port x Reset bit y
            using BR12 = Field<12, 1>;    // Port x Reset bit y
            using BR13 = Field<13, 1>;    // Port x Reset bit y
            using BR14 = Field<14, 1>;    // Port x Reset bit y
            using BR15 = Field<15, 1>;    // Port x Reset bit y
        };

    };

    // General-purpose I/Os
    struct GPIOC {
        // GPIO port mode register
        struct MODER : public Register<0x48000800> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x48000804> {
            using OT15 = Field<15, 1>;    // Port x configuration bit 15
            using OT14 = Field<14, 1>;    // Port x configuration bit 14
            using OT13 = Field<13, 1>;    // Port x configuration bit 13
            using OT12 = Field<12, 1>;    // Port x configuration bit 12
            using OT11 = Field<11, 1>;    // Port x configuration bit 11
            using OT10 = Field<10, 1>;    // Port x configuration bit 10
            using OT9 = Field<9, 1>;    // Port x configuration bit 9
            using OT8 = Field<8, 1>;    // Port x configuration bit 8
            using OT7 = Field<7, 1>;    // Port x configuration bit 7
            using OT6 = Field<6, 1>;    // Port x configuration bit 6
            using OT5 = Field<5, 1>;    // Port x configuration bit 5
            using OT4 = Field<4, 1>;    // Port x configuration bit 4
            using OT3 = Field<3, 1>;    // Port x configuration bit 3
            using OT2 = Field<2, 1>;    // Port x configuration bit 2
            using OT1 = Field<1, 1>;    // Port x configuration bit 1
            using OT0 = Field<0, 1>;    // Port x configuration bit 0
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x48000808> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4800080c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x48000810> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x48000814> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x48000818> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4800081c> {
            using LCKK = Field<16, 1>;    // Lok Key
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x48000820> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x48000824> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // Port bit reset register
        struct BRR : public Register<0x48000828> {
            using BR0 = Field<0, 1>;    // Port x Reset bit y
            using BR1 = Field<1, 1>;    // Port x Reset bit y
            using BR2 = Field<2, 1>;    // Port x Reset bit y
            using BR3 = Field<3, 1>;    // Port x Reset bit y
            using BR4 = Field<4, 1>;    // Port x Reset bit y
            using BR5 = Field<5, 1>;    // Port x Reset bit y
            using BR6 = Field<6, 1>;    // Port x Reset bit y
            using BR7 = Field<7, 1>;    // Port x Reset bit y
            using BR8 = Field<8, 1>;    // Port x Reset bit y
            using BR9 = Field<9, 1>;    // Port x Reset bit y
            using BR10 = Field<10, 1>;    // Port x Reset bit y
            using BR11 = Field<11, 1>;    // Port x Reset bit y
            using BR12 = Field<12, 1>;    // Port x Reset bit y
            using BR13 = Field<13, 1>;    // Port x Reset bit y
            using BR14 = Field<14, 1>;    // Port x Reset bit y
            using BR15 = Field<15, 1>;    // Port x Reset bit y
        };

    };

    // General-purpose I/Os
    struct GPIOD {
        // GPIO port mode register
        struct MODER : public Register<0x48000c00> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x48000c04> {
            using OT15 = Field<15, 1>;    // Port x configuration bit 15
            using OT14 = Field<14, 1>;    // Port x configuration bit 14
            using OT13 = Field<13, 1>;    // Port x configuration bit 13
            using OT12 = Field<12, 1>;    // Port x configuration bit 12
            using OT11 = Field<11, 1>;    // Port x configuration bit 11
            using OT10 = Field<10, 1>;    // Port x configuration bit 10
            using OT9 = Field<9, 1>;    // Port x configuration bit 9
            using OT8 = Field<8, 1>;    // Port x configuration bit 8
            using OT7 = Field<7, 1>;    // Port x configuration bit 7
            using OT6 = Field<6, 1>;    // Port x configuration bit 6
            using OT5 = Field<5, 1>;    // Port x configuration bit 5
            using OT4 = Field<4, 1>;    // Port x configuration bit 4
            using OT3 = Field<3, 1>;    // Port x configuration bit 3
            using OT2 = Field<2, 1>;    // Port x configuration bit 2
            using OT1 = Field<1, 1>;    // Port x configuration bit 1
            using OT0 = Field<0, 1>;    // Port x configuration bit 0
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x48000c08> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x48000c0c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x48000c10> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x48000c14> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x48000c18> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x48000c1c> {
            using LCKK = Field<16, 1>;    // Lok Key
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x48000c20> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x48000c24> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // Port bit reset register
        struct BRR : public Register<0x48000c28> {
            using BR0 = Field<0, 1>;    // Port x Reset bit y
            using BR1 = Field<1, 1>;    // Port x Reset bit y
            using BR2 = Field<2, 1>;    // Port x Reset bit y
            using BR3 = Field<3, 1>;    // Port x Reset bit y
            using BR4 = Field<4, 1>;    // Port x Reset bit y
            using BR5 = Field<5, 1>;    // Port x Reset bit y
            using BR6 = Field<6, 1>;    // Port x Reset bit y
            using BR7 = Field<7, 1>;    // Port x Reset bit y
            using BR8 = Field<8, 1>;    // Port x Reset bit y
            using BR9 = Field<9, 1>;    // Port x Reset bit y
            using BR10 = Field<10, 1>;    // Port x Reset bit y
            using BR11 = Field<11, 1>;    // Port x Reset bit y
            using BR12 = Field<12, 1>;    // Port x Reset bit y
            using BR13 = Field<13, 1>;    // Port x Reset bit y
            using BR14 = Field<14, 1>;    // Port x Reset bit y
            using BR15 = Field<15, 1>;    // Port x Reset bit y
        };

    };

    // General-purpose I/Os
    struct GPIOF {
        // GPIO port mode register
        struct MODER : public Register<0x48001400> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x48001404> {
            using OT15 = Field<15, 1>;    // Port x configuration bit 15
            using OT14 = Field<14, 1>;    // Port x configuration bit 14
            using OT13 = Field<13, 1>;    // Port x configuration bit 13
            using OT12 = Field<12, 1>;    // Port x configuration bit 12
            using OT11 = Field<11, 1>;    // Port x configuration bit 11
            using OT10 = Field<10, 1>;    // Port x configuration bit 10
            using OT9 = Field<9, 1>;    // Port x configuration bit 9
            using OT8 = Field<8, 1>;    // Port x configuration bit 8
            using OT7 = Field<7, 1>;    // Port x configuration bit 7
            using OT6 = Field<6, 1>;    // Port x configuration bit 6
            using OT5 = Field<5, 1>;    // Port x configuration bit 5
            using OT4 = Field<4, 1>;    // Port x configuration bit 4
            using OT3 = Field<3, 1>;    // Port x configuration bit 3
            using OT2 = Field<2, 1>;    // Port x configuration bit 2
            using OT1 = Field<1, 1>;    // Port x configuration bit 1
            using OT0 = Field<0, 1>;    // Port x configuration bit 0
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x48001408> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4800140c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x48001410> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x48001414> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x48001418> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4800141c> {
            using LCKK = Field<16, 1>;    // Lok Key
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x48001420> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x48001424> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // Port bit reset register
        struct BRR : public Register<0x48001428> {
            using BR0 = Field<0, 1>;    // Port x Reset bit y
            using BR1 = Field<1, 1>;    // Port x Reset bit y
            using BR2 = Field<2, 1>;    // Port x Reset bit y
            using BR3 = Field<3, 1>;    // Port x Reset bit y
            using BR4 = Field<4, 1>;    // Port x Reset bit y
            using BR5 = Field<5, 1>;    // Port x Reset bit y
            using BR6 = Field<6, 1>;    // Port x Reset bit y
            using BR7 = Field<7, 1>;    // Port x Reset bit y
            using BR8 = Field<8, 1>;    // Port x Reset bit y
            using BR9 = Field<9, 1>;    // Port x Reset bit y
            using BR10 = Field<10, 1>;    // Port x Reset bit y
            using BR11 = Field<11, 1>;    // Port x Reset bit y
            using BR12 = Field<12, 1>;    // Port x Reset bit y
            using BR13 = Field<13, 1>;    // Port x Reset bit y
            using BR14 = Field<14, 1>;    // Port x Reset bit y
            using BR15 = Field<15, 1>;    // Port x Reset bit y
        };

    };

    // Touch sensing controller
    struct TSC {
        // control register
        struct CR : public Register<0x40024000> {
            using CTPH = Field<28, 4>;    // Charge transfer pulse high
            using CTPL = Field<24, 4>;    // Charge transfer pulse low
            using SSD = Field<17, 7>;    // Spread spectrum deviation
            using SSE = Field<16, 1>;    // Spread spectrum enable
            using SSPSC = Field<15, 1>;    // Spread spectrum prescaler
            using PGPSC = Field<12, 3>;    // pulse generator prescaler
            using MCV = Field<5, 3>;    // Max count value
            using IODEF = Field<4, 1>;    // I/O Default mode
            using SYNCPOL = Field<3, 1>;    // Synchronization pin polarity
            using AM = Field<2, 1>;    // Acquisition mode
            using START = Field<1, 1>;    // Start a new acquisition
            using TSCE = Field<0, 1>;    // Touch sensing controller enable
        };

        // interrupt enable register
        struct IER : public Register<0x40024004> {
            using MCEIE = Field<1, 1>;    // Max count error interrupt enable
            using EOAIE = Field<0, 1>;    // End of acquisition interrupt enable
        };

        // interrupt clear register
        struct ICR : public Register<0x40024008> {
            using MCEIC = Field<1, 1>;    // Max count error interrupt clear
            using EOAIC = Field<0, 1>;    // End of acquisition interrupt clear
        };

        // interrupt status register
        struct ISR : public Register<0x4002400c> {
            using MCEF = Field<1, 1>;    // Max count error flag
            using EOAF = Field<0, 1>;    // End of acquisition flag
        };

        // I/O hysteresis control register
        struct IOHCR : public Register<0x40024010> {
            using G1_IO1 = Field<0, 1>;    // G1_IO1 Schmitt trigger hysteresis mode
            using G1_IO2 = Field<1, 1>;    // G1_IO2 Schmitt trigger hysteresis mode
            using G1_IO3 = Field<2, 1>;    // G1_IO3 Schmitt trigger hysteresis mode
            using G1_IO4 = Field<3, 1>;    // G1_IO4 Schmitt trigger hysteresis mode
            using G2_IO1 = Field<4, 1>;    // G2_IO1 Schmitt trigger hysteresis mode
            using G2_IO2 = Field<5, 1>;    // G2_IO2 Schmitt trigger hysteresis mode
            using G2_IO3 = Field<6, 1>;    // G2_IO3 Schmitt trigger hysteresis mode
            using G2_IO4 = Field<7, 1>;    // G2_IO4 Schmitt trigger hysteresis mode
            using G3_IO1 = Field<8, 1>;    // G3_IO1 Schmitt trigger hysteresis mode
            using G3_IO2 = Field<9, 1>;    // G3_IO2 Schmitt trigger hysteresis mode
            using G3_IO3 = Field<10, 1>;    // G3_IO3 Schmitt trigger hysteresis mode
            using G3_IO4 = Field<11, 1>;    // G3_IO4 Schmitt trigger hysteresis mode
            using G4_IO1 = Field<12, 1>;    // G4_IO1 Schmitt trigger hysteresis mode
            using G4_IO2 = Field<13, 1>;    // G4_IO2 Schmitt trigger hysteresis mode
            using G4_IO3 = Field<14, 1>;    // G4_IO3 Schmitt trigger hysteresis mode
            using G4_IO4 = Field<15, 1>;    // G4_IO4 Schmitt trigger hysteresis mode
            using G5_IO1 = Field<16, 1>;    // G5_IO1 Schmitt trigger hysteresis mode
            using G5_IO2 = Field<17, 1>;    // G5_IO2 Schmitt trigger hysteresis mode
            using G5_IO3 = Field<18, 1>;    // G5_IO3 Schmitt trigger hysteresis mode
            using G5_IO4 = Field<19, 1>;    // G5_IO4 Schmitt trigger hysteresis mode
            using G6_IO1 = Field<20, 1>;    // G6_IO1 Schmitt trigger hysteresis mode
            using G6_IO2 = Field<21, 1>;    // G6_IO2 Schmitt trigger hysteresis mode
            using G6_IO3 = Field<22, 1>;    // G6_IO3 Schmitt trigger hysteresis mode
            using G6_IO4 = Field<23, 1>;    // G6_IO4 Schmitt trigger hysteresis mode
            using G7_IO1 = Field<24, 1>;    // G7_IO1 Schmitt trigger hysteresis mode
            using G7_IO2 = Field<25, 1>;    // G7_IO2 Schmitt trigger hysteresis mode
            using G7_IO3 = Field<26, 1>;    // G7_IO3 Schmitt trigger hysteresis mode
            using G7_IO4 = Field<27, 1>;    // G7_IO4 Schmitt trigger hysteresis mode
            using G8_IO1 = Field<28, 1>;    // G8_IO1 Schmitt trigger hysteresis mode
            using G8_IO2 = Field<29, 1>;    // G8_IO2 Schmitt trigger hysteresis mode
            using G8_IO3 = Field<30, 1>;    // G8_IO3 Schmitt trigger hysteresis mode
            using G8_IO4 = Field<31, 1>;    // G8_IO4 Schmitt trigger hysteresis mode
        };

        // I/O analog switch control register
        struct IOASCR : public Register<0x40024018> {
            using G1_IO1 = Field<0, 1>;    // G1_IO1 analog switch enable
            using G1_IO2 = Field<1, 1>;    // G1_IO2 analog switch enable
            using G1_IO3 = Field<2, 1>;    // G1_IO3 analog switch enable
            using G1_IO4 = Field<3, 1>;    // G1_IO4 analog switch enable
            using G2_IO1 = Field<4, 1>;    // G2_IO1 analog switch enable
            using G2_IO2 = Field<5, 1>;    // G2_IO2 analog switch enable
            using G2_IO3 = Field<6, 1>;    // G2_IO3 analog switch enable
            using G2_IO4 = Field<7, 1>;    // G2_IO4 analog switch enable
            using G3_IO1 = Field<8, 1>;    // G3_IO1 analog switch enable
            using G3_IO2 = Field<9, 1>;    // G3_IO2 analog switch enable
            using G3_IO3 = Field<10, 1>;    // G3_IO3 analog switch enable
            using G3_IO4 = Field<11, 1>;    // G3_IO4 analog switch enable
            using G4_IO1 = Field<12, 1>;    // G4_IO1 analog switch enable
            using G4_IO2 = Field<13, 1>;    // G4_IO2 analog switch enable
            using G4_IO3 = Field<14, 1>;    // G4_IO3 analog switch enable
            using G4_IO4 = Field<15, 1>;    // G4_IO4 analog switch enable
            using G5_IO1 = Field<16, 1>;    // G5_IO1 analog switch enable
            using G5_IO2 = Field<17, 1>;    // G5_IO2 analog switch enable
            using G5_IO3 = Field<18, 1>;    // G5_IO3 analog switch enable
            using G5_IO4 = Field<19, 1>;    // G5_IO4 analog switch enable
            using G6_IO1 = Field<20, 1>;    // G6_IO1 analog switch enable
            using G6_IO2 = Field<21, 1>;    // G6_IO2 analog switch enable
            using G6_IO3 = Field<22, 1>;    // G6_IO3 analog switch enable
            using G6_IO4 = Field<23, 1>;    // G6_IO4 analog switch enable
            using G7_IO1 = Field<24, 1>;    // G7_IO1 analog switch enable
            using G7_IO2 = Field<25, 1>;    // G7_IO2 analog switch enable
            using G7_IO3 = Field<26, 1>;    // G7_IO3 analog switch enable
            using G7_IO4 = Field<27, 1>;    // G7_IO4 analog switch enable
            using G8_IO1 = Field<28, 1>;    // G8_IO1 analog switch enable
            using G8_IO2 = Field<29, 1>;    // G8_IO2 analog switch enable
            using G8_IO3 = Field<30, 1>;    // G8_IO3 analog switch enable
            using G8_IO4 = Field<31, 1>;    // G8_IO4 analog switch enable
        };

        // I/O sampling control register
        struct IOSCR : public Register<0x40024020> {
            using G1_IO1 = Field<0, 1>;    // G1_IO1 sampling mode
            using G1_IO2 = Field<1, 1>;    // G1_IO2 sampling mode
            using G1_IO3 = Field<2, 1>;    // G1_IO3 sampling mode
            using G1_IO4 = Field<3, 1>;    // G1_IO4 sampling mode
            using G2_IO1 = Field<4, 1>;    // G2_IO1 sampling mode
            using G2_IO2 = Field<5, 1>;    // G2_IO2 sampling mode
            using G2_IO3 = Field<6, 1>;    // G2_IO3 sampling mode
            using G2_IO4 = Field<7, 1>;    // G2_IO4 sampling mode
            using G3_IO1 = Field<8, 1>;    // G3_IO1 sampling mode
            using G3_IO2 = Field<9, 1>;    // G3_IO2 sampling mode
            using G3_IO3 = Field<10, 1>;    // G3_IO3 sampling mode
            using G3_IO4 = Field<11, 1>;    // G3_IO4 sampling mode
            using G4_IO1 = Field<12, 1>;    // G4_IO1 sampling mode
            using G4_IO2 = Field<13, 1>;    // G4_IO2 sampling mode
            using G4_IO3 = Field<14, 1>;    // G4_IO3 sampling mode
            using G4_IO4 = Field<15, 1>;    // G4_IO4 sampling mode
            using G5_IO1 = Field<16, 1>;    // G5_IO1 sampling mode
            using G5_IO2 = Field<17, 1>;    // G5_IO2 sampling mode
            using G5_IO3 = Field<18, 1>;    // G5_IO3 sampling mode
            using G5_IO4 = Field<19, 1>;    // G5_IO4 sampling mode
            using G6_IO1 = Field<20, 1>;    // G6_IO1 sampling mode
            using G6_IO2 = Field<21, 1>;    // G6_IO2 sampling mode
            using G6_IO3 = Field<22, 1>;    // G6_IO3 sampling mode
            using G6_IO4 = Field<23, 1>;    // G6_IO4 sampling mode
            using G7_IO1 = Field<24, 1>;    // G7_IO1 sampling mode
            using G7_IO2 = Field<25, 1>;    // G7_IO2 sampling mode
            using G7_IO3 = Field<26, 1>;    // G7_IO3 sampling mode
            using G7_IO4 = Field<27, 1>;    // G7_IO4 sampling mode
            using G8_IO1 = Field<28, 1>;    // G8_IO1 sampling mode
            using G8_IO2 = Field<29, 1>;    // G8_IO2 sampling mode
            using G8_IO3 = Field<30, 1>;    // G8_IO3 sampling mode
            using G8_IO4 = Field<31, 1>;    // G8_IO4 sampling mode
        };

        // I/O channel control register
        struct IOCCR : public Register<0x40024028> {
            using G1_IO1 = Field<0, 1>;    // G1_IO1 channel mode
            using G1_IO2 = Field<1, 1>;    // G1_IO2 channel mode
            using G1_IO3 = Field<2, 1>;    // G1_IO3 channel mode
            using G1_IO4 = Field<3, 1>;    // G1_IO4 channel mode
            using G2_IO1 = Field<4, 1>;    // G2_IO1 channel mode
            using G2_IO2 = Field<5, 1>;    // G2_IO2 channel mode
            using G2_IO3 = Field<6, 1>;    // G2_IO3 channel mode
            using G2_IO4 = Field<7, 1>;    // G2_IO4 channel mode
            using G3_IO1 = Field<8, 1>;    // G3_IO1 channel mode
            using G3_IO2 = Field<9, 1>;    // G3_IO2 channel mode
            using G3_IO3 = Field<10, 1>;    // G3_IO3 channel mode
            using G3_IO4 = Field<11, 1>;    // G3_IO4 channel mode
            using G4_IO1 = Field<12, 1>;    // G4_IO1 channel mode
            using G4_IO2 = Field<13, 1>;    // G4_IO2 channel mode
            using G4_IO3 = Field<14, 1>;    // G4_IO3 channel mode
            using G4_IO4 = Field<15, 1>;    // G4_IO4 channel mode
            using G5_IO1 = Field<16, 1>;    // G5_IO1 channel mode
            using G5_IO2 = Field<17, 1>;    // G5_IO2 channel mode
            using G5_IO3 = Field<18, 1>;    // G5_IO3 channel mode
            using G5_IO4 = Field<19, 1>;    // G5_IO4 channel mode
            using G6_IO1 = Field<20, 1>;    // G6_IO1 channel mode
            using G6_IO2 = Field<21, 1>;    // G6_IO2 channel mode
            using G6_IO3 = Field<22, 1>;    // G6_IO3 channel mode
            using G6_IO4 = Field<23, 1>;    // G6_IO4 channel mode
            using G7_IO1 = Field<24, 1>;    // G7_IO1 channel mode
            using G7_IO2 = Field<25, 1>;    // G7_IO2 channel mode
            using G7_IO3 = Field<26, 1>;    // G7_IO3 channel mode
            using G7_IO4 = Field<27, 1>;    // G7_IO4 channel mode
            using G8_IO1 = Field<28, 1>;    // G8_IO1 channel mode
            using G8_IO2 = Field<29, 1>;    // G8_IO2 channel mode
            using G8_IO3 = Field<30, 1>;    // G8_IO3 channel mode
            using G8_IO4 = Field<31, 1>;    // G8_IO4 channel mode
        };

        // I/O group control status register
        struct IOGCSR : public Register<0x40024030> {
            using G8S = Field<23, 1>;    // Analog I/O group x status
            using G7S = Field<22, 1>;    // Analog I/O group x status
            using G6S = Field<21, 1>;    // Analog I/O group x status
            using G5S = Field<20, 1>;    // Analog I/O group x status
            using G4S = Field<19, 1>;    // Analog I/O group x status
            using G3S = Field<18, 1>;    // Analog I/O group x status
            using G2S = Field<17, 1>;    // Analog I/O group x status
            using G1S = Field<16, 1>;    // Analog I/O group x status
            using G8E = Field<7, 1>;    // Analog I/O group x enable
            using G7E = Field<6, 1>;    // Analog I/O group x enable
            using G6E = Field<5, 1>;    // Analog I/O group x enable
            using G5E = Field<4, 1>;    // Analog I/O group x enable
            using G4E = Field<3, 1>;    // Analog I/O group x enable
            using G3E = Field<2, 1>;    // Analog I/O group x enable
            using G2E = Field<1, 1>;    // Analog I/O group x enable
            using G1E = Field<0, 1>;    // Analog I/O group x enable
        };

        // I/O group x counter register
        struct IOG1CR : public Register<0x40024034> {
            using CNT = Field<0, 14>;    // Counter value
        };

        // I/O group x counter register
        struct IOG2CR : public Register<0x40024038> {
            using CNT = Field<0, 14>;    // Counter value
        };

        // I/O group x counter register
        struct IOG3CR : public Register<0x4002403c> {
            using CNT = Field<0, 14>;    // Counter value
        };

        // I/O group x counter register
        struct IOG4CR : public Register<0x40024040> {
            using CNT = Field<0, 14>;    // Counter value
        };

        // I/O group x counter register
        struct IOG5CR : public Register<0x40024044> {
            using CNT = Field<0, 14>;    // Counter value
        };

        // I/O group x counter register
        struct IOG6CR : public Register<0x40024048> {
            using CNT = Field<0, 14>;    // Counter value
        };

        // I/O group x counter register
        struct IOG7CR : public Register<0x4002404c> {
            using CNT = Field<0, 14>;    // Counter value
        };

        // I/O group x counter register
        struct IOG8CR : public Register<0x40024050> {
            using CNT = Field<0, 14>;    // Counter value
        };

    };

    // cyclic redundancy check calculation unit
    struct CRC {
        // Data register
        struct DR : public Register<0x40023000> {
            using Field = Field<0, 32>;    // Data register bits
        };

        // Independent data register
        struct IDR : public Register<0x40023004> {
            using Field = Field<0, 8>;    // General-purpose 8-bit data register bits
        };

        // Control register
        struct CR : public Register<0x40023008> {
            using RESET = Field<0, 1>;    // reset bit
            using POLYSIZE = Field<3, 2>;    // Polynomial size
            using REV_IN = Field<5, 2>;    // Reverse input data
            using REV_OUT = Field<7, 1>;    // Reverse output data
        };

        // Initial CRC value
        struct INIT : public Register<0x40023010> {
            using Field = Field<0, 32>;    // Programmable initial CRC value
        };

        // CRC polynomial
        struct POL : public Register<0x40023014> {
            using Field = Field<0, 32>;    // Programmable polynomial
        };

    };

    // Flash
    struct Flash {
        // Flash access control register
        struct ACR : public Register<0x40022000> {
            using LATENCY = Field<0, 3>;    // LATENCY
            using PRFTBE = Field<4, 1>;    // PRFTBE
            using PRFTBS = Field<5, 1>;    // PRFTBS
        };

        // Flash key register
        struct KEYR : public Register<0x40022004> {
            using FKEYR = Field<0, 32>;    // Flash Key
        };

        // Flash option key register
        struct OPTKEYR : public Register<0x40022008> {
            using Field = Field<0, 32>;    // Option byte key
        };

        // Flash status register
        struct SR : public Register<0x4002200c> {
            using EOP = Field<5, 1>;    // End of operation
            using WRPRT = Field<4, 1>;    // Write protection error
            using PGERR = Field<2, 1>;    // Programming error
            using BSY = Field<0, 1>;    // Busy
        };

        // Flash control register
        struct CR : public Register<0x40022010> {
            using FORCE_OPTLOAD = Field<13, 1>;    // Force option byte loading
            using EOPIE = Field<12, 1>;    // End of operation interrupt enable
            using ERRIE = Field<10, 1>;    // Error interrupt enable
            using OPTWRE = Field<9, 1>;    // Option bytes write enable
            using LOCK = Field<7, 1>;    // Lock
            using STRT = Field<6, 1>;    // Start
            using OPTER = Field<5, 1>;    // Option byte erase
            using OPTPG = Field<4, 1>;    // Option byte programming
            using MER = Field<2, 1>;    // Mass erase
            using PER = Field<1, 1>;    // Page erase
            using PG = Field<0, 1>;    // Programming
        };

        // Flash address register
        struct AR : public Register<0x40022014> {
            using FAR = Field<0, 32>;    // Flash address
        };

        // Option byte register
        struct OBR : public Register<0x4002201c> {
            using OPTERR = Field<0, 1>;    // Option byte error
            using LEVEL1_PROT = Field<1, 1>;    // Level 1 protection status
            using LEVEL2_PROT = Field<2, 1>;    // Level 2 protection status
            using WDG_SW = Field<8, 1>;    // WDG_SW
            using nRST_STOP = Field<9, 1>;    // nRST_STOP
            using nRST_STDBY = Field<10, 1>;    // nRST_STDBY
            using BOOT1 = Field<12, 1>;    // BOOT1
            using VDDA_MONITOR = Field<13, 1>;    // VDDA_MONITOR
            using SRAM_PARITY_CHECK = Field<14, 1>;    // SRAM_PARITY_CHECK
            using Data0 = Field<16, 8>;    // Data0
            using Data1 = Field<24, 8>;    // Data1
        };

        // Write protection register
        struct WRPR : public Register<0x40022020> {
            using WRP = Field<0, 32>;    // Write protect
        };

    };

    // Reset and clock control
    struct RCC {
        // Clock control register
        struct CR : public Register<0x40021000> {
            using HSION = Field<0, 1>;    // Internal High Speed clock enable
            using HSIRDY = Field<1, 1>;    // Internal High Speed clock ready flag
            using HSITRIM = Field<3, 5>;    // Internal High Speed clock trimming
            using HSICAL = Field<8, 8>;    // Internal High Speed clock Calibration
            using HSEON = Field<16, 1>;    // External High Speed clock enable
            using HSERDY = Field<17, 1>;    // External High Speed clock ready flag
            using HSEBYP = Field<18, 1>;    // External High Speed clock Bypass
            using CSSON = Field<19, 1>;    // Clock Security System enable
            using PLLON = Field<24, 1>;    // PLL enable
            using PLLRDY = Field<25, 1>;    // PLL clock ready flag
        };

        // Clock configuration register (RCC_CFGR)
        struct CFGR : public Register<0x40021004> {
            using SW = Field<0, 2>;    // System clock Switch
            using SWS = Field<2, 2>;    // System Clock Switch Status
            using HPRE = Field<4, 4>;    // AHB prescaler
            using PPRE1 = Field<8, 3>;    // APB Low speed prescaler (APB1)
            using PPRE2 = Field<11, 3>;    // APB high speed prescaler (APB2)
            using PLLSRC = Field<16, 1>;    // PLL entry clock source
            using PLLXTPRE = Field<17, 1>;    // HSE divider for PLL entry
            using PLLMUL = Field<18, 4>;    // PLL Multiplication Factor
            using USBPRES = Field<22, 1>;    // USB prescaler
            using MCO = Field<24, 3>;    // Microcontroller clock output
            using MCOF = Field<28, 1>;    // Microcontroller Clock Output Flag
            using I2SSRC = Field<23, 1>;    // I2S external clock source selection
        };

        // Clock interrupt register (RCC_CIR)
        struct CIR : public Register<0x40021008> {
            using LSIRDYF = Field<0, 1>;    // LSI Ready Interrupt flag
            using LSERDYF = Field<1, 1>;    // LSE Ready Interrupt flag
            using HSIRDYF = Field<2, 1>;    // HSI Ready Interrupt flag
            using HSERDYF = Field<3, 1>;    // HSE Ready Interrupt flag
            using PLLRDYF = Field<4, 1>;    // PLL Ready Interrupt flag
            using CSSF = Field<7, 1>;    // Clock Security System Interrupt flag
            using LSIRDYIE = Field<8, 1>;    // LSI Ready Interrupt Enable
            using LSERDYIE = Field<9, 1>;    // LSE Ready Interrupt Enable
            using HSIRDYIE = Field<10, 1>;    // HSI Ready Interrupt Enable
            using HSERDYIE = Field<11, 1>;    // HSE Ready Interrupt Enable
            using PLLRDYIE = Field<12, 1>;    // PLL Ready Interrupt Enable
            using LSIRDYC = Field<16, 1>;    // LSI Ready Interrupt Clear
            using LSERDYC = Field<17, 1>;    // LSE Ready Interrupt Clear
            using HSIRDYC = Field<18, 1>;    // HSI Ready Interrupt Clear
            using HSERDYC = Field<19, 1>;    // HSE Ready Interrupt Clear
            using PLLRDYC = Field<20, 1>;    // PLL Ready Interrupt Clear
            using CSSC = Field<23, 1>;    // Clock security system interrupt clear
        };

        // APB2 peripheral reset register (RCC_APB2RSTR)
        struct APB2RSTR : public Register<0x4002100c> {
            using SYSCFGRST = Field<0, 1>;    // SYSCFG and COMP reset
            using TIM1RST = Field<11, 1>;    // TIM1 timer reset
            using SPI1RST = Field<12, 1>;    // SPI 1 reset
            using TIM8RST = Field<13, 1>;    // TIM8 timer reset
            using USART1RST = Field<14, 1>;    // USART1 reset
            using TIM15RST = Field<16, 1>;    // TIM15 timer reset
            using TIM16RST = Field<17, 1>;    // TIM16 timer reset
            using TIM17RST = Field<18, 1>;    // TIM17 timer reset
        };

        // APB1 peripheral reset register (RCC_APB1RSTR)
        struct APB1RSTR : public Register<0x40021010> {
            using TIM2RST = Field<0, 1>;    // Timer 2 reset
            using TIM3RST = Field<1, 1>;    // Timer 3 reset
            using TIM4RST = Field<2, 1>;    // Timer 14 reset
            using TIM6RST = Field<4, 1>;    // Timer 6 reset
            using TIM7RST = Field<5, 1>;    // Timer 7 reset
            using WWDGRST = Field<11, 1>;    // Window watchdog reset
            using SPI2RST = Field<14, 1>;    // SPI2 reset
            using SPI3RST = Field<15, 1>;    // SPI3 reset
            using USART2RST = Field<17, 1>;    // USART 2 reset
            using USART3RST = Field<18, 1>;    // USART3 reset
            using UART4RST = Field<19, 1>;    // UART 4 reset
            using UART5RST = Field<20, 1>;    // UART 5 reset
            using I2C1RST = Field<21, 1>;    // I2C1 reset
            using I2C2RST = Field<22, 1>;    // I2C2 reset
            using USBRST = Field<23, 1>;    // USB reset
            using CANRST = Field<25, 1>;    // CAN reset
            using PWRRST = Field<28, 1>;    // Power interface reset
            using DACRST = Field<29, 1>;    // DAC interface reset
        };

        // AHB Peripheral Clock enable register (RCC_AHBENR)
        struct AHBENR : public Register<0x40021014> {
            using DMAEN = Field<0, 1>;    // DMA1 clock enable
            using DMA2EN = Field<1, 1>;    // DMA2 clock enable
            using SRAMEN = Field<2, 1>;    // SRAM interface clock enable
            using FLITFEN = Field<4, 1>;    // FLITF clock enable
            using CRCEN = Field<6, 1>;    // CRC clock enable
            using IOPAEN = Field<17, 1>;    // I/O port A clock enable
            using IOPBEN = Field<18, 1>;    // I/O port B clock enable
            using IOPCEN = Field<19, 1>;    // I/O port C clock enable
            using IOPDEN = Field<20, 1>;    // I/O port D clock enable
            using IOPEEN = Field<21, 1>;    // I/O port E clock enable
            using IOPFEN = Field<22, 1>;    // I/O port F clock enable
            using TSCEN = Field<24, 1>;    // Touch sensing controller clock enable
            using ADC12EN = Field<28, 1>;    // ADC1 and ADC2 clock enable
            using ADC34EN = Field<29, 1>;    // ADC3 and ADC4 clock enable
        };

        // APB2 peripheral clock enable register (RCC_APB2ENR)
        struct APB2ENR : public Register<0x40021018> {
            using SYSCFGEN = Field<0, 1>;    // SYSCFG clock enable
            using TIM1EN = Field<11, 1>;    // TIM1 Timer clock enable
            using SPI1EN = Field<12, 1>;    // SPI 1 clock enable
            using TIM8EN = Field<13, 1>;    // TIM8 Timer clock enable
            using USART1EN = Field<14, 1>;    // USART1 clock enable
            using TIM15EN = Field<16, 1>;    // TIM15 timer clock enable
            using TIM16EN = Field<17, 1>;    // TIM16 timer clock enable
            using TIM17EN = Field<18, 1>;    // TIM17 timer clock enable
        };

        // APB1 peripheral clock enable register (RCC_APB1ENR)
        struct APB1ENR : public Register<0x4002101c> {
            using TIM2EN = Field<0, 1>;    // Timer 2 clock enable
            using TIM3EN = Field<1, 1>;    // Timer 3 clock enable
            using TIM4EN = Field<2, 1>;    // Timer 4 clock enable
            using TIM6EN = Field<4, 1>;    // Timer 6 clock enable
            using TIM7EN = Field<5, 1>;    // Timer 7 clock enable
            using WWDGEN = Field<11, 1>;    // Window watchdog clock enable
            using SPI2EN = Field<14, 1>;    // SPI 2 clock enable
            using SPI3EN = Field<15, 1>;    // SPI 3 clock enable
            using USART2EN = Field<17, 1>;    // USART 2 clock enable
            using I2C1EN = Field<21, 1>;    // I2C 1 clock enable
            using I2C2EN = Field<22, 1>;    // I2C 2 clock enable
            using USBEN = Field<23, 1>;    // USB clock enable
            using CANEN = Field<25, 1>;    // CAN clock enable
            using PWREN = Field<28, 1>;    // Power interface clock enable
            using DACEN = Field<29, 1>;    // DAC interface clock enable
        };

        // Backup domain control register (RCC_BDCR)
        struct BDCR : public Register<0x40021020> {
            using LSEON = Field<0, 1>;    // External Low Speed oscillator enable
            using LSERDY = Field<1, 1>;    // External Low Speed oscillator ready
            using LSEBYP = Field<2, 1>;    // External Low Speed oscillator bypass
            using LSEDRV = Field<3, 2>;    // LSE oscillator drive capability
            using RTCSEL = Field<8, 2>;    // RTC clock source selection
            using RTCEN = Field<15, 1>;    // RTC clock enable
            using BDRST = Field<16, 1>;    // Backup domain software reset
        };

        // Control/status register (RCC_CSR)
        struct CSR : public Register<0x40021024> {
            using LSION = Field<0, 1>;    // Internal low speed oscillator enable
            using LSIRDY = Field<1, 1>;    // Internal low speed oscillator ready
            using RMVF = Field<24, 1>;    // Remove reset flag
            using OBLRSTF = Field<25, 1>;    // Option byte loader reset flag
            using PINRSTF = Field<26, 1>;    // PIN reset flag
            using PORRSTF = Field<27, 1>;    // POR/PDR reset flag
            using SFTRSTF = Field<28, 1>;    // Software reset flag
            using IWDGRSTF = Field<29, 1>;    // Independent watchdog reset flag
            using WWDGRSTF = Field<30, 1>;    // Window watchdog reset flag
            using LPWRRSTF = Field<31, 1>;    // Low-power reset flag
        };

        // AHB peripheral reset register
        struct AHBRSTR : public Register<0x40021028> {
            using IOPARST = Field<17, 1>;    // I/O port A reset
            using IOPBRST = Field<18, 1>;    // I/O port B reset
            using IOPCRST = Field<19, 1>;    // I/O port C reset
            using IOPDRST = Field<20, 1>;    // I/O port D reset
            using IOPERST = Field<21, 1>;    // I/O port E reset
            using IOPFRST = Field<22, 1>;    // I/O port F reset
            using TSCRST = Field<24, 1>;    // Touch sensing controller reset
            using ADC12RST = Field<28, 1>;    // ADC1 and ADC2 reset
            using ADC34RST = Field<29, 1>;    // ADC3 and ADC4 reset
        };

        // Clock configuration register 2
        struct CFGR2 : public Register<0x4002102c> {
            using PREDIV = Field<0, 4>;    // PREDIV division factor
            using ADC12PRES = Field<4, 5>;    // ADC1 and ADC2 prescaler
            using ADC34PRES = Field<9, 5>;    // ADC3 and ADC4 prescaler
        };

        // Clock configuration register 3
        struct CFGR3 : public Register<0x40021030> {
            using USART1SW = Field<0, 2>;    // USART1 clock source selection
            using I2C1SW = Field<4, 1>;    // I2C1 clock source selection
            using I2C2SW = Field<5, 1>;    // I2C2 clock source selection
            using USART2SW = Field<16, 2>;    // USART2 clock source selection
            using USART3SW = Field<18, 2>;    // USART3 clock source selection
            using TIM1SW = Field<8, 1>;    // Timer1 clock source selection
            using TIM8SW = Field<9, 1>;    // Timer8 clock source selection
            using UART4SW = Field<20, 2>;    // UART4 clock source selection
            using UART5SW = Field<22, 2>;    // UART5 clock source selection
        };

    };

    // DMA controller 1
    struct DMA1 {
        // DMA interrupt status register (DMA_ISR)
        struct ISR : public Register<0x40020000> {
            using GIF1 = Field<0, 1>;    // Channel 1 Global interrupt flag
            using TCIF1 = Field<1, 1>;    // Channel 1 Transfer Complete flag
            using HTIF1 = Field<2, 1>;    // Channel 1 Half Transfer Complete flag
            using TEIF1 = Field<3, 1>;    // Channel 1 Transfer Error flag
            using GIF2 = Field<4, 1>;    // Channel 2 Global interrupt flag
            using TCIF2 = Field<5, 1>;    // Channel 2 Transfer Complete flag
            using HTIF2 = Field<6, 1>;    // Channel 2 Half Transfer Complete flag
            using TEIF2 = Field<7, 1>;    // Channel 2 Transfer Error flag
            using GIF3 = Field<8, 1>;    // Channel 3 Global interrupt flag
            using TCIF3 = Field<9, 1>;    // Channel 3 Transfer Complete flag
            using HTIF3 = Field<10, 1>;    // Channel 3 Half Transfer Complete flag
            using TEIF3 = Field<11, 1>;    // Channel 3 Transfer Error flag
            using GIF4 = Field<12, 1>;    // Channel 4 Global interrupt flag
            using TCIF4 = Field<13, 1>;    // Channel 4 Transfer Complete flag
            using HTIF4 = Field<14, 1>;    // Channel 4 Half Transfer Complete flag
            using TEIF4 = Field<15, 1>;    // Channel 4 Transfer Error flag
            using GIF5 = Field<16, 1>;    // Channel 5 Global interrupt flag
            using TCIF5 = Field<17, 1>;    // Channel 5 Transfer Complete flag
            using HTIF5 = Field<18, 1>;    // Channel 5 Half Transfer Complete flag
            using TEIF5 = Field<19, 1>;    // Channel 5 Transfer Error flag
            using GIF6 = Field<20, 1>;    // Channel 6 Global interrupt flag
            using TCIF6 = Field<21, 1>;    // Channel 6 Transfer Complete flag
            using HTIF6 = Field<22, 1>;    // Channel 6 Half Transfer Complete flag
            using TEIF6 = Field<23, 1>;    // Channel 6 Transfer Error flag
            using GIF7 = Field<24, 1>;    // Channel 7 Global interrupt flag
            using TCIF7 = Field<25, 1>;    // Channel 7 Transfer Complete flag
            using HTIF7 = Field<26, 1>;    // Channel 7 Half Transfer Complete flag
            using TEIF7 = Field<27, 1>;    // Channel 7 Transfer Error flag
        };

        // DMA interrupt flag clear register (DMA_IFCR)
        struct IFCR : public Register<0x40020004> {
            using CGIF1 = Field<0, 1>;    // Channel 1 Global interrupt clear
            using CTCIF1 = Field<1, 1>;    // Channel 1 Transfer Complete clear
            using CHTIF1 = Field<2, 1>;    // Channel 1 Half Transfer clear
            using CTEIF1 = Field<3, 1>;    // Channel 1 Transfer Error clear
            using CGIF2 = Field<4, 1>;    // Channel 2 Global interrupt clear
            using CTCIF2 = Field<5, 1>;    // Channel 2 Transfer Complete clear
            using CHTIF2 = Field<6, 1>;    // Channel 2 Half Transfer clear
            using CTEIF2 = Field<7, 1>;    // Channel 2 Transfer Error clear
            using CGIF3 = Field<8, 1>;    // Channel 3 Global interrupt clear
            using CTCIF3 = Field<9, 1>;    // Channel 3 Transfer Complete clear
            using CHTIF3 = Field<10, 1>;    // Channel 3 Half Transfer clear
            using CTEIF3 = Field<11, 1>;    // Channel 3 Transfer Error clear
            using CGIF4 = Field<12, 1>;    // Channel 4 Global interrupt clear
            using CTCIF4 = Field<13, 1>;    // Channel 4 Transfer Complete clear
            using CHTIF4 = Field<14, 1>;    // Channel 4 Half Transfer clear
            using CTEIF4 = Field<15, 1>;    // Channel 4 Transfer Error clear
            using CGIF5 = Field<16, 1>;    // Channel 5 Global interrupt clear
            using CTCIF5 = Field<17, 1>;    // Channel 5 Transfer Complete clear
            using CHTIF5 = Field<18, 1>;    // Channel 5 Half Transfer clear
            using CTEIF5 = Field<19, 1>;    // Channel 5 Transfer Error clear
            using CGIF6 = Field<20, 1>;    // Channel 6 Global interrupt clear
            using CTCIF6 = Field<21, 1>;    // Channel 6 Transfer Complete clear
            using CHTIF6 = Field<22, 1>;    // Channel 6 Half Transfer clear
            using CTEIF6 = Field<23, 1>;    // Channel 6 Transfer Error clear
            using CGIF7 = Field<24, 1>;    // Channel 7 Global interrupt clear
            using CTCIF7 = Field<25, 1>;    // Channel 7 Transfer Complete clear
            using CHTIF7 = Field<26, 1>;    // Channel 7 Half Transfer clear
            using CTEIF7 = Field<27, 1>;    // Channel 7 Transfer Error clear
        };

        // DMA channel configuration register (DMA_CCR)
        struct CCR1 : public Register<0x40020008> {
            using EN = Field<0, 1>;    // Channel enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<2, 1>;    // Half Transfer interrupt enable
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using DIR = Field<4, 1>;    // Data transfer direction
            using CIRC = Field<5, 1>;    // Circular mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using MINC = Field<7, 1>;    // Memory increment mode
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MSIZE = Field<10, 2>;    // Memory size
            using PL = Field<12, 2>;    // Channel Priority level
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
        };

        // DMA channel 1 number of data register
        struct CNDTR1 : public Register<0x4002000c> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // DMA channel 1 peripheral address register
        struct CPAR1 : public Register<0x40020010> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel 1 memory address register
        struct CMAR1 : public Register<0x40020014> {
            using MA = Field<0, 32>;    // Memory address
        };

        // DMA channel configuration register (DMA_CCR)
        struct CCR2 : public Register<0x4002001c> {
            using EN = Field<0, 1>;    // Channel enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<2, 1>;    // Half Transfer interrupt enable
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using DIR = Field<4, 1>;    // Data transfer direction
            using CIRC = Field<5, 1>;    // Circular mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using MINC = Field<7, 1>;    // Memory increment mode
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MSIZE = Field<10, 2>;    // Memory size
            using PL = Field<12, 2>;    // Channel Priority level
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
        };

        // DMA channel 2 number of data register
        struct CNDTR2 : public Register<0x40020020> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // DMA channel 2 peripheral address register
        struct CPAR2 : public Register<0x40020024> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel 2 memory address register
        struct CMAR2 : public Register<0x40020028> {
            using MA = Field<0, 32>;    // Memory address
        };

        // DMA channel configuration register (DMA_CCR)
        struct CCR3 : public Register<0x40020030> {
            using EN = Field<0, 1>;    // Channel enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<2, 1>;    // Half Transfer interrupt enable
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using DIR = Field<4, 1>;    // Data transfer direction
            using CIRC = Field<5, 1>;    // Circular mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using MINC = Field<7, 1>;    // Memory increment mode
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MSIZE = Field<10, 2>;    // Memory size
            using PL = Field<12, 2>;    // Channel Priority level
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
        };

        // DMA channel 3 number of data register
        struct CNDTR3 : public Register<0x40020034> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // DMA channel 3 peripheral address register
        struct CPAR3 : public Register<0x40020038> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel 3 memory address register
        struct CMAR3 : public Register<0x4002003c> {
            using MA = Field<0, 32>;    // Memory address
        };

        // DMA channel configuration register (DMA_CCR)
        struct CCR4 : public Register<0x40020044> {
            using EN = Field<0, 1>;    // Channel enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<2, 1>;    // Half Transfer interrupt enable
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using DIR = Field<4, 1>;    // Data transfer direction
            using CIRC = Field<5, 1>;    // Circular mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using MINC = Field<7, 1>;    // Memory increment mode
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MSIZE = Field<10, 2>;    // Memory size
            using PL = Field<12, 2>;    // Channel Priority level
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
        };

        // DMA channel 4 number of data register
        struct CNDTR4 : public Register<0x40020048> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // DMA channel 4 peripheral address register
        struct CPAR4 : public Register<0x4002004c> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel 4 memory address register
        struct CMAR4 : public Register<0x40020050> {
            using MA = Field<0, 32>;    // Memory address
        };

        // DMA channel configuration register (DMA_CCR)
        struct CCR5 : public Register<0x40020058> {
            using EN = Field<0, 1>;    // Channel enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<2, 1>;    // Half Transfer interrupt enable
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using DIR = Field<4, 1>;    // Data transfer direction
            using CIRC = Field<5, 1>;    // Circular mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using MINC = Field<7, 1>;    // Memory increment mode
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MSIZE = Field<10, 2>;    // Memory size
            using PL = Field<12, 2>;    // Channel Priority level
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
        };

        // DMA channel 5 number of data register
        struct CNDTR5 : public Register<0x4002005c> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // DMA channel 5 peripheral address register
        struct CPAR5 : public Register<0x40020060> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel 5 memory address register
        struct CMAR5 : public Register<0x40020064> {
            using MA = Field<0, 32>;    // Memory address
        };

        // DMA channel configuration register (DMA_CCR)
        struct CCR6 : public Register<0x4002006c> {
            using EN = Field<0, 1>;    // Channel enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<2, 1>;    // Half Transfer interrupt enable
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using DIR = Field<4, 1>;    // Data transfer direction
            using CIRC = Field<5, 1>;    // Circular mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using MINC = Field<7, 1>;    // Memory increment mode
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MSIZE = Field<10, 2>;    // Memory size
            using PL = Field<12, 2>;    // Channel Priority level
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
        };

        // DMA channel 6 number of data register
        struct CNDTR6 : public Register<0x40020070> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // DMA channel 6 peripheral address register
        struct CPAR6 : public Register<0x40020074> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel 6 memory address register
        struct CMAR6 : public Register<0x40020078> {
            using MA = Field<0, 32>;    // Memory address
        };

        // DMA channel configuration register (DMA_CCR)
        struct CCR7 : public Register<0x40020080> {
            using EN = Field<0, 1>;    // Channel enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<2, 1>;    // Half Transfer interrupt enable
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using DIR = Field<4, 1>;    // Data transfer direction
            using CIRC = Field<5, 1>;    // Circular mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using MINC = Field<7, 1>;    // Memory increment mode
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MSIZE = Field<10, 2>;    // Memory size
            using PL = Field<12, 2>;    // Channel Priority level
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
        };

        // DMA channel 7 number of data register
        struct CNDTR7 : public Register<0x40020084> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // DMA channel 7 peripheral address register
        struct CPAR7 : public Register<0x40020088> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel 7 memory address register
        struct CMAR7 : public Register<0x4002008c> {
            using MA = Field<0, 32>;    // Memory address
        };

    };

    // General purpose timer
    struct TIM2 {
        // control register 1
        struct CR1 : public Register<0x40000000> {
            using CEN = Field<0, 1>;    // Counter enable
            using UDIS = Field<1, 1>;    // Update disable
            using URS = Field<2, 1>;    // Update request source
            using OPM = Field<3, 1>;    // One-pulse mode
            using DIR = Field<4, 1>;    // Direction
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CKD = Field<8, 2>;    // Clock division
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
        };

        // control register 2
        struct CR2 : public Register<0x40000004> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000008> {
            using SMS = Field<0, 3>;    // Slave mode selection
            using OCCS = Field<3, 1>;    // OCREF clear selection
            using TS = Field<4, 3>;    // Trigger selection
            using MSM = Field<7, 1>;    // Master/Slave mode
            using ETF = Field<8, 4>;    // External trigger filter
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ECE = Field<14, 1>;    // External clock enable
            using ETP = Field<15, 1>;    // External trigger polarity
            using SMS_3 = Field<16, 1>;    // Slave mode selection bit3
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000000c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000010> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40000014> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40000018> {
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
            using OC1FE = Field<2, 1>;    // Output compare 1 fast enable
            using OC1PE = Field<3, 1>;    // Output compare 1 preload enable
            using OC1M = Field<4, 3>;    // Output compare 1 mode
            using OC1CE = Field<7, 1>;    // Output compare 1 clear enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC2FE = Field<10, 1>;    // Output compare 2 fast enable
            using OC2PE = Field<11, 1>;    // Output compare 2 preload enable
            using OC2M = Field<12, 3>;    // Output compare 2 mode
            using OC2CE = Field<15, 1>;    // Output compare 2 clear enable
            using OC1M_3 = Field<16, 1>;    // Output compare 1 mode bit 3
            using OC2M_3 = Field<24, 1>;    // Output compare 2 mode bit 3
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000018> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4000001c> {
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using O24CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC3M_3 = Field<16, 1>;    // Output compare 3 mode bit3
            using OC4M_3 = Field<24, 1>;    // Output compare 4 mode bit3
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000001c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000020> {
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4NP = Field<15, 1>;    // Capture/Compare 3 output Polarity
        };

        // counter
        struct CNT : public Register<0x40000024> {
            using CNTL = Field<0, 16>;    // Low counter value
            using CNTH = Field<16, 15>;    // High counter value
            using CNT_or_UIFCPY = Field<31, 1>;    // if IUFREMAP=0 than CNT with read write access else UIFCPY with read only access
        };

        // prescaler
        struct PSC : public Register<0x40000028> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000002c> {
            using ARRL = Field<0, 16>;    // Low Auto-reload value
            using ARRH = Field<16, 16>;    // High Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000034> {
            using CCR1L = Field<0, 16>;    // Low Capture/Compare 1 value
            using CCR1H = Field<16, 16>;    // High Capture/Compare 1 value (on TIM2)
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40000038> {
            using CCR2L = Field<0, 16>;    // Low Capture/Compare 2 value
            using CCR2H = Field<16, 16>;    // High Capture/Compare 2 value (on TIM2)
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4000003c> {
            using CCR3L = Field<0, 16>;    // Low Capture/Compare value
            using CCR3H = Field<16, 16>;    // High Capture/Compare value (on TIM2)
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40000040> {
            using CCR4L = Field<0, 16>;    // Low Capture/Compare value
            using CCR4H = Field<16, 16>;    // High Capture/Compare value (on TIM2)
        };

        // DMA control register
        struct DCR : public Register<0x40000048> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4000004c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

    };

    // General purpose timers
    struct TIM15 {
        // control register 1
        struct CR1 : public Register<0x40014000> {
            using CEN = Field<0, 1>;    // Counter enable
            using UDIS = Field<1, 1>;    // Update disable
            using URS = Field<2, 1>;    // Update request source
            using OPM = Field<3, 1>;    // One-pulse mode
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CKD = Field<8, 2>;    // Clock division
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
        };

        // control register 2
        struct CR2 : public Register<0x40014004> {
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using MMS = Field<4, 3>;    // Master mode selection
            using TI1S = Field<7, 1>;    // TI1 selection
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS2 = Field<10, 1>;    // Output Idle state 2
        };

        // slave mode control register
        struct SMCR : public Register<0x40014008> {
            using SMS = Field<0, 3>;    // Slave mode selection
            using TS = Field<4, 3>;    // Trigger selection
            using MSM = Field<7, 1>;    // Master/Slave mode
            using SMS_3 = Field<16, 1>;    // Slave mode selection bit 3
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001400c> {
            using UIE = Field<0, 1>;    // Update interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using TDE = Field<14, 1>;    // Trigger DMA request enable
        };

        // status register
        struct SR : public Register<0x40014010> {
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40014014> {
            using BG = Field<7, 1>;    // Break generation
            using TG = Field<6, 1>;    // Trigger generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register (output mode)
        struct CCMR1_Output : public Register<0x40014018> {
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC2FE = Field<10, 1>;    // Output Compare 2 fast enable
            using OC2PE = Field<11, 1>;    // Output Compare 2 preload enable
            using OC2M = Field<12, 3>;    // Output Compare 2 mode
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode bit 3
            using OC2M_3 = Field<24, 1>;    // Output Compare 2 mode bit 3
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40014018> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40014020> {
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40014024> {
            using Field = Field<0, 16>;    // counter value
            using UIFCPY = Field<31, 1>;    // UIF copy
        };

        // prescaler
        struct PSC : public Register<0x40014028> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001402c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // repetition counter register
        struct RCR : public Register<0x40014030> {
            using REP = Field<0, 8>;    // Repetition counter value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40014034> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40014038> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40014044> {
            using MOE = Field<15, 1>;    // Main output enable
            using AOE = Field<14, 1>;    // Automatic output enable
            using BKP = Field<13, 1>;    // Break polarity
            using BKE = Field<12, 1>;    // Break enable
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using LOCK = Field<8, 2>;    // Lock configuration
            using DTG = Field<0, 8>;    // Dead-time generator setup
            using BKF = Field<16, 4>;    // Break filter
        };

        // DMA control register
        struct DCR : public Register<0x40014048> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4001404c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

    };

    // General-purpose-timers
    struct TIM16 {
        // control register 1
        struct CR1 : public Register<0x40014400> {
            using CEN = Field<0, 1>;    // Counter enable
            using UDIS = Field<1, 1>;    // Update disable
            using URS = Field<2, 1>;    // Update request source
            using OPM = Field<3, 1>;    // One-pulse mode
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CKD = Field<8, 2>;    // Clock division
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
        };

        // control register 2
        struct CR2 : public Register<0x40014404> {
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001440c> {
            using UIE = Field<0, 1>;    // Update interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using TDE = Field<14, 1>;    // Trigger DMA request enable
        };

        // status register
        struct SR : public Register<0x40014410> {
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40014414> {
            using BG = Field<7, 1>;    // Break generation
            using TG = Field<6, 1>;    // Trigger generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register (output mode)
        struct CCMR1_Output : public Register<0x40014418> {
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40014418> {
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40014420> {
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40014424> {
            using Field = Field<0, 16>;    // counter value
            using UIFCPY = Field<31, 1>;    // UIF Copy
        };

        // prescaler
        struct PSC : public Register<0x40014428> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001442c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // repetition counter register
        struct RCR : public Register<0x40014430> {
            using REP = Field<0, 8>;    // Repetition counter value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40014434> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40014444> {
            using DTG = Field<0, 8>;    // Dead-time generator setup
            using LOCK = Field<8, 2>;    // Lock configuration
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using BKE = Field<12, 1>;    // Break enable
            using BKP = Field<13, 1>;    // Break polarity
            using AOE = Field<14, 1>;    // Automatic output enable
            using MOE = Field<15, 1>;    // Main output enable
            using BKF = Field<16, 4>;    // Break filter
        };

        // DMA control register
        struct DCR : public Register<0x40014448> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4001444c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // option register
        struct OR : public Register<0x40014450> {
        };

    };

    // General purpose timer
    struct TIM17 {
        // control register 1
        struct CR1 : public Register<0x40014800> {
            using CEN = Field<0, 1>;    // Counter enable
            using UDIS = Field<1, 1>;    // Update disable
            using URS = Field<2, 1>;    // Update request source
            using OPM = Field<3, 1>;    // One-pulse mode
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CKD = Field<8, 2>;    // Clock division
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
        };

        // control register 2
        struct CR2 : public Register<0x40014804> {
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001480c> {
            using UIE = Field<0, 1>;    // Update interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using TDE = Field<14, 1>;    // Trigger DMA request enable
        };

        // status register
        struct SR : public Register<0x40014810> {
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40014814> {
            using BG = Field<7, 1>;    // Break generation
            using TG = Field<6, 1>;    // Trigger generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register (output mode)
        struct CCMR1_Output : public Register<0x40014818> {
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40014818> {
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40014820> {
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40014824> {
            using Field = Field<0, 16>;    // counter value
            using UIFCPY = Field<31, 1>;    // UIF Copy
        };

        // prescaler
        struct PSC : public Register<0x40014828> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001482c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // repetition counter register
        struct RCR : public Register<0x40014830> {
            using REP = Field<0, 8>;    // Repetition counter value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40014834> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40014844> {
            using DTG = Field<0, 8>;    // Dead-time generator setup
            using LOCK = Field<8, 2>;    // Lock configuration
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using BKE = Field<12, 1>;    // Break enable
            using BKP = Field<13, 1>;    // Break polarity
            using AOE = Field<14, 1>;    // Automatic output enable
            using MOE = Field<15, 1>;    // Main output enable
            using BKF = Field<16, 4>;    // Break filter
        };

        // DMA control register
        struct DCR : public Register<0x40014848> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4001484c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

    };

    // Universal synchronous asynchronous receiver-transmitter
    struct USART1 {
        // Control register 1
        struct CR1 : public Register<0x40013800> {
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT = Field<21, 5>;    // Driver Enable assertion time
            using DEDT = Field<16, 5>;    // Driver Enable deassertion time
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40013804> {
            using ADD4 = Field<28, 4>;    // Address of the USART node
            using ADD0 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD = Field<21, 2>;    // Auto baud rate mode
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using DATAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x40013808> {
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // IrDA low-power
            using IREN = Field<1, 1>;    // IrDA mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4001380c> {
            using DIV_Mantissa = Field<4, 12>;    // mantissa of USARTDIV
            using DIV_Fraction = Field<0, 4>;    // fraction of USARTDIV
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40013810> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40013814> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public Register<0x40013818> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public Register<0x4001381c> {
            using REACK = Field<22, 1>;    // Receive enable acknowledge flag
            using TEACK = Field<21, 1>;    // Transmit enable acknowledge flag
            using WUF = Field<20, 1>;    // Wakeup from Stop mode flag
            using RWU = Field<19, 1>;    // Receiver wakeup from Mute mode
            using SBKF = Field<18, 1>;    // Send break flag
            using CMF = Field<17, 1>;    // character match flag
            using BUSY = Field<16, 1>;    // Busy flag
            using ABRF = Field<15, 1>;    // Auto baud rate flag
            using ABRE = Field<14, 1>;    // Auto baud rate error
            using EOBF = Field<12, 1>;    // End of block flag
            using RTOF = Field<11, 1>;    // Receiver timeout
            using CTS = Field<10, 1>;    // CTS flag
            using CTSIF = Field<9, 1>;    // CTS interrupt flag
            using LBDF = Field<8, 1>;    // LIN break detection flag
            using TXE = Field<7, 1>;    // Transmit data register empty
            using TC = Field<6, 1>;    // Transmission complete
            using RXNE = Field<5, 1>;    // Read data register not empty
            using IDLE = Field<4, 1>;    // Idle line detected
            using ORE = Field<3, 1>;    // Overrun error
            using NF = Field<2, 1>;    // Noise detected flag
            using FE = Field<1, 1>;    // Framing error
            using PE = Field<0, 1>;    // Parity error
        };

        // Interrupt flag clear register
        struct ICR : public Register<0x40013820> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using EOBCF = Field<12, 1>;    // End of timeout clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public Register<0x40013824> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40013828> {
            using Field = Field<0, 9>;    // Transmit data value
        };

    };

    // Universal synchronous asynchronous receiver-transmitter
    struct USART2 {
        // Control register 1
        struct CR1 : public Register<0x40004400> {
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT = Field<21, 5>;    // Driver Enable assertion time
            using DEDT = Field<16, 5>;    // Driver Enable deassertion time
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40004404> {
            using ADD4 = Field<28, 4>;    // Address of the USART node
            using ADD0 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD = Field<21, 2>;    // Auto baud rate mode
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using DATAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x40004408> {
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // IrDA low-power
            using IREN = Field<1, 1>;    // IrDA mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4000440c> {
            using DIV_Mantissa = Field<4, 12>;    // mantissa of USARTDIV
            using DIV_Fraction = Field<0, 4>;    // fraction of USARTDIV
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40004410> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40004414> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public Register<0x40004418> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public Register<0x4000441c> {
            using REACK = Field<22, 1>;    // Receive enable acknowledge flag
            using TEACK = Field<21, 1>;    // Transmit enable acknowledge flag
            using WUF = Field<20, 1>;    // Wakeup from Stop mode flag
            using RWU = Field<19, 1>;    // Receiver wakeup from Mute mode
            using SBKF = Field<18, 1>;    // Send break flag
            using CMF = Field<17, 1>;    // character match flag
            using BUSY = Field<16, 1>;    // Busy flag
            using ABRF = Field<15, 1>;    // Auto baud rate flag
            using ABRE = Field<14, 1>;    // Auto baud rate error
            using EOBF = Field<12, 1>;    // End of block flag
            using RTOF = Field<11, 1>;    // Receiver timeout
            using CTS = Field<10, 1>;    // CTS flag
            using CTSIF = Field<9, 1>;    // CTS interrupt flag
            using LBDF = Field<8, 1>;    // LIN break detection flag
            using TXE = Field<7, 1>;    // Transmit data register empty
            using TC = Field<6, 1>;    // Transmission complete
            using RXNE = Field<5, 1>;    // Read data register not empty
            using IDLE = Field<4, 1>;    // Idle line detected
            using ORE = Field<3, 1>;    // Overrun error
            using NF = Field<2, 1>;    // Noise detected flag
            using FE = Field<1, 1>;    // Framing error
            using PE = Field<0, 1>;    // Parity error
        };

        // Interrupt flag clear register
        struct ICR : public Register<0x40004420> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using EOBCF = Field<12, 1>;    // End of timeout clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public Register<0x40004424> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40004428> {
            using Field = Field<0, 9>;    // Transmit data value
        };

    };

    // Universal synchronous asynchronous receiver-transmitter
    struct USART3 {
        // Control register 1
        struct CR1 : public Register<0x40004800> {
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT = Field<21, 5>;    // Driver Enable assertion time
            using DEDT = Field<16, 5>;    // Driver Enable deassertion time
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40004804> {
            using ADD4 = Field<28, 4>;    // Address of the USART node
            using ADD0 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD = Field<21, 2>;    // Auto baud rate mode
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using DATAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x40004808> {
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // IrDA low-power
            using IREN = Field<1, 1>;    // IrDA mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4000480c> {
            using DIV_Mantissa = Field<4, 12>;    // mantissa of USARTDIV
            using DIV_Fraction = Field<0, 4>;    // fraction of USARTDIV
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40004810> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40004814> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public Register<0x40004818> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public Register<0x4000481c> {
            using REACK = Field<22, 1>;    // Receive enable acknowledge flag
            using TEACK = Field<21, 1>;    // Transmit enable acknowledge flag
            using WUF = Field<20, 1>;    // Wakeup from Stop mode flag
            using RWU = Field<19, 1>;    // Receiver wakeup from Mute mode
            using SBKF = Field<18, 1>;    // Send break flag
            using CMF = Field<17, 1>;    // character match flag
            using BUSY = Field<16, 1>;    // Busy flag
            using ABRF = Field<15, 1>;    // Auto baud rate flag
            using ABRE = Field<14, 1>;    // Auto baud rate error
            using EOBF = Field<12, 1>;    // End of block flag
            using RTOF = Field<11, 1>;    // Receiver timeout
            using CTS = Field<10, 1>;    // CTS flag
            using CTSIF = Field<9, 1>;    // CTS interrupt flag
            using LBDF = Field<8, 1>;    // LIN break detection flag
            using TXE = Field<7, 1>;    // Transmit data register empty
            using TC = Field<6, 1>;    // Transmission complete
            using RXNE = Field<5, 1>;    // Read data register not empty
            using IDLE = Field<4, 1>;    // Idle line detected
            using ORE = Field<3, 1>;    // Overrun error
            using NF = Field<2, 1>;    // Noise detected flag
            using FE = Field<1, 1>;    // Framing error
            using PE = Field<0, 1>;    // Parity error
        };

        // Interrupt flag clear register
        struct ICR : public Register<0x40004820> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using EOBCF = Field<12, 1>;    // End of timeout clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public Register<0x40004824> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40004828> {
            using Field = Field<0, 9>;    // Transmit data value
        };

    };

    // Serial peripheral interface/Inter-IC2
    struct SPI2 {
        // control register 1
        struct CR1 : public Register<0x40003800> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using DFF = Field<11, 1>;    // Data frame format
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40003804> {
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using SSOE = Field<2, 1>;    // SS output enable
            using NSSP = Field<3, 1>;    // NSS pulse management
            using FRF = Field<4, 1>;    // Frame format
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
            using DS = Field<8, 4>;    // Data size
            using FRXTH = Field<12, 1>;    // FIFO reception threshold
            using LDMA_RX = Field<13, 1>;    // Last DMA transfer for reception
            using LDMA_TX = Field<14, 1>;    // Last DMA transfer for transmission
        };

        // status register
        struct SR : public Register<0x40003808> {
            using RXNE = Field<0, 1>;    // Receive buffer not empty
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using CHSIDE = Field<2, 1>;    // Channel side
            using UDR = Field<3, 1>;    // Underrun flag
            using CRCERR = Field<4, 1>;    // CRC error flag
            using MODF = Field<5, 1>;    // Mode fault
            using OVR = Field<6, 1>;    // Overrun flag
            using BSY = Field<7, 1>;    // Busy flag
            using TIFRFE = Field<8, 1>;    // TI frame format error
            using FRLVL = Field<9, 2>;    // FIFO reception level
            using FTLVL = Field<11, 2>;    // FIFO transmission level
        };

        // data register
        struct DR : public Register<0x4000380c> {
            using Field = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40003810> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public Register<0x40003814> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public Register<0x40003818> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

        // I2S configuration register
        struct I2SCFGR : public Register<0x4000381c> {
            using I2SMOD = Field<11, 1>;    // I2S mode selection
            using I2SE = Field<10, 1>;    // I2S Enable
            using I2SCFG = Field<8, 2>;    // I2S configuration mode
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using CKPOL = Field<3, 1>;    // Steady state clock polarity
            using DATLEN = Field<1, 2>;    // Data length to be transferred
            using CHLEN = Field<0, 1>;    // Channel length (number of bits per audio channel)
        };

        // I2S prescaler register
        struct I2SPR : public Register<0x40003820> {
            using MCKOE = Field<9, 1>;    // Master clock output enable
            using ODD = Field<8, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<0, 8>;    // I2S Linear prescaler
        };

    };

    // Serial peripheral interface/Inter-IC2
    struct I2S2ext {
        // control register 1
        struct CR1 : public Register<0x40003400> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using DFF = Field<11, 1>;    // Data frame format
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40003404> {
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using SSOE = Field<2, 1>;    // SS output enable
            using NSSP = Field<3, 1>;    // NSS pulse management
            using FRF = Field<4, 1>;    // Frame format
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
            using DS = Field<8, 4>;    // Data size
            using FRXTH = Field<12, 1>;    // FIFO reception threshold
            using LDMA_RX = Field<13, 1>;    // Last DMA transfer for reception
            using LDMA_TX = Field<14, 1>;    // Last DMA transfer for transmission
        };

        // status register
        struct SR : public Register<0x40003408> {
            using RXNE = Field<0, 1>;    // Receive buffer not empty
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using CHSIDE = Field<2, 1>;    // Channel side
            using UDR = Field<3, 1>;    // Underrun flag
            using CRCERR = Field<4, 1>;    // CRC error flag
            using MODF = Field<5, 1>;    // Mode fault
            using OVR = Field<6, 1>;    // Overrun flag
            using BSY = Field<7, 1>;    // Busy flag
            using TIFRFE = Field<8, 1>;    // TI frame format error
            using FRLVL = Field<9, 2>;    // FIFO reception level
            using FTLVL = Field<11, 2>;    // FIFO transmission level
        };

        // data register
        struct DR : public Register<0x4000340c> {
            using Field = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40003410> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public Register<0x40003414> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public Register<0x40003418> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

        // I2S configuration register
        struct I2SCFGR : public Register<0x4000341c> {
            using I2SMOD = Field<11, 1>;    // I2S mode selection
            using I2SE = Field<10, 1>;    // I2S Enable
            using I2SCFG = Field<8, 2>;    // I2S configuration mode
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using CKPOL = Field<3, 1>;    // Steady state clock polarity
            using DATLEN = Field<1, 2>;    // Data length to be transferred
            using CHLEN = Field<0, 1>;    // Channel length (number of bits per audio channel)
        };

        // I2S prescaler register
        struct I2SPR : public Register<0x40003420> {
            using MCKOE = Field<9, 1>;    // Master clock output enable
            using ODD = Field<8, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<0, 8>;    // I2S Linear prescaler
        };

    };

    // Serial peripheral interface/Inter-IC2
    struct I2S3ext {
        // control register 1
        struct CR1 : public Register<0x40004000> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using DFF = Field<11, 1>;    // Data frame format
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40004004> {
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using SSOE = Field<2, 1>;    // SS output enable
            using NSSP = Field<3, 1>;    // NSS pulse management
            using FRF = Field<4, 1>;    // Frame format
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
            using DS = Field<8, 4>;    // Data size
            using FRXTH = Field<12, 1>;    // FIFO reception threshold
            using LDMA_RX = Field<13, 1>;    // Last DMA transfer for reception
            using LDMA_TX = Field<14, 1>;    // Last DMA transfer for transmission
        };

        // status register
        struct SR : public Register<0x40004008> {
            using RXNE = Field<0, 1>;    // Receive buffer not empty
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using CHSIDE = Field<2, 1>;    // Channel side
            using UDR = Field<3, 1>;    // Underrun flag
            using CRCERR = Field<4, 1>;    // CRC error flag
            using MODF = Field<5, 1>;    // Mode fault
            using OVR = Field<6, 1>;    // Overrun flag
            using BSY = Field<7, 1>;    // Busy flag
            using TIFRFE = Field<8, 1>;    // TI frame format error
            using FRLVL = Field<9, 2>;    // FIFO reception level
            using FTLVL = Field<11, 2>;    // FIFO transmission level
        };

        // data register
        struct DR : public Register<0x4000400c> {
            using Field = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40004010> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public Register<0x40004014> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public Register<0x40004018> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

        // I2S configuration register
        struct I2SCFGR : public Register<0x4000401c> {
            using I2SMOD = Field<11, 1>;    // I2S mode selection
            using I2SE = Field<10, 1>;    // I2S Enable
            using I2SCFG = Field<8, 2>;    // I2S configuration mode
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using CKPOL = Field<3, 1>;    // Steady state clock polarity
            using DATLEN = Field<1, 2>;    // Data length to be transferred
            using CHLEN = Field<0, 1>;    // Channel length (number of bits per audio channel)
        };

        // I2S prescaler register
        struct I2SPR : public Register<0x40004020> {
            using MCKOE = Field<9, 1>;    // Master clock output enable
            using ODD = Field<8, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<0, 8>;    // I2S Linear prescaler
        };

    };

    // Serial peripheral interface/Inter-IC2
    struct SPI3 {
        // control register 1
        struct CR1 : public Register<0x40003c00> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using CRCL = Field<11, 1>;    // Data frame format
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40003c04> {
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using SSOE = Field<2, 1>;    // SS output enable
            using NSSP = Field<3, 1>;    // NSS pulse management
            using FRF = Field<4, 1>;    // Frame format
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
            using DS = Field<8, 4>;    // Data size
            using FRXTH = Field<12, 1>;    // FIFO reception threshold
            using LDMA_RX = Field<13, 1>;    // Last DMA transfer for reception
            using LDMA_TX = Field<14, 1>;    // Last DMA transfer for transmission
        };

        // status register
        struct SR : public Register<0x40003c08> {
            using RXNE = Field<0, 1>;    // Receive buffer not empty
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using CHSIDE = Field<2, 1>;    // Channel side
            using UDR = Field<3, 1>;    // Underrun flag
            using CRCERR = Field<4, 1>;    // CRC error flag
            using MODF = Field<5, 1>;    // Mode fault
            using OVR = Field<6, 1>;    // Overrun flag
            using BSY = Field<7, 1>;    // Busy flag
            using TIFRFE = Field<8, 1>;    // TI frame format error
            using FRLVL = Field<9, 2>;    // FIFO reception level
            using FTLVL = Field<11, 2>;    // FIFO transmission level
        };

        // data register
        struct DR : public Register<0x40003c0c> {
            using Field = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40003c10> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public Register<0x40003c14> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public Register<0x40003c18> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

        // I2S configuration register
        struct I2SCFGR : public Register<0x40003c1c> {
            using I2SMOD = Field<11, 1>;    // I2S mode selection
            using I2SE = Field<10, 1>;    // I2S Enable
            using I2SCFG = Field<8, 2>;    // I2S configuration mode
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using CKPOL = Field<3, 1>;    // Steady state clock polarity
            using DATLEN = Field<1, 2>;    // Data length to be transferred
            using CHLEN = Field<0, 1>;    // Channel length (number of bits per audio channel)
        };

        // I2S prescaler register
        struct I2SPR : public Register<0x40003c20> {
            using MCKOE = Field<9, 1>;    // Master clock output enable
            using ODD = Field<8, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<0, 8>;    // I2S Linear prescaler
        };

    };

    // Serial peripheral interface/Inter-IC2
    struct SPI1 {
        // control register 1
        struct CR1 : public Register<0x40013000> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using CRCL = Field<11, 1>;    // Data frame format
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40013004> {
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using SSOE = Field<2, 1>;    // SS output enable
            using NSSP = Field<3, 1>;    // NSS pulse management
            using FRF = Field<4, 1>;    // Frame format
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
            using DS = Field<8, 4>;    // Data size
            using FRXTH = Field<12, 1>;    // FIFO reception threshold
            using LDMA_RX = Field<13, 1>;    // Last DMA transfer for reception
            using LDMA_TX = Field<14, 1>;    // Last DMA transfer for transmission
        };

        // status register
        struct SR : public Register<0x40013008> {
            using RXNE = Field<0, 1>;    // Receive buffer not empty
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using CHSIDE = Field<2, 1>;    // Channel side
            using UDR = Field<3, 1>;    // Underrun flag
            using CRCERR = Field<4, 1>;    // CRC error flag
            using MODF = Field<5, 1>;    // Mode fault
            using OVR = Field<6, 1>;    // Overrun flag
            using BSY = Field<7, 1>;    // Busy flag
            using TIFRFE = Field<8, 1>;    // TI frame format error
            using FRLVL = Field<9, 2>;    // FIFO reception level
            using FTLVL = Field<11, 2>;    // FIFO transmission level
        };

        // data register
        struct DR : public Register<0x4001300c> {
            using Field = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40013010> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public Register<0x40013014> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public Register<0x40013018> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

        // I2S configuration register
        struct I2SCFGR : public Register<0x4001301c> {
            using I2SMOD = Field<11, 1>;    // I2S mode selection
            using I2SE = Field<10, 1>;    // I2S Enable
            using I2SCFG = Field<8, 2>;    // I2S configuration mode
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using CKPOL = Field<3, 1>;    // Steady state clock polarity
            using DATLEN = Field<1, 2>;    // Data length to be transferred
            using CHLEN = Field<0, 1>;    // Channel length (number of bits per audio channel)
        };

        // I2S prescaler register
        struct I2SPR : public Register<0x40013020> {
            using MCKOE = Field<9, 1>;    // Master clock output enable
            using ODD = Field<8, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<0, 8>;    // I2S Linear prescaler
        };

    };

    // External interrupt/event controller
    struct EXTI {
        // Interrupt mask register
        struct IMR1 : public Register<0x40010400> {
            using MR0 = Field<0, 1>;    // Interrupt Mask on line 0
            using MR1 = Field<1, 1>;    // Interrupt Mask on line 1
            using MR2 = Field<2, 1>;    // Interrupt Mask on line 2
            using MR3 = Field<3, 1>;    // Interrupt Mask on line 3
            using MR4 = Field<4, 1>;    // Interrupt Mask on line 4
            using MR5 = Field<5, 1>;    // Interrupt Mask on line 5
            using MR6 = Field<6, 1>;    // Interrupt Mask on line 6
            using MR7 = Field<7, 1>;    // Interrupt Mask on line 7
            using MR8 = Field<8, 1>;    // Interrupt Mask on line 8
            using MR9 = Field<9, 1>;    // Interrupt Mask on line 9
            using MR10 = Field<10, 1>;    // Interrupt Mask on line 10
            using MR11 = Field<11, 1>;    // Interrupt Mask on line 11
            using MR12 = Field<12, 1>;    // Interrupt Mask on line 12
            using MR13 = Field<13, 1>;    // Interrupt Mask on line 13
            using MR14 = Field<14, 1>;    // Interrupt Mask on line 14
            using MR15 = Field<15, 1>;    // Interrupt Mask on line 15
            using MR16 = Field<16, 1>;    // Interrupt Mask on line 16
            using MR17 = Field<17, 1>;    // Interrupt Mask on line 17
            using MR18 = Field<18, 1>;    // Interrupt Mask on line 18
            using MR19 = Field<19, 1>;    // Interrupt Mask on line 19
            using MR20 = Field<20, 1>;    // Interrupt Mask on line 20
            using MR21 = Field<21, 1>;    // Interrupt Mask on line 21
            using MR22 = Field<22, 1>;    // Interrupt Mask on line 22
            using MR23 = Field<23, 1>;    // Interrupt Mask on line 23
            using MR24 = Field<24, 1>;    // Interrupt Mask on line 24
            using MR25 = Field<25, 1>;    // Interrupt Mask on line 25
            using MR26 = Field<26, 1>;    // Interrupt Mask on line 26
            using MR27 = Field<27, 1>;    // Interrupt Mask on line 27
            using MR28 = Field<28, 1>;    // Interrupt Mask on line 28
            using MR29 = Field<29, 1>;    // Interrupt Mask on line 29
            using MR30 = Field<30, 1>;    // Interrupt Mask on line 30
            using MR31 = Field<31, 1>;    // Interrupt Mask on line 31
        };

        // Event mask register
        struct EMR1 : public Register<0x40010404> {
            using MR0 = Field<0, 1>;    // Event Mask on line 0
            using MR1 = Field<1, 1>;    // Event Mask on line 1
            using MR2 = Field<2, 1>;    // Event Mask on line 2
            using MR3 = Field<3, 1>;    // Event Mask on line 3
            using MR4 = Field<4, 1>;    // Event Mask on line 4
            using MR5 = Field<5, 1>;    // Event Mask on line 5
            using MR6 = Field<6, 1>;    // Event Mask on line 6
            using MR7 = Field<7, 1>;    // Event Mask on line 7
            using MR8 = Field<8, 1>;    // Event Mask on line 8
            using MR9 = Field<9, 1>;    // Event Mask on line 9
            using MR10 = Field<10, 1>;    // Event Mask on line 10
            using MR11 = Field<11, 1>;    // Event Mask on line 11
            using MR12 = Field<12, 1>;    // Event Mask on line 12
            using MR13 = Field<13, 1>;    // Event Mask on line 13
            using MR14 = Field<14, 1>;    // Event Mask on line 14
            using MR15 = Field<15, 1>;    // Event Mask on line 15
            using MR16 = Field<16, 1>;    // Event Mask on line 16
            using MR17 = Field<17, 1>;    // Event Mask on line 17
            using MR18 = Field<18, 1>;    // Event Mask on line 18
            using MR19 = Field<19, 1>;    // Event Mask on line 19
            using MR20 = Field<20, 1>;    // Event Mask on line 20
            using MR21 = Field<21, 1>;    // Event Mask on line 21
            using MR22 = Field<22, 1>;    // Event Mask on line 22
            using MR23 = Field<23, 1>;    // Event Mask on line 23
            using MR24 = Field<24, 1>;    // Event Mask on line 24
            using MR25 = Field<25, 1>;    // Event Mask on line 25
            using MR26 = Field<26, 1>;    // Event Mask on line 26
            using MR27 = Field<27, 1>;    // Event Mask on line 27
            using MR28 = Field<28, 1>;    // Event Mask on line 28
            using MR29 = Field<29, 1>;    // Event Mask on line 29
            using MR30 = Field<30, 1>;    // Event Mask on line 30
            using MR31 = Field<31, 1>;    // Event Mask on line 31
        };

        // Rising Trigger selection register
        struct RTSR1 : public Register<0x40010408> {
            using TR0 = Field<0, 1>;    // Rising trigger event configuration of line 0
            using TR1 = Field<1, 1>;    // Rising trigger event configuration of line 1
            using TR2 = Field<2, 1>;    // Rising trigger event configuration of line 2
            using TR3 = Field<3, 1>;    // Rising trigger event configuration of line 3
            using TR4 = Field<4, 1>;    // Rising trigger event configuration of line 4
            using TR5 = Field<5, 1>;    // Rising trigger event configuration of line 5
            using TR6 = Field<6, 1>;    // Rising trigger event configuration of line 6
            using TR7 = Field<7, 1>;    // Rising trigger event configuration of line 7
            using TR8 = Field<8, 1>;    // Rising trigger event configuration of line 8
            using TR9 = Field<9, 1>;    // Rising trigger event configuration of line 9
            using TR10 = Field<10, 1>;    // Rising trigger event configuration of line 10
            using TR11 = Field<11, 1>;    // Rising trigger event configuration of line 11
            using TR12 = Field<12, 1>;    // Rising trigger event configuration of line 12
            using TR13 = Field<13, 1>;    // Rising trigger event configuration of line 13
            using TR14 = Field<14, 1>;    // Rising trigger event configuration of line 14
            using TR15 = Field<15, 1>;    // Rising trigger event configuration of line 15
            using TR16 = Field<16, 1>;    // Rising trigger event configuration of line 16
            using TR17 = Field<17, 1>;    // Rising trigger event configuration of line 17
            using TR18 = Field<18, 1>;    // Rising trigger event configuration of line 18
            using TR19 = Field<19, 1>;    // Rising trigger event configuration of line 19
            using TR20 = Field<20, 1>;    // Rising trigger event configuration of line 20
            using TR21 = Field<21, 1>;    // Rising trigger event configuration of line 21
            using TR22 = Field<22, 1>;    // Rising trigger event configuration of line 22
            using TR29 = Field<29, 1>;    // Rising trigger event configuration of line 29
            using TR30 = Field<30, 1>;    // Rising trigger event configuration of line 30
            using TR31 = Field<31, 1>;    // Rising trigger event configuration of line 31
        };

        // Falling Trigger selection register
        struct FTSR1 : public Register<0x4001040c> {
            using TR0 = Field<0, 1>;    // Falling trigger event configuration of line 0
            using TR1 = Field<1, 1>;    // Falling trigger event configuration of line 1
            using TR2 = Field<2, 1>;    // Falling trigger event configuration of line 2
            using TR3 = Field<3, 1>;    // Falling trigger event configuration of line 3
            using TR4 = Field<4, 1>;    // Falling trigger event configuration of line 4
            using TR5 = Field<5, 1>;    // Falling trigger event configuration of line 5
            using TR6 = Field<6, 1>;    // Falling trigger event configuration of line 6
            using TR7 = Field<7, 1>;    // Falling trigger event configuration of line 7
            using TR8 = Field<8, 1>;    // Falling trigger event configuration of line 8
            using TR9 = Field<9, 1>;    // Falling trigger event configuration of line 9
            using TR10 = Field<10, 1>;    // Falling trigger event configuration of line 10
            using TR11 = Field<11, 1>;    // Falling trigger event configuration of line 11
            using TR12 = Field<12, 1>;    // Falling trigger event configuration of line 12
            using TR13 = Field<13, 1>;    // Falling trigger event configuration of line 13
            using TR14 = Field<14, 1>;    // Falling trigger event configuration of line 14
            using TR15 = Field<15, 1>;    // Falling trigger event configuration of line 15
            using TR16 = Field<16, 1>;    // Falling trigger event configuration of line 16
            using TR17 = Field<17, 1>;    // Falling trigger event configuration of line 17
            using TR18 = Field<18, 1>;    // Falling trigger event configuration of line 18
            using TR19 = Field<19, 1>;    // Falling trigger event configuration of line 19
            using TR20 = Field<20, 1>;    // Falling trigger event configuration of line 20
            using TR21 = Field<21, 1>;    // Falling trigger event configuration of line 21
            using TR22 = Field<22, 1>;    // Falling trigger event configuration of line 22
            using TR29 = Field<29, 1>;    // Falling trigger event configuration of line 29
            using TR30 = Field<30, 1>;    // Falling trigger event configuration of line 30.
            using TR31 = Field<31, 1>;    // Falling trigger event configuration of line 31
        };

        // Software interrupt event register
        struct SWIER1 : public Register<0x40010410> {
            using SWIER0 = Field<0, 1>;    // Software Interrupt on line 0
            using Field = Field<1, 1>;    // Software Interrupt on line 1
            using SWIER2 = Field<2, 1>;    // Software Interrupt on line 2
            using SWIER3 = Field<3, 1>;    // Software Interrupt on line 3
            using SWIER4 = Field<4, 1>;    // Software Interrupt on line 4
            using SWIER5 = Field<5, 1>;    // Software Interrupt on line 5
            using SWIER6 = Field<6, 1>;    // Software Interrupt on line 6
            using SWIER7 = Field<7, 1>;    // Software Interrupt on line 7
            using SWIER8 = Field<8, 1>;    // Software Interrupt on line 8
            using SWIER9 = Field<9, 1>;    // Software Interrupt on line 9
            using SWIER10 = Field<10, 1>;    // Software Interrupt on line 10
            using SWIER11 = Field<11, 1>;    // Software Interrupt on line 11
            using SWIER12 = Field<12, 1>;    // Software Interrupt on line 12
            using SWIER13 = Field<13, 1>;    // Software Interrupt on line 13
            using SWIER14 = Field<14, 1>;    // Software Interrupt on line 14
            using SWIER15 = Field<15, 1>;    // Software Interrupt on line 15
            using SWIER16 = Field<16, 1>;    // Software Interrupt on line 16
            using SWIER17 = Field<17, 1>;    // Software Interrupt on line 17
            using SWIER18 = Field<18, 1>;    // Software Interrupt on line 18
            using SWIER19 = Field<19, 1>;    // Software Interrupt on line 19
            using SWIER20 = Field<20, 1>;    // Software Interrupt on line 20
            using SWIER21 = Field<21, 1>;    // Software Interrupt on line 21
            using SWIER22 = Field<22, 1>;    // Software Interrupt on line 22
            using SWIER29 = Field<29, 1>;    // Software Interrupt on line 29
            using SWIER30 = Field<30, 1>;    // Software Interrupt on line 309
            using SWIER31 = Field<31, 1>;    // Software Interrupt on line 319
        };

        // Pending register
        struct PR1 : public Register<0x40010414> {
            using PR0 = Field<0, 1>;    // Pending bit 0
            using Field = Field<1, 1>;    // Pending bit 1
            using PR2 = Field<2, 1>;    // Pending bit 2
            using PR3 = Field<3, 1>;    // Pending bit 3
            using PR4 = Field<4, 1>;    // Pending bit 4
            using PR5 = Field<5, 1>;    // Pending bit 5
            using PR6 = Field<6, 1>;    // Pending bit 6
            using PR7 = Field<7, 1>;    // Pending bit 7
            using PR8 = Field<8, 1>;    // Pending bit 8
            using PR9 = Field<9, 1>;    // Pending bit 9
            using PR10 = Field<10, 1>;    // Pending bit 10
            using PR11 = Field<11, 1>;    // Pending bit 11
            using PR12 = Field<12, 1>;    // Pending bit 12
            using PR13 = Field<13, 1>;    // Pending bit 13
            using PR14 = Field<14, 1>;    // Pending bit 14
            using PR15 = Field<15, 1>;    // Pending bit 15
            using PR16 = Field<16, 1>;    // Pending bit 16
            using PR17 = Field<17, 1>;    // Pending bit 17
            using PR18 = Field<18, 1>;    // Pending bit 18
            using PR19 = Field<19, 1>;    // Pending bit 19
            using PR20 = Field<20, 1>;    // Pending bit 20
            using PR21 = Field<21, 1>;    // Pending bit 21
            using PR22 = Field<22, 1>;    // Pending bit 22
            using PR29 = Field<29, 1>;    // Pending bit 29
            using PR30 = Field<30, 1>;    // Pending bit 30
            using PR31 = Field<31, 1>;    // Pending bit 31
        };

        // Interrupt mask register
        struct IMR2 : public Register<0x40010418> {
            using MR32 = Field<0, 1>;    // Interrupt Mask on external/internal line 32
            using MR33 = Field<1, 1>;    // Interrupt Mask on external/internal line 33
            using MR34 = Field<2, 1>;    // Interrupt Mask on external/internal line 34
            using MR35 = Field<3, 1>;    // Interrupt Mask on external/internal line 35
        };

        // Event mask register
        struct EMR2 : public Register<0x4001041c> {
            using MR32 = Field<0, 1>;    // Event mask on external/internal line 32
            using MR33 = Field<1, 1>;    // Event mask on external/internal line 33
            using MR34 = Field<2, 1>;    // Event mask on external/internal line 34
            using MR35 = Field<3, 1>;    // Event mask on external/internal line 35
        };

        // Rising Trigger selection register
        struct RTSR2 : public Register<0x40010420> {
            using TR32 = Field<0, 1>;    // Rising trigger event configuration bit of line 32
            using TR33 = Field<1, 1>;    // Rising trigger event configuration bit of line 33
        };

        // Falling Trigger selection register
        struct FTSR2 : public Register<0x40010424> {
            using TR32 = Field<0, 1>;    // Falling trigger event configuration bit of line 32
            using TR33 = Field<1, 1>;    // Falling trigger event configuration bit of line 33
        };

        // Software interrupt event register
        struct SWIER2 : public Register<0x40010428> {
            using SWIER32 = Field<0, 1>;    // Software interrupt on line 32
            using SWIER33 = Field<1, 1>;    // Software interrupt on line 33
        };

        // Pending register
        struct PR2 : public Register<0x4001042c> {
            using PR32 = Field<0, 1>;    // Pending bit on line 32
            using PR33 = Field<1, 1>;    // Pending bit on line 33
        };

    };

    // Power control
    struct PWR {
        // power control register
        struct CR : public Register<0x40007000> {
            using LPDS = Field<0, 1>;    // Low-power deep sleep
            using PDDS = Field<1, 1>;    // Power down deepsleep
            using CWUF = Field<2, 1>;    // Clear wakeup flag
            using CSBF = Field<3, 1>;    // Clear standby flag
            using PVDE = Field<4, 1>;    // Power voltage detector enable
            using PLS = Field<5, 3>;    // PVD level selection
            using DBP = Field<8, 1>;    // Disable backup domain write protection
        };

        // power control/status register
        struct CSR : public Register<0x40007004> {
            using WUF = Field<0, 1>;    // Wakeup flag
            using SBF = Field<1, 1>;    // Standby flag
            using PVDO = Field<2, 1>;    // PVD output
            using EWUP1 = Field<8, 1>;    // Enable WKUP1 pin
            using EWUP2 = Field<9, 1>;    // Enable WKUP2 pin
        };

    };

    // Inter-integrated circuit
    struct I2C1 {
        // Control register 1
        struct CR1 : public Register<0x40005400> {
            using PE = Field<0, 1>;    // Peripheral enable
            using TXIE = Field<1, 1>;    // TX Interrupt enable
            using RXIE = Field<2, 1>;    // RX Interrupt enable
            using ADDRIE = Field<3, 1>;    // Address match interrupt enable (slave only)
            using NACKIE = Field<4, 1>;    // Not acknowledge received interrupt enable
            using STOPIE = Field<5, 1>;    // STOP detection Interrupt enable
            using TCIE = Field<6, 1>;    // Transfer Complete interrupt enable
            using ERRIE = Field<7, 1>;    // Error interrupts enable
            using DNF = Field<8, 4>;    // Digital noise filter
            using ANFOFF = Field<12, 1>;    // Analog noise filter OFF
            using SWRST = Field<13, 1>;    // Software reset
            using TXDMAEN = Field<14, 1>;    // DMA transmission requests enable
            using RXDMAEN = Field<15, 1>;    // DMA reception requests enable
            using SBC = Field<16, 1>;    // Slave byte control
            using NOSTRETCH = Field<17, 1>;    // Clock stretching disable
            using WUPEN = Field<18, 1>;    // Wakeup from STOP enable
            using GCEN = Field<19, 1>;    // General call enable
            using SMBHEN = Field<20, 1>;    // SMBus Host address enable
            using SMBDEN = Field<21, 1>;    // SMBus Device Default address enable
            using ALERTEN = Field<22, 1>;    // SMBUS alert enable
            using PECEN = Field<23, 1>;    // PEC enable
        };

        // Control register 2
        struct CR2 : public Register<0x40005404> {
            using PECBYTE = Field<26, 1>;    // Packet error checking byte
            using AUTOEND = Field<25, 1>;    // Automatic end mode (master mode)
            using RELOAD = Field<24, 1>;    // NBYTES reload mode
            using NBYTES = Field<16, 8>;    // Number of bytes
            using NACK = Field<15, 1>;    // NACK generation (slave mode)
            using STOP = Field<14, 1>;    // Stop generation (master mode)
            using START = Field<13, 1>;    // Start generation
            using HEAD10R = Field<12, 1>;    // 10-bit address header only read direction (master receiver mode)
            using ADD10 = Field<11, 1>;    // 10-bit addressing mode (master mode)
            using RD_WRN = Field<10, 1>;    // Transfer direction (master mode)
            using SADD8 = Field<8, 2>;    // Slave address bit 9:8 (master mode)
            using SADD1 = Field<1, 7>;    // Slave address bit 7:1 (master mode)
            using SADD0 = Field<0, 1>;    // Slave address bit 0 (master mode)
        };

        // Own address register 1
        struct OAR1 : public Register<0x40005408> {
            using OA1_0 = Field<0, 1>;    // Interface address
            using OA1_1 = Field<1, 7>;    // Interface address
            using OA1_8 = Field<8, 2>;    // Interface address
            using OA1MODE = Field<10, 1>;    // Own Address 1 10-bit mode
            using OA1EN = Field<15, 1>;    // Own Address 1 enable
        };

        // Own address register 2
        struct OAR2 : public Register<0x4000540c> {
            using OA2 = Field<1, 7>;    // Interface address
            using OA2MSK = Field<8, 3>;    // Own Address 2 masks
            using OA2EN = Field<15, 1>;    // Own Address 2 enable
        };

        // Timing register
        struct TIMINGR : public Register<0x40005410> {
            using SCLL = Field<0, 8>;    // SCL low period (master mode)
            using SCLH = Field<8, 8>;    // SCL high period (master mode)
            using SDADEL = Field<16, 4>;    // Data hold time
            using SCLDEL = Field<20, 4>;    // Data setup time
            using PRESC = Field<28, 4>;    // Timing prescaler
        };

        // Status register 1
        struct TIMEOUTR : public Register<0x40005414> {
            using TIMEOUTA = Field<0, 12>;    // Bus timeout A
            using TIDLE = Field<12, 1>;    // Idle clock timeout detection
            using TIMOUTEN = Field<15, 1>;    // Clock timeout enable
            using TIMEOUTB = Field<16, 12>;    // Bus timeout B
            using TEXTEN = Field<31, 1>;    // Extended clock timeout enable
        };

        // Interrupt and Status register
        struct ISR : public Register<0x40005418> {
            using ADDCODE = Field<17, 7>;    // Address match code (Slave mode)
            using DIR = Field<16, 1>;    // Transfer direction (Slave mode)
            using BUSY = Field<15, 1>;    // Bus busy
            using ALERT = Field<13, 1>;    // SMBus alert
            using TIMEOUT = Field<12, 1>;    // Timeout or t_low detection flag
            using PECERR = Field<11, 1>;    // PEC Error in reception
            using OVR = Field<10, 1>;    // Overrun/Underrun (slave mode)
            using ARLO = Field<9, 1>;    // Arbitration lost
            using BERR = Field<8, 1>;    // Bus error
            using TCR = Field<7, 1>;    // Transfer Complete Reload
            using TC = Field<6, 1>;    // Transfer Complete (master mode)
            using STOPF = Field<5, 1>;    // Stop detection flag
            using NACKF = Field<4, 1>;    // Not acknowledge received flag
            using ADDR = Field<3, 1>;    // Address matched (slave mode)
            using RXNE = Field<2, 1>;    // Receive data register not empty (receivers)
            using TXIS = Field<1, 1>;    // Transmit interrupt status (transmitters)
            using TXE = Field<0, 1>;    // Transmit data register empty (transmitters)
        };

        // Interrupt clear register
        struct ICR : public Register<0x4000541c> {
            using ALERTCF = Field<13, 1>;    // Alert flag clear
            using TIMOUTCF = Field<12, 1>;    // Timeout detection flag clear
            using PECCF = Field<11, 1>;    // PEC Error flag clear
            using OVRCF = Field<10, 1>;    // Overrun/Underrun flag clear
            using ARLOCF = Field<9, 1>;    // Arbitration lost flag clear
            using BERRCF = Field<8, 1>;    // Bus error flag clear
            using STOPCF = Field<5, 1>;    // Stop detection flag clear
            using NACKCF = Field<4, 1>;    // Not Acknowledge flag clear
            using ADDRCF = Field<3, 1>;    // Address Matched flag clear
        };

        // PEC register
        struct PECR : public Register<0x40005420> {
            using PEC = Field<0, 8>;    // Packet error checking register
        };

        // Receive data register
        struct RXDR : public Register<0x40005424> {
            using RXDATA = Field<0, 8>;    // 8-bit receive data
        };

        // Transmit data register
        struct TXDR : public Register<0x40005428> {
            using TXDATA = Field<0, 8>;    // 8-bit transmit data
        };

    };

    // Inter-integrated circuit
    struct I2C2 {
        // Control register 1
        struct CR1 : public Register<0x40005800> {
            using PE = Field<0, 1>;    // Peripheral enable
            using TXIE = Field<1, 1>;    // TX Interrupt enable
            using RXIE = Field<2, 1>;    // RX Interrupt enable
            using ADDRIE = Field<3, 1>;    // Address match interrupt enable (slave only)
            using NACKIE = Field<4, 1>;    // Not acknowledge received interrupt enable
            using STOPIE = Field<5, 1>;    // STOP detection Interrupt enable
            using TCIE = Field<6, 1>;    // Transfer Complete interrupt enable
            using ERRIE = Field<7, 1>;    // Error interrupts enable
            using DNF = Field<8, 4>;    // Digital noise filter
            using ANFOFF = Field<12, 1>;    // Analog noise filter OFF
            using SWRST = Field<13, 1>;    // Software reset
            using TXDMAEN = Field<14, 1>;    // DMA transmission requests enable
            using RXDMAEN = Field<15, 1>;    // DMA reception requests enable
            using SBC = Field<16, 1>;    // Slave byte control
            using NOSTRETCH = Field<17, 1>;    // Clock stretching disable
            using WUPEN = Field<18, 1>;    // Wakeup from STOP enable
            using GCEN = Field<19, 1>;    // General call enable
            using SMBHEN = Field<20, 1>;    // SMBus Host address enable
            using SMBDEN = Field<21, 1>;    // SMBus Device Default address enable
            using ALERTEN = Field<22, 1>;    // SMBUS alert enable
            using PECEN = Field<23, 1>;    // PEC enable
        };

        // Control register 2
        struct CR2 : public Register<0x40005804> {
            using PECBYTE = Field<26, 1>;    // Packet error checking byte
            using AUTOEND = Field<25, 1>;    // Automatic end mode (master mode)
            using RELOAD = Field<24, 1>;    // NBYTES reload mode
            using NBYTES = Field<16, 8>;    // Number of bytes
            using NACK = Field<15, 1>;    // NACK generation (slave mode)
            using STOP = Field<14, 1>;    // Stop generation (master mode)
            using START = Field<13, 1>;    // Start generation
            using HEAD10R = Field<12, 1>;    // 10-bit address header only read direction (master receiver mode)
            using ADD10 = Field<11, 1>;    // 10-bit addressing mode (master mode)
            using RD_WRN = Field<10, 1>;    // Transfer direction (master mode)
            using SADD8 = Field<8, 2>;    // Slave address bit 9:8 (master mode)
            using SADD1 = Field<1, 7>;    // Slave address bit 7:1 (master mode)
            using SADD0 = Field<0, 1>;    // Slave address bit 0 (master mode)
        };

        // Own address register 1
        struct OAR1 : public Register<0x40005808> {
            using OA1_0 = Field<0, 1>;    // Interface address
            using OA1_1 = Field<1, 7>;    // Interface address
            using OA1_8 = Field<8, 2>;    // Interface address
            using OA1MODE = Field<10, 1>;    // Own Address 1 10-bit mode
            using OA1EN = Field<15, 1>;    // Own Address 1 enable
        };

        // Own address register 2
        struct OAR2 : public Register<0x4000580c> {
            using OA2 = Field<1, 7>;    // Interface address
            using OA2MSK = Field<8, 3>;    // Own Address 2 masks
            using OA2EN = Field<15, 1>;    // Own Address 2 enable
        };

        // Timing register
        struct TIMINGR : public Register<0x40005810> {
            using SCLL = Field<0, 8>;    // SCL low period (master mode)
            using SCLH = Field<8, 8>;    // SCL high period (master mode)
            using SDADEL = Field<16, 4>;    // Data hold time
            using SCLDEL = Field<20, 4>;    // Data setup time
            using PRESC = Field<28, 4>;    // Timing prescaler
        };

        // Status register 1
        struct TIMEOUTR : public Register<0x40005814> {
            using TIMEOUTA = Field<0, 12>;    // Bus timeout A
            using TIDLE = Field<12, 1>;    // Idle clock timeout detection
            using TIMOUTEN = Field<15, 1>;    // Clock timeout enable
            using TIMEOUTB = Field<16, 12>;    // Bus timeout B
            using TEXTEN = Field<31, 1>;    // Extended clock timeout enable
        };

        // Interrupt and Status register
        struct ISR : public Register<0x40005818> {
            using ADDCODE = Field<17, 7>;    // Address match code (Slave mode)
            using DIR = Field<16, 1>;    // Transfer direction (Slave mode)
            using BUSY = Field<15, 1>;    // Bus busy
            using ALERT = Field<13, 1>;    // SMBus alert
            using TIMEOUT = Field<12, 1>;    // Timeout or t_low detection flag
            using PECERR = Field<11, 1>;    // PEC Error in reception
            using OVR = Field<10, 1>;    // Overrun/Underrun (slave mode)
            using ARLO = Field<9, 1>;    // Arbitration lost
            using BERR = Field<8, 1>;    // Bus error
            using TCR = Field<7, 1>;    // Transfer Complete Reload
            using TC = Field<6, 1>;    // Transfer Complete (master mode)
            using STOPF = Field<5, 1>;    // Stop detection flag
            using NACKF = Field<4, 1>;    // Not acknowledge received flag
            using ADDR = Field<3, 1>;    // Address matched (slave mode)
            using RXNE = Field<2, 1>;    // Receive data register not empty (receivers)
            using TXIS = Field<1, 1>;    // Transmit interrupt status (transmitters)
            using TXE = Field<0, 1>;    // Transmit data register empty (transmitters)
        };

        // Interrupt clear register
        struct ICR : public Register<0x4000581c> {
            using ALERTCF = Field<13, 1>;    // Alert flag clear
            using TIMOUTCF = Field<12, 1>;    // Timeout detection flag clear
            using PECCF = Field<11, 1>;    // PEC Error flag clear
            using OVRCF = Field<10, 1>;    // Overrun/Underrun flag clear
            using ARLOCF = Field<9, 1>;    // Arbitration lost flag clear
            using BERRCF = Field<8, 1>;    // Bus error flag clear
            using STOPCF = Field<5, 1>;    // Stop detection flag clear
            using NACKCF = Field<4, 1>;    // Not Acknowledge flag clear
            using ADDRCF = Field<3, 1>;    // Address Matched flag clear
        };

        // PEC register
        struct PECR : public Register<0x40005820> {
            using PEC = Field<0, 8>;    // Packet error checking register
        };

        // Receive data register
        struct RXDR : public Register<0x40005824> {
            using RXDATA = Field<0, 8>;    // 8-bit receive data
        };

        // Transmit data register
        struct TXDR : public Register<0x40005828> {
            using TXDATA = Field<0, 8>;    // 8-bit transmit data
        };

    };

    // Inter-integrated circuit
    struct I2C3 {
        // Control register 1
        struct CR1 : public Register<0x40007800> {
            using PE = Field<0, 1>;    // Peripheral enable
            using TXIE = Field<1, 1>;    // TX Interrupt enable
            using RXIE = Field<2, 1>;    // RX Interrupt enable
            using ADDRIE = Field<3, 1>;    // Address match interrupt enable (slave only)
            using NACKIE = Field<4, 1>;    // Not acknowledge received interrupt enable
            using STOPIE = Field<5, 1>;    // STOP detection Interrupt enable
            using TCIE = Field<6, 1>;    // Transfer Complete interrupt enable
            using ERRIE = Field<7, 1>;    // Error interrupts enable
            using DNF = Field<8, 4>;    // Digital noise filter
            using ANFOFF = Field<12, 1>;    // Analog noise filter OFF
            using SWRST = Field<13, 1>;    // Software reset
            using TXDMAEN = Field<14, 1>;    // DMA transmission requests enable
            using RXDMAEN = Field<15, 1>;    // DMA reception requests enable
            using SBC = Field<16, 1>;    // Slave byte control
            using NOSTRETCH = Field<17, 1>;    // Clock stretching disable
            using WUPEN = Field<18, 1>;    // Wakeup from STOP enable
            using GCEN = Field<19, 1>;    // General call enable
            using SMBHEN = Field<20, 1>;    // SMBus Host address enable
            using SMBDEN = Field<21, 1>;    // SMBus Device Default address enable
            using ALERTEN = Field<22, 1>;    // SMBUS alert enable
            using PECEN = Field<23, 1>;    // PEC enable
        };

        // Control register 2
        struct CR2 : public Register<0x40007804> {
            using PECBYTE = Field<26, 1>;    // Packet error checking byte
            using AUTOEND = Field<25, 1>;    // Automatic end mode (master mode)
            using RELOAD = Field<24, 1>;    // NBYTES reload mode
            using NBYTES = Field<16, 8>;    // Number of bytes
            using NACK = Field<15, 1>;    // NACK generation (slave mode)
            using STOP = Field<14, 1>;    // Stop generation (master mode)
            using START = Field<13, 1>;    // Start generation
            using HEAD10R = Field<12, 1>;    // 10-bit address header only read direction (master receiver mode)
            using ADD10 = Field<11, 1>;    // 10-bit addressing mode (master mode)
            using RD_WRN = Field<10, 1>;    // Transfer direction (master mode)
            using SADD8 = Field<8, 2>;    // Slave address bit 9:8 (master mode)
            using SADD1 = Field<1, 7>;    // Slave address bit 7:1 (master mode)
            using SADD0 = Field<0, 1>;    // Slave address bit 0 (master mode)
        };

        // Own address register 1
        struct OAR1 : public Register<0x40007808> {
            using OA1_0 = Field<0, 1>;    // Interface address
            using OA1_1 = Field<1, 7>;    // Interface address
            using OA1_8 = Field<8, 2>;    // Interface address
            using OA1MODE = Field<10, 1>;    // Own Address 1 10-bit mode
            using OA1EN = Field<15, 1>;    // Own Address 1 enable
        };

        // Own address register 2
        struct OAR2 : public Register<0x4000780c> {
            using OA2 = Field<1, 7>;    // Interface address
            using OA2MSK = Field<8, 3>;    // Own Address 2 masks
            using OA2EN = Field<15, 1>;    // Own Address 2 enable
        };

        // Timing register
        struct TIMINGR : public Register<0x40007810> {
            using SCLL = Field<0, 8>;    // SCL low period (master mode)
            using SCLH = Field<8, 8>;    // SCL high period (master mode)
            using SDADEL = Field<16, 4>;    // Data hold time
            using SCLDEL = Field<20, 4>;    // Data setup time
            using PRESC = Field<28, 4>;    // Timing prescaler
        };

        // Status register 1
        struct TIMEOUTR : public Register<0x40007814> {
            using TIMEOUTA = Field<0, 12>;    // Bus timeout A
            using TIDLE = Field<12, 1>;    // Idle clock timeout detection
            using TIMOUTEN = Field<15, 1>;    // Clock timeout enable
            using TIMEOUTB = Field<16, 12>;    // Bus timeout B
            using TEXTEN = Field<31, 1>;    // Extended clock timeout enable
        };

        // Interrupt and Status register
        struct ISR : public Register<0x40007818> {
            using ADDCODE = Field<17, 7>;    // Address match code (Slave mode)
            using DIR = Field<16, 1>;    // Transfer direction (Slave mode)
            using BUSY = Field<15, 1>;    // Bus busy
            using ALERT = Field<13, 1>;    // SMBus alert
            using TIMEOUT = Field<12, 1>;    // Timeout or t_low detection flag
            using PECERR = Field<11, 1>;    // PEC Error in reception
            using OVR = Field<10, 1>;    // Overrun/Underrun (slave mode)
            using ARLO = Field<9, 1>;    // Arbitration lost
            using BERR = Field<8, 1>;    // Bus error
            using TCR = Field<7, 1>;    // Transfer Complete Reload
            using TC = Field<6, 1>;    // Transfer Complete (master mode)
            using STOPF = Field<5, 1>;    // Stop detection flag
            using NACKF = Field<4, 1>;    // Not acknowledge received flag
            using ADDR = Field<3, 1>;    // Address matched (slave mode)
            using RXNE = Field<2, 1>;    // Receive data register not empty (receivers)
            using TXIS = Field<1, 1>;    // Transmit interrupt status (transmitters)
            using TXE = Field<0, 1>;    // Transmit data register empty (transmitters)
        };

        // Interrupt clear register
        struct ICR : public Register<0x4000781c> {
            using ALERTCF = Field<13, 1>;    // Alert flag clear
            using TIMOUTCF = Field<12, 1>;    // Timeout detection flag clear
            using PECCF = Field<11, 1>;    // PEC Error flag clear
            using OVRCF = Field<10, 1>;    // Overrun/Underrun flag clear
            using ARLOCF = Field<9, 1>;    // Arbitration lost flag clear
            using BERRCF = Field<8, 1>;    // Bus error flag clear
            using STOPCF = Field<5, 1>;    // Stop detection flag clear
            using NACKCF = Field<4, 1>;    // Not Acknowledge flag clear
            using ADDRCF = Field<3, 1>;    // Address Matched flag clear
        };

        // PEC register
        struct PECR : public Register<0x40007820> {
            using PEC = Field<0, 8>;    // Packet error checking register
        };

        // Receive data register
        struct RXDR : public Register<0x40007824> {
            using RXDATA = Field<0, 8>;    // 8-bit receive data
        };

        // Transmit data register
        struct TXDR : public Register<0x40007828> {
            using TXDATA = Field<0, 8>;    // 8-bit transmit data
        };

    };

    // Independent watchdog
    struct IWDG {
        // Key register
        struct KR : public Register<0x40003000> {
            using KEY = Field<0, 16>;    // Key value
        };

        // Prescaler register
        struct PR : public Register<0x40003004> {
            using Field = Field<0, 3>;    // Prescaler divider
        };

        // Reload register
        struct RLR : public Register<0x40003008> {
            using RL = Field<0, 12>;    // Watchdog counter reload value
        };

        // Status register
        struct SR : public Register<0x4000300c> {
            using PVU = Field<0, 1>;    // Watchdog prescaler value update
            using RVU = Field<1, 1>;    // Watchdog counter reload value update
            using WVU = Field<2, 1>;    // Watchdog counter window value update
        };

        // Window register
        struct WINR : public Register<0x40003010> {
            using WIN = Field<0, 12>;    // Watchdog counter window value
        };

    };

    // Window watchdog
    struct WWDG {
        // Control register
        struct CR : public Register<0x40002c00> {
            using T = Field<0, 7>;    // 7-bit counter
            using WDGA = Field<7, 1>;    // Activation bit
        };

        // Configuration register
        struct CFR : public Register<0x40002c04> {
            using EWI = Field<9, 1>;    // Early wakeup interrupt
            using WDGTB = Field<7, 2>;    // Timer base
            using W = Field<0, 7>;    // 7-bit window value
        };

        // Status register
        struct SR : public Register<0x40002c08> {
            using EWIF = Field<0, 1>;    // Early wakeup interrupt flag
        };

    };

    // Real-time clock
    struct RTC {
        // time register
        struct TR : public Register<0x40002800> {
            using PM = Field<22, 1>;    // AM/PM notation
            using HT = Field<20, 2>;    // Hour tens in BCD format
            using HU = Field<16, 4>;    // Hour units in BCD format
            using MNT = Field<12, 3>;    // Minute tens in BCD format
            using MNU = Field<8, 4>;    // Minute units in BCD format
            using ST = Field<4, 3>;    // Second tens in BCD format
            using SU = Field<0, 4>;    // Second units in BCD format
        };

        // date register
        struct DR : public Register<0x40002804> {
            using YT = Field<20, 4>;    // Year tens in BCD format
            using YU = Field<16, 4>;    // Year units in BCD format
            using WDU = Field<13, 3>;    // Week day units
            using MT = Field<12, 1>;    // Month tens in BCD format
            using MU = Field<8, 4>;    // Month units in BCD format
            using DT = Field<4, 2>;    // Date tens in BCD format
            using DU = Field<0, 4>;    // Date units in BCD format
        };

        // control register
        struct CR : public Register<0x40002808> {
            using WCKSEL = Field<0, 3>;    // Wakeup clock selection
            using TSEDGE = Field<3, 1>;    // Time-stamp event active edge
            using REFCKON = Field<4, 1>;    // Reference clock detection enable (50 or 60 Hz)
            using BYPSHAD = Field<5, 1>;    // Bypass the shadow registers
            using FMT = Field<6, 1>;    // Hour format
            using ALRAE = Field<8, 1>;    // Alarm A enable
            using ALRBE = Field<9, 1>;    // Alarm B enable
            using WUTE = Field<10, 1>;    // Wakeup timer enable
            using TSE = Field<11, 1>;    // Time stamp enable
            using ALRAIE = Field<12, 1>;    // Alarm A interrupt enable
            using ALRBIE = Field<13, 1>;    // Alarm B interrupt enable
            using WUTIE = Field<14, 1>;    // Wakeup timer interrupt enable
            using TSIE = Field<15, 1>;    // Time-stamp interrupt enable
            using ADD1H = Field<16, 1>;    // Add 1 hour (summer time change)
            using SUB1H = Field<17, 1>;    // Subtract 1 hour (winter time change)
            using BKP = Field<18, 1>;    // Backup
            using COSEL = Field<19, 1>;    // Calibration output selection
            using POL = Field<20, 1>;    // Output polarity
            using OSEL = Field<21, 2>;    // Output selection
            using COE = Field<23, 1>;    // Calibration output enable
        };

        // initialization and status register
        struct ISR : public Register<0x4000280c> {
            using ALRAWF = Field<0, 1>;    // Alarm A write flag
            using ALRBWF = Field<1, 1>;    // Alarm B write flag
            using WUTWF = Field<2, 1>;    // Wakeup timer write flag
            using SHPF = Field<3, 1>;    // Shift operation pending
            using INITS = Field<4, 1>;    // Initialization status flag
            using RSF = Field<5, 1>;    // Registers synchronization flag
            using INITF = Field<6, 1>;    // Initialization flag
            using INIT = Field<7, 1>;    // Initialization mode
            using ALRAF = Field<8, 1>;    // Alarm A flag
            using ALRBF = Field<9, 1>;    // Alarm B flag
            using WUTF = Field<10, 1>;    // Wakeup timer flag
            using TSF = Field<11, 1>;    // Time-stamp flag
            using TSOVF = Field<12, 1>;    // Time-stamp overflow flag
            using TAMP1F = Field<13, 1>;    // Tamper detection flag
            using TAMP2F = Field<14, 1>;    // RTC_TAMP2 detection flag
            using TAMP3F = Field<15, 1>;    // RTC_TAMP3 detection flag
            using RECALPF = Field<16, 1>;    // Recalibration pending Flag
        };

        // prescaler register
        struct PRER : public Register<0x40002810> {
            using PREDIV_A = Field<16, 7>;    // Asynchronous prescaler factor
            using PREDIV_S = Field<0, 15>;    // Synchronous prescaler factor
        };

        // wakeup timer register
        struct WUTR : public Register<0x40002814> {
            using WUT = Field<0, 16>;    // Wakeup auto-reload value bits
        };

        // alarm A register
        struct ALRMAR : public Register<0x4000281c> {
            using MSK4 = Field<31, 1>;    // Alarm A date mask
            using WDSEL = Field<30, 1>;    // Week day selection
            using DT = Field<28, 2>;    // Date tens in BCD format
            using DU = Field<24, 4>;    // Date units or day in BCD format
            using MSK3 = Field<23, 1>;    // Alarm A hours mask
            using PM = Field<22, 1>;    // AM/PM notation
            using HT = Field<20, 2>;    // Hour tens in BCD format
            using HU = Field<16, 4>;    // Hour units in BCD format
            using MSK2 = Field<15, 1>;    // Alarm A minutes mask
            using MNT = Field<12, 3>;    // Minute tens in BCD format
            using MNU = Field<8, 4>;    // Minute units in BCD format
            using MSK1 = Field<7, 1>;    // Alarm A seconds mask
            using ST = Field<4, 3>;    // Second tens in BCD format
            using SU = Field<0, 4>;    // Second units in BCD format
        };

        // alarm B register
        struct ALRMBR : public Register<0x40002820> {
            using MSK4 = Field<31, 1>;    // Alarm B date mask
            using WDSEL = Field<30, 1>;    // Week day selection
            using DT = Field<28, 2>;    // Date tens in BCD format
            using DU = Field<24, 4>;    // Date units or day in BCD format
            using MSK3 = Field<23, 1>;    // Alarm B hours mask
            using PM = Field<22, 1>;    // AM/PM notation
            using HT = Field<20, 2>;    // Hour tens in BCD format
            using HU = Field<16, 4>;    // Hour units in BCD format
            using MSK2 = Field<15, 1>;    // Alarm B minutes mask
            using MNT = Field<12, 3>;    // Minute tens in BCD format
            using MNU = Field<8, 4>;    // Minute units in BCD format
            using MSK1 = Field<7, 1>;    // Alarm B seconds mask
            using ST = Field<4, 3>;    // Second tens in BCD format
            using SU = Field<0, 4>;    // Second units in BCD format
        };

        // write protection register
        struct WPR : public Register<0x40002824> {
            using KEY = Field<0, 8>;    // Write protection key
        };

        // sub second register
        struct SSR : public Register<0x40002828> {
            using SS = Field<0, 16>;    // Sub second value
        };

        // shift control register
        struct SHIFTR : public Register<0x4000282c> {
            using ADD1S = Field<31, 1>;    // Add one second
            using SUBFS = Field<0, 15>;    // Subtract a fraction of a second
        };

        // time stamp time register
        struct TSTR : public Register<0x40002830> {
            using SU = Field<0, 4>;    // Second units in BCD format
            using ST = Field<4, 3>;    // Second tens in BCD format
            using MNU = Field<8, 4>;    // Minute units in BCD format
            using MNT = Field<12, 3>;    // Minute tens in BCD format
            using HU = Field<16, 4>;    // Hour units in BCD format
            using HT = Field<20, 2>;    // Hour tens in BCD format
            using PM = Field<22, 1>;    // AM/PM notation
        };

        // time stamp date register
        struct TSDR : public Register<0x40002834> {
            using WDU = Field<13, 3>;    // Week day units
            using MT = Field<12, 1>;    // Month tens in BCD format
            using MU = Field<8, 4>;    // Month units in BCD format
            using DT = Field<4, 2>;    // Date tens in BCD format
            using DU = Field<0, 4>;    // Date units in BCD format
        };

        // timestamp sub second register
        struct TSSSR : public Register<0x40002838> {
            using SS = Field<0, 16>;    // Sub second value
        };

        // calibration register
        struct CALR : public Register<0x4000283c> {
            using CALP = Field<15, 1>;    // Increase frequency of RTC by 488.5 ppm
            using CALW8 = Field<14, 1>;    // Use an 8-second calibration cycle period
            using CALW16 = Field<13, 1>;    // Use a 16-second calibration cycle period
            using CALM = Field<0, 9>;    // Calibration minus
        };

        // tamper and alternate function configuration register
        struct TAFCR : public Register<0x40002840> {
            using TAMP1E = Field<0, 1>;    // Tamper 1 detection enable
            using TAMP1TRG = Field<1, 1>;    // Active level for tamper 1
            using TAMPIE = Field<2, 1>;    // Tamper interrupt enable
            using TAMP2E = Field<3, 1>;    // Tamper 2 detection enable
            using TAMP2TRG = Field<4, 1>;    // Active level for tamper 2
            using TAMP3E = Field<5, 1>;    // Tamper 3 detection enable
            using TAMP3TRG = Field<6, 1>;    // Active level for tamper 3
            using TAMPTS = Field<7, 1>;    // Activate timestamp on tamper detection event
            using TAMPFREQ = Field<8, 3>;    // Tamper sampling frequency
            using TAMPFLT = Field<11, 2>;    // Tamper filter count
            using TAMPPRCH = Field<13, 2>;    // Tamper precharge duration
            using TAMPPUDIS = Field<15, 1>;    // TAMPER pull-up disable
            using PC13VALUE = Field<18, 1>;    // PC13 value
            using PC13MODE = Field<19, 1>;    // PC13 mode
            using PC14VALUE = Field<20, 1>;    // PC14 value
            using PC14MODE = Field<21, 1>;    // PC 14 mode
            using PC15VALUE = Field<22, 1>;    // PC15 value
            using PC15MODE = Field<23, 1>;    // PC15 mode
        };

        // alarm A sub second register
        struct ALRMASSR : public Register<0x40002844> {
            using MASKSS = Field<24, 4>;    // Mask the most-significant bits starting at this bit
            using SS = Field<0, 15>;    // Sub seconds value
        };

        // alarm B sub second register
        struct ALRMBSSR : public Register<0x40002848> {
            using MASKSS = Field<24, 4>;    // Mask the most-significant bits starting at this bit
            using SS = Field<0, 15>;    // Sub seconds value
        };

        // backup register
        struct BKP0R : public Register<0x40002850> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP1R : public Register<0x40002854> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP2R : public Register<0x40002858> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP3R : public Register<0x4000285c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP4R : public Register<0x40002860> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP5R : public Register<0x40002864> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP6R : public Register<0x40002868> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP7R : public Register<0x4000286c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP8R : public Register<0x40002870> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP9R : public Register<0x40002874> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP10R : public Register<0x40002878> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP11R : public Register<0x4000287c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP12R : public Register<0x40002880> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP13R : public Register<0x40002884> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP14R : public Register<0x40002888> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP15R : public Register<0x4000288c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP16R : public Register<0x40002890> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP17R : public Register<0x40002894> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP18R : public Register<0x40002898> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP19R : public Register<0x4000289c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP20R : public Register<0x400028a0> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP21R : public Register<0x400028a4> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP22R : public Register<0x400028a8> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP23R : public Register<0x400028ac> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP24R : public Register<0x400028b0> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP25R : public Register<0x400028b4> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP26R : public Register<0x400028b8> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP27R : public Register<0x400028bc> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP28R : public Register<0x400028c0> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP29R : public Register<0x400028c4> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP30R : public Register<0x400028c8> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP31R : public Register<0x400028cc> {
            using BKP = Field<0, 32>;    // BKP
        };

    };

    // Basic timers
    struct TIM6 {
        // control register 1
        struct CR1 : public Register<0x40001000> {
            using CEN = Field<0, 1>;    // Counter enable
            using UDIS = Field<1, 1>;    // Update disable
            using URS = Field<2, 1>;    // Update request source
            using OPM = Field<3, 1>;    // One-pulse mode
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
        };

        // control register 2
        struct CR2 : public Register<0x40001004> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000100c> {
            using UDE = Field<8, 1>;    // Update DMA request enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40001010> {
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40001014> {
            using UG = Field<0, 1>;    // Update generation
        };

        // counter
        struct CNT : public Register<0x40001024> {
            using Field = Field<0, 16>;    // Low counter value
            using UIFCPY = Field<31, 1>;    // UIF Copy
        };

        // prescaler
        struct PSC : public Register<0x40001028> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000102c> {
            using Field = Field<0, 16>;    // Low Auto-reload value
        };

    };

    // Basic timers
    struct TIM7 {
        // control register 1
        struct CR1 : public Register<0x40001400> {
            using CEN = Field<0, 1>;    // Counter enable
            using UDIS = Field<1, 1>;    // Update disable
            using URS = Field<2, 1>;    // Update request source
            using OPM = Field<3, 1>;    // One-pulse mode
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
        };

        // control register 2
        struct CR2 : public Register<0x40001404> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000140c> {
            using UDE = Field<8, 1>;    // Update DMA request enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40001410> {
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40001414> {
            using UG = Field<0, 1>;    // Update generation
        };

        // counter
        struct CNT : public Register<0x40001424> {
            using Field = Field<0, 16>;    // Low counter value
            using UIFCPY = Field<31, 1>;    // UIF Copy
        };

        // prescaler
        struct PSC : public Register<0x40001428> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000142c> {
            using Field = Field<0, 16>;    // Low Auto-reload value
        };

    };

    // Digital-to-analog converter
    struct DAC1 {
        // control register
        struct CR : public Register<0x40007400> {
            using DMAUDRIE2 = Field<29, 1>;    // DAC channel2 DMA underrun interrupt enable
            using DMAEN2 = Field<28, 1>;    // DAC channel2 DMA enable
            using MAMP2 = Field<24, 4>;    // DAC channel2 mask/amplitude selector
            using WAVE2 = Field<22, 2>;    // DAC channel2 noise/triangle wave generation enable
            using TSEL2 = Field<19, 3>;    // DAC channel2 trigger selection
            using TEN2 = Field<18, 1>;    // DAC channel2 trigger enable
            using BOFF2 = Field<17, 1>;    // DAC channel2 output buffer disable
            using EN2 = Field<16, 1>;    // DAC channel2 enable
            using DMAUDRIE1 = Field<13, 1>;    // DAC channel1 DMA Underrun Interrupt enable
            using DMAEN1 = Field<12, 1>;    // DAC channel1 DMA enable
            using MAMP1 = Field<8, 4>;    // DAC channel1 mask/amplitude selector
            using WAVE1 = Field<6, 2>;    // DAC channel1 noise/triangle wave generation enable
            using TSEL1 = Field<3, 3>;    // DAC channel1 trigger selection
            using TEN1 = Field<2, 1>;    // DAC channel1 trigger enable
            using BOFF1 = Field<1, 1>;    // DAC channel1 output buffer disable
            using EN1 = Field<0, 1>;    // DAC channel1 enable
        };

        // software trigger register
        struct SWTRIGR : public Register<0x40007404> {
            using SWTRIG2 = Field<1, 1>;    // DAC channel2 software trigger
            using SWTRIG1 = Field<0, 1>;    // DAC channel1 software trigger
        };

        // channel1 12-bit right-aligned data holding register
        struct DHR12R1 : public Register<0x40007408> {
            using DACC1DHR = Field<0, 12>;    // DAC channel1 12-bit right-aligned data
        };

        // channel1 12-bit left aligned data holding register
        struct DHR12L1 : public Register<0x4000740c> {
            using DACC1DHR = Field<4, 12>;    // DAC channel1 12-bit left-aligned data
        };

        // channel1 8-bit right aligned data holding register
        struct DHR8R1 : public Register<0x40007410> {
            using DACC1DHR = Field<0, 8>;    // DAC channel1 8-bit right-aligned data
        };

        // channel2 12-bit right aligned data holding register
        struct DHR12R2 : public Register<0x40007414> {
            using DACC2DHR = Field<0, 12>;    // DAC channel2 12-bit right-aligned data
        };

        // channel2 12-bit left aligned data holding register
        struct DHR12L2 : public Register<0x40007418> {
            using DACC2DHR = Field<4, 12>;    // DAC channel2 12-bit left-aligned data
        };

        // channel2 8-bit right-aligned data holding register
        struct DHR8R2 : public Register<0x4000741c> {
            using DACC2DHR = Field<0, 8>;    // DAC channel2 8-bit right-aligned data
        };

        // Dual DAC 12-bit right-aligned data holding register
        struct DHR12RD : public Register<0x40007420> {
            using DACC2DHR = Field<16, 12>;    // DAC channel2 12-bit right-aligned data
            using DACC1DHR = Field<0, 12>;    // DAC channel1 12-bit right-aligned data
        };

        // DUAL DAC 12-bit left aligned data holding register
        struct DHR12LD : public Register<0x40007424> {
            using DACC2DHR = Field<20, 12>;    // DAC channel2 12-bit left-aligned data
            using DACC1DHR = Field<4, 12>;    // DAC channel1 12-bit left-aligned data
        };

        // DUAL DAC 8-bit right aligned data holding register
        struct DHR8RD : public Register<0x40007428> {
            using DACC2DHR = Field<8, 8>;    // DAC channel2 8-bit right-aligned data
            using DACC1DHR = Field<0, 8>;    // DAC channel1 8-bit right-aligned data
        };

        // channel1 data output register
        struct DOR1 : public Register<0x4000742c> {
            using DACC1DOR = Field<0, 12>;    // DAC channel1 data output
        };

        // channel2 data output register
        struct DOR2 : public Register<0x40007430> {
            using DACC2DOR = Field<0, 12>;    // DAC channel2 data output
        };

        // status register
        struct SR : public Register<0x40007434> {
            using DMAUDR2 = Field<29, 1>;    // DAC channel2 DMA underrun flag
            using DMAUDR1 = Field<13, 1>;    // DAC channel1 DMA underrun flag
        };

    };

    // Digital-to-analog converter
    struct DAC2 {
        // control register
        struct CR : public Register<0x40009800> {
            using DMAUDRIE2 = Field<29, 1>;    // DAC channel2 DMA underrun interrupt enable
            using DMAEN2 = Field<28, 1>;    // DAC channel2 DMA enable
            using MAMP2 = Field<24, 4>;    // DAC channel2 mask/amplitude selector
            using WAVE2 = Field<22, 2>;    // DAC channel2 noise/triangle wave generation enable
            using TSEL2 = Field<19, 3>;    // DAC channel2 trigger selection
            using TEN2 = Field<18, 1>;    // DAC channel2 trigger enable
            using BOFF2 = Field<17, 1>;    // DAC channel2 output buffer disable
            using EN2 = Field<16, 1>;    // DAC channel2 enable
            using DMAUDRIE1 = Field<13, 1>;    // DAC channel1 DMA Underrun Interrupt enable
            using DMAEN1 = Field<12, 1>;    // DAC channel1 DMA enable
            using MAMP1 = Field<8, 4>;    // DAC channel1 mask/amplitude selector
            using WAVE1 = Field<6, 2>;    // DAC channel1 noise/triangle wave generation enable
            using TSEL1 = Field<3, 3>;    // DAC channel1 trigger selection
            using TEN1 = Field<2, 1>;    // DAC channel1 trigger enable
            using BOFF1 = Field<1, 1>;    // DAC channel1 output buffer disable
            using EN1 = Field<0, 1>;    // DAC channel1 enable
        };

        // software trigger register
        struct SWTRIGR : public Register<0x40009804> {
            using SWTRIG2 = Field<1, 1>;    // DAC channel2 software trigger
            using SWTRIG1 = Field<0, 1>;    // DAC channel1 software trigger
        };

        // channel1 12-bit right-aligned data holding register
        struct DHR12R1 : public Register<0x40009808> {
            using DACC1DHR = Field<0, 12>;    // DAC channel1 12-bit right-aligned data
        };

        // channel1 12-bit left aligned data holding register
        struct DHR12L1 : public Register<0x4000980c> {
            using DACC1DHR = Field<4, 12>;    // DAC channel1 12-bit left-aligned data
        };

        // channel1 8-bit right aligned data holding register
        struct DHR8R1 : public Register<0x40009810> {
            using DACC1DHR = Field<0, 8>;    // DAC channel1 8-bit right-aligned data
        };

        // channel2 12-bit right aligned data holding register
        struct DHR12R2 : public Register<0x40009814> {
            using DACC2DHR = Field<0, 12>;    // DAC channel2 12-bit right-aligned data
        };

        // channel2 12-bit left aligned data holding register
        struct DHR12L2 : public Register<0x40009818> {
            using DACC2DHR = Field<4, 12>;    // DAC channel2 12-bit left-aligned data
        };

        // channel2 8-bit right-aligned data holding register
        struct DHR8R2 : public Register<0x4000981c> {
            using DACC2DHR = Field<0, 8>;    // DAC channel2 8-bit right-aligned data
        };

        // Dual DAC 12-bit right-aligned data holding register
        struct DHR12RD : public Register<0x40009820> {
            using DACC2DHR = Field<16, 12>;    // DAC channel2 12-bit right-aligned data
            using DACC1DHR = Field<0, 12>;    // DAC channel1 12-bit right-aligned data
        };

        // DUAL DAC 12-bit left aligned data holding register
        struct DHR12LD : public Register<0x40009824> {
            using DACC2DHR = Field<20, 12>;    // DAC channel2 12-bit left-aligned data
            using DACC1DHR = Field<4, 12>;    // DAC channel1 12-bit left-aligned data
        };

        // DUAL DAC 8-bit right aligned data holding register
        struct DHR8RD : public Register<0x40009828> {
            using DACC2DHR = Field<8, 8>;    // DAC channel2 8-bit right-aligned data
            using DACC1DHR = Field<0, 8>;    // DAC channel1 8-bit right-aligned data
        };

        // channel1 data output register
        struct DOR1 : public Register<0x4000982c> {
            using DACC1DOR = Field<0, 12>;    // DAC channel1 data output
        };

        // channel2 data output register
        struct DOR2 : public Register<0x40009830> {
            using DACC2DOR = Field<0, 12>;    // DAC channel2 data output
        };

        // status register
        struct SR : public Register<0x40009834> {
            using DMAUDR2 = Field<29, 1>;    // DAC channel2 DMA underrun flag
            using DMAUDR1 = Field<13, 1>;    // DAC channel1 DMA underrun flag
        };

    };

    // Debug support
    struct DBGMCU {
        // MCU Device ID Code Register
        struct IDCODE : public Register<0xe0042000> {
            using DEV_ID = Field<0, 12>;    // Device Identifier
            using REV_ID = Field<16, 16>;    // Revision Identifier
        };

        // Debug MCU Configuration Register
        struct CR : public Register<0xe0042004> {
            using DBG_SLEEP = Field<0, 1>;    // Debug Sleep mode
            using DBG_STOP = Field<1, 1>;    // Debug Stop Mode
            using DBG_STANDBY = Field<2, 1>;    // Debug Standby Mode
            using TRACE_IOEN = Field<5, 1>;    // Trace pin assignment control
            using TRACE_MODE = Field<6, 2>;    // Trace pin assignment control
        };

        // APB Low Freeze Register
        struct APB1FZ : public Register<0xe0042008> {
            using DBG_TIM2_STOP = Field<0, 1>;    // Debug Timer 2 stopped when Core is halted
            using DBG_TIM3_STOP = Field<1, 1>;    // Debug Timer 3 stopped when Core is halted
            using DBG_TIM4_STOP = Field<2, 1>;    // Debug Timer 4 stopped when Core is halted
            using DBG_TIM5_STOP = Field<3, 1>;    // Debug Timer 5 stopped when Core is halted
            using DBG_TIM6_STOP = Field<4, 1>;    // Debug Timer 6 stopped when Core is halted
            using DBG_TIM7_STOP = Field<5, 1>;    // Debug Timer 7 stopped when Core is halted
            using DBG_TIM12_STOP = Field<6, 1>;    // Debug Timer 12 stopped when Core is halted
            using DBG_TIM13_STOP = Field<7, 1>;    // Debug Timer 13 stopped when Core is halted
            using DBG_TIMER14_STOP = Field<8, 1>;    // Debug Timer 14 stopped when Core is halted
            using DBG_TIM18_STOP = Field<9, 1>;    // Debug Timer 18 stopped when Core is halted
            using DBG_RTC_STOP = Field<10, 1>;    // Debug RTC stopped when Core is halted
            using DBG_WWDG_STOP = Field<11, 1>;    // Debug Window Wachdog stopped when Core is halted
            using DBG_IWDG_STOP = Field<12, 1>;    // Debug Independent Wachdog stopped when Core is halted
            using I2C1_SMBUS_TIMEOUT = Field<21, 1>;    // SMBUS timeout mode stopped when Core is halted
            using I2C2_SMBUS_TIMEOUT = Field<22, 1>;    // SMBUS timeout mode stopped when Core is halted
            using DBG_CAN_STOP = Field<25, 1>;    // Debug CAN stopped when core is halted
        };

        // APB High Freeze Register
        struct APB2FZ : public Register<0xe004200c> {
            using DBG_TIM15_STOP = Field<2, 1>;    // Debug Timer 15 stopped when Core is halted
            using DBG_TIM16_STOP = Field<3, 1>;    // Debug Timer 16 stopped when Core is halted
            using DBG_TIM17_STO = Field<4, 1>;    // Debug Timer 17 stopped when Core is halted
            using DBG_TIM19_STOP = Field<5, 1>;    // Debug Timer 19 stopped when Core is halted
        };

    };

    // Advanced timer
    struct TIM1 {
        // control register 1
        struct CR1 : public Register<0x40012c00> {
            using CEN = Field<0, 1>;    // Counter enable
            using UDIS = Field<1, 1>;    // Update disable
            using URS = Field<2, 1>;    // Update request source
            using OPM = Field<3, 1>;    // One-pulse mode
            using DIR = Field<4, 1>;    // Direction
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CKD = Field<8, 2>;    // Clock division
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
        };

        // control register 2
        struct CR2 : public Register<0x40012c04> {
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using MMS = Field<4, 3>;    // Master mode selection
            using TI1S = Field<7, 1>;    // TI1 selection
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS2 = Field<10, 1>;    // Output Idle state 2
            using OIS2N = Field<11, 1>;    // Output Idle state 2
            using OIS3 = Field<12, 1>;    // Output Idle state 3
            using OIS3N = Field<13, 1>;    // Output Idle state 3
            using OIS4 = Field<14, 1>;    // Output Idle state 4
            using OIS5 = Field<16, 1>;    // Output Idle state 5
            using OIS6 = Field<18, 1>;    // Output Idle state 6
            using MMS2 = Field<20, 4>;    // Master mode selection 2
        };

        // slave mode control register
        struct SMCR : public Register<0x40012c08> {
            using SMS = Field<0, 3>;    // Slave mode selection
            using OCCS = Field<3, 1>;    // OCREF clear selection
            using TS = Field<4, 3>;    // Trigger selection
            using MSM = Field<7, 1>;    // Master/Slave mode
            using ETF = Field<8, 4>;    // External trigger filter
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ECE = Field<14, 1>;    // External clock enable
            using ETP = Field<15, 1>;    // External trigger polarity
            using SMS3 = Field<16, 1>;    // Slave mode selection bit 3
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x40012c0c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40012c10> {
            using UIF = Field<0, 1>;    // Update interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using B2IF = Field<8, 1>;    // Break 2 interrupt flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using C5IF = Field<16, 1>;    // Capture/Compare 5 interrupt flag
            using C6IF = Field<17, 1>;    // Capture/Compare 6 interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40012c14> {
            using UG = Field<0, 1>;    // Update generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using TG = Field<6, 1>;    // Trigger generation
            using BG = Field<7, 1>;    // Break generation
            using B2G = Field<8, 1>;    // Break 2 generation
        };

        // capture/compare mode register (output mode)
        struct CCMR1_Output : public Register<0x40012c18> {
            using OC2CE = Field<15, 1>;    // Output Compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output Compare 2 mode
            using OC2PE = Field<11, 1>;    // Output Compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output Compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output Compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode bit 3
            using OC2M_3 = Field<24, 1>;    // Output Compare 2 mode bit 3
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40012c18> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register (output mode)
        struct CCMR2_Output : public Register<0x40012c1c> {
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
            using OC3M_3 = Field<16, 1>;    // Output Compare 3 mode bit 3
            using OC4M_3 = Field<24, 1>;    // Output Compare 4 mode bit 3
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x40012c1c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40012c20> {
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2NE = Field<6, 1>;    // Capture/Compare 2 complementary output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3NE = Field<10, 1>;    // Capture/Compare 3 complementary output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 output Polarity
            using CC5E = Field<16, 1>;    // Capture/Compare 5 output enable
            using CC5P = Field<17, 1>;    // Capture/Compare 5 output Polarity
            using CC6E = Field<20, 1>;    // Capture/Compare 6 output enable
            using CC6P = Field<21, 1>;    // Capture/Compare 6 output Polarity
        };

        // counter
        struct CNT : public Register<0x40012c24> {
            using Field = Field<0, 16>;    // counter value
            using UIFCPY = Field<31, 1>;    // UIF copy
        };

        // prescaler
        struct PSC : public Register<0x40012c28> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x40012c2c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // repetition counter register
        struct RCR : public Register<0x40012c30> {
            using REP = Field<0, 16>;    // Repetition counter value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40012c34> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40012c38> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x40012c3c> {
            using Field = Field<0, 16>;    // Capture/Compare 3 value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40012c40> {
            using Field = Field<0, 16>;    // Capture/Compare 3 value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40012c44> {
            using DTG = Field<0, 8>;    // Dead-time generator setup
            using LOCK = Field<8, 2>;    // Lock configuration
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using BKE = Field<12, 1>;    // Break enable
            using BKP = Field<13, 1>;    // Break polarity
            using AOE = Field<14, 1>;    // Automatic output enable
            using MOE = Field<15, 1>;    // Main output enable
            using BKF = Field<16, 4>;    // Break filter
            using BK2F = Field<20, 4>;    // Break 2 filter
            using BK2E = Field<24, 1>;    // Break 2 enable
            using BK2P = Field<25, 1>;    // Break 2 polarity
        };

        // DMA control register
        struct DCR : public Register<0x40012c48> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x40012c4c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // capture/compare mode register 3 (output mode)
        struct CCMR3_Output : public Register<0x40012c54> {
            using OC5FE = Field<2, 1>;    // Output compare 5 fast enable
            using OC5PE = Field<3, 1>;    // Output compare 5 preload enable
            using OC5M = Field<4, 3>;    // Output compare 5 mode
            using OC5CE = Field<7, 1>;    // Output compare 5 clear enable
            using OC6FE = Field<10, 1>;    // Output compare 6 fast enable
            using OC6PE = Field<11, 1>;    // Output compare 6 preload enable
            using OC6M = Field<12, 3>;    // Output compare 6 mode
            using OC6CE = Field<15, 1>;    // Output compare 6 clear enable
            using OC5M_3 = Field<16, 1>;    // Outout Compare 5 mode bit 3
            using OC6M_3 = Field<24, 1>;    // Outout Compare 6 mode bit 3
        };

        // capture/compare register 5
        struct CCR5 : public Register<0x40012c58> {
            using Field = Field<0, 16>;    // Capture/Compare 5 value
            using GC5C1 = Field<29, 1>;    // Group Channel 5 and Channel 1
            using GC5C2 = Field<30, 1>;    // Group Channel 5 and Channel 2
            using GC5C3 = Field<31, 1>;    // Group Channel 5 and Channel 3
        };

        // capture/compare register 6
        struct CCR6 : public Register<0x40012c5c> {
            using Field = Field<0, 16>;    // Capture/Compare 6 value
        };

        // option registers
        struct OR : public Register<0x40012c60> {
            using TIM1_ETR_ADC1_RMP = Field<0, 2>;    // TIM1_ETR_ADC1 remapping capability
            using TIM1_ETR_ADC4_RMP = Field<2, 2>;    // TIM1_ETR_ADC4 remapping capability
        };

    };

    // Analog-to-Digital Converter
    struct ADC1 {
        // interrupt and status register
        struct ISR : public Register<0x50000000> {
            using JQOVF = Field<10, 1>;    // JQOVF
            using AWD3 = Field<9, 1>;    // AWD3
            using AWD2 = Field<8, 1>;    // AWD2
            using AWD1 = Field<7, 1>;    // AWD1
            using JEOS = Field<6, 1>;    // JEOS
            using JEOC = Field<5, 1>;    // JEOC
            using OVR = Field<4, 1>;    // OVR
            using EOS = Field<3, 1>;    // EOS
            using EOC = Field<2, 1>;    // EOC
            using EOSMP = Field<1, 1>;    // EOSMP
            using ADRDY = Field<0, 1>;    // ADRDY
        };

        // interrupt enable register
        struct IER : public Register<0x50000004> {
            using JQOVFIE = Field<10, 1>;    // JQOVFIE
            using AWD3IE = Field<9, 1>;    // AWD3IE
            using AWD2IE = Field<8, 1>;    // AWD2IE
            using AWD1IE = Field<7, 1>;    // AWD1IE
            using JEOSIE = Field<6, 1>;    // JEOSIE
            using JEOCIE = Field<5, 1>;    // JEOCIE
            using OVRIE = Field<4, 1>;    // OVRIE
            using EOSIE = Field<3, 1>;    // EOSIE
            using EOCIE = Field<2, 1>;    // EOCIE
            using EOSMPIE = Field<1, 1>;    // EOSMPIE
            using ADRDYIE = Field<0, 1>;    // ADRDYIE
        };

        // control register
        struct CR : public Register<0x50000008> {
            using ADCAL = Field<31, 1>;    // ADCAL
            using ADCALDIF = Field<30, 1>;    // ADCALDIF
            using DEEPPWD = Field<29, 1>;    // DEEPPWD
            using ADVREGEN = Field<28, 1>;    // ADVREGEN
            using JADSTP = Field<5, 1>;    // JADSTP
            using ADSTP = Field<4, 1>;    // ADSTP
            using JADSTART = Field<3, 1>;    // JADSTART
            using ADSTART = Field<2, 1>;    // ADSTART
            using ADDIS = Field<1, 1>;    // ADDIS
            using ADEN = Field<0, 1>;    // ADEN
        };

        // configuration register
        struct CFGR : public Register<0x5000000c> {
            using AWDCH1CH = Field<26, 5>;    // AWDCH1CH
            using JAUTO = Field<25, 1>;    // JAUTO
            using JAWD1EN = Field<24, 1>;    // JAWD1EN
            using AWD1EN = Field<23, 1>;    // AWD1EN
            using AWD1SGL = Field<22, 1>;    // AWD1SGL
            using JQM = Field<21, 1>;    // JQM
            using JDISCEN = Field<20, 1>;    // JDISCEN
            using DISCNUM = Field<17, 3>;    // DISCNUM
            using DISCEN = Field<16, 1>;    // DISCEN
            using AUTOFF = Field<15, 1>;    // AUTOFF
            using AUTDLY = Field<14, 1>;    // AUTDLY
            using CONT = Field<13, 1>;    // CONT
            using OVRMOD = Field<12, 1>;    // OVRMOD
            using EXTEN = Field<10, 2>;    // EXTEN
            using EXTSEL = Field<6, 4>;    // EXTSEL
            using ALIGN = Field<5, 1>;    // ALIGN
            using RES = Field<3, 2>;    // RES
            using DMACFG = Field<1, 1>;    // DMACFG
            using DMAEN = Field<0, 1>;    // DMAEN
        };

        // sample time register 1
        struct SMPR1 : public Register<0x50000014> {
            using SMP9 = Field<27, 3>;    // SMP9
            using SMP8 = Field<24, 3>;    // SMP8
            using SMP7 = Field<21, 3>;    // SMP7
            using SMP6 = Field<18, 3>;    // SMP6
            using SMP5 = Field<15, 3>;    // SMP5
            using SMP4 = Field<12, 3>;    // SMP4
            using SMP3 = Field<9, 3>;    // SMP3
            using SMP2 = Field<6, 3>;    // SMP2
            using SMP1 = Field<3, 3>;    // SMP1
        };

        // sample time register 2
        struct SMPR2 : public Register<0x50000018> {
            using SMP18 = Field<24, 3>;    // SMP18
            using SMP17 = Field<21, 3>;    // SMP17
            using SMP16 = Field<18, 3>;    // SMP16
            using SMP15 = Field<15, 3>;    // SMP15
            using SMP14 = Field<12, 3>;    // SMP14
            using SMP13 = Field<9, 3>;    // SMP13
            using SMP12 = Field<6, 3>;    // SMP12
            using SMP11 = Field<3, 3>;    // SMP11
            using SMP10 = Field<0, 3>;    // SMP10
        };

        // watchdog threshold register 1
        struct TR1 : public Register<0x50000020> {
            using HT1 = Field<16, 12>;    // HT1
            using LT1 = Field<0, 12>;    // LT1
        };

        // watchdog threshold register
        struct TR2 : public Register<0x50000024> {
            using HT2 = Field<16, 8>;    // HT2
            using LT2 = Field<0, 8>;    // LT2
        };

        // watchdog threshold register 3
        struct TR3 : public Register<0x50000028> {
            using HT3 = Field<16, 8>;    // HT3
            using LT3 = Field<0, 8>;    // LT3
        };

        // regular sequence register 1
        struct SQR1 : public Register<0x50000030> {
            using SQ4 = Field<24, 5>;    // SQ4
            using SQ3 = Field<18, 5>;    // SQ3
            using SQ2 = Field<12, 5>;    // SQ2
            using SQ1 = Field<6, 5>;    // SQ1
            using L3 = Field<0, 4>;    // L3
        };

        // regular sequence register 2
        struct SQR2 : public Register<0x50000034> {
            using SQ9 = Field<24, 5>;    // SQ9
            using SQ8 = Field<18, 5>;    // SQ8
            using SQ7 = Field<12, 5>;    // SQ7
            using SQ6 = Field<6, 5>;    // SQ6
            using SQ5 = Field<0, 5>;    // SQ5
        };

        // regular sequence register 3
        struct SQR3 : public Register<0x50000038> {
            using SQ14 = Field<24, 5>;    // SQ14
            using SQ13 = Field<18, 5>;    // SQ13
            using SQ12 = Field<12, 5>;    // SQ12
            using SQ11 = Field<6, 5>;    // SQ11
            using SQ10 = Field<0, 5>;    // SQ10
        };

        // regular sequence register 4
        struct SQR4 : public Register<0x5000003c> {
            using SQ16 = Field<6, 5>;    // SQ16
            using SQ15 = Field<0, 5>;    // SQ15
        };

        // regular Data Register
        struct DR : public Register<0x50000040> {
            using regularDATA = Field<0, 16>;    // regularDATA
        };

        // injected sequence register
        struct JSQR : public Register<0x5000004c> {
            using JSQ4 = Field<26, 5>;    // JSQ4
            using JSQ3 = Field<20, 5>;    // JSQ3
            using JSQ2 = Field<14, 5>;    // JSQ2
            using JSQ1 = Field<8, 5>;    // JSQ1
            using JEXTEN = Field<6, 2>;    // JEXTEN
            using JEXTSEL = Field<2, 4>;    // JEXTSEL
            using JL = Field<0, 2>;    // JL
        };

        // offset register 1
        struct OFR1 : public Register<0x50000060> {
            using OFFSET1_EN = Field<31, 1>;    // OFFSET1_EN
            using OFFSET1_CH = Field<26, 5>;    // OFFSET1_CH
            using OFFSET1 = Field<0, 12>;    // OFFSET1
        };

        // offset register 2
        struct OFR2 : public Register<0x50000064> {
            using OFFSET2_EN = Field<31, 1>;    // OFFSET2_EN
            using OFFSET2_CH = Field<26, 5>;    // OFFSET2_CH
            using OFFSET2 = Field<0, 12>;    // OFFSET2
        };

        // offset register 3
        struct OFR3 : public Register<0x50000068> {
            using OFFSET3_EN = Field<31, 1>;    // OFFSET3_EN
            using OFFSET3_CH = Field<26, 5>;    // OFFSET3_CH
            using OFFSET3 = Field<0, 12>;    // OFFSET3
        };

        // offset register 4
        struct OFR4 : public Register<0x5000006c> {
            using OFFSET4_EN = Field<31, 1>;    // OFFSET4_EN
            using OFFSET4_CH = Field<26, 5>;    // OFFSET4_CH
            using OFFSET4 = Field<0, 12>;    // OFFSET4
        };

        // injected data register 1
        struct JDR1 : public Register<0x50000080> {
            using JDATA1 = Field<0, 16>;    // JDATA1
        };

        // injected data register 2
        struct JDR2 : public Register<0x50000084> {
            using JDATA2 = Field<0, 16>;    // JDATA2
        };

        // injected data register 3
        struct JDR3 : public Register<0x50000088> {
            using JDATA3 = Field<0, 16>;    // JDATA3
        };

        // injected data register 4
        struct JDR4 : public Register<0x5000008c> {
            using JDATA4 = Field<0, 16>;    // JDATA4
        };

        // Analog Watchdog 2 Configuration Register
        struct AWD2CR : public Register<0x500000a0> {
            using AWD2CH = Field<1, 18>;    // AWD2CH
        };

        // Analog Watchdog 3 Configuration Register
        struct AWD3CR : public Register<0x500000a4> {
            using AWD3CH = Field<1, 18>;    // AWD3CH
        };

        // Differential Mode Selection Register 2
        struct DIFSEL : public Register<0x500000b0> {
            using DIFSEL_1_15 = Field<1, 15>;    // Differential mode for channels 15 to 1
            using DIFSEL_16_18 = Field<16, 3>;    // Differential mode for channels 18 to 16
        };

        // Calibration Factors
        struct CALFACT : public Register<0x500000b4> {
            using CALFACT_D = Field<16, 7>;    // CALFACT_D
            using CALFACT_S = Field<0, 7>;    // CALFACT_S
        };

    };

    // Analog-to-Digital Converter
    struct ADC2 {
        // interrupt and status register
        struct ISR : public Register<0x50000100> {
            using JQOVF = Field<10, 1>;    // JQOVF
            using AWD3 = Field<9, 1>;    // AWD3
            using AWD2 = Field<8, 1>;    // AWD2
            using AWD1 = Field<7, 1>;    // AWD1
            using JEOS = Field<6, 1>;    // JEOS
            using JEOC = Field<5, 1>;    // JEOC
            using OVR = Field<4, 1>;    // OVR
            using EOS = Field<3, 1>;    // EOS
            using EOC = Field<2, 1>;    // EOC
            using EOSMP = Field<1, 1>;    // EOSMP
            using ADRDY = Field<0, 1>;    // ADRDY
        };

        // interrupt enable register
        struct IER : public Register<0x50000104> {
            using JQOVFIE = Field<10, 1>;    // JQOVFIE
            using AWD3IE = Field<9, 1>;    // AWD3IE
            using AWD2IE = Field<8, 1>;    // AWD2IE
            using AWD1IE = Field<7, 1>;    // AWD1IE
            using JEOSIE = Field<6, 1>;    // JEOSIE
            using JEOCIE = Field<5, 1>;    // JEOCIE
            using OVRIE = Field<4, 1>;    // OVRIE
            using EOSIE = Field<3, 1>;    // EOSIE
            using EOCIE = Field<2, 1>;    // EOCIE
            using EOSMPIE = Field<1, 1>;    // EOSMPIE
            using ADRDYIE = Field<0, 1>;    // ADRDYIE
        };

        // control register
        struct CR : public Register<0x50000108> {
            using ADCAL = Field<31, 1>;    // ADCAL
            using ADCALDIF = Field<30, 1>;    // ADCALDIF
            using DEEPPWD = Field<29, 1>;    // DEEPPWD
            using ADVREGEN = Field<28, 1>;    // ADVREGEN
            using JADSTP = Field<5, 1>;    // JADSTP
            using ADSTP = Field<4, 1>;    // ADSTP
            using JADSTART = Field<3, 1>;    // JADSTART
            using ADSTART = Field<2, 1>;    // ADSTART
            using ADDIS = Field<1, 1>;    // ADDIS
            using ADEN = Field<0, 1>;    // ADEN
        };

        // configuration register
        struct CFGR : public Register<0x5000010c> {
            using AWDCH1CH = Field<26, 5>;    // AWDCH1CH
            using JAUTO = Field<25, 1>;    // JAUTO
            using JAWD1EN = Field<24, 1>;    // JAWD1EN
            using AWD1EN = Field<23, 1>;    // AWD1EN
            using AWD1SGL = Field<22, 1>;    // AWD1SGL
            using JQM = Field<21, 1>;    // JQM
            using JDISCEN = Field<20, 1>;    // JDISCEN
            using DISCNUM = Field<17, 3>;    // DISCNUM
            using DISCEN = Field<16, 1>;    // DISCEN
            using AUTOFF = Field<15, 1>;    // AUTOFF
            using AUTDLY = Field<14, 1>;    // AUTDLY
            using CONT = Field<13, 1>;    // CONT
            using OVRMOD = Field<12, 1>;    // OVRMOD
            using EXTEN = Field<10, 2>;    // EXTEN
            using EXTSEL = Field<6, 4>;    // EXTSEL
            using ALIGN = Field<5, 1>;    // ALIGN
            using RES = Field<3, 2>;    // RES
            using DMACFG = Field<1, 1>;    // DMACFG
            using DMAEN = Field<0, 1>;    // DMAEN
        };

        // sample time register 1
        struct SMPR1 : public Register<0x50000114> {
            using SMP9 = Field<27, 3>;    // SMP9
            using SMP8 = Field<24, 3>;    // SMP8
            using SMP7 = Field<21, 3>;    // SMP7
            using SMP6 = Field<18, 3>;    // SMP6
            using SMP5 = Field<15, 3>;    // SMP5
            using SMP4 = Field<12, 3>;    // SMP4
            using SMP3 = Field<9, 3>;    // SMP3
            using SMP2 = Field<6, 3>;    // SMP2
            using SMP1 = Field<3, 3>;    // SMP1
        };

        // sample time register 2
        struct SMPR2 : public Register<0x50000118> {
            using SMP18 = Field<24, 3>;    // SMP18
            using SMP17 = Field<21, 3>;    // SMP17
            using SMP16 = Field<18, 3>;    // SMP16
            using SMP15 = Field<15, 3>;    // SMP15
            using SMP14 = Field<12, 3>;    // SMP14
            using SMP13 = Field<9, 3>;    // SMP13
            using SMP12 = Field<6, 3>;    // SMP12
            using SMP11 = Field<3, 3>;    // SMP11
            using SMP10 = Field<0, 3>;    // SMP10
        };

        // watchdog threshold register 1
        struct TR1 : public Register<0x50000120> {
            using HT1 = Field<16, 12>;    // HT1
            using LT1 = Field<0, 12>;    // LT1
        };

        // watchdog threshold register
        struct TR2 : public Register<0x50000124> {
            using HT2 = Field<16, 8>;    // HT2
            using LT2 = Field<0, 8>;    // LT2
        };

        // watchdog threshold register 3
        struct TR3 : public Register<0x50000128> {
            using HT3 = Field<16, 8>;    // HT3
            using LT3 = Field<0, 8>;    // LT3
        };

        // regular sequence register 1
        struct SQR1 : public Register<0x50000130> {
            using SQ4 = Field<24, 5>;    // SQ4
            using SQ3 = Field<18, 5>;    // SQ3
            using SQ2 = Field<12, 5>;    // SQ2
            using SQ1 = Field<6, 5>;    // SQ1
            using L3 = Field<0, 4>;    // L3
        };

        // regular sequence register 2
        struct SQR2 : public Register<0x50000134> {
            using SQ9 = Field<24, 5>;    // SQ9
            using SQ8 = Field<18, 5>;    // SQ8
            using SQ7 = Field<12, 5>;    // SQ7
            using SQ6 = Field<6, 5>;    // SQ6
            using SQ5 = Field<0, 5>;    // SQ5
        };

        // regular sequence register 3
        struct SQR3 : public Register<0x50000138> {
            using SQ14 = Field<24, 5>;    // SQ14
            using SQ13 = Field<18, 5>;    // SQ13
            using SQ12 = Field<12, 5>;    // SQ12
            using SQ11 = Field<6, 5>;    // SQ11
            using SQ10 = Field<0, 5>;    // SQ10
        };

        // regular sequence register 4
        struct SQR4 : public Register<0x5000013c> {
            using SQ16 = Field<6, 5>;    // SQ16
            using SQ15 = Field<0, 5>;    // SQ15
        };

        // regular Data Register
        struct DR : public Register<0x50000140> {
            using regularDATA = Field<0, 16>;    // regularDATA
        };

        // injected sequence register
        struct JSQR : public Register<0x5000014c> {
            using JSQ4 = Field<26, 5>;    // JSQ4
            using JSQ3 = Field<20, 5>;    // JSQ3
            using JSQ2 = Field<14, 5>;    // JSQ2
            using JSQ1 = Field<8, 5>;    // JSQ1
            using JEXTEN = Field<6, 2>;    // JEXTEN
            using JEXTSEL = Field<2, 4>;    // JEXTSEL
            using JL = Field<0, 2>;    // JL
        };

        // offset register 1
        struct OFR1 : public Register<0x50000160> {
            using OFFSET1_EN = Field<31, 1>;    // OFFSET1_EN
            using OFFSET1_CH = Field<26, 5>;    // OFFSET1_CH
            using OFFSET1 = Field<0, 12>;    // OFFSET1
        };

        // offset register 2
        struct OFR2 : public Register<0x50000164> {
            using OFFSET2_EN = Field<31, 1>;    // OFFSET2_EN
            using OFFSET2_CH = Field<26, 5>;    // OFFSET2_CH
            using OFFSET2 = Field<0, 12>;    // OFFSET2
        };

        // offset register 3
        struct OFR3 : public Register<0x50000168> {
            using OFFSET3_EN = Field<31, 1>;    // OFFSET3_EN
            using OFFSET3_CH = Field<26, 5>;    // OFFSET3_CH
            using OFFSET3 = Field<0, 12>;    // OFFSET3
        };

        // offset register 4
        struct OFR4 : public Register<0x5000016c> {
            using OFFSET4_EN = Field<31, 1>;    // OFFSET4_EN
            using OFFSET4_CH = Field<26, 5>;    // OFFSET4_CH
            using OFFSET4 = Field<0, 12>;    // OFFSET4
        };

        // injected data register 1
        struct JDR1 : public Register<0x50000180> {
            using JDATA1 = Field<0, 16>;    // JDATA1
        };

        // injected data register 2
        struct JDR2 : public Register<0x50000184> {
            using JDATA2 = Field<0, 16>;    // JDATA2
        };

        // injected data register 3
        struct JDR3 : public Register<0x50000188> {
            using JDATA3 = Field<0, 16>;    // JDATA3
        };

        // injected data register 4
        struct JDR4 : public Register<0x5000018c> {
            using JDATA4 = Field<0, 16>;    // JDATA4
        };

        // Analog Watchdog 2 Configuration Register
        struct AWD2CR : public Register<0x500001a0> {
            using AWD2CH = Field<1, 18>;    // AWD2CH
        };

        // Analog Watchdog 3 Configuration Register
        struct AWD3CR : public Register<0x500001a4> {
            using AWD3CH = Field<1, 18>;    // AWD3CH
        };

        // Differential Mode Selection Register 2
        struct DIFSEL : public Register<0x500001b0> {
            using DIFSEL_1_15 = Field<1, 15>;    // Differential mode for channels 15 to 1
            using DIFSEL_16_18 = Field<16, 3>;    // Differential mode for channels 18 to 16
        };

        // Calibration Factors
        struct CALFACT : public Register<0x500001b4> {
            using CALFACT_D = Field<16, 7>;    // CALFACT_D
            using CALFACT_S = Field<0, 7>;    // CALFACT_S
        };

    };

    // System configuration controller
    struct SYSCFG_COMP_OPAMP {
        // configuration register 1
        struct SYSCFG_CFGR1 : public Register<0x40010000> {
            using MEM_MODE = Field<0, 2>;    // Memory mapping selection bits
            using USB_IT_RMP = Field<5, 1>;    // USB interrupt remap
            using TIM1_ITR_RMP = Field<6, 1>;    // Timer 1 ITR3 selection
            using DAC_TRIG_RMP = Field<7, 1>;    // DAC trigger remap (when TSEL = 001)
            using ADC24_DMA_RMP = Field<8, 1>;    // ADC24 DMA remapping bit
            using TIM16_DMA_RMP = Field<11, 1>;    // TIM16 DMA request remapping bit
            using TIM17_DMA_RMP = Field<12, 1>;    // TIM17 DMA request remapping bit
            using TIM6_DAC1_DMA_RMP = Field<13, 1>;    // TIM6 and DAC1 DMA request remapping bit
            using TIM7_DAC2_DMA_RMP = Field<14, 1>;    // TIM7 and DAC2 DMA request remapping bit
            using I2C_PB6_FM = Field<16, 1>;    // Fast Mode Plus (FM+) driving capability activation bits.
            using I2C_PB7_FM = Field<17, 1>;    // Fast Mode Plus (FM+) driving capability activation bits.
            using I2C_PB8_FM = Field<18, 1>;    // Fast Mode Plus (FM+) driving capability activation bits.
            using I2C_PB9_FM = Field<19, 1>;    // Fast Mode Plus (FM+) driving capability activation bits.
            using I2C1_FM = Field<20, 1>;    // I2C1 Fast Mode Plus
            using I2C2_FM = Field<21, 1>;    // I2C2 Fast Mode Plus
            using ENCODER_MODE = Field<22, 2>;    // Encoder mode
            using FPU_IT = Field<26, 6>;    // Interrupt enable bits from FPU
        };

        // external interrupt configuration register 1
        struct SYSCFG_EXTICR1 : public Register<0x40010008> {
            using EXTI3 = Field<12, 4>;    // EXTI 3 configuration bits
            using EXTI2 = Field<8, 4>;    // EXTI 2 configuration bits
            using EXTI1 = Field<4, 4>;    // EXTI 1 configuration bits
            using EXTI0 = Field<0, 4>;    // EXTI 0 configuration bits
        };

        // external interrupt configuration register 2
        struct SYSCFG_EXTICR2 : public Register<0x4001000c> {
            using EXTI7 = Field<12, 4>;    // EXTI 7 configuration bits
            using EXTI6 = Field<8, 4>;    // EXTI 6 configuration bits
            using EXTI5 = Field<4, 4>;    // EXTI 5 configuration bits
            using EXTI4 = Field<0, 4>;    // EXTI 4 configuration bits
        };

        // external interrupt configuration register 3
        struct SYSCFG_EXTICR3 : public Register<0x40010010> {
            using EXTI11 = Field<12, 4>;    // EXTI 11 configuration bits
            using EXTI10 = Field<8, 4>;    // EXTI 10 configuration bits
            using EXTI9 = Field<4, 4>;    // EXTI 9 configuration bits
            using EXTI8 = Field<0, 4>;    // EXTI 8 configuration bits
        };

        // external interrupt configuration register 4
        struct SYSCFG_EXTICR4 : public Register<0x40010014> {
            using EXTI15 = Field<12, 4>;    // EXTI 15 configuration bits
            using EXTI14 = Field<8, 4>;    // EXTI 14 configuration bits
            using EXTI13 = Field<4, 4>;    // EXTI 13 configuration bits
            using EXTI12 = Field<0, 4>;    // EXTI 12 configuration bits
        };

        // configuration register 2
        struct SYSCFG_CFGR2 : public Register<0x40010018> {
            using LOCUP_LOCK = Field<0, 1>;    // Cortex-M0 LOCKUP bit enable bit
            using SRAM_PARITY_LOCK = Field<1, 1>;    // SRAM parity lock bit
            using PVD_LOCK = Field<2, 1>;    // PVD lock enable bit
            using BYP_ADD_PAR = Field<4, 1>;    // Bypass address bit 29 in parity calculation
            using SRAM_PEF = Field<8, 1>;    // SRAM parity flag
        };

        // CCM SRAM protection register
        struct SYSCFG_RCR : public Register<0x40010004> {
            using PAGE0_WP = Field<0, 1>;    // CCM SRAM page write protection bit
            using PAGE1_WP = Field<1, 1>;    // CCM SRAM page write protection bit
            using PAGE2_WP = Field<2, 1>;    // CCM SRAM page write protection bit
            using PAGE3_WP = Field<3, 1>;    // CCM SRAM page write protection bit
            using PAGE4_WP = Field<4, 1>;    // CCM SRAM page write protection bit
            using PAGE5_WP = Field<5, 1>;    // CCM SRAM page write protection bit
            using PAGE6_WP = Field<6, 1>;    // CCM SRAM page write protection bit
            using PAGE7_WP = Field<7, 1>;    // CCM SRAM page write protection bit
        };

        // configuration register 3
        struct SYSCFG_CFGR3 : public Register<0x40010050> {
            using DAC1_TRIG5_RMP = Field<17, 1>;    // DAC1_CH1 / DAC1_CH2 Trigger remap
            using DAC1_TRIG3_RMP = Field<16, 1>;    // DAC1_CH1 / DAC1_CH2 Trigger remap
            using ADC2_DMA_RMP_1 = Field<9, 1>;    // ADC2 DMA controller remapping bit
            using ADC2_DMA_RMP_0 = Field<6, 2>;    // ADC2 DMA channel remapping bit
            using I2C1_RX_DMA_RMP = Field<4, 2>;    // I2C1_RX DMA remapping bit
            using SPI1_TX_DMA_RMP = Field<2, 2>;    // SPI1_TX DMA remapping bit
            using SPI1_RX_DMA_RMP = Field<0, 2>;    // SPI1_RX DMA remapping bit
        };

        // OPAMP2 control register
        struct OPAMP2_CSR : public Register<0x4001003c> {
            using OPAMP2EN = Field<0, 1>;    // OPAMP2 enable
            using FORCE_VP = Field<1, 1>;    // FORCE_VP
            using VP_SEL = Field<2, 2>;    // OPAMP2 Non inverting input selection
            using VM_SEL = Field<5, 2>;    // OPAMP2 inverting input selection
            using TCM_EN = Field<7, 1>;    // Timer controlled Mux mode enable
            using VMS_SEL = Field<8, 1>;    // OPAMP2 inverting input secondary selection
            using VPS_SEL = Field<9, 2>;    // OPAMP2 Non inverting input secondary selection
            using CALON = Field<11, 1>;    // Calibration mode enable
            using CAL_SEL = Field<12, 2>;    // Calibration selection
            using PGA_GAIN = Field<14, 4>;    // Gain in PGA mode
            using USER_TRIM = Field<18, 1>;    // User trimming enable
            using TRIMOFFSETP = Field<19, 5>;    // Offset trimming value (PMOS)
            using TRIMOFFSETN = Field<24, 5>;    // Offset trimming value (NMOS)
            using TSTREF = Field<29, 1>;    // TSTREF
            using OUTCAL = Field<30, 1>;    // OPAMP 2 ouput status flag
            using LOCK = Field<31, 1>;    // OPAMP 2 lock
        };

        // control and status register
        struct COMP2_CSR : public Register<0x40010020> {
            using COMP2EN = Field<0, 1>;    // Comparator 2 enable
            using COMP2MODE = Field<2, 2>;    // Comparator 2 mode
            using COMP2INSEL = Field<4, 3>;    // Comparator 2 inverting input selection
            using COMP2INPSEL = Field<7, 1>;    // Comparator 2 non inverted input selection
            using COMP2INMSEL = Field<9, 1>;    // Comparator 1inverting input selection
            using COMP2_OUT_SEL = Field<10, 4>;    // Comparator 2 output selection
            using COMP2POL = Field<15, 1>;    // Comparator 2 output polarity
            using COMP2HYST = Field<16, 2>;    // Comparator 2 hysteresis
            using COMP2_BLANKING = Field<18, 3>;    // Comparator 2 blanking source
            using COMP2OUT = Field<30, 1>;    // Comparator 2 output
            using COMP2LOCK = Field<31, 1>;    // Comparator 2 lock
        };

        // control and status register
        struct COMP4_CSR : public Register<0x40010028> {
            using COMP4EN = Field<0, 1>;    // Comparator 4 enable
            using COMP4MODE = Field<2, 2>;    // Comparator 4 mode
            using COMP4INSEL = Field<4, 3>;    // Comparator 4 inverting input selection
            using COMP4INPSEL = Field<7, 1>;    // Comparator 4 non inverted input selection
            using COM4WINMODE = Field<9, 1>;    // Comparator 4 window mode
            using COMP4_OUT_SEL = Field<10, 4>;    // Comparator 4 output selection
            using COMP4POL = Field<15, 1>;    // Comparator 4 output polarity
            using COMP4HYST = Field<16, 2>;    // Comparator 4 hysteresis
            using COMP4_BLANKING = Field<18, 3>;    // Comparator 4 blanking source
            using COMP4OUT = Field<30, 1>;    // Comparator 4 output
            using COMP4LOCK = Field<31, 1>;    // Comparator 4 lock
        };

        // control and status register
        struct COMP6_CSR : public Register<0x40010030> {
            using COMP6EN = Field<0, 1>;    // Comparator 6 enable
            using COMP6MODE = Field<2, 2>;    // Comparator 6 mode
            using COMP6INSEL = Field<4, 3>;    // Comparator 6 inverting input selection
            using COMP6INPSEL = Field<7, 1>;    // Comparator 6 non inverted input selection
            using COM6WINMODE = Field<9, 1>;    // Comparator 6 window mode
            using COMP6_OUT_SEL = Field<10, 4>;    // Comparator 6 output selection
            using COMP6POL = Field<15, 1>;    // Comparator 6 output polarity
            using COMP6HYST = Field<16, 2>;    // Comparator 6 hysteresis
            using COMP6_BLANKING = Field<18, 3>;    // Comparator 6 blanking source
            using COMP6OUT = Field<30, 1>;    // Comparator 6 output
            using COMP6LOCK = Field<31, 1>;    // Comparator 6 lock
        };

    };

    // General purpose timer
    struct TIM3 {
        // control register 1
        struct CR1 : public Register<0x40000400> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000404> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000408> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000040c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000410> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40000414> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40000418> {
            using OC2CE = Field<15, 1>;    // Output compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output compare 2 mode
            using OC2PE = Field<11, 1>;    // Output compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output compare 1 mode
            using OC1PE = Field<3, 1>;    // Output compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000418> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4000041c> {
            using O24CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000041c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000420> {
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4NP = Field<15, 1>;    // Capture/Compare 3 output Polarity
        };

        // counter
        struct CNT : public Register<0x40000424> {
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40000428> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000042c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000434> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40000438> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4000043c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40000440> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40000448> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4000044c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

    };

    // Controller area network
    struct CAN {
        // master control register
        struct MCR : public Register<0x40006400> {
            using DBF = Field<16, 1>;    // DBF
            using RESET = Field<15, 1>;    // RESET
            using TTCM = Field<7, 1>;    // TTCM
            using ABOM = Field<6, 1>;    // ABOM
            using AWUM = Field<5, 1>;    // AWUM
            using NART = Field<4, 1>;    // NART
            using RFLM = Field<3, 1>;    // RFLM
            using TXFP = Field<2, 1>;    // TXFP
            using SLEEP = Field<1, 1>;    // SLEEP
            using INRQ = Field<0, 1>;    // INRQ
        };

        // master status register
        struct MSR : public Register<0x40006404> {
            using RX = Field<11, 1>;    // RX
            using SAMP = Field<10, 1>;    // SAMP
            using RXM = Field<9, 1>;    // RXM
            using TXM = Field<8, 1>;    // TXM
            using SLAKI = Field<4, 1>;    // SLAKI
            using WKUI = Field<3, 1>;    // WKUI
            using ERRI = Field<2, 1>;    // ERRI
            using SLAK = Field<1, 1>;    // SLAK
            using INAK = Field<0, 1>;    // INAK
        };

        // transmit status register
        struct TSR : public Register<0x40006408> {
            using LOW2 = Field<31, 1>;    // Lowest priority flag for mailbox 2
            using LOW1 = Field<30, 1>;    // Lowest priority flag for mailbox 1
            using LOW0 = Field<29, 1>;    // Lowest priority flag for mailbox 0
            using TME2 = Field<28, 1>;    // Lowest priority flag for mailbox 2
            using TME1 = Field<27, 1>;    // Lowest priority flag for mailbox 1
            using TME0 = Field<26, 1>;    // Lowest priority flag for mailbox 0
            using CODE = Field<24, 2>;    // CODE
            using ABRQ2 = Field<23, 1>;    // ABRQ2
            using TERR2 = Field<19, 1>;    // TERR2
            using ALST2 = Field<18, 1>;    // ALST2
            using TXOK2 = Field<17, 1>;    // TXOK2
            using RQCP2 = Field<16, 1>;    // RQCP2
            using ABRQ1 = Field<15, 1>;    // ABRQ1
            using TERR1 = Field<11, 1>;    // TERR1
            using ALST1 = Field<10, 1>;    // ALST1
            using TXOK1 = Field<9, 1>;    // TXOK1
            using RQCP1 = Field<8, 1>;    // RQCP1
            using ABRQ0 = Field<7, 1>;    // ABRQ0
            using TERR0 = Field<3, 1>;    // TERR0
            using ALST0 = Field<2, 1>;    // ALST0
            using TXOK0 = Field<1, 1>;    // TXOK0
            using RQCP0 = Field<0, 1>;    // RQCP0
        };

        // receive FIFO 0 register
        struct RF0R : public Register<0x4000640c> {
            using RFOM0 = Field<5, 1>;    // RFOM0
            using FOVR0 = Field<4, 1>;    // FOVR0
            using FULL0 = Field<3, 1>;    // FULL0
            using FMP0 = Field<0, 2>;    // FMP0
        };

        // receive FIFO 1 register
        struct RF1R : public Register<0x40006410> {
            using RFOM1 = Field<5, 1>;    // RFOM1
            using FOVR1 = Field<4, 1>;    // FOVR1
            using FULL1 = Field<3, 1>;    // FULL1
            using FMP1 = Field<0, 2>;    // FMP1
        };

        // interrupt enable register
        struct IER : public Register<0x40006414> {
            using SLKIE = Field<17, 1>;    // SLKIE
            using WKUIE = Field<16, 1>;    // WKUIE
            using ERRIE = Field<15, 1>;    // ERRIE
            using LECIE = Field<11, 1>;    // LECIE
            using BOFIE = Field<10, 1>;    // BOFIE
            using EPVIE = Field<9, 1>;    // EPVIE
            using EWGIE = Field<8, 1>;    // EWGIE
            using FOVIE1 = Field<6, 1>;    // FOVIE1
            using FFIE1 = Field<5, 1>;    // FFIE1
            using FMPIE1 = Field<4, 1>;    // FMPIE1
            using FOVIE0 = Field<3, 1>;    // FOVIE0
            using FFIE0 = Field<2, 1>;    // FFIE0
            using FMPIE0 = Field<1, 1>;    // FMPIE0
            using TMEIE = Field<0, 1>;    // TMEIE
        };

        // error status register
        struct ESR : public Register<0x40006418> {
            using REC = Field<24, 8>;    // REC
            using TEC = Field<16, 8>;    // TEC
            using LEC = Field<4, 3>;    // LEC
            using BOFF = Field<2, 1>;    // BOFF
            using EPVF = Field<1, 1>;    // EPVF
            using EWGF = Field<0, 1>;    // EWGF
        };

        // bit timing register
        struct BTR : public Register<0x4000641c> {
            using SILM = Field<31, 1>;    // SILM
            using LBKM = Field<30, 1>;    // LBKM
            using SJW = Field<24, 2>;    // SJW
            using TS2 = Field<20, 3>;    // TS2
            using TS1 = Field<16, 4>;    // TS1
            using BRP = Field<0, 10>;    // BRP
        };

        // TX mailbox identifier register
        struct TI0R : public Register<0x40006580> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
            using TXRQ = Field<0, 1>;    // TXRQ
        };

        // mailbox data length control and time stamp register
        struct TDT0R : public Register<0x40006584> {
            using TIME = Field<16, 16>;    // TIME
            using TGT = Field<8, 1>;    // TGT
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data low register
        struct TDL0R : public Register<0x40006588> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct TDH0R : public Register<0x4000658c> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // TX mailbox identifier register
        struct TI1R : public Register<0x40006590> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
            using TXRQ = Field<0, 1>;    // TXRQ
        };

        // mailbox data length control and time stamp register
        struct TDT1R : public Register<0x40006594> {
            using TIME = Field<16, 16>;    // TIME
            using TGT = Field<8, 1>;    // TGT
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data low register
        struct TDL1R : public Register<0x40006598> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct TDH1R : public Register<0x4000659c> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // TX mailbox identifier register
        struct TI2R : public Register<0x400065a0> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
            using TXRQ = Field<0, 1>;    // TXRQ
        };

        // mailbox data length control and time stamp register
        struct TDT2R : public Register<0x400065a4> {
            using TIME = Field<16, 16>;    // TIME
            using TGT = Field<8, 1>;    // TGT
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data low register
        struct TDL2R : public Register<0x400065a8> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct TDH2R : public Register<0x400065ac> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // receive FIFO mailbox identifier register
        struct RI0R : public Register<0x400065b0> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
        };

        // receive FIFO mailbox data length control and time stamp register
        struct RDT0R : public Register<0x400065b4> {
            using TIME = Field<16, 16>;    // TIME
            using FMI = Field<8, 8>;    // FMI
            using DLC = Field<0, 4>;    // DLC
        };

        // receive FIFO mailbox data low register
        struct RDL0R : public Register<0x400065b8> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // receive FIFO mailbox data high register
        struct RDH0R : public Register<0x400065bc> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // receive FIFO mailbox identifier register
        struct RI1R : public Register<0x400065c0> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
        };

        // receive FIFO mailbox data length control and time stamp register
        struct RDT1R : public Register<0x400065c4> {
            using TIME = Field<16, 16>;    // TIME
            using FMI = Field<8, 8>;    // FMI
            using DLC = Field<0, 4>;    // DLC
        };

        // receive FIFO mailbox data low register
        struct RDL1R : public Register<0x400065c8> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // receive FIFO mailbox data high register
        struct RDH1R : public Register<0x400065cc> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // filter master register
        struct FMR : public Register<0x40006600> {
            using CAN2SB = Field<8, 6>;    // CAN2 start bank
            using FINIT = Field<0, 1>;    // Filter init mode
        };

        // filter mode register
        struct FM1R : public Register<0x40006604> {
            using FBM0 = Field<0, 1>;    // Filter mode
            using FBM1 = Field<1, 1>;    // Filter mode
            using FBM2 = Field<2, 1>;    // Filter mode
            using FBM3 = Field<3, 1>;    // Filter mode
            using FBM4 = Field<4, 1>;    // Filter mode
            using FBM5 = Field<5, 1>;    // Filter mode
            using FBM6 = Field<6, 1>;    // Filter mode
            using FBM7 = Field<7, 1>;    // Filter mode
            using FBM8 = Field<8, 1>;    // Filter mode
            using FBM9 = Field<9, 1>;    // Filter mode
            using FBM10 = Field<10, 1>;    // Filter mode
            using FBM11 = Field<11, 1>;    // Filter mode
            using FBM12 = Field<12, 1>;    // Filter mode
            using FBM13 = Field<13, 1>;    // Filter mode
            using FBM14 = Field<14, 1>;    // Filter mode
            using FBM15 = Field<15, 1>;    // Filter mode
            using FBM16 = Field<16, 1>;    // Filter mode
            using FBM17 = Field<17, 1>;    // Filter mode
            using FBM18 = Field<18, 1>;    // Filter mode
            using FBM19 = Field<19, 1>;    // Filter mode
            using FBM20 = Field<20, 1>;    // Filter mode
            using FBM21 = Field<21, 1>;    // Filter mode
            using FBM22 = Field<22, 1>;    // Filter mode
            using FBM23 = Field<23, 1>;    // Filter mode
            using FBM24 = Field<24, 1>;    // Filter mode
            using FBM25 = Field<25, 1>;    // Filter mode
            using FBM26 = Field<26, 1>;    // Filter mode
            using FBM27 = Field<27, 1>;    // Filter mode
        };

        // filter scale register
        struct FS1R : public Register<0x4000660c> {
            using FSC0 = Field<0, 1>;    // Filter scale configuration
            using FSC1 = Field<1, 1>;    // Filter scale configuration
            using FSC2 = Field<2, 1>;    // Filter scale configuration
            using FSC3 = Field<3, 1>;    // Filter scale configuration
            using FSC4 = Field<4, 1>;    // Filter scale configuration
            using FSC5 = Field<5, 1>;    // Filter scale configuration
            using FSC6 = Field<6, 1>;    // Filter scale configuration
            using FSC7 = Field<7, 1>;    // Filter scale configuration
            using FSC8 = Field<8, 1>;    // Filter scale configuration
            using FSC9 = Field<9, 1>;    // Filter scale configuration
            using FSC10 = Field<10, 1>;    // Filter scale configuration
            using FSC11 = Field<11, 1>;    // Filter scale configuration
            using FSC12 = Field<12, 1>;    // Filter scale configuration
            using FSC13 = Field<13, 1>;    // Filter scale configuration
            using FSC14 = Field<14, 1>;    // Filter scale configuration
            using FSC15 = Field<15, 1>;    // Filter scale configuration
            using FSC16 = Field<16, 1>;    // Filter scale configuration
            using FSC17 = Field<17, 1>;    // Filter scale configuration
            using FSC18 = Field<18, 1>;    // Filter scale configuration
            using FSC19 = Field<19, 1>;    // Filter scale configuration
            using FSC20 = Field<20, 1>;    // Filter scale configuration
            using FSC21 = Field<21, 1>;    // Filter scale configuration
            using FSC22 = Field<22, 1>;    // Filter scale configuration
            using FSC23 = Field<23, 1>;    // Filter scale configuration
            using FSC24 = Field<24, 1>;    // Filter scale configuration
            using FSC25 = Field<25, 1>;    // Filter scale configuration
            using FSC26 = Field<26, 1>;    // Filter scale configuration
            using FSC27 = Field<27, 1>;    // Filter scale configuration
        };

        // filter FIFO assignment register
        struct FFA1R : public Register<0x40006614> {
            using FFA0 = Field<0, 1>;    // Filter FIFO assignment for filter 0
            using FFA1 = Field<1, 1>;    // Filter FIFO assignment for filter 1
            using FFA2 = Field<2, 1>;    // Filter FIFO assignment for filter 2
            using FFA3 = Field<3, 1>;    // Filter FIFO assignment for filter 3
            using FFA4 = Field<4, 1>;    // Filter FIFO assignment for filter 4
            using FFA5 = Field<5, 1>;    // Filter FIFO assignment for filter 5
            using FFA6 = Field<6, 1>;    // Filter FIFO assignment for filter 6
            using FFA7 = Field<7, 1>;    // Filter FIFO assignment for filter 7
            using FFA8 = Field<8, 1>;    // Filter FIFO assignment for filter 8
            using FFA9 = Field<9, 1>;    // Filter FIFO assignment for filter 9
            using FFA10 = Field<10, 1>;    // Filter FIFO assignment for filter 10
            using FFA11 = Field<11, 1>;    // Filter FIFO assignment for filter 11
            using FFA12 = Field<12, 1>;    // Filter FIFO assignment for filter 12
            using FFA13 = Field<13, 1>;    // Filter FIFO assignment for filter 13
            using FFA14 = Field<14, 1>;    // Filter FIFO assignment for filter 14
            using FFA15 = Field<15, 1>;    // Filter FIFO assignment for filter 15
            using FFA16 = Field<16, 1>;    // Filter FIFO assignment for filter 16
            using FFA17 = Field<17, 1>;    // Filter FIFO assignment for filter 17
            using FFA18 = Field<18, 1>;    // Filter FIFO assignment for filter 18
            using FFA19 = Field<19, 1>;    // Filter FIFO assignment for filter 19
            using FFA20 = Field<20, 1>;    // Filter FIFO assignment for filter 20
            using FFA21 = Field<21, 1>;    // Filter FIFO assignment for filter 21
            using FFA22 = Field<22, 1>;    // Filter FIFO assignment for filter 22
            using FFA23 = Field<23, 1>;    // Filter FIFO assignment for filter 23
            using FFA24 = Field<24, 1>;    // Filter FIFO assignment for filter 24
            using FFA25 = Field<25, 1>;    // Filter FIFO assignment for filter 25
            using FFA26 = Field<26, 1>;    // Filter FIFO assignment for filter 26
            using FFA27 = Field<27, 1>;    // Filter FIFO assignment for filter 27
        };

        // CAN filter activation register
        struct FA1R : public Register<0x4000661c> {
            using FACT0 = Field<0, 1>;    // Filter active
            using FACT1 = Field<1, 1>;    // Filter active
            using FACT2 = Field<2, 1>;    // Filter active
            using FACT3 = Field<3, 1>;    // Filter active
            using FACT4 = Field<4, 1>;    // Filter active
            using FACT5 = Field<5, 1>;    // Filter active
            using FACT6 = Field<6, 1>;    // Filter active
            using FACT7 = Field<7, 1>;    // Filter active
            using FACT8 = Field<8, 1>;    // Filter active
            using FACT9 = Field<9, 1>;    // Filter active
            using FACT10 = Field<10, 1>;    // Filter active
            using FACT11 = Field<11, 1>;    // Filter active
            using FACT12 = Field<12, 1>;    // Filter active
            using FACT13 = Field<13, 1>;    // Filter active
            using FACT14 = Field<14, 1>;    // Filter active
            using FACT15 = Field<15, 1>;    // Filter active
            using FACT16 = Field<16, 1>;    // Filter active
            using FACT17 = Field<17, 1>;    // Filter active
            using FACT18 = Field<18, 1>;    // Filter active
            using FACT19 = Field<19, 1>;    // Filter active
            using FACT20 = Field<20, 1>;    // Filter active
            using FACT21 = Field<21, 1>;    // Filter active
            using FACT22 = Field<22, 1>;    // Filter active
            using FACT23 = Field<23, 1>;    // Filter active
            using FACT24 = Field<24, 1>;    // Filter active
            using FACT25 = Field<25, 1>;    // Filter active
            using FACT26 = Field<26, 1>;    // Filter active
            using FACT27 = Field<27, 1>;    // Filter active
        };

        // Filter bank 0 register 1
        struct F0R1 : public Register<0x40006640> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 0 register 2
        struct F0R2 : public Register<0x40006644> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 1 register 1
        struct F1R1 : public Register<0x40006648> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 1 register 2
        struct F1R2 : public Register<0x4000664c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 2 register 1
        struct F2R1 : public Register<0x40006650> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 2 register 2
        struct F2R2 : public Register<0x40006654> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 3 register 1
        struct F3R1 : public Register<0x40006658> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 3 register 2
        struct F3R2 : public Register<0x4000665c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 4 register 1
        struct F4R1 : public Register<0x40006660> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 4 register 2
        struct F4R2 : public Register<0x40006664> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 5 register 1
        struct F5R1 : public Register<0x40006668> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 5 register 2
        struct F5R2 : public Register<0x4000666c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 6 register 1
        struct F6R1 : public Register<0x40006670> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 6 register 2
        struct F6R2 : public Register<0x40006674> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 7 register 1
        struct F7R1 : public Register<0x40006678> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 7 register 2
        struct F7R2 : public Register<0x4000667c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 8 register 1
        struct F8R1 : public Register<0x40006680> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 8 register 2
        struct F8R2 : public Register<0x40006684> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 9 register 1
        struct F9R1 : public Register<0x40006688> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 9 register 2
        struct F9R2 : public Register<0x4000668c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 10 register 1
        struct F10R1 : public Register<0x40006690> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 10 register 2
        struct F10R2 : public Register<0x40006694> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 11 register 1
        struct F11R1 : public Register<0x40006698> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 11 register 2
        struct F11R2 : public Register<0x4000669c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 4 register 1
        struct F12R1 : public Register<0x400066a0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 12 register 2
        struct F12R2 : public Register<0x400066a4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 13 register 1
        struct F13R1 : public Register<0x400066a8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 13 register 2
        struct F13R2 : public Register<0x400066ac> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 14 register 1
        struct F14R1 : public Register<0x400066b0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 14 register 2
        struct F14R2 : public Register<0x400066b4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 15 register 1
        struct F15R1 : public Register<0x400066b8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 15 register 2
        struct F15R2 : public Register<0x400066bc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 16 register 1
        struct F16R1 : public Register<0x400066c0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 16 register 2
        struct F16R2 : public Register<0x400066c4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 17 register 1
        struct F17R1 : public Register<0x400066c8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 17 register 2
        struct F17R2 : public Register<0x400066cc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 18 register 1
        struct F18R1 : public Register<0x400066d0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 18 register 2
        struct F18R2 : public Register<0x400066d4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 19 register 1
        struct F19R1 : public Register<0x400066d8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 19 register 2
        struct F19R2 : public Register<0x400066dc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 20 register 1
        struct F20R1 : public Register<0x400066e0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 20 register 2
        struct F20R2 : public Register<0x400066e4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 21 register 1
        struct F21R1 : public Register<0x400066e8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 21 register 2
        struct F21R2 : public Register<0x400066ec> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 22 register 1
        struct F22R1 : public Register<0x400066f0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 22 register 2
        struct F22R2 : public Register<0x400066f4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 23 register 1
        struct F23R1 : public Register<0x400066f8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 23 register 2
        struct F23R2 : public Register<0x400066fc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 24 register 1
        struct F24R1 : public Register<0x40006700> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 24 register 2
        struct F24R2 : public Register<0x40006704> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 25 register 1
        struct F25R1 : public Register<0x40006708> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 25 register 2
        struct F25R2 : public Register<0x4000670c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 26 register 1
        struct F26R1 : public Register<0x40006710> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 26 register 2
        struct F26R2 : public Register<0x40006714> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 27 register 1
        struct F27R1 : public Register<0x40006718> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 27 register 2
        struct F27R2 : public Register<0x4000671c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

    };

    // ADC common registers
    struct ADC_Common {
        // ADC Common status register
        struct ADC1_CSR : public Register<0x50000300> {
            using ADRDY_MST = Field<0, 1>;    // Master ADC ready
            using EOSMP_MST = Field<1, 1>;    // End of Sampling phase flag of the master ADC
            using EOC_MST = Field<2, 1>;    // End of regular conversion of the master ADC
            using EOS_MST = Field<3, 1>;    // End of regular sequence flag of the master ADC
            using OVR_MST = Field<4, 1>;    // Overrun flag of the master ADC
            using JEOC_MST = Field<5, 1>;    // End of injected conversion flag of the master ADC
            using JEOS_MST = Field<6, 1>;    // End of injected sequence flag of the master ADC
            using AWD1_MST = Field<7, 1>;    // Analog watchdog 1 flag of the master ADC
            using AWD2_MST = Field<8, 1>;    // Analog watchdog 2 flag of the master ADC
            using AWD3_MST = Field<9, 1>;    // Analog watchdog 3 flag of the master ADC
            using JQOVF_MST = Field<10, 1>;    // Injected Context Queue Overflow flag of the master ADC
            using ADRDY_SLV = Field<16, 1>;    // Slave ADC ready
            using EOSMP_SLV = Field<17, 1>;    // End of Sampling phase flag of the slave ADC
            using EOC_SLV = Field<18, 1>;    // End of regular conversion of the slave ADC
            using EOS_SLV = Field<19, 1>;    // End of regular sequence flag of the slave ADC
            using OVR_SLV = Field<20, 1>;    // Overrun flag of the slave ADC
            using JEOC_SLV = Field<21, 1>;    // End of injected conversion flag of the slave ADC
            using JEOS_SLV = Field<22, 1>;    // End of injected sequence flag of the slave ADC
            using AWD1_SLV = Field<23, 1>;    // Analog watchdog 1 flag of the slave ADC
            using AWD2_SLV = Field<24, 1>;    // Analog watchdog 2 flag of the slave ADC
            using AWD3_SLV = Field<25, 1>;    // Analog watchdog 3 flag of the slave ADC
            using JQOVF_SLV = Field<26, 1>;    // Injected Context Queue Overflow flag of the slave ADC
        };

        // ADC common control register
        struct ADC1_CCR : public Register<0x50000308> {
            using DUAL = Field<0, 5>;    // Dual ADC mode selection
            using DELAY = Field<8, 4>;    // Delay between 2 sampling phases
            using DMACFG = Field<13, 1>;    // DMA configuration (for dual ADC mode)
            using MDMA = Field<14, 2>;    // Direct memory access mode for dual ADC mode
            using CKMODE = Field<16, 2>;    // ADC clock mode
            using VREFEN = Field<22, 1>;    // VREFINT enable
            using TSEN = Field<23, 1>;    // Temperature sensor enable
            using VBATEN = Field<24, 1>;    // VBAT enable
        };

        // ADC common regular data register for dual mode
        struct ADC1_CDR : public Register<0x5000030c> {
            using RDATA_SLV = Field<16, 16>;    // Regular data of the slave ADC
            using RDATA_MST = Field<0, 16>;    // Regular data of the master ADC
        };

    };

    // High Resolution Timer: Master Timers
    struct HRTIM_Master {
        // Master Timer Control Register
        struct MCR : public Register<0x40017400> {
            using BRSTDMA = Field<30, 2>;    // Burst DMA Update
            using MREPU = Field<29, 1>;    // Master Timer Repetition update
            using PREEN = Field<27, 1>;    // Preload enable
            using DACSYNC = Field<25, 2>;    // AC Synchronization
            using TECEN = Field<21, 1>;    // Timer E counter enable
            using TDCEN = Field<20, 1>;    // Timer D counter enable
            using TCCEN = Field<19, 1>;    // Timer C counter enable
            using TBCEN = Field<18, 1>;    // Timer B counter enable
            using TACEN = Field<17, 1>;    // Timer A counter enable
            using MCEN = Field<16, 1>;    // Master Counter enable
            using SYNC_SRC = Field<14, 2>;    // Synchronization source
            using SYNC_OUT = Field<12, 2>;    // Synchronization output
            using SYNCSTRTM = Field<11, 1>;    // Synchronization Starts Master
            using SYNCRSTM = Field<10, 1>;    // Synchronization Resets Master
            using SYNC_IN = Field<8, 2>;    // ynchronization input
            using HALF = Field<5, 1>;    // Half mode enable
            using RETRIG = Field<4, 1>;    // Master Re-triggerable mode
            using CONT = Field<3, 1>;    // Master Continuous mode
            using CK_PSC = Field<0, 3>;    // HRTIM Master Clock prescaler
        };

        // Master Timer Interrupt Status Register
        struct MISR : public Register<0x40017404> {
            using MUPD = Field<6, 1>;    // Master Update Interrupt Flag
            using SYNC = Field<5, 1>;    // Sync Input Interrupt Flag
            using MREP = Field<4, 1>;    // Master Repetition Interrupt Flag
            using MCMP4 = Field<3, 1>;    // Master Compare 4 Interrupt Flag
            using MCMP3 = Field<2, 1>;    // Master Compare 3 Interrupt Flag
            using MCMP2 = Field<1, 1>;    // Master Compare 2 Interrupt Flag
            using MCMP1 = Field<0, 1>;    // Master Compare 1 Interrupt Flag
        };

        // Master Timer Interrupt Clear Register
        struct MICR : public Register<0x40017408> {
            using MUPDC = Field<6, 1>;    // Master update Interrupt flag clear
            using SYNCC = Field<5, 1>;    // Sync Input Interrupt flag clear
            using MREPC = Field<4, 1>;    // Repetition Interrupt flag clear
            using MCMP4C = Field<3, 1>;    // Master Compare 4 Interrupt flag clear
            using MCMP3C = Field<2, 1>;    // Master Compare 3 Interrupt flag clear
            using MCMP2C = Field<1, 1>;    // Master Compare 2 Interrupt flag clear
            using MCMP1C = Field<0, 1>;    // Master Compare 1 Interrupt flag clear
        };

        // MDIER4
        struct MDIER4 : public Register<0x4001740c> {
            using MUPDDE = Field<22, 1>;    // MUPDDE
            using SYNCDE = Field<21, 1>;    // SYNCDE
            using MREPDE = Field<20, 1>;    // MREPDE
            using MCMP4DE = Field<19, 1>;    // MCMP4DE
            using MCMP3DE = Field<18, 1>;    // MCMP3DE
            using MCMP2DE = Field<17, 1>;    // MCMP2DE
            using MCMP1DE = Field<16, 1>;    // MCMP1DE
            using MUPDIE = Field<6, 1>;    // MUPDIE
            using SYNCIE = Field<5, 1>;    // SYNCIE
            using MREPIE = Field<4, 1>;    // MREPIE
            using MCMP4IE = Field<3, 1>;    // MCMP4IE
            using MCMP3IE = Field<2, 1>;    // MCMP3IE
            using MCMP2IE = Field<1, 1>;    // MCMP2IE
            using MCMP1IE = Field<0, 1>;    // MCMP1IE
        };

        // Master Timer Counter Register
        struct MCNTR : public Register<0x40017410> {
            using MCNT = Field<0, 16>;    // Counter value
        };

        // Master Timer Period Register
        struct MPER : public Register<0x40017414> {
            using Field = Field<0, 16>;    // Master Timer Period value
        };

        // Master Timer Repetition Register
        struct MREP : public Register<0x40017418> {
            using Field = Field<0, 8>;    // Master Timer Repetition counter value
        };

        // Master Timer Compare 1 Register
        struct MCMP1R : public Register<0x4001741c> {
            using MCMP1 = Field<0, 16>;    // Master Timer Compare 1 value
        };

        // Master Timer Compare 2 Register
        struct MCMP2R : public Register<0x40017424> {
            using MCMP2 = Field<0, 16>;    // Master Timer Compare 2 value
        };

        // Master Timer Compare 3 Register
        struct MCMP3R : public Register<0x40017428> {
            using MCMP3 = Field<0, 16>;    // Master Timer Compare 3 value
        };

        // Master Timer Compare 4 Register
        struct MCMP4R : public Register<0x4001742c> {
            using MCMP4 = Field<0, 16>;    // Master Timer Compare 4 value
        };

    };

    // High Resolution Timer: TIMA
    struct HRTIM_TIMA {
        // Timerx Control Register
        struct TIMACR : public Register<0x40017480> {
            using UPDGAT = Field<28, 4>;    // Update Gating
            using PREEN = Field<27, 1>;    // Preload enable
            using DACSYNC = Field<25, 2>;    // AC Synchronization
            using MSTU = Field<24, 1>;    // Master Timer update
            using TEU = Field<23, 1>;    // TEU
            using TDU = Field<22, 1>;    // TDU
            using TCU = Field<21, 1>;    // TCU
            using TBU = Field<20, 1>;    // TBU
            using TxRSTU = Field<18, 1>;    // Timerx reset update
            using TxREPU = Field<17, 1>;    // Timer x Repetition update
            using DELCMP4 = Field<14, 2>;    // Delayed CMP4 mode
            using DELCMP2 = Field<12, 2>;    // Delayed CMP2 mode
            using SYNCSTRTx = Field<11, 1>;    // Synchronization Starts Timer x
            using SYNCRSTx = Field<10, 1>;    // Synchronization Resets Timer x
            using PSHPLL = Field<6, 1>;    // Push-Pull mode enable
            using HALF = Field<5, 1>;    // Half mode enable
            using RETRIG = Field<4, 1>;    // Re-triggerable mode
            using CONT = Field<3, 1>;    // Continuous mode
            using CK_PSCx = Field<0, 3>;    // HRTIM Timer x Clock prescaler
        };

        // Timerx Interrupt Status Register
        struct TIMAISR : public Register<0x40017484> {
            using O2CPY = Field<21, 1>;    // Output 2 Copy
            using O1CPY = Field<20, 1>;    // Output 1 Copy
            using O2STAT = Field<19, 1>;    // Output 2 State
            using O1STAT = Field<18, 1>;    // Output 1 State
            using IPPSTAT = Field<17, 1>;    // Idle Push Pull Status
            using CPPSTAT = Field<16, 1>;    // Current Push Pull Status
            using DLYPRT = Field<14, 1>;    // Delayed Protection Flag
            using RST = Field<13, 1>;    // Reset Interrupt Flag
            using RSTx2 = Field<12, 1>;    // Output 2 Reset Interrupt Flag
            using SETx2 = Field<11, 1>;    // Output 2 Set Interrupt Flag
            using RSTx1 = Field<10, 1>;    // Output 1 Reset Interrupt Flag
            using SETx1 = Field<9, 1>;    // Output 1 Set Interrupt Flag
            using CPT2 = Field<8, 1>;    // Capture2 Interrupt Flag
            using CPT1 = Field<7, 1>;    // Capture1 Interrupt Flag
            using UPD = Field<6, 1>;    // Update Interrupt Flag
            using REP = Field<4, 1>;    // Repetition Interrupt Flag
            using CMP4 = Field<3, 1>;    // Compare 4 Interrupt Flag
            using CMP3 = Field<2, 1>;    // Compare 3 Interrupt Flag
            using CMP2 = Field<1, 1>;    // Compare 2 Interrupt Flag
            using CMP1 = Field<0, 1>;    // Compare 1 Interrupt Flag
        };

        // Timerx Interrupt Clear Register
        struct TIMAICR : public Register<0x40017488> {
            using DLYPRTC = Field<14, 1>;    // Delayed Protection Flag Clear
            using RSTC = Field<13, 1>;    // Reset Interrupt flag Clear
            using RSTx2C = Field<12, 1>;    // Output 2 Reset flag Clear
            using SET2xC = Field<11, 1>;    // Output 2 Set flag Clear
            using RSTx1C = Field<10, 1>;    // Output 1 Reset flag Clear
            using SET1xC = Field<9, 1>;    // Output 1 Set flag Clear
            using CPT2C = Field<8, 1>;    // Capture2 Interrupt flag Clear
            using CPT1C = Field<7, 1>;    // Capture1 Interrupt flag Clear
            using UPDC = Field<6, 1>;    // Update Interrupt flag Clear
            using REPC = Field<4, 1>;    // Repetition Interrupt flag Clear
            using CMP4C = Field<3, 1>;    // Compare 4 Interrupt flag Clear
            using CMP3C = Field<2, 1>;    // Compare 3 Interrupt flag Clear
            using CMP2C = Field<1, 1>;    // Compare 2 Interrupt flag Clear
            using CMP1C = Field<0, 1>;    // Compare 1 Interrupt flag Clear
        };

        // TIMxDIER5
        struct TIMADIER5 : public Register<0x4001748c> {
            using DLYPRTDE = Field<30, 1>;    // DLYPRTDE
            using RSTDE = Field<29, 1>;    // RSTDE
            using RSTx2DE = Field<28, 1>;    // RSTx2DE
            using SETx2DE = Field<27, 1>;    // SETx2DE
            using RSTx1DE = Field<26, 1>;    // RSTx1DE
            using SET1xDE = Field<25, 1>;    // SET1xDE
            using CPT2DE = Field<24, 1>;    // CPT2DE
            using CPT1DE = Field<23, 1>;    // CPT1DE
            using UPDDE = Field<22, 1>;    // UPDDE
            using REPDE = Field<20, 1>;    // REPDE
            using CMP4DE = Field<19, 1>;    // CMP4DE
            using CMP3DE = Field<18, 1>;    // CMP3DE
            using CMP2DE = Field<17, 1>;    // CMP2DE
            using CMP1DE = Field<16, 1>;    // CMP1DE
            using DLYPRTIE = Field<14, 1>;    // DLYPRTIE
            using RSTIE = Field<13, 1>;    // RSTIE
            using RSTx2IE = Field<12, 1>;    // RSTx2IE
            using SETx2IE = Field<11, 1>;    // SETx2IE
            using RSTx1IE = Field<10, 1>;    // RSTx1IE
            using SET1xIE = Field<9, 1>;    // SET1xIE
            using CPT2IE = Field<8, 1>;    // CPT2IE
            using CPT1IE = Field<7, 1>;    // CPT1IE
            using UPDIE = Field<6, 1>;    // UPDIE
            using REPIE = Field<4, 1>;    // REPIE
            using CMP4IE = Field<3, 1>;    // CMP4IE
            using CMP3IE = Field<2, 1>;    // CMP3IE
            using CMP2IE = Field<1, 1>;    // CMP2IE
            using CMP1IE = Field<0, 1>;    // CMP1IE
        };

        // Timerx Counter Register
        struct CNTAR : public Register<0x40017490> {
            using CNTx = Field<0, 16>;    // Timerx Counter value
        };

        // Timerx Period Register
        struct PERAR : public Register<0x40017494> {
            using PERx = Field<0, 16>;    // Timerx Period value
        };

        // Timerx Repetition Register
        struct REPAR : public Register<0x40017498> {
            using REPx = Field<0, 8>;    // Timerx Repetition counter value
        };

        // Timerx Compare 1 Register
        struct CMP1AR : public Register<0x4001749c> {
            using CMP1x = Field<0, 16>;    // Timerx Compare 1 value
        };

        // Timerx Compare 1 Compound Register
        struct CMP1CAR : public Register<0x400174a0> {
            using REPx = Field<16, 8>;    // Timerx Repetition value (aliased from HRTIM_REPx register)
            using CMP1x = Field<0, 16>;    // Timerx Compare 1 value
        };

        // Timerx Compare 2 Register
        struct CMP2AR : public Register<0x400174a4> {
            using CMP2x = Field<0, 16>;    // Timerx Compare 2 value
        };

        // Timerx Compare 3 Register
        struct CMP3AR : public Register<0x400174a8> {
            using CMP3x = Field<0, 16>;    // Timerx Compare 3 value
        };

        // Timerx Compare 4 Register
        struct CMP4AR : public Register<0x400174ac> {
            using CMP4x = Field<0, 16>;    // Timerx Compare 4 value
        };

        // Timerx Capture 1 Register
        struct CPT1AR : public Register<0x400174b0> {
            using CPT1x = Field<0, 16>;    // Timerx Capture 1 value
        };

        // Timerx Capture 2 Register
        struct CPT2AR : public Register<0x400174b4> {
            using CPT2x = Field<0, 16>;    // Timerx Capture 2 value
        };

        // Timerx Deadtime Register
        struct DTAR : public Register<0x400174b8> {
            using DTFLKx = Field<31, 1>;    // Deadtime Falling Lock
            using DTFSLKx = Field<30, 1>;    // Deadtime Falling Sign Lock
            using SDTFx = Field<25, 1>;    // Sign Deadtime Falling value
            using DTFx = Field<16, 9>;    // Deadtime Falling value
            using DTRLKx = Field<15, 1>;    // Deadtime Rising Lock
            using DTRSLKx = Field<14, 1>;    // Deadtime Rising Sign Lock
            using DTPRSC = Field<10, 3>;    // Deadtime Prescaler
            using SDTRx = Field<9, 1>;    // Sign Deadtime Rising value
            using DTRx = Field<0, 9>;    // Deadtime Rising value
        };

        // Timerx Output1 Set Register
        struct SETA1R : public Register<0x400174bc> {
            using UPDATE = Field<31, 1>;    // Registers update (transfer preload to active)
            using EXTEVNT10 = Field<30, 1>;    // External Event 10
            using EXTEVNT9 = Field<29, 1>;    // External Event 9
            using EXTEVNT8 = Field<28, 1>;    // External Event 8
            using EXTEVNT7 = Field<27, 1>;    // External Event 7
            using EXTEVNT6 = Field<26, 1>;    // External Event 6
            using EXTEVNT5 = Field<25, 1>;    // External Event 5
            using EXTEVNT4 = Field<24, 1>;    // External Event 4
            using EXTEVNT3 = Field<23, 1>;    // External Event 3
            using EXTEVNT2 = Field<22, 1>;    // External Event 2
            using EXTEVNT1 = Field<21, 1>;    // External Event 1
            using TIMEVNT9 = Field<20, 1>;    // Timer Event 9
            using TIMEVNT8 = Field<19, 1>;    // Timer Event 8
            using TIMEVNT7 = Field<18, 1>;    // Timer Event 7
            using TIMEVNT6 = Field<17, 1>;    // Timer Event 6
            using TIMEVNT5 = Field<16, 1>;    // Timer Event 5
            using TIMEVNT4 = Field<15, 1>;    // Timer Event 4
            using TIMEVNT3 = Field<14, 1>;    // Timer Event 3
            using TIMEVNT2 = Field<13, 1>;    // Timer Event 2
            using TIMEVNT1 = Field<12, 1>;    // Timer Event 1
            using MSTCMP4 = Field<11, 1>;    // Master Compare 4
            using MSTCMP3 = Field<10, 1>;    // Master Compare 3
            using MSTCMP2 = Field<9, 1>;    // Master Compare 2
            using MSTCMP1 = Field<8, 1>;    // Master Compare 1
            using MSTPER = Field<7, 1>;    // Master Period
            using CMP4 = Field<6, 1>;    // Timer A compare 4
            using CMP3 = Field<5, 1>;    // Timer A compare 3
            using CMP2 = Field<4, 1>;    // Timer A compare 2
            using CMP1 = Field<3, 1>;    // Timer A compare 1
            using PER = Field<2, 1>;    // Timer A Period
            using RESYNC = Field<1, 1>;    // Timer A resynchronizaton
            using SST = Field<0, 1>;    // Software Set trigger
        };

        // Timerx Output1 Reset Register
        struct RSTA1R : public Register<0x400174c0> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SRT = Field<0, 1>;    // SRT
        };

        // Timerx Output2 Set Register
        struct SETA2R : public Register<0x400174c4> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SST = Field<0, 1>;    // SST
        };

        // Timerx Output2 Reset Register
        struct RSTA2R : public Register<0x400174c8> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SRT = Field<0, 1>;    // SRT
        };

        // Timerx External Event Filtering Register 1
        struct EEFAR1 : public Register<0x400174cc> {
            using EE5FLTR = Field<25, 4>;    // External Event 5 filter
            using EE5LTCH = Field<24, 1>;    // External Event 5 latch
            using EE4FLTR = Field<19, 4>;    // External Event 4 filter
            using EE4LTCH = Field<18, 1>;    // External Event 4 latch
            using EE3FLTR = Field<13, 4>;    // External Event 3 filter
            using EE3LTCH = Field<12, 1>;    // External Event 3 latch
            using EE2FLTR = Field<7, 4>;    // External Event 2 filter
            using EE2LTCH = Field<6, 1>;    // External Event 2 latch
            using EE1FLTR = Field<1, 4>;    // External Event 1 filter
            using EE1LTCH = Field<0, 1>;    // External Event 1 latch
        };

        // Timerx External Event Filtering Register 2
        struct EEFAR2 : public Register<0x400174d0> {
            using EE10FLTR = Field<25, 4>;    // External Event 10 filter
            using EE10LTCH = Field<24, 1>;    // External Event 10 latch
            using EE9FLTR = Field<19, 4>;    // External Event 9 filter
            using EE9LTCH = Field<18, 1>;    // External Event 9 latch
            using EE8FLTR = Field<13, 4>;    // External Event 8 filter
            using EE8LTCH = Field<12, 1>;    // External Event 8 latch
            using EE7FLTR = Field<7, 4>;    // External Event 7 filter
            using EE7LTCH = Field<6, 1>;    // External Event 7 latch
            using EE6FLTR = Field<1, 4>;    // External Event 6 filter
            using EE6LTCH = Field<0, 1>;    // External Event 6 latch
        };

        // TimerA Reset Register
        struct RSTAR : public Register<0x400174d4> {
            using TIMECMP4 = Field<30, 1>;    // Timer E Compare 4
            using TIMECMP2 = Field<29, 1>;    // Timer E Compare 2
            using TIMECMP1 = Field<28, 1>;    // Timer E Compare 1
            using TIMDCMP4 = Field<27, 1>;    // Timer D Compare 4
            using TIMDCMP2 = Field<26, 1>;    // Timer D Compare 2
            using TIMDCMP1 = Field<25, 1>;    // Timer D Compare 1
            using TIMCCMP4 = Field<24, 1>;    // Timer C Compare 4
            using TIMCCMP2 = Field<23, 1>;    // Timer C Compare 2
            using TIMCCMP1 = Field<22, 1>;    // Timer C Compare 1
            using TIMBCMP4 = Field<21, 1>;    // Timer B Compare 4
            using TIMBCMP2 = Field<20, 1>;    // Timer B Compare 2
            using TIMBCMP1 = Field<19, 1>;    // Timer B Compare 1
            using EXTEVNT10 = Field<18, 1>;    // External Event 10
            using EXTEVNT9 = Field<17, 1>;    // External Event 9
            using EXTEVNT8 = Field<16, 1>;    // External Event 8
            using EXTEVNT7 = Field<15, 1>;    // External Event 7
            using EXTEVNT6 = Field<14, 1>;    // External Event 6
            using EXTEVNT5 = Field<13, 1>;    // External Event 5
            using EXTEVNT4 = Field<12, 1>;    // External Event 4
            using EXTEVNT3 = Field<11, 1>;    // External Event 3
            using EXTEVNT2 = Field<10, 1>;    // External Event 2
            using EXTEVNT1 = Field<9, 1>;    // External Event 1
            using MSTCMP4 = Field<8, 1>;    // Master compare 4
            using MSTCMP3 = Field<7, 1>;    // Master compare 3
            using MSTCMP2 = Field<6, 1>;    // Master compare 2
            using MSTCMP1 = Field<5, 1>;    // Master compare 1
            using MSTPER = Field<4, 1>;    // Master timer Period
            using CMP4 = Field<3, 1>;    // Timer A compare 4 reset
            using CMP2 = Field<2, 1>;    // Timer A compare 2 reset
            using UPDT = Field<1, 1>;    // Timer A Update reset
        };

        // Timerx Chopper Register
        struct CHPAR : public Register<0x400174d8> {
            using STRTPW = Field<7, 4>;    // STRTPW
            using CHPDTY = Field<4, 3>;    // Timerx chopper duty cycle value
            using CHPFRQ = Field<0, 4>;    // Timerx carrier frequency value
        };

        // Timerx Capture 2 Control Register
        struct CPT1ACR : public Register<0x400174dc> {
            using TECMP2 = Field<31, 1>;    // Timer E Compare 2
            using TECMP1 = Field<30, 1>;    // Timer E Compare 1
            using TE1RST = Field<29, 1>;    // Timer E output 1 Reset
            using TE1SET = Field<28, 1>;    // Timer E output 1 Set
            using TDCMP2 = Field<27, 1>;    // Timer D Compare 2
            using TDCMP1 = Field<26, 1>;    // Timer D Compare 1
            using TD1RST = Field<25, 1>;    // Timer D output 1 Reset
            using TD1SET = Field<24, 1>;    // Timer D output 1 Set
            using TCCMP2 = Field<23, 1>;    // Timer C Compare 2
            using TCCMP1 = Field<22, 1>;    // Timer C Compare 1
            using TC1RST = Field<21, 1>;    // Timer C output 1 Reset
            using TC1SET = Field<20, 1>;    // Timer C output 1 Set
            using TBCMP2 = Field<19, 1>;    // Timer B Compare 2
            using TBCMP1 = Field<18, 1>;    // Timer B Compare 1
            using TB1RST = Field<17, 1>;    // Timer B output 1 Reset
            using TB1SET = Field<16, 1>;    // Timer B output 1 Set
            using EXEV10CPT = Field<11, 1>;    // External Event 10 Capture
            using EXEV9CPT = Field<10, 1>;    // External Event 9 Capture
            using EXEV8CPT = Field<9, 1>;    // External Event 8 Capture
            using EXEV7CPT = Field<8, 1>;    // External Event 7 Capture
            using EXEV6CPT = Field<7, 1>;    // External Event 6 Capture
            using EXEV5CPT = Field<6, 1>;    // External Event 5 Capture
            using EXEV4CPT = Field<5, 1>;    // External Event 4 Capture
            using EXEV3CPT = Field<4, 1>;    // External Event 3 Capture
            using EXEV2CPT = Field<3, 1>;    // External Event 2 Capture
            using EXEV1CPT = Field<2, 1>;    // External Event 1 Capture
            using UDPCPT = Field<1, 1>;    // Update Capture
            using SWCPT = Field<0, 1>;    // Software Capture
        };

        // CPT2xCR
        struct CPT2ACR : public Register<0x400174e0> {
            using TECMP2 = Field<31, 1>;    // Timer E Compare 2
            using TECMP1 = Field<30, 1>;    // Timer E Compare 1
            using TE1RST = Field<29, 1>;    // Timer E output 1 Reset
            using TE1SET = Field<28, 1>;    // Timer E output 1 Set
            using TDCMP2 = Field<27, 1>;    // Timer D Compare 2
            using TDCMP1 = Field<26, 1>;    // Timer D Compare 1
            using TD1RST = Field<25, 1>;    // Timer D output 1 Reset
            using TD1SET = Field<24, 1>;    // Timer D output 1 Set
            using TCCMP2 = Field<23, 1>;    // Timer C Compare 2
            using TCCMP1 = Field<22, 1>;    // Timer C Compare 1
            using TC1RST = Field<21, 1>;    // Timer C output 1 Reset
            using TC1SET = Field<20, 1>;    // Timer C output 1 Set
            using TBCMP2 = Field<19, 1>;    // Timer B Compare 2
            using TBCMP1 = Field<18, 1>;    // Timer B Compare 1
            using TB1RST = Field<17, 1>;    // Timer B output 1 Reset
            using TB1SET = Field<16, 1>;    // Timer B output 1 Set
            using EXEV10CPT = Field<11, 1>;    // External Event 10 Capture
            using EXEV9CPT = Field<10, 1>;    // External Event 9 Capture
            using EXEV8CPT = Field<9, 1>;    // External Event 8 Capture
            using EXEV7CPT = Field<8, 1>;    // External Event 7 Capture
            using EXEV6CPT = Field<7, 1>;    // External Event 6 Capture
            using EXEV5CPT = Field<6, 1>;    // External Event 5 Capture
            using EXEV4CPT = Field<5, 1>;    // External Event 4 Capture
            using EXEV3CPT = Field<4, 1>;    // External Event 3 Capture
            using EXEV2CPT = Field<3, 1>;    // External Event 2 Capture
            using EXEV1CPT = Field<2, 1>;    // External Event 1 Capture
            using UDPCPT = Field<1, 1>;    // Update Capture
            using SWCPT = Field<0, 1>;    // Software Capture
        };

        // Timerx Output Register
        struct OUTAR : public Register<0x400174e4> {
            using DIDL2 = Field<23, 1>;    // Output 2 Deadtime upon burst mode Idle entry
            using CHP2 = Field<22, 1>;    // Output 2 Chopper enable
            using FAULT2 = Field<20, 2>;    // Output 2 Fault state
            using IDLES2 = Field<19, 1>;    // Output 2 Idle State
            using IDLEM2 = Field<18, 1>;    // Output 2 Idle mode
            using POL2 = Field<17, 1>;    // Output 2 polarity
            using DLYPRT = Field<10, 3>;    // Delayed Protection
            using DLYPRTEN = Field<9, 1>;    // Delayed Protection Enable
            using DTEN = Field<8, 1>;    // Deadtime enable
            using DIDL1 = Field<7, 1>;    // Output 1 Deadtime upon burst mode Idle entry
            using CHP1 = Field<6, 1>;    // Output 1 Chopper enable
            using FAULT1 = Field<4, 2>;    // Output 1 Fault state
            using IDLES1 = Field<3, 1>;    // Output 1 Idle State
            using IDLEM1 = Field<2, 1>;    // Output 1 Idle mode
            using POL1 = Field<1, 1>;    // Output 1 polarity
        };

        // Timerx Fault Register
        struct FLTAR : public Register<0x400174e8> {
            using FLTLCK = Field<31, 1>;    // Fault sources Lock
            using FLT5EN = Field<4, 1>;    // Fault 5 enable
            using FLT4EN = Field<3, 1>;    // Fault 4 enable
            using FLT3EN = Field<2, 1>;    // Fault 3 enable
            using FLT2EN = Field<1, 1>;    // Fault 2 enable
            using FLT1EN = Field<0, 1>;    // Fault 1 enable
        };

    };

    // High Resolution Timer: TIMB
    struct HRTIM_TIMB {
        // Timerx Control Register
        struct TIMBCR : public Register<0x40017500> {
            using UPDGAT = Field<28, 4>;    // Update Gating
            using PREEN = Field<27, 1>;    // Preload enable
            using DACSYNC = Field<25, 2>;    // AC Synchronization
            using MSTU = Field<24, 1>;    // Master Timer update
            using TEU = Field<23, 1>;    // TEU
            using TDU = Field<22, 1>;    // TDU
            using TCU = Field<21, 1>;    // TCU
            using TBU = Field<20, 1>;    // TBU
            using TxRSTU = Field<18, 1>;    // Timerx reset update
            using TxREPU = Field<17, 1>;    // Timer x Repetition update
            using DELCMP4 = Field<14, 2>;    // Delayed CMP4 mode
            using DELCMP2 = Field<12, 2>;    // Delayed CMP2 mode
            using SYNCSTRTx = Field<11, 1>;    // Synchronization Starts Timer x
            using SYNCRSTx = Field<10, 1>;    // Synchronization Resets Timer x
            using PSHPLL = Field<6, 1>;    // Push-Pull mode enable
            using HALF = Field<5, 1>;    // Half mode enable
            using RETRIG = Field<4, 1>;    // Re-triggerable mode
            using CONT = Field<3, 1>;    // Continuous mode
            using CK_PSCx = Field<0, 3>;    // HRTIM Timer x Clock prescaler
        };

        // Timerx Interrupt Status Register
        struct TIMBISR : public Register<0x40017504> {
            using O2CPY = Field<21, 1>;    // Output 2 Copy
            using O1CPY = Field<20, 1>;    // Output 1 Copy
            using O2STAT = Field<19, 1>;    // Output 2 State
            using O1STAT = Field<18, 1>;    // Output 1 State
            using IPPSTAT = Field<17, 1>;    // Idle Push Pull Status
            using CPPSTAT = Field<16, 1>;    // Current Push Pull Status
            using DLYPRT = Field<14, 1>;    // Delayed Protection Flag
            using RST = Field<13, 1>;    // Reset Interrupt Flag
            using RSTx2 = Field<12, 1>;    // Output 2 Reset Interrupt Flag
            using SETx2 = Field<11, 1>;    // Output 2 Set Interrupt Flag
            using RSTx1 = Field<10, 1>;    // Output 1 Reset Interrupt Flag
            using SETx1 = Field<9, 1>;    // Output 1 Set Interrupt Flag
            using CPT2 = Field<8, 1>;    // Capture2 Interrupt Flag
            using CPT1 = Field<7, 1>;    // Capture1 Interrupt Flag
            using UPD = Field<6, 1>;    // Update Interrupt Flag
            using REP = Field<4, 1>;    // Repetition Interrupt Flag
            using CMP4 = Field<3, 1>;    // Compare 4 Interrupt Flag
            using CMP3 = Field<2, 1>;    // Compare 3 Interrupt Flag
            using CMP2 = Field<1, 1>;    // Compare 2 Interrupt Flag
            using CMP1 = Field<0, 1>;    // Compare 1 Interrupt Flag
        };

        // Timerx Interrupt Clear Register
        struct TIMBICR : public Register<0x40017508> {
            using DLYPRTC = Field<14, 1>;    // Delayed Protection Flag Clear
            using RSTC = Field<13, 1>;    // Reset Interrupt flag Clear
            using RSTx2C = Field<12, 1>;    // Output 2 Reset flag Clear
            using SET2xC = Field<11, 1>;    // Output 2 Set flag Clear
            using RSTx1C = Field<10, 1>;    // Output 1 Reset flag Clear
            using SET1xC = Field<9, 1>;    // Output 1 Set flag Clear
            using CPT2C = Field<8, 1>;    // Capture2 Interrupt flag Clear
            using CPT1C = Field<7, 1>;    // Capture1 Interrupt flag Clear
            using UPDC = Field<6, 1>;    // Update Interrupt flag Clear
            using REPC = Field<4, 1>;    // Repetition Interrupt flag Clear
            using CMP4C = Field<3, 1>;    // Compare 4 Interrupt flag Clear
            using CMP3C = Field<2, 1>;    // Compare 3 Interrupt flag Clear
            using CMP2C = Field<1, 1>;    // Compare 2 Interrupt flag Clear
            using CMP1C = Field<0, 1>;    // Compare 1 Interrupt flag Clear
        };

        // TIMxDIER5
        struct TIMBDIER5 : public Register<0x4001750c> {
            using DLYPRTDE = Field<30, 1>;    // DLYPRTDE
            using RSTDE = Field<29, 1>;    // RSTDE
            using RSTx2DE = Field<28, 1>;    // RSTx2DE
            using SETx2DE = Field<27, 1>;    // SETx2DE
            using RSTx1DE = Field<26, 1>;    // RSTx1DE
            using SET1xDE = Field<25, 1>;    // SET1xDE
            using CPT2DE = Field<24, 1>;    // CPT2DE
            using CPT1DE = Field<23, 1>;    // CPT1DE
            using UPDDE = Field<22, 1>;    // UPDDE
            using REPDE = Field<20, 1>;    // REPDE
            using CMP4DE = Field<19, 1>;    // CMP4DE
            using CMP3DE = Field<18, 1>;    // CMP3DE
            using CMP2DE = Field<17, 1>;    // CMP2DE
            using CMP1DE = Field<16, 1>;    // CMP1DE
            using DLYPRTIE = Field<14, 1>;    // DLYPRTIE
            using RSTIE = Field<13, 1>;    // RSTIE
            using RSTx2IE = Field<12, 1>;    // RSTx2IE
            using SETx2IE = Field<11, 1>;    // SETx2IE
            using RSTx1IE = Field<10, 1>;    // RSTx1IE
            using SET1xIE = Field<9, 1>;    // SET1xIE
            using CPT2IE = Field<8, 1>;    // CPT2IE
            using CPT1IE = Field<7, 1>;    // CPT1IE
            using UPDIE = Field<6, 1>;    // UPDIE
            using REPIE = Field<4, 1>;    // REPIE
            using CMP4IE = Field<3, 1>;    // CMP4IE
            using CMP3IE = Field<2, 1>;    // CMP3IE
            using CMP2IE = Field<1, 1>;    // CMP2IE
            using CMP1IE = Field<0, 1>;    // CMP1IE
        };

        // Timerx Counter Register
        struct CNTR : public Register<0x40017510> {
            using CNTx = Field<0, 16>;    // Timerx Counter value
        };

        // Timerx Period Register
        struct PERBR : public Register<0x40017514> {
            using PERx = Field<0, 16>;    // Timerx Period value
        };

        // Timerx Repetition Register
        struct REPBR : public Register<0x40017518> {
            using REPx = Field<0, 8>;    // Timerx Repetition counter value
        };

        // Timerx Compare 1 Register
        struct CMP1BR : public Register<0x4001751c> {
            using CMP1x = Field<0, 16>;    // Timerx Compare 1 value
        };

        // Timerx Compare 1 Compound Register
        struct CMP1CBR : public Register<0x40017520> {
            using REPx = Field<16, 8>;    // Timerx Repetition value (aliased from HRTIM_REPx register)
            using CMP1x = Field<0, 16>;    // Timerx Compare 1 value
        };

        // Timerx Compare 2 Register
        struct CMP2BR : public Register<0x40017524> {
            using CMP2x = Field<0, 16>;    // Timerx Compare 2 value
        };

        // Timerx Compare 3 Register
        struct CMP3BR : public Register<0x40017528> {
            using CMP3x = Field<0, 16>;    // Timerx Compare 3 value
        };

        // Timerx Compare 4 Register
        struct CMP4BR : public Register<0x4001752c> {
            using CMP4x = Field<0, 16>;    // Timerx Compare 4 value
        };

        // Timerx Capture 1 Register
        struct CPT1BR : public Register<0x40017530> {
            using CPT1x = Field<0, 16>;    // Timerx Capture 1 value
        };

        // Timerx Capture 2 Register
        struct CPT2BR : public Register<0x40017534> {
            using CPT2x = Field<0, 16>;    // Timerx Capture 2 value
        };

        // Timerx Deadtime Register
        struct DTBR : public Register<0x40017538> {
            using DTFLKx = Field<31, 1>;    // Deadtime Falling Lock
            using DTFSLKx = Field<30, 1>;    // Deadtime Falling Sign Lock
            using SDTFx = Field<25, 1>;    // Sign Deadtime Falling value
            using DTFx = Field<16, 9>;    // Deadtime Falling value
            using DTRLKx = Field<15, 1>;    // Deadtime Rising Lock
            using DTRSLKx = Field<14, 1>;    // Deadtime Rising Sign Lock
            using DTPRSC = Field<10, 3>;    // Deadtime Prescaler
            using SDTRx = Field<9, 1>;    // Sign Deadtime Rising value
            using DTRx = Field<0, 9>;    // Deadtime Rising value
        };

        // Timerx Output1 Set Register
        struct SETB1R : public Register<0x4001753c> {
            using UPDATE = Field<31, 1>;    // Registers update (transfer preload to active)
            using EXTEVNT10 = Field<30, 1>;    // External Event 10
            using EXTEVNT9 = Field<29, 1>;    // External Event 9
            using EXTEVNT8 = Field<28, 1>;    // External Event 8
            using EXTEVNT7 = Field<27, 1>;    // External Event 7
            using EXTEVNT6 = Field<26, 1>;    // External Event 6
            using EXTEVNT5 = Field<25, 1>;    // External Event 5
            using EXTEVNT4 = Field<24, 1>;    // External Event 4
            using EXTEVNT3 = Field<23, 1>;    // External Event 3
            using EXTEVNT2 = Field<22, 1>;    // External Event 2
            using EXTEVNT1 = Field<21, 1>;    // External Event 1
            using TIMEVNT9 = Field<20, 1>;    // Timer Event 9
            using TIMEVNT8 = Field<19, 1>;    // Timer Event 8
            using TIMEVNT7 = Field<18, 1>;    // Timer Event 7
            using TIMEVNT6 = Field<17, 1>;    // Timer Event 6
            using TIMEVNT5 = Field<16, 1>;    // Timer Event 5
            using TIMEVNT4 = Field<15, 1>;    // Timer Event 4
            using TIMEVNT3 = Field<14, 1>;    // Timer Event 3
            using TIMEVNT2 = Field<13, 1>;    // Timer Event 2
            using TIMEVNT1 = Field<12, 1>;    // Timer Event 1
            using MSTCMP4 = Field<11, 1>;    // Master Compare 4
            using MSTCMP3 = Field<10, 1>;    // Master Compare 3
            using MSTCMP2 = Field<9, 1>;    // Master Compare 2
            using MSTCMP1 = Field<8, 1>;    // Master Compare 1
            using MSTPER = Field<7, 1>;    // Master Period
            using CMP4 = Field<6, 1>;    // Timer A compare 4
            using CMP3 = Field<5, 1>;    // Timer A compare 3
            using CMP2 = Field<4, 1>;    // Timer A compare 2
            using CMP1 = Field<3, 1>;    // Timer A compare 1
            using PER = Field<2, 1>;    // Timer A Period
            using RESYNC = Field<1, 1>;    // Timer A resynchronizaton
            using SST = Field<0, 1>;    // Software Set trigger
        };

        // Timerx Output1 Reset Register
        struct RSTB1R : public Register<0x40017540> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SRT = Field<0, 1>;    // SRT
        };

        // Timerx Output2 Set Register
        struct SETB2R : public Register<0x40017544> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SST = Field<0, 1>;    // SST
        };

        // Timerx Output2 Reset Register
        struct RSTB2R : public Register<0x40017548> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SRT = Field<0, 1>;    // SRT
        };

        // Timerx External Event Filtering Register 1
        struct EEFBR1 : public Register<0x4001754c> {
            using EE5FLTR = Field<25, 4>;    // External Event 5 filter
            using EE5LTCH = Field<24, 1>;    // External Event 5 latch
            using EE4FLTR = Field<19, 4>;    // External Event 4 filter
            using EE4LTCH = Field<18, 1>;    // External Event 4 latch
            using EE3FLTR = Field<13, 4>;    // External Event 3 filter
            using EE3LTCH = Field<12, 1>;    // External Event 3 latch
            using EE2FLTR = Field<7, 4>;    // External Event 2 filter
            using EE2LTCH = Field<6, 1>;    // External Event 2 latch
            using EE1FLTR = Field<1, 4>;    // External Event 1 filter
            using EE1LTCH = Field<0, 1>;    // External Event 1 latch
        };

        // Timerx External Event Filtering Register 2
        struct EEFBR2 : public Register<0x40017550> {
            using EE10FLTR = Field<25, 4>;    // External Event 10 filter
            using EE10LTCH = Field<24, 1>;    // External Event 10 latch
            using EE9FLTR = Field<19, 4>;    // External Event 9 filter
            using EE9LTCH = Field<18, 1>;    // External Event 9 latch
            using EE8FLTR = Field<13, 4>;    // External Event 8 filter
            using EE8LTCH = Field<12, 1>;    // External Event 8 latch
            using EE7FLTR = Field<7, 4>;    // External Event 7 filter
            using EE7LTCH = Field<6, 1>;    // External Event 7 latch
            using EE6FLTR = Field<1, 4>;    // External Event 6 filter
            using EE6LTCH = Field<0, 1>;    // External Event 6 latch
        };

        // TimerA Reset Register
        struct RSTBR : public Register<0x40017554> {
            using TIMECMP4 = Field<30, 1>;    // Timer E Compare 4
            using TIMECMP2 = Field<29, 1>;    // Timer E Compare 2
            using TIMECMP1 = Field<28, 1>;    // Timer E Compare 1
            using TIMDCMP4 = Field<27, 1>;    // Timer D Compare 4
            using TIMDCMP2 = Field<26, 1>;    // Timer D Compare 2
            using TIMDCMP1 = Field<25, 1>;    // Timer D Compare 1
            using TIMCCMP4 = Field<24, 1>;    // Timer C Compare 4
            using TIMCCMP2 = Field<23, 1>;    // Timer C Compare 2
            using TIMCCMP1 = Field<22, 1>;    // Timer C Compare 1
            using TIMACMP4 = Field<21, 1>;    // Timer A Compare 4
            using TIMACMP2 = Field<20, 1>;    // Timer A Compare 2
            using TIMACMP1 = Field<19, 1>;    // Timer A Compare 1
            using EXTEVNT10 = Field<18, 1>;    // External Event 10
            using EXTEVNT9 = Field<17, 1>;    // External Event 9
            using EXTEVNT8 = Field<16, 1>;    // External Event 8
            using EXTEVNT7 = Field<15, 1>;    // External Event 7
            using EXTEVNT6 = Field<14, 1>;    // External Event 6
            using EXTEVNT5 = Field<13, 1>;    // External Event 5
            using EXTEVNT4 = Field<12, 1>;    // External Event 4
            using EXTEVNT3 = Field<11, 1>;    // External Event 3
            using EXTEVNT2 = Field<10, 1>;    // External Event 2
            using EXTEVNT1 = Field<9, 1>;    // External Event 1
            using MSTCMP4 = Field<8, 1>;    // Master compare 4
            using MSTCMP3 = Field<7, 1>;    // Master compare 3
            using MSTCMP2 = Field<6, 1>;    // Master compare 2
            using MSTCMP1 = Field<5, 1>;    // Master compare 1
            using MSTPER = Field<4, 1>;    // Master timer Period
            using CMP4 = Field<3, 1>;    // Timer A compare 4 reset
            using CMP2 = Field<2, 1>;    // Timer A compare 2 reset
            using UPDT = Field<1, 1>;    // Timer A Update reset
        };

        // Timerx Chopper Register
        struct CHPBR : public Register<0x40017558> {
            using STRTPW = Field<7, 4>;    // STRTPW
            using CHPDTY = Field<4, 3>;    // Timerx chopper duty cycle value
            using CHPFRQ = Field<0, 4>;    // Timerx carrier frequency value
        };

        // Timerx Capture 2 Control Register
        struct CPT1BCR : public Register<0x4001755c> {
            using TECMP2 = Field<31, 1>;    // Timer E Compare 2
            using TECMP1 = Field<30, 1>;    // Timer E Compare 1
            using TE1RST = Field<29, 1>;    // Timer E output 1 Reset
            using TE1SET = Field<28, 1>;    // Timer E output 1 Set
            using TDCMP2 = Field<27, 1>;    // Timer D Compare 2
            using TDCMP1 = Field<26, 1>;    // Timer D Compare 1
            using TD1RST = Field<25, 1>;    // Timer D output 1 Reset
            using TD1SET = Field<24, 1>;    // Timer D output 1 Set
            using TCCMP2 = Field<23, 1>;    // Timer C Compare 2
            using TCCMP1 = Field<22, 1>;    // Timer C Compare 1
            using TC1RST = Field<21, 1>;    // Timer C output 1 Reset
            using TC1SET = Field<20, 1>;    // Timer C output 1 Set
            using TACMP2 = Field<15, 1>;    // Timer A Compare 2
            using TACMP1 = Field<14, 1>;    // Timer A Compare 1
            using TA1RST = Field<13, 1>;    // Timer A output 1 Reset
            using TA1SET = Field<12, 1>;    // Timer A output 1 Set
            using EXEV10CPT = Field<11, 1>;    // External Event 10 Capture
            using EXEV9CPT = Field<10, 1>;    // External Event 9 Capture
            using EXEV8CPT = Field<9, 1>;    // External Event 8 Capture
            using EXEV7CPT = Field<8, 1>;    // External Event 7 Capture
            using EXEV6CPT = Field<7, 1>;    // External Event 6 Capture
            using EXEV5CPT = Field<6, 1>;    // External Event 5 Capture
            using EXEV4CPT = Field<5, 1>;    // External Event 4 Capture
            using EXEV3CPT = Field<4, 1>;    // External Event 3 Capture
            using EXEV2CPT = Field<3, 1>;    // External Event 2 Capture
            using EXEV1CPT = Field<2, 1>;    // External Event 1 Capture
            using UDPCPT = Field<1, 1>;    // Update Capture
            using SWCPT = Field<0, 1>;    // Software Capture
        };

        // CPT2xCR
        struct CPT2BCR : public Register<0x40017560> {
            using TECMP2 = Field<31, 1>;    // Timer E Compare 2
            using TECMP1 = Field<30, 1>;    // Timer E Compare 1
            using TE1RST = Field<29, 1>;    // Timer E output 1 Reset
            using TE1SET = Field<28, 1>;    // Timer E output 1 Set
            using TDCMP2 = Field<27, 1>;    // Timer D Compare 2
            using TDCMP1 = Field<26, 1>;    // Timer D Compare 1
            using TD1RST = Field<25, 1>;    // Timer D output 1 Reset
            using TD1SET = Field<24, 1>;    // Timer D output 1 Set
            using TCCMP2 = Field<23, 1>;    // Timer C Compare 2
            using TCCMP1 = Field<22, 1>;    // Timer C Compare 1
            using TC1RST = Field<21, 1>;    // Timer C output 1 Reset
            using TC1SET = Field<20, 1>;    // Timer C output 1 Set
            using TACMP2 = Field<15, 1>;    // Timer A Compare 2
            using TACMP1 = Field<14, 1>;    // Timer A Compare 1
            using TA1RST = Field<13, 1>;    // Timer A output 1 Reset
            using TA1SET = Field<12, 1>;    // Timer A output 1 Set
            using EXEV10CPT = Field<11, 1>;    // External Event 10 Capture
            using EXEV9CPT = Field<10, 1>;    // External Event 9 Capture
            using EXEV8CPT = Field<9, 1>;    // External Event 8 Capture
            using EXEV7CPT = Field<8, 1>;    // External Event 7 Capture
            using EXEV6CPT = Field<7, 1>;    // External Event 6 Capture
            using EXEV5CPT = Field<6, 1>;    // External Event 5 Capture
            using EXEV4CPT = Field<5, 1>;    // External Event 4 Capture
            using EXEV3CPT = Field<4, 1>;    // External Event 3 Capture
            using EXEV2CPT = Field<3, 1>;    // External Event 2 Capture
            using EXEV1CPT = Field<2, 1>;    // External Event 1 Capture
            using UDPCPT = Field<1, 1>;    // Update Capture
            using SWCPT = Field<0, 1>;    // Software Capture
        };

        // Timerx Output Register
        struct OUTBR : public Register<0x40017564> {
            using DIDL2 = Field<23, 1>;    // Output 2 Deadtime upon burst mode Idle entry
            using CHP2 = Field<22, 1>;    // Output 2 Chopper enable
            using FAULT2 = Field<20, 2>;    // Output 2 Fault state
            using IDLES2 = Field<19, 1>;    // Output 2 Idle State
            using IDLEM2 = Field<18, 1>;    // Output 2 Idle mode
            using POL2 = Field<17, 1>;    // Output 2 polarity
            using DLYPRT = Field<10, 3>;    // Delayed Protection
            using DLYPRTEN = Field<9, 1>;    // Delayed Protection Enable
            using DTEN = Field<8, 1>;    // Deadtime enable
            using DIDL1 = Field<7, 1>;    // Output 1 Deadtime upon burst mode Idle entry
            using CHP1 = Field<6, 1>;    // Output 1 Chopper enable
            using FAULT1 = Field<4, 2>;    // Output 1 Fault state
            using IDLES1 = Field<3, 1>;    // Output 1 Idle State
            using IDLEM1 = Field<2, 1>;    // Output 1 Idle mode
            using POL1 = Field<1, 1>;    // Output 1 polarity
        };

        // Timerx Fault Register
        struct FLTBR : public Register<0x40017568> {
            using FLTLCK = Field<31, 1>;    // Fault sources Lock
            using FLT5EN = Field<4, 1>;    // Fault 5 enable
            using FLT4EN = Field<3, 1>;    // Fault 4 enable
            using FLT3EN = Field<2, 1>;    // Fault 3 enable
            using FLT2EN = Field<1, 1>;    // Fault 2 enable
            using FLT1EN = Field<0, 1>;    // Fault 1 enable
        };

    };

    // High Resolution Timer: TIMC
    struct HRTIM_TIMC {
        // Timerx Control Register
        struct TIMCCR : public Register<0x40017580> {
            using UPDGAT = Field<28, 4>;    // Update Gating
            using PREEN = Field<27, 1>;    // Preload enable
            using DACSYNC = Field<25, 2>;    // AC Synchronization
            using MSTU = Field<24, 1>;    // Master Timer update
            using TEU = Field<23, 1>;    // TEU
            using TDU = Field<22, 1>;    // TDU
            using TCU = Field<21, 1>;    // TCU
            using TBU = Field<20, 1>;    // TBU
            using TxRSTU = Field<18, 1>;    // Timerx reset update
            using TxREPU = Field<17, 1>;    // Timer x Repetition update
            using DELCMP4 = Field<14, 2>;    // Delayed CMP4 mode
            using DELCMP2 = Field<12, 2>;    // Delayed CMP2 mode
            using SYNCSTRTx = Field<11, 1>;    // Synchronization Starts Timer x
            using SYNCRSTx = Field<10, 1>;    // Synchronization Resets Timer x
            using PSHPLL = Field<6, 1>;    // Push-Pull mode enable
            using HALF = Field<5, 1>;    // Half mode enable
            using RETRIG = Field<4, 1>;    // Re-triggerable mode
            using CONT = Field<3, 1>;    // Continuous mode
            using CK_PSCx = Field<0, 3>;    // HRTIM Timer x Clock prescaler
        };

        // Timerx Interrupt Status Register
        struct TIMCISR : public Register<0x40017584> {
            using O2CPY = Field<21, 1>;    // Output 2 Copy
            using O1CPY = Field<20, 1>;    // Output 1 Copy
            using O2STAT = Field<19, 1>;    // Output 2 State
            using O1STAT = Field<18, 1>;    // Output 1 State
            using IPPSTAT = Field<17, 1>;    // Idle Push Pull Status
            using CPPSTAT = Field<16, 1>;    // Current Push Pull Status
            using DLYPRT = Field<14, 1>;    // Delayed Protection Flag
            using RST = Field<13, 1>;    // Reset Interrupt Flag
            using RSTx2 = Field<12, 1>;    // Output 2 Reset Interrupt Flag
            using SETx2 = Field<11, 1>;    // Output 2 Set Interrupt Flag
            using RSTx1 = Field<10, 1>;    // Output 1 Reset Interrupt Flag
            using SETx1 = Field<9, 1>;    // Output 1 Set Interrupt Flag
            using CPT2 = Field<8, 1>;    // Capture2 Interrupt Flag
            using CPT1 = Field<7, 1>;    // Capture1 Interrupt Flag
            using UPD = Field<6, 1>;    // Update Interrupt Flag
            using REP = Field<4, 1>;    // Repetition Interrupt Flag
            using CMP4 = Field<3, 1>;    // Compare 4 Interrupt Flag
            using CMP3 = Field<2, 1>;    // Compare 3 Interrupt Flag
            using CMP2 = Field<1, 1>;    // Compare 2 Interrupt Flag
            using CMP1 = Field<0, 1>;    // Compare 1 Interrupt Flag
        };

        // Timerx Interrupt Clear Register
        struct TIMCICR : public Register<0x40017588> {
            using DLYPRTC = Field<14, 1>;    // Delayed Protection Flag Clear
            using RSTC = Field<13, 1>;    // Reset Interrupt flag Clear
            using RSTx2C = Field<12, 1>;    // Output 2 Reset flag Clear
            using SET2xC = Field<11, 1>;    // Output 2 Set flag Clear
            using RSTx1C = Field<10, 1>;    // Output 1 Reset flag Clear
            using SET1xC = Field<9, 1>;    // Output 1 Set flag Clear
            using CPT2C = Field<8, 1>;    // Capture2 Interrupt flag Clear
            using CPT1C = Field<7, 1>;    // Capture1 Interrupt flag Clear
            using UPDC = Field<6, 1>;    // Update Interrupt flag Clear
            using REPC = Field<4, 1>;    // Repetition Interrupt flag Clear
            using CMP4C = Field<3, 1>;    // Compare 4 Interrupt flag Clear
            using CMP3C = Field<2, 1>;    // Compare 3 Interrupt flag Clear
            using CMP2C = Field<1, 1>;    // Compare 2 Interrupt flag Clear
            using CMP1C = Field<0, 1>;    // Compare 1 Interrupt flag Clear
        };

        // TIMxDIER5
        struct TIMCDIER5 : public Register<0x4001758c> {
            using DLYPRTDE = Field<30, 1>;    // DLYPRTDE
            using RSTDE = Field<29, 1>;    // RSTDE
            using RSTx2DE = Field<28, 1>;    // RSTx2DE
            using SETx2DE = Field<27, 1>;    // SETx2DE
            using RSTx1DE = Field<26, 1>;    // RSTx1DE
            using SET1xDE = Field<25, 1>;    // SET1xDE
            using CPT2DE = Field<24, 1>;    // CPT2DE
            using CPT1DE = Field<23, 1>;    // CPT1DE
            using UPDDE = Field<22, 1>;    // UPDDE
            using REPDE = Field<20, 1>;    // REPDE
            using CMP4DE = Field<19, 1>;    // CMP4DE
            using CMP3DE = Field<18, 1>;    // CMP3DE
            using CMP2DE = Field<17, 1>;    // CMP2DE
            using CMP1DE = Field<16, 1>;    // CMP1DE
            using DLYPRTIE = Field<14, 1>;    // DLYPRTIE
            using RSTIE = Field<13, 1>;    // RSTIE
            using RSTx2IE = Field<12, 1>;    // RSTx2IE
            using SETx2IE = Field<11, 1>;    // SETx2IE
            using RSTx1IE = Field<10, 1>;    // RSTx1IE
            using SET1xIE = Field<9, 1>;    // SET1xIE
            using CPT2IE = Field<8, 1>;    // CPT2IE
            using CPT1IE = Field<7, 1>;    // CPT1IE
            using UPDIE = Field<6, 1>;    // UPDIE
            using REPIE = Field<4, 1>;    // REPIE
            using CMP4IE = Field<3, 1>;    // CMP4IE
            using CMP3IE = Field<2, 1>;    // CMP3IE
            using CMP2IE = Field<1, 1>;    // CMP2IE
            using CMP1IE = Field<0, 1>;    // CMP1IE
        };

        // Timerx Counter Register
        struct CNTCR : public Register<0x40017590> {
            using CNTx = Field<0, 16>;    // Timerx Counter value
        };

        // Timerx Period Register
        struct PERCR : public Register<0x40017594> {
            using PERx = Field<0, 16>;    // Timerx Period value
        };

        // Timerx Repetition Register
        struct REPCR : public Register<0x40017598> {
            using REPx = Field<0, 8>;    // Timerx Repetition counter value
        };

        // Timerx Compare 1 Register
        struct CMP1CR : public Register<0x4001759c> {
            using CMP1x = Field<0, 16>;    // Timerx Compare 1 value
        };

        // Timerx Compare 1 Compound Register
        struct CMP1CCR : public Register<0x400175a0> {
            using REPx = Field<16, 8>;    // Timerx Repetition value (aliased from HRTIM_REPx register)
            using CMP1x = Field<0, 16>;    // Timerx Compare 1 value
        };

        // Timerx Compare 2 Register
        struct CMP2CR : public Register<0x400175a4> {
            using CMP2x = Field<0, 16>;    // Timerx Compare 2 value
        };

        // Timerx Compare 3 Register
        struct CMP3CR : public Register<0x400175a8> {
            using CMP3x = Field<0, 16>;    // Timerx Compare 3 value
        };

        // Timerx Compare 4 Register
        struct CMP4CR : public Register<0x400175ac> {
            using CMP4x = Field<0, 16>;    // Timerx Compare 4 value
        };

        // Timerx Capture 1 Register
        struct CPT1CR : public Register<0x400175b0> {
            using CPT1x = Field<0, 16>;    // Timerx Capture 1 value
        };

        // Timerx Capture 2 Register
        struct CPT2CR : public Register<0x400175b4> {
            using CPT2x = Field<0, 16>;    // Timerx Capture 2 value
        };

        // Timerx Deadtime Register
        struct DTCR : public Register<0x400175b8> {
            using DTFLKx = Field<31, 1>;    // Deadtime Falling Lock
            using DTFSLKx = Field<30, 1>;    // Deadtime Falling Sign Lock
            using SDTFx = Field<25, 1>;    // Sign Deadtime Falling value
            using DTFx = Field<16, 9>;    // Deadtime Falling value
            using DTRLKx = Field<15, 1>;    // Deadtime Rising Lock
            using DTRSLKx = Field<14, 1>;    // Deadtime Rising Sign Lock
            using DTPRSC = Field<10, 3>;    // Deadtime Prescaler
            using SDTRx = Field<9, 1>;    // Sign Deadtime Rising value
            using DTRx = Field<0, 9>;    // Deadtime Rising value
        };

        // Timerx Output1 Set Register
        struct SETC1R : public Register<0x400175bc> {
            using UPDATE = Field<31, 1>;    // Registers update (transfer preload to active)
            using EXTEVNT10 = Field<30, 1>;    // External Event 10
            using EXTEVNT9 = Field<29, 1>;    // External Event 9
            using EXTEVNT8 = Field<28, 1>;    // External Event 8
            using EXTEVNT7 = Field<27, 1>;    // External Event 7
            using EXTEVNT6 = Field<26, 1>;    // External Event 6
            using EXTEVNT5 = Field<25, 1>;    // External Event 5
            using EXTEVNT4 = Field<24, 1>;    // External Event 4
            using EXTEVNT3 = Field<23, 1>;    // External Event 3
            using EXTEVNT2 = Field<22, 1>;    // External Event 2
            using EXTEVNT1 = Field<21, 1>;    // External Event 1
            using TIMEVNT9 = Field<20, 1>;    // Timer Event 9
            using TIMEVNT8 = Field<19, 1>;    // Timer Event 8
            using TIMEVNT7 = Field<18, 1>;    // Timer Event 7
            using TIMEVNT6 = Field<17, 1>;    // Timer Event 6
            using TIMEVNT5 = Field<16, 1>;    // Timer Event 5
            using TIMEVNT4 = Field<15, 1>;    // Timer Event 4
            using TIMEVNT3 = Field<14, 1>;    // Timer Event 3
            using TIMEVNT2 = Field<13, 1>;    // Timer Event 2
            using TIMEVNT1 = Field<12, 1>;    // Timer Event 1
            using MSTCMP4 = Field<11, 1>;    // Master Compare 4
            using MSTCMP3 = Field<10, 1>;    // Master Compare 3
            using MSTCMP2 = Field<9, 1>;    // Master Compare 2
            using MSTCMP1 = Field<8, 1>;    // Master Compare 1
            using MSTPER = Field<7, 1>;    // Master Period
            using CMP4 = Field<6, 1>;    // Timer A compare 4
            using CMP3 = Field<5, 1>;    // Timer A compare 3
            using CMP2 = Field<4, 1>;    // Timer A compare 2
            using CMP1 = Field<3, 1>;    // Timer A compare 1
            using PER = Field<2, 1>;    // Timer A Period
            using RESYNC = Field<1, 1>;    // Timer A resynchronizaton
            using SST = Field<0, 1>;    // Software Set trigger
        };

        // Timerx Output1 Reset Register
        struct RSTC1R : public Register<0x400175c0> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SRT = Field<0, 1>;    // SRT
        };

        // Timerx Output2 Set Register
        struct SETC2R : public Register<0x400175c4> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SST = Field<0, 1>;    // SST
        };

        // Timerx Output2 Reset Register
        struct RSTC2R : public Register<0x400175c8> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SRT = Field<0, 1>;    // SRT
        };

        // Timerx External Event Filtering Register 1
        struct EEFCR1 : public Register<0x400175cc> {
            using EE5FLTR = Field<25, 4>;    // External Event 5 filter
            using EE5LTCH = Field<24, 1>;    // External Event 5 latch
            using EE4FLTR = Field<19, 4>;    // External Event 4 filter
            using EE4LTCH = Field<18, 1>;    // External Event 4 latch
            using EE3FLTR = Field<13, 4>;    // External Event 3 filter
            using EE3LTCH = Field<12, 1>;    // External Event 3 latch
            using EE2FLTR = Field<7, 4>;    // External Event 2 filter
            using EE2LTCH = Field<6, 1>;    // External Event 2 latch
            using EE1FLTR = Field<1, 4>;    // External Event 1 filter
            using EE1LTCH = Field<0, 1>;    // External Event 1 latch
        };

        // Timerx External Event Filtering Register 2
        struct EEFCR2 : public Register<0x400175d0> {
            using EE10FLTR = Field<25, 4>;    // External Event 10 filter
            using EE10LTCH = Field<24, 1>;    // External Event 10 latch
            using EE9FLTR = Field<19, 4>;    // External Event 9 filter
            using EE9LTCH = Field<18, 1>;    // External Event 9 latch
            using EE8FLTR = Field<13, 4>;    // External Event 8 filter
            using EE8LTCH = Field<12, 1>;    // External Event 8 latch
            using EE7FLTR = Field<7, 4>;    // External Event 7 filter
            using EE7LTCH = Field<6, 1>;    // External Event 7 latch
            using EE6FLTR = Field<1, 4>;    // External Event 6 filter
            using EE6LTCH = Field<0, 1>;    // External Event 6 latch
        };

        // TimerA Reset Register
        struct RSTCR : public Register<0x400175d4> {
            using TIMECMP4 = Field<30, 1>;    // Timer E Compare 4
            using TIMECMP2 = Field<29, 1>;    // Timer E Compare 2
            using TIMECMP1 = Field<28, 1>;    // Timer E Compare 1
            using TIMDCMP4 = Field<27, 1>;    // Timer D Compare 4
            using TIMDCMP2 = Field<26, 1>;    // Timer D Compare 2
            using TIMDCMP1 = Field<25, 1>;    // Timer D Compare 1
            using TIMBCMP4 = Field<24, 1>;    // Timer B Compare 4
            using TIMBCMP2 = Field<23, 1>;    // Timer B Compare 2
            using TIMBCMP1 = Field<22, 1>;    // Timer B Compare 1
            using TIMACMP4 = Field<21, 1>;    // Timer A Compare 4
            using TIMACMP2 = Field<20, 1>;    // Timer A Compare 2
            using TIMACMP1 = Field<19, 1>;    // Timer A Compare 1
            using EXTEVNT10 = Field<18, 1>;    // External Event 10
            using EXTEVNT9 = Field<17, 1>;    // External Event 9
            using EXTEVNT8 = Field<16, 1>;    // External Event 8
            using EXTEVNT7 = Field<15, 1>;    // External Event 7
            using EXTEVNT6 = Field<14, 1>;    // External Event 6
            using EXTEVNT5 = Field<13, 1>;    // External Event 5
            using EXTEVNT4 = Field<12, 1>;    // External Event 4
            using EXTEVNT3 = Field<11, 1>;    // External Event 3
            using EXTEVNT2 = Field<10, 1>;    // External Event 2
            using EXTEVNT1 = Field<9, 1>;    // External Event 1
            using MSTCMP4 = Field<8, 1>;    // Master compare 4
            using MSTCMP3 = Field<7, 1>;    // Master compare 3
            using MSTCMP2 = Field<6, 1>;    // Master compare 2
            using MSTCMP1 = Field<5, 1>;    // Master compare 1
            using MSTPER = Field<4, 1>;    // Master timer Period
            using CMP4 = Field<3, 1>;    // Timer A compare 4 reset
            using CMP2 = Field<2, 1>;    // Timer A compare 2 reset
            using UPDT = Field<1, 1>;    // Timer A Update reset
        };

        // Timerx Chopper Register
        struct CHPCR : public Register<0x400175d8> {
            using STRTPW = Field<7, 4>;    // STRTPW
            using CHPDTY = Field<4, 3>;    // Timerx chopper duty cycle value
            using CHPFRQ = Field<0, 4>;    // Timerx carrier frequency value
        };

        // Timerx Capture 2 Control Register
        struct CPT1CCR : public Register<0x400175dc> {
            using TECMP2 = Field<31, 1>;    // Timer E Compare 2
            using TECMP1 = Field<30, 1>;    // Timer E Compare 1
            using TE1RST = Field<29, 1>;    // Timer E output 1 Reset
            using TE1SET = Field<28, 1>;    // Timer E output 1 Set
            using TDCMP2 = Field<27, 1>;    // Timer D Compare 2
            using TDCMP1 = Field<26, 1>;    // Timer D Compare 1
            using TD1RST = Field<25, 1>;    // Timer D output 1 Reset
            using TD1SET = Field<24, 1>;    // Timer D output 1 Set
            using TBCMP2 = Field<19, 1>;    // Timer B Compare 2
            using TBCMP1 = Field<18, 1>;    // Timer B Compare 1
            using TB1RST = Field<17, 1>;    // Timer B output 1 Reset
            using TB1SET = Field<16, 1>;    // Timer B output 1 Set
            using TACMP2 = Field<15, 1>;    // Timer A Compare 2
            using TACMP1 = Field<14, 1>;    // Timer A Compare 1
            using TA1RST = Field<13, 1>;    // Timer A output 1 Reset
            using TA1SET = Field<12, 1>;    // Timer A output 1 Set
            using EXEV10CPT = Field<11, 1>;    // External Event 10 Capture
            using EXEV9CPT = Field<10, 1>;    // External Event 9 Capture
            using EXEV8CPT = Field<9, 1>;    // External Event 8 Capture
            using EXEV7CPT = Field<8, 1>;    // External Event 7 Capture
            using EXEV6CPT = Field<7, 1>;    // External Event 6 Capture
            using EXEV5CPT = Field<6, 1>;    // External Event 5 Capture
            using EXEV4CPT = Field<5, 1>;    // External Event 4 Capture
            using EXEV3CPT = Field<4, 1>;    // External Event 3 Capture
            using EXEV2CPT = Field<3, 1>;    // External Event 2 Capture
            using EXEV1CPT = Field<2, 1>;    // External Event 1 Capture
            using UDPCPT = Field<1, 1>;    // Update Capture
            using SWCPT = Field<0, 1>;    // Software Capture
        };

        // CPT2xCR
        struct CPT2CCR : public Register<0x400175e0> {
            using TECMP2 = Field<31, 1>;    // Timer E Compare 2
            using TECMP1 = Field<30, 1>;    // Timer E Compare 1
            using TE1RST = Field<29, 1>;    // Timer E output 1 Reset
            using TE1SET = Field<28, 1>;    // Timer E output 1 Set
            using TDCMP2 = Field<27, 1>;    // Timer D Compare 2
            using TDCMP1 = Field<26, 1>;    // Timer D Compare 1
            using TD1RST = Field<25, 1>;    // Timer D output 1 Reset
            using TD1SET = Field<24, 1>;    // Timer D output 1 Set
            using TBCMP2 = Field<19, 1>;    // Timer B Compare 2
            using TBCMP1 = Field<18, 1>;    // Timer B Compare 1
            using TB1RST = Field<17, 1>;    // Timer B output 1 Reset
            using TB1SET = Field<16, 1>;    // Timer B output 1 Set
            using TACMP2 = Field<15, 1>;    // Timer A Compare 2
            using TACMP1 = Field<14, 1>;    // Timer A Compare 1
            using TA1RST = Field<13, 1>;    // Timer A output 1 Reset
            using TA1SET = Field<12, 1>;    // Timer A output 1 Set
            using EXEV10CPT = Field<11, 1>;    // External Event 10 Capture
            using EXEV9CPT = Field<10, 1>;    // External Event 9 Capture
            using EXEV8CPT = Field<9, 1>;    // External Event 8 Capture
            using EXEV7CPT = Field<8, 1>;    // External Event 7 Capture
            using EXEV6CPT = Field<7, 1>;    // External Event 6 Capture
            using EXEV5CPT = Field<6, 1>;    // External Event 5 Capture
            using EXEV4CPT = Field<5, 1>;    // External Event 4 Capture
            using EXEV3CPT = Field<4, 1>;    // External Event 3 Capture
            using EXEV2CPT = Field<3, 1>;    // External Event 2 Capture
            using EXEV1CPT = Field<2, 1>;    // External Event 1 Capture
            using UDPCPT = Field<1, 1>;    // Update Capture
            using SWCPT = Field<0, 1>;    // Software Capture
        };

        // Timerx Output Register
        struct OUTCR : public Register<0x400175e4> {
            using DIDL2 = Field<23, 1>;    // Output 2 Deadtime upon burst mode Idle entry
            using CHP2 = Field<22, 1>;    // Output 2 Chopper enable
            using FAULT2 = Field<20, 2>;    // Output 2 Fault state
            using IDLES2 = Field<19, 1>;    // Output 2 Idle State
            using IDLEM2 = Field<18, 1>;    // Output 2 Idle mode
            using POL2 = Field<17, 1>;    // Output 2 polarity
            using DLYPRT = Field<10, 3>;    // Delayed Protection
            using DLYPRTEN = Field<9, 1>;    // Delayed Protection Enable
            using DTEN = Field<8, 1>;    // Deadtime enable
            using DIDL1 = Field<7, 1>;    // Output 1 Deadtime upon burst mode Idle entry
            using CHP1 = Field<6, 1>;    // Output 1 Chopper enable
            using FAULT1 = Field<4, 2>;    // Output 1 Fault state
            using IDLES1 = Field<3, 1>;    // Output 1 Idle State
            using IDLEM1 = Field<2, 1>;    // Output 1 Idle mode
            using POL1 = Field<1, 1>;    // Output 1 polarity
        };

        // Timerx Fault Register
        struct FLTCR : public Register<0x400175e8> {
            using FLTLCK = Field<31, 1>;    // Fault sources Lock
            using FLT5EN = Field<4, 1>;    // Fault 5 enable
            using FLT4EN = Field<3, 1>;    // Fault 4 enable
            using FLT3EN = Field<2, 1>;    // Fault 3 enable
            using FLT2EN = Field<1, 1>;    // Fault 2 enable
            using FLT1EN = Field<0, 1>;    // Fault 1 enable
        };

    };

    // High Resolution Timer: TIMD
    struct HRTIM_TIMD {
        // Timerx Control Register
        struct TIMDCR : public Register<0x40017600> {
            using UPDGAT = Field<28, 4>;    // Update Gating
            using PREEN = Field<27, 1>;    // Preload enable
            using DACSYNC = Field<25, 2>;    // AC Synchronization
            using MSTU = Field<24, 1>;    // Master Timer update
            using TEU = Field<23, 1>;    // TEU
            using TDU = Field<22, 1>;    // TDU
            using TCU = Field<21, 1>;    // TCU
            using TBU = Field<20, 1>;    // TBU
            using TxRSTU = Field<18, 1>;    // Timerx reset update
            using TxREPU = Field<17, 1>;    // Timer x Repetition update
            using DELCMP4 = Field<14, 2>;    // Delayed CMP4 mode
            using DELCMP2 = Field<12, 2>;    // Delayed CMP2 mode
            using SYNCSTRTx = Field<11, 1>;    // Synchronization Starts Timer x
            using SYNCRSTx = Field<10, 1>;    // Synchronization Resets Timer x
            using PSHPLL = Field<6, 1>;    // Push-Pull mode enable
            using HALF = Field<5, 1>;    // Half mode enable
            using RETRIG = Field<4, 1>;    // Re-triggerable mode
            using CONT = Field<3, 1>;    // Continuous mode
            using CK_PSCx = Field<0, 3>;    // HRTIM Timer x Clock prescaler
        };

        // Timerx Interrupt Status Register
        struct TIMDISR : public Register<0x40017604> {
            using O2CPY = Field<21, 1>;    // Output 2 Copy
            using O1CPY = Field<20, 1>;    // Output 1 Copy
            using O2STAT = Field<19, 1>;    // Output 2 State
            using O1STAT = Field<18, 1>;    // Output 1 State
            using IPPSTAT = Field<17, 1>;    // Idle Push Pull Status
            using CPPSTAT = Field<16, 1>;    // Current Push Pull Status
            using DLYPRT = Field<14, 1>;    // Delayed Protection Flag
            using RST = Field<13, 1>;    // Reset Interrupt Flag
            using RSTx2 = Field<12, 1>;    // Output 2 Reset Interrupt Flag
            using SETx2 = Field<11, 1>;    // Output 2 Set Interrupt Flag
            using RSTx1 = Field<10, 1>;    // Output 1 Reset Interrupt Flag
            using SETx1 = Field<9, 1>;    // Output 1 Set Interrupt Flag
            using CPT2 = Field<8, 1>;    // Capture2 Interrupt Flag
            using CPT1 = Field<7, 1>;    // Capture1 Interrupt Flag
            using UPD = Field<6, 1>;    // Update Interrupt Flag
            using REP = Field<4, 1>;    // Repetition Interrupt Flag
            using CMP4 = Field<3, 1>;    // Compare 4 Interrupt Flag
            using CMP3 = Field<2, 1>;    // Compare 3 Interrupt Flag
            using CMP2 = Field<1, 1>;    // Compare 2 Interrupt Flag
            using CMP1 = Field<0, 1>;    // Compare 1 Interrupt Flag
        };

        // Timerx Interrupt Clear Register
        struct TIMDICR : public Register<0x40017608> {
            using DLYPRTC = Field<14, 1>;    // Delayed Protection Flag Clear
            using RSTC = Field<13, 1>;    // Reset Interrupt flag Clear
            using RSTx2C = Field<12, 1>;    // Output 2 Reset flag Clear
            using SET2xC = Field<11, 1>;    // Output 2 Set flag Clear
            using RSTx1C = Field<10, 1>;    // Output 1 Reset flag Clear
            using SET1xC = Field<9, 1>;    // Output 1 Set flag Clear
            using CPT2C = Field<8, 1>;    // Capture2 Interrupt flag Clear
            using CPT1C = Field<7, 1>;    // Capture1 Interrupt flag Clear
            using UPDC = Field<6, 1>;    // Update Interrupt flag Clear
            using REPC = Field<4, 1>;    // Repetition Interrupt flag Clear
            using CMP4C = Field<3, 1>;    // Compare 4 Interrupt flag Clear
            using CMP3C = Field<2, 1>;    // Compare 3 Interrupt flag Clear
            using CMP2C = Field<1, 1>;    // Compare 2 Interrupt flag Clear
            using CMP1C = Field<0, 1>;    // Compare 1 Interrupt flag Clear
        };

        // TIMxDIER5
        struct TIMDDIER5 : public Register<0x4001760c> {
            using DLYPRTDE = Field<30, 1>;    // DLYPRTDE
            using RSTDE = Field<29, 1>;    // RSTDE
            using RSTx2DE = Field<28, 1>;    // RSTx2DE
            using SETx2DE = Field<27, 1>;    // SETx2DE
            using RSTx1DE = Field<26, 1>;    // RSTx1DE
            using SET1xDE = Field<25, 1>;    // SET1xDE
            using CPT2DE = Field<24, 1>;    // CPT2DE
            using CPT1DE = Field<23, 1>;    // CPT1DE
            using UPDDE = Field<22, 1>;    // UPDDE
            using REPDE = Field<20, 1>;    // REPDE
            using CMP4DE = Field<19, 1>;    // CMP4DE
            using CMP3DE = Field<18, 1>;    // CMP3DE
            using CMP2DE = Field<17, 1>;    // CMP2DE
            using CMP1DE = Field<16, 1>;    // CMP1DE
            using DLYPRTIE = Field<14, 1>;    // DLYPRTIE
            using RSTIE = Field<13, 1>;    // RSTIE
            using RSTx2IE = Field<12, 1>;    // RSTx2IE
            using SETx2IE = Field<11, 1>;    // SETx2IE
            using RSTx1IE = Field<10, 1>;    // RSTx1IE
            using SET1xIE = Field<9, 1>;    // SET1xIE
            using CPT2IE = Field<8, 1>;    // CPT2IE
            using CPT1IE = Field<7, 1>;    // CPT1IE
            using UPDIE = Field<6, 1>;    // UPDIE
            using REPIE = Field<4, 1>;    // REPIE
            using CMP4IE = Field<3, 1>;    // CMP4IE
            using CMP3IE = Field<2, 1>;    // CMP3IE
            using CMP2IE = Field<1, 1>;    // CMP2IE
            using CMP1IE = Field<0, 1>;    // CMP1IE
        };

        // Timerx Counter Register
        struct CNTDR : public Register<0x40017610> {
            using CNTx = Field<0, 16>;    // Timerx Counter value
        };

        // Timerx Period Register
        struct PERDR : public Register<0x40017614> {
            using PERx = Field<0, 16>;    // Timerx Period value
        };

        // Timerx Repetition Register
        struct REPDR : public Register<0x40017618> {
            using REPx = Field<0, 8>;    // Timerx Repetition counter value
        };

        // Timerx Compare 1 Register
        struct CMP1DR : public Register<0x4001761c> {
            using CMP1x = Field<0, 16>;    // Timerx Compare 1 value
        };

        // Timerx Compare 1 Compound Register
        struct CMP1CDR : public Register<0x40017620> {
            using REPx = Field<16, 8>;    // Timerx Repetition value (aliased from HRTIM_REPx register)
            using CMP1x = Field<0, 16>;    // Timerx Compare 1 value
        };

        // Timerx Compare 2 Register
        struct CMP2DR : public Register<0x40017624> {
            using CMP2x = Field<0, 16>;    // Timerx Compare 2 value
        };

        // Timerx Compare 3 Register
        struct CMP3DR : public Register<0x40017628> {
            using CMP3x = Field<0, 16>;    // Timerx Compare 3 value
        };

        // Timerx Compare 4 Register
        struct CMP4DR : public Register<0x4001762c> {
            using CMP4x = Field<0, 16>;    // Timerx Compare 4 value
        };

        // Timerx Capture 1 Register
        struct CPT1DR : public Register<0x40017630> {
            using CPT1x = Field<0, 16>;    // Timerx Capture 1 value
        };

        // Timerx Capture 2 Register
        struct CPT2DR : public Register<0x40017634> {
            using CPT2x = Field<0, 16>;    // Timerx Capture 2 value
        };

        // Timerx Deadtime Register
        struct DTDR : public Register<0x40017638> {
            using DTFLKx = Field<31, 1>;    // Deadtime Falling Lock
            using DTFSLKx = Field<30, 1>;    // Deadtime Falling Sign Lock
            using SDTFx = Field<25, 1>;    // Sign Deadtime Falling value
            using DTFx = Field<16, 9>;    // Deadtime Falling value
            using DTRLKx = Field<15, 1>;    // Deadtime Rising Lock
            using DTRSLKx = Field<14, 1>;    // Deadtime Rising Sign Lock
            using DTPRSC = Field<10, 3>;    // Deadtime Prescaler
            using SDTRx = Field<9, 1>;    // Sign Deadtime Rising value
            using DTRx = Field<0, 9>;    // Deadtime Rising value
        };

        // Timerx Output1 Set Register
        struct SETD1R : public Register<0x4001763c> {
            using UPDATE = Field<31, 1>;    // Registers update (transfer preload to active)
            using EXTEVNT10 = Field<30, 1>;    // External Event 10
            using EXTEVNT9 = Field<29, 1>;    // External Event 9
            using EXTEVNT8 = Field<28, 1>;    // External Event 8
            using EXTEVNT7 = Field<27, 1>;    // External Event 7
            using EXTEVNT6 = Field<26, 1>;    // External Event 6
            using EXTEVNT5 = Field<25, 1>;    // External Event 5
            using EXTEVNT4 = Field<24, 1>;    // External Event 4
            using EXTEVNT3 = Field<23, 1>;    // External Event 3
            using EXTEVNT2 = Field<22, 1>;    // External Event 2
            using EXTEVNT1 = Field<21, 1>;    // External Event 1
            using TIMEVNT9 = Field<20, 1>;    // Timer Event 9
            using TIMEVNT8 = Field<19, 1>;    // Timer Event 8
            using TIMEVNT7 = Field<18, 1>;    // Timer Event 7
            using TIMEVNT6 = Field<17, 1>;    // Timer Event 6
            using TIMEVNT5 = Field<16, 1>;    // Timer Event 5
            using TIMEVNT4 = Field<15, 1>;    // Timer Event 4
            using TIMEVNT3 = Field<14, 1>;    // Timer Event 3
            using TIMEVNT2 = Field<13, 1>;    // Timer Event 2
            using TIMEVNT1 = Field<12, 1>;    // Timer Event 1
            using MSTCMP4 = Field<11, 1>;    // Master Compare 4
            using MSTCMP3 = Field<10, 1>;    // Master Compare 3
            using MSTCMP2 = Field<9, 1>;    // Master Compare 2
            using MSTCMP1 = Field<8, 1>;    // Master Compare 1
            using MSTPER = Field<7, 1>;    // Master Period
            using CMP4 = Field<6, 1>;    // Timer A compare 4
            using CMP3 = Field<5, 1>;    // Timer A compare 3
            using CMP2 = Field<4, 1>;    // Timer A compare 2
            using CMP1 = Field<3, 1>;    // Timer A compare 1
            using PER = Field<2, 1>;    // Timer A Period
            using RESYNC = Field<1, 1>;    // Timer A resynchronizaton
            using SST = Field<0, 1>;    // Software Set trigger
        };

        // Timerx Output1 Reset Register
        struct RSTD1R : public Register<0x40017640> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SRT = Field<0, 1>;    // SRT
        };

        // Timerx Output2 Set Register
        struct SETD2R : public Register<0x40017644> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SST = Field<0, 1>;    // SST
        };

        // Timerx Output2 Reset Register
        struct RSTD2R : public Register<0x40017648> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SRT = Field<0, 1>;    // SRT
        };

        // Timerx External Event Filtering Register 1
        struct EEFDR1 : public Register<0x4001764c> {
            using EE5FLTR = Field<25, 4>;    // External Event 5 filter
            using EE5LTCH = Field<24, 1>;    // External Event 5 latch
            using EE4FLTR = Field<19, 4>;    // External Event 4 filter
            using EE4LTCH = Field<18, 1>;    // External Event 4 latch
            using EE3FLTR = Field<13, 4>;    // External Event 3 filter
            using EE3LTCH = Field<12, 1>;    // External Event 3 latch
            using EE2FLTR = Field<7, 4>;    // External Event 2 filter
            using EE2LTCH = Field<6, 1>;    // External Event 2 latch
            using EE1FLTR = Field<1, 4>;    // External Event 1 filter
            using EE1LTCH = Field<0, 1>;    // External Event 1 latch
        };

        // Timerx External Event Filtering Register 2
        struct EEFDR2 : public Register<0x40017650> {
            using EE10FLTR = Field<25, 4>;    // External Event 10 filter
            using EE10LTCH = Field<24, 1>;    // External Event 10 latch
            using EE9FLTR = Field<19, 4>;    // External Event 9 filter
            using EE9LTCH = Field<18, 1>;    // External Event 9 latch
            using EE8FLTR = Field<13, 4>;    // External Event 8 filter
            using EE8LTCH = Field<12, 1>;    // External Event 8 latch
            using EE7FLTR = Field<7, 4>;    // External Event 7 filter
            using EE7LTCH = Field<6, 1>;    // External Event 7 latch
            using EE6FLTR = Field<1, 4>;    // External Event 6 filter
            using EE6LTCH = Field<0, 1>;    // External Event 6 latch
        };

        // TimerA Reset Register
        struct RSTDR : public Register<0x40017654> {
            using TIMECMP4 = Field<30, 1>;    // Timer E Compare 4
            using TIMECMP2 = Field<29, 1>;    // Timer E Compare 2
            using TIMECMP1 = Field<28, 1>;    // Timer E Compare 1
            using TIMCCMP4 = Field<27, 1>;    // Timer C Compare 4
            using TIMCCMP2 = Field<26, 1>;    // Timer C Compare 2
            using TIMCCMP1 = Field<25, 1>;    // Timer C Compare 1
            using TIMBCMP4 = Field<24, 1>;    // Timer B Compare 4
            using TIMBCMP2 = Field<23, 1>;    // Timer B Compare 2
            using TIMBCMP1 = Field<22, 1>;    // Timer B Compare 1
            using TIMACMP4 = Field<21, 1>;    // Timer A Compare 4
            using TIMACMP2 = Field<20, 1>;    // Timer A Compare 2
            using TIMACMP1 = Field<19, 1>;    // Timer A Compare 1
            using EXTEVNT10 = Field<18, 1>;    // External Event 10
            using EXTEVNT9 = Field<17, 1>;    // External Event 9
            using EXTEVNT8 = Field<16, 1>;    // External Event 8
            using EXTEVNT7 = Field<15, 1>;    // External Event 7
            using EXTEVNT6 = Field<14, 1>;    // External Event 6
            using EXTEVNT5 = Field<13, 1>;    // External Event 5
            using EXTEVNT4 = Field<12, 1>;    // External Event 4
            using EXTEVNT3 = Field<11, 1>;    // External Event 3
            using EXTEVNT2 = Field<10, 1>;    // External Event 2
            using EXTEVNT1 = Field<9, 1>;    // External Event 1
            using MSTCMP4 = Field<8, 1>;    // Master compare 4
            using MSTCMP3 = Field<7, 1>;    // Master compare 3
            using MSTCMP2 = Field<6, 1>;    // Master compare 2
            using MSTCMP1 = Field<5, 1>;    // Master compare 1
            using MSTPER = Field<4, 1>;    // Master timer Period
            using CMP4 = Field<3, 1>;    // Timer A compare 4 reset
            using CMP2 = Field<2, 1>;    // Timer A compare 2 reset
            using UPDT = Field<1, 1>;    // Timer A Update reset
        };

        // Timerx Chopper Register
        struct CHPDR : public Register<0x40017658> {
            using STRTPW = Field<7, 4>;    // STRTPW
            using CHPDTY = Field<4, 3>;    // Timerx chopper duty cycle value
            using CHPFRQ = Field<0, 4>;    // Timerx carrier frequency value
        };

        // Timerx Capture 2 Control Register
        struct CPT1DCR : public Register<0x4001765c> {
            using TECMP2 = Field<31, 1>;    // Timer E Compare 2
            using TECMP1 = Field<30, 1>;    // Timer E Compare 1
            using TE1RST = Field<29, 1>;    // Timer E output 1 Reset
            using TE1SET = Field<28, 1>;    // Timer E output 1 Set
            using TCCMP2 = Field<23, 1>;    // Timer C Compare 2
            using TCCMP1 = Field<22, 1>;    // Timer C Compare 1
            using TC1RST = Field<21, 1>;    // Timer C output 1 Reset
            using TC1SET = Field<20, 1>;    // Timer C output 1 Set
            using TBCMP2 = Field<19, 1>;    // Timer B Compare 2
            using TBCMP1 = Field<18, 1>;    // Timer B Compare 1
            using TB1RST = Field<17, 1>;    // Timer B output 1 Reset
            using TB1SET = Field<16, 1>;    // Timer B output 1 Set
            using TACMP2 = Field<15, 1>;    // Timer A Compare 2
            using TACMP1 = Field<14, 1>;    // Timer A Compare 1
            using TA1RST = Field<13, 1>;    // Timer A output 1 Reset
            using TA1SET = Field<12, 1>;    // Timer A output 1 Set
            using EXEV10CPT = Field<11, 1>;    // External Event 10 Capture
            using EXEV9CPT = Field<10, 1>;    // External Event 9 Capture
            using EXEV8CPT = Field<9, 1>;    // External Event 8 Capture
            using EXEV7CPT = Field<8, 1>;    // External Event 7 Capture
            using EXEV6CPT = Field<7, 1>;    // External Event 6 Capture
            using EXEV5CPT = Field<6, 1>;    // External Event 5 Capture
            using EXEV4CPT = Field<5, 1>;    // External Event 4 Capture
            using EXEV3CPT = Field<4, 1>;    // External Event 3 Capture
            using EXEV2CPT = Field<3, 1>;    // External Event 2 Capture
            using EXEV1CPT = Field<2, 1>;    // External Event 1 Capture
            using UDPCPT = Field<1, 1>;    // Update Capture
            using SWCPT = Field<0, 1>;    // Software Capture
        };

        // CPT2xCR
        struct CPT2DCR : public Register<0x40017660> {
            using TECMP2 = Field<31, 1>;    // Timer E Compare 2
            using TECMP1 = Field<30, 1>;    // Timer E Compare 1
            using TE1RST = Field<29, 1>;    // Timer E output 1 Reset
            using TE1SET = Field<28, 1>;    // Timer E output 1 Set
            using TCCMP2 = Field<23, 1>;    // Timer C Compare 2
            using TCCMP1 = Field<22, 1>;    // Timer C Compare 1
            using TC1RST = Field<21, 1>;    // Timer C output 1 Reset
            using TC1SET = Field<20, 1>;    // Timer C output 1 Set
            using TBCMP2 = Field<19, 1>;    // Timer B Compare 2
            using TBCMP1 = Field<18, 1>;    // Timer B Compare 1
            using TB1RST = Field<17, 1>;    // Timer B output 1 Reset
            using TB1SET = Field<16, 1>;    // Timer B output 1 Set
            using TACMP2 = Field<15, 1>;    // Timer A Compare 2
            using TACMP1 = Field<14, 1>;    // Timer A Compare 1
            using TA1RST = Field<13, 1>;    // Timer A output 1 Reset
            using TA1SET = Field<12, 1>;    // Timer A output 1 Set
            using EXEV10CPT = Field<11, 1>;    // External Event 10 Capture
            using EXEV9CPT = Field<10, 1>;    // External Event 9 Capture
            using EXEV8CPT = Field<9, 1>;    // External Event 8 Capture
            using EXEV7CPT = Field<8, 1>;    // External Event 7 Capture
            using EXEV6CPT = Field<7, 1>;    // External Event 6 Capture
            using EXEV5CPT = Field<6, 1>;    // External Event 5 Capture
            using EXEV4CPT = Field<5, 1>;    // External Event 4 Capture
            using EXEV3CPT = Field<4, 1>;    // External Event 3 Capture
            using EXEV2CPT = Field<3, 1>;    // External Event 2 Capture
            using EXEV1CPT = Field<2, 1>;    // External Event 1 Capture
            using UDPCPT = Field<1, 1>;    // Update Capture
            using SWCPT = Field<0, 1>;    // Software Capture
        };

        // Timerx Output Register
        struct OUTDR : public Register<0x40017664> {
            using DIDL2 = Field<23, 1>;    // Output 2 Deadtime upon burst mode Idle entry
            using CHP2 = Field<22, 1>;    // Output 2 Chopper enable
            using FAULT2 = Field<20, 2>;    // Output 2 Fault state
            using IDLES2 = Field<19, 1>;    // Output 2 Idle State
            using IDLEM2 = Field<18, 1>;    // Output 2 Idle mode
            using POL2 = Field<17, 1>;    // Output 2 polarity
            using DLYPRT = Field<10, 3>;    // Delayed Protection
            using DLYPRTEN = Field<9, 1>;    // Delayed Protection Enable
            using DTEN = Field<8, 1>;    // Deadtime enable
            using DIDL1 = Field<7, 1>;    // Output 1 Deadtime upon burst mode Idle entry
            using CHP1 = Field<6, 1>;    // Output 1 Chopper enable
            using FAULT1 = Field<4, 2>;    // Output 1 Fault state
            using IDLES1 = Field<3, 1>;    // Output 1 Idle State
            using IDLEM1 = Field<2, 1>;    // Output 1 Idle mode
            using POL1 = Field<1, 1>;    // Output 1 polarity
        };

        // Timerx Fault Register
        struct FLTDR : public Register<0x40017668> {
            using FLTLCK = Field<31, 1>;    // Fault sources Lock
            using FLT5EN = Field<4, 1>;    // Fault 5 enable
            using FLT4EN = Field<3, 1>;    // Fault 4 enable
            using FLT3EN = Field<2, 1>;    // Fault 3 enable
            using FLT2EN = Field<1, 1>;    // Fault 2 enable
            using FLT1EN = Field<0, 1>;    // Fault 1 enable
        };

    };

    // High Resolution Timer: TIME
    struct HRTIM_TIME {
        // Timerx Control Register
        struct TIMECR : public Register<0x40017680> {
            using UPDGAT = Field<28, 4>;    // Update Gating
            using PREEN = Field<27, 1>;    // Preload enable
            using DACSYNC = Field<25, 2>;    // AC Synchronization
            using MSTU = Field<24, 1>;    // Master Timer update
            using TEU = Field<23, 1>;    // TEU
            using TDU = Field<22, 1>;    // TDU
            using TCU = Field<21, 1>;    // TCU
            using TBU = Field<20, 1>;    // TBU
            using TxRSTU = Field<18, 1>;    // Timerx reset update
            using TxREPU = Field<17, 1>;    // Timer x Repetition update
            using DELCMP4 = Field<14, 2>;    // Delayed CMP4 mode
            using DELCMP2 = Field<12, 2>;    // Delayed CMP2 mode
            using SYNCSTRTx = Field<11, 1>;    // Synchronization Starts Timer x
            using SYNCRSTx = Field<10, 1>;    // Synchronization Resets Timer x
            using PSHPLL = Field<6, 1>;    // Push-Pull mode enable
            using HALF = Field<5, 1>;    // Half mode enable
            using RETRIG = Field<4, 1>;    // Re-triggerable mode
            using CONT = Field<3, 1>;    // Continuous mode
            using CK_PSCx = Field<0, 3>;    // HRTIM Timer x Clock prescaler
        };

        // Timerx Interrupt Status Register
        struct TIMEISR : public Register<0x40017684> {
            using O2CPY = Field<21, 1>;    // Output 2 Copy
            using O1CPY = Field<20, 1>;    // Output 1 Copy
            using O2STAT = Field<19, 1>;    // Output 2 State
            using O1STAT = Field<18, 1>;    // Output 1 State
            using IPPSTAT = Field<17, 1>;    // Idle Push Pull Status
            using CPPSTAT = Field<16, 1>;    // Current Push Pull Status
            using DLYPRT = Field<14, 1>;    // Delayed Protection Flag
            using RST = Field<13, 1>;    // Reset Interrupt Flag
            using RSTx2 = Field<12, 1>;    // Output 2 Reset Interrupt Flag
            using SETx2 = Field<11, 1>;    // Output 2 Set Interrupt Flag
            using RSTx1 = Field<10, 1>;    // Output 1 Reset Interrupt Flag
            using SETx1 = Field<9, 1>;    // Output 1 Set Interrupt Flag
            using CPT2 = Field<8, 1>;    // Capture2 Interrupt Flag
            using CPT1 = Field<7, 1>;    // Capture1 Interrupt Flag
            using UPD = Field<6, 1>;    // Update Interrupt Flag
            using REP = Field<4, 1>;    // Repetition Interrupt Flag
            using CMP4 = Field<3, 1>;    // Compare 4 Interrupt Flag
            using CMP3 = Field<2, 1>;    // Compare 3 Interrupt Flag
            using CMP2 = Field<1, 1>;    // Compare 2 Interrupt Flag
            using CMP1 = Field<0, 1>;    // Compare 1 Interrupt Flag
        };

        // Timerx Interrupt Clear Register
        struct TIMEICR : public Register<0x40017688> {
            using DLYPRTC = Field<14, 1>;    // Delayed Protection Flag Clear
            using RSTC = Field<13, 1>;    // Reset Interrupt flag Clear
            using RSTx2C = Field<12, 1>;    // Output 2 Reset flag Clear
            using SET2xC = Field<11, 1>;    // Output 2 Set flag Clear
            using RSTx1C = Field<10, 1>;    // Output 1 Reset flag Clear
            using SET1xC = Field<9, 1>;    // Output 1 Set flag Clear
            using CPT2C = Field<8, 1>;    // Capture2 Interrupt flag Clear
            using CPT1C = Field<7, 1>;    // Capture1 Interrupt flag Clear
            using UPDC = Field<6, 1>;    // Update Interrupt flag Clear
            using REPC = Field<4, 1>;    // Repetition Interrupt flag Clear
            using CMP4C = Field<3, 1>;    // Compare 4 Interrupt flag Clear
            using CMP3C = Field<2, 1>;    // Compare 3 Interrupt flag Clear
            using CMP2C = Field<1, 1>;    // Compare 2 Interrupt flag Clear
            using CMP1C = Field<0, 1>;    // Compare 1 Interrupt flag Clear
        };

        // TIMxDIER5
        struct TIMEDIER5 : public Register<0x4001768c> {
            using DLYPRTDE = Field<30, 1>;    // DLYPRTDE
            using RSTDE = Field<29, 1>;    // RSTDE
            using RSTx2DE = Field<28, 1>;    // RSTx2DE
            using SETx2DE = Field<27, 1>;    // SETx2DE
            using RSTx1DE = Field<26, 1>;    // RSTx1DE
            using SET1xDE = Field<25, 1>;    // SET1xDE
            using CPT2DE = Field<24, 1>;    // CPT2DE
            using CPT1DE = Field<23, 1>;    // CPT1DE
            using UPDDE = Field<22, 1>;    // UPDDE
            using REPDE = Field<20, 1>;    // REPDE
            using CMP4DE = Field<19, 1>;    // CMP4DE
            using CMP3DE = Field<18, 1>;    // CMP3DE
            using CMP2DE = Field<17, 1>;    // CMP2DE
            using CMP1DE = Field<16, 1>;    // CMP1DE
            using DLYPRTIE = Field<14, 1>;    // DLYPRTIE
            using RSTIE = Field<13, 1>;    // RSTIE
            using RSTx2IE = Field<12, 1>;    // RSTx2IE
            using SETx2IE = Field<11, 1>;    // SETx2IE
            using RSTx1IE = Field<10, 1>;    // RSTx1IE
            using SET1xIE = Field<9, 1>;    // SET1xIE
            using CPT2IE = Field<8, 1>;    // CPT2IE
            using CPT1IE = Field<7, 1>;    // CPT1IE
            using UPDIE = Field<6, 1>;    // UPDIE
            using REPIE = Field<4, 1>;    // REPIE
            using CMP4IE = Field<3, 1>;    // CMP4IE
            using CMP3IE = Field<2, 1>;    // CMP3IE
            using CMP2IE = Field<1, 1>;    // CMP2IE
            using CMP1IE = Field<0, 1>;    // CMP1IE
        };

        // Timerx Counter Register
        struct CNTER : public Register<0x40017690> {
            using CNTx = Field<0, 16>;    // Timerx Counter value
        };

        // Timerx Period Register
        struct PERER : public Register<0x40017694> {
            using PERx = Field<0, 16>;    // Timerx Period value
        };

        // Timerx Repetition Register
        struct REPER : public Register<0x40017698> {
            using REPx = Field<0, 8>;    // Timerx Repetition counter value
        };

        // Timerx Compare 1 Register
        struct CMP1ER : public Register<0x4001769c> {
            using CMP1x = Field<0, 16>;    // Timerx Compare 1 value
        };

        // Timerx Compare 1 Compound Register
        struct CMP1CER : public Register<0x400176a0> {
            using REPx = Field<16, 8>;    // Timerx Repetition value (aliased from HRTIM_REPx register)
            using CMP1x = Field<0, 16>;    // Timerx Compare 1 value
        };

        // Timerx Compare 2 Register
        struct CMP2ER : public Register<0x400176a4> {
            using CMP2x = Field<0, 16>;    // Timerx Compare 2 value
        };

        // Timerx Compare 3 Register
        struct CMP3ER : public Register<0x400176a8> {
            using CMP3x = Field<0, 16>;    // Timerx Compare 3 value
        };

        // Timerx Compare 4 Register
        struct CMP4ER : public Register<0x400176ac> {
            using CMP4x = Field<0, 16>;    // Timerx Compare 4 value
        };

        // Timerx Capture 1 Register
        struct CPT1ER : public Register<0x400176b0> {
            using CPT1x = Field<0, 16>;    // Timerx Capture 1 value
        };

        // Timerx Capture 2 Register
        struct CPT2ER : public Register<0x400176b4> {
            using CPT2x = Field<0, 16>;    // Timerx Capture 2 value
        };

        // Timerx Deadtime Register
        struct DTER : public Register<0x400176b8> {
            using DTFLKx = Field<31, 1>;    // Deadtime Falling Lock
            using DTFSLKx = Field<30, 1>;    // Deadtime Falling Sign Lock
            using SDTFx = Field<25, 1>;    // Sign Deadtime Falling value
            using DTFx = Field<16, 9>;    // Deadtime Falling value
            using DTRLKx = Field<15, 1>;    // Deadtime Rising Lock
            using DTRSLKx = Field<14, 1>;    // Deadtime Rising Sign Lock
            using DTPRSC = Field<10, 3>;    // Deadtime Prescaler
            using SDTRx = Field<9, 1>;    // Sign Deadtime Rising value
            using DTRx = Field<0, 9>;    // Deadtime Rising value
        };

        // Timerx Output1 Set Register
        struct SETE1R : public Register<0x400176bc> {
            using UPDATE = Field<31, 1>;    // Registers update (transfer preload to active)
            using EXTEVNT10 = Field<30, 1>;    // External Event 10
            using EXTEVNT9 = Field<29, 1>;    // External Event 9
            using EXTEVNT8 = Field<28, 1>;    // External Event 8
            using EXTEVNT7 = Field<27, 1>;    // External Event 7
            using EXTEVNT6 = Field<26, 1>;    // External Event 6
            using EXTEVNT5 = Field<25, 1>;    // External Event 5
            using EXTEVNT4 = Field<24, 1>;    // External Event 4
            using EXTEVNT3 = Field<23, 1>;    // External Event 3
            using EXTEVNT2 = Field<22, 1>;    // External Event 2
            using EXTEVNT1 = Field<21, 1>;    // External Event 1
            using TIMEVNT9 = Field<20, 1>;    // Timer Event 9
            using TIMEVNT8 = Field<19, 1>;    // Timer Event 8
            using TIMEVNT7 = Field<18, 1>;    // Timer Event 7
            using TIMEVNT6 = Field<17, 1>;    // Timer Event 6
            using TIMEVNT5 = Field<16, 1>;    // Timer Event 5
            using TIMEVNT4 = Field<15, 1>;    // Timer Event 4
            using TIMEVNT3 = Field<14, 1>;    // Timer Event 3
            using TIMEVNT2 = Field<13, 1>;    // Timer Event 2
            using TIMEVNT1 = Field<12, 1>;    // Timer Event 1
            using MSTCMP4 = Field<11, 1>;    // Master Compare 4
            using MSTCMP3 = Field<10, 1>;    // Master Compare 3
            using MSTCMP2 = Field<9, 1>;    // Master Compare 2
            using MSTCMP1 = Field<8, 1>;    // Master Compare 1
            using MSTPER = Field<7, 1>;    // Master Period
            using CMP4 = Field<6, 1>;    // Timer A compare 4
            using CMP3 = Field<5, 1>;    // Timer A compare 3
            using CMP2 = Field<4, 1>;    // Timer A compare 2
            using CMP1 = Field<3, 1>;    // Timer A compare 1
            using PER = Field<2, 1>;    // Timer A Period
            using RESYNC = Field<1, 1>;    // Timer A resynchronizaton
            using SST = Field<0, 1>;    // Software Set trigger
        };

        // Timerx Output1 Reset Register
        struct RSTE1R : public Register<0x400176c0> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SRT = Field<0, 1>;    // SRT
        };

        // Timerx Output2 Set Register
        struct SETE2R : public Register<0x400176c4> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SST = Field<0, 1>;    // SST
        };

        // Timerx Output2 Reset Register
        struct RSTE2R : public Register<0x400176c8> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SRT = Field<0, 1>;    // SRT
        };

        // Timerx External Event Filtering Register 1
        struct EEFER1 : public Register<0x400176cc> {
            using EE5FLTR = Field<25, 4>;    // External Event 5 filter
            using EE5LTCH = Field<24, 1>;    // External Event 5 latch
            using EE4FLTR = Field<19, 4>;    // External Event 4 filter
            using EE4LTCH = Field<18, 1>;    // External Event 4 latch
            using EE3FLTR = Field<13, 4>;    // External Event 3 filter
            using EE3LTCH = Field<12, 1>;    // External Event 3 latch
            using EE2FLTR = Field<7, 4>;    // External Event 2 filter
            using EE2LTCH = Field<6, 1>;    // External Event 2 latch
            using EE1FLTR = Field<1, 4>;    // External Event 1 filter
            using EE1LTCH = Field<0, 1>;    // External Event 1 latch
        };

        // Timerx External Event Filtering Register 2
        struct EEFER2 : public Register<0x400176d0> {
            using EE10FLTR = Field<25, 4>;    // External Event 10 filter
            using EE10LTCH = Field<24, 1>;    // External Event 10 latch
            using EE9FLTR = Field<19, 4>;    // External Event 9 filter
            using EE9LTCH = Field<18, 1>;    // External Event 9 latch
            using EE8FLTR = Field<13, 4>;    // External Event 8 filter
            using EE8LTCH = Field<12, 1>;    // External Event 8 latch
            using EE7FLTR = Field<7, 4>;    // External Event 7 filter
            using EE7LTCH = Field<6, 1>;    // External Event 7 latch
            using EE6FLTR = Field<1, 4>;    // External Event 6 filter
            using EE6LTCH = Field<0, 1>;    // External Event 6 latch
        };

        // TimerA Reset Register
        struct RSTER : public Register<0x400176d4> {
            using TIMDCMP4 = Field<30, 1>;    // Timer D Compare 4
            using TIMDCMP2 = Field<29, 1>;    // Timer D Compare 2
            using TIMDCMP1 = Field<28, 1>;    // Timer D Compare 1
            using TIMCCMP4 = Field<27, 1>;    // Timer C Compare 4
            using TIMCCMP2 = Field<26, 1>;    // Timer C Compare 2
            using TIMCCMP1 = Field<25, 1>;    // Timer C Compare 1
            using TIMBCMP4 = Field<24, 1>;    // Timer B Compare 4
            using TIMBCMP2 = Field<23, 1>;    // Timer B Compare 2
            using TIMBCMP1 = Field<22, 1>;    // Timer B Compare 1
            using TIMACMP4 = Field<21, 1>;    // Timer A Compare 4
            using TIMACMP2 = Field<20, 1>;    // Timer A Compare 2
            using TIMACMP1 = Field<19, 1>;    // Timer A Compare 1
            using EXTEVNT10 = Field<18, 1>;    // External Event 10
            using EXTEVNT9 = Field<17, 1>;    // External Event 9
            using EXTEVNT8 = Field<16, 1>;    // External Event 8
            using EXTEVNT7 = Field<15, 1>;    // External Event 7
            using EXTEVNT6 = Field<14, 1>;    // External Event 6
            using EXTEVNT5 = Field<13, 1>;    // External Event 5
            using EXTEVNT4 = Field<12, 1>;    // External Event 4
            using EXTEVNT3 = Field<11, 1>;    // External Event 3
            using EXTEVNT2 = Field<10, 1>;    // External Event 2
            using EXTEVNT1 = Field<9, 1>;    // External Event 1
            using MSTCMP4 = Field<8, 1>;    // Master compare 4
            using MSTCMP3 = Field<7, 1>;    // Master compare 3
            using MSTCMP2 = Field<6, 1>;    // Master compare 2
            using MSTCMP1 = Field<5, 1>;    // Master compare 1
            using MSTPER = Field<4, 1>;    // Master timer Period
            using CMP4 = Field<3, 1>;    // Timer A compare 4 reset
            using CMP2 = Field<2, 1>;    // Timer A compare 2 reset
            using UPDT = Field<1, 1>;    // Timer A Update reset
        };

        // Timerx Chopper Register
        struct CHPER : public Register<0x400176d8> {
            using STRTPW = Field<7, 4>;    // STRTPW
            using CHPDTY = Field<4, 3>;    // Timerx chopper duty cycle value
            using CHPFRQ = Field<0, 4>;    // Timerx carrier frequency value
        };

        // Timerx Capture 2 Control Register
        struct CPT1ECR : public Register<0x400176dc> {
            using TDCMP2 = Field<27, 1>;    // Timer D Compare 2
            using TDCMP1 = Field<26, 1>;    // Timer D Compare 1
            using TD1RST = Field<25, 1>;    // Timer D output 1 Reset
            using TD1SET = Field<24, 1>;    // Timer D output 1 Set
            using TCCMP2 = Field<23, 1>;    // Timer C Compare 2
            using TCCMP1 = Field<22, 1>;    // Timer C Compare 1
            using TC1RST = Field<21, 1>;    // Timer C output 1 Reset
            using TC1SET = Field<20, 1>;    // Timer C output 1 Set
            using TBCMP2 = Field<19, 1>;    // Timer B Compare 2
            using TBCMP1 = Field<18, 1>;    // Timer B Compare 1
            using TB1RST = Field<17, 1>;    // Timer B output 1 Reset
            using TB1SET = Field<16, 1>;    // Timer B output 1 Set
            using TACMP2 = Field<15, 1>;    // Timer A Compare 2
            using TACMP1 = Field<14, 1>;    // Timer A Compare 1
            using TA1RST = Field<13, 1>;    // Timer A output 1 Reset
            using TA1SET = Field<12, 1>;    // Timer A output 1 Set
            using EXEV10CPT = Field<11, 1>;    // External Event 10 Capture
            using EXEV9CPT = Field<10, 1>;    // External Event 9 Capture
            using EXEV8CPT = Field<9, 1>;    // External Event 8 Capture
            using EXEV7CPT = Field<8, 1>;    // External Event 7 Capture
            using EXEV6CPT = Field<7, 1>;    // External Event 6 Capture
            using EXEV5CPT = Field<6, 1>;    // External Event 5 Capture
            using EXEV4CPT = Field<5, 1>;    // External Event 4 Capture
            using EXEV3CPT = Field<4, 1>;    // External Event 3 Capture
            using EXEV2CPT = Field<3, 1>;    // External Event 2 Capture
            using EXEV1CPT = Field<2, 1>;    // External Event 1 Capture
            using UDPCPT = Field<1, 1>;    // Update Capture
            using SWCPT = Field<0, 1>;    // Software Capture
        };

        // CPT2xCR
        struct CPT2ECR : public Register<0x400176e0> {
            using TDCMP2 = Field<27, 1>;    // Timer D Compare 2
            using TDCMP1 = Field<26, 1>;    // Timer D Compare 1
            using TD1RST = Field<25, 1>;    // Timer D output 1 Reset
            using TD1SET = Field<24, 1>;    // Timer D output 1 Set
            using TCCMP2 = Field<23, 1>;    // Timer C Compare 2
            using TCCMP1 = Field<22, 1>;    // Timer C Compare 1
            using TC1RST = Field<21, 1>;    // Timer C output 1 Reset
            using TC1SET = Field<20, 1>;    // Timer C output 1 Set
            using TBCMP2 = Field<19, 1>;    // Timer B Compare 2
            using TBCMP1 = Field<18, 1>;    // Timer B Compare 1
            using TB1RST = Field<17, 1>;    // Timer B output 1 Reset
            using TB1SET = Field<16, 1>;    // Timer B output 1 Set
            using TACMP2 = Field<15, 1>;    // Timer A Compare 2
            using TACMP1 = Field<14, 1>;    // Timer A Compare 1
            using TA1RST = Field<13, 1>;    // Timer A output 1 Reset
            using TA1SET = Field<12, 1>;    // Timer A output 1 Set
            using EXEV10CPT = Field<11, 1>;    // External Event 10 Capture
            using EXEV9CPT = Field<10, 1>;    // External Event 9 Capture
            using EXEV8CPT = Field<9, 1>;    // External Event 8 Capture
            using EXEV7CPT = Field<8, 1>;    // External Event 7 Capture
            using EXEV6CPT = Field<7, 1>;    // External Event 6 Capture
            using EXEV5CPT = Field<6, 1>;    // External Event 5 Capture
            using EXEV4CPT = Field<5, 1>;    // External Event 4 Capture
            using EXEV3CPT = Field<4, 1>;    // External Event 3 Capture
            using EXEV2CPT = Field<3, 1>;    // External Event 2 Capture
            using EXEV1CPT = Field<2, 1>;    // External Event 1 Capture
            using UDPCPT = Field<1, 1>;    // Update Capture
            using SWCPT = Field<0, 1>;    // Software Capture
        };

        // Timerx Output Register
        struct OUTER : public Register<0x400176e4> {
            using DIDL2 = Field<23, 1>;    // Output 2 Deadtime upon burst mode Idle entry
            using CHP2 = Field<22, 1>;    // Output 2 Chopper enable
            using FAULT2 = Field<20, 2>;    // Output 2 Fault state
            using IDLES2 = Field<19, 1>;    // Output 2 Idle State
            using IDLEM2 = Field<18, 1>;    // Output 2 Idle mode
            using POL2 = Field<17, 1>;    // Output 2 polarity
            using DLYPRT = Field<10, 3>;    // Delayed Protection
            using DLYPRTEN = Field<9, 1>;    // Delayed Protection Enable
            using DTEN = Field<8, 1>;    // Deadtime enable
            using DIDL1 = Field<7, 1>;    // Output 1 Deadtime upon burst mode Idle entry
            using CHP1 = Field<6, 1>;    // Output 1 Chopper enable
            using FAULT1 = Field<4, 2>;    // Output 1 Fault state
            using IDLES1 = Field<3, 1>;    // Output 1 Idle State
            using IDLEM1 = Field<2, 1>;    // Output 1 Idle mode
            using POL1 = Field<1, 1>;    // Output 1 polarity
        };

        // Timerx Fault Register
        struct FLTER : public Register<0x400176e8> {
            using FLTLCK = Field<31, 1>;    // Fault sources Lock
            using FLT5EN = Field<4, 1>;    // Fault 5 enable
            using FLT4EN = Field<3, 1>;    // Fault 4 enable
            using FLT3EN = Field<2, 1>;    // Fault 3 enable
            using FLT2EN = Field<1, 1>;    // Fault 2 enable
            using FLT1EN = Field<0, 1>;    // Fault 1 enable
        };

    };

    // High Resolution Timer: Common functions
    struct HRTIM_Common {
        // Control Register 1
        struct CR1 : public Register<0x40017780> {
            using AD4USRC = Field<25, 3>;    // ADC Trigger 4 Update Source
            using AD3USRC = Field<22, 3>;    // ADC Trigger 3 Update Source
            using AD2USRC = Field<19, 3>;    // ADC Trigger 2 Update Source
            using AD1USRC = Field<16, 3>;    // ADC Trigger 1 Update Source
            using TEUDIS = Field<5, 1>;    // Timer E Update Disable
            using TDUDIS = Field<4, 1>;    // Timer D Update Disable
            using TCUDIS = Field<3, 1>;    // Timer C Update Disable
            using TBUDIS = Field<2, 1>;    // Timer B Update Disable
            using TAUDIS = Field<1, 1>;    // Timer A Update Disable
            using MUDIS = Field<0, 1>;    // Master Update Disable
        };

        // Control Register 2
        struct CR2 : public Register<0x40017784> {
            using TERST = Field<13, 1>;    // Timer E counter software reset
            using TDRST = Field<12, 1>;    // Timer D counter software reset
            using TCRST = Field<11, 1>;    // Timer C counter software reset
            using TBRST = Field<10, 1>;    // Timer B counter software reset
            using TARST = Field<9, 1>;    // Timer A counter software reset
            using MRST = Field<8, 1>;    // Master Counter software reset
            using TESWU = Field<5, 1>;    // Timer E Software Update
            using TDSWU = Field<4, 1>;    // Timer D Software Update
            using TCSWU = Field<3, 1>;    // Timer C Software Update
            using TBSWU = Field<2, 1>;    // Timer B Software Update
            using TASWU = Field<1, 1>;    // Timer A Software update
            using MSWU = Field<0, 1>;    // Master Timer Software update
        };

        // Interrupt Status Register
        struct ISR : public Register<0x40017788> {
            using BMPER = Field<17, 1>;    // Burst mode Period Interrupt Flag
            using DLLRDY = Field<16, 1>;    // DLL Ready Interrupt Flag
            using SYSFLT = Field<5, 1>;    // System Fault Interrupt Flag
            using FLT5 = Field<4, 1>;    // Fault 5 Interrupt Flag
            using FLT4 = Field<3, 1>;    // Fault 4 Interrupt Flag
            using FLT3 = Field<2, 1>;    // Fault 3 Interrupt Flag
            using FLT2 = Field<1, 1>;    // Fault 2 Interrupt Flag
            using FLT1 = Field<0, 1>;    // Fault 1 Interrupt Flag
        };

        // Interrupt Clear Register
        struct ICR : public Register<0x4001778c> {
            using BMPERC = Field<17, 1>;    // Burst mode period flag Clear
            using DLLRDYC = Field<16, 1>;    // DLL Ready Interrupt flag Clear
            using SYSFLTC = Field<5, 1>;    // System Fault Interrupt Flag Clear
            using FLT5C = Field<4, 1>;    // Fault 5 Interrupt Flag Clear
            using FLT4C = Field<3, 1>;    // Fault 4 Interrupt Flag Clear
            using FLT3C = Field<2, 1>;    // Fault 3 Interrupt Flag Clear
            using FLT2C = Field<1, 1>;    // Fault 2 Interrupt Flag Clear
            using FLT1C = Field<0, 1>;    // Fault 1 Interrupt Flag Clear
        };

        // Interrupt Enable Register
        struct IER : public Register<0x40017790> {
            using BMPERIE = Field<17, 1>;    // Burst mode period Interrupt Enable
            using DLLRDYIE = Field<16, 1>;    // DLL Ready Interrupt Enable
            using SYSFLTE = Field<5, 1>;    // System Fault Interrupt Enable
            using FLT5IE = Field<4, 1>;    // Fault 5 Interrupt Enable
            using FLT4IE = Field<3, 1>;    // Fault 4 Interrupt Enable
            using FLT3IE = Field<2, 1>;    // Fault 3 Interrupt Enable
            using FLT2IE = Field<1, 1>;    // Fault 2 Interrupt Enable
            using FLT1IE = Field<0, 1>;    // Fault 1 Interrupt Enable
        };

        // Output Enable Register
        struct OENR : public Register<0x40017794> {
            using TE2OEN = Field<9, 1>;    // Timer E Output 2 Enable
            using TE1OEN = Field<8, 1>;    // Timer E Output 1 Enable
            using TD2OEN = Field<7, 1>;    // Timer D Output 2 Enable
            using TD1OEN = Field<6, 1>;    // Timer D Output 1 Enable
            using TC2OEN = Field<5, 1>;    // Timer C Output 2 Enable
            using TC1OEN = Field<4, 1>;    // Timer C Output 1 Enable
            using TB2OEN = Field<3, 1>;    // Timer B Output 2 Enable
            using TB1OEN = Field<2, 1>;    // Timer B Output 1 Enable
            using TA2OEN = Field<1, 1>;    // Timer A Output 2 Enable
            using TA1OEN = Field<0, 1>;    // Timer A Output 1 Enable
        };

        // DISR
        struct ODISR : public Register<0x40017798> {
            using TE2ODIS = Field<9, 1>;    // TE2ODIS
            using TE1ODIS = Field<8, 1>;    // TE1ODIS
            using TD2ODIS = Field<7, 1>;    // TD2ODIS
            using TD1ODIS = Field<6, 1>;    // TD1ODIS
            using TC2ODIS = Field<5, 1>;    // TC2ODIS
            using TC1ODIS = Field<4, 1>;    // TC1ODIS
            using TB2ODIS = Field<3, 1>;    // TB2ODIS
            using TB1ODIS = Field<2, 1>;    // TB1ODIS
            using TA2ODIS = Field<1, 1>;    // TA2ODIS
            using TA1ODIS = Field<0, 1>;    // TA1ODIS
        };

        // Output Disable Status Register
        struct ODSR : public Register<0x4001779c> {
            using TE2ODS = Field<9, 1>;    // Timer E Output 2 disable status
            using TE1ODS = Field<8, 1>;    // Timer E Output 1 disable status
            using TD2ODS = Field<7, 1>;    // Timer D Output 2 disable status
            using TD1ODS = Field<6, 1>;    // Timer D Output 1 disable status
            using TC2ODS = Field<5, 1>;    // Timer C Output 2 disable status
            using TC1ODS = Field<4, 1>;    // Timer C Output 1 disable status
            using TB2ODS = Field<3, 1>;    // Timer B Output 2 disable status
            using TB1ODS = Field<2, 1>;    // Timer B Output 1 disable status
            using TA2ODS = Field<1, 1>;    // Timer A Output 2 disable status
            using TA1ODS = Field<0, 1>;    // Timer A Output 1 disable status
        };

        // Burst Mode Control Register
        struct BMCR : public Register<0x400177a0> {
            using BMSTAT = Field<31, 1>;    // Burst Mode Status
            using TEBM = Field<21, 1>;    // Timer E Burst Mode
            using TDBM = Field<20, 1>;    // Timer D Burst Mode
            using TCBM = Field<19, 1>;    // Timer C Burst Mode
            using TBBM = Field<18, 1>;    // Timer B Burst Mode
            using TABM = Field<17, 1>;    // Timer A Burst Mode
            using MTBM = Field<16, 1>;    // Master Timer Burst Mode
            using BMPREN = Field<10, 1>;    // Burst Mode Preload Enable
            using BMPRSC = Field<6, 4>;    // Burst Mode Prescaler
            using BMCLK = Field<2, 4>;    // Burst Mode Clock source
            using BMOM = Field<1, 1>;    // Burst Mode operating mode
            using BME = Field<0, 1>;    // Burst Mode enable
        };

        // BMTRGR
        struct BMTRGR : public Register<0x400177a4> {
            using OCHPEV = Field<31, 1>;    // OCHPEV
            using EEV8 = Field<30, 1>;    // EEV8
            using EEV7 = Field<29, 1>;    // EEV7
            using TDEEV8 = Field<28, 1>;    // TDEEV8
            using TAEEV7 = Field<27, 1>;    // TAEEV7
            using TECMP2 = Field<26, 1>;    // TECMP2
            using TECMP1 = Field<25, 1>;    // TECMP1
            using TEREP = Field<24, 1>;    // TEREP
            using TERST = Field<23, 1>;    // TERST
            using TDCMP2 = Field<22, 1>;    // TDCMP2
            using TDCMP1 = Field<21, 1>;    // TDCMP1
            using TDREP = Field<20, 1>;    // TDREP
            using TDRST = Field<19, 1>;    // TDRST
            using TCCMP2 = Field<18, 1>;    // TCCMP2
            using TCCMP1 = Field<17, 1>;    // TCCMP1
            using TCREP = Field<16, 1>;    // TCREP
            using TCRST = Field<15, 1>;    // TCRST
            using TBCMP2 = Field<14, 1>;    // TBCMP2
            using TBCMP1 = Field<13, 1>;    // TBCMP1
            using TBREP = Field<12, 1>;    // TBREP
            using TBRST = Field<11, 1>;    // TBRST
            using TACMP2 = Field<10, 1>;    // TACMP2
            using TACMP1 = Field<9, 1>;    // TACMP1
            using TAREP = Field<8, 1>;    // TAREP
            using TARST = Field<7, 1>;    // TARST
            using MSTCMP4 = Field<6, 1>;    // MSTCMP4
            using MSTCMP3 = Field<5, 1>;    // MSTCMP3
            using MSTCMP2 = Field<4, 1>;    // MSTCMP2
            using MSTCMP1 = Field<3, 1>;    // MSTCMP1
            using MSTREP = Field<2, 1>;    // MSTREP
            using MSTRST = Field<1, 1>;    // MSTRST
            using SW = Field<0, 1>;    // SW
        };

        // BMCMPR
        struct BMCMPR : public Register<0x400177a8> {
            using BMCMP = Field<0, 16>;    // BMCMP
        };

        // Burst Mode Period Register
        struct BMPER : public Register<0x400177ac> {
            using Field = Field<0, 16>;    // Burst mode Period
        };

        // Timer External Event Control Register 1
        struct EECR1 : public Register<0x400177b0> {
            using EE5FAST = Field<29, 1>;    // External Event 5 Fast mode
            using EE5SNS = Field<27, 2>;    // External Event 5 Sensitivity
            using EE5POL = Field<26, 1>;    // External Event 5 Polarity
            using EE5SRC = Field<24, 2>;    // External Event 5 Source
            using EE4FAST = Field<23, 1>;    // External Event 4 Fast mode
            using EE4SNS = Field<21, 2>;    // External Event 4 Sensitivity
            using EE4POL = Field<20, 1>;    // External Event 4 Polarity
            using EE4SRC = Field<18, 2>;    // External Event 4 Source
            using EE3FAST = Field<17, 1>;    // External Event 3 Fast mode
            using EE3SNS = Field<15, 2>;    // External Event 3 Sensitivity
            using EE3POL = Field<14, 1>;    // External Event 3 Polarity
            using EE3SRC = Field<12, 2>;    // External Event 3 Source
            using EE2FAST = Field<11, 1>;    // External Event 2 Fast mode
            using EE2SNS = Field<9, 2>;    // External Event 2 Sensitivity
            using EE2POL = Field<8, 1>;    // External Event 2 Polarity
            using EE2SRC = Field<6, 2>;    // External Event 2 Source
            using EE1FAST = Field<5, 1>;    // External Event 1 Fast mode
            using EE1SNS = Field<3, 2>;    // External Event 1 Sensitivity
            using EE1POL = Field<2, 1>;    // External Event 1 Polarity
            using EE1SRC = Field<0, 2>;    // External Event 1 Source
        };

        // Timer External Event Control Register 2
        struct EECR2 : public Register<0x400177b4> {
            using EE10SNS = Field<27, 2>;    // External Event 10 Sensitivity
            using EE10POL = Field<26, 1>;    // External Event 10 Polarity
            using EE10SRC = Field<24, 2>;    // External Event 10 Source
            using EE9SNS = Field<21, 2>;    // External Event 9 Sensitivity
            using EE9POL = Field<20, 1>;    // External Event 9 Polarity
            using EE9SRC = Field<18, 2>;    // External Event 9 Source
            using EE8SNS = Field<15, 2>;    // External Event 8 Sensitivity
            using EE8POL = Field<14, 1>;    // External Event 8 Polarity
            using EE8SRC = Field<12, 2>;    // External Event 8 Source
            using EE7SNS = Field<9, 2>;    // External Event 7 Sensitivity
            using EE7POL = Field<8, 1>;    // External Event 7 Polarity
            using EE7SRC = Field<6, 2>;    // External Event 7 Source
            using EE6SNS = Field<3, 2>;    // External Event 6 Sensitivity
            using EE6POL = Field<2, 1>;    // External Event 6 Polarity
            using EE6SRC = Field<0, 2>;    // External Event 6 Source
        };

        // Timer External Event Control Register 3
        struct EECR3 : public Register<0x400177b8> {
            using EEVSD = Field<30, 2>;    // EEVSD
            using EE10F = Field<24, 4>;    // EE10F
            using EE9F = Field<18, 4>;    // EE9F
            using EE8F = Field<12, 4>;    // EE8F
            using EE7F = Field<6, 4>;    // EE7F
            using EE6F = Field<0, 4>;    // EE6F
        };

        // ADC Trigger 1 Register
        struct ADC1R : public Register<0x400177bc> {
            using AD1TEPER = Field<31, 1>;    // ADC trigger 1 on Timer E Period
            using AD1TEC4 = Field<30, 1>;    // ADC trigger 1 on Timer E compare 4
            using AD1TEC3 = Field<29, 1>;    // ADC trigger 1 on Timer E compare 3
            using AD1TEC2 = Field<28, 1>;    // ADC trigger 1 on Timer E compare 2
            using AD1TDPER = Field<27, 1>;    // ADC trigger 1 on Timer D Period
            using AD1TDC4 = Field<26, 1>;    // ADC trigger 1 on Timer D compare 4
            using AD1TDC3 = Field<25, 1>;    // ADC trigger 1 on Timer D compare 3
            using AD1TDC2 = Field<24, 1>;    // ADC trigger 1 on Timer D compare 2
            using AD1TCPER = Field<23, 1>;    // ADC trigger 1 on Timer C Period
            using AD1TCC4 = Field<22, 1>;    // ADC trigger 1 on Timer C compare 4
            using AD1TCC3 = Field<21, 1>;    // ADC trigger 1 on Timer C compare 3
            using AD1TCC2 = Field<20, 1>;    // ADC trigger 1 on Timer C compare 2
            using AD1TBRST = Field<19, 1>;    // ADC trigger 1 on Timer B Reset
            using AD1TBPER = Field<18, 1>;    // ADC trigger 1 on Timer B Period
            using AD1TBC4 = Field<17, 1>;    // ADC trigger 1 on Timer B compare 4
            using AD1TBC3 = Field<16, 1>;    // ADC trigger 1 on Timer B compare 3
            using AD1TBC2 = Field<15, 1>;    // ADC trigger 1 on Timer B compare 2
            using AD1TARST = Field<14, 1>;    // ADC trigger 1 on Timer A Reset
            using AD1TAPER = Field<13, 1>;    // ADC trigger 1 on Timer A Period
            using AD1TAC4 = Field<12, 1>;    // ADC trigger 1 on Timer A compare 4
            using AD1TAC3 = Field<11, 1>;    // ADC trigger 1 on Timer A compare 3
            using AD1TAC2 = Field<10, 1>;    // ADC trigger 1 on Timer A compare 2
            using AD1EEV5 = Field<9, 1>;    // ADC trigger 1 on External Event 5
            using AD1EEV4 = Field<8, 1>;    // ADC trigger 1 on External Event 4
            using AD1EEV3 = Field<7, 1>;    // ADC trigger 1 on External Event 3
            using AD1EEV2 = Field<6, 1>;    // ADC trigger 1 on External Event 2
            using AD1EEV1 = Field<5, 1>;    // ADC trigger 1 on External Event 1
            using AD1MPER = Field<4, 1>;    // ADC trigger 1 on Master Period
            using AD1MC4 = Field<3, 1>;    // ADC trigger 1 on Master Compare 4
            using AD1MC3 = Field<2, 1>;    // ADC trigger 1 on Master Compare 3
            using AD1MC2 = Field<1, 1>;    // ADC trigger 1 on Master Compare 2
            using AD1MC1 = Field<0, 1>;    // ADC trigger 1 on Master Compare 1
        };

        // ADC Trigger 2 Register
        struct ADC2R : public Register<0x400177c0> {
            using AD2TERST = Field<31, 1>;    // ADC trigger 2 on Timer E Reset
            using AD2TEC4 = Field<30, 1>;    // ADC trigger 2 on Timer E compare 4
            using AD2TEC3 = Field<29, 1>;    // ADC trigger 2 on Timer E compare 3
            using AD2TEC2 = Field<28, 1>;    // ADC trigger 2 on Timer E compare 2
            using AD2TDRST = Field<27, 1>;    // ADC trigger 2 on Timer D Reset
            using AD2TDPER = Field<26, 1>;    // ADC trigger 2 on Timer D Period
            using AD2TDC4 = Field<25, 1>;    // ADC trigger 2 on Timer D compare 4
            using AD2TDC3 = Field<24, 1>;    // ADC trigger 2 on Timer D compare 3
            using AD2TDC2 = Field<23, 1>;    // ADC trigger 2 on Timer D compare 2
            using AD2TCRST = Field<22, 1>;    // ADC trigger 2 on Timer C Reset
            using AD2TCPER = Field<21, 1>;    // ADC trigger 2 on Timer C Period
            using AD2TCC4 = Field<20, 1>;    // ADC trigger 2 on Timer C compare 4
            using AD2TCC3 = Field<19, 1>;    // ADC trigger 2 on Timer C compare 3
            using AD2TCC2 = Field<18, 1>;    // ADC trigger 2 on Timer C compare 2
            using AD2TBPER = Field<17, 1>;    // ADC trigger 2 on Timer B Period
            using AD2TBC4 = Field<16, 1>;    // ADC trigger 2 on Timer B compare 4
            using AD2TBC3 = Field<15, 1>;    // ADC trigger 2 on Timer B compare 3
            using AD2TBC2 = Field<14, 1>;    // ADC trigger 2 on Timer B compare 2
            using AD2TAPER = Field<13, 1>;    // ADC trigger 2 on Timer A Period
            using AD2TAC4 = Field<12, 1>;    // ADC trigger 2 on Timer A compare 4
            using AD2TAC3 = Field<11, 1>;    // ADC trigger 2 on Timer A compare 3
            using AD2TAC2 = Field<10, 1>;    // ADC trigger 2 on Timer A compare 2
            using AD2EEV10 = Field<9, 1>;    // ADC trigger 2 on External Event 10
            using AD2EEV9 = Field<8, 1>;    // ADC trigger 2 on External Event 9
            using AD2EEV8 = Field<7, 1>;    // ADC trigger 2 on External Event 8
            using AD2EEV7 = Field<6, 1>;    // ADC trigger 2 on External Event 7
            using AD2EEV6 = Field<5, 1>;    // ADC trigger 2 on External Event 6
            using AD2MPER = Field<4, 1>;    // ADC trigger 2 on Master Period
            using AD2MC4 = Field<3, 1>;    // ADC trigger 2 on Master Compare 4
            using AD2MC3 = Field<2, 1>;    // ADC trigger 2 on Master Compare 3
            using AD2MC2 = Field<1, 1>;    // ADC trigger 2 on Master Compare 2
            using AD2MC1 = Field<0, 1>;    // ADC trigger 2 on Master Compare 1
        };

        // ADC Trigger 3 Register
        struct ADC3R : public Register<0x400177c4> {
            using AD1TEPER = Field<31, 1>;    // AD1TEPER
            using AD1TEC4 = Field<30, 1>;    // AD1TEC4
            using AD1TEC3 = Field<29, 1>;    // AD1TEC3
            using AD1TEC2 = Field<28, 1>;    // AD1TEC2
            using AD1TDPER = Field<27, 1>;    // AD1TDPER
            using AD1TDC4 = Field<26, 1>;    // AD1TDC4
            using AD1TDC3 = Field<25, 1>;    // AD1TDC3
            using AD1TDC2 = Field<24, 1>;    // AD1TDC2
            using AD1TCPER = Field<23, 1>;    // AD1TCPER
            using AD1TCC4 = Field<22, 1>;    // AD1TCC4
            using AD1TCC3 = Field<21, 1>;    // AD1TCC3
            using AD1TCC2 = Field<20, 1>;    // AD1TCC2
            using AD1TBRST = Field<19, 1>;    // AD1TBRST
            using AD1TBPER = Field<18, 1>;    // AD1TBPER
            using AD1TBC4 = Field<17, 1>;    // AD1TBC4
            using AD1TBC3 = Field<16, 1>;    // AD1TBC3
            using AD1TBC2 = Field<15, 1>;    // AD1TBC2
            using AD1TARST = Field<14, 1>;    // AD1TARST
            using AD1TAPER = Field<13, 1>;    // AD1TAPER
            using AD1TAC4 = Field<12, 1>;    // AD1TAC4
            using AD1TAC3 = Field<11, 1>;    // AD1TAC3
            using AD1TAC2 = Field<10, 1>;    // AD1TAC2
            using AD1EEV5 = Field<9, 1>;    // AD1EEV5
            using AD1EEV4 = Field<8, 1>;    // AD1EEV4
            using AD1EEV3 = Field<7, 1>;    // AD1EEV3
            using AD1EEV2 = Field<6, 1>;    // AD1EEV2
            using AD1EEV1 = Field<5, 1>;    // AD1EEV1
            using AD1MPER = Field<4, 1>;    // AD1MPER
            using AD1MC4 = Field<3, 1>;    // AD1MC4
            using AD1MC3 = Field<2, 1>;    // AD1MC3
            using AD1MC2 = Field<1, 1>;    // AD1MC2
            using AD1MC1 = Field<0, 1>;    // AD1MC1
        };

        // ADC Trigger 4 Register
        struct ADC4R : public Register<0x400177c8> {
            using AD2TERST = Field<31, 1>;    // AD2TERST
            using AD2TEC4 = Field<30, 1>;    // AD2TEC4
            using AD2TEC3 = Field<29, 1>;    // AD2TEC3
            using AD2TEC2 = Field<28, 1>;    // AD2TEC2
            using AD2TDRST = Field<27, 1>;    // AD2TDRST
            using AD2TDPER = Field<26, 1>;    // AD2TDPER
            using AD2TDC4 = Field<25, 1>;    // AD2TDC4
            using AD2TDC3 = Field<24, 1>;    // AD2TDC3
            using AD2TDC2 = Field<23, 1>;    // AD2TDC2
            using AD2TCRST = Field<22, 1>;    // AD2TCRST
            using AD2TCPER = Field<21, 1>;    // AD2TCPER
            using AD2TCC4 = Field<20, 1>;    // AD2TCC4
            using AD2TCC3 = Field<19, 1>;    // AD2TCC3
            using AD2TCC2 = Field<18, 1>;    // AD2TCC2
            using AD2TBPER = Field<17, 1>;    // AD2TBPER
            using AD2TBC4 = Field<16, 1>;    // AD2TBC4
            using AD2TBC3 = Field<15, 1>;    // AD2TBC3
            using AD2TBC2 = Field<14, 1>;    // AD2TBC2
            using AD2TAPER = Field<13, 1>;    // AD2TAPER
            using AD2TAC4 = Field<12, 1>;    // AD2TAC4
            using AD2TAC3 = Field<11, 1>;    // AD2TAC3
            using AD2TAC2 = Field<10, 1>;    // AD2TAC2
            using AD2EEV10 = Field<9, 1>;    // AD2EEV10
            using AD2EEV9 = Field<8, 1>;    // AD2EEV9
            using AD2EEV8 = Field<7, 1>;    // AD2EEV8
            using AD2EEV7 = Field<6, 1>;    // AD2EEV7
            using AD2EEV6 = Field<5, 1>;    // AD2EEV6
            using AD2MPER = Field<4, 1>;    // AD2MPER
            using AD2MC4 = Field<3, 1>;    // AD2MC4
            using AD2MC3 = Field<2, 1>;    // AD2MC3
            using AD2MC2 = Field<1, 1>;    // AD2MC2
            using AD2MC1 = Field<0, 1>;    // AD2MC1
        };

        // DLL Control Register
        struct DLLCR : public Register<0x400177cc> {
            using CALRTE = Field<2, 2>;    // DLL Calibration rate
            using CALEN = Field<1, 1>;    // DLL Calibration Enable
            using CAL = Field<0, 1>;    // DLL Calibration Start
        };

        // HRTIM Fault Input Register 1
        struct FLTINR1 : public Register<0x400177d0> {
            using FLT4LCK = Field<31, 1>;    // FLT4LCK
            using FLT4F = Field<27, 4>;    // FLT4F
            using FLT4SRC = Field<26, 1>;    // FLT4SRC
            using FLT4P = Field<25, 1>;    // FLT4P
            using FLT4E = Field<24, 1>;    // FLT4E
            using FLT3LCK = Field<23, 1>;    // FLT3LCK
            using FLT3F = Field<19, 4>;    // FLT3F
            using FLT3SRC = Field<18, 1>;    // FLT3SRC
            using FLT3P = Field<17, 1>;    // FLT3P
            using FLT3E = Field<16, 1>;    // FLT3E
            using FLT2LCK = Field<15, 1>;    // FLT2LCK
            using FLT2F = Field<11, 4>;    // FLT2F
            using FLT2SRC = Field<10, 1>;    // FLT2SRC
            using FLT2P = Field<9, 1>;    // FLT2P
            using FLT2E = Field<8, 1>;    // FLT2E
            using FLT1LCK = Field<7, 1>;    // FLT1LCK
            using FLT1F = Field<3, 4>;    // FLT1F
            using FLT1SRC = Field<2, 1>;    // FLT1SRC
            using FLT1P = Field<1, 1>;    // FLT1P
            using FLT1E = Field<0, 1>;    // FLT1E
        };

        // HRTIM Fault Input Register 2
        struct FLTINR2 : public Register<0x400177d4> {
            using FLTSD = Field<24, 2>;    // FLTSD
            using FLT5LCK = Field<7, 1>;    // FLT5LCK
            using FLT5F = Field<3, 4>;    // FLT5F
            using FLT5SRC = Field<2, 1>;    // FLT5SRC
            using FLT5P = Field<1, 1>;    // FLT5P
            using FLT5E = Field<0, 1>;    // FLT5E
        };

        // BDMUPDR
        struct BDMUPDR : public Register<0x400177d8> {
            using MCMP4 = Field<9, 1>;    // MCMP4
            using MCMP3 = Field<8, 1>;    // MCMP3
            using MCMP2 = Field<7, 1>;    // MCMP2
            using MCMP1 = Field<6, 1>;    // MCMP1
            using MREP = Field<5, 1>;    // MREP
            using MPER = Field<4, 1>;    // MPER
            using MCNT = Field<3, 1>;    // MCNT
            using MDIER = Field<2, 1>;    // MDIER
            using MICR = Field<1, 1>;    // MICR
            using MCR = Field<0, 1>;    // MCR
        };

        // Burst DMA Timerx update Register
        struct BDTAUPR : public Register<0x400177dc> {
            using TIMxFLTR = Field<20, 1>;    // HRTIM_FLTxR register update enable
            using TIMxOUTR = Field<19, 1>;    // HRTIM_OUTxR register update enable
            using TIMxCHPR = Field<18, 1>;    // HRTIM_CHPxR register update enable
            using TIMxRSTR = Field<17, 1>;    // HRTIM_RSTxR register update enable
            using TIMxEEFR2 = Field<16, 1>;    // HRTIM_EEFxR2 register update enable
            using TIMxEEFR1 = Field<15, 1>;    // HRTIM_EEFxR1 register update enable
            using TIMxRST2R = Field<14, 1>;    // HRTIM_RST2xR register update enable
            using TIMxSET2R = Field<13, 1>;    // HRTIM_SET2xR register update enable
            using TIMxRST1R = Field<12, 1>;    // HRTIM_RST1xR register update enable
            using TIMxSET1R = Field<11, 1>;    // HRTIM_SET1xR register update enable
            using TIMx_DTxR = Field<10, 1>;    // HRTIM_DTxR register update enable
            using TIMxCMP4 = Field<9, 1>;    // HRTIM_CMP4xR register update enable
            using TIMxCMP3 = Field<8, 1>;    // HRTIM_CMP3xR register update enable
            using TIMxCMP2 = Field<7, 1>;    // HRTIM_CMP2xR register update enable
            using TIMxCMP1 = Field<6, 1>;    // HRTIM_CMP1xR register update enable
            using TIMxREP = Field<5, 1>;    // HRTIM_REPxR register update enable
            using TIMxPER = Field<4, 1>;    // HRTIM_PERxR register update enable
            using TIMxCNT = Field<3, 1>;    // HRTIM_CNTxR register update enable
            using TIMxDIER = Field<2, 1>;    // HRTIM_TIMxDIER register update enable
            using TIMxICR = Field<1, 1>;    // HRTIM_TIMxICR register update enable
            using TIMxCR = Field<0, 1>;    // HRTIM_TIMxCR register update enable
        };

        // Burst DMA Timerx update Register
        struct BDTBUPR : public Register<0x400177e0> {
            using TIMxFLTR = Field<20, 1>;    // HRTIM_FLTxR register update enable
            using TIMxOUTR = Field<19, 1>;    // HRTIM_OUTxR register update enable
            using TIMxCHPR = Field<18, 1>;    // HRTIM_CHPxR register update enable
            using TIMxRSTR = Field<17, 1>;    // HRTIM_RSTxR register update enable
            using TIMxEEFR2 = Field<16, 1>;    // HRTIM_EEFxR2 register update enable
            using TIMxEEFR1 = Field<15, 1>;    // HRTIM_EEFxR1 register update enable
            using TIMxRST2R = Field<14, 1>;    // HRTIM_RST2xR register update enable
            using TIMxSET2R = Field<13, 1>;    // HRTIM_SET2xR register update enable
            using TIMxRST1R = Field<12, 1>;    // HRTIM_RST1xR register update enable
            using TIMxSET1R = Field<11, 1>;    // HRTIM_SET1xR register update enable
            using TIMx_DTxR = Field<10, 1>;    // HRTIM_DTxR register update enable
            using TIMxCMP4 = Field<9, 1>;    // HRTIM_CMP4xR register update enable
            using TIMxCMP3 = Field<8, 1>;    // HRTIM_CMP3xR register update enable
            using TIMxCMP2 = Field<7, 1>;    // HRTIM_CMP2xR register update enable
            using TIMxCMP1 = Field<6, 1>;    // HRTIM_CMP1xR register update enable
            using TIMxREP = Field<5, 1>;    // HRTIM_REPxR register update enable
            using TIMxPER = Field<4, 1>;    // HRTIM_PERxR register update enable
            using TIMxCNT = Field<3, 1>;    // HRTIM_CNTxR register update enable
            using TIMxDIER = Field<2, 1>;    // HRTIM_TIMxDIER register update enable
            using TIMxICR = Field<1, 1>;    // HRTIM_TIMxICR register update enable
            using TIMxCR = Field<0, 1>;    // HRTIM_TIMxCR register update enable
        };

        // Burst DMA Timerx update Register
        struct BDTCUPR : public Register<0x400177e4> {
            using TIMxFLTR = Field<20, 1>;    // HRTIM_FLTxR register update enable
            using TIMxOUTR = Field<19, 1>;    // HRTIM_OUTxR register update enable
            using TIMxCHPR = Field<18, 1>;    // HRTIM_CHPxR register update enable
            using TIMxRSTR = Field<17, 1>;    // HRTIM_RSTxR register update enable
            using TIMxEEFR2 = Field<16, 1>;    // HRTIM_EEFxR2 register update enable
            using TIMxEEFR1 = Field<15, 1>;    // HRTIM_EEFxR1 register update enable
            using TIMxRST2R = Field<14, 1>;    // HRTIM_RST2xR register update enable
            using TIMxSET2R = Field<13, 1>;    // HRTIM_SET2xR register update enable
            using TIMxRST1R = Field<12, 1>;    // HRTIM_RST1xR register update enable
            using TIMxSET1R = Field<11, 1>;    // HRTIM_SET1xR register update enable
            using TIMx_DTxR = Field<10, 1>;    // HRTIM_DTxR register update enable
            using TIMxCMP4 = Field<9, 1>;    // HRTIM_CMP4xR register update enable
            using TIMxCMP3 = Field<8, 1>;    // HRTIM_CMP3xR register update enable
            using TIMxCMP2 = Field<7, 1>;    // HRTIM_CMP2xR register update enable
            using TIMxCMP1 = Field<6, 1>;    // HRTIM_CMP1xR register update enable
            using TIMxREP = Field<5, 1>;    // HRTIM_REPxR register update enable
            using TIMxPER = Field<4, 1>;    // HRTIM_PERxR register update enable
            using TIMxCNT = Field<3, 1>;    // HRTIM_CNTxR register update enable
            using TIMxDIER = Field<2, 1>;    // HRTIM_TIMxDIER register update enable
            using TIMxICR = Field<1, 1>;    // HRTIM_TIMxICR register update enable
            using TIMxCR = Field<0, 1>;    // HRTIM_TIMxCR register update enable
        };

        // Burst DMA Timerx update Register
        struct BDTDUPR : public Register<0x400177e8> {
            using TIMxFLTR = Field<20, 1>;    // HRTIM_FLTxR register update enable
            using TIMxOUTR = Field<19, 1>;    // HRTIM_OUTxR register update enable
            using TIMxCHPR = Field<18, 1>;    // HRTIM_CHPxR register update enable
            using TIMxRSTR = Field<17, 1>;    // HRTIM_RSTxR register update enable
            using TIMxEEFR2 = Field<16, 1>;    // HRTIM_EEFxR2 register update enable
            using TIMxEEFR1 = Field<15, 1>;    // HRTIM_EEFxR1 register update enable
            using TIMxRST2R = Field<14, 1>;    // HRTIM_RST2xR register update enable
            using TIMxSET2R = Field<13, 1>;    // HRTIM_SET2xR register update enable
            using TIMxRST1R = Field<12, 1>;    // HRTIM_RST1xR register update enable
            using TIMxSET1R = Field<11, 1>;    // HRTIM_SET1xR register update enable
            using TIMx_DTxR = Field<10, 1>;    // HRTIM_DTxR register update enable
            using TIMxCMP4 = Field<9, 1>;    // HRTIM_CMP4xR register update enable
            using TIMxCMP3 = Field<8, 1>;    // HRTIM_CMP3xR register update enable
            using TIMxCMP2 = Field<7, 1>;    // HRTIM_CMP2xR register update enable
            using TIMxCMP1 = Field<6, 1>;    // HRTIM_CMP1xR register update enable
            using TIMxREP = Field<5, 1>;    // HRTIM_REPxR register update enable
            using TIMxPER = Field<4, 1>;    // HRTIM_PERxR register update enable
            using TIMxCNT = Field<3, 1>;    // HRTIM_CNTxR register update enable
            using TIMxDIER = Field<2, 1>;    // HRTIM_TIMxDIER register update enable
            using TIMxICR = Field<1, 1>;    // HRTIM_TIMxICR register update enable
            using TIMxCR = Field<0, 1>;    // HRTIM_TIMxCR register update enable
        };

        // Burst DMA Timerx update Register
        struct BDTEUPR : public Register<0x400177ec> {
            using TIMxFLTR = Field<20, 1>;    // HRTIM_FLTxR register update enable
            using TIMxOUTR = Field<19, 1>;    // HRTIM_OUTxR register update enable
            using TIMxCHPR = Field<18, 1>;    // HRTIM_CHPxR register update enable
            using TIMxRSTR = Field<17, 1>;    // HRTIM_RSTxR register update enable
            using TIMxEEFR2 = Field<16, 1>;    // HRTIM_EEFxR2 register update enable
            using TIMxEEFR1 = Field<15, 1>;    // HRTIM_EEFxR1 register update enable
            using TIMxRST2R = Field<14, 1>;    // HRTIM_RST2xR register update enable
            using TIMxSET2R = Field<13, 1>;    // HRTIM_SET2xR register update enable
            using TIMxRST1R = Field<12, 1>;    // HRTIM_RST1xR register update enable
            using TIMxSET1R = Field<11, 1>;    // HRTIM_SET1xR register update enable
            using TIMx_DTxR = Field<10, 1>;    // HRTIM_DTxR register update enable
            using TIMxCMP4 = Field<9, 1>;    // HRTIM_CMP4xR register update enable
            using TIMxCMP3 = Field<8, 1>;    // HRTIM_CMP3xR register update enable
            using TIMxCMP2 = Field<7, 1>;    // HRTIM_CMP2xR register update enable
            using TIMxCMP1 = Field<6, 1>;    // HRTIM_CMP1xR register update enable
            using TIMxREP = Field<5, 1>;    // HRTIM_REPxR register update enable
            using TIMxPER = Field<4, 1>;    // HRTIM_PERxR register update enable
            using TIMxCNT = Field<3, 1>;    // HRTIM_CNTxR register update enable
            using TIMxDIER = Field<2, 1>;    // HRTIM_TIMxDIER register update enable
            using TIMxICR = Field<1, 1>;    // HRTIM_TIMxICR register update enable
            using TIMxCR = Field<0, 1>;    // HRTIM_TIMxCR register update enable
        };

        // Burst DMA Data Register
        struct BDMADR : public Register<0x400177f0> {
            using Field = Field<0, 32>;    // Burst DMA Data register
        };

    };

    // Nested Vectored Interrupt Controller
    struct NVIC {
        // Interrupt Set-Enable Register
        struct ISER0 : public Register<0xe000e100> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Set-Enable Register
        struct ISER1 : public Register<0xe000e104> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Set-Enable Register
        struct ISER2 : public Register<0xe000e108> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Clear-Enable Register
        struct ICER0 : public Register<0xe000e180> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Clear-Enable Register
        struct ICER1 : public Register<0xe000e184> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Clear-Enable Register
        struct ICER2 : public Register<0xe000e188> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Set-Pending Register
        struct ISPR0 : public Register<0xe000e200> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Set-Pending Register
        struct ISPR1 : public Register<0xe000e204> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Set-Pending Register
        struct ISPR2 : public Register<0xe000e208> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR0 : public Register<0xe000e280> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR1 : public Register<0xe000e284> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR2 : public Register<0xe000e288> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Active Bit Register
        struct IABR0 : public Register<0xe000e300> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Active Bit Register
        struct IABR1 : public Register<0xe000e304> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Active Bit Register
        struct IABR2 : public Register<0xe000e308> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Priority Register
        struct IPR0 : public Register<0xe000e400> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR1 : public Register<0xe000e404> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR2 : public Register<0xe000e408> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR3 : public Register<0xe000e40c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR4 : public Register<0xe000e410> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR5 : public Register<0xe000e414> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR6 : public Register<0xe000e418> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR7 : public Register<0xe000e41c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR8 : public Register<0xe000e420> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR9 : public Register<0xe000e424> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR10 : public Register<0xe000e428> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR11 : public Register<0xe000e42c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR12 : public Register<0xe000e430> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR13 : public Register<0xe000e434> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR14 : public Register<0xe000e438> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR15 : public Register<0xe000e43c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR16 : public Register<0xe000e440> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR17 : public Register<0xe000e444> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR18 : public Register<0xe000e448> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR19 : public Register<0xe000e44c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR20 : public Register<0xe000e450> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

    };

    // Floting point unit
    struct FPU {
        // Floating-point context control register
        struct FPCCR : public Register<0xe000ef34> {
            using LSPACT = Field<0, 1>;    // LSPACT
            using USER = Field<1, 1>;    // USER
            using THREAD = Field<3, 1>;    // THREAD
            using HFRDY = Field<4, 1>;    // HFRDY
            using MMRDY = Field<5, 1>;    // MMRDY
            using BFRDY = Field<6, 1>;    // BFRDY
            using MONRDY = Field<8, 1>;    // MONRDY
            using LSPEN = Field<30, 1>;    // LSPEN
            using ASPEN = Field<31, 1>;    // ASPEN
        };

        // Floating-point context address register
        struct FPCAR : public Register<0xe000ef38> {
            using ADDRESS = Field<3, 29>;    // Location of unpopulated floating-point
        };

        // Floating-point status control register
        struct FPSCR : public Register<0xe000ef3c> {
            using IOC = Field<0, 1>;    // Invalid operation cumulative exception bit
            using DZC = Field<1, 1>;    // Division by zero cumulative exception bit.
            using OFC = Field<2, 1>;    // Overflow cumulative exception bit
            using UFC = Field<3, 1>;    // Underflow cumulative exception bit
            using IXC = Field<4, 1>;    // Inexact cumulative exception bit
            using IDC = Field<7, 1>;    // Input denormal cumulative exception bit.
            using RMode = Field<22, 2>;    // Rounding Mode control field
            using FZ = Field<24, 1>;    // Flush-to-zero mode control bit:
            using DN = Field<25, 1>;    // Default NaN mode control bit
            using AHP = Field<26, 1>;    // Alternative half-precision control bit
            using V = Field<28, 1>;    // Overflow condition code flag
            using C = Field<29, 1>;    // Carry condition code flag
            using Z = Field<30, 1>;    // Zero condition code flag
            using N = Field<31, 1>;    // Negative condition code flag
        };

    };

    // Memory protection unit
    struct MPU {
        // MPU type register
        struct MPU_TYPER : public Register<0xe000ed90> {
            using SEPARATE = Field<0, 1>;    // Separate flag
            using DREGION = Field<8, 8>;    // Number of MPU data regions
            using IREGION = Field<16, 8>;    // Number of MPU instruction regions
        };

        // MPU control register
        struct MPU_CTRL : public Register<0xe000ed94> {
            using ENABLE = Field<0, 1>;    // Enables the MPU
            using HFNMIENA = Field<1, 1>;    // Enables the operation of MPU during hard fault
            using PRIVDEFENA = Field<2, 1>;    // Enable priviliged software access to default memory map
        };

        // MPU region number register
        struct MPU_RNR : public Register<0xe000ed98> {
            using REGION = Field<0, 8>;    // MPU region
        };

        // MPU region base address register
        struct MPU_RBAR : public Register<0xe000ed9c> {
            using REGION = Field<0, 4>;    // MPU region field
            using VALID = Field<4, 1>;    // MPU region number valid
            using ADDR = Field<5, 27>;    // Region base address field
        };

        // MPU region attribute and size register
        struct MPU_RASR : public Register<0xe000eda0> {
            using ENABLE = Field<0, 1>;    // Region enable bit.
            using SIZE = Field<1, 5>;    // Size of the MPU protection region
            using SRD = Field<8, 8>;    // Subregion disable bits
            using B = Field<16, 1>;    // memory attribute
            using C = Field<17, 1>;    // memory attribute
            using S = Field<18, 1>;    // Shareable memory attribute
            using TEX = Field<19, 3>;    // memory attribute
            using AP = Field<24, 3>;    // Access permission
            using XN = Field<28, 1>;    // Instruction access disable bit
        };

    };

    // SysTick timer
    struct STK {
        // SysTick control and status register
        struct CTRL : public Register<0xe000e010> {
            using ENABLE = Field<0, 1>;    // Counter enable
            using TICKINT = Field<1, 1>;    // SysTick exception request enable
            using CLKSOURCE = Field<2, 1>;    // Clock source selection
            using COUNTFLAG = Field<16, 1>;    // COUNTFLAG
        };

        // SysTick reload value register
        struct LOAD : public Register<0xe000e014> {
            using RELOAD = Field<0, 24>;    // RELOAD value
        };

        // SysTick current value register
        struct VAL : public Register<0xe000e018> {
            using CURRENT = Field<0, 24>;    // Current counter value
        };

        // SysTick calibration value register
        struct CALIB : public Register<0xe000e01c> {
            using TENMS = Field<0, 24>;    // Calibration value
            using SKEW = Field<30, 1>;    // SKEW flag: Indicates whether the TENMS value is exact
            using NOREF = Field<31, 1>;    // NOREF flag. Reads as zero
        };

    };

    // System control block
    struct SCB {
        // CPUID base register
        struct CPUID : public Register<0xe000ed00> {
            using Revision = Field<0, 4>;    // Revision number
            using PartNo = Field<4, 12>;    // Part number of the processor
            using Constant = Field<16, 4>;    // Reads as 0xF
            using Variant = Field<20, 4>;    // Variant number
            using Implementer = Field<24, 8>;    // Implementer code
        };

        // Interrupt control and state register
        struct ICSR : public Register<0xe000ed04> {
            using VECTACTIVE = Field<0, 9>;    // Active vector
            using RETTOBASE = Field<11, 1>;    // Return to base level
            using VECTPENDING = Field<12, 7>;    // Pending vector
            using ISRPENDING = Field<22, 1>;    // Interrupt pending flag
            using PENDSTCLR = Field<25, 1>;    // SysTick exception clear-pending bit
            using PENDSTSET = Field<26, 1>;    // SysTick exception set-pending bit
            using PENDSVCLR = Field<27, 1>;    // PendSV clear-pending bit
            using PENDSVSET = Field<28, 1>;    // PendSV set-pending bit
            using NMIPENDSET = Field<31, 1>;    // NMI set-pending bit.
        };

        // Vector table offset register
        struct VTOR : public Register<0xe000ed08> {
            using TBLOFF = Field<9, 21>;    // Vector table base offset field
        };

        // Application interrupt and reset control register
        struct AIRCR : public Register<0xe000ed0c> {
            using VECTRESET = Field<0, 1>;    // VECTRESET
            using VECTCLRACTIVE = Field<1, 1>;    // VECTCLRACTIVE
            using SYSRESETREQ = Field<2, 1>;    // SYSRESETREQ
            using PRIGROUP = Field<8, 3>;    // PRIGROUP
            using ENDIANESS = Field<15, 1>;    // ENDIANESS
            using VECTKEYSTAT = Field<16, 16>;    // Register key
        };

        // System control register
        struct SCR : public Register<0xe000ed10> {
            using SLEEPONEXIT = Field<1, 1>;    // SLEEPONEXIT
            using SLEEPDEEP = Field<2, 1>;    // SLEEPDEEP
            using SEVEONPEND = Field<4, 1>;    // Send Event on Pending bit
        };

        // Configuration and control register
        struct CCR : public Register<0xe000ed14> {
            using NONBASETHRDENA = Field<0, 1>;    // Configures how the processor enters Thread mode
            using USERSETMPEND = Field<1, 1>;    // USERSETMPEND
            using UNALIGN__TRP = Field<3, 1>;    // UNALIGN_ TRP
            using DIV_0_TRP = Field<4, 1>;    // DIV_0_TRP
            using BFHFNMIGN = Field<8, 1>;    // BFHFNMIGN
            using STKALIGN = Field<9, 1>;    // STKALIGN
        };

        // System handler priority registers
        struct SHPR1 : public Register<0xe000ed18> {
            using PRI_4 = Field<0, 8>;    // Priority of system handler 4
            using PRI_5 = Field<8, 8>;    // Priority of system handler 5
            using PRI_6 = Field<16, 8>;    // Priority of system handler 6
        };

        // System handler priority registers
        struct SHPR2 : public Register<0xe000ed1c> {
            using PRI_11 = Field<24, 8>;    // Priority of system handler 11
        };

        // System handler priority registers
        struct SHPR3 : public Register<0xe000ed20> {
            using PRI_14 = Field<16, 8>;    // Priority of system handler 14
            using PRI_15 = Field<24, 8>;    // Priority of system handler 15
        };

        // System handler control and state register
        struct SHCRS : public Register<0xe000ed24> {
            using MEMFAULTACT = Field<0, 1>;    // Memory management fault exception active bit
            using BUSFAULTACT = Field<1, 1>;    // Bus fault exception active bit
            using USGFAULTACT = Field<3, 1>;    // Usage fault exception active bit
            using SVCALLACT = Field<7, 1>;    // SVC call active bit
            using MONITORACT = Field<8, 1>;    // Debug monitor active bit
            using PENDSVACT = Field<10, 1>;    // PendSV exception active bit
            using SYSTICKACT = Field<11, 1>;    // SysTick exception active bit
            using USGFAULTPENDED = Field<12, 1>;    // Usage fault exception pending bit
            using MEMFAULTPENDED = Field<13, 1>;    // Memory management fault exception pending bit
            using BUSFAULTPENDED = Field<14, 1>;    // Bus fault exception pending bit
            using SVCALLPENDED = Field<15, 1>;    // SVC call pending bit
            using MEMFAULTENA = Field<16, 1>;    // Memory management fault enable bit
            using BUSFAULTENA = Field<17, 1>;    // Bus fault enable bit
            using USGFAULTENA = Field<18, 1>;    // Usage fault enable bit
        };

        // Configurable fault status register
        struct CFSR_UFSR_BFSR_MMFSR : public Register<0xe000ed28> {
            using IACCVIOL = Field<1, 1>;    // Instruction access violation flag
            using MUNSTKERR = Field<3, 1>;    // Memory manager fault on unstacking for a return from exception
            using MSTKERR = Field<4, 1>;    // Memory manager fault on stacking for exception entry.
            using MLSPERR = Field<5, 1>;    // MLSPERR
            using MMARVALID = Field<7, 1>;    // Memory Management Fault Address Register (MMAR) valid flag
            using IBUSERR = Field<8, 1>;    // Instruction bus error
            using PRECISERR = Field<9, 1>;    // Precise data bus error
            using IMPRECISERR = Field<10, 1>;    // Imprecise data bus error
            using UNSTKERR = Field<11, 1>;    // Bus fault on unstacking for a return from exception
            using STKERR = Field<12, 1>;    // Bus fault on stacking for exception entry
            using LSPERR = Field<13, 1>;    // Bus fault on floating-point lazy state preservation
            using BFARVALID = Field<15, 1>;    // Bus Fault Address Register (BFAR) valid flag
            using UNDEFINSTR = Field<16, 1>;    // Undefined instruction usage fault
            using INVSTATE = Field<17, 1>;    // Invalid state usage fault
            using INVPC = Field<18, 1>;    // Invalid PC load usage fault
            using NOCP = Field<19, 1>;    // No coprocessor usage fault.
            using UNALIGNED = Field<24, 1>;    // Unaligned access usage fault
            using DIVBYZERO = Field<25, 1>;    // Divide by zero usage fault
        };

        // Hard fault status register
        struct HFSR : public Register<0xe000ed2c> {
            using VECTTBL = Field<1, 1>;    // Vector table hard fault
            using FORCED = Field<30, 1>;    // Forced hard fault
            using DEBUG_VT = Field<31, 1>;    // Reserved for Debug use
        };

        // Memory management fault address register
        struct MMFAR : public Register<0xe000ed34> {
            using Field = Field<0, 32>;    // Memory management fault address
        };

        // Bus fault address register
        struct BFAR : public Register<0xe000ed38> {
            using Field = Field<0, 32>;    // Bus fault address
        };

        // Auxiliary fault status register
        struct AFSR : public Register<0xe000ed3c> {
            using IMPDEF = Field<0, 32>;    // Implementation defined
        };

    };

    // Nested vectored interrupt controller
    struct NVIC_STIR {
        // Software trigger interrupt register
        struct STIR : public Register<0xe000ef00> {
            using INTID = Field<0, 9>;    // Software generated interrupt ID
        };

    };

    // Floating point unit CPACR
    struct FPU_CPACR {
        // Coprocessor access control register
        struct CPACR : public Register<0xe000ed88> {
            using CP = Field<20, 4>;    // CP
        };

    };

    // System control block ACTLR
    struct SCB_ACTRL {
        // Auxiliary control register
        struct ACTRL : public Register<0xe000e008> {
            using DISMCYCINT = Field<0, 1>;    // DISMCYCINT
            using DISDEFWBUF = Field<1, 1>;    // DISDEFWBUF
            using DISFOLD = Field<2, 1>;    // DISFOLD
            using DISFPCA = Field<8, 1>;    // DISFPCA
            using DISOOFP = Field<9, 1>;    // DISOOFP
        };

    };

};
