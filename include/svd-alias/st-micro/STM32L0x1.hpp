// This is a file generated by svd-alias.

#pragma once

#include "svd-alias/bit-field.hpp"
#include "svd-alias/register.hpp"

struct STM32L0x1 {
    // Advanced encryption standard hardware accelerator
    struct AES {
        // control register
        struct CR : public Register<0x40026000> {
            using DMAOUTEN = Field<12, 1>;    // Enable DMA management of data output phase
            using DMAINEN = Field<11, 1>;    // Enable DMA management of data input phase
            using ERRIE = Field<10, 1>;    // Error interrupt enable
            using CCFIE = Field<9, 1>;    // CCF flag interrupt enable
            using ERRC = Field<8, 1>;    // Error clear
            using CCFC = Field<7, 1>;    // Computation Complete Flag Clear
            using CHMOD = Field<5, 2>;    // AES chaining mode
            using MODE = Field<3, 2>;    // AES operating mode
            using DATATYPE = Field<1, 2>;    // Data type selection (for data in and data out to/from the cryptographic block)
            using EN = Field<0, 1>;    // AES enable
        };

        // status register
        struct SR : public Register<0x40026004> {
            using WRERR = Field<2, 1>;    // Write error flag
            using RDERR = Field<1, 1>;    // Read error flag
            using CCF = Field<0, 1>;    // Computation complete flag
        };

        // data input register
        struct DINR : public Register<0x40026008> {
            using AES_DINR = Field<0, 32>;    // Data Input Register.
        };

        // data output register
        struct DOUTR : public Register<0x4002600c> {
            using AES_DOUTR = Field<0, 32>;    // Data output register
        };

        // key register 0
        struct KEYR0 : public Register<0x40026010> {
            using AES_KEYR0 = Field<0, 32>;    // Data Output Register (LSB key [31:0])
        };

        // key register 1
        struct KEYR1 : public Register<0x40026014> {
            using AES_KEYR1 = Field<0, 32>;    // AES key register (key [63:32])
        };

        // key register 2
        struct KEYR2 : public Register<0x40026018> {
            using AES_KEYR2 = Field<0, 32>;    // AES key register (key [95:64])
        };

        // key register 3
        struct KEYR3 : public Register<0x4002601c> {
            using AES_KEYR3 = Field<0, 32>;    // AES key register (MSB key [127:96])
        };

        // initialization vector register 0
        struct IVR0 : public Register<0x40026020> {
            using AES_IVR0 = Field<0, 32>;    // initialization vector register (LSB IVR [31:0])
        };

        // initialization vector register 1
        struct IVR1 : public Register<0x40026024> {
            using AES_IVR1 = Field<0, 32>;    // Initialization Vector Register (IVR [63:32])
        };

        // initialization vector register 2
        struct IVR2 : public Register<0x40026028> {
            using AES_IVR2 = Field<0, 32>;    // Initialization Vector Register (IVR [95:64])
        };

        // initialization vector register 3
        struct IVR3 : public Register<0x4002602c> {
            using AES_IVR3 = Field<0, 32>;    // Initialization Vector Register (MSB IVR [127:96])
        };

    };

    // Direct memory access controller
    struct DMA1 {
        // interrupt status register
        struct ISR : public Register<0x40020000> {
            using TEIF7 = Field<27, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF7 = Field<26, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF7 = Field<25, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF7 = Field<24, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF6 = Field<23, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF6 = Field<22, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF6 = Field<21, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF6 = Field<20, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF5 = Field<19, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF5 = Field<18, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF5 = Field<17, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF5 = Field<16, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF4 = Field<15, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF4 = Field<14, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF4 = Field<13, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF4 = Field<12, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF3 = Field<11, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF3 = Field<10, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF3 = Field<9, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF3 = Field<8, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF2 = Field<7, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF2 = Field<6, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF2 = Field<5, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF2 = Field<4, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF1 = Field<3, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF1 = Field<2, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF1 = Field<1, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF1 = Field<0, 1>;    // Channel x global interrupt flag (x = 1 ..7)
        };

        // interrupt flag clear register
        struct IFCR : public Register<0x40020004> {
            using CTEIF7 = Field<27, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF7 = Field<26, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF7 = Field<25, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF7 = Field<24, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF6 = Field<23, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF6 = Field<22, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF6 = Field<21, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF6 = Field<20, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF5 = Field<19, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF5 = Field<18, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF5 = Field<17, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF5 = Field<16, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF4 = Field<15, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF4 = Field<14, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF4 = Field<13, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF4 = Field<12, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF3 = Field<11, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF3 = Field<10, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF3 = Field<9, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF3 = Field<8, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF2 = Field<7, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF2 = Field<6, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF2 = Field<5, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF2 = Field<4, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF1 = Field<3, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF1 = Field<2, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF1 = Field<1, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF1 = Field<0, 1>;    // Channel x global interrupt clear (x = 1 ..7)
        };

        // channel x configuration register
        struct CCR1 : public Register<0x40020008> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR1 : public Register<0x4002000c> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR1 : public Register<0x40020010> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR1 : public Register<0x40020014> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR2 : public Register<0x4002001c> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR2 : public Register<0x40020020> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR2 : public Register<0x40020024> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR2 : public Register<0x40020028> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR3 : public Register<0x40020030> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR3 : public Register<0x40020034> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR3 : public Register<0x40020038> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR3 : public Register<0x4002003c> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR4 : public Register<0x40020044> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR4 : public Register<0x40020048> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR4 : public Register<0x4002004c> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR4 : public Register<0x40020050> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR5 : public Register<0x40020058> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR5 : public Register<0x4002005c> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR5 : public Register<0x40020060> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR5 : public Register<0x40020064> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR6 : public Register<0x4002006c> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR6 : public Register<0x40020070> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR6 : public Register<0x40020074> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR6 : public Register<0x40020078> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR7 : public Register<0x40020080> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR7 : public Register<0x40020084> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR7 : public Register<0x40020088> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR7 : public Register<0x4002008c> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel selection register
        struct CSELR : public Register<0x400200a8> {
            using C7S = Field<24, 4>;    // DMA channel 7 selection
            using C6S = Field<20, 4>;    // DMA channel 6 selection
            using C5S = Field<16, 4>;    // DMA channel 5 selection
            using C4S = Field<12, 4>;    // DMA channel 4 selection
            using C3S = Field<8, 4>;    // DMA channel 3 selection
            using C2S = Field<4, 4>;    // DMA channel 2 selection
            using C1S = Field<0, 4>;    // DMA channel 1 selection
        };

    };

    // Cyclic redundancy check calculation unit
    struct CRC {
        // Data register
        struct DR : public Register<0x40023000> {
            using DR = Field<0, 32>;    // Data register bits
        };

        // Independent data register
        struct IDR : public Register<0x40023004> {
            using IDR = Field<0, 8>;    // General-purpose 8-bit data register bits
        };

        // Control register
        struct CR : public Register<0x40023008> {
            using REV_OUT = Field<7, 1>;    // Reverse output data
            using REV_IN = Field<5, 2>;    // Reverse input data
            using POLYSIZE = Field<3, 2>;    // Polynomial size
            using RESET = Field<0, 1>;    // RESET bit
        };

        // Initial CRC value
        struct INIT : public Register<0x40023010> {
            using CRC_INIT = Field<0, 32>;    // Programmable initial CRC value
        };

        // polynomial
        struct POL : public Register<0x40023014> {
            using Polynomialcoefficients = Field<0, 32>;    // Programmable polynomial
        };

    };

    // General-purpose I/Os
    struct GPIOA {
        // GPIO port mode register
        struct MODER : public Register<0x50000000> {
            using MODE0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
            using MODE1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODE2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODE3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODE4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODE5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODE6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODE7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODE8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODE9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODE10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODE11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODE12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODE13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODE14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODE15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x50000004> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x50000008> {
            using OSPEED15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x5000000c> {
            using PUPD15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x50000010> {
            using ID15 = Field<15, 1>;    // Port input data bit (y = 0..15)
            using ID14 = Field<14, 1>;    // Port input data bit (y = 0..15)
            using ID13 = Field<13, 1>;    // Port input data bit (y = 0..15)
            using ID12 = Field<12, 1>;    // Port input data bit (y = 0..15)
            using ID11 = Field<11, 1>;    // Port input data bit (y = 0..15)
            using ID10 = Field<10, 1>;    // Port input data bit (y = 0..15)
            using ID9 = Field<9, 1>;    // Port input data bit (y = 0..15)
            using ID8 = Field<8, 1>;    // Port input data bit (y = 0..15)
            using ID7 = Field<7, 1>;    // Port input data bit (y = 0..15)
            using ID6 = Field<6, 1>;    // Port input data bit (y = 0..15)
            using ID5 = Field<5, 1>;    // Port input data bit (y = 0..15)
            using ID4 = Field<4, 1>;    // Port input data bit (y = 0..15)
            using ID3 = Field<3, 1>;    // Port input data bit (y = 0..15)
            using ID2 = Field<2, 1>;    // Port input data bit (y = 0..15)
            using ID1 = Field<1, 1>;    // Port input data bit (y = 0..15)
            using ID0 = Field<0, 1>;    // Port input data bit (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x50000014> {
            using OD15 = Field<15, 1>;    // Port output data bit (y = 0..15)
            using OD14 = Field<14, 1>;    // Port output data bit (y = 0..15)
            using OD13 = Field<13, 1>;    // Port output data bit (y = 0..15)
            using OD12 = Field<12, 1>;    // Port output data bit (y = 0..15)
            using OD11 = Field<11, 1>;    // Port output data bit (y = 0..15)
            using OD10 = Field<10, 1>;    // Port output data bit (y = 0..15)
            using OD9 = Field<9, 1>;    // Port output data bit (y = 0..15)
            using OD8 = Field<8, 1>;    // Port output data bit (y = 0..15)
            using OD7 = Field<7, 1>;    // Port output data bit (y = 0..15)
            using OD6 = Field<6, 1>;    // Port output data bit (y = 0..15)
            using OD5 = Field<5, 1>;    // Port output data bit (y = 0..15)
            using OD4 = Field<4, 1>;    // Port output data bit (y = 0..15)
            using OD3 = Field<3, 1>;    // Port output data bit (y = 0..15)
            using OD2 = Field<2, 1>;    // Port output data bit (y = 0..15)
            using OD1 = Field<1, 1>;    // Port output data bit (y = 0..15)
            using OD0 = Field<0, 1>;    // Port output data bit (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x50000018> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x reset bit y (y = 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x5000001c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x50000020> {
            using AFSEL7 = Field<28, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL6 = Field<24, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL5 = Field<20, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL4 = Field<16, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL3 = Field<12, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL2 = Field<8, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL1 = Field<4, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL0 = Field<0, 4>;    // Alternate function selection for port x pin y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x50000024> {
            using AFSEL15 = Field<28, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL14 = Field<24, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL13 = Field<20, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL12 = Field<16, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL11 = Field<12, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL10 = Field<8, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL9 = Field<4, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL8 = Field<0, 4>;    // Alternate function selection for port x pin y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x50000028> {
            using BR15 = Field<15, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR14 = Field<14, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR13 = Field<13, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR12 = Field<12, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR11 = Field<11, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR10 = Field<10, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR9 = Field<9, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR8 = Field<8, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR7 = Field<7, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR6 = Field<6, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR5 = Field<5, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR4 = Field<4, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR3 = Field<3, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR2 = Field<2, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR1 = Field<1, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR0 = Field<0, 1>;    // Port x Reset bit y (y= 0 .. 15)
        };

    };

    // General-purpose I/Os
    struct GPIOB {
        // GPIO port mode register
        struct MODER : public Register<0x50000400> {
            using MODE15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODE14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODE13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODE12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODE11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODE10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODE9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODE8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODE7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODE6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODE5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODE4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODE3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODE2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODE1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODE0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x50000404> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x50000408> {
            using OSPEED15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x5000040c> {
            using PUPD15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x50000410> {
            using ID15 = Field<15, 1>;    // Port input data bit (y = 0..15)
            using ID14 = Field<14, 1>;    // Port input data bit (y = 0..15)
            using ID13 = Field<13, 1>;    // Port input data bit (y = 0..15)
            using ID12 = Field<12, 1>;    // Port input data bit (y = 0..15)
            using ID11 = Field<11, 1>;    // Port input data bit (y = 0..15)
            using ID10 = Field<10, 1>;    // Port input data bit (y = 0..15)
            using ID9 = Field<9, 1>;    // Port input data bit (y = 0..15)
            using ID8 = Field<8, 1>;    // Port input data bit (y = 0..15)
            using ID7 = Field<7, 1>;    // Port input data bit (y = 0..15)
            using ID6 = Field<6, 1>;    // Port input data bit (y = 0..15)
            using ID5 = Field<5, 1>;    // Port input data bit (y = 0..15)
            using ID4 = Field<4, 1>;    // Port input data bit (y = 0..15)
            using ID3 = Field<3, 1>;    // Port input data bit (y = 0..15)
            using ID2 = Field<2, 1>;    // Port input data bit (y = 0..15)
            using ID1 = Field<1, 1>;    // Port input data bit (y = 0..15)
            using ID0 = Field<0, 1>;    // Port input data bit (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x50000414> {
            using OD15 = Field<15, 1>;    // Port output data bit (y = 0..15)
            using OD14 = Field<14, 1>;    // Port output data bit (y = 0..15)
            using OD13 = Field<13, 1>;    // Port output data bit (y = 0..15)
            using OD12 = Field<12, 1>;    // Port output data bit (y = 0..15)
            using OD11 = Field<11, 1>;    // Port output data bit (y = 0..15)
            using OD10 = Field<10, 1>;    // Port output data bit (y = 0..15)
            using OD9 = Field<9, 1>;    // Port output data bit (y = 0..15)
            using OD8 = Field<8, 1>;    // Port output data bit (y = 0..15)
            using OD7 = Field<7, 1>;    // Port output data bit (y = 0..15)
            using OD6 = Field<6, 1>;    // Port output data bit (y = 0..15)
            using OD5 = Field<5, 1>;    // Port output data bit (y = 0..15)
            using OD4 = Field<4, 1>;    // Port output data bit (y = 0..15)
            using OD3 = Field<3, 1>;    // Port output data bit (y = 0..15)
            using OD2 = Field<2, 1>;    // Port output data bit (y = 0..15)
            using OD1 = Field<1, 1>;    // Port output data bit (y = 0..15)
            using OD0 = Field<0, 1>;    // Port output data bit (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x50000418> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x reset bit y (y = 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x5000041c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x50000420> {
            using AFSEL7 = Field<28, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL6 = Field<24, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL5 = Field<20, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL4 = Field<16, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL3 = Field<12, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL2 = Field<8, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL1 = Field<4, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL0 = Field<0, 4>;    // Alternate function selection for port x pin y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x50000424> {
            using AFSEL15 = Field<28, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL14 = Field<24, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL13 = Field<20, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL12 = Field<16, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL11 = Field<12, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL10 = Field<8, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL9 = Field<4, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL8 = Field<0, 4>;    // Alternate function selection for port x pin y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x50000428> {
            using BR15 = Field<15, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR14 = Field<14, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR13 = Field<13, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR12 = Field<12, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR11 = Field<11, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR10 = Field<10, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR9 = Field<9, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR8 = Field<8, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR7 = Field<7, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR6 = Field<6, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR5 = Field<5, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR4 = Field<4, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR3 = Field<3, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR2 = Field<2, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR1 = Field<1, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR0 = Field<0, 1>;    // Port x Reset bit y (y= 0 .. 15)
        };

    };

    // General-purpose I/Os
    struct GPIOC {
        // GPIO port mode register
        struct MODER : public Register<0x50000800> {
            using MODE15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODE14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODE13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODE12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODE11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODE10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODE9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODE8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODE7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODE6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODE5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODE4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODE3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODE2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODE1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODE0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x50000804> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x50000808> {
            using OSPEED15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x5000080c> {
            using PUPD15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x50000810> {
            using ID15 = Field<15, 1>;    // Port input data bit (y = 0..15)
            using ID14 = Field<14, 1>;    // Port input data bit (y = 0..15)
            using ID13 = Field<13, 1>;    // Port input data bit (y = 0..15)
            using ID12 = Field<12, 1>;    // Port input data bit (y = 0..15)
            using ID11 = Field<11, 1>;    // Port input data bit (y = 0..15)
            using ID10 = Field<10, 1>;    // Port input data bit (y = 0..15)
            using ID9 = Field<9, 1>;    // Port input data bit (y = 0..15)
            using ID8 = Field<8, 1>;    // Port input data bit (y = 0..15)
            using ID7 = Field<7, 1>;    // Port input data bit (y = 0..15)
            using ID6 = Field<6, 1>;    // Port input data bit (y = 0..15)
            using ID5 = Field<5, 1>;    // Port input data bit (y = 0..15)
            using ID4 = Field<4, 1>;    // Port input data bit (y = 0..15)
            using ID3 = Field<3, 1>;    // Port input data bit (y = 0..15)
            using ID2 = Field<2, 1>;    // Port input data bit (y = 0..15)
            using ID1 = Field<1, 1>;    // Port input data bit (y = 0..15)
            using ID0 = Field<0, 1>;    // Port input data bit (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x50000814> {
            using OD15 = Field<15, 1>;    // Port output data bit (y = 0..15)
            using OD14 = Field<14, 1>;    // Port output data bit (y = 0..15)
            using OD13 = Field<13, 1>;    // Port output data bit (y = 0..15)
            using OD12 = Field<12, 1>;    // Port output data bit (y = 0..15)
            using OD11 = Field<11, 1>;    // Port output data bit (y = 0..15)
            using OD10 = Field<10, 1>;    // Port output data bit (y = 0..15)
            using OD9 = Field<9, 1>;    // Port output data bit (y = 0..15)
            using OD8 = Field<8, 1>;    // Port output data bit (y = 0..15)
            using OD7 = Field<7, 1>;    // Port output data bit (y = 0..15)
            using OD6 = Field<6, 1>;    // Port output data bit (y = 0..15)
            using OD5 = Field<5, 1>;    // Port output data bit (y = 0..15)
            using OD4 = Field<4, 1>;    // Port output data bit (y = 0..15)
            using OD3 = Field<3, 1>;    // Port output data bit (y = 0..15)
            using OD2 = Field<2, 1>;    // Port output data bit (y = 0..15)
            using OD1 = Field<1, 1>;    // Port output data bit (y = 0..15)
            using OD0 = Field<0, 1>;    // Port output data bit (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x50000818> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x reset bit y (y = 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x5000081c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x50000820> {
            using AFSEL7 = Field<28, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL6 = Field<24, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL5 = Field<20, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL4 = Field<16, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL3 = Field<12, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL2 = Field<8, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL1 = Field<4, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL0 = Field<0, 4>;    // Alternate function selection for port x pin y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x50000824> {
            using AFSEL15 = Field<28, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL14 = Field<24, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL13 = Field<20, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL12 = Field<16, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL11 = Field<12, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL10 = Field<8, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL9 = Field<4, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL8 = Field<0, 4>;    // Alternate function selection for port x pin y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x50000828> {
            using BR15 = Field<15, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR14 = Field<14, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR13 = Field<13, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR12 = Field<12, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR11 = Field<11, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR10 = Field<10, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR9 = Field<9, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR8 = Field<8, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR7 = Field<7, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR6 = Field<6, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR5 = Field<5, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR4 = Field<4, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR3 = Field<3, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR2 = Field<2, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR1 = Field<1, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR0 = Field<0, 1>;    // Port x Reset bit y (y= 0 .. 15)
        };

    };

    // General-purpose I/Os
    struct GPIOD {
        // GPIO port mode register
        struct MODER : public Register<0x50000c00> {
            using MODE15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODE14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODE13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODE12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODE11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODE10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODE9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODE8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODE7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODE6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODE5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODE4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODE3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODE2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODE1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODE0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x50000c04> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x50000c08> {
            using OSPEED15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x50000c0c> {
            using PUPD15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x50000c10> {
            using ID15 = Field<15, 1>;    // Port input data bit (y = 0..15)
            using ID14 = Field<14, 1>;    // Port input data bit (y = 0..15)
            using ID13 = Field<13, 1>;    // Port input data bit (y = 0..15)
            using ID12 = Field<12, 1>;    // Port input data bit (y = 0..15)
            using ID11 = Field<11, 1>;    // Port input data bit (y = 0..15)
            using ID10 = Field<10, 1>;    // Port input data bit (y = 0..15)
            using ID9 = Field<9, 1>;    // Port input data bit (y = 0..15)
            using ID8 = Field<8, 1>;    // Port input data bit (y = 0..15)
            using ID7 = Field<7, 1>;    // Port input data bit (y = 0..15)
            using ID6 = Field<6, 1>;    // Port input data bit (y = 0..15)
            using ID5 = Field<5, 1>;    // Port input data bit (y = 0..15)
            using ID4 = Field<4, 1>;    // Port input data bit (y = 0..15)
            using ID3 = Field<3, 1>;    // Port input data bit (y = 0..15)
            using ID2 = Field<2, 1>;    // Port input data bit (y = 0..15)
            using ID1 = Field<1, 1>;    // Port input data bit (y = 0..15)
            using ID0 = Field<0, 1>;    // Port input data bit (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x50000c14> {
            using OD15 = Field<15, 1>;    // Port output data bit (y = 0..15)
            using OD14 = Field<14, 1>;    // Port output data bit (y = 0..15)
            using OD13 = Field<13, 1>;    // Port output data bit (y = 0..15)
            using OD12 = Field<12, 1>;    // Port output data bit (y = 0..15)
            using OD11 = Field<11, 1>;    // Port output data bit (y = 0..15)
            using OD10 = Field<10, 1>;    // Port output data bit (y = 0..15)
            using OD9 = Field<9, 1>;    // Port output data bit (y = 0..15)
            using OD8 = Field<8, 1>;    // Port output data bit (y = 0..15)
            using OD7 = Field<7, 1>;    // Port output data bit (y = 0..15)
            using OD6 = Field<6, 1>;    // Port output data bit (y = 0..15)
            using OD5 = Field<5, 1>;    // Port output data bit (y = 0..15)
            using OD4 = Field<4, 1>;    // Port output data bit (y = 0..15)
            using OD3 = Field<3, 1>;    // Port output data bit (y = 0..15)
            using OD2 = Field<2, 1>;    // Port output data bit (y = 0..15)
            using OD1 = Field<1, 1>;    // Port output data bit (y = 0..15)
            using OD0 = Field<0, 1>;    // Port output data bit (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x50000c18> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x reset bit y (y = 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x50000c1c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x50000c20> {
            using AFSEL7 = Field<28, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL6 = Field<24, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL5 = Field<20, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL4 = Field<16, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL3 = Field<12, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL2 = Field<8, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL1 = Field<4, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL0 = Field<0, 4>;    // Alternate function selection for port x pin y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x50000c24> {
            using AFSEL15 = Field<28, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL14 = Field<24, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL13 = Field<20, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL12 = Field<16, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL11 = Field<12, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL10 = Field<8, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL9 = Field<4, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL8 = Field<0, 4>;    // Alternate function selection for port x pin y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x50000c28> {
            using BR15 = Field<15, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR14 = Field<14, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR13 = Field<13, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR12 = Field<12, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR11 = Field<11, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR10 = Field<10, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR9 = Field<9, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR8 = Field<8, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR7 = Field<7, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR6 = Field<6, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR5 = Field<5, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR4 = Field<4, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR3 = Field<3, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR2 = Field<2, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR1 = Field<1, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR0 = Field<0, 1>;    // Port x Reset bit y (y= 0 .. 15)
        };

    };

    // General-purpose I/Os
    struct GPIOH {
        // GPIO port mode register
        struct MODER : public Register<0x50001c00> {
            using MODE15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODE14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODE13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODE12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODE11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODE10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODE9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODE8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODE7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODE6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODE5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODE4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODE3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODE2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODE1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODE0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x50001c04> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x50001c08> {
            using OSPEED15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x50001c0c> {
            using PUPD15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x50001c10> {
            using ID15 = Field<15, 1>;    // Port input data bit (y = 0..15)
            using ID14 = Field<14, 1>;    // Port input data bit (y = 0..15)
            using ID13 = Field<13, 1>;    // Port input data bit (y = 0..15)
            using ID12 = Field<12, 1>;    // Port input data bit (y = 0..15)
            using ID11 = Field<11, 1>;    // Port input data bit (y = 0..15)
            using ID10 = Field<10, 1>;    // Port input data bit (y = 0..15)
            using ID9 = Field<9, 1>;    // Port input data bit (y = 0..15)
            using ID8 = Field<8, 1>;    // Port input data bit (y = 0..15)
            using ID7 = Field<7, 1>;    // Port input data bit (y = 0..15)
            using ID6 = Field<6, 1>;    // Port input data bit (y = 0..15)
            using ID5 = Field<5, 1>;    // Port input data bit (y = 0..15)
            using ID4 = Field<4, 1>;    // Port input data bit (y = 0..15)
            using ID3 = Field<3, 1>;    // Port input data bit (y = 0..15)
            using ID2 = Field<2, 1>;    // Port input data bit (y = 0..15)
            using ID1 = Field<1, 1>;    // Port input data bit (y = 0..15)
            using ID0 = Field<0, 1>;    // Port input data bit (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x50001c14> {
            using OD15 = Field<15, 1>;    // Port output data bit (y = 0..15)
            using OD14 = Field<14, 1>;    // Port output data bit (y = 0..15)
            using OD13 = Field<13, 1>;    // Port output data bit (y = 0..15)
            using OD12 = Field<12, 1>;    // Port output data bit (y = 0..15)
            using OD11 = Field<11, 1>;    // Port output data bit (y = 0..15)
            using OD10 = Field<10, 1>;    // Port output data bit (y = 0..15)
            using OD9 = Field<9, 1>;    // Port output data bit (y = 0..15)
            using OD8 = Field<8, 1>;    // Port output data bit (y = 0..15)
            using OD7 = Field<7, 1>;    // Port output data bit (y = 0..15)
            using OD6 = Field<6, 1>;    // Port output data bit (y = 0..15)
            using OD5 = Field<5, 1>;    // Port output data bit (y = 0..15)
            using OD4 = Field<4, 1>;    // Port output data bit (y = 0..15)
            using OD3 = Field<3, 1>;    // Port output data bit (y = 0..15)
            using OD2 = Field<2, 1>;    // Port output data bit (y = 0..15)
            using OD1 = Field<1, 1>;    // Port output data bit (y = 0..15)
            using OD0 = Field<0, 1>;    // Port output data bit (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x50001c18> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x reset bit y (y = 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x50001c1c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x50001c20> {
            using AFSEL7 = Field<28, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL6 = Field<24, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL5 = Field<20, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL4 = Field<16, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL3 = Field<12, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL2 = Field<8, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL1 = Field<4, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL0 = Field<0, 4>;    // Alternate function selection for port x pin y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x50001c24> {
            using AFSEL15 = Field<28, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL14 = Field<24, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL13 = Field<20, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL12 = Field<16, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL11 = Field<12, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL10 = Field<8, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL9 = Field<4, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL8 = Field<0, 4>;    // Alternate function selection for port x pin y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x50001c28> {
            using BR15 = Field<15, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR14 = Field<14, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR13 = Field<13, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR12 = Field<12, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR11 = Field<11, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR10 = Field<10, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR9 = Field<9, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR8 = Field<8, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR7 = Field<7, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR6 = Field<6, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR5 = Field<5, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR4 = Field<4, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR3 = Field<3, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR2 = Field<2, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR1 = Field<1, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR0 = Field<0, 1>;    // Port x Reset bit y (y= 0 .. 15)
        };

    };

    // General-purpose I/Os
    struct GPIOE {
        // GPIO port mode register
        struct MODER : public Register<0x50001000> {
            using MODE15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODE14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODE13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODE12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODE11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODE10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODE9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODE8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODE7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODE6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODE5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODE4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODE3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODE2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODE1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODE0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x50001004> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x50001008> {
            using OSPEED15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEED0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x5000100c> {
            using PUPD15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPD0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x50001010> {
            using ID15 = Field<15, 1>;    // Port input data bit (y = 0..15)
            using ID14 = Field<14, 1>;    // Port input data bit (y = 0..15)
            using ID13 = Field<13, 1>;    // Port input data bit (y = 0..15)
            using ID12 = Field<12, 1>;    // Port input data bit (y = 0..15)
            using ID11 = Field<11, 1>;    // Port input data bit (y = 0..15)
            using ID10 = Field<10, 1>;    // Port input data bit (y = 0..15)
            using ID9 = Field<9, 1>;    // Port input data bit (y = 0..15)
            using ID8 = Field<8, 1>;    // Port input data bit (y = 0..15)
            using ID7 = Field<7, 1>;    // Port input data bit (y = 0..15)
            using ID6 = Field<6, 1>;    // Port input data bit (y = 0..15)
            using ID5 = Field<5, 1>;    // Port input data bit (y = 0..15)
            using ID4 = Field<4, 1>;    // Port input data bit (y = 0..15)
            using ID3 = Field<3, 1>;    // Port input data bit (y = 0..15)
            using ID2 = Field<2, 1>;    // Port input data bit (y = 0..15)
            using ID1 = Field<1, 1>;    // Port input data bit (y = 0..15)
            using ID0 = Field<0, 1>;    // Port input data bit (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x50001014> {
            using OD15 = Field<15, 1>;    // Port output data bit (y = 0..15)
            using OD14 = Field<14, 1>;    // Port output data bit (y = 0..15)
            using OD13 = Field<13, 1>;    // Port output data bit (y = 0..15)
            using OD12 = Field<12, 1>;    // Port output data bit (y = 0..15)
            using OD11 = Field<11, 1>;    // Port output data bit (y = 0..15)
            using OD10 = Field<10, 1>;    // Port output data bit (y = 0..15)
            using OD9 = Field<9, 1>;    // Port output data bit (y = 0..15)
            using OD8 = Field<8, 1>;    // Port output data bit (y = 0..15)
            using OD7 = Field<7, 1>;    // Port output data bit (y = 0..15)
            using OD6 = Field<6, 1>;    // Port output data bit (y = 0..15)
            using OD5 = Field<5, 1>;    // Port output data bit (y = 0..15)
            using OD4 = Field<4, 1>;    // Port output data bit (y = 0..15)
            using OD3 = Field<3, 1>;    // Port output data bit (y = 0..15)
            using OD2 = Field<2, 1>;    // Port output data bit (y = 0..15)
            using OD1 = Field<1, 1>;    // Port output data bit (y = 0..15)
            using OD0 = Field<0, 1>;    // Port output data bit (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x50001018> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x reset bit y (y = 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x5000101c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x50001020> {
            using AFSEL7 = Field<28, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL6 = Field<24, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL5 = Field<20, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL4 = Field<16, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL3 = Field<12, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL2 = Field<8, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL1 = Field<4, 4>;    // Alternate function selection for port x pin y (y = 0..7)
            using AFSEL0 = Field<0, 4>;    // Alternate function selection for port x pin y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x50001024> {
            using AFSEL15 = Field<28, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL14 = Field<24, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL13 = Field<20, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL12 = Field<16, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL11 = Field<12, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL10 = Field<8, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL9 = Field<4, 4>;    // Alternate function selection for port x pin y (y = 8..15)
            using AFSEL8 = Field<0, 4>;    // Alternate function selection for port x pin y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x50001028> {
            using BR15 = Field<15, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR14 = Field<14, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR13 = Field<13, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR12 = Field<12, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR11 = Field<11, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR10 = Field<10, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR9 = Field<9, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR8 = Field<8, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR7 = Field<7, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR6 = Field<6, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR5 = Field<5, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR4 = Field<4, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR3 = Field<3, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR2 = Field<2, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR1 = Field<1, 1>;    // Port x Reset bit y (y= 0 .. 15)
            using BR0 = Field<0, 1>;    // Port x Reset bit y (y= 0 .. 15)
        };

    };

    // Low power timer
    struct LPTIM {
        // Interrupt and Status Register
        struct ISR : public Register<0x40007c00> {
            using DOWN = Field<6, 1>;    // Counter direction change up to down
            using UP = Field<5, 1>;    // Counter direction change down to up
            using ARROK = Field<4, 1>;    // Autoreload register update OK
            using CMPOK = Field<3, 1>;    // Compare register update OK
            using EXTTRIG = Field<2, 1>;    // External trigger edge event
            using ARRM = Field<1, 1>;    // Autoreload match
            using CMPM = Field<0, 1>;    // Compare match
        };

        // Interrupt Clear Register
        struct ICR : public Register<0x40007c04> {
            using DOWNCF = Field<6, 1>;    // Direction change to down Clear Flag
            using UPCF = Field<5, 1>;    // Direction change to UP Clear Flag
            using ARROKCF = Field<4, 1>;    // Autoreload register update OK Clear Flag
            using CMPOKCF = Field<3, 1>;    // Compare register update OK Clear Flag
            using EXTTRIGCF = Field<2, 1>;    // External trigger valid edge Clear Flag
            using ARRMCF = Field<1, 1>;    // Autoreload match Clear Flag
            using CMPMCF = Field<0, 1>;    // compare match Clear Flag
        };

        // Interrupt Enable Register
        struct IER : public Register<0x40007c08> {
            using DOWNIE = Field<6, 1>;    // Direction change to down Interrupt Enable
            using UPIE = Field<5, 1>;    // Direction change to UP Interrupt Enable
            using ARROKIE = Field<4, 1>;    // Autoreload register update OK Interrupt Enable
            using CMPOKIE = Field<3, 1>;    // Compare register update OK Interrupt Enable
            using EXTTRIGIE = Field<2, 1>;    // External trigger valid edge Interrupt Enable
            using ARRMIE = Field<1, 1>;    // Autoreload match Interrupt Enable
            using CMPMIE = Field<0, 1>;    // Compare match Interrupt Enable
        };

        // Configuration Register
        struct CFGR : public Register<0x40007c0c> {
            using ENC = Field<24, 1>;    // Encoder mode enable
            using COUNTMODE = Field<23, 1>;    // counter mode enabled
            using PRELOAD = Field<22, 1>;    // Registers update mode
            using WAVPOL = Field<21, 1>;    // Waveform shape polarity
            using WAVE = Field<20, 1>;    // Waveform shape
            using TIMOUT = Field<19, 1>;    // Timeout enable
            using TRIGEN = Field<17, 2>;    // Trigger enable and polarity
            using TRIGSEL = Field<13, 3>;    // Trigger selector
            using PRESC = Field<9, 3>;    // Clock prescaler
            using TRGFLT = Field<6, 2>;    // Configurable digital filter for trigger
            using CKFLT = Field<3, 2>;    // Configurable digital filter for external clock
            using CKPOL = Field<1, 2>;    // Clock Polarity
            using CKSEL = Field<0, 1>;    // Clock selector
        };

        // Control Register
        struct CR : public Register<0x40007c10> {
            using CNTSTRT = Field<2, 1>;    // Timer start in continuous mode
            using SNGSTRT = Field<1, 1>;    // LPTIM start in single mode
            using ENABLE = Field<0, 1>;    // LPTIM Enable
        };

        // Compare Register
        struct CMP : public Register<0x40007c14> {
            using CMP = Field<0, 16>;    // Compare value.
        };

        // Autoreload Register
        struct ARR : public Register<0x40007c18> {
            using ARR = Field<0, 16>;    // Auto reload value.
        };

        // Counter Register
        struct CNT : public Register<0x40007c1c> {
            using CNT = Field<0, 16>;    // Counter value.
        };

    };

    // Real-time clock
    struct RTC {
        // RTC time register
        struct TR : public Register<0x40002800> {
            using PM = Field<22, 1>;    // AM/PM notation
            using HT = Field<20, 2>;    // Hour tens in BCD format
            using HU = Field<16, 4>;    // Hour units in BCD format
            using MNT = Field<12, 3>;    // Minute tens in BCD format
            using MNU = Field<8, 4>;    // Minute units in BCD format
            using ST = Field<4, 3>;    // Second tens in BCD format
            using SU = Field<0, 4>;    // Second units in BCD format
        };

        // RTC date register
        struct DR : public Register<0x40002804> {
            using YT = Field<20, 4>;    // Year tens in BCD format
            using YU = Field<16, 4>;    // Year units in BCD format
            using WDU = Field<13, 3>;    // Week day units
            using MT = Field<12, 1>;    // Month tens in BCD format
            using MU = Field<8, 4>;    // Month units in BCD format
            using DT = Field<4, 2>;    // Date tens in BCD format
            using DU = Field<0, 4>;    // Date units in BCD format
        };

        // RTC control register
        struct CR : public Register<0x40002808> {
            using COE = Field<23, 1>;    // Calibration output enable
            using OSEL = Field<21, 2>;    // Output selection
            using POL = Field<20, 1>;    // Output polarity
            using COSEL = Field<19, 1>;    // Calibration output selection
            using BKP = Field<18, 1>;    // Backup
            using SUB1H = Field<17, 1>;    // Subtract 1 hour (winter time change)
            using ADD1H = Field<16, 1>;    // Add 1 hour (summer time change)
            using TSIE = Field<15, 1>;    // Time-stamp interrupt enable
            using WUTIE = Field<14, 1>;    // Wakeup timer interrupt enable
            using ALRBIE = Field<13, 1>;    // Alarm B interrupt enable
            using ALRAIE = Field<12, 1>;    // Alarm A interrupt enable
            using TSE = Field<11, 1>;    // timestamp enable
            using WUTE = Field<10, 1>;    // Wakeup timer enable
            using ALRBE = Field<9, 1>;    // Alarm B enable
            using ALRAE = Field<8, 1>;    // Alarm A enable
            using FMT = Field<6, 1>;    // Hour format
            using BYPSHAD = Field<5, 1>;    // Bypass the shadow registers
            using REFCKON = Field<4, 1>;    // RTC_REFIN reference clock detection enable (50 or 60 Hz)
            using TSEDGE = Field<3, 1>;    // Time-stamp event active edge
            using WUCKSEL = Field<0, 3>;    // Wakeup clock selection
        };

        // RTC initialization and status register
        struct ISR : public Register<0x4000280c> {
            using TAMP2F = Field<14, 1>;    // RTC_TAMP2 detection flag
            using TAMP1F = Field<13, 1>;    // RTC_TAMP1 detection flag
            using TSOVF = Field<12, 1>;    // Time-stamp overflow flag
            using TSF = Field<11, 1>;    // Time-stamp flag
            using WUTF = Field<10, 1>;    // Wakeup timer flag
            using ALRBF = Field<9, 1>;    // Alarm B flag
            using ALRAF = Field<8, 1>;    // Alarm A flag
            using INIT = Field<7, 1>;    // Initialization mode
            using INITF = Field<6, 1>;    // Initialization flag
            using RSF = Field<5, 1>;    // Registers synchronization flag
            using INITS = Field<4, 1>;    // Initialization status flag
            using SHPF = Field<3, 1>;    // Shift operation pending
            using WUTWF = Field<2, 1>;    // Wakeup timer write flag
            using ALRBWF = Field<1, 1>;    // Alarm B write flag
            using ALRAWF = Field<0, 1>;    // Alarm A write flag
        };

        // RTC prescaler register
        struct PRER : public Register<0x40002810> {
            using PREDIV_A = Field<16, 7>;    // Asynchronous prescaler factor
            using PREDIV_S = Field<0, 16>;    // Synchronous prescaler factor
        };

        // RTC wakeup timer register
        struct WUTR : public Register<0x40002814> {
            using WUT = Field<0, 16>;    // Wakeup auto-reload value bits
        };

        // RTC alarm A register
        struct ALRMAR : public Register<0x4000281c> {
            using MSK4 = Field<31, 1>;    // Alarm A date mask
            using WDSEL = Field<30, 1>;    // Week day selection
            using DT = Field<28, 2>;    // Date tens in BCD format.
            using DU = Field<24, 4>;    // Date units or day in BCD format.
            using MSK3 = Field<23, 1>;    // Alarm A hours mask
            using PM = Field<22, 1>;    // AM/PM notation
            using HT = Field<20, 2>;    // Hour tens in BCD format.
            using HU = Field<16, 4>;    // Hour units in BCD format.
            using MSK2 = Field<15, 1>;    // Alarm A minutes mask
            using MNT = Field<12, 3>;    // Minute tens in BCD format.
            using MNU = Field<8, 4>;    // Minute units in BCD format.
            using MSK1 = Field<7, 1>;    // Alarm A seconds mask
            using ST = Field<4, 3>;    // Second tens in BCD format.
            using SU = Field<0, 4>;    // Second units in BCD format.
        };

        // RTC alarm B register
        struct ALRMBR : public Register<0x40002820> {
            using MSK4 = Field<31, 1>;    // Alarm B date mask
            using WDSEL = Field<30, 1>;    // Week day selection
            using DT = Field<28, 2>;    // Date tens in BCD format
            using DU = Field<24, 4>;    // Date units or day in BCD format
            using MSK3 = Field<23, 1>;    // Alarm B hours mask
            using PM = Field<22, 1>;    // AM/PM notation
            using HT = Field<20, 2>;    // Hour tens in BCD format
            using HU = Field<16, 4>;    // Hour units in BCD format
            using MSK2 = Field<15, 1>;    // Alarm B minutes mask
            using MNT = Field<12, 3>;    // Minute tens in BCD format
            using MNU = Field<8, 4>;    // Minute units in BCD format
            using MSK1 = Field<7, 1>;    // Alarm B seconds mask
            using ST = Field<4, 3>;    // Second tens in BCD format
            using SU = Field<0, 4>;    // Second units in BCD format
        };

        // write protection register
        struct WPR : public Register<0x40002824> {
            using KEY = Field<0, 8>;    // Write protection key
        };

        // RTC sub second register
        struct SSR : public Register<0x40002828> {
            using SS = Field<0, 16>;    // Sub second value
        };

        // RTC shift control register
        struct SHIFTR : public Register<0x4000282c> {
            using ADD1S = Field<31, 1>;    // Add one second
            using SUBFS = Field<0, 15>;    // Subtract a fraction of a second
        };

        // RTC timestamp time register
        struct TSTR : public Register<0x40002830> {
            using PM = Field<22, 1>;    // AM/PM notation
            using HT = Field<20, 2>;    // Hour tens in BCD format.
            using HU = Field<16, 4>;    // Hour units in BCD format.
            using MNT = Field<12, 3>;    // Minute tens in BCD format.
            using MNU = Field<8, 4>;    // Minute units in BCD format.
            using ST = Field<4, 3>;    // Second tens in BCD format.
            using SU = Field<0, 4>;    // Second units in BCD format.
        };

        // RTC timestamp date register
        struct TSDR : public Register<0x40002834> {
            using WDU = Field<13, 3>;    // Week day units
            using MT = Field<12, 1>;    // Month tens in BCD format
            using MU = Field<8, 4>;    // Month units in BCD format
            using DT = Field<4, 2>;    // Date tens in BCD format
            using DU = Field<0, 4>;    // Date units in BCD format
        };

        // RTC time-stamp sub second register
        struct TSSSR : public Register<0x40002838> {
            using SS = Field<0, 16>;    // Sub second value
        };

        // RTC calibration register
        struct CALR : public Register<0x4000283c> {
            using CALP = Field<15, 1>;    // Increase frequency of RTC by 488.5 ppm
            using CALW8 = Field<14, 1>;    // Use an 8-second calibration cycle period
            using CALW16 = Field<13, 1>;    // Use a 16-second calibration cycle period
            using CALM = Field<0, 9>;    // Calibration minus
        };

        // RTC tamper configuration register
        struct TAMPCR : public Register<0x40002840> {
            using TAMP2MF = Field<21, 1>;    // Tamper 2 mask flag
            using TAMP2NOERASE = Field<20, 1>;    // Tamper 2 no erase
            using TAMP2IE = Field<19, 1>;    // Tamper 2 interrupt enable
            using TAMP1MF = Field<18, 1>;    // Tamper 1 mask flag
            using TAMP1NOERASE = Field<17, 1>;    // Tamper 1 no erase
            using TAMP1IE = Field<16, 1>;    // Tamper 1 interrupt enable
            using TAMPPUDIS = Field<15, 1>;    // RTC_TAMPx pull-up disable
            using TAMPPRCH = Field<13, 2>;    // RTC_TAMPx precharge duration
            using TAMPFLT = Field<11, 2>;    // RTC_TAMPx filter count
            using TAMPFREQ = Field<8, 3>;    // Tamper sampling frequency
            using TAMPTS = Field<7, 1>;    // Activate timestamp on tamper detection event
            using TAMP2_TRG = Field<4, 1>;    // Active level for RTC_TAMP2 input
            using TAMP2E = Field<3, 1>;    // RTC_TAMP2 input detection enable
            using TAMPIE = Field<2, 1>;    // Tamper interrupt enable
            using TAMP1TRG = Field<1, 1>;    // Active level for RTC_TAMP1 input
            using TAMP1E = Field<0, 1>;    // RTC_TAMP1 input detection enable
        };

        // RTC alarm A sub second register
        struct ALRMASSR : public Register<0x40002844> {
            using MASKSS = Field<24, 4>;    // Mask the most-significant bits starting at this bit
            using SS = Field<0, 15>;    // Sub seconds value
        };

        // RTC alarm B sub second register
        struct ALRMBSSR : public Register<0x40002848> {
            using MASKSS = Field<24, 4>;    // Mask the most-significant bits starting at this bit
            using SS = Field<0, 15>;    // Sub seconds value
        };

        // option register
        struct OR : public Register<0x4000284c> {
            using RTC_OUT_RMP = Field<1, 1>;    // RTC_ALARM on PC13 output type
            using RTC_ALARM_TYPE = Field<0, 1>;    // RTC_ALARM on PC13 output type
        };

        // RTC backup registers
        struct BKP0R : public Register<0x40002850> {
            using BKP = Field<0, 32>;    // BKP
        };

        // RTC backup registers
        struct BKP1R : public Register<0x40002854> {
            using BKP = Field<0, 32>;    // BKP
        };

        // RTC backup registers
        struct BKP2R : public Register<0x40002858> {
            using BKP = Field<0, 32>;    // BKP
        };

        // RTC backup registers
        struct BKP3R : public Register<0x4000285c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // RTC backup registers
        struct BKP4R : public Register<0x40002860> {
            using BKP = Field<0, 32>;    // BKP
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART1 {
        // Control register 1
        struct CR1 : public Register<0x40013800> {
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40013804> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x40013808> {
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4001380c> {
            using DIV_Mantissa = Field<4, 12>;    // DIV_Mantissa
            using DIV_Fraction = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40013810> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40013814> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public Register<0x40013818> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public Register<0x4001381c> {
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public Register<0x40013820> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public Register<0x40013824> {
            using RDR = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40013828> {
            using TDR = Field<0, 9>;    // Transmit data value
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART2 {
        // Control register 1
        struct CR1 : public Register<0x40004400> {
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40004404> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x40004408> {
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4000440c> {
            using DIV_Mantissa = Field<4, 12>;    // DIV_Mantissa
            using DIV_Fraction = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40004410> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40004414> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public Register<0x40004418> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public Register<0x4000441c> {
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public Register<0x40004420> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public Register<0x40004424> {
            using RDR = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40004428> {
            using TDR = Field<0, 9>;    // Transmit data value
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART4 {
        // Control register 1
        struct CR1 : public Register<0x40004c00> {
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40004c04> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x40004c08> {
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x40004c0c> {
            using DIV_Mantissa = Field<4, 12>;    // DIV_Mantissa
            using DIV_Fraction = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40004c10> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40004c14> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public Register<0x40004c18> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public Register<0x40004c1c> {
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public Register<0x40004c20> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public Register<0x40004c24> {
            using RDR = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40004c28> {
            using TDR = Field<0, 9>;    // Transmit data value
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART5 {
        // Control register 1
        struct CR1 : public Register<0x40005000> {
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40005004> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x40005008> {
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4000500c> {
            using DIV_Mantissa = Field<4, 12>;    // DIV_Mantissa
            using DIV_Fraction = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40005010> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40005014> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public Register<0x40005018> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public Register<0x4000501c> {
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public Register<0x40005020> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public Register<0x40005024> {
            using RDR = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40005028> {
            using TDR = Field<0, 9>;    // Transmit data value
        };

    };

    // Independent watchdog
    struct IWDG {
        // Key register
        struct KR : public Register<0x40003000> {
            using KEY = Field<0, 16>;    // Key value (write only, read 0x0000)
        };

        // Prescaler register
        struct PR : public Register<0x40003004> {
            using PR = Field<0, 3>;    // Prescaler divider
        };

        // Reload register
        struct RLR : public Register<0x40003008> {
            using RL = Field<0, 12>;    // Watchdog counter reload value
        };

        // Status register
        struct SR : public Register<0x4000300c> {
            using WVU = Field<2, 1>;    // Watchdog counter window value update
            using RVU = Field<1, 1>;    // Watchdog counter reload value update
            using PVU = Field<0, 1>;    // Watchdog prescaler value update
        };

        // Window register
        struct WINR : public Register<0x40003010> {
            using WIN = Field<0, 12>;    // Watchdog counter window value
        };

    };

    // System window watchdog
    struct WWDG {
        // Control register
        struct CR : public Register<0x40002c00> {
            using WDGA = Field<7, 1>;    // Activation bit
            using T = Field<0, 7>;    // 7-bit counter (MSB to LSB)
        };

        // Configuration register
        struct CFR : public Register<0x40002c04> {
            using EWI = Field<9, 1>;    // Early wakeup interrupt
            using WDGTB1 = Field<8, 1>;    // Timer base
            using WDGTB0 = Field<7, 1>;    // WDGTB0
            using W = Field<0, 7>;    // 7-bit window value
        };

        // Status register
        struct SR : public Register<0x40002c08> {
            using EWIF = Field<0, 1>;    // Early wakeup interrupt flag
        };

    };

    // Firewall
    struct Firewall {
        // Code segment start address
        struct FIREWALL_CSSA : public Register<0x40011c00> {
            using ADD = Field<8, 16>;    // code segment start address
        };

        // Code segment length
        struct FIREWALL_CSL : public Register<0x40011c04> {
            using LENG = Field<8, 14>;    // code segment length
        };

        // Non-volatile data segment start address
        struct FIREWALL_NVDSSA : public Register<0x40011c08> {
            using ADD = Field<8, 16>;    // Non-volatile data segment start address
        };

        // Non-volatile data segment length
        struct FIREWALL_NVDSL : public Register<0x40011c0c> {
            using LENG = Field<8, 14>;    // Non-volatile data segment length
        };

        // Volatile data segment start address
        struct FIREWALL_VDSSA : public Register<0x40011c10> {
            using ADD = Field<6, 10>;    // Volatile data segment start address
        };

        // Volatile data segment length
        struct FIREWALL_VDSL : public Register<0x40011c14> {
            using LENG = Field<6, 10>;    // Non-volatile data segment length
        };

        // Configuration register
        struct FIREWALL_CR : public Register<0x40011c20> {
            using VDE = Field<2, 1>;    // Volatile data execution
            using VDS = Field<1, 1>;    // Volatile data shared
            using FPA = Field<0, 1>;    // Firewall pre alarm
        };

    };

    // Reset and clock control
    struct RCC {
        // Clock control register
        struct CR : public Register<0x40021000> {
            using PLLRDY = Field<25, 1>;    // PLL clock ready flag
            using PLLON = Field<24, 1>;    // PLL enable bit
            using RTCPRE = Field<20, 2>;    // TC/LCD prescaler
            using CSSLSEON = Field<19, 1>;    // Clock security system on HSE enable bit
            using HSEBYP = Field<18, 1>;    // HSE clock bypass bit
            using HSERDY = Field<17, 1>;    // HSE clock ready flag
            using HSEON = Field<16, 1>;    // HSE clock enable bit
            using MSIRDY = Field<9, 1>;    // MSI clock ready flag
            using MSION = Field<8, 1>;    // MSI clock enable bit
            using HSI16DIVF = Field<4, 1>;    // HSI16DIVF
            using HSI16DIVEN = Field<3, 1>;    // HSI16DIVEN
            using HSI16RDYF = Field<2, 1>;    // Internal high-speed clock ready flag
            using HSI16KERON = Field<1, 1>;    // High-speed internal clock enable bit for some IP kernels
            using HSI16ON = Field<0, 1>;    // 16 MHz high-speed internal clock enable
            using HSI16OUTEN = Field<5, 1>;    // 16 MHz high-speed internal clock output enable
        };

        // Internal clock sources calibration register
        struct ICSCR : public Register<0x40021004> {
            using MSITRIM = Field<24, 8>;    // MSI clock trimming
            using MSICAL = Field<16, 8>;    // MSI clock calibration
            using MSIRANGE = Field<13, 3>;    // MSI clock ranges
            using HSI16TRIM = Field<8, 5>;    // High speed internal clock trimming
            using HSI16CAL = Field<0, 8>;    // nternal high speed clock calibration
        };

        // Clock configuration register
        struct CFGR : public Register<0x4002100c> {
            using MCOPRE = Field<28, 3>;    // Microcontroller clock output prescaler
            using MCOSEL = Field<24, 3>;    // Microcontroller clock output selection
            using PLLDIV = Field<22, 2>;    // PLL output division
            using PLLMUL = Field<18, 4>;    // PLL multiplication factor
            using PLLSRC = Field<16, 1>;    // PLL entry clock source
            using STOPWUCK = Field<15, 1>;    // Wake-up from stop clock selection
            using PPRE2 = Field<11, 3>;    // APB high-speed prescaler (APB2)
            using PPRE1 = Field<8, 3>;    // APB low-speed prescaler (APB1)
            using HPRE = Field<4, 4>;    // AHB prescaler
            using SWS = Field<2, 2>;    // System clock switch status
            using SW = Field<0, 2>;    // System clock switch
        };

        // Clock interrupt enable register
        struct CIER : public Register<0x40021010> {
            using CSSLSE = Field<7, 1>;    // LSE CSS interrupt flag
            using MSIRDYIE = Field<5, 1>;    // MSI ready interrupt flag
            using PLLRDYIE = Field<4, 1>;    // PLL ready interrupt flag
            using HSERDYIE = Field<3, 1>;    // HSE ready interrupt flag
            using HSI16RDYIE = Field<2, 1>;    // HSI16 ready interrupt flag
            using LSERDYIE = Field<1, 1>;    // LSE ready interrupt flag
            using LSIRDYIE = Field<0, 1>;    // LSI ready interrupt flag
        };

        // Clock interrupt flag register
        struct CIFR : public Register<0x40021014> {
            using CSSHSEF = Field<8, 1>;    // Clock Security System Interrupt flag
            using CSSLSEF = Field<7, 1>;    // LSE Clock Security System Interrupt flag
            using MSIRDYF = Field<5, 1>;    // MSI ready interrupt flag
            using PLLRDYF = Field<4, 1>;    // PLL ready interrupt flag
            using HSERDYF = Field<3, 1>;    // HSE ready interrupt flag
            using HSI16RDYF = Field<2, 1>;    // HSI16 ready interrupt flag
            using LSERDYF = Field<1, 1>;    // LSE ready interrupt flag
            using LSIRDYF = Field<0, 1>;    // LSI ready interrupt flag
        };

        // Clock interrupt clear register
        struct CICR : public Register<0x40021018> {
            using CSSHSEC = Field<8, 1>;    // Clock Security System Interrupt clear
            using CSSLSEC = Field<7, 1>;    // LSE Clock Security System Interrupt clear
            using MSIRDYC = Field<5, 1>;    // MSI ready Interrupt clear
            using PLLRDYC = Field<4, 1>;    // PLL ready Interrupt clear
            using HSERDYC = Field<3, 1>;    // HSE ready Interrupt clear
            using HSI16RDYC = Field<2, 1>;    // HSI16 ready Interrupt clear
            using LSERDYC = Field<1, 1>;    // LSE ready Interrupt clear
            using LSIRDYC = Field<0, 1>;    // LSI ready Interrupt clear
        };

        // GPIO reset register
        struct IOPRSTR : public Register<0x4002101c> {
            using IOPHRST = Field<7, 1>;    // I/O port H reset
            using IOPDRST = Field<3, 1>;    // I/O port D reset
            using IOPCRST = Field<2, 1>;    // I/O port A reset
            using IOPBRST = Field<1, 1>;    // I/O port B reset
            using IOPARST = Field<0, 1>;    // I/O port A reset
            using IOPERST = Field<4, 1>;    // I/O port E reset
        };

        // AHB peripheral reset register
        struct AHBRSTR : public Register<0x40021020> {
            using CRYPRST = Field<24, 1>;    // Crypto module reset
            using CRCRST = Field<12, 1>;    // Test integration module reset
            using MIFRST = Field<8, 1>;    // Memory interface reset
            using DMARST = Field<0, 1>;    // DMA reset
        };

        // APB2 peripheral reset register
        struct APB2RSTR : public Register<0x40021024> {
            using DBGRST = Field<22, 1>;    // DBG reset
            using USART1RST = Field<14, 1>;    // USART1 reset
            using SPI1RST = Field<12, 1>;    // SPI 1 reset
            using ADCRST = Field<9, 1>;    // ADC interface reset
            using TIM22RST = Field<5, 1>;    // TIM22 timer reset
            using TIM21RST = Field<2, 1>;    // TIM21 timer reset
            using SYSCFGRST = Field<0, 1>;    // System configuration controller reset
        };

        // APB1 peripheral reset register
        struct APB1RSTR : public Register<0x40021028> {
            using LPTIM1RST = Field<31, 1>;    // Low power timer reset
            using PWRRST = Field<28, 1>;    // Power interface reset
            using I2C2RST = Field<22, 1>;    // I2C2 reset
            using I2C1RST = Field<21, 1>;    // I2C1 reset
            using LPUART1RST = Field<18, 1>;    // LPUART1 reset
            using USART2RST = Field<17, 1>;    // USART2 reset
            using SPI2RST = Field<14, 1>;    // SPI2 reset
            using WWDGRST = Field<11, 1>;    // Window watchdog reset
            using TIM6RST = Field<4, 1>;    // Timer 6 reset
            using TIM2RST = Field<0, 1>;    // Timer 2 reset
            using TIM3RST = Field<1, 1>;    // Timer 3 reset
            using TIM7RST = Field<5, 1>;    // Timer 7 reset
            using USART4RST = Field<19, 1>;    // USART4 reset
            using USART5RST = Field<20, 1>;    // USART5 reset
            using CRCRST = Field<27, 1>;    // CRC reset
            using I2C3 = Field<30, 1>;    // I2C3 reset
        };

        // GPIO clock enable register
        struct IOPENR : public Register<0x4002102c> {
            using IOPHEN = Field<7, 1>;    // I/O port H clock enable bit
            using IOPDEN = Field<3, 1>;    // I/O port D clock enable bit
            using IOPCEN = Field<2, 1>;    // IO port A clock enable bit
            using IOPBEN = Field<1, 1>;    // IO port B clock enable bit
            using IOPAEN = Field<0, 1>;    // IO port A clock enable bit
            using IOPEEN = Field<4, 1>;    // IO port E clock enable bit
        };

        // AHB peripheral clock enable register
        struct AHBENR : public Register<0x40021030> {
            using CRYPEN = Field<24, 1>;    // Crypto clock enable bit
            using CRCEN = Field<12, 1>;    // CRC clock enable bit
            using MIFEN = Field<8, 1>;    // NVM interface clock enable bit
            using DMAEN = Field<0, 1>;    // DMA clock enable bit
        };

        // APB2 peripheral clock enable register
        struct APB2ENR : public Register<0x40021034> {
            using DBGEN = Field<22, 1>;    // DBG clock enable bit
            using USART1EN = Field<14, 1>;    // USART1 clock enable bit
            using SPI1EN = Field<12, 1>;    // SPI1 clock enable bit
            using ADCEN = Field<9, 1>;    // ADC clock enable bit
            using FWEN = Field<7, 1>;    // Firewall clock enable bit
            using TIM22EN = Field<5, 1>;    // TIM22 timer clock enable bit
            using TIM21EN = Field<2, 1>;    // TIM21 timer clock enable bit
            using SYSCFGEN = Field<0, 1>;    // System configuration controller clock enable bit
        };

        // APB1 peripheral clock enable register
        struct APB1ENR : public Register<0x40021038> {
            using LPTIM1EN = Field<31, 1>;    // Low power timer clock enable bit
            using PWREN = Field<28, 1>;    // Power interface clock enable bit
            using I2C2EN = Field<22, 1>;    // I2C2 clock enable bit
            using I2C1EN = Field<21, 1>;    // I2C1 clock enable bit
            using LPUART1EN = Field<18, 1>;    // LPUART1 clock enable bit
            using USART2EN = Field<17, 1>;    // UART2 clock enable bit
            using SPI2EN = Field<14, 1>;    // SPI2 clock enable bit
            using WWDGEN = Field<11, 1>;    // Window watchdog clock enable bit
            using TIM6EN = Field<4, 1>;    // Timer 6 clock enable bit
            using TIM2EN = Field<0, 1>;    // Timer2 clock enable bit
            using TIM3EN = Field<2, 1>;    // Timer 3 clock enbale bit
            using TIM7EN = Field<5, 1>;    // Timer 7 clock enable bit
            using USART4EN = Field<19, 1>;    // USART4 clock enable bit
            using USART5EN = Field<20, 1>;    // USART5 clock enable bit
            using I2C3EN = Field<30, 1>;    // I2C3 clock enable bit
        };

        // GPIO clock enable in sleep mode register
        struct IOPSMEN : public Register<0x4002103c> {
            using IOPHSMEN = Field<7, 1>;    // Port H clock enable during Sleep mode bit
            using IOPDSMEN = Field<3, 1>;    // Port D clock enable during Sleep mode bit
            using IOPCSMEN = Field<2, 1>;    // Port C clock enable during Sleep mode bit
            using IOPBSMEN = Field<1, 1>;    // Port B clock enable during Sleep mode bit
            using IOPASMEN = Field<0, 1>;    // Port A clock enable during Sleep mode bit
            using IOPESMEN = Field<4, 1>;    // Port E clock enable during Sleep mode bit
        };

        // AHB peripheral clock enable in sleep mode register
        struct AHBSMENR : public Register<0x40021040> {
            using CRYPTSMEN = Field<24, 1>;    // Crypto clock enable during sleep mode bit
            using CRCSMEN = Field<12, 1>;    // CRC clock enable during sleep mode bit
            using SRAMSMEN = Field<9, 1>;    // SRAM interface clock enable during sleep mode bit
            using MIFSMEN = Field<8, 1>;    // NVM interface clock enable during sleep mode bit
            using DMASMEN = Field<0, 1>;    // DMA clock enable during sleep mode bit
        };

        // APB2 peripheral clock enable in sleep mode register
        struct APB2SMENR : public Register<0x40021044> {
            using DBGSMEN = Field<22, 1>;    // DBG clock enable during sleep mode bit
            using USART1SMEN = Field<14, 1>;    // USART1 clock enable during sleep mode bit
            using SPI1SMEN = Field<12, 1>;    // SPI1 clock enable during sleep mode bit
            using ADCSMEN = Field<9, 1>;    // ADC clock enable during sleep mode bit
            using TIM22SMEN = Field<5, 1>;    // TIM22 timer clock enable during sleep mode bit
            using TIM21SMEN = Field<2, 1>;    // TIM21 timer clock enable during sleep mode bit
            using SYSCFGSMEN = Field<0, 1>;    // System configuration controller clock enable during sleep mode bit
        };

        // APB1 peripheral clock enable in sleep mode register
        struct APB1SMENR : public Register<0x40021048> {
            using LPTIM1SMEN = Field<31, 1>;    // Low power timer clock enable during sleep mode bit
            using PWRSMEN = Field<28, 1>;    // Power interface clock enable during sleep mode bit
            using CRSSMEN = Field<27, 1>;    // Clock recovery system clock enable during sleep mode bit
            using I2C2SMEN = Field<22, 1>;    // I2C2 clock enable during sleep mode bit
            using I2C1SMEN = Field<21, 1>;    // I2C1 clock enable during sleep mode bit
            using LPUART1SMEN = Field<18, 1>;    // LPUART1 clock enable during sleep mode bit
            using USART2SMEN = Field<17, 1>;    // UART2 clock enable during sleep mode bit
            using SPI2SMEN = Field<14, 1>;    // SPI2 clock enable during sleep mode bit
            using WWDGSMEN = Field<11, 1>;    // Window watchdog clock enable during sleep mode bit
            using TIM6SMEN = Field<4, 1>;    // Timer 6 clock enable during sleep mode bit
            using TIM2SMEN = Field<0, 1>;    // Timer2 clock enable during sleep mode bit
            using TIM3SMEN = Field<1, 1>;    // Timer 3 clock enable during sleep mode bit
            using TIM7SMEN = Field<5, 1>;    // Timer 7 clock enable during sleep mode bit
            using USART4SMEN = Field<19, 1>;    // USART4 clock enabe during sleep mode bit
            using USART5SMEN = Field<20, 1>;    // USART5 clock enable during sleep mode bit
            using I2C3SMEN = Field<30, 1>;    // I2C3 clock enable during sleep mode bit
        };

        // Clock configuration register
        struct CCIPR : public Register<0x4002104c> {
            using LPTIM1SEL1 = Field<19, 1>;    // Low Power Timer clock source selection bits
            using LPTIM1SEL0 = Field<18, 1>;    // LPTIM1SEL0
            using I2C1SEL1 = Field<13, 1>;    // I2C1 clock source selection bits
            using I2C1SEL0 = Field<12, 1>;    // I2C1SEL0
            using LPUART1SEL1 = Field<11, 1>;    // LPUART1 clock source selection bits
            using LPUART1SEL0 = Field<10, 1>;    // LPUART1SEL0
            using USART2SEL1 = Field<3, 1>;    // USART2 clock source selection bits
            using USART2SEL0 = Field<2, 1>;    // USART2SEL0
            using USART1SEL1 = Field<1, 1>;    // USART1 clock source selection bits
            using USART1SEL0 = Field<0, 1>;    // USART1SEL0
            using I2C3SEL0 = Field<16, 1>;    // I2C3 clock source selection bits
            using I2C3SEL1 = Field<17, 1>;    // I2C3 clock source selection bits
        };

        // Control and status register
        struct CSR : public Register<0x40021050> {
            using LPWRSTF = Field<31, 1>;    // Low-power reset flag
            using WWDGRSTF = Field<30, 1>;    // Window watchdog reset flag
            using IWDGRSTF = Field<29, 1>;    // Independent watchdog reset flag
            using SFTRSTF = Field<28, 1>;    // Software reset flag
            using PORRSTF = Field<27, 1>;    // POR/PDR reset flag
            using PINRSTF = Field<26, 1>;    // PIN reset flag
            using OBLRSTF = Field<25, 1>;    // OBLRSTF
            using FWRSTF = Field<24, 1>;    // Firewall reset flag
            using RTCRST = Field<19, 1>;    // RTC software reset bit
            using RTCEN = Field<18, 1>;    // RTC clock enable bit
            using RTCSEL = Field<16, 2>;    // RTC and LCD clock source selection bits
            using CSSLSED = Field<14, 1>;    // CSS on LSE failure detection flag
            using CSSLSEON = Field<13, 1>;    // CSSLSEON
            using LSEDRV = Field<11, 2>;    // LSEDRV
            using LSEBYP = Field<10, 1>;    // External low-speed oscillator bypass bit
            using LSERDY = Field<9, 1>;    // External low-speed oscillator ready bit
            using LSEON = Field<8, 1>;    // External low-speed oscillator enable bit
            using LSIRDY = Field<1, 1>;    // Internal low-speed oscillator ready bit
            using LSION = Field<0, 1>;    // Internal low-speed oscillator enable
            using LSIIWDGLP = Field<2, 1>;    // LSI clock input to IWDG in Ultra-low-power mode (Stop and Standby) enable bit
            using RMVF = Field<23, 1>;    // Remove reset flag
        };

    };

    // System configuration controller and COMP register
    struct SYSCFG_COMP {
        // SYSCFG configuration register 1
        struct CFGR1 : public Register<0x40010000> {
            using BOOT_MODE = Field<8, 2>;    // Boot mode selected by the boot pins status bits
            using MEM_MODE = Field<0, 2>;    // Memory mapping selection bits
        };

        // SYSCFG configuration register 2
        struct CFGR2 : public Register<0x40010004> {
            using I2C2_FMP = Field<13, 1>;    // I2C2 Fm+ drive capability enable bit
            using I2C1_FMP = Field<12, 1>;    // I2C1 Fm+ drive capability enable bit
            using I2C_PB9_FMP = Field<11, 1>;    // Fm+ drive capability on PB9 enable bit
            using I2C_PB8_FMP = Field<10, 1>;    // Fm+ drive capability on PB8 enable bit
            using I2C_PB7_FMP = Field<9, 1>;    // Fm+ drive capability on PB7 enable bit
            using I2C_PB6_FMP = Field<8, 1>;    // Fm+ drive capability on PB6 enable bit
            using CAPA = Field<1, 3>;    // Configuration of internal VLCD rail connection to optional external capacitor
            using FWDISEN = Field<0, 1>;    // Firewall disable bit
        };

        // external interrupt configuration register 1
        struct EXTICR1 : public Register<0x40010008> {
            using EXTI3 = Field<12, 4>;    // EXTI x configuration (x = 0 to 3)
            using EXTI2 = Field<8, 4>;    // EXTI x configuration (x = 0 to 3)
            using EXTI1 = Field<4, 4>;    // EXTI x configuration (x = 0 to 3)
            using EXTI0 = Field<0, 4>;    // EXTI x configuration (x = 0 to 3)
        };

        // external interrupt configuration register 2
        struct EXTICR2 : public Register<0x4001000c> {
            using EXTI7 = Field<12, 4>;    // EXTI x configuration (x = 4 to 7)
            using EXTI6 = Field<8, 4>;    // EXTI x configuration (x = 4 to 7)
            using EXTI5 = Field<4, 4>;    // EXTI x configuration (x = 4 to 7)
            using EXTI4 = Field<0, 4>;    // EXTI x configuration (x = 4 to 7)
        };

        // external interrupt configuration register 3
        struct EXTICR3 : public Register<0x40010010> {
            using EXTI11 = Field<12, 4>;    // EXTI x configuration (x = 8 to 11)
            using EXTI10 = Field<8, 4>;    // EXTI10
            using EXTI9 = Field<4, 4>;    // EXTI x configuration (x = 8 to 11)
            using EXTI8 = Field<0, 4>;    // EXTI x configuration (x = 8 to 11)
        };

        // external interrupt configuration register 4
        struct EXTICR4 : public Register<0x40010014> {
            using EXTI15 = Field<12, 4>;    // EXTI x configuration (x = 12 to 15)
            using EXTI14 = Field<8, 4>;    // EXTI14
            using EXTI13 = Field<4, 4>;    // EXTI13
            using EXTI12 = Field<0, 4>;    // EXTI12
        };

        // SYSCFG configuration register 3
        struct CFGR3 : public Register<0x40010020> {
            using REF_LOCK = Field<31, 1>;    // REF_CTRL lock bit
            using VREFINT_RDYF = Field<30, 1>;    // VREFINT ready flag
            using VREFINT_COMP_RDYF = Field<29, 1>;    // VREFINT for comparator ready flag
            using VREFINT_ADC_RDYF = Field<28, 1>;    // VREFINT for ADC ready flag
            using SENSOR_ADC_RDYF = Field<27, 1>;    // Sensor for ADC ready flag
            using REF_RC48MHz_RDYF = Field<26, 1>;    // VREFINT for 48 MHz RC oscillator ready flag
            using ENREF_RC48MHz = Field<13, 1>;    // VREFINT reference for 48 MHz RC oscillator enable bit
            using ENBUF_VREFINT_COMP = Field<12, 1>;    // VREFINT reference for comparator 2 enable bit
            using ENBUF_SENSOR_ADC = Field<9, 1>;    // Sensor reference for ADC enable bit
            using ENBUF_BGAP_ADC = Field<8, 1>;    // VREFINT reference for ADC enable bit
            using SEL_VREF_OUT = Field<4, 2>;    // BGAP_ADC connection bit
            using EN_BGAP = Field<0, 1>;    // Vref Enable bit
        };

        // Comparator 1 control and status register
        struct COMP1_CTRL : public Register<0x40010018> {
            using COMP1EN = Field<0, 1>;    // Comparator 1 enable bit
            using COMP1INNSEL = Field<4, 2>;    // Comparator 1 Input Minus connection configuration bit
            using COMP1WM = Field<8, 1>;    // Comparator 1 window mode selection bit
            using COMP1LPTIMIN1 = Field<12, 1>;    // Comparator 1 LPTIM input propagation bit
            using COMP1POLARITY = Field<15, 1>;    // Comparator 1 polarity selection bit
            using COMP1VALUE = Field<30, 1>;    // Comparator 1 output status bit
            using COMP1LOCK = Field<31, 1>;    // COMP1_CSR register lock bit
        };

        // Comparator 2 control and status register
        struct COMP2_CTRL : public Register<0x4001001c> {
            using COMP2EN = Field<0, 1>;    // Comparator 2 enable bit
            using COMP2SPEED = Field<3, 1>;    // Comparator 2 power mode selection bit
            using COMP2INNSEL = Field<4, 3>;    // Comparator 2 Input Minus connection configuration bit
            using COMP2INPSEL = Field<8, 3>;    // Comparator 2 Input Plus connection configuration bit
            using COMP2LPTIMIN2 = Field<12, 1>;    // Comparator 2 LPTIM input 2 propagation bit
            using COMP2LPTIMIN1 = Field<13, 1>;    // Comparator 2 LPTIM input 1 propagation bit
            using COMP2POLARITY = Field<15, 1>;    // Comparator 2 polarity selection bit
            using COMP2VALUE = Field<30, 1>;    // Comparator 2 output status bit
            using COMP2LOCK = Field<31, 1>;    // COMP2_CSR register lock bit
        };

    };

    // Serial peripheral interface
    struct SPI1 {
        // control register 1
        struct CR1 : public Register<0x40013000> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using DFF = Field<11, 1>;    // Data frame format
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40013004> {
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using SSOE = Field<2, 1>;    // SS output enable
            using FRF = Field<4, 1>;    // Frame format
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
        };

        // status register
        struct SR : public Register<0x40013008> {
            using RXNE = Field<0, 1>;    // Receive buffer not empty
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using CHSIDE = Field<2, 1>;    // Channel side
            using UDR = Field<3, 1>;    // Underrun flag
            using CRCERR = Field<4, 1>;    // CRC error flag
            using MODF = Field<5, 1>;    // Mode fault
            using OVR = Field<6, 1>;    // Overrun flag
            using BSY = Field<7, 1>;    // Busy flag
            using TIFRFE = Field<8, 1>;    // TI frame format error
        };

        // data register
        struct DR : public Register<0x4001300c> {
            using DR = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40013010> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public Register<0x40013014> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public Register<0x40013018> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

        // I2S configuration register
        struct I2SCFGR : public Register<0x4001301c> {
            using I2SMOD = Field<11, 1>;    // I2S mode selection
            using I2SE = Field<10, 1>;    // I2S Enable
            using I2SCFG = Field<8, 2>;    // I2S configuration mode
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using CKPOL = Field<3, 1>;    // Steady state clock polarity
            using DATLEN = Field<1, 2>;    // Data length to be transferred
            using CHLEN = Field<0, 1>;    // Channel length (number of bits per audio channel)
        };

        // I2S prescaler register
        struct I2SPR : public Register<0x40013020> {
            using MCKOE = Field<9, 1>;    // Master clock output enable
            using ODD = Field<8, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<0, 8>;    // I2S Linear prescaler
        };

    };

    // Serial peripheral interface
    struct SPI2 {
        // control register 1
        struct CR1 : public Register<0x40003800> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using DFF = Field<11, 1>;    // Data frame format
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40003804> {
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using SSOE = Field<2, 1>;    // SS output enable
            using FRF = Field<4, 1>;    // Frame format
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
        };

        // status register
        struct SR : public Register<0x40003808> {
            using RXNE = Field<0, 1>;    // Receive buffer not empty
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using CHSIDE = Field<2, 1>;    // Channel side
            using UDR = Field<3, 1>;    // Underrun flag
            using CRCERR = Field<4, 1>;    // CRC error flag
            using MODF = Field<5, 1>;    // Mode fault
            using OVR = Field<6, 1>;    // Overrun flag
            using BSY = Field<7, 1>;    // Busy flag
            using TIFRFE = Field<8, 1>;    // TI frame format error
        };

        // data register
        struct DR : public Register<0x4000380c> {
            using DR = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40003810> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public Register<0x40003814> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public Register<0x40003818> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

        // I2S configuration register
        struct I2SCFGR : public Register<0x4000381c> {
            using I2SMOD = Field<11, 1>;    // I2S mode selection
            using I2SE = Field<10, 1>;    // I2S Enable
            using I2SCFG = Field<8, 2>;    // I2S configuration mode
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using CKPOL = Field<3, 1>;    // Steady state clock polarity
            using DATLEN = Field<1, 2>;    // Data length to be transferred
            using CHLEN = Field<0, 1>;    // Channel length (number of bits per audio channel)
        };

        // I2S prescaler register
        struct I2SPR : public Register<0x40003820> {
            using MCKOE = Field<9, 1>;    // Master clock output enable
            using ODD = Field<8, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<0, 8>;    // I2S Linear prescaler
        };

    };

    // Inter-integrated circuit
    struct I2C1 {
        // Control register 1
        struct CR1 : public Register<0x40005400> {
            using PE = Field<0, 1>;    // Peripheral enable
            using TXIE = Field<1, 1>;    // TX Interrupt enable
            using RXIE = Field<2, 1>;    // RX Interrupt enable
            using ADDRIE = Field<3, 1>;    // Address match interrupt enable (slave only)
            using NACKIE = Field<4, 1>;    // Not acknowledge received interrupt enable
            using STOPIE = Field<5, 1>;    // STOP detection Interrupt enable
            using TCIE = Field<6, 1>;    // Transfer Complete interrupt enable
            using ERRIE = Field<7, 1>;    // Error interrupts enable
            using DNF = Field<8, 4>;    // Digital noise filter
            using ANFOFF = Field<12, 1>;    // Analog noise filter OFF
            using TXDMAEN = Field<14, 1>;    // DMA transmission requests enable
            using RXDMAEN = Field<15, 1>;    // DMA reception requests enable
            using SBC = Field<16, 1>;    // Slave byte control
            using NOSTRETCH = Field<17, 1>;    // Clock stretching disable
            using WUPEN = Field<18, 1>;    // Wakeup from STOP enable
            using GCEN = Field<19, 1>;    // General call enable
            using SMBHEN = Field<20, 1>;    // SMBus Host address enable
            using SMBDEN = Field<21, 1>;    // SMBus Device Default address enable
            using ALERTEN = Field<22, 1>;    // SMBUS alert enable
            using PECEN = Field<23, 1>;    // PEC enable
        };

        // Control register 2
        struct CR2 : public Register<0x40005404> {
            using PECBYTE = Field<26, 1>;    // Packet error checking byte
            using AUTOEND = Field<25, 1>;    // Automatic end mode (master mode)
            using RELOAD = Field<24, 1>;    // NBYTES reload mode
            using NBYTES = Field<16, 8>;    // Number of bytes
            using NACK = Field<15, 1>;    // NACK generation (slave mode)
            using STOP = Field<14, 1>;    // Stop generation (master mode)
            using START = Field<13, 1>;    // Start generation
            using HEAD10R = Field<12, 1>;    // 10-bit address header only read direction (master receiver mode)
            using ADD10 = Field<11, 1>;    // 10-bit addressing mode (master mode)
            using RD_WRN = Field<10, 1>;    // Transfer direction (master mode)
            using SADD = Field<0, 10>;    // Slave address bit (master mode)
        };

        // Own address register 1
        struct OAR1 : public Register<0x40005408> {
            using OA1 = Field<0, 10>;    // Interface address
            using OA1MODE = Field<10, 1>;    // Own Address 1 10-bit mode
            using OA1EN = Field<15, 1>;    // Own Address 1 enable
        };

        // Own address register 2
        struct OAR2 : public Register<0x4000540c> {
            using OA2 = Field<1, 7>;    // Interface address
            using OA2MSK = Field<8, 3>;    // Own Address 2 masks
            using OA2EN = Field<15, 1>;    // Own Address 2 enable
        };

        // Timing register
        struct TIMINGR : public Register<0x40005410> {
            using SCLL = Field<0, 8>;    // SCL low period (master mode)
            using SCLH = Field<8, 8>;    // SCL high period (master mode)
            using SDADEL = Field<16, 4>;    // Data hold time
            using SCLDEL = Field<20, 4>;    // Data setup time
            using PRESC = Field<28, 4>;    // Timing prescaler
        };

        // Status register 1
        struct TIMEOUTR : public Register<0x40005414> {
            using TIMEOUTA = Field<0, 12>;    // Bus timeout A
            using TIDLE = Field<12, 1>;    // Idle clock timeout detection
            using TIMOUTEN = Field<15, 1>;    // Clock timeout enable
            using TIMEOUTB = Field<16, 12>;    // Bus timeout B
            using TEXTEN = Field<31, 1>;    // Extended clock timeout enable
        };

        // Interrupt and Status register
        struct ISR : public Register<0x40005418> {
            using ADDCODE = Field<17, 7>;    // Address match code (Slave mode)
            using DIR = Field<16, 1>;    // Transfer direction (Slave mode)
            using BUSY = Field<15, 1>;    // Bus busy
            using ALERT = Field<13, 1>;    // SMBus alert
            using TIMEOUT = Field<12, 1>;    // Timeout or t_low detection flag
            using PECERR = Field<11, 1>;    // PEC Error in reception
            using OVR = Field<10, 1>;    // Overrun/Underrun (slave mode)
            using ARLO = Field<9, 1>;    // Arbitration lost
            using BERR = Field<8, 1>;    // Bus error
            using TCR = Field<7, 1>;    // Transfer Complete Reload
            using TC = Field<6, 1>;    // Transfer Complete (master mode)
            using STOPF = Field<5, 1>;    // Stop detection flag
            using NACKF = Field<4, 1>;    // Not acknowledge received flag
            using ADDR = Field<3, 1>;    // Address matched (slave mode)
            using RXNE = Field<2, 1>;    // Receive data register not empty (receivers)
            using TXIS = Field<1, 1>;    // Transmit interrupt status (transmitters)
            using TXE = Field<0, 1>;    // Transmit data register empty (transmitters)
        };

        // Interrupt clear register
        struct ICR : public Register<0x4000541c> {
            using ALERTCF = Field<13, 1>;    // Alert flag clear
            using TIMOUTCF = Field<12, 1>;    // Timeout detection flag clear
            using PECCF = Field<11, 1>;    // PEC Error flag clear
            using OVRCF = Field<10, 1>;    // Overrun/Underrun flag clear
            using ARLOCF = Field<9, 1>;    // Arbitration lost flag clear
            using BERRCF = Field<8, 1>;    // Bus error flag clear
            using STOPCF = Field<5, 1>;    // Stop detection flag clear
            using NACKCF = Field<4, 1>;    // Not Acknowledge flag clear
            using ADDRCF = Field<3, 1>;    // Address Matched flag clear
        };

        // PEC register
        struct PECR : public Register<0x40005420> {
            using PEC = Field<0, 8>;    // Packet error checking register
        };

        // Receive data register
        struct RXDR : public Register<0x40005424> {
            using RXDATA = Field<0, 8>;    // 8-bit receive data
        };

        // Transmit data register
        struct TXDR : public Register<0x40005428> {
            using TXDATA = Field<0, 8>;    // 8-bit transmit data
        };

    };

    // Inter-integrated circuit
    struct I2C2 {
        // Control register 1
        struct CR1 : public Register<0x40005800> {
            using PE = Field<0, 1>;    // Peripheral enable
            using TXIE = Field<1, 1>;    // TX Interrupt enable
            using RXIE = Field<2, 1>;    // RX Interrupt enable
            using ADDRIE = Field<3, 1>;    // Address match interrupt enable (slave only)
            using NACKIE = Field<4, 1>;    // Not acknowledge received interrupt enable
            using STOPIE = Field<5, 1>;    // STOP detection Interrupt enable
            using TCIE = Field<6, 1>;    // Transfer Complete interrupt enable
            using ERRIE = Field<7, 1>;    // Error interrupts enable
            using DNF = Field<8, 4>;    // Digital noise filter
            using ANFOFF = Field<12, 1>;    // Analog noise filter OFF
            using TXDMAEN = Field<14, 1>;    // DMA transmission requests enable
            using RXDMAEN = Field<15, 1>;    // DMA reception requests enable
            using SBC = Field<16, 1>;    // Slave byte control
            using NOSTRETCH = Field<17, 1>;    // Clock stretching disable
            using WUPEN = Field<18, 1>;    // Wakeup from STOP enable
            using GCEN = Field<19, 1>;    // General call enable
            using SMBHEN = Field<20, 1>;    // SMBus Host address enable
            using SMBDEN = Field<21, 1>;    // SMBus Device Default address enable
            using ALERTEN = Field<22, 1>;    // SMBUS alert enable
            using PECEN = Field<23, 1>;    // PEC enable
        };

        // Control register 2
        struct CR2 : public Register<0x40005804> {
            using PECBYTE = Field<26, 1>;    // Packet error checking byte
            using AUTOEND = Field<25, 1>;    // Automatic end mode (master mode)
            using RELOAD = Field<24, 1>;    // NBYTES reload mode
            using NBYTES = Field<16, 8>;    // Number of bytes
            using NACK = Field<15, 1>;    // NACK generation (slave mode)
            using STOP = Field<14, 1>;    // Stop generation (master mode)
            using START = Field<13, 1>;    // Start generation
            using HEAD10R = Field<12, 1>;    // 10-bit address header only read direction (master receiver mode)
            using ADD10 = Field<11, 1>;    // 10-bit addressing mode (master mode)
            using RD_WRN = Field<10, 1>;    // Transfer direction (master mode)
            using SADD = Field<0, 10>;    // Slave address bit (master mode)
        };

        // Own address register 1
        struct OAR1 : public Register<0x40005808> {
            using OA1 = Field<0, 10>;    // Interface address
            using OA1MODE = Field<10, 1>;    // Own Address 1 10-bit mode
            using OA1EN = Field<15, 1>;    // Own Address 1 enable
        };

        // Own address register 2
        struct OAR2 : public Register<0x4000580c> {
            using OA2 = Field<1, 7>;    // Interface address
            using OA2MSK = Field<8, 3>;    // Own Address 2 masks
            using OA2EN = Field<15, 1>;    // Own Address 2 enable
        };

        // Timing register
        struct TIMINGR : public Register<0x40005810> {
            using SCLL = Field<0, 8>;    // SCL low period (master mode)
            using SCLH = Field<8, 8>;    // SCL high period (master mode)
            using SDADEL = Field<16, 4>;    // Data hold time
            using SCLDEL = Field<20, 4>;    // Data setup time
            using PRESC = Field<28, 4>;    // Timing prescaler
        };

        // Status register 1
        struct TIMEOUTR : public Register<0x40005814> {
            using TIMEOUTA = Field<0, 12>;    // Bus timeout A
            using TIDLE = Field<12, 1>;    // Idle clock timeout detection
            using TIMOUTEN = Field<15, 1>;    // Clock timeout enable
            using TIMEOUTB = Field<16, 12>;    // Bus timeout B
            using TEXTEN = Field<31, 1>;    // Extended clock timeout enable
        };

        // Interrupt and Status register
        struct ISR : public Register<0x40005818> {
            using ADDCODE = Field<17, 7>;    // Address match code (Slave mode)
            using DIR = Field<16, 1>;    // Transfer direction (Slave mode)
            using BUSY = Field<15, 1>;    // Bus busy
            using ALERT = Field<13, 1>;    // SMBus alert
            using TIMEOUT = Field<12, 1>;    // Timeout or t_low detection flag
            using PECERR = Field<11, 1>;    // PEC Error in reception
            using OVR = Field<10, 1>;    // Overrun/Underrun (slave mode)
            using ARLO = Field<9, 1>;    // Arbitration lost
            using BERR = Field<8, 1>;    // Bus error
            using TCR = Field<7, 1>;    // Transfer Complete Reload
            using TC = Field<6, 1>;    // Transfer Complete (master mode)
            using STOPF = Field<5, 1>;    // Stop detection flag
            using NACKF = Field<4, 1>;    // Not acknowledge received flag
            using ADDR = Field<3, 1>;    // Address matched (slave mode)
            using RXNE = Field<2, 1>;    // Receive data register not empty (receivers)
            using TXIS = Field<1, 1>;    // Transmit interrupt status (transmitters)
            using TXE = Field<0, 1>;    // Transmit data register empty (transmitters)
        };

        // Interrupt clear register
        struct ICR : public Register<0x4000581c> {
            using ALERTCF = Field<13, 1>;    // Alert flag clear
            using TIMOUTCF = Field<12, 1>;    // Timeout detection flag clear
            using PECCF = Field<11, 1>;    // PEC Error flag clear
            using OVRCF = Field<10, 1>;    // Overrun/Underrun flag clear
            using ARLOCF = Field<9, 1>;    // Arbitration lost flag clear
            using BERRCF = Field<8, 1>;    // Bus error flag clear
            using STOPCF = Field<5, 1>;    // Stop detection flag clear
            using NACKCF = Field<4, 1>;    // Not Acknowledge flag clear
            using ADDRCF = Field<3, 1>;    // Address Matched flag clear
        };

        // PEC register
        struct PECR : public Register<0x40005820> {
            using PEC = Field<0, 8>;    // Packet error checking register
        };

        // Receive data register
        struct RXDR : public Register<0x40005824> {
            using RXDATA = Field<0, 8>;    // 8-bit receive data
        };

        // Transmit data register
        struct TXDR : public Register<0x40005828> {
            using TXDATA = Field<0, 8>;    // 8-bit transmit data
        };

    };

    // Inter-integrated circuit
    struct I2C3 {
        // Control register 1
        struct CR1 : public Register<0x40007800> {
            using PE = Field<0, 1>;    // Peripheral enable
            using TXIE = Field<1, 1>;    // TX Interrupt enable
            using RXIE = Field<2, 1>;    // RX Interrupt enable
            using ADDRIE = Field<3, 1>;    // Address match interrupt enable (slave only)
            using NACKIE = Field<4, 1>;    // Not acknowledge received interrupt enable
            using STOPIE = Field<5, 1>;    // STOP detection Interrupt enable
            using TCIE = Field<6, 1>;    // Transfer Complete interrupt enable
            using ERRIE = Field<7, 1>;    // Error interrupts enable
            using DNF = Field<8, 4>;    // Digital noise filter
            using ANFOFF = Field<12, 1>;    // Analog noise filter OFF
            using TXDMAEN = Field<14, 1>;    // DMA transmission requests enable
            using RXDMAEN = Field<15, 1>;    // DMA reception requests enable
            using SBC = Field<16, 1>;    // Slave byte control
            using NOSTRETCH = Field<17, 1>;    // Clock stretching disable
            using WUPEN = Field<18, 1>;    // Wakeup from STOP enable
            using GCEN = Field<19, 1>;    // General call enable
            using SMBHEN = Field<20, 1>;    // SMBus Host address enable
            using SMBDEN = Field<21, 1>;    // SMBus Device Default address enable
            using ALERTEN = Field<22, 1>;    // SMBUS alert enable
            using PECEN = Field<23, 1>;    // PEC enable
        };

        // Control register 2
        struct CR2 : public Register<0x40007804> {
            using PECBYTE = Field<26, 1>;    // Packet error checking byte
            using AUTOEND = Field<25, 1>;    // Automatic end mode (master mode)
            using RELOAD = Field<24, 1>;    // NBYTES reload mode
            using NBYTES = Field<16, 8>;    // Number of bytes
            using NACK = Field<15, 1>;    // NACK generation (slave mode)
            using STOP = Field<14, 1>;    // Stop generation (master mode)
            using START = Field<13, 1>;    // Start generation
            using HEAD10R = Field<12, 1>;    // 10-bit address header only read direction (master receiver mode)
            using ADD10 = Field<11, 1>;    // 10-bit addressing mode (master mode)
            using RD_WRN = Field<10, 1>;    // Transfer direction (master mode)
            using SADD = Field<0, 10>;    // Slave address bit (master mode)
        };

        // Own address register 1
        struct OAR1 : public Register<0x40007808> {
            using OA1 = Field<0, 10>;    // Interface address
            using OA1MODE = Field<10, 1>;    // Own Address 1 10-bit mode
            using OA1EN = Field<15, 1>;    // Own Address 1 enable
        };

        // Own address register 2
        struct OAR2 : public Register<0x4000780c> {
            using OA2 = Field<1, 7>;    // Interface address
            using OA2MSK = Field<8, 3>;    // Own Address 2 masks
            using OA2EN = Field<15, 1>;    // Own Address 2 enable
        };

        // Timing register
        struct TIMINGR : public Register<0x40007810> {
            using SCLL = Field<0, 8>;    // SCL low period (master mode)
            using SCLH = Field<8, 8>;    // SCL high period (master mode)
            using SDADEL = Field<16, 4>;    // Data hold time
            using SCLDEL = Field<20, 4>;    // Data setup time
            using PRESC = Field<28, 4>;    // Timing prescaler
        };

        // Status register 1
        struct TIMEOUTR : public Register<0x40007814> {
            using TIMEOUTA = Field<0, 12>;    // Bus timeout A
            using TIDLE = Field<12, 1>;    // Idle clock timeout detection
            using TIMOUTEN = Field<15, 1>;    // Clock timeout enable
            using TIMEOUTB = Field<16, 12>;    // Bus timeout B
            using TEXTEN = Field<31, 1>;    // Extended clock timeout enable
        };

        // Interrupt and Status register
        struct ISR : public Register<0x40007818> {
            using ADDCODE = Field<17, 7>;    // Address match code (Slave mode)
            using DIR = Field<16, 1>;    // Transfer direction (Slave mode)
            using BUSY = Field<15, 1>;    // Bus busy
            using ALERT = Field<13, 1>;    // SMBus alert
            using TIMEOUT = Field<12, 1>;    // Timeout or t_low detection flag
            using PECERR = Field<11, 1>;    // PEC Error in reception
            using OVR = Field<10, 1>;    // Overrun/Underrun (slave mode)
            using ARLO = Field<9, 1>;    // Arbitration lost
            using BERR = Field<8, 1>;    // Bus error
            using TCR = Field<7, 1>;    // Transfer Complete Reload
            using TC = Field<6, 1>;    // Transfer Complete (master mode)
            using STOPF = Field<5, 1>;    // Stop detection flag
            using NACKF = Field<4, 1>;    // Not acknowledge received flag
            using ADDR = Field<3, 1>;    // Address matched (slave mode)
            using RXNE = Field<2, 1>;    // Receive data register not empty (receivers)
            using TXIS = Field<1, 1>;    // Transmit interrupt status (transmitters)
            using TXE = Field<0, 1>;    // Transmit data register empty (transmitters)
        };

        // Interrupt clear register
        struct ICR : public Register<0x4000781c> {
            using ALERTCF = Field<13, 1>;    // Alert flag clear
            using TIMOUTCF = Field<12, 1>;    // Timeout detection flag clear
            using PECCF = Field<11, 1>;    // PEC Error flag clear
            using OVRCF = Field<10, 1>;    // Overrun/Underrun flag clear
            using ARLOCF = Field<9, 1>;    // Arbitration lost flag clear
            using BERRCF = Field<8, 1>;    // Bus error flag clear
            using STOPCF = Field<5, 1>;    // Stop detection flag clear
            using NACKCF = Field<4, 1>;    // Not Acknowledge flag clear
            using ADDRCF = Field<3, 1>;    // Address Matched flag clear
        };

        // PEC register
        struct PECR : public Register<0x40007820> {
            using PEC = Field<0, 8>;    // Packet error checking register
        };

        // Receive data register
        struct RXDR : public Register<0x40007824> {
            using RXDATA = Field<0, 8>;    // 8-bit receive data
        };

        // Transmit data register
        struct TXDR : public Register<0x40007828> {
            using TXDATA = Field<0, 8>;    // 8-bit transmit data
        };

    };

    // Power control
    struct PWR {
        // power control register
        struct CR : public Register<0x40007000> {
            using LPDS = Field<0, 1>;    // Low-power deep sleep
            using PDDS = Field<1, 1>;    // Power down deepsleep
            using CWUF = Field<2, 1>;    // Clear wakeup flag
            using CSBF = Field<3, 1>;    // Clear standby flag
            using PVDE = Field<4, 1>;    // Power voltage detector enable
            using PLS = Field<5, 3>;    // PVD level selection
            using DBP = Field<8, 1>;    // Disable backup domain write protection
            using ULP = Field<9, 1>;    // Ultra-low-power mode
            using FWU = Field<10, 1>;    // Fast wakeup
            using VOS = Field<11, 2>;    // Voltage scaling range selection
            using DS_EE_KOFF = Field<13, 1>;    // Deep sleep mode with Flash memory kept off
            using LPRUN = Field<14, 1>;    // Low power run mode
        };

        // power control/status register
        struct CSR : public Register<0x40007004> {
            using BRE = Field<9, 1>;    // Backup regulator enable
            using EWUP = Field<8, 1>;    // Enable WKUP pin
            using BRR = Field<3, 1>;    // Backup regulator ready
            using PVDO = Field<2, 1>;    // PVD output
            using SBF = Field<1, 1>;    // Standby flag
            using WUF = Field<0, 1>;    // Wakeup flag
            using VOSF = Field<4, 1>;    // Voltage Scaling select flag
            using REGLPF = Field<5, 1>;    // Regulator LP flag
        };

    };

    // Flash
    struct Flash {
        // Access control register
        struct ACR : public Register<0x40022000> {
            using LATENCY = Field<0, 1>;    // Latency
            using PRFTEN = Field<1, 1>;    // Prefetch enable
            using SLEEP_PD = Field<3, 1>;    // Flash mode during Sleep
            using RUN_PD = Field<4, 1>;    // Flash mode during Run
            using DESAB_BUF = Field<5, 1>;    // Disable Buffer
            using PRE_READ = Field<6, 1>;    // Pre-read data address
        };

        // Program/erase control register
        struct PECR : public Register<0x40022004> {
            using PELOCK = Field<0, 1>;    // FLASH_PECR and data EEPROM lock
            using PRGLOCK = Field<1, 1>;    // Program memory lock
            using OPTLOCK = Field<2, 1>;    // Option bytes block lock
            using PROG = Field<3, 1>;    // Program memory selection
            using DATA = Field<4, 1>;    // Data EEPROM selection
            using FTDW = Field<8, 1>;    // Fixed time data write for Byte, Half Word and Word programming
            using ERASE = Field<9, 1>;    // Page or Double Word erase mode
            using FPRG = Field<10, 1>;    // Half Page/Double Word programming mode
            using PARALLELBANK = Field<15, 1>;    // Parallel bank mode
            using EOPIE = Field<16, 1>;    // End of programming interrupt enable
            using ERRIE = Field<17, 1>;    // Error interrupt enable
            using OBL_LAUNCH = Field<18, 1>;    // Launch the option byte loading
        };

        // Power down key register
        struct PDKEYR : public Register<0x40022008> {
            using PDKEYR = Field<0, 32>;    // RUN_PD in FLASH_ACR key
        };

        // Program/erase key register
        struct PEKEYR : public Register<0x4002200c> {
            using PEKEYR = Field<0, 32>;    // FLASH_PEC and data EEPROM key
        };

        // Program memory key register
        struct PRGKEYR : public Register<0x40022010> {
            using PRGKEYR = Field<0, 32>;    // Program memory key
        };

        // Option byte key register
        struct OPTKEYR : public Register<0x40022014> {
            using OPTKEYR = Field<0, 32>;    // Option byte key
        };

        // Status register
        struct SR : public Register<0x40022018> {
            using BSY = Field<0, 1>;    // Write/erase operations in progress
            using EOP = Field<1, 1>;    // End of operation
            using ENDHV = Field<2, 1>;    // End of high voltage
            using READY = Field<3, 1>;    // Flash memory module ready after low power mode
            using WRPERR = Field<8, 1>;    // Write protected error
            using PGAERR = Field<9, 1>;    // Programming alignment error
            using SIZERR = Field<10, 1>;    // Size error
            using OPTVERR = Field<11, 1>;    // Option validity error
            using RDERR = Field<14, 1>;    // RDERR
            using NOTZEROERR = Field<16, 1>;    // NOTZEROERR
            using FWWERR = Field<17, 1>;    // FWWERR
        };

        // Option byte register
        struct OBR : public Register<0x4002201c> {
            using RDPRT = Field<0, 8>;    // Read protection
            using BOR_LEV = Field<16, 4>;    // BOR_LEV
            using SPRMOD = Field<8, 1>;    // Selection of protection mode of WPR bits
        };

        // Write protection register
        struct WRPR : public Register<0x40022020> {
            using WRP = Field<0, 16>;    // Write protection
        };

    };

    // External interrupt/event controller
    struct EXTI {
        // Interrupt mask register (EXTI_IMR)
        struct IMR : public Register<0x40010400> {
            using IM0 = Field<0, 1>;    // Interrupt Mask on line 0
            using IM1 = Field<1, 1>;    // Interrupt Mask on line 1
            using IM2 = Field<2, 1>;    // Interrupt Mask on line 2
            using IM3 = Field<3, 1>;    // Interrupt Mask on line 3
            using IM4 = Field<4, 1>;    // Interrupt Mask on line 4
            using IM5 = Field<5, 1>;    // Interrupt Mask on line 5
            using IM6 = Field<6, 1>;    // Interrupt Mask on line 6
            using IM7 = Field<7, 1>;    // Interrupt Mask on line 7
            using IM8 = Field<8, 1>;    // Interrupt Mask on line 8
            using IM9 = Field<9, 1>;    // Interrupt Mask on line 9
            using IM10 = Field<10, 1>;    // Interrupt Mask on line 10
            using IM11 = Field<11, 1>;    // Interrupt Mask on line 11
            using IM12 = Field<12, 1>;    // Interrupt Mask on line 12
            using IM13 = Field<13, 1>;    // Interrupt Mask on line 13
            using IM14 = Field<14, 1>;    // Interrupt Mask on line 14
            using IM15 = Field<15, 1>;    // Interrupt Mask on line 15
            using IM16 = Field<16, 1>;    // Interrupt Mask on line 16
            using IM17 = Field<17, 1>;    // Interrupt Mask on line 17
            using IM18 = Field<18, 1>;    // Interrupt Mask on line 18
            using IM19 = Field<19, 1>;    // Interrupt Mask on line 19
            using IM20 = Field<20, 1>;    // Interrupt Mask on line 20
            using IM21 = Field<21, 1>;    // Interrupt Mask on line 21
            using IM22 = Field<22, 1>;    // Interrupt Mask on line 22
            using IM23 = Field<23, 1>;    // Interrupt Mask on line 23
            using IM24 = Field<24, 1>;    // Interrupt Mask on line 24
            using IM25 = Field<25, 1>;    // Interrupt Mask on line 25
            using IM26 = Field<26, 1>;    // Interrupt Mask on line 27
            using IM28 = Field<28, 1>;    // Interrupt Mask on line 27
            using IM29 = Field<29, 1>;    // Interrupt Mask on line 27
        };

        // Event mask register (EXTI_EMR)
        struct EMR : public Register<0x40010404> {
            using EM0 = Field<0, 1>;    // Event Mask on line 0
            using EM1 = Field<1, 1>;    // Event Mask on line 1
            using EM2 = Field<2, 1>;    // Event Mask on line 2
            using EM3 = Field<3, 1>;    // Event Mask on line 3
            using EM4 = Field<4, 1>;    // Event Mask on line 4
            using EM5 = Field<5, 1>;    // Event Mask on line 5
            using EM6 = Field<6, 1>;    // Event Mask on line 6
            using EM7 = Field<7, 1>;    // Event Mask on line 7
            using EM8 = Field<8, 1>;    // Event Mask on line 8
            using EM9 = Field<9, 1>;    // Event Mask on line 9
            using EM10 = Field<10, 1>;    // Event Mask on line 10
            using EM11 = Field<11, 1>;    // Event Mask on line 11
            using EM12 = Field<12, 1>;    // Event Mask on line 12
            using EM13 = Field<13, 1>;    // Event Mask on line 13
            using EM14 = Field<14, 1>;    // Event Mask on line 14
            using EM15 = Field<15, 1>;    // Event Mask on line 15
            using EM16 = Field<16, 1>;    // Event Mask on line 16
            using EM17 = Field<17, 1>;    // Event Mask on line 17
            using EM18 = Field<18, 1>;    // Event Mask on line 18
            using EM19 = Field<19, 1>;    // Event Mask on line 19
            using EM20 = Field<20, 1>;    // Event Mask on line 20
            using EM21 = Field<21, 1>;    // Event Mask on line 21
            using EM22 = Field<22, 1>;    // Event Mask on line 22
            using EM23 = Field<23, 1>;    // Event Mask on line 23
            using EM24 = Field<24, 1>;    // Event Mask on line 24
            using EM25 = Field<25, 1>;    // Event Mask on line 25
            using EM26 = Field<26, 1>;    // Event Mask on line 26
            using EM28 = Field<28, 1>;    // Event Mask on line 28
            using EM29 = Field<29, 1>;    // Event Mask on line 29
        };

        // Rising Trigger selection register (EXTI_RTSR)
        struct RTSR : public Register<0x40010408> {
            using RT0 = Field<0, 1>;    // Rising trigger event configuration of line 0
            using RT1 = Field<1, 1>;    // Rising trigger event configuration of line 1
            using RT2 = Field<2, 1>;    // Rising trigger event configuration of line 2
            using RT3 = Field<3, 1>;    // Rising trigger event configuration of line 3
            using RT4 = Field<4, 1>;    // Rising trigger event configuration of line 4
            using RT5 = Field<5, 1>;    // Rising trigger event configuration of line 5
            using RT6 = Field<6, 1>;    // Rising trigger event configuration of line 6
            using RT7 = Field<7, 1>;    // Rising trigger event configuration of line 7
            using RT8 = Field<8, 1>;    // Rising trigger event configuration of line 8
            using RT9 = Field<9, 1>;    // Rising trigger event configuration of line 9
            using RT10 = Field<10, 1>;    // Rising trigger event configuration of line 10
            using RT11 = Field<11, 1>;    // Rising trigger event configuration of line 11
            using RT12 = Field<12, 1>;    // Rising trigger event configuration of line 12
            using RT13 = Field<13, 1>;    // Rising trigger event configuration of line 13
            using RT14 = Field<14, 1>;    // Rising trigger event configuration of line 14
            using RT15 = Field<15, 1>;    // Rising trigger event configuration of line 15
            using RT16 = Field<16, 1>;    // Rising trigger event configuration of line 16
            using RT17 = Field<17, 1>;    // Rising trigger event configuration of line 17
            using RT19 = Field<19, 1>;    // Rising trigger event configuration of line 19
            using RT20 = Field<20, 1>;    // Rising trigger event configuration of line 20
            using RT21 = Field<21, 1>;    // Rising trigger event configuration of line 21
            using RT22 = Field<22, 1>;    // Rising trigger event configuration of line 22
        };

        // Falling Trigger selection register (EXTI_FTSR)
        struct FTSR : public Register<0x4001040c> {
            using FT0 = Field<0, 1>;    // Falling trigger event configuration of line 0
            using FT1 = Field<1, 1>;    // Falling trigger event configuration of line 1
            using FT2 = Field<2, 1>;    // Falling trigger event configuration of line 2
            using FT3 = Field<3, 1>;    // Falling trigger event configuration of line 3
            using FT4 = Field<4, 1>;    // Falling trigger event configuration of line 4
            using FT5 = Field<5, 1>;    // Falling trigger event configuration of line 5
            using FT6 = Field<6, 1>;    // Falling trigger event configuration of line 6
            using FT7 = Field<7, 1>;    // Falling trigger event configuration of line 7
            using FT8 = Field<8, 1>;    // Falling trigger event configuration of line 8
            using FT9 = Field<9, 1>;    // Falling trigger event configuration of line 9
            using FT10 = Field<10, 1>;    // Falling trigger event configuration of line 10
            using FT11 = Field<11, 1>;    // Falling trigger event configuration of line 11
            using FT12 = Field<12, 1>;    // Falling trigger event configuration of line 12
            using FT13 = Field<13, 1>;    // Falling trigger event configuration of line 13
            using FT14 = Field<14, 1>;    // Falling trigger event configuration of line 14
            using FT15 = Field<15, 1>;    // Falling trigger event configuration of line 15
            using FT16 = Field<16, 1>;    // Falling trigger event configuration of line 16
            using FT17 = Field<17, 1>;    // Falling trigger event configuration of line 17
            using FT19 = Field<19, 1>;    // Falling trigger event configuration of line 19
            using FT20 = Field<20, 1>;    // Falling trigger event configuration of line 20
            using FT21 = Field<21, 1>;    // Falling trigger event configuration of line 21
            using FT22 = Field<22, 1>;    // Falling trigger event configuration of line 22
        };

        // Software interrupt event register (EXTI_SWIER)
        struct SWIER : public Register<0x40010410> {
            using SWI0 = Field<0, 1>;    // Software Interrupt on line 0
            using SWI1 = Field<1, 1>;    // Software Interrupt on line 1
            using SWI2 = Field<2, 1>;    // Software Interrupt on line 2
            using SWI3 = Field<3, 1>;    // Software Interrupt on line 3
            using SWI4 = Field<4, 1>;    // Software Interrupt on line 4
            using SWI5 = Field<5, 1>;    // Software Interrupt on line 5
            using SWI6 = Field<6, 1>;    // Software Interrupt on line 6
            using SWI7 = Field<7, 1>;    // Software Interrupt on line 7
            using SWI8 = Field<8, 1>;    // Software Interrupt on line 8
            using SWI9 = Field<9, 1>;    // Software Interrupt on line 9
            using SWI10 = Field<10, 1>;    // Software Interrupt on line 10
            using SWI11 = Field<11, 1>;    // Software Interrupt on line 11
            using SWI12 = Field<12, 1>;    // Software Interrupt on line 12
            using SWI13 = Field<13, 1>;    // Software Interrupt on line 13
            using SWI14 = Field<14, 1>;    // Software Interrupt on line 14
            using SWI15 = Field<15, 1>;    // Software Interrupt on line 15
            using SWI16 = Field<16, 1>;    // Software Interrupt on line 16
            using SWI17 = Field<17, 1>;    // Software Interrupt on line 17
            using SWI19 = Field<19, 1>;    // Software Interrupt on line 19
            using SWI20 = Field<20, 1>;    // Software Interrupt on line 20
            using SWI21 = Field<21, 1>;    // Software Interrupt on line 21
            using SWI22 = Field<22, 1>;    // Software Interrupt on line 22
        };

        // Pending register (EXTI_PR)
        struct PR : public Register<0x40010414> {
            using PIF0 = Field<0, 1>;    // Pending bit 0
            using PIF1 = Field<1, 1>;    // Pending bit 1
            using PIF2 = Field<2, 1>;    // Pending bit 2
            using PIF3 = Field<3, 1>;    // Pending bit 3
            using PIF4 = Field<4, 1>;    // Pending bit 4
            using PIF5 = Field<5, 1>;    // Pending bit 5
            using PIF6 = Field<6, 1>;    // Pending bit 6
            using PIF7 = Field<7, 1>;    // Pending bit 7
            using PIF8 = Field<8, 1>;    // Pending bit 8
            using PIF9 = Field<9, 1>;    // Pending bit 9
            using PIF10 = Field<10, 1>;    // Pending bit 10
            using PIF11 = Field<11, 1>;    // Pending bit 11
            using PIF12 = Field<12, 1>;    // Pending bit 12
            using PIF13 = Field<13, 1>;    // Pending bit 13
            using PIF14 = Field<14, 1>;    // Pending bit 14
            using PIF15 = Field<15, 1>;    // Pending bit 15
            using PIF16 = Field<16, 1>;    // Pending bit 16
            using PIF17 = Field<17, 1>;    // Pending bit 17
            using PIF19 = Field<19, 1>;    // Pending bit 19
            using PIF20 = Field<20, 1>;    // Pending bit 20
            using PIF21 = Field<21, 1>;    // Pending bit 21
            using PIF22 = Field<22, 1>;    // Pending bit 22
        };

    };

    // Analog-to-digital converter
    struct ADC {
        // interrupt and status register
        struct ISR : public Register<0x40012400> {
            using ADRDY = Field<0, 1>;    // ADC ready
            using EOSMP = Field<1, 1>;    // End of sampling flag
            using EOC = Field<2, 1>;    // End of conversion flag
            using EOS = Field<3, 1>;    // End of sequence flag
            using OVR = Field<4, 1>;    // ADC overrun
            using AWD = Field<7, 1>;    // Analog watchdog flag
            using EOCAL = Field<11, 1>;    // End Of Calibration flag
        };

        // interrupt enable register
        struct IER : public Register<0x40012404> {
            using ADRDYIE = Field<0, 1>;    // ADC ready interrupt enable
            using EOSMPIE = Field<1, 1>;    // End of sampling flag interrupt enable
            using EOCIE = Field<2, 1>;    // End of conversion interrupt enable
            using EOSIE = Field<3, 1>;    // End of conversion sequence interrupt enable
            using OVRIE = Field<4, 1>;    // Overrun interrupt enable
            using AWDIE = Field<7, 1>;    // Analog watchdog interrupt enable
            using EOCALIE = Field<11, 1>;    // End of calibration interrupt enable
        };

        // control register
        struct CR : public Register<0x40012408> {
            using ADEN = Field<0, 1>;    // ADC enable command
            using ADDIS = Field<1, 1>;    // ADC disable command
            using ADSTART = Field<2, 1>;    // ADC start conversion command
            using ADSTP = Field<4, 1>;    // ADC stop conversion command
            using ADVREGEN = Field<28, 1>;    // ADC Voltage Regulator Enable
            using ADCAL = Field<31, 1>;    // ADC calibration
        };

        // configuration register 1
        struct CFGR1 : public Register<0x4001240c> {
            using AWDCH = Field<26, 5>;    // Analog watchdog channel selection
            using AWDEN = Field<23, 1>;    // Analog watchdog enable
            using AWDSGL = Field<22, 1>;    // Enable the watchdog on a single channel or on all channels
            using DISCEN = Field<16, 1>;    // Discontinuous mode
            using AUTOFF = Field<15, 1>;    // Auto-off mode
            using AUTDLY = Field<14, 1>;    // Auto-delayed conversion mode
            using CONT = Field<13, 1>;    // Single / continuous conversion mode
            using OVRMOD = Field<12, 1>;    // Overrun management mode
            using EXTEN = Field<10, 2>;    // External trigger enable and polarity selection
            using EXTSEL = Field<6, 3>;    // External trigger selection
            using ALIGN = Field<5, 1>;    // Data alignment
            using RES = Field<3, 2>;    // Data resolution
            using SCANDIR = Field<2, 1>;    // Scan sequence direction
            using DMACFG = Field<1, 1>;    // Direct memery access configuration
            using DMAEN = Field<0, 1>;    // Direct memory access enable
        };

        // configuration register 2
        struct CFGR2 : public Register<0x40012410> {
            using OVSE = Field<0, 1>;    // Oversampler Enable
            using OVSR = Field<2, 3>;    // Oversampling ratio
            using OVSS = Field<5, 4>;    // Oversampling shift
            using TOVS = Field<9, 1>;    // Triggered Oversampling
            using CKMODE = Field<30, 2>;    // ADC clock mode
        };

        // sampling time register
        struct SMPR : public Register<0x40012414> {
            using SMPR = Field<0, 3>;    // Sampling time selection
        };

        // watchdog threshold register
        struct TR : public Register<0x40012420> {
            using HT = Field<16, 12>;    // Analog watchdog higher threshold
            using LT = Field<0, 12>;    // Analog watchdog lower threshold
        };

        // channel selection register
        struct CHSELR : public Register<0x40012428> {
            using CHSEL18 = Field<18, 1>;    // Channel-x selection
            using CHSEL17 = Field<17, 1>;    // Channel-x selection
            using CHSEL16 = Field<16, 1>;    // Channel-x selection
            using CHSEL15 = Field<15, 1>;    // Channel-x selection
            using CHSEL14 = Field<14, 1>;    // Channel-x selection
            using CHSEL13 = Field<13, 1>;    // Channel-x selection
            using CHSEL12 = Field<12, 1>;    // Channel-x selection
            using CHSEL11 = Field<11, 1>;    // Channel-x selection
            using CHSEL10 = Field<10, 1>;    // Channel-x selection
            using CHSEL9 = Field<9, 1>;    // Channel-x selection
            using CHSEL8 = Field<8, 1>;    // Channel-x selection
            using CHSEL7 = Field<7, 1>;    // Channel-x selection
            using CHSEL6 = Field<6, 1>;    // Channel-x selection
            using CHSEL5 = Field<5, 1>;    // Channel-x selection
            using CHSEL4 = Field<4, 1>;    // Channel-x selection
            using CHSEL3 = Field<3, 1>;    // Channel-x selection
            using CHSEL2 = Field<2, 1>;    // Channel-x selection
            using CHSEL1 = Field<1, 1>;    // Channel-x selection
            using CHSEL0 = Field<0, 1>;    // Channel-x selection
        };

        // data register
        struct DR : public Register<0x40012440> {
            using DATA = Field<0, 16>;    // Converted data
        };

        // ADC Calibration factor
        struct CALFACT : public Register<0x400124b4> {
            using CALFACT = Field<0, 7>;    // Calibration factor
        };

        // ADC common configuration register
        struct CCR : public Register<0x40012708> {
            using PRESC = Field<18, 4>;    // ADC prescaler
            using VREFEN = Field<22, 1>;    // VREFINT enable
            using TSEN = Field<23, 1>;    // Temperature sensor enable
            using VLCDEN = Field<24, 1>;    // VLCD enable
            using LFMEN = Field<25, 1>;    // Low Frequency Mode enable
        };

    };

    // Debug support
    struct DBG {
        // MCU Device ID Code Register
        struct IDCODE : public Register<0x40015800> {
            using DEV_ID = Field<0, 12>;    // Device Identifier
            using REV_ID = Field<16, 16>;    // Revision Identifier
        };

        // Debug MCU Configuration Register
        struct CR : public Register<0x40015804> {
            using DBG_STOP = Field<1, 1>;    // Debug Stop Mode
            using DBG_STANDBY = Field<2, 1>;    // Debug Standby Mode
            using DBG_SLEEP = Field<0, 1>;    // Debug Sleep Mode
        };

        // APB Low Freeze Register
        struct APB1_FZ : public Register<0x40015808> {
            using DBG_TIMER2_STOP = Field<0, 1>;    // Debug Timer 2 stopped when Core is halted
            using DBG_TIMER6_STOP = Field<4, 1>;    // Debug Timer 6 stopped when Core is halted
            using DBG_RTC_STOP = Field<10, 1>;    // Debug RTC stopped when Core is halted
            using DBG_WWDG_STOP = Field<11, 1>;    // Debug Window Wachdog stopped when Core is halted
            using DBG_IWDG_STOP = Field<12, 1>;    // Debug Independent Wachdog stopped when Core is halted
            using DBG_I2C1_STOP = Field<21, 1>;    // I2C1 SMBUS timeout mode stopped when core is halted
            using DBG_I2C2_STOP = Field<22, 1>;    // I2C2 SMBUS timeout mode stopped when core is halted
            using DBG_LPTIMER_STOP = Field<31, 1>;    // LPTIM1 counter stopped when core is halted
        };

        // APB High Freeze Register
        struct APB2_FZ : public Register<0x4001580c> {
            using DBG_TIMER21_STOP = Field<2, 1>;    // Debug Timer 21 stopped when Core is halted
            using DBG_TIMER22_STO = Field<6, 1>;    // Debug Timer 22 stopped when Core is halted
        };

    };

    // General-purpose-timers
    struct TIM2 {
        // control register 1
        struct CR1 : public Register<0x40000000> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000004> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000008> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000000c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000010> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40000014> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40000018> {
            using OC2CE = Field<15, 1>;    // Output compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output compare 2 mode
            using OC2PE = Field<11, 1>;    // Output compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output compare 1 mode
            using OC1PE = Field<3, 1>;    // Output compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000018> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4000001c> {
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000001c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000020> {
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 output Polarity
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000024> {
            using CNT_H = Field<16, 16>;    // High counter value (TIM2 only)
            using CNT_L = Field<0, 16>;    // Low counter value
        };

        // prescaler
        struct PSC : public Register<0x40000028> {
            using PSC = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000002c> {
            using ARR_H = Field<16, 16>;    // High Auto-reload value (TIM2 only)
            using ARR_L = Field<0, 16>;    // Low Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000034> {
            using CCR1_H = Field<16, 16>;    // High Capture/Compare 1 value (TIM2 only)
            using CCR1_L = Field<0, 16>;    // Low Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40000038> {
            using CCR2_H = Field<16, 16>;    // High Capture/Compare 2 value (TIM2 only)
            using CCR2_L = Field<0, 16>;    // Low Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4000003c> {
            using CCR3_H = Field<16, 16>;    // High Capture/Compare value (TIM2 only)
            using CCR3_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40000040> {
            using CCR4_H = Field<16, 16>;    // High Capture/Compare value (TIM2 only)
            using CCR4_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40000048> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4000004c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // TIM2 option register
        struct OR : public Register<0x40000050> {
            using ETR_RMP = Field<0, 3>;    // Timer2 ETR remap
            using TI4_RMP = Field<3, 2>;    // Internal trigger
        };

    };

    // General-purpose-timers
    struct TIM3 {
        // control register 1
        struct CR1 : public Register<0x40000400> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000404> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000408> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000040c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000410> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40000414> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40000418> {
            using OC2CE = Field<15, 1>;    // Output compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output compare 2 mode
            using OC2PE = Field<11, 1>;    // Output compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output compare 1 mode
            using OC1PE = Field<3, 1>;    // Output compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000418> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4000041c> {
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000041c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000420> {
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 output Polarity
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000424> {
            using CNT_H = Field<16, 16>;    // High counter value (TIM2 only)
            using CNT_L = Field<0, 16>;    // Low counter value
        };

        // prescaler
        struct PSC : public Register<0x40000428> {
            using PSC = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000042c> {
            using ARR_H = Field<16, 16>;    // High Auto-reload value (TIM2 only)
            using ARR_L = Field<0, 16>;    // Low Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000434> {
            using CCR1_H = Field<16, 16>;    // High Capture/Compare 1 value (TIM2 only)
            using CCR1_L = Field<0, 16>;    // Low Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40000438> {
            using CCR2_H = Field<16, 16>;    // High Capture/Compare 2 value (TIM2 only)
            using CCR2_L = Field<0, 16>;    // Low Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4000043c> {
            using CCR3_H = Field<16, 16>;    // High Capture/Compare value (TIM2 only)
            using CCR3_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40000440> {
            using CCR4_H = Field<16, 16>;    // High Capture/Compare value (TIM2 only)
            using CCR4_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40000448> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4000044c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // TIM2 option register
        struct OR : public Register<0x40000450> {
            using ETR_RMP = Field<0, 3>;    // Timer2 ETR remap
            using TI4_RMP = Field<3, 2>;    // Internal trigger
        };

    };

    // Basic-timers
    struct TIM6 {
        // control register 1
        struct CR1 : public Register<0x40001000> {
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40001004> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000100c> {
            using UDE = Field<8, 1>;    // Update DMA request enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40001010> {
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40001014> {
            using UG = Field<0, 1>;    // Update generation
        };

        // counter
        struct CNT : public Register<0x40001024> {
            using CNT = Field<0, 16>;    // Low counter value
        };

        // prescaler
        struct PSC : public Register<0x40001028> {
            using PSC = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000102c> {
            using ARR = Field<0, 16>;    // Low Auto-reload value
        };

    };

    // Basic-timers
    struct TIM7 {
        // control register 1
        struct CR1 : public Register<0x40001400> {
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40001404> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000140c> {
            using UDE = Field<8, 1>;    // Update DMA request enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40001410> {
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40001414> {
            using UG = Field<0, 1>;    // Update generation
        };

        // counter
        struct CNT : public Register<0x40001424> {
            using CNT = Field<0, 16>;    // Low counter value
        };

        // prescaler
        struct PSC : public Register<0x40001428> {
            using PSC = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000142c> {
            using ARR = Field<0, 16>;    // Low Auto-reload value
        };

    };

    // General-purpose-timers
    struct TIM21 {
        // control register 1
        struct CR1 : public Register<0x40010800> {
            using CEN = Field<0, 1>;    // Counter enable
            using UDIS = Field<1, 1>;    // Update disable
            using URS = Field<2, 1>;    // Update request source
            using OPM = Field<3, 1>;    // One-pulse mode
            using DIR = Field<4, 1>;    // Direction
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CKD = Field<8, 2>;    // Clock division
        };

        // control register 2
        struct CR2 : public Register<0x40010804> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40010808> {
            using SMS = Field<0, 3>;    // Slave mode selection
            using TS = Field<4, 3>;    // Trigger selection
            using MSM = Field<7, 1>;    // Master/Slave mode
            using ETF = Field<8, 4>;    // External trigger filter
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ECE = Field<14, 1>;    // External clock enable
            using ETP = Field<15, 1>;    // External trigger polarity
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001080c> {
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40010810> {
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40010814> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register (output mode)
        struct CCMR1_Output : public Register<0x40010818> {
            using OC2M = Field<12, 3>;    // Output Compare 2 mode
            using OC2PE = Field<11, 1>;    // Output Compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output Compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40010818> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40010820> {
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40010824> {
            using CNT = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40010828> {
            using PSC = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001082c> {
            using ARR = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40010834> {
            using CCR1 = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40010838> {
            using CCR2 = Field<0, 16>;    // Capture/Compare 2 value
        };

        // TIM21 option register
        struct OR : public Register<0x40010850> {
            using ETR_RMP = Field<0, 2>;    // Timer21 ETR remap
            using TI1_RMP = Field<2, 3>;    // Timer21 TI1
            using TI2_RMP = Field<5, 1>;    // Timer21 TI2
        };

    };

    // General-purpose-timers
    struct TIM22 {
        // control register 1
        struct CR1 : public Register<0x40011400> {
            using CEN = Field<0, 1>;    // Counter enable
            using UDIS = Field<1, 1>;    // Update disable
            using URS = Field<2, 1>;    // Update request source
            using OPM = Field<3, 1>;    // One-pulse mode
            using DIR = Field<4, 1>;    // Direction
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CKD = Field<8, 2>;    // Clock division
        };

        // control register 2
        struct CR2 : public Register<0x40011404> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40011408> {
            using SMS = Field<0, 3>;    // Slave mode selection
            using TS = Field<4, 3>;    // Trigger selection
            using MSM = Field<7, 1>;    // Master/Slave mode
            using ETF = Field<8, 4>;    // External trigger filter
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ECE = Field<14, 1>;    // External clock enable
            using ETP = Field<15, 1>;    // External trigger polarity
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001140c> {
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40011410> {
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40011414> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register (output mode)
        struct CCMR1_Output : public Register<0x40011418> {
            using OC2M = Field<12, 3>;    // Output Compare 2 mode
            using OC2PE = Field<11, 1>;    // Output Compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output Compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40011418> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40011420> {
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40011424> {
            using CNT = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40011428> {
            using PSC = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001142c> {
            using ARR = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40011434> {
            using CCR1 = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40011438> {
            using CCR2 = Field<0, 16>;    // Capture/Compare 2 value
        };

        // TIM22 option register
        struct OR : public Register<0x40011450> {
            using ETR_RMP = Field<0, 2>;    // Timer22 ETR remap
            using TI1_RMP = Field<2, 2>;    // Timer22 TI1
        };

    };

    // Lower power Universal asynchronous receiver transmitter
    struct LPUART1 {
        // Control register 1
        struct CR1 : public Register<0x40004800> {
            using M1 = Field<28, 1>;    // Word length
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40004804> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x40004808> {
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4000480c> {
            using BRR = Field<0, 20>;    // BRR
        };

        // Request register
        struct RQR : public Register<0x40004818> {
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
        };

        // Interrupt & status register
        struct ISR : public Register<0x4000481c> {
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public Register<0x40004820> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public Register<0x40004824> {
            using RDR = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40004828> {
            using TDR = Field<0, 9>;    // Transmit data value
        };

    };

    // Nested Vectored Interrupt Controller
    struct NVIC {
        // Interrupt Set Enable Register
        struct ISER : public Register<0xe000e100> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Clear Enable Register
        struct ICER : public Register<0xe000e180> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Set-Pending Register
        struct ISPR : public Register<0xe000e200> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR : public Register<0xe000e280> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Priority Register 0
        struct IPR0 : public Register<0xe000e400> {
            using PRI_0 = Field<0, 8>;    // priority for interrupt 0
            using PRI_1 = Field<8, 8>;    // priority for interrupt 1
            using PRI_2 = Field<16, 8>;    // priority for interrupt 2
            using PRI_3 = Field<24, 8>;    // priority for interrupt 3
        };

        // Interrupt Priority Register 1
        struct IPR1 : public Register<0xe000e404> {
            using PRI_4 = Field<0, 8>;    // priority for interrupt n
            using PRI_5 = Field<8, 8>;    // priority for interrupt n
            using PRI_6 = Field<16, 8>;    // priority for interrupt n
            using PRI_7 = Field<24, 8>;    // priority for interrupt n
        };

        // Interrupt Priority Register 2
        struct IPR2 : public Register<0xe000e408> {
            using PRI_8 = Field<0, 8>;    // priority for interrupt n
            using PRI_9 = Field<8, 8>;    // priority for interrupt n
            using PRI_10 = Field<16, 8>;    // priority for interrupt n
            using PRI_11 = Field<24, 8>;    // priority for interrupt n
        };

        // Interrupt Priority Register 3
        struct IPR3 : public Register<0xe000e40c> {
            using PRI_12 = Field<0, 8>;    // priority for interrupt n
            using PRI_13 = Field<8, 8>;    // priority for interrupt n
            using PRI_14 = Field<16, 8>;    // priority for interrupt n
            using PRI_15 = Field<24, 8>;    // priority for interrupt n
        };

        // Interrupt Priority Register 4
        struct IPR4 : public Register<0xe000e410> {
            using PRI_16 = Field<0, 8>;    // priority for interrupt n
            using PRI_17 = Field<8, 8>;    // priority for interrupt n
            using PRI_18 = Field<16, 8>;    // priority for interrupt n
            using PRI_19 = Field<24, 8>;    // priority for interrupt n
        };

        // Interrupt Priority Register 5
        struct IPR5 : public Register<0xe000e414> {
            using PRI_20 = Field<0, 8>;    // priority for interrupt n
            using PRI_21 = Field<8, 8>;    // priority for interrupt n
            using PRI_22 = Field<16, 8>;    // priority for interrupt n
            using PRI_23 = Field<24, 8>;    // priority for interrupt n
        };

        // Interrupt Priority Register 6
        struct IPR6 : public Register<0xe000e418> {
            using PRI_24 = Field<0, 8>;    // priority for interrupt n
            using PRI_25 = Field<8, 8>;    // priority for interrupt n
            using PRI_26 = Field<16, 8>;    // priority for interrupt n
            using PRI_27 = Field<24, 8>;    // priority for interrupt n
        };

        // Interrupt Priority Register 7
        struct IPR7 : public Register<0xe000e41c> {
            using PRI_28 = Field<0, 8>;    // priority for interrupt n
            using PRI_29 = Field<8, 8>;    // priority for interrupt n
            using PRI_30 = Field<16, 8>;    // priority for interrupt n
            using PRI_31 = Field<24, 8>;    // priority for interrupt n
        };

    };

    // Memory protection unit
    struct MPU {
        // MPU type register
        struct MPU_TYPER : public Register<0xe000ed90> {
            using SEPARATE = Field<0, 1>;    // Separate flag
            using DREGION = Field<8, 8>;    // Number of MPU data regions
            using IREGION = Field<16, 8>;    // Number of MPU instruction regions
        };

        // MPU control register
        struct MPU_CTRL : public Register<0xe000ed94> {
            using ENABLE = Field<0, 1>;    // Enables the MPU
            using HFNMIENA = Field<1, 1>;    // Enables the operation of MPU during hard fault
            using PRIVDEFENA = Field<2, 1>;    // Enable priviliged software access to default memory map
        };

        // MPU region number register
        struct MPU_RNR : public Register<0xe000ed98> {
            using REGION = Field<0, 8>;    // MPU region
        };

        // MPU region base address register
        struct MPU_RBAR : public Register<0xe000ed9c> {
            using REGION = Field<0, 4>;    // MPU region field
            using VALID = Field<4, 1>;    // MPU region number valid
            using ADDR = Field<5, 27>;    // Region base address field
        };

        // MPU region attribute and size register
        struct MPU_RASR : public Register<0xe000eda0> {
            using ENABLE = Field<0, 1>;    // Region enable bit.
            using SIZE = Field<1, 5>;    // Size of the MPU protection region
            using SRD = Field<8, 8>;    // Subregion disable bits
            using B = Field<16, 1>;    // memory attribute
            using C = Field<17, 1>;    // memory attribute
            using S = Field<18, 1>;    // Shareable memory attribute
            using TEX = Field<19, 3>;    // memory attribute
            using AP = Field<24, 3>;    // Access permission
            using XN = Field<28, 1>;    // Instruction access disable bit
        };

    };

    // SysTick timer
    struct STK {
        // SysTick control and status register
        struct CSR : public Register<0xe000e010> {
            using ENABLE = Field<0, 1>;    // Counter enable
            using TICKINT = Field<1, 1>;    // SysTick exception request enable
            using CLKSOURCE = Field<2, 1>;    // Clock source selection
            using COUNTFLAG = Field<16, 1>;    // COUNTFLAG
        };

        // SysTick reload value register
        struct RVR : public Register<0xe000e014> {
            using RELOAD = Field<0, 24>;    // RELOAD value
        };

        // SysTick current value register
        struct CVR : public Register<0xe000e018> {
            using CURRENT = Field<0, 24>;    // Current counter value
        };

        // SysTick calibration value register
        struct CALIB : public Register<0xe000e01c> {
            using TENMS = Field<0, 24>;    // Calibration value
            using SKEW = Field<30, 1>;    // SKEW flag: Indicates whether the TENMS value is exact
            using NOREF = Field<31, 1>;    // NOREF flag. Reads as zero
        };

    };

    // System control block
    struct SCB {
        // CPUID base register
        struct CPUID : public Register<0xe000ed00> {
            using Revision = Field<0, 4>;    // Revision number
            using PartNo = Field<4, 12>;    // Part number of the processor
            using Architecture = Field<16, 4>;    // Reads as 0xF
            using Variant = Field<20, 4>;    // Variant number
            using Implementer = Field<24, 8>;    // Implementer code
        };

        // Interrupt control and state register
        struct ICSR : public Register<0xe000ed04> {
            using VECTACTIVE = Field<0, 9>;    // Active vector
            using RETTOBASE = Field<11, 1>;    // Return to base level
            using VECTPENDING = Field<12, 7>;    // Pending vector
            using ISRPENDING = Field<22, 1>;    // Interrupt pending flag
            using PENDSTCLR = Field<25, 1>;    // SysTick exception clear-pending bit
            using PENDSTSET = Field<26, 1>;    // SysTick exception set-pending bit
            using PENDSVCLR = Field<27, 1>;    // PendSV clear-pending bit
            using PENDSVSET = Field<28, 1>;    // PendSV set-pending bit
            using NMIPENDSET = Field<31, 1>;    // NMI set-pending bit.
        };

        // Vector table offset register
        struct VTOR : public Register<0xe000ed08> {
            using TBLOFF = Field<7, 25>;    // Vector table base offset field
        };

        // Application interrupt and reset control register
        struct AIRCR : public Register<0xe000ed0c> {
            using VECTCLRACTIVE = Field<1, 1>;    // VECTCLRACTIVE
            using SYSRESETREQ = Field<2, 1>;    // SYSRESETREQ
            using ENDIANESS = Field<15, 1>;    // ENDIANESS
            using VECTKEYSTAT = Field<16, 16>;    // Register key
        };

        // System control register
        struct SCR : public Register<0xe000ed10> {
            using SLEEPONEXIT = Field<1, 1>;    // SLEEPONEXIT
            using SLEEPDEEP = Field<2, 1>;    // SLEEPDEEP
            using SEVEONPEND = Field<4, 1>;    // Send Event on Pending bit
        };

        // Configuration and control register
        struct CCR : public Register<0xe000ed14> {
            using NONBASETHRDENA = Field<0, 1>;    // Configures how the processor enters Thread mode
            using USERSETMPEND = Field<1, 1>;    // USERSETMPEND
            using UNALIGN__TRP = Field<3, 1>;    // UNALIGN_ TRP
            using DIV_0_TRP = Field<4, 1>;    // DIV_0_TRP
            using BFHFNMIGN = Field<8, 1>;    // BFHFNMIGN
            using STKALIGN = Field<9, 1>;    // STKALIGN
        };

        // System handler priority registers
        struct SHPR2 : public Register<0xe000ed1c> {
            using PRI_11 = Field<24, 8>;    // Priority of system handler 11
        };

        // System handler priority registers
        struct SHPR3 : public Register<0xe000ed20> {
            using PRI_14 = Field<16, 8>;    // Priority of system handler 14
            using PRI_15 = Field<24, 8>;    // Priority of system handler 15
        };

    };

};
