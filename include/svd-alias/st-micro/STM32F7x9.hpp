// This is a file generated by svd-alias.

#pragma once

#include "svd-alias/bit-field.hpp"
#include "svd-alias/register.hpp"

struct STM32F7x9 {
    // Random number generator
    struct RNG {
        // control register
        struct CR : public Register<0x50060800> {
            using IE = Field<3, 1>;    // Interrupt enable
            using RNGEN = Field<2, 1>;    // Random number generator enable
        };

        // status register
        struct SR : public Register<0x50060804> {
            using SEIS = Field<6, 1>;    // Seed error interrupt status
            using CEIS = Field<5, 1>;    // Clock error interrupt status
            using SECS = Field<2, 1>;    // Seed error current status
            using CECS = Field<1, 1>;    // Clock error current status
            using DRDY = Field<0, 1>;    // Data ready
        };

        // data register
        struct DR : public RegisterReadOnly<0x50060808> {
            using RNDATA = Field<0, 32>;    // Random data
        };

    };

    // Hash processor
    struct HASH {
        // control register
        struct CR : public Register<0x50060400> {
            using INIT = Field<2, 1>;    // Initialize message digest calculation
            using DMAE = Field<3, 1>;    // DMA enable
            using DATATYPE = Field<4, 2>;    // Data type selection
            using MODE = Field<6, 1>;    // Mode selection
            using ALGO0 = Field<7, 1>;    // Algorithm selection
            using NBW = Field<8, 4>;    // Number of words already pushed
            using DINNE = Field<12, 1>;    // DIN not empty
            using MDMAT = Field<13, 1>;    // Multiple DMA Transfers
            using LKEY = Field<16, 1>;    // Long key selection
            using ALGO1 = Field<18, 1>;    // ALGO
        };

        // data input register
        struct DIN : public Register<0x50060404> {
            using DATAIN = Field<0, 32>;    // Data input
        };

        // start register
        struct STR : public Register<0x50060408> {
            using DCAL = Field<8, 1>;    // Digest calculation
            using NBLW = Field<0, 5>;    // Number of valid bits in the last word of the message
        };

        // digest registers
        struct HR0 : public RegisterReadOnly<0x5006040c> {
            using H0 = Field<0, 32>;    // H0
        };

        // digest registers
        struct HR1 : public RegisterReadOnly<0x50060410> {
            using H1 = Field<0, 32>;    // H1
        };

        // digest registers
        struct HR2 : public RegisterReadOnly<0x50060414> {
            using H2 = Field<0, 32>;    // H2
        };

        // digest registers
        struct HR3 : public RegisterReadOnly<0x50060418> {
            using H3 = Field<0, 32>;    // H3
        };

        // digest registers
        struct HR4 : public RegisterReadOnly<0x5006041c> {
            using H4 = Field<0, 32>;    // H4
        };

        // interrupt enable register
        struct IMR : public Register<0x50060420> {
            using DCIE = Field<1, 1>;    // Digest calculation completion interrupt enable
            using DINIE = Field<0, 1>;    // Data input interrupt enable
        };

        // status register
        struct SR : public Register<0x50060424> {
            using BUSY = Field<3, 1>;    // Busy bit
            using DMAS = Field<2, 1>;    // DMA Status
            using DCIS = Field<1, 1>;    // Digest calculation completion interrupt status
            using DINIS = Field<0, 1>;    // Data input interrupt status
        };

        // context swap registers
        struct CSR0 : public Register<0x500604f8> {
            using Field = Field<0, 32>;    // CSR0
        };

        // context swap registers
        struct CSR1 : public Register<0x500604fc> {
            using Field = Field<0, 32>;    // CSR1
        };

        // context swap registers
        struct CSR2 : public Register<0x50060500> {
            using Field = Field<0, 32>;    // CSR2
        };

        // context swap registers
        struct CSR3 : public Register<0x50060504> {
            using Field = Field<0, 32>;    // CSR3
        };

        // context swap registers
        struct CSR4 : public Register<0x50060508> {
            using Field = Field<0, 32>;    // CSR4
        };

        // context swap registers
        struct CSR5 : public Register<0x5006050c> {
            using Field = Field<0, 32>;    // CSR5
        };

        // context swap registers
        struct CSR6 : public Register<0x50060510> {
            using Field = Field<0, 32>;    // CSR6
        };

        // context swap registers
        struct CSR7 : public Register<0x50060514> {
            using Field = Field<0, 32>;    // CSR7
        };

        // context swap registers
        struct CSR8 : public Register<0x50060518> {
            using Field = Field<0, 32>;    // CSR8
        };

        // context swap registers
        struct CSR9 : public Register<0x5006051c> {
            using Field = Field<0, 32>;    // CSR9
        };

        // context swap registers
        struct CSR10 : public Register<0x50060520> {
            using Field = Field<0, 32>;    // CSR10
        };

        // context swap registers
        struct CSR11 : public Register<0x50060524> {
            using Field = Field<0, 32>;    // CSR11
        };

        // context swap registers
        struct CSR12 : public Register<0x50060528> {
            using Field = Field<0, 32>;    // CSR12
        };

        // context swap registers
        struct CSR13 : public Register<0x5006052c> {
            using Field = Field<0, 32>;    // CSR13
        };

        // context swap registers
        struct CSR14 : public Register<0x50060530> {
            using Field = Field<0, 32>;    // CSR14
        };

        // context swap registers
        struct CSR15 : public Register<0x50060534> {
            using Field = Field<0, 32>;    // CSR15
        };

        // context swap registers
        struct CSR16 : public Register<0x50060538> {
            using Field = Field<0, 32>;    // CSR16
        };

        // context swap registers
        struct CSR17 : public Register<0x5006053c> {
            using Field = Field<0, 32>;    // CSR17
        };

        // context swap registers
        struct CSR18 : public Register<0x50060540> {
            using Field = Field<0, 32>;    // CSR18
        };

        // context swap registers
        struct CSR19 : public Register<0x50060544> {
            using Field = Field<0, 32>;    // CSR19
        };

        // context swap registers
        struct CSR20 : public Register<0x50060548> {
            using Field = Field<0, 32>;    // CSR20
        };

        // context swap registers
        struct CSR21 : public Register<0x5006054c> {
            using Field = Field<0, 32>;    // CSR21
        };

        // context swap registers
        struct CSR22 : public Register<0x50060550> {
            using Field = Field<0, 32>;    // CSR22
        };

        // context swap registers
        struct CSR23 : public Register<0x50060554> {
            using Field = Field<0, 32>;    // CSR23
        };

        // context swap registers
        struct CSR24 : public Register<0x50060558> {
            using Field = Field<0, 32>;    // CSR24
        };

        // context swap registers
        struct CSR25 : public Register<0x5006055c> {
            using Field = Field<0, 32>;    // CSR25
        };

        // context swap registers
        struct CSR26 : public Register<0x50060560> {
            using Field = Field<0, 32>;    // CSR26
        };

        // context swap registers
        struct CSR27 : public Register<0x50060564> {
            using Field = Field<0, 32>;    // CSR27
        };

        // context swap registers
        struct CSR28 : public Register<0x50060568> {
            using Field = Field<0, 32>;    // CSR28
        };

        // context swap registers
        struct CSR29 : public Register<0x5006056c> {
            using Field = Field<0, 32>;    // CSR29
        };

        // context swap registers
        struct CSR30 : public Register<0x50060570> {
            using Field = Field<0, 32>;    // CSR30
        };

        // context swap registers
        struct CSR31 : public Register<0x50060574> {
            using Field = Field<0, 32>;    // CSR31
        };

        // context swap registers
        struct CSR32 : public Register<0x50060578> {
            using Field = Field<0, 32>;    // CSR32
        };

        // context swap registers
        struct CSR33 : public Register<0x5006057c> {
            using Field = Field<0, 32>;    // CSR33
        };

        // context swap registers
        struct CSR34 : public Register<0x50060580> {
            using Field = Field<0, 32>;    // CSR34
        };

        // context swap registers
        struct CSR35 : public Register<0x50060584> {
            using Field = Field<0, 32>;    // CSR35
        };

        // context swap registers
        struct CSR36 : public Register<0x50060588> {
            using Field = Field<0, 32>;    // CSR36
        };

        // context swap registers
        struct CSR37 : public Register<0x5006058c> {
            using Field = Field<0, 32>;    // CSR37
        };

        // context swap registers
        struct CSR38 : public Register<0x50060590> {
            using Field = Field<0, 32>;    // CSR38
        };

        // context swap registers
        struct CSR39 : public Register<0x50060594> {
            using Field = Field<0, 32>;    // CSR39
        };

        // context swap registers
        struct CSR40 : public Register<0x50060598> {
            using Field = Field<0, 32>;    // CSR40
        };

        // context swap registers
        struct CSR41 : public Register<0x5006059c> {
            using Field = Field<0, 32>;    // CSR41
        };

        // context swap registers
        struct CSR42 : public Register<0x500605a0> {
            using Field = Field<0, 32>;    // CSR42
        };

        // context swap registers
        struct CSR43 : public Register<0x500605a4> {
            using Field = Field<0, 32>;    // CSR43
        };

        // context swap registers
        struct CSR44 : public Register<0x500605a8> {
            using Field = Field<0, 32>;    // CSR44
        };

        // context swap registers
        struct CSR45 : public Register<0x500605ac> {
            using Field = Field<0, 32>;    // CSR45
        };

        // context swap registers
        struct CSR46 : public Register<0x500605b0> {
            using Field = Field<0, 32>;    // CSR46
        };

        // context swap registers
        struct CSR47 : public Register<0x500605b4> {
            using Field = Field<0, 32>;    // CSR47
        };

        // context swap registers
        struct CSR48 : public Register<0x500605b8> {
            using Field = Field<0, 32>;    // CSR48
        };

        // context swap registers
        struct CSR49 : public Register<0x500605bc> {
            using Field = Field<0, 32>;    // CSR49
        };

        // context swap registers
        struct CSR50 : public Register<0x500605c0> {
            using Field = Field<0, 32>;    // CSR50
        };

        // context swap registers
        struct CSR51 : public Register<0x500605c4> {
            using Field = Field<0, 32>;    // CSR51
        };

        // context swap registers
        struct CSR52 : public Register<0x500605c8> {
            using Field = Field<0, 32>;    // CSR52
        };

        // context swap registers
        struct CSR53 : public Register<0x500605cc> {
            using Field = Field<0, 32>;    // CSR53
        };

        // HASH digest register
        struct HASH_HR0 : public RegisterReadOnly<0x50060710> {
            using H0 = Field<0, 32>;    // H0
        };

        // read-only
        struct HASH_HR1 : public RegisterReadOnly<0x50060714> {
            using H1 = Field<0, 32>;    // H1
        };

        // read-only
        struct HASH_HR2 : public RegisterReadOnly<0x50060718> {
            using H2 = Field<0, 32>;    // H2
        };

        // read-only
        struct HASH_HR3 : public RegisterReadOnly<0x5006071c> {
            using H3 = Field<0, 32>;    // H3
        };

        // read-only
        struct HASH_HR4 : public RegisterReadOnly<0x50060720> {
            using H4 = Field<0, 32>;    // H4
        };

        // read-only
        struct HASH_HR5 : public RegisterReadOnly<0x50060724> {
            using H5 = Field<0, 32>;    // H5
        };

        // read-only
        struct HASH_HR6 : public RegisterReadOnly<0x50060728> {
            using H6 = Field<0, 32>;    // H6
        };

        // read-only
        struct HASH_HR7 : public RegisterReadOnly<0x5006072c> {
            using H7 = Field<0, 32>;    // H7
        };

    };

    // Cryptographic processor
    struct CRYP {
        // control register
        struct CR : public Register<0x50060000> {
            using ALGODIR = Field<2, 1>;    // Algorithm direction
            using ALGOMODE0 = Field<3, 3>;    // Algorithm mode
            using DATATYPE = Field<6, 2>;    // Data type selection
            using KEYSIZE = Field<8, 2>;    // Key size selection (AES mode only)
            using FFLUSH = Field<14, 1>;    // FIFO flush
            using CRYPEN = Field<15, 1>;    // Cryptographic processor enable
            using GCM_CCMPH = Field<16, 2>;    // GCM_CCMPH
            using ALGOMODE3 = Field<19, 1>;    // ALGOMODE
        };

        // status register
        struct SR : public RegisterReadOnly<0x50060004> {
            using BUSY = Field<4, 1>;    // Busy bit
            using OFFU = Field<3, 1>;    // Output FIFO full
            using OFNE = Field<2, 1>;    // Output FIFO not empty
            using IFNF = Field<1, 1>;    // Input FIFO not full
            using IFEM = Field<0, 1>;    // Input FIFO empty
        };

        // data input register
        struct DIN : public Register<0x50060008> {
            using DATAIN = Field<0, 32>;    // Data input
        };

        // data output register
        struct DOUT : public RegisterReadOnly<0x5006000c> {
            using DATAOUT = Field<0, 32>;    // Data output
        };

        // DMA control register
        struct DMACR : public Register<0x50060010> {
            using DOEN = Field<1, 1>;    // DMA output enable
            using DIEN = Field<0, 1>;    // DMA input enable
        };

        // interrupt mask set/clear register
        struct IMSCR : public Register<0x50060014> {
            using OUTIM = Field<1, 1>;    // Output FIFO service interrupt mask
            using INIM = Field<0, 1>;    // Input FIFO service interrupt mask
        };

        // raw interrupt status register
        struct RISR : public RegisterReadOnly<0x50060018> {
            using OUTRIS = Field<1, 1>;    // Output FIFO service raw interrupt status
            using INRIS = Field<0, 1>;    // Input FIFO service raw interrupt status
        };

        // masked interrupt status register
        struct MISR : public RegisterReadOnly<0x5006001c> {
            using OUTMIS = Field<1, 1>;    // Output FIFO service masked interrupt status
            using INMIS = Field<0, 1>;    // Input FIFO service masked interrupt status
        };

        // key registers
        struct K0LR : public RegisterWriteOnly<0x50060020> {
            using b224 = Field<0, 1>;    // b224
            using b225 = Field<1, 1>;    // b225
            using b226 = Field<2, 1>;    // b226
            using b227 = Field<3, 1>;    // b227
            using b228 = Field<4, 1>;    // b228
            using b229 = Field<5, 1>;    // b229
            using b230 = Field<6, 1>;    // b230
            using b231 = Field<7, 1>;    // b231
            using b232 = Field<8, 1>;    // b232
            using b233 = Field<9, 1>;    // b233
            using b234 = Field<10, 1>;    // b234
            using b235 = Field<11, 1>;    // b235
            using b236 = Field<12, 1>;    // b236
            using b237 = Field<13, 1>;    // b237
            using b238 = Field<14, 1>;    // b238
            using b239 = Field<15, 1>;    // b239
            using b240 = Field<16, 1>;    // b240
            using b241 = Field<17, 1>;    // b241
            using b242 = Field<18, 1>;    // b242
            using b243 = Field<19, 1>;    // b243
            using b244 = Field<20, 1>;    // b244
            using b245 = Field<21, 1>;    // b245
            using b246 = Field<22, 1>;    // b246
            using b247 = Field<23, 1>;    // b247
            using b248 = Field<24, 1>;    // b248
            using b249 = Field<25, 1>;    // b249
            using b250 = Field<26, 1>;    // b250
            using b251 = Field<27, 1>;    // b251
            using b252 = Field<28, 1>;    // b252
            using b253 = Field<29, 1>;    // b253
            using b254 = Field<30, 1>;    // b254
            using b255 = Field<31, 1>;    // b255
        };

        // key registers
        struct K0RR : public RegisterWriteOnly<0x50060024> {
            using b192 = Field<0, 1>;    // b192
            using b193 = Field<1, 1>;    // b193
            using b194 = Field<2, 1>;    // b194
            using b195 = Field<3, 1>;    // b195
            using b196 = Field<4, 1>;    // b196
            using b197 = Field<5, 1>;    // b197
            using b198 = Field<6, 1>;    // b198
            using b199 = Field<7, 1>;    // b199
            using b200 = Field<8, 1>;    // b200
            using b201 = Field<9, 1>;    // b201
            using b202 = Field<10, 1>;    // b202
            using b203 = Field<11, 1>;    // b203
            using b204 = Field<12, 1>;    // b204
            using b205 = Field<13, 1>;    // b205
            using b206 = Field<14, 1>;    // b206
            using b207 = Field<15, 1>;    // b207
            using b208 = Field<16, 1>;    // b208
            using b209 = Field<17, 1>;    // b209
            using b210 = Field<18, 1>;    // b210
            using b211 = Field<19, 1>;    // b211
            using b212 = Field<20, 1>;    // b212
            using b213 = Field<21, 1>;    // b213
            using b214 = Field<22, 1>;    // b214
            using b215 = Field<23, 1>;    // b215
            using b216 = Field<24, 1>;    // b216
            using b217 = Field<25, 1>;    // b217
            using b218 = Field<26, 1>;    // b218
            using b219 = Field<27, 1>;    // b219
            using b220 = Field<28, 1>;    // b220
            using b221 = Field<29, 1>;    // b221
            using b222 = Field<30, 1>;    // b222
            using b223 = Field<31, 1>;    // b223
        };

        // key registers
        struct K1LR : public RegisterWriteOnly<0x50060028> {
            using b160 = Field<0, 1>;    // b160
            using b161 = Field<1, 1>;    // b161
            using b162 = Field<2, 1>;    // b162
            using b163 = Field<3, 1>;    // b163
            using b164 = Field<4, 1>;    // b164
            using b165 = Field<5, 1>;    // b165
            using b166 = Field<6, 1>;    // b166
            using b167 = Field<7, 1>;    // b167
            using b168 = Field<8, 1>;    // b168
            using b169 = Field<9, 1>;    // b169
            using b170 = Field<10, 1>;    // b170
            using b171 = Field<11, 1>;    // b171
            using b172 = Field<12, 1>;    // b172
            using b173 = Field<13, 1>;    // b173
            using b174 = Field<14, 1>;    // b174
            using b175 = Field<15, 1>;    // b175
            using b176 = Field<16, 1>;    // b176
            using b177 = Field<17, 1>;    // b177
            using b178 = Field<18, 1>;    // b178
            using b179 = Field<19, 1>;    // b179
            using b180 = Field<20, 1>;    // b180
            using b181 = Field<21, 1>;    // b181
            using b182 = Field<22, 1>;    // b182
            using b183 = Field<23, 1>;    // b183
            using b184 = Field<24, 1>;    // b184
            using b185 = Field<25, 1>;    // b185
            using b186 = Field<26, 1>;    // b186
            using b187 = Field<27, 1>;    // b187
            using b188 = Field<28, 1>;    // b188
            using b189 = Field<29, 1>;    // b189
            using b190 = Field<30, 1>;    // b190
            using b191 = Field<31, 1>;    // b191
        };

        // key registers
        struct K1RR : public RegisterWriteOnly<0x5006002c> {
            using b128 = Field<0, 1>;    // b128
            using b129 = Field<1, 1>;    // b129
            using b130 = Field<2, 1>;    // b130
            using b131 = Field<3, 1>;    // b131
            using b132 = Field<4, 1>;    // b132
            using b133 = Field<5, 1>;    // b133
            using b134 = Field<6, 1>;    // b134
            using b135 = Field<7, 1>;    // b135
            using b136 = Field<8, 1>;    // b136
            using b137 = Field<9, 1>;    // b137
            using b138 = Field<10, 1>;    // b138
            using b139 = Field<11, 1>;    // b139
            using b140 = Field<12, 1>;    // b140
            using b141 = Field<13, 1>;    // b141
            using b142 = Field<14, 1>;    // b142
            using b143 = Field<15, 1>;    // b143
            using b144 = Field<16, 1>;    // b144
            using b145 = Field<17, 1>;    // b145
            using b146 = Field<18, 1>;    // b146
            using b147 = Field<19, 1>;    // b147
            using b148 = Field<20, 1>;    // b148
            using b149 = Field<21, 1>;    // b149
            using b150 = Field<22, 1>;    // b150
            using b151 = Field<23, 1>;    // b151
            using b152 = Field<24, 1>;    // b152
            using b153 = Field<25, 1>;    // b153
            using b154 = Field<26, 1>;    // b154
            using b155 = Field<27, 1>;    // b155
            using b156 = Field<28, 1>;    // b156
            using b157 = Field<29, 1>;    // b157
            using b158 = Field<30, 1>;    // b158
            using b159 = Field<31, 1>;    // b159
        };

        // key registers
        struct K2LR : public RegisterWriteOnly<0x50060030> {
            using b96 = Field<0, 1>;    // b96
            using b97 = Field<1, 1>;    // b97
            using b98 = Field<2, 1>;    // b98
            using b99 = Field<3, 1>;    // b99
            using b100 = Field<4, 1>;    // b100
            using b101 = Field<5, 1>;    // b101
            using b102 = Field<6, 1>;    // b102
            using b103 = Field<7, 1>;    // b103
            using b104 = Field<8, 1>;    // b104
            using b105 = Field<9, 1>;    // b105
            using b106 = Field<10, 1>;    // b106
            using b107 = Field<11, 1>;    // b107
            using b108 = Field<12, 1>;    // b108
            using b109 = Field<13, 1>;    // b109
            using b110 = Field<14, 1>;    // b110
            using b111 = Field<15, 1>;    // b111
            using b112 = Field<16, 1>;    // b112
            using b113 = Field<17, 1>;    // b113
            using b114 = Field<18, 1>;    // b114
            using b115 = Field<19, 1>;    // b115
            using b116 = Field<20, 1>;    // b116
            using b117 = Field<21, 1>;    // b117
            using b118 = Field<22, 1>;    // b118
            using b119 = Field<23, 1>;    // b119
            using b120 = Field<24, 1>;    // b120
            using b121 = Field<25, 1>;    // b121
            using b122 = Field<26, 1>;    // b122
            using b123 = Field<27, 1>;    // b123
            using b124 = Field<28, 1>;    // b124
            using b125 = Field<29, 1>;    // b125
            using b126 = Field<30, 1>;    // b126
            using b127 = Field<31, 1>;    // b127
        };

        // key registers
        struct K2RR : public RegisterWriteOnly<0x50060034> {
            using b64 = Field<0, 1>;    // b64
            using b65 = Field<1, 1>;    // b65
            using b66 = Field<2, 1>;    // b66
            using b67 = Field<3, 1>;    // b67
            using b68 = Field<4, 1>;    // b68
            using b69 = Field<5, 1>;    // b69
            using b70 = Field<6, 1>;    // b70
            using b71 = Field<7, 1>;    // b71
            using b72 = Field<8, 1>;    // b72
            using b73 = Field<9, 1>;    // b73
            using b74 = Field<10, 1>;    // b74
            using b75 = Field<11, 1>;    // b75
            using b76 = Field<12, 1>;    // b76
            using b77 = Field<13, 1>;    // b77
            using b78 = Field<14, 1>;    // b78
            using b79 = Field<15, 1>;    // b79
            using b80 = Field<16, 1>;    // b80
            using b81 = Field<17, 1>;    // b81
            using b82 = Field<18, 1>;    // b82
            using b83 = Field<19, 1>;    // b83
            using b84 = Field<20, 1>;    // b84
            using b85 = Field<21, 1>;    // b85
            using b86 = Field<22, 1>;    // b86
            using b87 = Field<23, 1>;    // b87
            using b88 = Field<24, 1>;    // b88
            using b89 = Field<25, 1>;    // b89
            using b90 = Field<26, 1>;    // b90
            using b91 = Field<27, 1>;    // b91
            using b92 = Field<28, 1>;    // b92
            using b93 = Field<29, 1>;    // b93
            using b94 = Field<30, 1>;    // b94
            using b95 = Field<31, 1>;    // b95
        };

        // key registers
        struct K3LR : public RegisterWriteOnly<0x50060038> {
            using b32 = Field<0, 1>;    // b32
            using b33 = Field<1, 1>;    // b33
            using b34 = Field<2, 1>;    // b34
            using b35 = Field<3, 1>;    // b35
            using b36 = Field<4, 1>;    // b36
            using b37 = Field<5, 1>;    // b37
            using b38 = Field<6, 1>;    // b38
            using b39 = Field<7, 1>;    // b39
            using b40 = Field<8, 1>;    // b40
            using b41 = Field<9, 1>;    // b41
            using b42 = Field<10, 1>;    // b42
            using b43 = Field<11, 1>;    // b43
            using b44 = Field<12, 1>;    // b44
            using b45 = Field<13, 1>;    // b45
            using b46 = Field<14, 1>;    // b46
            using b47 = Field<15, 1>;    // b47
            using b48 = Field<16, 1>;    // b48
            using b49 = Field<17, 1>;    // b49
            using b50 = Field<18, 1>;    // b50
            using b51 = Field<19, 1>;    // b51
            using b52 = Field<20, 1>;    // b52
            using b53 = Field<21, 1>;    // b53
            using b54 = Field<22, 1>;    // b54
            using b55 = Field<23, 1>;    // b55
            using b56 = Field<24, 1>;    // b56
            using b57 = Field<25, 1>;    // b57
            using b58 = Field<26, 1>;    // b58
            using b59 = Field<27, 1>;    // b59
            using b60 = Field<28, 1>;    // b60
            using b61 = Field<29, 1>;    // b61
            using b62 = Field<30, 1>;    // b62
            using b63 = Field<31, 1>;    // b63
        };

        // key registers
        struct K3RR : public RegisterWriteOnly<0x5006003c> {
            using b0 = Field<0, 1>;    // b0
            using b1 = Field<1, 1>;    // b1
            using b2 = Field<2, 1>;    // b2
            using b3 = Field<3, 1>;    // b3
            using b4 = Field<4, 1>;    // b4
            using b5 = Field<5, 1>;    // b5
            using b6 = Field<6, 1>;    // b6
            using b7 = Field<7, 1>;    // b7
            using b8 = Field<8, 1>;    // b8
            using b9 = Field<9, 1>;    // b9
            using b10 = Field<10, 1>;    // b10
            using b11 = Field<11, 1>;    // b11
            using b12 = Field<12, 1>;    // b12
            using b13 = Field<13, 1>;    // b13
            using b14 = Field<14, 1>;    // b14
            using b15 = Field<15, 1>;    // b15
            using b16 = Field<16, 1>;    // b16
            using b17 = Field<17, 1>;    // b17
            using b18 = Field<18, 1>;    // b18
            using b19 = Field<19, 1>;    // b19
            using b20 = Field<20, 1>;    // b20
            using b21 = Field<21, 1>;    // b21
            using b22 = Field<22, 1>;    // b22
            using b23 = Field<23, 1>;    // b23
            using b24 = Field<24, 1>;    // b24
            using b25 = Field<25, 1>;    // b25
            using b26 = Field<26, 1>;    // b26
            using b27 = Field<27, 1>;    // b27
            using b28 = Field<28, 1>;    // b28
            using b29 = Field<29, 1>;    // b29
            using b30 = Field<30, 1>;    // b30
            using b31 = Field<31, 1>;    // b31
        };

        // initialization vector registers
        struct IV0LR : public Register<0x50060040> {
            using IV31 = Field<0, 1>;    // IV31
            using IV30 = Field<1, 1>;    // IV30
            using IV29 = Field<2, 1>;    // IV29
            using IV28 = Field<3, 1>;    // IV28
            using IV27 = Field<4, 1>;    // IV27
            using IV26 = Field<5, 1>;    // IV26
            using IV25 = Field<6, 1>;    // IV25
            using IV24 = Field<7, 1>;    // IV24
            using IV23 = Field<8, 1>;    // IV23
            using IV22 = Field<9, 1>;    // IV22
            using IV21 = Field<10, 1>;    // IV21
            using IV20 = Field<11, 1>;    // IV20
            using IV19 = Field<12, 1>;    // IV19
            using IV18 = Field<13, 1>;    // IV18
            using IV17 = Field<14, 1>;    // IV17
            using IV16 = Field<15, 1>;    // IV16
            using IV15 = Field<16, 1>;    // IV15
            using IV14 = Field<17, 1>;    // IV14
            using IV13 = Field<18, 1>;    // IV13
            using IV12 = Field<19, 1>;    // IV12
            using IV11 = Field<20, 1>;    // IV11
            using IV10 = Field<21, 1>;    // IV10
            using IV9 = Field<22, 1>;    // IV9
            using IV8 = Field<23, 1>;    // IV8
            using IV7 = Field<24, 1>;    // IV7
            using IV6 = Field<25, 1>;    // IV6
            using IV5 = Field<26, 1>;    // IV5
            using IV4 = Field<27, 1>;    // IV4
            using IV3 = Field<28, 1>;    // IV3
            using IV2 = Field<29, 1>;    // IV2
            using IV1 = Field<30, 1>;    // IV1
            using IV0 = Field<31, 1>;    // IV0
        };

        // initialization vector registers
        struct IV0RR : public Register<0x50060044> {
            using IV63 = Field<0, 1>;    // IV63
            using IV62 = Field<1, 1>;    // IV62
            using IV61 = Field<2, 1>;    // IV61
            using IV60 = Field<3, 1>;    // IV60
            using IV59 = Field<4, 1>;    // IV59
            using IV58 = Field<5, 1>;    // IV58
            using IV57 = Field<6, 1>;    // IV57
            using IV56 = Field<7, 1>;    // IV56
            using IV55 = Field<8, 1>;    // IV55
            using IV54 = Field<9, 1>;    // IV54
            using IV53 = Field<10, 1>;    // IV53
            using IV52 = Field<11, 1>;    // IV52
            using IV51 = Field<12, 1>;    // IV51
            using IV50 = Field<13, 1>;    // IV50
            using IV49 = Field<14, 1>;    // IV49
            using IV48 = Field<15, 1>;    // IV48
            using IV47 = Field<16, 1>;    // IV47
            using IV46 = Field<17, 1>;    // IV46
            using IV45 = Field<18, 1>;    // IV45
            using IV44 = Field<19, 1>;    // IV44
            using IV43 = Field<20, 1>;    // IV43
            using IV42 = Field<21, 1>;    // IV42
            using IV41 = Field<22, 1>;    // IV41
            using IV40 = Field<23, 1>;    // IV40
            using IV39 = Field<24, 1>;    // IV39
            using IV38 = Field<25, 1>;    // IV38
            using IV37 = Field<26, 1>;    // IV37
            using IV36 = Field<27, 1>;    // IV36
            using IV35 = Field<28, 1>;    // IV35
            using IV34 = Field<29, 1>;    // IV34
            using IV33 = Field<30, 1>;    // IV33
            using IV32 = Field<31, 1>;    // IV32
        };

        // initialization vector registers
        struct IV1LR : public Register<0x50060048> {
            using IV95 = Field<0, 1>;    // IV95
            using IV94 = Field<1, 1>;    // IV94
            using IV93 = Field<2, 1>;    // IV93
            using IV92 = Field<3, 1>;    // IV92
            using IV91 = Field<4, 1>;    // IV91
            using IV90 = Field<5, 1>;    // IV90
            using IV89 = Field<6, 1>;    // IV89
            using IV88 = Field<7, 1>;    // IV88
            using IV87 = Field<8, 1>;    // IV87
            using IV86 = Field<9, 1>;    // IV86
            using IV85 = Field<10, 1>;    // IV85
            using IV84 = Field<11, 1>;    // IV84
            using IV83 = Field<12, 1>;    // IV83
            using IV82 = Field<13, 1>;    // IV82
            using IV81 = Field<14, 1>;    // IV81
            using IV80 = Field<15, 1>;    // IV80
            using IV79 = Field<16, 1>;    // IV79
            using IV78 = Field<17, 1>;    // IV78
            using IV77 = Field<18, 1>;    // IV77
            using IV76 = Field<19, 1>;    // IV76
            using IV75 = Field<20, 1>;    // IV75
            using IV74 = Field<21, 1>;    // IV74
            using IV73 = Field<22, 1>;    // IV73
            using IV72 = Field<23, 1>;    // IV72
            using IV71 = Field<24, 1>;    // IV71
            using IV70 = Field<25, 1>;    // IV70
            using IV69 = Field<26, 1>;    // IV69
            using IV68 = Field<27, 1>;    // IV68
            using IV67 = Field<28, 1>;    // IV67
            using IV66 = Field<29, 1>;    // IV66
            using IV65 = Field<30, 1>;    // IV65
            using IV64 = Field<31, 1>;    // IV64
        };

        // initialization vector registers
        struct IV1RR : public Register<0x5006004c> {
            using IV127 = Field<0, 1>;    // IV127
            using IV126 = Field<1, 1>;    // IV126
            using IV125 = Field<2, 1>;    // IV125
            using IV124 = Field<3, 1>;    // IV124
            using IV123 = Field<4, 1>;    // IV123
            using IV122 = Field<5, 1>;    // IV122
            using IV121 = Field<6, 1>;    // IV121
            using IV120 = Field<7, 1>;    // IV120
            using IV119 = Field<8, 1>;    // IV119
            using IV118 = Field<9, 1>;    // IV118
            using IV117 = Field<10, 1>;    // IV117
            using IV116 = Field<11, 1>;    // IV116
            using IV115 = Field<12, 1>;    // IV115
            using IV114 = Field<13, 1>;    // IV114
            using IV113 = Field<14, 1>;    // IV113
            using IV112 = Field<15, 1>;    // IV112
            using IV111 = Field<16, 1>;    // IV111
            using IV110 = Field<17, 1>;    // IV110
            using IV109 = Field<18, 1>;    // IV109
            using IV108 = Field<19, 1>;    // IV108
            using IV107 = Field<20, 1>;    // IV107
            using IV106 = Field<21, 1>;    // IV106
            using IV105 = Field<22, 1>;    // IV105
            using IV104 = Field<23, 1>;    // IV104
            using IV103 = Field<24, 1>;    // IV103
            using IV102 = Field<25, 1>;    // IV102
            using IV101 = Field<26, 1>;    // IV101
            using IV100 = Field<27, 1>;    // IV100
            using IV99 = Field<28, 1>;    // IV99
            using IV98 = Field<29, 1>;    // IV98
            using IV97 = Field<30, 1>;    // IV97
            using IV96 = Field<31, 1>;    // IV96
        };

        // context swap register
        struct CSGCMCCM0R : public Register<0x50060050> {
            using Field = Field<0, 32>;    // CSGCMCCM0R
        };

        // context swap register
        struct CSGCMCCM1R : public Register<0x50060054> {
            using Field = Field<0, 32>;    // CSGCMCCM1R
        };

        // context swap register
        struct CSGCMCCM2R : public Register<0x50060058> {
            using Field = Field<0, 32>;    // CSGCMCCM2R
        };

        // context swap register
        struct CSGCMCCM3R : public Register<0x5006005c> {
            using Field = Field<0, 32>;    // CSGCMCCM3R
        };

        // context swap register
        struct CSGCMCCM4R : public Register<0x50060060> {
            using Field = Field<0, 32>;    // CSGCMCCM4R
        };

        // context swap register
        struct CSGCMCCM5R : public Register<0x50060064> {
            using Field = Field<0, 32>;    // CSGCMCCM5R
        };

        // context swap register
        struct CSGCMCCM6R : public Register<0x50060068> {
            using Field = Field<0, 32>;    // CSGCMCCM6R
        };

        // context swap register
        struct CSGCMCCM7R : public Register<0x5006006c> {
            using Field = Field<0, 32>;    // CSGCMCCM7R
        };

        // context swap register
        struct CSGCM0R : public Register<0x50060070> {
            using Field = Field<0, 32>;    // CSGCM0R
        };

        // context swap register
        struct CSGCM1R : public Register<0x50060074> {
            using Field = Field<0, 32>;    // CSGCM1R
        };

        // context swap register
        struct CSGCM2R : public Register<0x50060078> {
            using Field = Field<0, 32>;    // CSGCM2R
        };

        // context swap register
        struct CSGCM3R : public Register<0x5006007c> {
            using Field = Field<0, 32>;    // CSGCM3R
        };

        // context swap register
        struct CSGCM4R : public Register<0x50060080> {
            using Field = Field<0, 32>;    // CSGCM4R
        };

        // context swap register
        struct CSGCM5R : public Register<0x50060084> {
            using Field = Field<0, 32>;    // CSGCM5R
        };

        // context swap register
        struct CSGCM6R : public Register<0x50060088> {
            using Field = Field<0, 32>;    // CSGCM6R
        };

        // context swap register
        struct CSGCM7R : public Register<0x5006008c> {
            using Field = Field<0, 32>;    // CSGCM7R
        };

    };

    // Digital camera interface
    struct DCMI {
        // control register 1
        struct CR : public Register<0x50050000> {
            using ENABLE = Field<14, 1>;    // DCMI enable
            using EDM = Field<10, 2>;    // Extended data mode
            using FCRC = Field<8, 2>;    // Frame capture rate control
            using VSPOL = Field<7, 1>;    // Vertical synchronization polarity
            using HSPOL = Field<6, 1>;    // Horizontal synchronization polarity
            using PCKPOL = Field<5, 1>;    // Pixel clock polarity
            using ESS = Field<4, 1>;    // Embedded synchronization select
            using JPEG = Field<3, 1>;    // JPEG format
            using CROP = Field<2, 1>;    // Crop feature
            using CM = Field<1, 1>;    // Capture mode
            using CAPTURE = Field<0, 1>;    // Capture enable
        };

        // status register
        struct SR : public RegisterReadOnly<0x50050004> {
            using FNE = Field<2, 1>;    // FIFO not empty
            using VSYNC = Field<1, 1>;    // VSYNC
            using HSYNC = Field<0, 1>;    // HSYNC
        };

        // raw interrupt status register
        struct RIS : public RegisterReadOnly<0x50050008> {
            using LINE_RIS = Field<4, 1>;    // Line raw interrupt status
            using VSYNC_RIS = Field<3, 1>;    // VSYNC raw interrupt status
            using ERR_RIS = Field<2, 1>;    // Synchronization error raw interrupt status
            using OVR_RIS = Field<1, 1>;    // Overrun raw interrupt status
            using FRAME_RIS = Field<0, 1>;    // Capture complete raw interrupt status
        };

        // interrupt enable register
        struct IER : public Register<0x5005000c> {
            using LINE_IE = Field<4, 1>;    // Line interrupt enable
            using VSYNC_IE = Field<3, 1>;    // VSYNC interrupt enable
            using ERR_IE = Field<2, 1>;    // Synchronization error interrupt enable
            using OVR_IE = Field<1, 1>;    // Overrun interrupt enable
            using FRAME_IE = Field<0, 1>;    // Capture complete interrupt enable
        };

        // masked interrupt status register
        struct MIS : public RegisterReadOnly<0x50050010> {
            using LINE_MIS = Field<4, 1>;    // Line masked interrupt status
            using VSYNC_MIS = Field<3, 1>;    // VSYNC masked interrupt status
            using ERR_MIS = Field<2, 1>;    // Synchronization error masked interrupt status
            using OVR_MIS = Field<1, 1>;    // Overrun masked interrupt status
            using FRAME_MIS = Field<0, 1>;    // Capture complete masked interrupt status
        };

        // interrupt clear register
        struct ICR : public RegisterWriteOnly<0x50050014> {
            using LINE_ISC = Field<4, 1>;    // line interrupt status clear
            using VSYNC_ISC = Field<3, 1>;    // Vertical synch interrupt status clear
            using ERR_ISC = Field<2, 1>;    // Synchronization error interrupt status clear
            using OVR_ISC = Field<1, 1>;    // Overrun interrupt status clear
            using FRAME_ISC = Field<0, 1>;    // Capture complete interrupt status clear
        };

        // embedded synchronization code register
        struct ESCR : public Register<0x50050018> {
            using FEC = Field<24, 8>;    // Frame end delimiter code
            using LEC = Field<16, 8>;    // Line end delimiter code
            using LSC = Field<8, 8>;    // Line start delimiter code
            using FSC = Field<0, 8>;    // Frame start delimiter code
        };

        // embedded synchronization unmask register
        struct ESUR : public Register<0x5005001c> {
            using FEU = Field<24, 8>;    // Frame end delimiter unmask
            using LEU = Field<16, 8>;    // Line end delimiter unmask
            using LSU = Field<8, 8>;    // Line start delimiter unmask
            using FSU = Field<0, 8>;    // Frame start delimiter unmask
        };

        // crop window start
        struct CWSTRT : public Register<0x50050020> {
            using VST = Field<16, 13>;    // Vertical start line count
            using HOFFCNT = Field<0, 14>;    // Horizontal offset count
        };

        // crop window size
        struct CWSIZE : public Register<0x50050024> {
            using VLINE = Field<16, 14>;    // Vertical line count
            using CAPCNT = Field<0, 14>;    // Capture count
        };

        // data register
        struct DR : public RegisterReadOnly<0x50050028> {
            using Byte3 = Field<24, 8>;    // Data byte 3
            using Byte2 = Field<16, 8>;    // Data byte 2
            using Byte1 = Field<8, 8>;    // Data byte 1
            using Byte0 = Field<0, 8>;    // Data byte 0
        };

    };

    // Flexible memory controller
    struct FMC {
        // SRAM/NOR-Flash chip-select control register 1
        struct BCR1 : public Register<0xa0000000> {
            using CCLKEN = Field<20, 1>;    // CCLKEN
            using CBURSTRW = Field<19, 1>;    // CBURSTRW
            using ASYNCWAIT = Field<15, 1>;    // ASYNCWAIT
            using EXTMOD = Field<14, 1>;    // EXTMOD
            using WAITEN = Field<13, 1>;    // WAITEN
            using WREN = Field<12, 1>;    // WREN
            using WAITCFG = Field<11, 1>;    // WAITCFG
            using WAITPOL = Field<9, 1>;    // WAITPOL
            using BURSTEN = Field<8, 1>;    // BURSTEN
            using FACCEN = Field<6, 1>;    // FACCEN
            using MWID = Field<4, 2>;    // MWID
            using MTYP = Field<2, 2>;    // MTYP
            using MUXEN = Field<1, 1>;    // MUXEN
            using MBKEN = Field<0, 1>;    // MBKEN
        };

        // SRAM/NOR-Flash chip-select timing register 1
        struct BTR1 : public Register<0xa0000004> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // SRAM/NOR-Flash chip-select control register 2
        struct BCR2 : public Register<0xa0000008> {
            using CBURSTRW = Field<19, 1>;    // CBURSTRW
            using ASYNCWAIT = Field<15, 1>;    // ASYNCWAIT
            using EXTMOD = Field<14, 1>;    // EXTMOD
            using WAITEN = Field<13, 1>;    // WAITEN
            using WREN = Field<12, 1>;    // WREN
            using WAITCFG = Field<11, 1>;    // WAITCFG
            using WRAPMOD = Field<10, 1>;    // WRAPMOD
            using WAITPOL = Field<9, 1>;    // WAITPOL
            using BURSTEN = Field<8, 1>;    // BURSTEN
            using FACCEN = Field<6, 1>;    // FACCEN
            using MWID = Field<4, 2>;    // MWID
            using MTYP = Field<2, 2>;    // MTYP
            using MUXEN = Field<1, 1>;    // MUXEN
            using MBKEN = Field<0, 1>;    // MBKEN
        };

        // SRAM/NOR-Flash chip-select timing register 2
        struct BTR2 : public Register<0xa000000c> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // SRAM/NOR-Flash chip-select control register 3
        struct BCR3 : public Register<0xa0000010> {
            using CBURSTRW = Field<19, 1>;    // CBURSTRW
            using ASYNCWAIT = Field<15, 1>;    // ASYNCWAIT
            using EXTMOD = Field<14, 1>;    // EXTMOD
            using WAITEN = Field<13, 1>;    // WAITEN
            using WREN = Field<12, 1>;    // WREN
            using WAITCFG = Field<11, 1>;    // WAITCFG
            using WRAPMOD = Field<10, 1>;    // WRAPMOD
            using WAITPOL = Field<9, 1>;    // WAITPOL
            using BURSTEN = Field<8, 1>;    // BURSTEN
            using FACCEN = Field<6, 1>;    // FACCEN
            using MWID = Field<4, 2>;    // MWID
            using MTYP = Field<2, 2>;    // MTYP
            using MUXEN = Field<1, 1>;    // MUXEN
            using MBKEN = Field<0, 1>;    // MBKEN
        };

        // SRAM/NOR-Flash chip-select timing register 3
        struct BTR3 : public Register<0xa0000014> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // SRAM/NOR-Flash chip-select control register 4
        struct BCR4 : public Register<0xa0000018> {
            using CBURSTRW = Field<19, 1>;    // CBURSTRW
            using ASYNCWAIT = Field<15, 1>;    // ASYNCWAIT
            using EXTMOD = Field<14, 1>;    // EXTMOD
            using WAITEN = Field<13, 1>;    // WAITEN
            using WREN = Field<12, 1>;    // WREN
            using WAITCFG = Field<11, 1>;    // WAITCFG
            using WRAPMOD = Field<10, 1>;    // WRAPMOD
            using WAITPOL = Field<9, 1>;    // WAITPOL
            using BURSTEN = Field<8, 1>;    // BURSTEN
            using FACCEN = Field<6, 1>;    // FACCEN
            using MWID = Field<4, 2>;    // MWID
            using MTYP = Field<2, 2>;    // MTYP
            using MUXEN = Field<1, 1>;    // MUXEN
            using MBKEN = Field<0, 1>;    // MBKEN
        };

        // SRAM/NOR-Flash chip-select timing register 4
        struct BTR4 : public Register<0xa000001c> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // PC Card/NAND Flash control register
        struct PCR : public Register<0xa0000080> {
            using ECCPS = Field<17, 3>;    // ECCPS
            using TAR = Field<13, 4>;    // TAR
            using TCLR = Field<9, 4>;    // TCLR
            using ECCEN = Field<6, 1>;    // ECCEN
            using PWID = Field<4, 2>;    // PWID
            using PTYP = Field<3, 1>;    // PTYP
            using PBKEN = Field<2, 1>;    // PBKEN
            using PWAITEN = Field<1, 1>;    // PWAITEN
        };

        // FIFO status and interrupt register
        struct SR : public Register<0xa0000084> {
            using FEMPT = Field<6, 1>;    // FEMPT
            using IFEN = Field<5, 1>;    // IFEN
            using ILEN = Field<4, 1>;    // ILEN
            using IREN = Field<3, 1>;    // IREN
            using IFS = Field<2, 1>;    // IFS
            using ILS = Field<1, 1>;    // ILS
            using IRS = Field<0, 1>;    // IRS
        };

        // Common memory space timing register
        struct PMEM : public Register<0xa0000088> {
            using MEMHIZx = Field<24, 8>;    // MEMHIZx
            using MEMHOLDx = Field<16, 8>;    // MEMHOLDx
            using MEMWAITx = Field<8, 8>;    // MEMWAITx
            using MEMSETx = Field<0, 8>;    // MEMSETx
        };

        // Attribute memory space timing register
        struct PATT : public Register<0xa000008c> {
            using ATTHIZx = Field<24, 8>;    // ATTHIZx
            using ATTHOLDx = Field<16, 8>;    // ATTHOLDx
            using ATTWAITx = Field<8, 8>;    // ATTWAITx
            using ATTSETx = Field<0, 8>;    // ATTSETx
        };

        // ECC result register
        struct ECCR : public RegisterReadOnly<0xa0000094> {
            using ECCx = Field<0, 32>;    // ECCx
        };

        // SRAM/NOR-Flash write timing registers 1
        struct BWTR1 : public Register<0xa0000104> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // SRAM/NOR-Flash write timing registers 2
        struct BWTR2 : public Register<0xa000010c> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // SRAM/NOR-Flash write timing registers 3
        struct BWTR3 : public Register<0xa0000114> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // SRAM/NOR-Flash write timing registers 4
        struct BWTR4 : public Register<0xa000011c> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // SDRAM Control Register 1
        struct SDCR1 : public Register<0xa0000140> {
            using NC = Field<0, 2>;    // Number of column address bits
            using NR = Field<2, 2>;    // Number of row address bits
            using MWID = Field<4, 2>;    // Memory data bus width
            using NB = Field<6, 1>;    // Number of internal banks
            using CAS = Field<7, 2>;    // CAS latency
            using WP = Field<9, 1>;    // Write protection
            using SDCLK = Field<10, 2>;    // SDRAM clock configuration
            using RBURST = Field<12, 1>;    // Burst read
            using RPIPE = Field<13, 2>;    // Read pipe
        };

        // SDRAM Control Register 2
        struct SDCR2 : public Register<0xa0000144> {
            using NC = Field<0, 2>;    // Number of column address bits
            using NR = Field<2, 2>;    // Number of row address bits
            using MWID = Field<4, 2>;    // Memory data bus width
            using NB = Field<6, 1>;    // Number of internal banks
            using CAS = Field<7, 2>;    // CAS latency
            using WP = Field<9, 1>;    // Write protection
            using SDCLK = Field<10, 2>;    // SDRAM clock configuration
            using RBURST = Field<12, 1>;    // Burst read
            using RPIPE = Field<13, 2>;    // Read pipe
        };

        // SDRAM Timing register 1
        struct SDTR1 : public Register<0xa0000148> {
            using TMRD = Field<0, 4>;    // Load Mode Register to Active
            using TXSR = Field<4, 4>;    // Exit self-refresh delay
            using TRAS = Field<8, 4>;    // Self refresh time
            using TRC = Field<12, 4>;    // Row cycle delay
            using TWR = Field<16, 4>;    // Recovery delay
            using TRP = Field<20, 4>;    // Row precharge delay
            using TRCD = Field<24, 4>;    // Row to column delay
        };

        // SDRAM Timing register 2
        struct SDTR2 : public Register<0xa000014c> {
            using TMRD = Field<0, 4>;    // Load Mode Register to Active
            using TXSR = Field<4, 4>;    // Exit self-refresh delay
            using TRAS = Field<8, 4>;    // Self refresh time
            using TRC = Field<12, 4>;    // Row cycle delay
            using TWR = Field<16, 4>;    // Recovery delay
            using TRP = Field<20, 4>;    // Row precharge delay
            using TRCD = Field<24, 4>;    // Row to column delay
        };

        // SDRAM Command Mode register
        struct SDCMR : public Register<0xa0000150> {
            using MODE = Field<0, 3>;    // Command mode
            using CTB2 = Field<3, 1>;    // Command target bank 2
            using CTB1 = Field<4, 1>;    // Command target bank 1
            using NRFS = Field<5, 4>;    // Number of Auto-refresh
            using MRD = Field<9, 13>;    // Mode Register definition
        };

        // SDRAM Refresh Timer register
        struct SDRTR : public Register<0xa0000154> {
            using CRE = Field<0, 1>;    // Clear Refresh error flag
            using COUNT = Field<1, 13>;    // Refresh Timer Count
            using REIE = Field<14, 1>;    // RES Interrupt Enable
        };

        // SDRAM Status register
        struct SDSR : public RegisterReadOnly<0xa0000158> {
            using RE = Field<0, 1>;    // Refresh error flag
            using MODES1 = Field<1, 2>;    // Status Mode for Bank 1
            using MODES2 = Field<3, 2>;    // Status Mode for Bank 2
            using BUSY = Field<5, 1>;    // Busy status
        };

    };

    // DMA controller
    struct DMA2 {
        // low interrupt status register
        struct LISR : public RegisterReadOnly<0x40026400> {
            using TCIF3 = Field<27, 1>;    // Stream x transfer complete interrupt flag (x = 3..0)
            using HTIF3 = Field<26, 1>;    // Stream x half transfer interrupt flag (x=3..0)
            using TEIF3 = Field<25, 1>;    // Stream x transfer error interrupt flag (x=3..0)
            using DMEIF3 = Field<24, 1>;    // Stream x direct mode error interrupt flag (x=3..0)
            using FEIF3 = Field<22, 1>;    // Stream x FIFO error interrupt flag (x=3..0)
            using TCIF2 = Field<21, 1>;    // Stream x transfer complete interrupt flag (x = 3..0)
            using HTIF2 = Field<20, 1>;    // Stream x half transfer interrupt flag (x=3..0)
            using TEIF2 = Field<19, 1>;    // Stream x transfer error interrupt flag (x=3..0)
            using DMEIF2 = Field<18, 1>;    // Stream x direct mode error interrupt flag (x=3..0)
            using FEIF2 = Field<16, 1>;    // Stream x FIFO error interrupt flag (x=3..0)
            using TCIF1 = Field<11, 1>;    // Stream x transfer complete interrupt flag (x = 3..0)
            using HTIF1 = Field<10, 1>;    // Stream x half transfer interrupt flag (x=3..0)
            using TEIF1 = Field<9, 1>;    // Stream x transfer error interrupt flag (x=3..0)
            using DMEIF1 = Field<8, 1>;    // Stream x direct mode error interrupt flag (x=3..0)
            using FEIF1 = Field<6, 1>;    // Stream x FIFO error interrupt flag (x=3..0)
            using TCIF0 = Field<5, 1>;    // Stream x transfer complete interrupt flag (x = 3..0)
            using HTIF0 = Field<4, 1>;    // Stream x half transfer interrupt flag (x=3..0)
            using TEIF0 = Field<3, 1>;    // Stream x transfer error interrupt flag (x=3..0)
            using DMEIF0 = Field<2, 1>;    // Stream x direct mode error interrupt flag (x=3..0)
            using FEIF0 = Field<0, 1>;    // Stream x FIFO error interrupt flag (x=3..0)
        };

        // high interrupt status register
        struct HISR : public RegisterReadOnly<0x40026404> {
            using TCIF7 = Field<27, 1>;    // Stream x transfer complete interrupt flag (x=7..4)
            using HTIF7 = Field<26, 1>;    // Stream x half transfer interrupt flag (x=7..4)
            using TEIF7 = Field<25, 1>;    // Stream x transfer error interrupt flag (x=7..4)
            using DMEIF7 = Field<24, 1>;    // Stream x direct mode error interrupt flag (x=7..4)
            using FEIF7 = Field<22, 1>;    // Stream x FIFO error interrupt flag (x=7..4)
            using TCIF6 = Field<21, 1>;    // Stream x transfer complete interrupt flag (x=7..4)
            using HTIF6 = Field<20, 1>;    // Stream x half transfer interrupt flag (x=7..4)
            using TEIF6 = Field<19, 1>;    // Stream x transfer error interrupt flag (x=7..4)
            using DMEIF6 = Field<18, 1>;    // Stream x direct mode error interrupt flag (x=7..4)
            using FEIF6 = Field<16, 1>;    // Stream x FIFO error interrupt flag (x=7..4)
            using TCIF5 = Field<11, 1>;    // Stream x transfer complete interrupt flag (x=7..4)
            using HTIF5 = Field<10, 1>;    // Stream x half transfer interrupt flag (x=7..4)
            using TEIF5 = Field<9, 1>;    // Stream x transfer error interrupt flag (x=7..4)
            using DMEIF5 = Field<8, 1>;    // Stream x direct mode error interrupt flag (x=7..4)
            using FEIF5 = Field<6, 1>;    // Stream x FIFO error interrupt flag (x=7..4)
            using TCIF4 = Field<5, 1>;    // Stream x transfer complete interrupt flag (x=7..4)
            using HTIF4 = Field<4, 1>;    // Stream x half transfer interrupt flag (x=7..4)
            using TEIF4 = Field<3, 1>;    // Stream x transfer error interrupt flag (x=7..4)
            using DMEIF4 = Field<2, 1>;    // Stream x direct mode error interrupt flag (x=7..4)
            using FEIF4 = Field<0, 1>;    // Stream x FIFO error interrupt flag (x=7..4)
        };

        // low interrupt flag clear register
        struct LIFCR : public Register<0x40026408> {
            using CTCIF3 = Field<27, 1>;    // Stream x clear transfer complete interrupt flag (x = 3..0)
            using CHTIF3 = Field<26, 1>;    // Stream x clear half transfer interrupt flag (x = 3..0)
            using CTEIF3 = Field<25, 1>;    // Stream x clear transfer error interrupt flag (x = 3..0)
            using CDMEIF3 = Field<24, 1>;    // Stream x clear direct mode error interrupt flag (x = 3..0)
            using CFEIF3 = Field<22, 1>;    // Stream x clear FIFO error interrupt flag (x = 3..0)
            using CTCIF2 = Field<21, 1>;    // Stream x clear transfer complete interrupt flag (x = 3..0)
            using CHTIF2 = Field<20, 1>;    // Stream x clear half transfer interrupt flag (x = 3..0)
            using CTEIF2 = Field<19, 1>;    // Stream x clear transfer error interrupt flag (x = 3..0)
            using CDMEIF2 = Field<18, 1>;    // Stream x clear direct mode error interrupt flag (x = 3..0)
            using CFEIF2 = Field<16, 1>;    // Stream x clear FIFO error interrupt flag (x = 3..0)
            using CTCIF1 = Field<11, 1>;    // Stream x clear transfer complete interrupt flag (x = 3..0)
            using CHTIF1 = Field<10, 1>;    // Stream x clear half transfer interrupt flag (x = 3..0)
            using CTEIF1 = Field<9, 1>;    // Stream x clear transfer error interrupt flag (x = 3..0)
            using CDMEIF1 = Field<8, 1>;    // Stream x clear direct mode error interrupt flag (x = 3..0)
            using CFEIF1 = Field<6, 1>;    // Stream x clear FIFO error interrupt flag (x = 3..0)
            using CTCIF0 = Field<5, 1>;    // Stream x clear transfer complete interrupt flag (x = 3..0)
            using CHTIF0 = Field<4, 1>;    // Stream x clear half transfer interrupt flag (x = 3..0)
            using CTEIF0 = Field<3, 1>;    // Stream x clear transfer error interrupt flag (x = 3..0)
            using CDMEIF0 = Field<2, 1>;    // Stream x clear direct mode error interrupt flag (x = 3..0)
            using CFEIF0 = Field<0, 1>;    // Stream x clear FIFO error interrupt flag (x = 3..0)
        };

        // high interrupt flag clear register
        struct HIFCR : public Register<0x4002640c> {
            using CTCIF7 = Field<27, 1>;    // Stream x clear transfer complete interrupt flag (x = 7..4)
            using CHTIF7 = Field<26, 1>;    // Stream x clear half transfer interrupt flag (x = 7..4)
            using CTEIF7 = Field<25, 1>;    // Stream x clear transfer error interrupt flag (x = 7..4)
            using CDMEIF7 = Field<24, 1>;    // Stream x clear direct mode error interrupt flag (x = 7..4)
            using CFEIF7 = Field<22, 1>;    // Stream x clear FIFO error interrupt flag (x = 7..4)
            using CTCIF6 = Field<21, 1>;    // Stream x clear transfer complete interrupt flag (x = 7..4)
            using CHTIF6 = Field<20, 1>;    // Stream x clear half transfer interrupt flag (x = 7..4)
            using CTEIF6 = Field<19, 1>;    // Stream x clear transfer error interrupt flag (x = 7..4)
            using CDMEIF6 = Field<18, 1>;    // Stream x clear direct mode error interrupt flag (x = 7..4)
            using CFEIF6 = Field<16, 1>;    // Stream x clear FIFO error interrupt flag (x = 7..4)
            using CTCIF5 = Field<11, 1>;    // Stream x clear transfer complete interrupt flag (x = 7..4)
            using CHTIF5 = Field<10, 1>;    // Stream x clear half transfer interrupt flag (x = 7..4)
            using CTEIF5 = Field<9, 1>;    // Stream x clear transfer error interrupt flag (x = 7..4)
            using CDMEIF5 = Field<8, 1>;    // Stream x clear direct mode error interrupt flag (x = 7..4)
            using CFEIF5 = Field<6, 1>;    // Stream x clear FIFO error interrupt flag (x = 7..4)
            using CTCIF4 = Field<5, 1>;    // Stream x clear transfer complete interrupt flag (x = 7..4)
            using CHTIF4 = Field<4, 1>;    // Stream x clear half transfer interrupt flag (x = 7..4)
            using CTEIF4 = Field<3, 1>;    // Stream x clear transfer error interrupt flag (x = 7..4)
            using CDMEIF4 = Field<2, 1>;    // Stream x clear direct mode error interrupt flag (x = 7..4)
            using CFEIF4 = Field<0, 1>;    // Stream x clear FIFO error interrupt flag (x = 7..4)
        };

        // stream x configuration register
        struct S0CR : public Register<0x40026410> {
            using CHSEL = Field<25, 4>;    // Channel selection
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S0NDTR : public Register<0x40026414> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S0PAR : public Register<0x40026418> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S0M0AR : public Register<0x4002641c> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S0M1AR : public Register<0x40026420> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S0FCR : public Register<0x40026424> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S1CR : public Register<0x40026428> {
            using CHSEL = Field<25, 4>;    // Channel selection
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S1NDTR : public Register<0x4002642c> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S1PAR : public Register<0x40026430> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S1M0AR : public Register<0x40026434> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S1M1AR : public Register<0x40026438> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S1FCR : public Register<0x4002643c> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S2CR : public Register<0x40026440> {
            using CHSEL = Field<25, 4>;    // Channel selection
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S2NDTR : public Register<0x40026444> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S2PAR : public Register<0x40026448> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S2M0AR : public Register<0x4002644c> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S2M1AR : public Register<0x40026450> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S2FCR : public Register<0x40026454> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S3CR : public Register<0x40026458> {
            using CHSEL = Field<25, 4>;    // Channel selection
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S3NDTR : public Register<0x4002645c> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S3PAR : public Register<0x40026460> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S3M0AR : public Register<0x40026464> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S3M1AR : public Register<0x40026468> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S3FCR : public Register<0x4002646c> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S4CR : public Register<0x40026470> {
            using CHSEL = Field<25, 4>;    // Channel selection
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S4NDTR : public Register<0x40026474> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S4PAR : public Register<0x40026478> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S4M0AR : public Register<0x4002647c> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S4M1AR : public Register<0x40026480> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S4FCR : public Register<0x40026484> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S5CR : public Register<0x40026488> {
            using CHSEL = Field<25, 4>;    // Channel selection
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S5NDTR : public Register<0x4002648c> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S5PAR : public Register<0x40026490> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S5M0AR : public Register<0x40026494> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S5M1AR : public Register<0x40026498> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S5FCR : public Register<0x4002649c> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S6CR : public Register<0x400264a0> {
            using CHSEL = Field<25, 4>;    // Channel selection
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S6NDTR : public Register<0x400264a4> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S6PAR : public Register<0x400264a8> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S6M0AR : public Register<0x400264ac> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S6M1AR : public Register<0x400264b0> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S6FCR : public Register<0x400264b4> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S7CR : public Register<0x400264b8> {
            using CHSEL = Field<25, 4>;    // Channel selection
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S7NDTR : public Register<0x400264bc> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S7PAR : public Register<0x400264c0> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S7M0AR : public Register<0x400264c4> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S7M1AR : public Register<0x400264c8> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S7FCR : public Register<0x400264cc> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

    };

    // DMA controller
    struct DMA1 {
        // low interrupt status register
        struct LISR : public RegisterReadOnly<0x40026000> {
            using TCIF3 = Field<27, 1>;    // Stream x transfer complete interrupt flag (x = 3..0)
            using HTIF3 = Field<26, 1>;    // Stream x half transfer interrupt flag (x=3..0)
            using TEIF3 = Field<25, 1>;    // Stream x transfer error interrupt flag (x=3..0)
            using DMEIF3 = Field<24, 1>;    // Stream x direct mode error interrupt flag (x=3..0)
            using FEIF3 = Field<22, 1>;    // Stream x FIFO error interrupt flag (x=3..0)
            using TCIF2 = Field<21, 1>;    // Stream x transfer complete interrupt flag (x = 3..0)
            using HTIF2 = Field<20, 1>;    // Stream x half transfer interrupt flag (x=3..0)
            using TEIF2 = Field<19, 1>;    // Stream x transfer error interrupt flag (x=3..0)
            using DMEIF2 = Field<18, 1>;    // Stream x direct mode error interrupt flag (x=3..0)
            using FEIF2 = Field<16, 1>;    // Stream x FIFO error interrupt flag (x=3..0)
            using TCIF1 = Field<11, 1>;    // Stream x transfer complete interrupt flag (x = 3..0)
            using HTIF1 = Field<10, 1>;    // Stream x half transfer interrupt flag (x=3..0)
            using TEIF1 = Field<9, 1>;    // Stream x transfer error interrupt flag (x=3..0)
            using DMEIF1 = Field<8, 1>;    // Stream x direct mode error interrupt flag (x=3..0)
            using FEIF1 = Field<6, 1>;    // Stream x FIFO error interrupt flag (x=3..0)
            using TCIF0 = Field<5, 1>;    // Stream x transfer complete interrupt flag (x = 3..0)
            using HTIF0 = Field<4, 1>;    // Stream x half transfer interrupt flag (x=3..0)
            using TEIF0 = Field<3, 1>;    // Stream x transfer error interrupt flag (x=3..0)
            using DMEIF0 = Field<2, 1>;    // Stream x direct mode error interrupt flag (x=3..0)
            using FEIF0 = Field<0, 1>;    // Stream x FIFO error interrupt flag (x=3..0)
        };

        // high interrupt status register
        struct HISR : public RegisterReadOnly<0x40026004> {
            using TCIF7 = Field<27, 1>;    // Stream x transfer complete interrupt flag (x=7..4)
            using HTIF7 = Field<26, 1>;    // Stream x half transfer interrupt flag (x=7..4)
            using TEIF7 = Field<25, 1>;    // Stream x transfer error interrupt flag (x=7..4)
            using DMEIF7 = Field<24, 1>;    // Stream x direct mode error interrupt flag (x=7..4)
            using FEIF7 = Field<22, 1>;    // Stream x FIFO error interrupt flag (x=7..4)
            using TCIF6 = Field<21, 1>;    // Stream x transfer complete interrupt flag (x=7..4)
            using HTIF6 = Field<20, 1>;    // Stream x half transfer interrupt flag (x=7..4)
            using TEIF6 = Field<19, 1>;    // Stream x transfer error interrupt flag (x=7..4)
            using DMEIF6 = Field<18, 1>;    // Stream x direct mode error interrupt flag (x=7..4)
            using FEIF6 = Field<16, 1>;    // Stream x FIFO error interrupt flag (x=7..4)
            using TCIF5 = Field<11, 1>;    // Stream x transfer complete interrupt flag (x=7..4)
            using HTIF5 = Field<10, 1>;    // Stream x half transfer interrupt flag (x=7..4)
            using TEIF5 = Field<9, 1>;    // Stream x transfer error interrupt flag (x=7..4)
            using DMEIF5 = Field<8, 1>;    // Stream x direct mode error interrupt flag (x=7..4)
            using FEIF5 = Field<6, 1>;    // Stream x FIFO error interrupt flag (x=7..4)
            using TCIF4 = Field<5, 1>;    // Stream x transfer complete interrupt flag (x=7..4)
            using HTIF4 = Field<4, 1>;    // Stream x half transfer interrupt flag (x=7..4)
            using TEIF4 = Field<3, 1>;    // Stream x transfer error interrupt flag (x=7..4)
            using DMEIF4 = Field<2, 1>;    // Stream x direct mode error interrupt flag (x=7..4)
            using FEIF4 = Field<0, 1>;    // Stream x FIFO error interrupt flag (x=7..4)
        };

        // low interrupt flag clear register
        struct LIFCR : public Register<0x40026008> {
            using CTCIF3 = Field<27, 1>;    // Stream x clear transfer complete interrupt flag (x = 3..0)
            using CHTIF3 = Field<26, 1>;    // Stream x clear half transfer interrupt flag (x = 3..0)
            using CTEIF3 = Field<25, 1>;    // Stream x clear transfer error interrupt flag (x = 3..0)
            using CDMEIF3 = Field<24, 1>;    // Stream x clear direct mode error interrupt flag (x = 3..0)
            using CFEIF3 = Field<22, 1>;    // Stream x clear FIFO error interrupt flag (x = 3..0)
            using CTCIF2 = Field<21, 1>;    // Stream x clear transfer complete interrupt flag (x = 3..0)
            using CHTIF2 = Field<20, 1>;    // Stream x clear half transfer interrupt flag (x = 3..0)
            using CTEIF2 = Field<19, 1>;    // Stream x clear transfer error interrupt flag (x = 3..0)
            using CDMEIF2 = Field<18, 1>;    // Stream x clear direct mode error interrupt flag (x = 3..0)
            using CFEIF2 = Field<16, 1>;    // Stream x clear FIFO error interrupt flag (x = 3..0)
            using CTCIF1 = Field<11, 1>;    // Stream x clear transfer complete interrupt flag (x = 3..0)
            using CHTIF1 = Field<10, 1>;    // Stream x clear half transfer interrupt flag (x = 3..0)
            using CTEIF1 = Field<9, 1>;    // Stream x clear transfer error interrupt flag (x = 3..0)
            using CDMEIF1 = Field<8, 1>;    // Stream x clear direct mode error interrupt flag (x = 3..0)
            using CFEIF1 = Field<6, 1>;    // Stream x clear FIFO error interrupt flag (x = 3..0)
            using CTCIF0 = Field<5, 1>;    // Stream x clear transfer complete interrupt flag (x = 3..0)
            using CHTIF0 = Field<4, 1>;    // Stream x clear half transfer interrupt flag (x = 3..0)
            using CTEIF0 = Field<3, 1>;    // Stream x clear transfer error interrupt flag (x = 3..0)
            using CDMEIF0 = Field<2, 1>;    // Stream x clear direct mode error interrupt flag (x = 3..0)
            using CFEIF0 = Field<0, 1>;    // Stream x clear FIFO error interrupt flag (x = 3..0)
        };

        // high interrupt flag clear register
        struct HIFCR : public Register<0x4002600c> {
            using CTCIF7 = Field<27, 1>;    // Stream x clear transfer complete interrupt flag (x = 7..4)
            using CHTIF7 = Field<26, 1>;    // Stream x clear half transfer interrupt flag (x = 7..4)
            using CTEIF7 = Field<25, 1>;    // Stream x clear transfer error interrupt flag (x = 7..4)
            using CDMEIF7 = Field<24, 1>;    // Stream x clear direct mode error interrupt flag (x = 7..4)
            using CFEIF7 = Field<22, 1>;    // Stream x clear FIFO error interrupt flag (x = 7..4)
            using CTCIF6 = Field<21, 1>;    // Stream x clear transfer complete interrupt flag (x = 7..4)
            using CHTIF6 = Field<20, 1>;    // Stream x clear half transfer interrupt flag (x = 7..4)
            using CTEIF6 = Field<19, 1>;    // Stream x clear transfer error interrupt flag (x = 7..4)
            using CDMEIF6 = Field<18, 1>;    // Stream x clear direct mode error interrupt flag (x = 7..4)
            using CFEIF6 = Field<16, 1>;    // Stream x clear FIFO error interrupt flag (x = 7..4)
            using CTCIF5 = Field<11, 1>;    // Stream x clear transfer complete interrupt flag (x = 7..4)
            using CHTIF5 = Field<10, 1>;    // Stream x clear half transfer interrupt flag (x = 7..4)
            using CTEIF5 = Field<9, 1>;    // Stream x clear transfer error interrupt flag (x = 7..4)
            using CDMEIF5 = Field<8, 1>;    // Stream x clear direct mode error interrupt flag (x = 7..4)
            using CFEIF5 = Field<6, 1>;    // Stream x clear FIFO error interrupt flag (x = 7..4)
            using CTCIF4 = Field<5, 1>;    // Stream x clear transfer complete interrupt flag (x = 7..4)
            using CHTIF4 = Field<4, 1>;    // Stream x clear half transfer interrupt flag (x = 7..4)
            using CTEIF4 = Field<3, 1>;    // Stream x clear transfer error interrupt flag (x = 7..4)
            using CDMEIF4 = Field<2, 1>;    // Stream x clear direct mode error interrupt flag (x = 7..4)
            using CFEIF4 = Field<0, 1>;    // Stream x clear FIFO error interrupt flag (x = 7..4)
        };

        // stream x configuration register
        struct S0CR : public Register<0x40026010> {
            using CHSEL = Field<25, 4>;    // Channel selection
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S0NDTR : public Register<0x40026014> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S0PAR : public Register<0x40026018> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S0M0AR : public Register<0x4002601c> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S0M1AR : public Register<0x40026020> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S0FCR : public Register<0x40026024> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S1CR : public Register<0x40026028> {
            using CHSEL = Field<25, 4>;    // Channel selection
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S1NDTR : public Register<0x4002602c> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S1PAR : public Register<0x40026030> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S1M0AR : public Register<0x40026034> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S1M1AR : public Register<0x40026038> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S1FCR : public Register<0x4002603c> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S2CR : public Register<0x40026040> {
            using CHSEL = Field<25, 4>;    // Channel selection
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S2NDTR : public Register<0x40026044> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S2PAR : public Register<0x40026048> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S2M0AR : public Register<0x4002604c> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S2M1AR : public Register<0x40026050> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S2FCR : public Register<0x40026054> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S3CR : public Register<0x40026058> {
            using CHSEL = Field<25, 4>;    // Channel selection
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S3NDTR : public Register<0x4002605c> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S3PAR : public Register<0x40026060> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S3M0AR : public Register<0x40026064> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S3M1AR : public Register<0x40026068> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S3FCR : public Register<0x4002606c> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S4CR : public Register<0x40026070> {
            using CHSEL = Field<25, 4>;    // Channel selection
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S4NDTR : public Register<0x40026074> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S4PAR : public Register<0x40026078> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S4M0AR : public Register<0x4002607c> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S4M1AR : public Register<0x40026080> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S4FCR : public Register<0x40026084> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S5CR : public Register<0x40026088> {
            using CHSEL = Field<25, 4>;    // Channel selection
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S5NDTR : public Register<0x4002608c> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S5PAR : public Register<0x40026090> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S5M0AR : public Register<0x40026094> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S5M1AR : public Register<0x40026098> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S5FCR : public Register<0x4002609c> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S6CR : public Register<0x400260a0> {
            using CHSEL = Field<25, 4>;    // Channel selection
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S6NDTR : public Register<0x400260a4> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S6PAR : public Register<0x400260a8> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S6M0AR : public Register<0x400260ac> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S6M1AR : public Register<0x400260b0> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S6FCR : public Register<0x400260b4> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S7CR : public Register<0x400260b8> {
            using CHSEL = Field<25, 4>;    // Channel selection
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S7NDTR : public Register<0x400260bc> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S7PAR : public Register<0x400260c0> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S7M0AR : public Register<0x400260c4> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S7M1AR : public Register<0x400260c8> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S7FCR : public Register<0x400260cc> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

    };

    // Reset and clock control
    struct RCC {
        // clock control register
        struct CR : public Register<0x40023800> {
            using PLLI2SRDY = Field<27, 1>;    // PLLI2S clock ready flag
            using PLLI2SON = Field<26, 1>;    // PLLI2S enable
            using PLLRDY = Field<25, 1>;    // Main PLL (PLL) clock ready flag
            using PLLON = Field<24, 1>;    // Main PLL (PLL) enable
            using CSSON = Field<19, 1>;    // Clock security system enable
            using HSEBYP = Field<18, 1>;    // HSE clock bypass
            using HSERDY = Field<17, 1>;    // HSE clock ready flag
            using HSEON = Field<16, 1>;    // HSE clock enable
            using HSICAL = Field<8, 8>;    // Internal high-speed clock calibration
            using HSITRIM = Field<3, 5>;    // Internal high-speed clock trimming
            using HSIRDY = Field<1, 1>;    // Internal high-speed clock ready flag
            using HSION = Field<0, 1>;    // Internal high-speed clock enable
        };

        // PLL configuration register
        struct PLLCFGR : public Register<0x40023804> {
            using PLLQ3 = Field<27, 1>;    // Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks
            using PLLQ2 = Field<26, 1>;    // Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks
            using PLLQ1 = Field<25, 1>;    // Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks
            using PLLQ0 = Field<24, 1>;    // Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks
            using PLLSRC = Field<22, 1>;    // Main PLL(PLL) and audio PLL (PLLI2S) entry clock source
            using PLLP1 = Field<17, 1>;    // Main PLL (PLL) division factor for main system clock
            using PLLP0 = Field<16, 1>;    // Main PLL (PLL) division factor for main system clock
            using PLLN8 = Field<14, 1>;    // Main PLL (PLL) multiplication factor for VCO
            using PLLN7 = Field<13, 1>;    // Main PLL (PLL) multiplication factor for VCO
            using PLLN6 = Field<12, 1>;    // Main PLL (PLL) multiplication factor for VCO
            using PLLN5 = Field<11, 1>;    // Main PLL (PLL) multiplication factor for VCO
            using PLLN4 = Field<10, 1>;    // Main PLL (PLL) multiplication factor for VCO
            using PLLN3 = Field<9, 1>;    // Main PLL (PLL) multiplication factor for VCO
            using PLLN2 = Field<8, 1>;    // Main PLL (PLL) multiplication factor for VCO
            using PLLN1 = Field<7, 1>;    // Main PLL (PLL) multiplication factor for VCO
            using PLLN0 = Field<6, 1>;    // Main PLL (PLL) multiplication factor for VCO
            using PLLM5 = Field<5, 1>;    // Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
            using PLLM4 = Field<4, 1>;    // Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
            using PLLM3 = Field<3, 1>;    // Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
            using PLLM2 = Field<2, 1>;    // Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
            using PLLM1 = Field<1, 1>;    // Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
            using PLLM0 = Field<0, 1>;    // Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
        };

        // clock configuration register
        struct CFGR : public Register<0x40023808> {
            using MCO2 = Field<30, 2>;    // Microcontroller clock output 2
            using MCO2PRE = Field<27, 3>;    // MCO2 prescaler
            using MCO1PRE = Field<24, 3>;    // MCO1 prescaler
            using I2SSRC = Field<23, 1>;    // I2S clock selection
            using MCO1 = Field<21, 2>;    // Microcontroller clock output 1
            using RTCPRE = Field<16, 5>;    // HSE division factor for RTC clock
            using PPRE2 = Field<13, 3>;    // APB high-speed prescaler (APB2)
            using PPRE1 = Field<10, 3>;    // APB Low speed prescaler (APB1)
            using HPRE = Field<4, 4>;    // AHB prescaler
            using SWS1 = Field<3, 1>;    // System clock switch status
            using SWS0 = Field<2, 1>;    // System clock switch status
            using SW1 = Field<1, 1>;    // System clock switch
            using SW0 = Field<0, 1>;    // System clock switch
        };

        // clock interrupt register
        struct CIR : public Register<0x4002380c> {
            using CSSC = Field<23, 1>;    // Clock security system interrupt clear
            using PLLSAIRDYC = Field<22, 1>;    // PLLSAI Ready Interrupt Clear
            using PLLI2SRDYC = Field<21, 1>;    // PLLI2S ready interrupt clear
            using PLLRDYC = Field<20, 1>;    // Main PLL(PLL) ready interrupt clear
            using HSERDYC = Field<19, 1>;    // HSE ready interrupt clear
            using HSIRDYC = Field<18, 1>;    // HSI ready interrupt clear
            using LSERDYC = Field<17, 1>;    // LSE ready interrupt clear
            using LSIRDYC = Field<16, 1>;    // LSI ready interrupt clear
            using PLLSAIRDYIE = Field<14, 1>;    // PLLSAI Ready Interrupt Enable
            using PLLI2SRDYIE = Field<13, 1>;    // PLLI2S ready interrupt enable
            using PLLRDYIE = Field<12, 1>;    // Main PLL (PLL) ready interrupt enable
            using HSERDYIE = Field<11, 1>;    // HSE ready interrupt enable
            using HSIRDYIE = Field<10, 1>;    // HSI ready interrupt enable
            using LSERDYIE = Field<9, 1>;    // LSE ready interrupt enable
            using LSIRDYIE = Field<8, 1>;    // LSI ready interrupt enable
            using CSSF = Field<7, 1>;    // Clock security system interrupt flag
            using PLLSAIRDYF = Field<6, 1>;    // PLLSAI ready interrupt flag
            using PLLI2SRDYF = Field<5, 1>;    // PLLI2S ready interrupt flag
            using PLLRDYF = Field<4, 1>;    // Main PLL (PLL) ready interrupt flag
            using HSERDYF = Field<3, 1>;    // HSE ready interrupt flag
            using HSIRDYF = Field<2, 1>;    // HSI ready interrupt flag
            using LSERDYF = Field<1, 1>;    // LSE ready interrupt flag
            using LSIRDYF = Field<0, 1>;    // LSI ready interrupt flag
        };

        // AHB1 peripheral reset register
        struct AHB1RSTR : public Register<0x40023810> {
            using OTGHSRST = Field<29, 1>;    // USB OTG HS module reset
            using ETHMACRST = Field<25, 1>;    // Ethernet MAC reset
            using DMA2DRST = Field<23, 1>;    // DMA2D reset
            using DMA2RST = Field<22, 1>;    // DMA2 reset
            using DMA1RST = Field<21, 1>;    // DMA2 reset
            using CRCRST = Field<12, 1>;    // CRC reset
            using GPIOKRST = Field<10, 1>;    // IO port K reset
            using GPIOJRST = Field<9, 1>;    // IO port J reset
            using GPIOIRST = Field<8, 1>;    // IO port I reset
            using GPIOHRST = Field<7, 1>;    // IO port H reset
            using GPIOGRST = Field<6, 1>;    // IO port G reset
            using GPIOFRST = Field<5, 1>;    // IO port F reset
            using GPIOERST = Field<4, 1>;    // IO port E reset
            using GPIODRST = Field<3, 1>;    // IO port D reset
            using GPIOCRST = Field<2, 1>;    // IO port C reset
            using GPIOBRST = Field<1, 1>;    // IO port B reset
            using GPIOARST = Field<0, 1>;    // IO port A reset
        };

        // AHB2 peripheral reset register
        struct AHB2RSTR : public Register<0x40023814> {
            using OTGFSRST = Field<7, 1>;    // USB OTG FS module reset
            using RNGRST = Field<6, 1>;    // Random number generator module reset
            using HSAHRST = Field<5, 1>;    // Hash module reset
            using CRYPRST = Field<4, 1>;    // Cryptographic module reset
            using DCMIRST = Field<0, 1>;    // Camera interface reset
        };

        // AHB3 peripheral reset register
        struct AHB3RSTR : public Register<0x40023818> {
            using FMCRST = Field<0, 1>;    // Flexible memory controller module reset
            using QSPIRST = Field<1, 1>;    // Quad SPI memory controller reset
        };

        // APB1 peripheral reset register
        struct APB1RSTR : public Register<0x40023820> {
            using TIM2RST = Field<0, 1>;    // TIM2 reset
            using TIM3RST = Field<1, 1>;    // TIM3 reset
            using TIM4RST = Field<2, 1>;    // TIM4 reset
            using TIM5RST = Field<3, 1>;    // TIM5 reset
            using TIM6RST = Field<4, 1>;    // TIM6 reset
            using TIM7RST = Field<5, 1>;    // TIM7 reset
            using TIM12RST = Field<6, 1>;    // TIM12 reset
            using TIM13RST = Field<7, 1>;    // TIM13 reset
            using TIM14RST = Field<8, 1>;    // TIM14 reset
            using WWDGRST = Field<11, 1>;    // Window watchdog reset
            using SPI2RST = Field<14, 1>;    // SPI 2 reset
            using SPI3RST = Field<15, 1>;    // SPI 3 reset
            using UART2RST = Field<17, 1>;    // USART 2 reset
            using UART3RST = Field<18, 1>;    // USART 3 reset
            using UART4RST = Field<19, 1>;    // USART 4 reset
            using UART5RST = Field<20, 1>;    // USART 5 reset
            using I2C1RST = Field<21, 1>;    // I2C 1 reset
            using I2C2RST = Field<22, 1>;    // I2C 2 reset
            using I2C3RST = Field<23, 1>;    // I2C3 reset
            using CAN1RST = Field<25, 1>;    // CAN1 reset
            using CAN2RST = Field<26, 1>;    // CAN2 reset
            using PWRRST = Field<28, 1>;    // Power interface reset
            using DACRST = Field<29, 1>;    // DAC reset
            using UART7RST = Field<30, 1>;    // UART7 reset
            using UART8RST = Field<31, 1>;    // UART8 reset
            using SPDIFRXRST = Field<16, 1>;    // SPDIF-RX reset
            using CECRST = Field<27, 1>;    // HDMI-CEC reset
            using LPTIM1RST = Field<9, 1>;    // Low power timer 1 reset
            using I2C4RST = Field<24, 1>;    // I2C 4 reset
        };

        // APB2 peripheral reset register
        struct APB2RSTR : public Register<0x40023824> {
            using TIM1RST = Field<0, 1>;    // TIM1 reset
            using TIM8RST = Field<1, 1>;    // TIM8 reset
            using USART1RST = Field<4, 1>;    // USART1 reset
            using USART6RST = Field<5, 1>;    // USART6 reset
            using ADCRST = Field<8, 1>;    // ADC interface reset (common to all ADCs)
            using SPI1RST = Field<12, 1>;    // SPI 1 reset
            using SPI4RST = Field<13, 1>;    // SPI4 reset
            using SYSCFGRST = Field<14, 1>;    // System configuration controller reset
            using TIM9RST = Field<16, 1>;    // TIM9 reset
            using TIM10RST = Field<17, 1>;    // TIM10 reset
            using TIM11RST = Field<18, 1>;    // TIM11 reset
            using SPI5RST = Field<20, 1>;    // SPI5 reset
            using SPI6RST = Field<21, 1>;    // SPI6 reset
            using SAI1RST = Field<22, 1>;    // SAI1 reset
            using LTDCRST = Field<26, 1>;    // LTDC reset
            using SAI2RST = Field<23, 1>;    // SAI2 reset
            using SDMMC1RST = Field<11, 1>;    // SDMMC1 reset
        };

        // AHB1 peripheral clock register
        struct AHB1ENR : public Register<0x40023830> {
            using OTGHSULPIEN = Field<30, 1>;    // USB OTG HSULPI clock enable
            using OTGHSEN = Field<29, 1>;    // USB OTG HS clock enable
            using ETHMACPTPEN = Field<28, 1>;    // Ethernet PTP clock enable
            using ETHMACRXEN = Field<27, 1>;    // Ethernet Reception clock enable
            using ETHMACTXEN = Field<26, 1>;    // Ethernet Transmission clock enable
            using ETHMACEN = Field<25, 1>;    // Ethernet MAC clock enable
            using DMA2DEN = Field<23, 1>;    // DMA2D clock enable
            using DMA2EN = Field<22, 1>;    // DMA2 clock enable
            using DMA1EN = Field<21, 1>;    // DMA1 clock enable
            using CCMDATARAMEN = Field<20, 1>;    // CCM data RAM clock enable
            using BKPSRAMEN = Field<18, 1>;    // Backup SRAM interface clock enable
            using CRCEN = Field<12, 1>;    // CRC clock enable
            using GPIOKEN = Field<10, 1>;    // IO port K clock enable
            using GPIOJEN = Field<9, 1>;    // IO port J clock enable
            using GPIOIEN = Field<8, 1>;    // IO port I clock enable
            using GPIOHEN = Field<7, 1>;    // IO port H clock enable
            using GPIOGEN = Field<6, 1>;    // IO port G clock enable
            using GPIOFEN = Field<5, 1>;    // IO port F clock enable
            using GPIOEEN = Field<4, 1>;    // IO port E clock enable
            using GPIODEN = Field<3, 1>;    // IO port D clock enable
            using GPIOCEN = Field<2, 1>;    // IO port C clock enable
            using GPIOBEN = Field<1, 1>;    // IO port B clock enable
            using GPIOAEN = Field<0, 1>;    // IO port A clock enable
        };

        // AHB2 peripheral clock enable register
        struct AHB2ENR : public Register<0x40023834> {
            using OTGFSEN = Field<7, 1>;    // USB OTG FS clock enable
            using RNGEN = Field<6, 1>;    // Random number generator clock enable
            using HASHEN = Field<5, 1>;    // Hash modules clock enable
            using CRYPEN = Field<4, 1>;    // Cryptographic modules clock enable
            using DCMIEN = Field<0, 1>;    // Camera interface enable
        };

        // AHB3 peripheral clock enable register
        struct AHB3ENR : public Register<0x40023838> {
            using FMCEN = Field<0, 1>;    // Flexible memory controller module clock enable
            using QSPIEN = Field<1, 1>;    // Quad SPI memory controller clock enable
        };

        // APB1 peripheral clock enable register
        struct APB1ENR : public Register<0x40023840> {
            using TIM2EN = Field<0, 1>;    // TIM2 clock enable
            using TIM3EN = Field<1, 1>;    // TIM3 clock enable
            using TIM4EN = Field<2, 1>;    // TIM4 clock enable
            using TIM5EN = Field<3, 1>;    // TIM5 clock enable
            using TIM6EN = Field<4, 1>;    // TIM6 clock enable
            using TIM7EN = Field<5, 1>;    // TIM7 clock enable
            using TIM12EN = Field<6, 1>;    // TIM12 clock enable
            using TIM13EN = Field<7, 1>;    // TIM13 clock enable
            using TIM14EN = Field<8, 1>;    // TIM14 clock enable
            using WWDGEN = Field<11, 1>;    // Window watchdog clock enable
            using SPI2EN = Field<14, 1>;    // SPI2 clock enable
            using SPI3EN = Field<15, 1>;    // SPI3 clock enable
            using USART2EN = Field<17, 1>;    // USART 2 clock enable
            using USART3EN = Field<18, 1>;    // USART3 clock enable
            using UART4EN = Field<19, 1>;    // UART4 clock enable
            using UART5EN = Field<20, 1>;    // UART5 clock enable
            using I2C1EN = Field<21, 1>;    // I2C1 clock enable
            using I2C2EN = Field<22, 1>;    // I2C2 clock enable
            using I2C3EN = Field<23, 1>;    // I2C3 clock enable
            using CAN1EN = Field<25, 1>;    // CAN 1 clock enable
            using CAN2EN = Field<26, 1>;    // CAN 2 clock enable
            using PWREN = Field<28, 1>;    // Power interface clock enable
            using DACEN = Field<29, 1>;    // DAC interface clock enable
            using UART7ENR = Field<30, 1>;    // UART7 clock enable
            using UART8ENR = Field<31, 1>;    // UART8 clock enable
            using SPDIFRXEN = Field<16, 1>;    // SPDIF-RX clock enable
            using CECEN = Field<27, 1>;    // HDMI-CEN clock enable
            using LPTMI1EN = Field<9, 1>;    // Low power timer 1 clock enable
            using I2C4EN = Field<24, 1>;    // I2C4 clock enable
        };

        // APB2 peripheral clock enable register
        struct APB2ENR : public Register<0x40023844> {
            using TIM1EN = Field<0, 1>;    // TIM1 clock enable
            using TIM8EN = Field<1, 1>;    // TIM8 clock enable
            using USART1EN = Field<4, 1>;    // USART1 clock enable
            using USART6EN = Field<5, 1>;    // USART6 clock enable
            using ADC1EN = Field<8, 1>;    // ADC1 clock enable
            using ADC2EN = Field<9, 1>;    // ADC2 clock enable
            using ADC3EN = Field<10, 1>;    // ADC3 clock enable
            using SPI1EN = Field<12, 1>;    // SPI1 clock enable
            using SPI4ENR = Field<13, 1>;    // SPI4 clock enable
            using SYSCFGEN = Field<14, 1>;    // System configuration controller clock enable
            using TIM9EN = Field<16, 1>;    // TIM9 clock enable
            using TIM10EN = Field<17, 1>;    // TIM10 clock enable
            using TIM11EN = Field<18, 1>;    // TIM11 clock enable
            using SPI5ENR = Field<20, 1>;    // SPI5 clock enable
            using SPI6ENR = Field<21, 1>;    // SPI6 clock enable
            using SAI1EN = Field<22, 1>;    // SAI1 clock enable
            using LTDCEN = Field<26, 1>;    // LTDC clock enable
            using SAI2EN = Field<23, 1>;    // SAI2 clock enable
            using SDMMC1EN = Field<11, 1>;    // SDMMC1 clock enable
        };

        // AHB1 peripheral clock enable in low power mode register
        struct AHB1LPENR : public Register<0x40023850> {
            using GPIOALPEN = Field<0, 1>;    // IO port A clock enable during sleep mode
            using GPIOBLPEN = Field<1, 1>;    // IO port B clock enable during Sleep mode
            using GPIOCLPEN = Field<2, 1>;    // IO port C clock enable during Sleep mode
            using GPIODLPEN = Field<3, 1>;    // IO port D clock enable during Sleep mode
            using GPIOELPEN = Field<4, 1>;    // IO port E clock enable during Sleep mode
            using GPIOFLPEN = Field<5, 1>;    // IO port F clock enable during Sleep mode
            using GPIOGLPEN = Field<6, 1>;    // IO port G clock enable during Sleep mode
            using GPIOHLPEN = Field<7, 1>;    // IO port H clock enable during Sleep mode
            using GPIOILPEN = Field<8, 1>;    // IO port I clock enable during Sleep mode
            using GPIOJLPEN = Field<9, 1>;    // IO port J clock enable during Sleep mode
            using GPIOKLPEN = Field<10, 1>;    // IO port K clock enable during Sleep mode
            using CRCLPEN = Field<12, 1>;    // CRC clock enable during Sleep mode
            using FLITFLPEN = Field<15, 1>;    // Flash interface clock enable during Sleep mode
            using SRAM1LPEN = Field<16, 1>;    // SRAM 1interface clock enable during Sleep mode
            using SRAM2LPEN = Field<17, 1>;    // SRAM 2 interface clock enable during Sleep mode
            using BKPSRAMLPEN = Field<18, 1>;    // Backup SRAM interface clock enable during Sleep mode
            using SRAM3LPEN = Field<19, 1>;    // SRAM 3 interface clock enable during Sleep mode
            using DMA1LPEN = Field<21, 1>;    // DMA1 clock enable during Sleep mode
            using DMA2LPEN = Field<22, 1>;    // DMA2 clock enable during Sleep mode
            using DMA2DLPEN = Field<23, 1>;    // DMA2D clock enable during Sleep mode
            using ETHMACLPEN = Field<25, 1>;    // Ethernet MAC clock enable during Sleep mode
            using ETHMACTXLPEN = Field<26, 1>;    // Ethernet transmission clock enable during Sleep mode
            using ETHMACRXLPEN = Field<27, 1>;    // Ethernet reception clock enable during Sleep mode
            using ETHMACPTPLPEN = Field<28, 1>;    // Ethernet PTP clock enable during Sleep mode
            using OTGHSLPEN = Field<29, 1>;    // USB OTG HS clock enable during Sleep mode
            using OTGHSULPILPEN = Field<30, 1>;    // USB OTG HS ULPI clock enable during Sleep mode
        };

        // AHB2 peripheral clock enable in low power mode register
        struct AHB2LPENR : public Register<0x40023854> {
            using OTGFSLPEN = Field<7, 1>;    // USB OTG FS clock enable during Sleep mode
            using RNGLPEN = Field<6, 1>;    // Random number generator clock enable during Sleep mode
            using HASHLPEN = Field<5, 1>;    // Hash modules clock enable during Sleep mode
            using CRYPLPEN = Field<4, 1>;    // Cryptography modules clock enable during Sleep mode
            using DCMILPEN = Field<0, 1>;    // Camera interface enable during Sleep mode
        };

        // AHB3 peripheral clock enable in low power mode register
        struct AHB3LPENR : public Register<0x40023858> {
            using FMCLPEN = Field<0, 1>;    // Flexible memory controller module clock enable during Sleep mode
            using QSPILPEN = Field<1, 1>;    // Quand SPI memory controller clock enable during Sleep mode
        };

        // APB1 peripheral clock enable in low power mode register
        struct APB1LPENR : public Register<0x40023860> {
            using TIM2LPEN = Field<0, 1>;    // TIM2 clock enable during Sleep mode
            using TIM3LPEN = Field<1, 1>;    // TIM3 clock enable during Sleep mode
            using TIM4LPEN = Field<2, 1>;    // TIM4 clock enable during Sleep mode
            using TIM5LPEN = Field<3, 1>;    // TIM5 clock enable during Sleep mode
            using TIM6LPEN = Field<4, 1>;    // TIM6 clock enable during Sleep mode
            using TIM7LPEN = Field<5, 1>;    // TIM7 clock enable during Sleep mode
            using TIM12LPEN = Field<6, 1>;    // TIM12 clock enable during Sleep mode
            using TIM13LPEN = Field<7, 1>;    // TIM13 clock enable during Sleep mode
            using TIM14LPEN = Field<8, 1>;    // TIM14 clock enable during Sleep mode
            using WWDGLPEN = Field<11, 1>;    // Window watchdog clock enable during Sleep mode
            using SPI2LPEN = Field<14, 1>;    // SPI2 clock enable during Sleep mode
            using SPI3LPEN = Field<15, 1>;    // SPI3 clock enable during Sleep mode
            using USART2LPEN = Field<17, 1>;    // USART2 clock enable during Sleep mode
            using USART3LPEN = Field<18, 1>;    // USART3 clock enable during Sleep mode
            using UART4LPEN = Field<19, 1>;    // UART4 clock enable during Sleep mode
            using UART5LPEN = Field<20, 1>;    // UART5 clock enable during Sleep mode
            using I2C1LPEN = Field<21, 1>;    // I2C1 clock enable during Sleep mode
            using I2C2LPEN = Field<22, 1>;    // I2C2 clock enable during Sleep mode
            using I2C3LPEN = Field<23, 1>;    // I2C3 clock enable during Sleep mode
            using CAN1LPEN = Field<25, 1>;    // CAN 1 clock enable during Sleep mode
            using CAN2LPEN = Field<26, 1>;    // CAN 2 clock enable during Sleep mode
            using PWRLPEN = Field<28, 1>;    // Power interface clock enable during Sleep mode
            using DACLPEN = Field<29, 1>;    // DAC interface clock enable during Sleep mode
            using UART7LPEN = Field<30, 1>;    // UART7 clock enable during Sleep mode
            using UART8LPEN = Field<31, 1>;    // UART8 clock enable during Sleep mode
            using SPDIFRXLPEN = Field<16, 1>;    // SPDIF-RX clock enable during sleep mode
            using CECLPEN = Field<27, 1>;    // HDMI-CEN clock enable during Sleep mode
            using LPTIM1LPEN = Field<9, 1>;    // low power timer 1 clock enable during Sleep mode
            using I2C4LPEN = Field<24, 1>;    // I2C4 clock enable during Sleep mode
        };

        // APB2 peripheral clock enabled in low power mode register
        struct APB2LPENR : public Register<0x40023864> {
            using TIM1LPEN = Field<0, 1>;    // TIM1 clock enable during Sleep mode
            using TIM8LPEN = Field<1, 1>;    // TIM8 clock enable during Sleep mode
            using USART1LPEN = Field<4, 1>;    // USART1 clock enable during Sleep mode
            using USART6LPEN = Field<5, 1>;    // USART6 clock enable during Sleep mode
            using ADC1LPEN = Field<8, 1>;    // ADC1 clock enable during Sleep mode
            using ADC2LPEN = Field<9, 1>;    // ADC2 clock enable during Sleep mode
            using ADC3LPEN = Field<10, 1>;    // ADC 3 clock enable during Sleep mode
            using SPI1LPEN = Field<12, 1>;    // SPI 1 clock enable during Sleep mode
            using SPI4LPEN = Field<13, 1>;    // SPI 4 clock enable during Sleep mode
            using SYSCFGLPEN = Field<14, 1>;    // System configuration controller clock enable during Sleep mode
            using TIM9LPEN = Field<16, 1>;    // TIM9 clock enable during sleep mode
            using TIM10LPEN = Field<17, 1>;    // TIM10 clock enable during Sleep mode
            using TIM11LPEN = Field<18, 1>;    // TIM11 clock enable during Sleep mode
            using SPI5LPEN = Field<20, 1>;    // SPI 5 clock enable during Sleep mode
            using SPI6LPEN = Field<21, 1>;    // SPI 6 clock enable during Sleep mode
            using SAI1LPEN = Field<22, 1>;    // SAI1 clock enable during sleep mode
            using LTDCLPEN = Field<26, 1>;    // LTDC clock enable during sleep mode
            using SAI2LPEN = Field<23, 1>;    // SAI2 clock enable during sleep mode
            using SDMMC1LPEN = Field<11, 1>;    // SDMMC1 clock enable during Sleep mode
        };

        // Backup domain control register
        struct BDCR : public Register<0x40023870> {
            using BDRST = Field<16, 1>;    // Backup domain software reset
            using RTCEN = Field<15, 1>;    // RTC clock enable
            using RTCSEL1 = Field<9, 1>;    // RTC clock source selection
            using RTCSEL0 = Field<8, 1>;    // RTC clock source selection
            using LSEBYP = Field<2, 1>;    // External low-speed oscillator bypass
            using LSERDY = Field<1, 1>;    // External low-speed oscillator ready
            using LSEON = Field<0, 1>;    // External low-speed oscillator enable
        };

        // clock control & status register
        struct CSR : public Register<0x40023874> {
            using LPWRRSTF = Field<31, 1>;    // Low-power reset flag
            using WWDGRSTF = Field<30, 1>;    // Window watchdog reset flag
            using WDGRSTF = Field<29, 1>;    // Independent watchdog reset flag
            using SFTRSTF = Field<28, 1>;    // Software reset flag
            using PORRSTF = Field<27, 1>;    // POR/PDR reset flag
            using PADRSTF = Field<26, 1>;    // PIN reset flag
            using BORRSTF = Field<25, 1>;    // BOR reset flag
            using RMVF = Field<24, 1>;    // Remove reset flag
            using LSIRDY = Field<1, 1>;    // Internal low-speed oscillator ready
            using LSION = Field<0, 1>;    // Internal low-speed oscillator enable
        };

        // spread spectrum clock generation register
        struct SSCGR : public Register<0x40023880> {
            using SSCGEN = Field<31, 1>;    // Spread spectrum modulation enable
            using SPREADSEL = Field<30, 1>;    // Spread Select
            using INCSTEP = Field<13, 15>;    // Incrementation step
            using MODPER = Field<0, 13>;    // Modulation period
        };

        // PLLI2S configuration register
        struct PLLI2SCFGR : public Register<0x40023884> {
            using PLLI2SR = Field<28, 3>;    // PLLI2S division factor for I2S clocks
            using PLLI2SQ = Field<24, 4>;    // PLLI2S division factor for SAI1 clock
            using PLLI2SN = Field<6, 9>;    // PLLI2S multiplication factor for VCO
        };

        // PLL configuration register
        struct PLLSAICFGR : public Register<0x40023888> {
            using PLLSAIN = Field<6, 9>;    // PLLSAI division factor for VCO
            using PLLSAIP = Field<16, 2>;    // PLLSAI division factor for 48MHz clock
            using PLLSAIQ = Field<24, 4>;    // PLLSAI division factor for SAI clock
            using PLLSAIR = Field<28, 3>;    // PLLSAI division factor for LCD clock
        };

        // dedicated clocks configuration register
        struct DKCFGR1 : public Register<0x4002388c> {
            using PLLI2SDIV = Field<0, 5>;    // PLLI2S division factor for SAI1 clock
            using PLLSAIDIVQ = Field<8, 5>;    // PLLSAI division factor for SAI1 clock
            using PLLSAIDIVR = Field<16, 2>;    // division factor for LCD_CLK
            using SAI1SEL = Field<20, 2>;    // SAI1 clock source selection
            using SAI2SEL = Field<22, 2>;    // SAI2 clock source selection
            using TIMPRE = Field<24, 1>;    // Timers clocks prescalers selection
        };

        // dedicated clocks configuration register
        struct DKCFGR2 : public Register<0x40023890> {
            using USART1SEL = Field<0, 2>;    // USART 1 clock source selection
            using USART2SEL = Field<2, 2>;    // USART 2 clock source selection
            using USART3SEL = Field<4, 2>;    // USART 3 clock source selection
            using UART4SEL = Field<6, 2>;    // UART 4 clock source selection
            using UART5SEL = Field<8, 2>;    // UART 5 clock source selection
            using USART6SEL = Field<10, 2>;    // USART 6 clock source selection
            using UART7SEL = Field<12, 2>;    // UART 7 clock source selection
            using UART8SEL = Field<14, 2>;    // UART 8 clock source selection
            using I2C1SEL = Field<16, 2>;    // I2C1 clock source selection
            using I2C2SEL = Field<18, 2>;    // I2C2 clock source selection
            using I2C3SEL = Field<20, 2>;    // I2C3 clock source selection
            using I2C4SEL = Field<22, 2>;    // I2C4 clock source selection
            using LPTIM1SEL = Field<24, 2>;    // Low power timer 1 clock source selection
            using CECSEL = Field<26, 1>;    // HDMI-CEC clock source selection
            using CK48MSEL = Field<27, 1>;    // 48MHz clock source selection
            using SDMMCSEL = Field<28, 1>;    // SDMMC clock source selection
        };

    };

    // General-purpose I/Os
    struct GPIOD {
        // GPIO port mode register
        struct MODER : public Register<0x40020c00> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x40020c04> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct GPIOB_OSPEEDR : public Register<0x40020c08> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x40020c0c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public RegisterReadOnly<0x40020c10> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x40020c14> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public RegisterWriteOnly<0x40020c18> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x40020c1c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function lowregister
        struct AFRL : public Register<0x40020c20> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x40020c24> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x40020c28> {
            using BR0 = Field<0, 1>;    // Port D Reset bit 0
            using BR1 = Field<1, 1>;    // Port D Reset bit 1
            using BR2 = Field<2, 1>;    // Port D Reset bit 2
            using BR3 = Field<3, 1>;    // Port D Reset bit 3
            using BR4 = Field<4, 1>;    // Port D Reset bit 4
            using BR5 = Field<5, 1>;    // Port D Reset bit 5
            using BR6 = Field<6, 1>;    // Port D Reset bit 6
            using BR7 = Field<7, 1>;    // Port D Reset bit 7
            using BR8 = Field<8, 1>;    // Port D Reset bit 8
            using BR9 = Field<9, 1>;    // Port D Reset bit 9
            using BR10 = Field<10, 1>;    // Port D Reset bit 10
            using BR11 = Field<11, 1>;    // Port D Reset bit 11
            using BR12 = Field<12, 1>;    // Port D Reset bit 12
            using BR13 = Field<13, 1>;    // Port D Reset bit 13
            using BR14 = Field<14, 1>;    // Port D Reset bit 14
            using BR15 = Field<15, 1>;    // Port D Reset bit 15
        };

    };

    // General-purpose I/Os
    struct GPIOC {
        // GPIO port mode register
        struct MODER : public Register<0x40020800> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x40020804> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct GPIOB_OSPEEDR : public Register<0x40020808> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4002080c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public RegisterReadOnly<0x40020810> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x40020814> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public RegisterWriteOnly<0x40020818> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4002081c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function lowregister
        struct AFRL : public Register<0x40020820> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x40020824> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x40020828> {
            using BR0 = Field<0, 1>;    // Port D Reset bit 0
            using BR1 = Field<1, 1>;    // Port D Reset bit 1
            using BR2 = Field<2, 1>;    // Port D Reset bit 2
            using BR3 = Field<3, 1>;    // Port D Reset bit 3
            using BR4 = Field<4, 1>;    // Port D Reset bit 4
            using BR5 = Field<5, 1>;    // Port D Reset bit 5
            using BR6 = Field<6, 1>;    // Port D Reset bit 6
            using BR7 = Field<7, 1>;    // Port D Reset bit 7
            using BR8 = Field<8, 1>;    // Port D Reset bit 8
            using BR9 = Field<9, 1>;    // Port D Reset bit 9
            using BR10 = Field<10, 1>;    // Port D Reset bit 10
            using BR11 = Field<11, 1>;    // Port D Reset bit 11
            using BR12 = Field<12, 1>;    // Port D Reset bit 12
            using BR13 = Field<13, 1>;    // Port D Reset bit 13
            using BR14 = Field<14, 1>;    // Port D Reset bit 14
            using BR15 = Field<15, 1>;    // Port D Reset bit 15
        };

    };

    // General-purpose I/Os
    struct GPIOK {
        // GPIO port mode register
        struct MODER : public Register<0x40022800> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x40022804> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct GPIOB_OSPEEDR : public Register<0x40022808> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4002280c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public RegisterReadOnly<0x40022810> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x40022814> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public RegisterWriteOnly<0x40022818> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4002281c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function lowregister
        struct AFRL : public Register<0x40022820> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x40022824> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x40022828> {
            using BR0 = Field<0, 1>;    // Port D Reset bit 0
            using BR1 = Field<1, 1>;    // Port D Reset bit 1
            using BR2 = Field<2, 1>;    // Port D Reset bit 2
            using BR3 = Field<3, 1>;    // Port D Reset bit 3
            using BR4 = Field<4, 1>;    // Port D Reset bit 4
            using BR5 = Field<5, 1>;    // Port D Reset bit 5
            using BR6 = Field<6, 1>;    // Port D Reset bit 6
            using BR7 = Field<7, 1>;    // Port D Reset bit 7
            using BR8 = Field<8, 1>;    // Port D Reset bit 8
            using BR9 = Field<9, 1>;    // Port D Reset bit 9
            using BR10 = Field<10, 1>;    // Port D Reset bit 10
            using BR11 = Field<11, 1>;    // Port D Reset bit 11
            using BR12 = Field<12, 1>;    // Port D Reset bit 12
            using BR13 = Field<13, 1>;    // Port D Reset bit 13
            using BR14 = Field<14, 1>;    // Port D Reset bit 14
            using BR15 = Field<15, 1>;    // Port D Reset bit 15
        };

    };

    // General-purpose I/Os
    struct GPIOJ {
        // GPIO port mode register
        struct MODER : public Register<0x40022400> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x40022404> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct GPIOB_OSPEEDR : public Register<0x40022408> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4002240c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public RegisterReadOnly<0x40022410> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x40022414> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public RegisterWriteOnly<0x40022418> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4002241c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function lowregister
        struct AFRL : public Register<0x40022420> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x40022424> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x40022428> {
            using BR0 = Field<0, 1>;    // Port D Reset bit 0
            using BR1 = Field<1, 1>;    // Port D Reset bit 1
            using BR2 = Field<2, 1>;    // Port D Reset bit 2
            using BR3 = Field<3, 1>;    // Port D Reset bit 3
            using BR4 = Field<4, 1>;    // Port D Reset bit 4
            using BR5 = Field<5, 1>;    // Port D Reset bit 5
            using BR6 = Field<6, 1>;    // Port D Reset bit 6
            using BR7 = Field<7, 1>;    // Port D Reset bit 7
            using BR8 = Field<8, 1>;    // Port D Reset bit 8
            using BR9 = Field<9, 1>;    // Port D Reset bit 9
            using BR10 = Field<10, 1>;    // Port D Reset bit 10
            using BR11 = Field<11, 1>;    // Port D Reset bit 11
            using BR12 = Field<12, 1>;    // Port D Reset bit 12
            using BR13 = Field<13, 1>;    // Port D Reset bit 13
            using BR14 = Field<14, 1>;    // Port D Reset bit 14
            using BR15 = Field<15, 1>;    // Port D Reset bit 15
        };

    };

    // General-purpose I/Os
    struct GPIOI {
        // GPIO port mode register
        struct MODER : public Register<0x40022000> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x40022004> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct GPIOB_OSPEEDR : public Register<0x40022008> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4002200c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public RegisterReadOnly<0x40022010> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x40022014> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public RegisterWriteOnly<0x40022018> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4002201c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function lowregister
        struct AFRL : public Register<0x40022020> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x40022024> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x40022028> {
            using BR0 = Field<0, 1>;    // Port D Reset bit 0
            using BR1 = Field<1, 1>;    // Port D Reset bit 1
            using BR2 = Field<2, 1>;    // Port D Reset bit 2
            using BR3 = Field<3, 1>;    // Port D Reset bit 3
            using BR4 = Field<4, 1>;    // Port D Reset bit 4
            using BR5 = Field<5, 1>;    // Port D Reset bit 5
            using BR6 = Field<6, 1>;    // Port D Reset bit 6
            using BR7 = Field<7, 1>;    // Port D Reset bit 7
            using BR8 = Field<8, 1>;    // Port D Reset bit 8
            using BR9 = Field<9, 1>;    // Port D Reset bit 9
            using BR10 = Field<10, 1>;    // Port D Reset bit 10
            using BR11 = Field<11, 1>;    // Port D Reset bit 11
            using BR12 = Field<12, 1>;    // Port D Reset bit 12
            using BR13 = Field<13, 1>;    // Port D Reset bit 13
            using BR14 = Field<14, 1>;    // Port D Reset bit 14
            using BR15 = Field<15, 1>;    // Port D Reset bit 15
        };

    };

    // General-purpose I/Os
    struct GPIOH {
        // GPIO port mode register
        struct MODER : public Register<0x40021c00> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x40021c04> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct GPIOB_OSPEEDR : public Register<0x40021c08> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x40021c0c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public RegisterReadOnly<0x40021c10> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x40021c14> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public RegisterWriteOnly<0x40021c18> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x40021c1c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function lowregister
        struct AFRL : public Register<0x40021c20> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x40021c24> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x40021c28> {
            using BR0 = Field<0, 1>;    // Port D Reset bit 0
            using BR1 = Field<1, 1>;    // Port D Reset bit 1
            using BR2 = Field<2, 1>;    // Port D Reset bit 2
            using BR3 = Field<3, 1>;    // Port D Reset bit 3
            using BR4 = Field<4, 1>;    // Port D Reset bit 4
            using BR5 = Field<5, 1>;    // Port D Reset bit 5
            using BR6 = Field<6, 1>;    // Port D Reset bit 6
            using BR7 = Field<7, 1>;    // Port D Reset bit 7
            using BR8 = Field<8, 1>;    // Port D Reset bit 8
            using BR9 = Field<9, 1>;    // Port D Reset bit 9
            using BR10 = Field<10, 1>;    // Port D Reset bit 10
            using BR11 = Field<11, 1>;    // Port D Reset bit 11
            using BR12 = Field<12, 1>;    // Port D Reset bit 12
            using BR13 = Field<13, 1>;    // Port D Reset bit 13
            using BR14 = Field<14, 1>;    // Port D Reset bit 14
            using BR15 = Field<15, 1>;    // Port D Reset bit 15
        };

    };

    // General-purpose I/Os
    struct GPIOG {
        // GPIO port mode register
        struct MODER : public Register<0x40021800> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x40021804> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct GPIOB_OSPEEDR : public Register<0x40021808> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4002180c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public RegisterReadOnly<0x40021810> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x40021814> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public RegisterWriteOnly<0x40021818> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4002181c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function lowregister
        struct AFRL : public Register<0x40021820> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x40021824> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x40021828> {
            using BR0 = Field<0, 1>;    // Port D Reset bit 0
            using BR1 = Field<1, 1>;    // Port D Reset bit 1
            using BR2 = Field<2, 1>;    // Port D Reset bit 2
            using BR3 = Field<3, 1>;    // Port D Reset bit 3
            using BR4 = Field<4, 1>;    // Port D Reset bit 4
            using BR5 = Field<5, 1>;    // Port D Reset bit 5
            using BR6 = Field<6, 1>;    // Port D Reset bit 6
            using BR7 = Field<7, 1>;    // Port D Reset bit 7
            using BR8 = Field<8, 1>;    // Port D Reset bit 8
            using BR9 = Field<9, 1>;    // Port D Reset bit 9
            using BR10 = Field<10, 1>;    // Port D Reset bit 10
            using BR11 = Field<11, 1>;    // Port D Reset bit 11
            using BR12 = Field<12, 1>;    // Port D Reset bit 12
            using BR13 = Field<13, 1>;    // Port D Reset bit 13
            using BR14 = Field<14, 1>;    // Port D Reset bit 14
            using BR15 = Field<15, 1>;    // Port D Reset bit 15
        };

    };

    // General-purpose I/Os
    struct GPIOF {
        // GPIO port mode register
        struct MODER : public Register<0x40021400> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x40021404> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct GPIOB_OSPEEDR : public Register<0x40021408> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4002140c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public RegisterReadOnly<0x40021410> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x40021414> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public RegisterWriteOnly<0x40021418> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4002141c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function lowregister
        struct AFRL : public Register<0x40021420> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x40021424> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x40021428> {
            using BR0 = Field<0, 1>;    // Port D Reset bit 0
            using BR1 = Field<1, 1>;    // Port D Reset bit 1
            using BR2 = Field<2, 1>;    // Port D Reset bit 2
            using BR3 = Field<3, 1>;    // Port D Reset bit 3
            using BR4 = Field<4, 1>;    // Port D Reset bit 4
            using BR5 = Field<5, 1>;    // Port D Reset bit 5
            using BR6 = Field<6, 1>;    // Port D Reset bit 6
            using BR7 = Field<7, 1>;    // Port D Reset bit 7
            using BR8 = Field<8, 1>;    // Port D Reset bit 8
            using BR9 = Field<9, 1>;    // Port D Reset bit 9
            using BR10 = Field<10, 1>;    // Port D Reset bit 10
            using BR11 = Field<11, 1>;    // Port D Reset bit 11
            using BR12 = Field<12, 1>;    // Port D Reset bit 12
            using BR13 = Field<13, 1>;    // Port D Reset bit 13
            using BR14 = Field<14, 1>;    // Port D Reset bit 14
            using BR15 = Field<15, 1>;    // Port D Reset bit 15
        };

    };

    // General-purpose I/Os
    struct GPIOE {
        // GPIO port mode register
        struct MODER : public Register<0x40021000> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x40021004> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct GPIOB_OSPEEDR : public Register<0x40021008> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4002100c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public RegisterReadOnly<0x40021010> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x40021014> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public RegisterWriteOnly<0x40021018> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4002101c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function lowregister
        struct AFRL : public Register<0x40021020> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x40021024> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x40021028> {
            using BR0 = Field<0, 1>;    // Port D Reset bit 0
            using BR1 = Field<1, 1>;    // Port D Reset bit 1
            using BR2 = Field<2, 1>;    // Port D Reset bit 2
            using BR3 = Field<3, 1>;    // Port D Reset bit 3
            using BR4 = Field<4, 1>;    // Port D Reset bit 4
            using BR5 = Field<5, 1>;    // Port D Reset bit 5
            using BR6 = Field<6, 1>;    // Port D Reset bit 6
            using BR7 = Field<7, 1>;    // Port D Reset bit 7
            using BR8 = Field<8, 1>;    // Port D Reset bit 8
            using BR9 = Field<9, 1>;    // Port D Reset bit 9
            using BR10 = Field<10, 1>;    // Port D Reset bit 10
            using BR11 = Field<11, 1>;    // Port D Reset bit 11
            using BR12 = Field<12, 1>;    // Port D Reset bit 12
            using BR13 = Field<13, 1>;    // Port D Reset bit 13
            using BR14 = Field<14, 1>;    // Port D Reset bit 14
            using BR15 = Field<15, 1>;    // Port D Reset bit 15
        };

    };

    // General-purpose I/Os
    struct GPIOB {
        // GPIO port mode register
        struct MODER : public Register<0x40020400> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x40020404> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct GPIOB_OSPEEDR : public Register<0x40020408> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4002040c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public RegisterReadOnly<0x40020410> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x40020414> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public RegisterWriteOnly<0x40020418> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4002041c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x40020420> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x40020424> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x40020428> {
            using BR0 = Field<0, 1>;    // Port B Reset bit 0
            using BR1 = Field<1, 1>;    // Port B Reset bit 1
            using BR2 = Field<2, 1>;    // Port B Reset bit 2
            using BR3 = Field<3, 1>;    // Port B Reset bit 3
            using BR4 = Field<4, 1>;    // Port B Reset bit 4
            using BR5 = Field<5, 1>;    // Port B Reset bit 5
            using BR6 = Field<6, 1>;    // Port B Reset bit 6
            using BR7 = Field<7, 1>;    // Port B Reset bit 7
            using BR8 = Field<8, 1>;    // Port B Reset bit 8
            using BR9 = Field<9, 1>;    // Port B Reset bit 9
            using BR10 = Field<10, 1>;    // Port B Reset bit 10
            using BR11 = Field<11, 1>;    // Port B Reset bit 11
            using BR12 = Field<12, 1>;    // Port B Reset bit 12
            using BR13 = Field<13, 1>;    // Port B Reset bit 13
            using BR14 = Field<14, 1>;    // Port B Reset bit 14
            using BR15 = Field<15, 1>;    // Port B Reset bit 15
        };

    };

    // General-purpose I/Os
    struct GPIOA {
        // GPIO port mode register
        struct MODER : public Register<0x40020000> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x40020004> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct GPIOB_OSPEEDR : public Register<0x40020008> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4002000c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public RegisterReadOnly<0x40020010> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x40020014> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public RegisterWriteOnly<0x40020018> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4002001c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x40020020> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x40020024> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x40020028> {
            using BR0 = Field<0, 1>;    // Port A Reset bit 0
            using BR1 = Field<1, 1>;    // Port A Reset bit 1
            using BR2 = Field<2, 1>;    // Port A Reset bit 2
            using BR3 = Field<3, 1>;    // Port A Reset bit 3
            using BR4 = Field<4, 1>;    // Port A Reset bit 4
            using BR5 = Field<5, 1>;    // Port A Reset bit 5
            using BR6 = Field<6, 1>;    // Port A Reset bit 6
            using BR7 = Field<7, 1>;    // Port A Reset bit 7
            using BR8 = Field<8, 1>;    // Port A Reset bit 8
            using BR9 = Field<9, 1>;    // Port A Reset bit 9
            using BR10 = Field<10, 1>;    // Port A Reset bit 10
            using BR11 = Field<11, 1>;    // Port A Reset bit 11
            using BR12 = Field<12, 1>;    // Port A Reset bit 12
            using BR13 = Field<13, 1>;    // Port A Reset bit 13
            using BR14 = Field<14, 1>;    // Port A Reset bit 14
            using BR15 = Field<15, 1>;    // Port A Reset bit 15
        };

    };

    // System configuration controller
    struct SYSCFG {
        // memory remap register
        struct MEMRM : public Register<0x40013800> {
            using MEM_MODE = Field<0, 3>;    // Memory mapping selection
            using FB_MODE = Field<8, 1>;    // Flash bank mode selection
            using SWP_FMC = Field<10, 2>;    // FMC memory mapping swap
        };

        // peripheral mode configuration register
        struct PMC : public Register<0x40013804> {
            using MII_RMII_SEL = Field<23, 1>;    // Ethernet PHY interface selection
            using ADC1DC2 = Field<16, 1>;    // ADC1DC2
            using ADC2DC2 = Field<17, 1>;    // ADC2DC2
            using ADC3DC2 = Field<18, 1>;    // ADC3DC2
        };

        // external interrupt configuration register 1
        struct EXTICR1 : public Register<0x40013808> {
            using EXTI3 = Field<12, 4>;    // EXTI x configuration (x = 0 to 3)
            using EXTI2 = Field<8, 4>;    // EXTI x configuration (x = 0 to 3)
            using EXTI1 = Field<4, 4>;    // EXTI x configuration (x = 0 to 3)
            using EXTI0 = Field<0, 4>;    // EXTI x configuration (x = 0 to 3)
        };

        // external interrupt configuration register 2
        struct EXTICR2 : public Register<0x4001380c> {
            using EXTI7 = Field<12, 4>;    // EXTI x configuration (x = 4 to 7)
            using EXTI6 = Field<8, 4>;    // EXTI x configuration (x = 4 to 7)
            using EXTI5 = Field<4, 4>;    // EXTI x configuration (x = 4 to 7)
            using EXTI4 = Field<0, 4>;    // EXTI x configuration (x = 4 to 7)
        };

        // external interrupt configuration register 3
        struct EXTICR3 : public Register<0x40013810> {
            using EXTI11 = Field<12, 4>;    // EXTI x configuration (x = 8 to 11)
            using EXTI10 = Field<8, 4>;    // EXTI10
            using EXTI9 = Field<4, 4>;    // EXTI x configuration (x = 8 to 11)
            using EXTI8 = Field<0, 4>;    // EXTI x configuration (x = 8 to 11)
        };

        // external interrupt configuration register 4
        struct EXTICR4 : public Register<0x40013814> {
            using EXTI15 = Field<12, 4>;    // EXTI x configuration (x = 12 to 15)
            using EXTI14 = Field<8, 4>;    // EXTI x configuration (x = 12 to 15)
            using EXTI13 = Field<4, 4>;    // EXTI x configuration (x = 12 to 15)
            using EXTI12 = Field<0, 4>;    // EXTI x configuration (x = 12 to 15)
        };

        // Compensation cell control register
        struct CMPCR : public RegisterReadOnly<0x40013820> {
            using READY = Field<8, 1>;    // READY
            using CMP_PD = Field<0, 1>;    // Compensation cell power-down
        };

    };

    // Serial peripheral interface
    struct SPI1 {
        // control register 1
        struct CR1 : public Register<0x40013000> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using CRCL = Field<11, 1>;    // CRC length
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40013004> {
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using SSOE = Field<2, 1>;    // SS output enable
            using NSSP = Field<3, 1>;    // NSS pulse management
            using FRF = Field<4, 1>;    // Frame format
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
            using DS = Field<8, 4>;    // Data size
            using FRXTH = Field<12, 1>;    // FIFO reception threshold
            using LDMA_RX = Field<13, 1>;    // Last DMA transfer for reception
            using LDMA_TX = Field<14, 1>;    // Last DMA transfer for transmission
        };

        // status register
        struct SR : public Register<0x40013008> {
            using FRE = Field<8, 1>;    // Frame format error
            using BSY = Field<7, 1>;    // Busy flag
            using OVR = Field<6, 1>;    // Overrun flag
            using MODF = Field<5, 1>;    // Mode fault
            using CRCERR = Field<4, 1>;    // CRC error flag
            using UDR = Field<3, 1>;    // Underrun flag
            using CHSIDE = Field<2, 1>;    // Channel side
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using RXNE = Field<0, 1>;    // Receive buffer not empty
            using FRLVL = Field<9, 2>;    // FIFO reception level
            using FTLVL = Field<11, 2>;    // FIFO Transmission Level
        };

        // data register
        struct DR : public Register<0x4001300c> {
            using Field = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40013010> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public RegisterReadOnly<0x40013014> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public RegisterReadOnly<0x40013018> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

        // I2S configuration register
        struct I2SCFGR : public Register<0x4001301c> {
            using I2SMOD = Field<11, 1>;    // I2S mode selection
            using I2SE = Field<10, 1>;    // I2S Enable
            using I2SCFG = Field<8, 2>;    // I2S configuration mode
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using CKPOL = Field<3, 1>;    // Steady state clock polarity
            using DATLEN = Field<1, 2>;    // Data length to be transferred
            using CHLEN = Field<0, 1>;    // Channel length (number of bits per audio channel)
            using ASTRTEN = Field<12, 1>;    // Asynchronous start enable
        };

        // I2S prescaler register
        struct I2SPR : public Register<0x40013020> {
            using MCKOE = Field<9, 1>;    // Master clock output enable
            using ODD = Field<8, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<0, 8>;    // I2S Linear prescaler
        };

    };

    // Serial peripheral interface
    struct SPI2 {
        // control register 1
        struct CR1 : public Register<0x40003800> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using CRCL = Field<11, 1>;    // CRC length
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40003804> {
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using SSOE = Field<2, 1>;    // SS output enable
            using NSSP = Field<3, 1>;    // NSS pulse management
            using FRF = Field<4, 1>;    // Frame format
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
            using DS = Field<8, 4>;    // Data size
            using FRXTH = Field<12, 1>;    // FIFO reception threshold
            using LDMA_RX = Field<13, 1>;    // Last DMA transfer for reception
            using LDMA_TX = Field<14, 1>;    // Last DMA transfer for transmission
        };

        // status register
        struct SR : public Register<0x40003808> {
            using FRE = Field<8, 1>;    // Frame format error
            using BSY = Field<7, 1>;    // Busy flag
            using OVR = Field<6, 1>;    // Overrun flag
            using MODF = Field<5, 1>;    // Mode fault
            using CRCERR = Field<4, 1>;    // CRC error flag
            using UDR = Field<3, 1>;    // Underrun flag
            using CHSIDE = Field<2, 1>;    // Channel side
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using RXNE = Field<0, 1>;    // Receive buffer not empty
            using FRLVL = Field<9, 2>;    // FIFO reception level
            using FTLVL = Field<11, 2>;    // FIFO Transmission Level
        };

        // data register
        struct DR : public Register<0x4000380c> {
            using Field = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40003810> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public RegisterReadOnly<0x40003814> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public RegisterReadOnly<0x40003818> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

        // I2S configuration register
        struct I2SCFGR : public Register<0x4000381c> {
            using I2SMOD = Field<11, 1>;    // I2S mode selection
            using I2SE = Field<10, 1>;    // I2S Enable
            using I2SCFG = Field<8, 2>;    // I2S configuration mode
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using CKPOL = Field<3, 1>;    // Steady state clock polarity
            using DATLEN = Field<1, 2>;    // Data length to be transferred
            using CHLEN = Field<0, 1>;    // Channel length (number of bits per audio channel)
            using ASTRTEN = Field<12, 1>;    // Asynchronous start enable
        };

        // I2S prescaler register
        struct I2SPR : public Register<0x40003820> {
            using MCKOE = Field<9, 1>;    // Master clock output enable
            using ODD = Field<8, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<0, 8>;    // I2S Linear prescaler
        };

    };

    // Serial peripheral interface
    struct SPI3 {
        // control register 1
        struct CR1 : public Register<0x40003c00> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using CRCL = Field<11, 1>;    // CRC length
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40003c04> {
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using SSOE = Field<2, 1>;    // SS output enable
            using NSSP = Field<3, 1>;    // NSS pulse management
            using FRF = Field<4, 1>;    // Frame format
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
            using DS = Field<8, 4>;    // Data size
            using FRXTH = Field<12, 1>;    // FIFO reception threshold
            using LDMA_RX = Field<13, 1>;    // Last DMA transfer for reception
            using LDMA_TX = Field<14, 1>;    // Last DMA transfer for transmission
        };

        // status register
        struct SR : public Register<0x40003c08> {
            using FRE = Field<8, 1>;    // Frame format error
            using BSY = Field<7, 1>;    // Busy flag
            using OVR = Field<6, 1>;    // Overrun flag
            using MODF = Field<5, 1>;    // Mode fault
            using CRCERR = Field<4, 1>;    // CRC error flag
            using UDR = Field<3, 1>;    // Underrun flag
            using CHSIDE = Field<2, 1>;    // Channel side
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using RXNE = Field<0, 1>;    // Receive buffer not empty
            using FRLVL = Field<9, 2>;    // FIFO reception level
            using FTLVL = Field<11, 2>;    // FIFO Transmission Level
        };

        // data register
        struct DR : public Register<0x40003c0c> {
            using Field = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40003c10> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public RegisterReadOnly<0x40003c14> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public RegisterReadOnly<0x40003c18> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

        // I2S configuration register
        struct I2SCFGR : public Register<0x40003c1c> {
            using I2SMOD = Field<11, 1>;    // I2S mode selection
            using I2SE = Field<10, 1>;    // I2S Enable
            using I2SCFG = Field<8, 2>;    // I2S configuration mode
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using CKPOL = Field<3, 1>;    // Steady state clock polarity
            using DATLEN = Field<1, 2>;    // Data length to be transferred
            using CHLEN = Field<0, 1>;    // Channel length (number of bits per audio channel)
            using ASTRTEN = Field<12, 1>;    // Asynchronous start enable
        };

        // I2S prescaler register
        struct I2SPR : public Register<0x40003c20> {
            using MCKOE = Field<9, 1>;    // Master clock output enable
            using ODD = Field<8, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<0, 8>;    // I2S Linear prescaler
        };

    };

    // Serial peripheral interface
    struct SPI4 {
        // control register 1
        struct CR1 : public Register<0x40013400> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using CRCL = Field<11, 1>;    // CRC length
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40013404> {
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using SSOE = Field<2, 1>;    // SS output enable
            using NSSP = Field<3, 1>;    // NSS pulse management
            using FRF = Field<4, 1>;    // Frame format
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
            using DS = Field<8, 4>;    // Data size
            using FRXTH = Field<12, 1>;    // FIFO reception threshold
            using LDMA_RX = Field<13, 1>;    // Last DMA transfer for reception
            using LDMA_TX = Field<14, 1>;    // Last DMA transfer for transmission
        };

        // status register
        struct SR : public Register<0x40013408> {
            using FRE = Field<8, 1>;    // Frame format error
            using BSY = Field<7, 1>;    // Busy flag
            using OVR = Field<6, 1>;    // Overrun flag
            using MODF = Field<5, 1>;    // Mode fault
            using CRCERR = Field<4, 1>;    // CRC error flag
            using UDR = Field<3, 1>;    // Underrun flag
            using CHSIDE = Field<2, 1>;    // Channel side
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using RXNE = Field<0, 1>;    // Receive buffer not empty
            using FRLVL = Field<9, 2>;    // FIFO reception level
            using FTLVL = Field<11, 2>;    // FIFO Transmission Level
        };

        // data register
        struct DR : public Register<0x4001340c> {
            using Field = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40013410> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public RegisterReadOnly<0x40013414> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public RegisterReadOnly<0x40013418> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

        // I2S configuration register
        struct I2SCFGR : public Register<0x4001341c> {
            using I2SMOD = Field<11, 1>;    // I2S mode selection
            using I2SE = Field<10, 1>;    // I2S Enable
            using I2SCFG = Field<8, 2>;    // I2S configuration mode
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using CKPOL = Field<3, 1>;    // Steady state clock polarity
            using DATLEN = Field<1, 2>;    // Data length to be transferred
            using CHLEN = Field<0, 1>;    // Channel length (number of bits per audio channel)
            using ASTRTEN = Field<12, 1>;    // Asynchronous start enable
        };

        // I2S prescaler register
        struct I2SPR : public Register<0x40013420> {
            using MCKOE = Field<9, 1>;    // Master clock output enable
            using ODD = Field<8, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<0, 8>;    // I2S Linear prescaler
        };

    };

    // Serial peripheral interface
    struct SPI5 {
        // control register 1
        struct CR1 : public Register<0x40015000> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using CRCL = Field<11, 1>;    // CRC length
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40015004> {
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using SSOE = Field<2, 1>;    // SS output enable
            using NSSP = Field<3, 1>;    // NSS pulse management
            using FRF = Field<4, 1>;    // Frame format
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
            using DS = Field<8, 4>;    // Data size
            using FRXTH = Field<12, 1>;    // FIFO reception threshold
            using LDMA_RX = Field<13, 1>;    // Last DMA transfer for reception
            using LDMA_TX = Field<14, 1>;    // Last DMA transfer for transmission
        };

        // status register
        struct SR : public Register<0x40015008> {
            using FRE = Field<8, 1>;    // Frame format error
            using BSY = Field<7, 1>;    // Busy flag
            using OVR = Field<6, 1>;    // Overrun flag
            using MODF = Field<5, 1>;    // Mode fault
            using CRCERR = Field<4, 1>;    // CRC error flag
            using UDR = Field<3, 1>;    // Underrun flag
            using CHSIDE = Field<2, 1>;    // Channel side
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using RXNE = Field<0, 1>;    // Receive buffer not empty
            using FRLVL = Field<9, 2>;    // FIFO reception level
            using FTLVL = Field<11, 2>;    // FIFO Transmission Level
        };

        // data register
        struct DR : public Register<0x4001500c> {
            using Field = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40015010> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public RegisterReadOnly<0x40015014> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public RegisterReadOnly<0x40015018> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

        // I2S configuration register
        struct I2SCFGR : public Register<0x4001501c> {
            using I2SMOD = Field<11, 1>;    // I2S mode selection
            using I2SE = Field<10, 1>;    // I2S Enable
            using I2SCFG = Field<8, 2>;    // I2S configuration mode
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using CKPOL = Field<3, 1>;    // Steady state clock polarity
            using DATLEN = Field<1, 2>;    // Data length to be transferred
            using CHLEN = Field<0, 1>;    // Channel length (number of bits per audio channel)
            using ASTRTEN = Field<12, 1>;    // Asynchronous start enable
        };

        // I2S prescaler register
        struct I2SPR : public Register<0x40015020> {
            using MCKOE = Field<9, 1>;    // Master clock output enable
            using ODD = Field<8, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<0, 8>;    // I2S Linear prescaler
        };

    };

    // Serial peripheral interface
    struct SPI6 {
        // control register 1
        struct CR1 : public Register<0x40015400> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using CRCL = Field<11, 1>;    // CRC length
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40015404> {
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using SSOE = Field<2, 1>;    // SS output enable
            using NSSP = Field<3, 1>;    // NSS pulse management
            using FRF = Field<4, 1>;    // Frame format
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
            using DS = Field<8, 4>;    // Data size
            using FRXTH = Field<12, 1>;    // FIFO reception threshold
            using LDMA_RX = Field<13, 1>;    // Last DMA transfer for reception
            using LDMA_TX = Field<14, 1>;    // Last DMA transfer for transmission
        };

        // status register
        struct SR : public Register<0x40015408> {
            using FRE = Field<8, 1>;    // Frame format error
            using BSY = Field<7, 1>;    // Busy flag
            using OVR = Field<6, 1>;    // Overrun flag
            using MODF = Field<5, 1>;    // Mode fault
            using CRCERR = Field<4, 1>;    // CRC error flag
            using UDR = Field<3, 1>;    // Underrun flag
            using CHSIDE = Field<2, 1>;    // Channel side
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using RXNE = Field<0, 1>;    // Receive buffer not empty
            using FRLVL = Field<9, 2>;    // FIFO reception level
            using FTLVL = Field<11, 2>;    // FIFO Transmission Level
        };

        // data register
        struct DR : public Register<0x4001540c> {
            using Field = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40015410> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public RegisterReadOnly<0x40015414> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public RegisterReadOnly<0x40015418> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

        // I2S configuration register
        struct I2SCFGR : public Register<0x4001541c> {
            using I2SMOD = Field<11, 1>;    // I2S mode selection
            using I2SE = Field<10, 1>;    // I2S Enable
            using I2SCFG = Field<8, 2>;    // I2S configuration mode
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using CKPOL = Field<3, 1>;    // Steady state clock polarity
            using DATLEN = Field<1, 2>;    // Data length to be transferred
            using CHLEN = Field<0, 1>;    // Channel length (number of bits per audio channel)
            using ASTRTEN = Field<12, 1>;    // Asynchronous start enable
        };

        // I2S prescaler register
        struct I2SPR : public Register<0x40015420> {
            using MCKOE = Field<9, 1>;    // Master clock output enable
            using ODD = Field<8, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<0, 8>;    // I2S Linear prescaler
        };

    };

    // Analog-to-digital converter
    struct ADC1 {
        // status register
        struct SR : public Register<0x40012000> {
            using OVR = Field<5, 1>;    // Overrun
            using STRT = Field<4, 1>;    // Regular channel start flag
            using JSTRT = Field<3, 1>;    // Injected channel start flag
            using JEOC = Field<2, 1>;    // Injected channel end of conversion
            using EOC = Field<1, 1>;    // Regular channel end of conversion
            using AWD = Field<0, 1>;    // Analog watchdog flag
        };

        // control register 1
        struct CR1 : public Register<0x40012004> {
            using OVRIE = Field<26, 1>;    // Overrun interrupt enable
            using RES = Field<24, 2>;    // Resolution
            using AWDEN = Field<23, 1>;    // Analog watchdog enable on regular channels
            using JAWDEN = Field<22, 1>;    // Analog watchdog enable on injected channels
            using DISCNUM = Field<13, 3>;    // Discontinuous mode channel count
            using JDISCEN = Field<12, 1>;    // Discontinuous mode on injected channels
            using DISCEN = Field<11, 1>;    // Discontinuous mode on regular channels
            using JAUTO = Field<10, 1>;    // Automatic injected group conversion
            using AWDSGL = Field<9, 1>;    // Enable the watchdog on a single channel in scan mode
            using SCAN = Field<8, 1>;    // Scan mode
            using JEOCIE = Field<7, 1>;    // Interrupt enable for injected channels
            using AWDIE = Field<6, 1>;    // Analog watchdog interrupt enable
            using EOCIE = Field<5, 1>;    // Interrupt enable for EOC
            using AWDCH = Field<0, 5>;    // Analog watchdog channel select bits
        };

        // control register 2
        struct CR2 : public Register<0x40012008> {
            using SWSTART = Field<30, 1>;    // Start conversion of regular channels
            using EXTEN = Field<28, 2>;    // External trigger enable for regular channels
            using EXTSEL = Field<24, 4>;    // External event select for regular group
            using JSWSTART = Field<22, 1>;    // Start conversion of injected channels
            using JEXTEN = Field<20, 2>;    // External trigger enable for injected channels
            using JEXTSEL = Field<16, 4>;    // External event select for injected group
            using ALIGN = Field<11, 1>;    // Data alignment
            using EOCS = Field<10, 1>;    // End of conversion selection
            using DDS = Field<9, 1>;    // DMA disable selection (for single ADC mode)
            using DMA = Field<8, 1>;    // Direct memory access mode (for single ADC mode)
            using CONT = Field<1, 1>;    // Continuous conversion
            using ADON = Field<0, 1>;    // A/D Converter ON / OFF
        };

        // sample time register 1
        struct SMPR1 : public Register<0x4001200c> {
            using SMPx_x = Field<0, 32>;    // Sample time bits
        };

        // sample time register 2
        struct SMPR2 : public Register<0x40012010> {
            using SMPx_x = Field<0, 32>;    // Sample time bits
        };

        // injected channel data offset register x
        struct JOFR1 : public Register<0x40012014> {
            using JOFFSET1 = Field<0, 12>;    // Data offset for injected channel x
        };

        // injected channel data offset register x
        struct JOFR2 : public Register<0x40012018> {
            using JOFFSET2 = Field<0, 12>;    // Data offset for injected channel x
        };

        // injected channel data offset register x
        struct JOFR3 : public Register<0x4001201c> {
            using JOFFSET3 = Field<0, 12>;    // Data offset for injected channel x
        };

        // injected channel data offset register x
        struct JOFR4 : public Register<0x40012020> {
            using JOFFSET4 = Field<0, 12>;    // Data offset for injected channel x
        };

        // watchdog higher threshold register
        struct HTR : public Register<0x40012024> {
            using HT = Field<0, 12>;    // Analog watchdog higher threshold
        };

        // watchdog lower threshold register
        struct LTR : public Register<0x40012028> {
            using LT = Field<0, 12>;    // Analog watchdog lower threshold
        };

        // regular sequence register 1
        struct SQR1 : public Register<0x4001202c> {
            using L = Field<20, 4>;    // Regular channel sequence length
            using SQ16 = Field<15, 5>;    // 16th conversion in regular sequence
            using SQ15 = Field<10, 5>;    // 15th conversion in regular sequence
            using SQ14 = Field<5, 5>;    // 14th conversion in regular sequence
            using SQ13 = Field<0, 5>;    // 13th conversion in regular sequence
        };

        // regular sequence register 2
        struct SQR2 : public Register<0x40012030> {
            using SQ12 = Field<25, 5>;    // 12th conversion in regular sequence
            using SQ11 = Field<20, 5>;    // 11th conversion in regular sequence
            using SQ10 = Field<15, 5>;    // 10th conversion in regular sequence
            using SQ9 = Field<10, 5>;    // 9th conversion in regular sequence
            using SQ8 = Field<5, 5>;    // 8th conversion in regular sequence
            using SQ7 = Field<0, 5>;    // 7th conversion in regular sequence
        };

        // regular sequence register 3
        struct SQR3 : public Register<0x40012034> {
            using SQ6 = Field<25, 5>;    // 6th conversion in regular sequence
            using SQ5 = Field<20, 5>;    // 5th conversion in regular sequence
            using SQ4 = Field<15, 5>;    // 4th conversion in regular sequence
            using SQ3 = Field<10, 5>;    // 3rd conversion in regular sequence
            using SQ2 = Field<5, 5>;    // 2nd conversion in regular sequence
            using SQ1 = Field<0, 5>;    // 1st conversion in regular sequence
        };

        // injected sequence register
        struct JSQR : public Register<0x40012038> {
            using JL = Field<20, 2>;    // Injected sequence length
            using JSQ4 = Field<15, 5>;    // 4th conversion in injected sequence
            using JSQ3 = Field<10, 5>;    // 3rd conversion in injected sequence
            using JSQ2 = Field<5, 5>;    // 2nd conversion in injected sequence
            using JSQ1 = Field<0, 5>;    // 1st conversion in injected sequence
        };

        // injected data register x
        struct JDR1 : public RegisterReadOnly<0x4001203c> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // injected data register x
        struct JDR2 : public RegisterReadOnly<0x40012040> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // injected data register x
        struct JDR3 : public RegisterReadOnly<0x40012044> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // injected data register x
        struct JDR4 : public RegisterReadOnly<0x40012048> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // regular data register
        struct DR : public RegisterReadOnly<0x4001204c> {
            using DATA = Field<0, 16>;    // Regular data
        };

    };

    // Analog-to-digital converter
    struct ADC2 {
        // status register
        struct SR : public Register<0x40012100> {
            using OVR = Field<5, 1>;    // Overrun
            using STRT = Field<4, 1>;    // Regular channel start flag
            using JSTRT = Field<3, 1>;    // Injected channel start flag
            using JEOC = Field<2, 1>;    // Injected channel end of conversion
            using EOC = Field<1, 1>;    // Regular channel end of conversion
            using AWD = Field<0, 1>;    // Analog watchdog flag
        };

        // control register 1
        struct CR1 : public Register<0x40012104> {
            using OVRIE = Field<26, 1>;    // Overrun interrupt enable
            using RES = Field<24, 2>;    // Resolution
            using AWDEN = Field<23, 1>;    // Analog watchdog enable on regular channels
            using JAWDEN = Field<22, 1>;    // Analog watchdog enable on injected channels
            using DISCNUM = Field<13, 3>;    // Discontinuous mode channel count
            using JDISCEN = Field<12, 1>;    // Discontinuous mode on injected channels
            using DISCEN = Field<11, 1>;    // Discontinuous mode on regular channels
            using JAUTO = Field<10, 1>;    // Automatic injected group conversion
            using AWDSGL = Field<9, 1>;    // Enable the watchdog on a single channel in scan mode
            using SCAN = Field<8, 1>;    // Scan mode
            using JEOCIE = Field<7, 1>;    // Interrupt enable for injected channels
            using AWDIE = Field<6, 1>;    // Analog watchdog interrupt enable
            using EOCIE = Field<5, 1>;    // Interrupt enable for EOC
            using AWDCH = Field<0, 5>;    // Analog watchdog channel select bits
        };

        // control register 2
        struct CR2 : public Register<0x40012108> {
            using SWSTART = Field<30, 1>;    // Start conversion of regular channels
            using EXTEN = Field<28, 2>;    // External trigger enable for regular channels
            using EXTSEL = Field<24, 4>;    // External event select for regular group
            using JSWSTART = Field<22, 1>;    // Start conversion of injected channels
            using JEXTEN = Field<20, 2>;    // External trigger enable for injected channels
            using JEXTSEL = Field<16, 4>;    // External event select for injected group
            using ALIGN = Field<11, 1>;    // Data alignment
            using EOCS = Field<10, 1>;    // End of conversion selection
            using DDS = Field<9, 1>;    // DMA disable selection (for single ADC mode)
            using DMA = Field<8, 1>;    // Direct memory access mode (for single ADC mode)
            using CONT = Field<1, 1>;    // Continuous conversion
            using ADON = Field<0, 1>;    // A/D Converter ON / OFF
        };

        // sample time register 1
        struct SMPR1 : public Register<0x4001210c> {
            using SMPx_x = Field<0, 32>;    // Sample time bits
        };

        // sample time register 2
        struct SMPR2 : public Register<0x40012110> {
            using SMPx_x = Field<0, 32>;    // Sample time bits
        };

        // injected channel data offset register x
        struct JOFR1 : public Register<0x40012114> {
            using JOFFSET1 = Field<0, 12>;    // Data offset for injected channel x
        };

        // injected channel data offset register x
        struct JOFR2 : public Register<0x40012118> {
            using JOFFSET2 = Field<0, 12>;    // Data offset for injected channel x
        };

        // injected channel data offset register x
        struct JOFR3 : public Register<0x4001211c> {
            using JOFFSET3 = Field<0, 12>;    // Data offset for injected channel x
        };

        // injected channel data offset register x
        struct JOFR4 : public Register<0x40012120> {
            using JOFFSET4 = Field<0, 12>;    // Data offset for injected channel x
        };

        // watchdog higher threshold register
        struct HTR : public Register<0x40012124> {
            using HT = Field<0, 12>;    // Analog watchdog higher threshold
        };

        // watchdog lower threshold register
        struct LTR : public Register<0x40012128> {
            using LT = Field<0, 12>;    // Analog watchdog lower threshold
        };

        // regular sequence register 1
        struct SQR1 : public Register<0x4001212c> {
            using L = Field<20, 4>;    // Regular channel sequence length
            using SQ16 = Field<15, 5>;    // 16th conversion in regular sequence
            using SQ15 = Field<10, 5>;    // 15th conversion in regular sequence
            using SQ14 = Field<5, 5>;    // 14th conversion in regular sequence
            using SQ13 = Field<0, 5>;    // 13th conversion in regular sequence
        };

        // regular sequence register 2
        struct SQR2 : public Register<0x40012130> {
            using SQ12 = Field<25, 5>;    // 12th conversion in regular sequence
            using SQ11 = Field<20, 5>;    // 11th conversion in regular sequence
            using SQ10 = Field<15, 5>;    // 10th conversion in regular sequence
            using SQ9 = Field<10, 5>;    // 9th conversion in regular sequence
            using SQ8 = Field<5, 5>;    // 8th conversion in regular sequence
            using SQ7 = Field<0, 5>;    // 7th conversion in regular sequence
        };

        // regular sequence register 3
        struct SQR3 : public Register<0x40012134> {
            using SQ6 = Field<25, 5>;    // 6th conversion in regular sequence
            using SQ5 = Field<20, 5>;    // 5th conversion in regular sequence
            using SQ4 = Field<15, 5>;    // 4th conversion in regular sequence
            using SQ3 = Field<10, 5>;    // 3rd conversion in regular sequence
            using SQ2 = Field<5, 5>;    // 2nd conversion in regular sequence
            using SQ1 = Field<0, 5>;    // 1st conversion in regular sequence
        };

        // injected sequence register
        struct JSQR : public Register<0x40012138> {
            using JL = Field<20, 2>;    // Injected sequence length
            using JSQ4 = Field<15, 5>;    // 4th conversion in injected sequence
            using JSQ3 = Field<10, 5>;    // 3rd conversion in injected sequence
            using JSQ2 = Field<5, 5>;    // 2nd conversion in injected sequence
            using JSQ1 = Field<0, 5>;    // 1st conversion in injected sequence
        };

        // injected data register x
        struct JDR1 : public RegisterReadOnly<0x4001213c> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // injected data register x
        struct JDR2 : public RegisterReadOnly<0x40012140> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // injected data register x
        struct JDR3 : public RegisterReadOnly<0x40012144> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // injected data register x
        struct JDR4 : public RegisterReadOnly<0x40012148> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // regular data register
        struct DR : public RegisterReadOnly<0x4001214c> {
            using DATA = Field<0, 16>;    // Regular data
        };

    };

    // Analog-to-digital converter
    struct ADC3 {
        // status register
        struct SR : public Register<0x40012200> {
            using OVR = Field<5, 1>;    // Overrun
            using STRT = Field<4, 1>;    // Regular channel start flag
            using JSTRT = Field<3, 1>;    // Injected channel start flag
            using JEOC = Field<2, 1>;    // Injected channel end of conversion
            using EOC = Field<1, 1>;    // Regular channel end of conversion
            using AWD = Field<0, 1>;    // Analog watchdog flag
        };

        // control register 1
        struct CR1 : public Register<0x40012204> {
            using OVRIE = Field<26, 1>;    // Overrun interrupt enable
            using RES = Field<24, 2>;    // Resolution
            using AWDEN = Field<23, 1>;    // Analog watchdog enable on regular channels
            using JAWDEN = Field<22, 1>;    // Analog watchdog enable on injected channels
            using DISCNUM = Field<13, 3>;    // Discontinuous mode channel count
            using JDISCEN = Field<12, 1>;    // Discontinuous mode on injected channels
            using DISCEN = Field<11, 1>;    // Discontinuous mode on regular channels
            using JAUTO = Field<10, 1>;    // Automatic injected group conversion
            using AWDSGL = Field<9, 1>;    // Enable the watchdog on a single channel in scan mode
            using SCAN = Field<8, 1>;    // Scan mode
            using JEOCIE = Field<7, 1>;    // Interrupt enable for injected channels
            using AWDIE = Field<6, 1>;    // Analog watchdog interrupt enable
            using EOCIE = Field<5, 1>;    // Interrupt enable for EOC
            using AWDCH = Field<0, 5>;    // Analog watchdog channel select bits
        };

        // control register 2
        struct CR2 : public Register<0x40012208> {
            using SWSTART = Field<30, 1>;    // Start conversion of regular channels
            using EXTEN = Field<28, 2>;    // External trigger enable for regular channels
            using EXTSEL = Field<24, 4>;    // External event select for regular group
            using JSWSTART = Field<22, 1>;    // Start conversion of injected channels
            using JEXTEN = Field<20, 2>;    // External trigger enable for injected channels
            using JEXTSEL = Field<16, 4>;    // External event select for injected group
            using ALIGN = Field<11, 1>;    // Data alignment
            using EOCS = Field<10, 1>;    // End of conversion selection
            using DDS = Field<9, 1>;    // DMA disable selection (for single ADC mode)
            using DMA = Field<8, 1>;    // Direct memory access mode (for single ADC mode)
            using CONT = Field<1, 1>;    // Continuous conversion
            using ADON = Field<0, 1>;    // A/D Converter ON / OFF
        };

        // sample time register 1
        struct SMPR1 : public Register<0x4001220c> {
            using SMPx_x = Field<0, 32>;    // Sample time bits
        };

        // sample time register 2
        struct SMPR2 : public Register<0x40012210> {
            using SMPx_x = Field<0, 32>;    // Sample time bits
        };

        // injected channel data offset register x
        struct JOFR1 : public Register<0x40012214> {
            using JOFFSET1 = Field<0, 12>;    // Data offset for injected channel x
        };

        // injected channel data offset register x
        struct JOFR2 : public Register<0x40012218> {
            using JOFFSET2 = Field<0, 12>;    // Data offset for injected channel x
        };

        // injected channel data offset register x
        struct JOFR3 : public Register<0x4001221c> {
            using JOFFSET3 = Field<0, 12>;    // Data offset for injected channel x
        };

        // injected channel data offset register x
        struct JOFR4 : public Register<0x40012220> {
            using JOFFSET4 = Field<0, 12>;    // Data offset for injected channel x
        };

        // watchdog higher threshold register
        struct HTR : public Register<0x40012224> {
            using HT = Field<0, 12>;    // Analog watchdog higher threshold
        };

        // watchdog lower threshold register
        struct LTR : public Register<0x40012228> {
            using LT = Field<0, 12>;    // Analog watchdog lower threshold
        };

        // regular sequence register 1
        struct SQR1 : public Register<0x4001222c> {
            using L = Field<20, 4>;    // Regular channel sequence length
            using SQ16 = Field<15, 5>;    // 16th conversion in regular sequence
            using SQ15 = Field<10, 5>;    // 15th conversion in regular sequence
            using SQ14 = Field<5, 5>;    // 14th conversion in regular sequence
            using SQ13 = Field<0, 5>;    // 13th conversion in regular sequence
        };

        // regular sequence register 2
        struct SQR2 : public Register<0x40012230> {
            using SQ12 = Field<25, 5>;    // 12th conversion in regular sequence
            using SQ11 = Field<20, 5>;    // 11th conversion in regular sequence
            using SQ10 = Field<15, 5>;    // 10th conversion in regular sequence
            using SQ9 = Field<10, 5>;    // 9th conversion in regular sequence
            using SQ8 = Field<5, 5>;    // 8th conversion in regular sequence
            using SQ7 = Field<0, 5>;    // 7th conversion in regular sequence
        };

        // regular sequence register 3
        struct SQR3 : public Register<0x40012234> {
            using SQ6 = Field<25, 5>;    // 6th conversion in regular sequence
            using SQ5 = Field<20, 5>;    // 5th conversion in regular sequence
            using SQ4 = Field<15, 5>;    // 4th conversion in regular sequence
            using SQ3 = Field<10, 5>;    // 3rd conversion in regular sequence
            using SQ2 = Field<5, 5>;    // 2nd conversion in regular sequence
            using SQ1 = Field<0, 5>;    // 1st conversion in regular sequence
        };

        // injected sequence register
        struct JSQR : public Register<0x40012238> {
            using JL = Field<20, 2>;    // Injected sequence length
            using JSQ4 = Field<15, 5>;    // 4th conversion in injected sequence
            using JSQ3 = Field<10, 5>;    // 3rd conversion in injected sequence
            using JSQ2 = Field<5, 5>;    // 2nd conversion in injected sequence
            using JSQ1 = Field<0, 5>;    // 1st conversion in injected sequence
        };

        // injected data register x
        struct JDR1 : public RegisterReadOnly<0x4001223c> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // injected data register x
        struct JDR2 : public RegisterReadOnly<0x40012240> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // injected data register x
        struct JDR3 : public RegisterReadOnly<0x40012244> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // injected data register x
        struct JDR4 : public RegisterReadOnly<0x40012248> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // regular data register
        struct DR : public RegisterReadOnly<0x4001224c> {
            using DATA = Field<0, 16>;    // Regular data
        };

    };

    // Digital-to-analog converter
    struct DAC {
        // control register
        struct CR : public Register<0x40007400> {
            using DMAUDRIE2 = Field<29, 1>;    // DAC channel2 DMA underrun interrupt enable
            using DMAEN2 = Field<28, 1>;    // DAC channel2 DMA enable
            using MAMP2 = Field<24, 4>;    // DAC channel2 mask/amplitude selector
            using WAVE2 = Field<22, 2>;    // DAC channel2 noise/triangle wave generation enable
            using TSEL2 = Field<19, 3>;    // DAC channel2 trigger selection
            using TEN2 = Field<18, 1>;    // DAC channel2 trigger enable
            using BOFF2 = Field<17, 1>;    // DAC channel2 output buffer disable
            using EN2 = Field<16, 1>;    // DAC channel2 enable
            using DMAUDRIE1 = Field<13, 1>;    // DAC channel1 DMA Underrun Interrupt enable
            using DMAEN1 = Field<12, 1>;    // DAC channel1 DMA enable
            using MAMP1 = Field<8, 4>;    // DAC channel1 mask/amplitude selector
            using WAVE1 = Field<6, 2>;    // DAC channel1 noise/triangle wave generation enable
            using TSEL1 = Field<3, 3>;    // DAC channel1 trigger selection
            using TEN1 = Field<2, 1>;    // DAC channel1 trigger enable
            using BOFF1 = Field<1, 1>;    // DAC channel1 output buffer disable
            using EN1 = Field<0, 1>;    // DAC channel1 enable
        };

        // software trigger register
        struct SWTRIGR : public RegisterWriteOnly<0x40007404> {
            using SWTRIG2 = Field<1, 1>;    // DAC channel2 software trigger
            using SWTRIG1 = Field<0, 1>;    // DAC channel1 software trigger
        };

        // channel1 12-bit right-aligned data holding register
        struct DHR12R1 : public Register<0x40007408> {
            using DACC1DHR = Field<0, 12>;    // DAC channel1 12-bit right-aligned data
        };

        // channel1 12-bit left aligned data holding register
        struct DHR12L1 : public Register<0x4000740c> {
            using DACC1DHR = Field<4, 12>;    // DAC channel1 12-bit left-aligned data
        };

        // channel1 8-bit right aligned data holding register
        struct DHR8R1 : public Register<0x40007410> {
            using DACC1DHR = Field<0, 8>;    // DAC channel1 8-bit right-aligned data
        };

        // channel2 12-bit right aligned data holding register
        struct DHR12R2 : public Register<0x40007414> {
            using DACC2DHR = Field<0, 12>;    // DAC channel2 12-bit right-aligned data
        };

        // channel2 12-bit left aligned data holding register
        struct DHR12L2 : public Register<0x40007418> {
            using DACC2DHR = Field<4, 12>;    // DAC channel2 12-bit left-aligned data
        };

        // channel2 8-bit right-aligned data holding register
        struct DHR8R2 : public Register<0x4000741c> {
            using DACC2DHR = Field<0, 8>;    // DAC channel2 8-bit right-aligned data
        };

        // Dual DAC 12-bit right-aligned data holding register
        struct DHR12RD : public Register<0x40007420> {
            using DACC2DHR = Field<16, 12>;    // DAC channel2 12-bit right-aligned data
            using DACC1DHR = Field<0, 12>;    // DAC channel1 12-bit right-aligned data
        };

        // DUAL DAC 12-bit left aligned data holding register
        struct DHR12LD : public Register<0x40007424> {
            using DACC2DHR = Field<20, 12>;    // DAC channel2 12-bit left-aligned data
            using DACC1DHR = Field<4, 12>;    // DAC channel1 12-bit left-aligned data
        };

        // DUAL DAC 8-bit right aligned data holding register
        struct DHR8RD : public Register<0x40007428> {
            using DACC2DHR = Field<8, 8>;    // DAC channel2 8-bit right-aligned data
            using DACC1DHR = Field<0, 8>;    // DAC channel1 8-bit right-aligned data
        };

        // channel1 data output register
        struct DOR1 : public RegisterReadOnly<0x4000742c> {
            using DACC1DOR = Field<0, 12>;    // DAC channel1 data output
        };

        // channel2 data output register
        struct DOR2 : public RegisterReadOnly<0x40007430> {
            using DACC2DOR = Field<0, 12>;    // DAC channel2 data output
        };

        // status register
        struct SR : public Register<0x40007434> {
            using DMAUDR2 = Field<29, 1>;    // DAC channel2 DMA underrun flag
            using DMAUDR1 = Field<13, 1>;    // DAC channel1 DMA underrun flag
        };

    };

    // Power control
    struct PWR {
        // power control register
        struct CR1 : public Register<0x40007000> {
            using LPDS = Field<0, 1>;    // Low-power deep sleep
            using PDDS = Field<1, 1>;    // Power down deepsleep
            using CSBF = Field<3, 1>;    // Clear standby flag
            using PVDE = Field<4, 1>;    // Power voltage detector enable
            using PLS = Field<5, 3>;    // PVD level selection
            using DBP = Field<8, 1>;    // Disable backup domain write protection
            using FPDS = Field<9, 1>;    // Flash power down in Stop mode
            using LPUDS = Field<10, 1>;    // Low-power regulator in deepsleep under-drive mode
            using MRUDS = Field<11, 1>;    // Main regulator in deepsleep under-drive mode
            using ADCDC1 = Field<13, 1>;    // ADCDC1
            using VOS = Field<14, 2>;    // Regulator voltage scaling output selection
            using ODEN = Field<16, 1>;    // Over-drive enable
            using ODSWEN = Field<17, 1>;    // Over-drive switching enabled
            using UDEN = Field<18, 2>;    // Under-drive enable in stop mode
        };

        // power control/status register
        struct CSR1 : public Register<0x40007004> {
            using WUIF = Field<0, 1>;    // Wakeup internal flag
            using SBF = Field<1, 1>;    // Standby flag
            using PVDO = Field<2, 1>;    // PVD output
            using BRR = Field<3, 1>;    // Backup regulator ready
            using BRE = Field<9, 1>;    // Backup regulator enable
            using VOSRDY = Field<14, 1>;    // Regulator voltage scaling output selection ready bit
            using ODRDY = Field<16, 1>;    // Over-drive mode ready
            using ODSWRDY = Field<17, 1>;    // Over-drive mode switching ready
            using UDRDY = Field<18, 2>;    // Under-drive ready flag
        };

        // power control register
        struct CR2 : public Register<0x40007008> {
            using CWUPF1 = Field<0, 1>;    // Clear Wakeup Pin flag for PA0
            using CWUPF2 = Field<1, 1>;    // Clear Wakeup Pin flag for PA2
            using CWUPF3 = Field<2, 1>;    // Clear Wakeup Pin flag for PC1
            using CWUPF4 = Field<3, 1>;    // Clear Wakeup Pin flag for PC13
            using CWUPF5 = Field<4, 1>;    // Clear Wakeup Pin flag for PI8
            using CWUPF6 = Field<5, 1>;    // Clear Wakeup Pin flag for PI11
            using WUPP1 = Field<8, 1>;    // Wakeup pin polarity bit for PA0
            using WUPP2 = Field<9, 1>;    // Wakeup pin polarity bit for PA2
            using WUPP3 = Field<10, 1>;    // Wakeup pin polarity bit for PC1
            using WUPP4 = Field<11, 1>;    // Wakeup pin polarity bit for PC13
            using WUPP5 = Field<12, 1>;    // Wakeup pin polarity bit for PI8
            using WUPP6 = Field<13, 1>;    // Wakeup pin polarity bit for PI11
        };

        // power control/status register
        struct CSR2 : public Register<0x4000700c> {
            using WUPF1 = Field<0, 1>;    // Wakeup Pin flag for PA0
            using WUPF2 = Field<1, 1>;    // Wakeup Pin flag for PA2
            using WUPF3 = Field<2, 1>;    // Wakeup Pin flag for PC1
            using WUPF4 = Field<3, 1>;    // Wakeup Pin flag for PC13
            using WUPF5 = Field<4, 1>;    // Wakeup Pin flag for PI8
            using WUPF6 = Field<5, 1>;    // Wakeup Pin flag for PI11
            using EWUP1 = Field<8, 1>;    // Enable Wakeup pin for PA0
            using EWUP2 = Field<9, 1>;    // Enable Wakeup pin for PA2
            using EWUP3 = Field<10, 1>;    // Enable Wakeup pin for PC1
            using EWUP4 = Field<11, 1>;    // Enable Wakeup pin for PC13
            using EWUP5 = Field<12, 1>;    // Enable Wakeup pin for PI8
            using EWUP6 = Field<13, 1>;    // Enable Wakeup pin for PI11
        };

    };

    // Independent watchdog
    struct IWDG {
        // Key register
        struct KR : public RegisterWriteOnly<0x40003000> {
            using KEY = Field<0, 16>;    // Key value (write only, read 0000h)
        };

        // Prescaler register
        struct PR : public Register<0x40003004> {
            using Field = Field<0, 3>;    // Prescaler divider
        };

        // Reload register
        struct RLR : public Register<0x40003008> {
            using RL = Field<0, 12>;    // Watchdog counter reload value
        };

        // Status register
        struct SR : public RegisterReadOnly<0x4000300c> {
            using RVU = Field<1, 1>;    // Watchdog counter reload value update
            using PVU = Field<0, 1>;    // Watchdog prescaler value update
        };

        // Window register
        struct WINR : public Register<0x40003010> {
            using WIN = Field<0, 12>;    // Watchdog counter window value
        };

    };

    // Window watchdog
    struct WWDG {
        // Control register
        struct CR : public Register<0x40002c00> {
            using WDGA = Field<7, 1>;    // Activation bit
            using T = Field<0, 7>;    // 7-bit counter (MSB to LSB)
        };

        // Configuration register
        struct CFR : public Register<0x40002c04> {
            using EWI = Field<9, 1>;    // Early wakeup interrupt
            using WDGTB1 = Field<8, 1>;    // Timer base
            using WDGTB0 = Field<7, 1>;    // Timer base
            using W = Field<0, 7>;    // 7-bit window value
        };

        // Status register
        struct SR : public Register<0x40002c08> {
            using EWIF = Field<0, 1>;    // Early wakeup interrupt flag
        };

    };

    // Advanced-timers
    struct TIM1 {
        // control register 1
        struct CR1 : public Register<0x40010000> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40010004> {
            using OIS4 = Field<14, 1>;    // Output Idle state 4
            using OIS3N = Field<13, 1>;    // Output Idle state 3
            using OIS3 = Field<12, 1>;    // Output Idle state 3
            using OIS2N = Field<11, 1>;    // Output Idle state 2
            using OIS2 = Field<10, 1>;    // Output Idle state 2
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
        };

        // slave mode control register
        struct SMCR : public Register<0x40010008> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001000c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
        };

        // status register
        struct SR : public Register<0x40010010> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40010014> {
            using BG = Field<7, 1>;    // Break generation
            using TG = Field<6, 1>;    // Trigger generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40010018> {
            using OC2CE = Field<15, 1>;    // Output Compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output Compare 2 mode
            using OC2PE = Field<11, 1>;    // Output Compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output Compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output Compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40010018> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4001001c> {
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4001001c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40010020> {
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3NE = Field<10, 1>;    // Capture/Compare 3 complementary output enable
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2NE = Field<6, 1>;    // Capture/Compare 2 complementary output enable
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40010024> {
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40010028> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001002c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40010034> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40010038> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4001003c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40010040> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40010048> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4001004c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // repetition counter register
        struct RCR : public Register<0x40010030> {
            using REP = Field<0, 8>;    // Repetition counter value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40010044> {
            using MOE = Field<15, 1>;    // Main output enable
            using AOE = Field<14, 1>;    // Automatic output enable
            using BKP = Field<13, 1>;    // Break polarity
            using BKE = Field<12, 1>;    // Break enable
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using LOCK = Field<8, 2>;    // Lock configuration
            using DTG = Field<0, 8>;    // Dead-time generator setup
        };

        // capture/compare mode register 3 (output mode)
        struct CCMR3_Output : public Register<0x40010054> {
            using OC5FE = Field<2, 1>;    // Output compare 5 fast enable
            using OC5PE = Field<3, 1>;    // Output compare 5 preload enable
            using OC5M = Field<4, 3>;    // Output compare 5 mode
            using OC5CE = Field<7, 1>;    // Output compare 5 clear enable
            using OC6FE = Field<10, 1>;    // Output compare 6 fast enable
            using OC6PE = Field<11, 1>;    // Output compare 6 preload enable
            using OC6M = Field<12, 3>;    // Output compare 6 mode
            using OC6CE = Field<15, 1>;    // Output compare 6 clear enable
            using OC5M3 = Field<16, 1>;    // Output Compare 5 mode
            using OC6M3 = Field<24, 1>;    // Output Compare 6 mode
        };

        // capture/compare register 5
        struct CCR5 : public Register<0x40010058> {
            using Field = Field<0, 16>;    // Capture/Compare 5 value
            using GC5C1 = Field<29, 1>;    // Group Channel 5 and Channel 1
            using GC5C2 = Field<30, 1>;    // Group Channel 5 and Channel 2
            using GC5C3 = Field<31, 1>;    // Group Channel 5 and Channel 3
        };

        // capture/compare register 6
        struct CRR6 : public Register<0x4001005c> {
            using CCR6 = Field<0, 16>;    // Capture/Compare 6 value
        };

    };

    // Advanced-timers
    struct TIM8 {
        // control register 1
        struct CR1 : public Register<0x40010400> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40010404> {
            using OIS4 = Field<14, 1>;    // Output Idle state 4
            using OIS3N = Field<13, 1>;    // Output Idle state 3
            using OIS3 = Field<12, 1>;    // Output Idle state 3
            using OIS2N = Field<11, 1>;    // Output Idle state 2
            using OIS2 = Field<10, 1>;    // Output Idle state 2
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
        };

        // slave mode control register
        struct SMCR : public Register<0x40010408> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001040c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
        };

        // status register
        struct SR : public Register<0x40010410> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40010414> {
            using BG = Field<7, 1>;    // Break generation
            using TG = Field<6, 1>;    // Trigger generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40010418> {
            using OC2CE = Field<15, 1>;    // Output Compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output Compare 2 mode
            using OC2PE = Field<11, 1>;    // Output Compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output Compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output Compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40010418> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4001041c> {
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4001041c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40010420> {
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3NE = Field<10, 1>;    // Capture/Compare 3 complementary output enable
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2NE = Field<6, 1>;    // Capture/Compare 2 complementary output enable
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40010424> {
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40010428> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001042c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40010434> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40010438> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4001043c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40010440> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40010448> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4001044c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // repetition counter register
        struct RCR : public Register<0x40010430> {
            using REP = Field<0, 8>;    // Repetition counter value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40010444> {
            using MOE = Field<15, 1>;    // Main output enable
            using AOE = Field<14, 1>;    // Automatic output enable
            using BKP = Field<13, 1>;    // Break polarity
            using BKE = Field<12, 1>;    // Break enable
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using LOCK = Field<8, 2>;    // Lock configuration
            using DTG = Field<0, 8>;    // Dead-time generator setup
        };

        // capture/compare mode register 3 (output mode)
        struct CCMR3_Output : public Register<0x40010454> {
            using OC5FE = Field<2, 1>;    // Output compare 5 fast enable
            using OC5PE = Field<3, 1>;    // Output compare 5 preload enable
            using OC5M = Field<4, 3>;    // Output compare 5 mode
            using OC5CE = Field<7, 1>;    // Output compare 5 clear enable
            using OC6FE = Field<10, 1>;    // Output compare 6 fast enable
            using OC6PE = Field<11, 1>;    // Output compare 6 preload enable
            using OC6M = Field<12, 3>;    // Output compare 6 mode
            using OC6CE = Field<15, 1>;    // Output compare 6 clear enable
            using OC5M3 = Field<16, 1>;    // Output Compare 5 mode
            using OC6M3 = Field<24, 1>;    // Output Compare 6 mode
        };

        // capture/compare register 5
        struct CCR5 : public Register<0x40010458> {
            using Field = Field<0, 16>;    // Capture/Compare 5 value
            using GC5C1 = Field<29, 1>;    // Group Channel 5 and Channel 1
            using GC5C2 = Field<30, 1>;    // Group Channel 5 and Channel 2
            using GC5C3 = Field<31, 1>;    // Group Channel 5 and Channel 3
        };

        // capture/compare register 6
        struct CRR6 : public Register<0x4001045c> {
            using CCR6 = Field<0, 16>;    // Capture/Compare 6 value
        };

    };

    // General purpose timers
    struct TIM2 {
        // control register 1
        struct CR1 : public Register<0x40000000> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000004> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000008> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000000c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000010> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40000014> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40000018> {
            using OC2CE = Field<15, 1>;    // OC2CE
            using OC2M = Field<12, 3>;    // OC2M
            using OC2PE = Field<11, 1>;    // OC2PE
            using OC2FE = Field<10, 1>;    // OC2FE
            using CC2S = Field<8, 2>;    // CC2S
            using OC1CE = Field<7, 1>;    // OC1CE
            using OC1M = Field<4, 3>;    // OC1M
            using OC1PE = Field<3, 1>;    // OC1PE
            using OC1FE = Field<2, 1>;    // OC1FE
            using CC1S = Field<0, 2>;    // CC1S
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000018> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4000001c> {
            using O24CE = Field<15, 1>;    // O24CE
            using OC4M = Field<12, 3>;    // OC4M
            using OC4PE = Field<11, 1>;    // OC4PE
            using OC4FE = Field<10, 1>;    // OC4FE
            using CC4S = Field<8, 2>;    // CC4S
            using OC3CE = Field<7, 1>;    // OC3CE
            using OC3M = Field<4, 3>;    // OC3M
            using OC3PE = Field<3, 1>;    // OC3PE
            using OC3FE = Field<2, 1>;    // OC3FE
            using CC3S = Field<0, 2>;    // CC3S
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000001c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000020> {
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 output Polarity
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000024> {
            using CNT_H = Field<16, 16>;    // High counter value
            using CNT_L = Field<0, 16>;    // Low counter value
        };

        // prescaler
        struct PSC : public Register<0x40000028> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000002c> {
            using ARR_H = Field<16, 16>;    // High Auto-reload value
            using ARR_L = Field<0, 16>;    // Low Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000034> {
            using CCR1_H = Field<16, 16>;    // High Capture/Compare 1 value
            using CCR1_L = Field<0, 16>;    // Low Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40000038> {
            using CCR2_H = Field<16, 16>;    // High Capture/Compare 2 value
            using CCR2_L = Field<0, 16>;    // Low Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4000003c> {
            using CCR3_H = Field<16, 16>;    // High Capture/Compare value
            using CCR3_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40000040> {
            using CCR4_H = Field<16, 16>;    // High Capture/Compare value
            using CCR4_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40000048> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4000004c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // TIM2 option register 1
        struct OR1 : public Register<0x40000050> {
            using TI4_RMP = Field<2, 2>;    // Input Capture 4 remap
            using ETR1_RMP = Field<1, 1>;    // External trigger remap
            using ITR1_RMP = Field<0, 1>;    // Internal trigger 1 remap
        };

        // TIM2 option register 2
        struct OR2 : public Register<0x40000060> {
            using ETRSEL = Field<14, 3>;    // ETR source selection
        };

    };

    // General purpose timers
    struct TIM3 {
        // control register 1
        struct CR1 : public Register<0x40000400> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000404> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000408> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000040c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000410> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40000414> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40000418> {
            using OC2CE = Field<15, 1>;    // OC2CE
            using OC2M = Field<12, 3>;    // OC2M
            using OC2PE = Field<11, 1>;    // OC2PE
            using OC2FE = Field<10, 1>;    // OC2FE
            using CC2S = Field<8, 2>;    // CC2S
            using OC1CE = Field<7, 1>;    // OC1CE
            using OC1M = Field<4, 3>;    // OC1M
            using OC1PE = Field<3, 1>;    // OC1PE
            using OC1FE = Field<2, 1>;    // OC1FE
            using CC1S = Field<0, 2>;    // CC1S
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000418> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4000041c> {
            using O24CE = Field<15, 1>;    // O24CE
            using OC4M = Field<12, 3>;    // OC4M
            using OC4PE = Field<11, 1>;    // OC4PE
            using OC4FE = Field<10, 1>;    // OC4FE
            using CC4S = Field<8, 2>;    // CC4S
            using OC3CE = Field<7, 1>;    // OC3CE
            using OC3M = Field<4, 3>;    // OC3M
            using OC3PE = Field<3, 1>;    // OC3PE
            using OC3FE = Field<2, 1>;    // OC3FE
            using CC3S = Field<0, 2>;    // CC3S
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000041c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000420> {
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 output Polarity
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000424> {
            using CNT_H = Field<16, 16>;    // High counter value
            using CNT_L = Field<0, 16>;    // Low counter value
        };

        // prescaler
        struct PSC : public Register<0x40000428> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000042c> {
            using ARR_H = Field<16, 16>;    // High Auto-reload value
            using ARR_L = Field<0, 16>;    // Low Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000434> {
            using CCR1_H = Field<16, 16>;    // High Capture/Compare 1 value
            using CCR1_L = Field<0, 16>;    // Low Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40000438> {
            using CCR2_H = Field<16, 16>;    // High Capture/Compare 2 value
            using CCR2_L = Field<0, 16>;    // Low Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4000043c> {
            using CCR3_H = Field<16, 16>;    // High Capture/Compare value
            using CCR3_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40000440> {
            using CCR4_H = Field<16, 16>;    // High Capture/Compare value
            using CCR4_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40000448> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4000044c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // TIM3 option register 1
        struct OR1 : public Register<0x40000450> {
            using TI1_RMP = Field<0, 2>;    // Input Capture 1 remap
        };

        // TIM3 option register 2
        struct OR2 : public Register<0x40000460> {
            using ETRSEL = Field<14, 3>;    // ETR source selection
        };

    };

    // General purpose timers
    struct TIM4 {
        // control register 1
        struct CR1 : public Register<0x40000800> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000804> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000808> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000080c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000810> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40000814> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40000818> {
            using OC2CE = Field<15, 1>;    // OC2CE
            using OC2M = Field<12, 3>;    // OC2M
            using OC2PE = Field<11, 1>;    // OC2PE
            using OC2FE = Field<10, 1>;    // OC2FE
            using CC2S = Field<8, 2>;    // CC2S
            using OC1CE = Field<7, 1>;    // OC1CE
            using OC1M = Field<4, 3>;    // OC1M
            using OC1PE = Field<3, 1>;    // OC1PE
            using OC1FE = Field<2, 1>;    // OC1FE
            using CC1S = Field<0, 2>;    // CC1S
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000818> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4000081c> {
            using O24CE = Field<15, 1>;    // O24CE
            using OC4M = Field<12, 3>;    // OC4M
            using OC4PE = Field<11, 1>;    // OC4PE
            using OC4FE = Field<10, 1>;    // OC4FE
            using CC4S = Field<8, 2>;    // CC4S
            using OC3CE = Field<7, 1>;    // OC3CE
            using OC3M = Field<4, 3>;    // OC3M
            using OC3PE = Field<3, 1>;    // OC3PE
            using OC3FE = Field<2, 1>;    // OC3FE
            using CC3S = Field<0, 2>;    // CC3S
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000081c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000820> {
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 output Polarity
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000824> {
            using CNT_H = Field<16, 16>;    // High counter value
            using CNT_L = Field<0, 16>;    // Low counter value
        };

        // prescaler
        struct PSC : public Register<0x40000828> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000082c> {
            using ARR_H = Field<16, 16>;    // High Auto-reload value
            using ARR_L = Field<0, 16>;    // Low Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000834> {
            using CCR1_H = Field<16, 16>;    // High Capture/Compare 1 value
            using CCR1_L = Field<0, 16>;    // Low Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40000838> {
            using CCR2_H = Field<16, 16>;    // High Capture/Compare 2 value
            using CCR2_L = Field<0, 16>;    // Low Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4000083c> {
            using CCR3_H = Field<16, 16>;    // High Capture/Compare value
            using CCR3_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40000840> {
            using CCR4_H = Field<16, 16>;    // High Capture/Compare value
            using CCR4_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40000848> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4000084c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

    };

    // General purpose timers
    struct TIM5 {
        // control register 1
        struct CR1 : public Register<0x40000c00> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000c04> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000c08> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x40000c0c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000c10> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40000c14> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40000c18> {
            using OC2CE = Field<15, 1>;    // OC2CE
            using OC2M = Field<12, 3>;    // OC2M
            using OC2PE = Field<11, 1>;    // OC2PE
            using OC2FE = Field<10, 1>;    // OC2FE
            using CC2S = Field<8, 2>;    // CC2S
            using OC1CE = Field<7, 1>;    // OC1CE
            using OC1M = Field<4, 3>;    // OC1M
            using OC1PE = Field<3, 1>;    // OC1PE
            using OC1FE = Field<2, 1>;    // OC1FE
            using CC1S = Field<0, 2>;    // CC1S
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000c18> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x40000c1c> {
            using O24CE = Field<15, 1>;    // O24CE
            using OC4M = Field<12, 3>;    // OC4M
            using OC4PE = Field<11, 1>;    // OC4PE
            using OC4FE = Field<10, 1>;    // OC4FE
            using CC4S = Field<8, 2>;    // CC4S
            using OC3CE = Field<7, 1>;    // OC3CE
            using OC3M = Field<4, 3>;    // OC3M
            using OC3PE = Field<3, 1>;    // OC3PE
            using OC3FE = Field<2, 1>;    // OC3FE
            using CC3S = Field<0, 2>;    // CC3S
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x40000c1c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000c20> {
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 output Polarity
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000c24> {
            using CNT_H = Field<16, 16>;    // High counter value
            using CNT_L = Field<0, 16>;    // Low counter value
        };

        // prescaler
        struct PSC : public Register<0x40000c28> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x40000c2c> {
            using ARR_H = Field<16, 16>;    // High Auto-reload value
            using ARR_L = Field<0, 16>;    // Low Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000c34> {
            using CCR1_H = Field<16, 16>;    // High Capture/Compare 1 value
            using CCR1_L = Field<0, 16>;    // Low Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40000c38> {
            using CCR2_H = Field<16, 16>;    // High Capture/Compare 2 value
            using CCR2_L = Field<0, 16>;    // Low Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x40000c3c> {
            using CCR3_H = Field<16, 16>;    // High Capture/Compare value
            using CCR3_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40000c40> {
            using CCR4_H = Field<16, 16>;    // High Capture/Compare value
            using CCR4_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40000c48> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x40000c4c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

    };

    // General purpose timers
    struct TIM9 {
        // control register 1
        struct CR1 : public Register<0x40014000> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // slave mode control register
        struct SMCR : public Register<0x40014008> {
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001400c> {
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40014010> {
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40014014> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40014018> {
            using OC2M = Field<12, 3>;    // Output Compare 2 mode
            using OC2PE = Field<11, 1>;    // Output Compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output Compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40014018> {
            using IC2F = Field<12, 3>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 3>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40014020> {
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40014024> {
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40014028> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001402c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40014034> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40014038> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

    };

    // General purpose timers
    struct TIM12 {
        // control register 1
        struct CR1 : public Register<0x40001800> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // slave mode control register
        struct SMCR : public Register<0x40001808> {
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000180c> {
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40001810> {
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40001814> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40001818> {
            using OC2M = Field<12, 3>;    // Output Compare 2 mode
            using OC2PE = Field<11, 1>;    // Output Compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output Compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40001818> {
            using IC2F = Field<12, 3>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 3>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40001820> {
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40001824> {
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40001828> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000182c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40001834> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40001838> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

    };

    // General-purpose-timers
    struct TIM10 {
        // control register 1
        struct CR1 : public Register<0x40014400> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001440c> {
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40014410> {
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40014414> {
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40014418> {
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40014418> {
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40014420> {
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40014424> {
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40014428> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001442c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40014434> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // slave mode control register
        struct SMCR : public Register<0x40014408> {
            using SMS3 = Field<16, 1>;    // Slave mode selection
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // option register
        struct OR : public Register<0x40014450> {
            using TI1_RMP = Field<0, 2>;    // TIM11 Input 1 remapping capability
        };

    };

    // General-purpose-timers
    struct TIM11 {
        // control register 1
        struct CR1 : public Register<0x40014800> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001480c> {
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40014810> {
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40014814> {
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40014818> {
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40014818> {
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40014820> {
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40014824> {
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40014828> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001482c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40014834> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // slave mode control register
        struct SMCR : public Register<0x40014808> {
            using SMS3 = Field<16, 1>;    // Slave mode selection
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // option register
        struct OR : public Register<0x40014850> {
            using TI1_RMP = Field<0, 2>;    // TIM11 Input 1 remapping capability
        };

    };

    // General-purpose-timers
    struct TIM13 {
        // control register 1
        struct CR1 : public Register<0x40001c00> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x40001c0c> {
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40001c10> {
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40001c14> {
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40001c18> {
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40001c18> {
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40001c20> {
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40001c24> {
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40001c28> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x40001c2c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40001c34> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // slave mode control register
        struct SMCR : public Register<0x40001c08> {
            using SMS3 = Field<16, 1>;    // Slave mode selection
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // option register
        struct OR : public Register<0x40001c50> {
            using TI1_RMP = Field<0, 2>;    // TIM11 Input 1 remapping capability
        };

    };

    // General-purpose-timers
    struct TIM14 {
        // control register 1
        struct CR1 : public Register<0x40002000> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000200c> {
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40002010> {
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40002014> {
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40002018> {
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40002018> {
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40002020> {
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40002024> {
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40002028> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000202c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40002034> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // slave mode control register
        struct SMCR : public Register<0x40002008> {
            using SMS3 = Field<16, 1>;    // Slave mode selection
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // option register
        struct OR : public Register<0x40002050> {
            using TI1_RMP = Field<0, 2>;    // TIM11 Input 1 remapping capability
        };

    };

    // Basic timers
    struct TIM6 {
        // control register 1
        struct CR1 : public Register<0x40001000> {
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40001004> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000100c> {
            using UDE = Field<8, 1>;    // Update DMA request enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40001010> {
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40001014> {
            using UG = Field<0, 1>;    // Update generation
        };

        // counter
        struct CNT : public Register<0x40001024> {
            using Field = Field<0, 16>;    // Low counter value
        };

        // prescaler
        struct PSC : public Register<0x40001028> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000102c> {
            using Field = Field<0, 16>;    // Low Auto-reload value
        };

    };

    // Basic timers
    struct TIM7 {
        // control register 1
        struct CR1 : public Register<0x40001400> {
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40001404> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000140c> {
            using UDE = Field<8, 1>;    // Update DMA request enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40001410> {
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40001414> {
            using UG = Field<0, 1>;    // Update generation
        };

        // counter
        struct CNT : public Register<0x40001424> {
            using Field = Field<0, 16>;    // Low counter value
        };

        // prescaler
        struct PSC : public Register<0x40001428> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000142c> {
            using Field = Field<0, 16>;    // Low Auto-reload value
        };

    };

    // Ethernet: media access control (MAC)
    struct Ethernet_MAC {
        // Ethernet MAC configuration register
        struct MACCR : public Register<0x40028000> {
            using RE = Field<2, 1>;    // RE
            using TE = Field<3, 1>;    // TE
            using DC = Field<4, 1>;    // DC
            using BL = Field<5, 2>;    // BL
            using APCS = Field<7, 1>;    // APCS
            using RD = Field<9, 1>;    // RD
            using IPCO = Field<10, 1>;    // IPCO
            using DM = Field<11, 1>;    // DM
            using LM = Field<12, 1>;    // LM
            using ROD = Field<13, 1>;    // ROD
            using FES = Field<14, 1>;    // FES
            using CSD = Field<16, 1>;    // CSD
            using IFG = Field<17, 3>;    // IFG
            using JD = Field<22, 1>;    // JD
            using WD = Field<23, 1>;    // WD
            using CSTF = Field<25, 1>;    // CSTF
        };

        // Ethernet MAC frame filter register
        struct MACFFR : public Register<0x40028004> {
            using PM = Field<0, 1>;    // PM
            using HU = Field<1, 1>;    // HU
            using HM = Field<2, 1>;    // HM
            using DAIF = Field<3, 1>;    // DAIF
            using RAM = Field<4, 1>;    // RAM
            using BFD = Field<5, 1>;    // BFD
            using PCF = Field<6, 1>;    // PCF
            using SAIF = Field<7, 1>;    // SAIF
            using SAF = Field<8, 1>;    // SAF
            using HPF = Field<9, 1>;    // HPF
            using RA = Field<31, 1>;    // RA
        };

        // Ethernet MAC hash table high register
        struct MACHTHR : public Register<0x40028008> {
            using HTH = Field<0, 32>;    // HTH
        };

        // Ethernet MAC hash table low register
        struct MACHTLR : public Register<0x4002800c> {
            using HTL = Field<0, 32>;    // HTL
        };

        // Ethernet MAC MII address register
        struct MACMIIAR : public Register<0x40028010> {
            using MB = Field<0, 1>;    // MB
            using MW = Field<1, 1>;    // MW
            using CR = Field<2, 3>;    // CR
            using MR = Field<6, 5>;    // MR
            using PA = Field<11, 5>;    // PA
        };

        // Ethernet MAC MII data register
        struct MACMIIDR : public Register<0x40028014> {
            using TD = Field<0, 16>;    // TD
        };

        // Ethernet MAC flow control register
        struct MACFCR : public Register<0x40028018> {
            using FCB = Field<0, 1>;    // FCB
            using TFCE = Field<1, 1>;    // TFCE
            using RFCE = Field<2, 1>;    // RFCE
            using UPFD = Field<3, 1>;    // UPFD
            using PLT = Field<4, 2>;    // PLT
            using ZQPD = Field<7, 1>;    // ZQPD
            using PT = Field<16, 16>;    // PT
        };

        // Ethernet MAC VLAN tag register
        struct MACVLANTR : public Register<0x4002801c> {
            using VLANTI = Field<0, 16>;    // VLANTI
            using VLANTC = Field<16, 1>;    // VLANTC
        };

        // Ethernet MAC PMT control and status register
        struct MACPMTCSR : public Register<0x4002802c> {
            using PD = Field<0, 1>;    // PD
            using MPE = Field<1, 1>;    // MPE
            using WFE = Field<2, 1>;    // WFE
            using MPR = Field<5, 1>;    // MPR
            using WFR = Field<6, 1>;    // WFR
            using GU = Field<9, 1>;    // GU
            using WFFRPR = Field<31, 1>;    // WFFRPR
        };

        // Ethernet MAC debug register
        struct MACDBGR : public RegisterReadOnly<0x40028034> {
            using CR = Field<0, 1>;    // CR
            using CSR = Field<1, 1>;    // CSR
            using ROR = Field<2, 1>;    // ROR
            using MCF = Field<3, 1>;    // MCF
            using MCP = Field<4, 1>;    // MCP
            using MCFHP = Field<5, 1>;    // MCFHP
        };

        // Ethernet MAC interrupt status register
        struct MACSR : public Register<0x40028038> {
            using PMTS = Field<3, 1>;    // PMTS
            using MMCS = Field<4, 1>;    // PMTS
            using MMCRS = Field<5, 1>;    // MMCRS
            using MMCTS = Field<6, 1>;    // MMCTS
            using TSTS = Field<9, 1>;    // TSTS
        };

        // Ethernet MAC interrupt mask register
        struct MACIMR : public Register<0x4002803c> {
            using PMTIM = Field<3, 1>;    // PMTIM
            using TSTIM = Field<9, 1>;    // TSTIM
        };

        // Ethernet MAC address 0 high register
        struct MACA0HR : public Register<0x40028040> {
            using MACA0H = Field<0, 16>;    // MAC address0 high
            using MO = Field<31, 1>;    // Always 1
        };

        // Ethernet MAC address 0 low register
        struct MACA0LR : public Register<0x40028044> {
            using MACA0L = Field<0, 32>;    // 0
        };

        // Ethernet MAC address 1 high register
        struct MACA1HR : public Register<0x40028048> {
            using MACA1H = Field<0, 16>;    // MACA1H
            using MBC = Field<24, 6>;    // MBC
            using SA = Field<30, 1>;    // SA
            using AE = Field<31, 1>;    // AE
        };

        // Ethernet MAC address1 low register
        struct MACA1LR : public Register<0x4002804c> {
            using Field = Field<0, 32>;    // MACA1LR
        };

        // Ethernet MAC address 2 high register
        struct MACA2HR : public Register<0x40028050> {
            using MAC2AH = Field<0, 16>;    // MAC2AH
            using MBC = Field<24, 6>;    // MBC
            using SA = Field<30, 1>;    // SA
            using AE = Field<31, 1>;    // AE
        };

        // Ethernet MAC address 2 low register
        struct MACA2LR : public Register<0x40028054> {
            using MACA2L = Field<0, 31>;    // MACA2L
        };

        // Ethernet MAC address 3 high register
        struct MACA3HR : public Register<0x40028058> {
            using MACA3H = Field<0, 16>;    // MACA3H
            using MBC = Field<24, 6>;    // MBC
            using SA = Field<30, 1>;    // SA
            using AE = Field<31, 1>;    // AE
        };

        // Ethernet MAC address 3 low register
        struct MACA3LR : public Register<0x4002805c> {
            using MBCA3L = Field<0, 32>;    // MBCA3L
        };

        // Ethernet MAC remote wakeup frame filter register
        struct MACRWUFFER : public Register<0x40028060> {
        };

    };

    // Cryptographic processor
    struct CRC {
        // Data register
        struct DR : public Register<0x40023000> {
            using Field = Field<0, 32>;    // Data Register
        };

        // Independent Data register
        struct IDR : public Register<0x40023004> {
            using Field = Field<0, 8>;    // Independent Data register
        };

        // Control register
        struct CR : public RegisterWriteOnly<0x40023008> {
            using Field = Field<0, 1>;    // Control regidter
        };

        // Initial CRC value
        struct INIT : public Register<0x4002300c> {
            using CRC_INIT = Field<0, 32>;    // Programmable initial CRC value
        };

        // CRC polynomial
        struct POL : public Register<0x40023010> {
            using Field = Field<0, 32>;    // Programmable polynomial
        };

    };

    // Controller area network
    struct CAN1 {
        // master control register
        struct MCR : public Register<0x40006400> {
            using DBF = Field<16, 1>;    // DBF
            using RESET = Field<15, 1>;    // RESET
            using TTCM = Field<7, 1>;    // TTCM
            using ABOM = Field<6, 1>;    // ABOM
            using AWUM = Field<5, 1>;    // AWUM
            using NART = Field<4, 1>;    // NART
            using RFLM = Field<3, 1>;    // RFLM
            using TXFP = Field<2, 1>;    // TXFP
            using SLEEP = Field<1, 1>;    // SLEEP
            using INRQ = Field<0, 1>;    // INRQ
        };

        // master status register
        struct MSR : public Register<0x40006404> {
            using RX = Field<11, 1>;    // RX
            using SAMP = Field<10, 1>;    // SAMP
            using RXM = Field<9, 1>;    // RXM
            using TXM = Field<8, 1>;    // TXM
            using SLAKI = Field<4, 1>;    // SLAKI
            using WKUI = Field<3, 1>;    // WKUI
            using ERRI = Field<2, 1>;    // ERRI
            using SLAK = Field<1, 1>;    // SLAK
            using INAK = Field<0, 1>;    // INAK
        };

        // transmit status register
        struct TSR : public Register<0x40006408> {
            using LOW2 = Field<31, 1>;    // Lowest priority flag for mailbox 2
            using LOW1 = Field<30, 1>;    // Lowest priority flag for mailbox 1
            using LOW0 = Field<29, 1>;    // Lowest priority flag for mailbox 0
            using TME2 = Field<28, 1>;    // Lowest priority flag for mailbox 2
            using TME1 = Field<27, 1>;    // Lowest priority flag for mailbox 1
            using TME0 = Field<26, 1>;    // Lowest priority flag for mailbox 0
            using CODE = Field<24, 2>;    // CODE
            using ABRQ2 = Field<23, 1>;    // ABRQ2
            using TERR2 = Field<19, 1>;    // TERR2
            using ALST2 = Field<18, 1>;    // ALST2
            using TXOK2 = Field<17, 1>;    // TXOK2
            using RQCP2 = Field<16, 1>;    // RQCP2
            using ABRQ1 = Field<15, 1>;    // ABRQ1
            using TERR1 = Field<11, 1>;    // TERR1
            using ALST1 = Field<10, 1>;    // ALST1
            using TXOK1 = Field<9, 1>;    // TXOK1
            using RQCP1 = Field<8, 1>;    // RQCP1
            using ABRQ0 = Field<7, 1>;    // ABRQ0
            using TERR0 = Field<3, 1>;    // TERR0
            using ALST0 = Field<2, 1>;    // ALST0
            using TXOK0 = Field<1, 1>;    // TXOK0
            using RQCP0 = Field<0, 1>;    // RQCP0
        };

        // receive FIFO 0 register
        struct RF0R : public Register<0x4000640c> {
            using RFOM0 = Field<5, 1>;    // RFOM0
            using FOVR0 = Field<4, 1>;    // FOVR0
            using FULL0 = Field<3, 1>;    // FULL0
            using FMP0 = Field<0, 2>;    // FMP0
        };

        // receive FIFO 1 register
        struct RF1R : public Register<0x40006410> {
            using RFOM1 = Field<5, 1>;    // RFOM1
            using FOVR1 = Field<4, 1>;    // FOVR1
            using FULL1 = Field<3, 1>;    // FULL1
            using FMP1 = Field<0, 2>;    // FMP1
        };

        // interrupt enable register
        struct IER : public Register<0x40006414> {
            using SLKIE = Field<17, 1>;    // SLKIE
            using WKUIE = Field<16, 1>;    // WKUIE
            using ERRIE = Field<15, 1>;    // ERRIE
            using LECIE = Field<11, 1>;    // LECIE
            using BOFIE = Field<10, 1>;    // BOFIE
            using EPVIE = Field<9, 1>;    // EPVIE
            using EWGIE = Field<8, 1>;    // EWGIE
            using FOVIE1 = Field<6, 1>;    // FOVIE1
            using FFIE1 = Field<5, 1>;    // FFIE1
            using FMPIE1 = Field<4, 1>;    // FMPIE1
            using FOVIE0 = Field<3, 1>;    // FOVIE0
            using FFIE0 = Field<2, 1>;    // FFIE0
            using FMPIE0 = Field<1, 1>;    // FMPIE0
            using TMEIE = Field<0, 1>;    // TMEIE
        };

        // interrupt enable register
        struct ESR : public Register<0x40006418> {
            using REC = Field<24, 8>;    // REC
            using TEC = Field<16, 8>;    // TEC
            using LEC = Field<4, 3>;    // LEC
            using BOFF = Field<2, 1>;    // BOFF
            using EPVF = Field<1, 1>;    // EPVF
            using EWGF = Field<0, 1>;    // EWGF
        };

        // bit timing register
        struct BTR : public Register<0x4000641c> {
            using SILM = Field<31, 1>;    // SILM
            using LBKM = Field<30, 1>;    // LBKM
            using SJW = Field<24, 2>;    // SJW
            using TS2 = Field<20, 3>;    // TS2
            using TS1 = Field<16, 4>;    // TS1
            using BRP = Field<0, 10>;    // BRP
        };

        // TX mailbox identifier register
        struct TI0R : public Register<0x40006580> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
            using TXRQ = Field<0, 1>;    // TXRQ
        };

        // mailbox data length control and time stamp register
        struct TDT0R : public Register<0x40006584> {
            using TIME = Field<16, 16>;    // TIME
            using TGT = Field<8, 1>;    // TGT
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data low register
        struct TDL0R : public Register<0x40006588> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct TDH0R : public Register<0x4000658c> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // mailbox identifier register
        struct TI1R : public Register<0x40006590> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
            using TXRQ = Field<0, 1>;    // TXRQ
        };

        // mailbox data length control and time stamp register
        struct TDT1R : public Register<0x40006594> {
            using TIME = Field<16, 16>;    // TIME
            using TGT = Field<8, 1>;    // TGT
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data low register
        struct TDL1R : public Register<0x40006598> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct TDH1R : public Register<0x4000659c> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // mailbox identifier register
        struct TI2R : public Register<0x400065a0> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
            using TXRQ = Field<0, 1>;    // TXRQ
        };

        // mailbox data length control and time stamp register
        struct TDT2R : public Register<0x400065a4> {
            using TIME = Field<16, 16>;    // TIME
            using TGT = Field<8, 1>;    // TGT
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data low register
        struct TDL2R : public Register<0x400065a8> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct TDH2R : public Register<0x400065ac> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // receive FIFO mailbox identifier register
        struct RI0R : public RegisterReadOnly<0x400065b0> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
        };

        // mailbox data high register
        struct RDT0R : public RegisterReadOnly<0x400065b4> {
            using TIME = Field<16, 16>;    // TIME
            using FMI = Field<8, 8>;    // FMI
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data high register
        struct RDL0R : public RegisterReadOnly<0x400065b8> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // receive FIFO mailbox data high register
        struct RDH0R : public RegisterReadOnly<0x400065bc> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // mailbox data high register
        struct RI1R : public RegisterReadOnly<0x400065c0> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
        };

        // mailbox data high register
        struct RDT1R : public RegisterReadOnly<0x400065c4> {
            using TIME = Field<16, 16>;    // TIME
            using FMI = Field<8, 8>;    // FMI
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data high register
        struct RDL1R : public RegisterReadOnly<0x400065c8> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct RDH1R : public RegisterReadOnly<0x400065cc> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // filter master register
        struct FMR : public Register<0x40006600> {
            using CAN2SB = Field<8, 6>;    // CAN2SB
            using FINIT = Field<0, 1>;    // FINIT
        };

        // filter mode register
        struct FM1R : public Register<0x40006604> {
            using FBM0 = Field<0, 1>;    // Filter mode
            using FBM1 = Field<1, 1>;    // Filter mode
            using FBM2 = Field<2, 1>;    // Filter mode
            using FBM3 = Field<3, 1>;    // Filter mode
            using FBM4 = Field<4, 1>;    // Filter mode
            using FBM5 = Field<5, 1>;    // Filter mode
            using FBM6 = Field<6, 1>;    // Filter mode
            using FBM7 = Field<7, 1>;    // Filter mode
            using FBM8 = Field<8, 1>;    // Filter mode
            using FBM9 = Field<9, 1>;    // Filter mode
            using FBM10 = Field<10, 1>;    // Filter mode
            using FBM11 = Field<11, 1>;    // Filter mode
            using FBM12 = Field<12, 1>;    // Filter mode
            using FBM13 = Field<13, 1>;    // Filter mode
            using FBM14 = Field<14, 1>;    // Filter mode
            using FBM15 = Field<15, 1>;    // Filter mode
            using FBM16 = Field<16, 1>;    // Filter mode
            using FBM17 = Field<17, 1>;    // Filter mode
            using FBM18 = Field<18, 1>;    // Filter mode
            using FBM19 = Field<19, 1>;    // Filter mode
            using FBM20 = Field<20, 1>;    // Filter mode
            using FBM21 = Field<21, 1>;    // Filter mode
            using FBM22 = Field<22, 1>;    // Filter mode
            using FBM23 = Field<23, 1>;    // Filter mode
            using FBM24 = Field<24, 1>;    // Filter mode
            using FBM25 = Field<25, 1>;    // Filter mode
            using FBM26 = Field<26, 1>;    // Filter mode
            using FBM27 = Field<27, 1>;    // Filter mode
        };

        // filter scale register
        struct FS1R : public Register<0x4000660c> {
            using FSC0 = Field<0, 1>;    // Filter scale configuration
            using FSC1 = Field<1, 1>;    // Filter scale configuration
            using FSC2 = Field<2, 1>;    // Filter scale configuration
            using FSC3 = Field<3, 1>;    // Filter scale configuration
            using FSC4 = Field<4, 1>;    // Filter scale configuration
            using FSC5 = Field<5, 1>;    // Filter scale configuration
            using FSC6 = Field<6, 1>;    // Filter scale configuration
            using FSC7 = Field<7, 1>;    // Filter scale configuration
            using FSC8 = Field<8, 1>;    // Filter scale configuration
            using FSC9 = Field<9, 1>;    // Filter scale configuration
            using FSC10 = Field<10, 1>;    // Filter scale configuration
            using FSC11 = Field<11, 1>;    // Filter scale configuration
            using FSC12 = Field<12, 1>;    // Filter scale configuration
            using FSC13 = Field<13, 1>;    // Filter scale configuration
            using FSC14 = Field<14, 1>;    // Filter scale configuration
            using FSC15 = Field<15, 1>;    // Filter scale configuration
            using FSC16 = Field<16, 1>;    // Filter scale configuration
            using FSC17 = Field<17, 1>;    // Filter scale configuration
            using FSC18 = Field<18, 1>;    // Filter scale configuration
            using FSC19 = Field<19, 1>;    // Filter scale configuration
            using FSC20 = Field<20, 1>;    // Filter scale configuration
            using FSC21 = Field<21, 1>;    // Filter scale configuration
            using FSC22 = Field<22, 1>;    // Filter scale configuration
            using FSC23 = Field<23, 1>;    // Filter scale configuration
            using FSC24 = Field<24, 1>;    // Filter scale configuration
            using FSC25 = Field<25, 1>;    // Filter scale configuration
            using FSC26 = Field<26, 1>;    // Filter scale configuration
            using FSC27 = Field<27, 1>;    // Filter scale configuration
        };

        // filter FIFO assignment register
        struct FFA1R : public Register<0x40006614> {
            using FFA0 = Field<0, 1>;    // Filter FIFO assignment for filter 0
            using FFA1 = Field<1, 1>;    // Filter FIFO assignment for filter 1
            using FFA2 = Field<2, 1>;    // Filter FIFO assignment for filter 2
            using FFA3 = Field<3, 1>;    // Filter FIFO assignment for filter 3
            using FFA4 = Field<4, 1>;    // Filter FIFO assignment for filter 4
            using FFA5 = Field<5, 1>;    // Filter FIFO assignment for filter 5
            using FFA6 = Field<6, 1>;    // Filter FIFO assignment for filter 6
            using FFA7 = Field<7, 1>;    // Filter FIFO assignment for filter 7
            using FFA8 = Field<8, 1>;    // Filter FIFO assignment for filter 8
            using FFA9 = Field<9, 1>;    // Filter FIFO assignment for filter 9
            using FFA10 = Field<10, 1>;    // Filter FIFO assignment for filter 10
            using FFA11 = Field<11, 1>;    // Filter FIFO assignment for filter 11
            using FFA12 = Field<12, 1>;    // Filter FIFO assignment for filter 12
            using FFA13 = Field<13, 1>;    // Filter FIFO assignment for filter 13
            using FFA14 = Field<14, 1>;    // Filter FIFO assignment for filter 14
            using FFA15 = Field<15, 1>;    // Filter FIFO assignment for filter 15
            using FFA16 = Field<16, 1>;    // Filter FIFO assignment for filter 16
            using FFA17 = Field<17, 1>;    // Filter FIFO assignment for filter 17
            using FFA18 = Field<18, 1>;    // Filter FIFO assignment for filter 18
            using FFA19 = Field<19, 1>;    // Filter FIFO assignment for filter 19
            using FFA20 = Field<20, 1>;    // Filter FIFO assignment for filter 20
            using FFA21 = Field<21, 1>;    // Filter FIFO assignment for filter 21
            using FFA22 = Field<22, 1>;    // Filter FIFO assignment for filter 22
            using FFA23 = Field<23, 1>;    // Filter FIFO assignment for filter 23
            using FFA24 = Field<24, 1>;    // Filter FIFO assignment for filter 24
            using FFA25 = Field<25, 1>;    // Filter FIFO assignment for filter 25
            using FFA26 = Field<26, 1>;    // Filter FIFO assignment for filter 26
            using FFA27 = Field<27, 1>;    // Filter FIFO assignment for filter 27
        };

        // filter activation register
        struct FA1R : public Register<0x4000661c> {
            using FACT0 = Field<0, 1>;    // Filter active
            using FACT1 = Field<1, 1>;    // Filter active
            using FACT2 = Field<2, 1>;    // Filter active
            using FACT3 = Field<3, 1>;    // Filter active
            using FACT4 = Field<4, 1>;    // Filter active
            using FACT5 = Field<5, 1>;    // Filter active
            using FACT6 = Field<6, 1>;    // Filter active
            using FACT7 = Field<7, 1>;    // Filter active
            using FACT8 = Field<8, 1>;    // Filter active
            using FACT9 = Field<9, 1>;    // Filter active
            using FACT10 = Field<10, 1>;    // Filter active
            using FACT11 = Field<11, 1>;    // Filter active
            using FACT12 = Field<12, 1>;    // Filter active
            using FACT13 = Field<13, 1>;    // Filter active
            using FACT14 = Field<14, 1>;    // Filter active
            using FACT15 = Field<15, 1>;    // Filter active
            using FACT16 = Field<16, 1>;    // Filter active
            using FACT17 = Field<17, 1>;    // Filter active
            using FACT18 = Field<18, 1>;    // Filter active
            using FACT19 = Field<19, 1>;    // Filter active
            using FACT20 = Field<20, 1>;    // Filter active
            using FACT21 = Field<21, 1>;    // Filter active
            using FACT22 = Field<22, 1>;    // Filter active
            using FACT23 = Field<23, 1>;    // Filter active
            using FACT24 = Field<24, 1>;    // Filter active
            using FACT25 = Field<25, 1>;    // Filter active
            using FACT26 = Field<26, 1>;    // Filter active
            using FACT27 = Field<27, 1>;    // Filter active
        };

        // Filter bank 0 register 1
        struct F0R1 : public Register<0x40006640> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 0 register 2
        struct F0R2 : public Register<0x40006644> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 1 register 1
        struct F1R1 : public Register<0x40006648> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 1 register 2
        struct F1R2 : public Register<0x4000664c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 2 register 1
        struct F2R1 : public Register<0x40006650> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 2 register 2
        struct F2R2 : public Register<0x40006654> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 3 register 1
        struct F3R1 : public Register<0x40006658> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 3 register 2
        struct F3R2 : public Register<0x4000665c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 4 register 1
        struct F4R1 : public Register<0x40006660> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 4 register 2
        struct F4R2 : public Register<0x40006664> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 5 register 1
        struct F5R1 : public Register<0x40006668> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 5 register 2
        struct F5R2 : public Register<0x4000666c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 6 register 1
        struct F6R1 : public Register<0x40006670> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 6 register 2
        struct F6R2 : public Register<0x40006674> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 7 register 1
        struct F7R1 : public Register<0x40006678> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 7 register 2
        struct F7R2 : public Register<0x4000667c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 8 register 1
        struct F8R1 : public Register<0x40006680> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 8 register 2
        struct F8R2 : public Register<0x40006684> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 9 register 1
        struct F9R1 : public Register<0x40006688> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 9 register 2
        struct F9R2 : public Register<0x4000668c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 10 register 1
        struct F10R1 : public Register<0x40006690> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 10 register 2
        struct F10R2 : public Register<0x40006694> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 11 register 1
        struct F11R1 : public Register<0x40006698> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 11 register 2
        struct F11R2 : public Register<0x4000669c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 4 register 1
        struct F12R1 : public Register<0x400066a0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 12 register 2
        struct F12R2 : public Register<0x400066a4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 13 register 1
        struct F13R1 : public Register<0x400066a8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 13 register 2
        struct F13R2 : public Register<0x400066ac> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 14 register 1
        struct F14R1 : public Register<0x400066b0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 14 register 2
        struct F14R2 : public Register<0x400066b4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 15 register 1
        struct F15R1 : public Register<0x400066b8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 15 register 2
        struct F15R2 : public Register<0x400066bc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 16 register 1
        struct F16R1 : public Register<0x400066c0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 16 register 2
        struct F16R2 : public Register<0x400066c4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 17 register 1
        struct F17R1 : public Register<0x400066c8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 17 register 2
        struct F17R2 : public Register<0x400066cc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 18 register 1
        struct F18R1 : public Register<0x400066d0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 18 register 2
        struct F18R2 : public Register<0x400066d4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 19 register 1
        struct F19R1 : public Register<0x400066d8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 19 register 2
        struct F19R2 : public Register<0x400066dc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 20 register 1
        struct F20R1 : public Register<0x400066e0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 20 register 2
        struct F20R2 : public Register<0x400066e4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 21 register 1
        struct F21R1 : public Register<0x400066e8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 21 register 2
        struct F21R2 : public Register<0x400066ec> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 22 register 1
        struct F22R1 : public Register<0x400066f0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 22 register 2
        struct F22R2 : public Register<0x400066f4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 23 register 1
        struct F23R1 : public Register<0x400066f8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 23 register 2
        struct F23R2 : public Register<0x400066fc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 24 register 1
        struct F24R1 : public Register<0x40006700> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 24 register 2
        struct F24R2 : public Register<0x40006704> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 25 register 1
        struct F25R1 : public Register<0x40006708> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 25 register 2
        struct F25R2 : public Register<0x4000670c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 26 register 1
        struct F26R1 : public Register<0x40006710> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 26 register 2
        struct F26R2 : public Register<0x40006714> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 27 register 1
        struct F27R1 : public Register<0x40006718> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 27 register 2
        struct F27R2 : public Register<0x4000671c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

    };

    // Controller area network
    struct CAN2 {
        // master control register
        struct MCR : public Register<0x40006800> {
            using DBF = Field<16, 1>;    // DBF
            using RESET = Field<15, 1>;    // RESET
            using TTCM = Field<7, 1>;    // TTCM
            using ABOM = Field<6, 1>;    // ABOM
            using AWUM = Field<5, 1>;    // AWUM
            using NART = Field<4, 1>;    // NART
            using RFLM = Field<3, 1>;    // RFLM
            using TXFP = Field<2, 1>;    // TXFP
            using SLEEP = Field<1, 1>;    // SLEEP
            using INRQ = Field<0, 1>;    // INRQ
        };

        // master status register
        struct MSR : public Register<0x40006804> {
            using RX = Field<11, 1>;    // RX
            using SAMP = Field<10, 1>;    // SAMP
            using RXM = Field<9, 1>;    // RXM
            using TXM = Field<8, 1>;    // TXM
            using SLAKI = Field<4, 1>;    // SLAKI
            using WKUI = Field<3, 1>;    // WKUI
            using ERRI = Field<2, 1>;    // ERRI
            using SLAK = Field<1, 1>;    // SLAK
            using INAK = Field<0, 1>;    // INAK
        };

        // transmit status register
        struct TSR : public Register<0x40006808> {
            using LOW2 = Field<31, 1>;    // Lowest priority flag for mailbox 2
            using LOW1 = Field<30, 1>;    // Lowest priority flag for mailbox 1
            using LOW0 = Field<29, 1>;    // Lowest priority flag for mailbox 0
            using TME2 = Field<28, 1>;    // Lowest priority flag for mailbox 2
            using TME1 = Field<27, 1>;    // Lowest priority flag for mailbox 1
            using TME0 = Field<26, 1>;    // Lowest priority flag for mailbox 0
            using CODE = Field<24, 2>;    // CODE
            using ABRQ2 = Field<23, 1>;    // ABRQ2
            using TERR2 = Field<19, 1>;    // TERR2
            using ALST2 = Field<18, 1>;    // ALST2
            using TXOK2 = Field<17, 1>;    // TXOK2
            using RQCP2 = Field<16, 1>;    // RQCP2
            using ABRQ1 = Field<15, 1>;    // ABRQ1
            using TERR1 = Field<11, 1>;    // TERR1
            using ALST1 = Field<10, 1>;    // ALST1
            using TXOK1 = Field<9, 1>;    // TXOK1
            using RQCP1 = Field<8, 1>;    // RQCP1
            using ABRQ0 = Field<7, 1>;    // ABRQ0
            using TERR0 = Field<3, 1>;    // TERR0
            using ALST0 = Field<2, 1>;    // ALST0
            using TXOK0 = Field<1, 1>;    // TXOK0
            using RQCP0 = Field<0, 1>;    // RQCP0
        };

        // receive FIFO 0 register
        struct RF0R : public Register<0x4000680c> {
            using RFOM0 = Field<5, 1>;    // RFOM0
            using FOVR0 = Field<4, 1>;    // FOVR0
            using FULL0 = Field<3, 1>;    // FULL0
            using FMP0 = Field<0, 2>;    // FMP0
        };

        // receive FIFO 1 register
        struct RF1R : public Register<0x40006810> {
            using RFOM1 = Field<5, 1>;    // RFOM1
            using FOVR1 = Field<4, 1>;    // FOVR1
            using FULL1 = Field<3, 1>;    // FULL1
            using FMP1 = Field<0, 2>;    // FMP1
        };

        // interrupt enable register
        struct IER : public Register<0x40006814> {
            using SLKIE = Field<17, 1>;    // SLKIE
            using WKUIE = Field<16, 1>;    // WKUIE
            using ERRIE = Field<15, 1>;    // ERRIE
            using LECIE = Field<11, 1>;    // LECIE
            using BOFIE = Field<10, 1>;    // BOFIE
            using EPVIE = Field<9, 1>;    // EPVIE
            using EWGIE = Field<8, 1>;    // EWGIE
            using FOVIE1 = Field<6, 1>;    // FOVIE1
            using FFIE1 = Field<5, 1>;    // FFIE1
            using FMPIE1 = Field<4, 1>;    // FMPIE1
            using FOVIE0 = Field<3, 1>;    // FOVIE0
            using FFIE0 = Field<2, 1>;    // FFIE0
            using FMPIE0 = Field<1, 1>;    // FMPIE0
            using TMEIE = Field<0, 1>;    // TMEIE
        };

        // interrupt enable register
        struct ESR : public Register<0x40006818> {
            using REC = Field<24, 8>;    // REC
            using TEC = Field<16, 8>;    // TEC
            using LEC = Field<4, 3>;    // LEC
            using BOFF = Field<2, 1>;    // BOFF
            using EPVF = Field<1, 1>;    // EPVF
            using EWGF = Field<0, 1>;    // EWGF
        };

        // bit timing register
        struct BTR : public Register<0x4000681c> {
            using SILM = Field<31, 1>;    // SILM
            using LBKM = Field<30, 1>;    // LBKM
            using SJW = Field<24, 2>;    // SJW
            using TS2 = Field<20, 3>;    // TS2
            using TS1 = Field<16, 4>;    // TS1
            using BRP = Field<0, 10>;    // BRP
        };

        // TX mailbox identifier register
        struct TI0R : public Register<0x40006980> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
            using TXRQ = Field<0, 1>;    // TXRQ
        };

        // mailbox data length control and time stamp register
        struct TDT0R : public Register<0x40006984> {
            using TIME = Field<16, 16>;    // TIME
            using TGT = Field<8, 1>;    // TGT
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data low register
        struct TDL0R : public Register<0x40006988> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct TDH0R : public Register<0x4000698c> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // mailbox identifier register
        struct TI1R : public Register<0x40006990> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
            using TXRQ = Field<0, 1>;    // TXRQ
        };

        // mailbox data length control and time stamp register
        struct TDT1R : public Register<0x40006994> {
            using TIME = Field<16, 16>;    // TIME
            using TGT = Field<8, 1>;    // TGT
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data low register
        struct TDL1R : public Register<0x40006998> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct TDH1R : public Register<0x4000699c> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // mailbox identifier register
        struct TI2R : public Register<0x400069a0> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
            using TXRQ = Field<0, 1>;    // TXRQ
        };

        // mailbox data length control and time stamp register
        struct TDT2R : public Register<0x400069a4> {
            using TIME = Field<16, 16>;    // TIME
            using TGT = Field<8, 1>;    // TGT
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data low register
        struct TDL2R : public Register<0x400069a8> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct TDH2R : public Register<0x400069ac> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // receive FIFO mailbox identifier register
        struct RI0R : public RegisterReadOnly<0x400069b0> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
        };

        // mailbox data high register
        struct RDT0R : public RegisterReadOnly<0x400069b4> {
            using TIME = Field<16, 16>;    // TIME
            using FMI = Field<8, 8>;    // FMI
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data high register
        struct RDL0R : public RegisterReadOnly<0x400069b8> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // receive FIFO mailbox data high register
        struct RDH0R : public RegisterReadOnly<0x400069bc> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // mailbox data high register
        struct RI1R : public RegisterReadOnly<0x400069c0> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
        };

        // mailbox data high register
        struct RDT1R : public RegisterReadOnly<0x400069c4> {
            using TIME = Field<16, 16>;    // TIME
            using FMI = Field<8, 8>;    // FMI
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data high register
        struct RDL1R : public RegisterReadOnly<0x400069c8> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct RDH1R : public RegisterReadOnly<0x400069cc> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // filter master register
        struct FMR : public Register<0x40006a00> {
            using CAN2SB = Field<8, 6>;    // CAN2SB
            using FINIT = Field<0, 1>;    // FINIT
        };

        // filter mode register
        struct FM1R : public Register<0x40006a04> {
            using FBM0 = Field<0, 1>;    // Filter mode
            using FBM1 = Field<1, 1>;    // Filter mode
            using FBM2 = Field<2, 1>;    // Filter mode
            using FBM3 = Field<3, 1>;    // Filter mode
            using FBM4 = Field<4, 1>;    // Filter mode
            using FBM5 = Field<5, 1>;    // Filter mode
            using FBM6 = Field<6, 1>;    // Filter mode
            using FBM7 = Field<7, 1>;    // Filter mode
            using FBM8 = Field<8, 1>;    // Filter mode
            using FBM9 = Field<9, 1>;    // Filter mode
            using FBM10 = Field<10, 1>;    // Filter mode
            using FBM11 = Field<11, 1>;    // Filter mode
            using FBM12 = Field<12, 1>;    // Filter mode
            using FBM13 = Field<13, 1>;    // Filter mode
            using FBM14 = Field<14, 1>;    // Filter mode
            using FBM15 = Field<15, 1>;    // Filter mode
            using FBM16 = Field<16, 1>;    // Filter mode
            using FBM17 = Field<17, 1>;    // Filter mode
            using FBM18 = Field<18, 1>;    // Filter mode
            using FBM19 = Field<19, 1>;    // Filter mode
            using FBM20 = Field<20, 1>;    // Filter mode
            using FBM21 = Field<21, 1>;    // Filter mode
            using FBM22 = Field<22, 1>;    // Filter mode
            using FBM23 = Field<23, 1>;    // Filter mode
            using FBM24 = Field<24, 1>;    // Filter mode
            using FBM25 = Field<25, 1>;    // Filter mode
            using FBM26 = Field<26, 1>;    // Filter mode
            using FBM27 = Field<27, 1>;    // Filter mode
        };

        // filter scale register
        struct FS1R : public Register<0x40006a0c> {
            using FSC0 = Field<0, 1>;    // Filter scale configuration
            using FSC1 = Field<1, 1>;    // Filter scale configuration
            using FSC2 = Field<2, 1>;    // Filter scale configuration
            using FSC3 = Field<3, 1>;    // Filter scale configuration
            using FSC4 = Field<4, 1>;    // Filter scale configuration
            using FSC5 = Field<5, 1>;    // Filter scale configuration
            using FSC6 = Field<6, 1>;    // Filter scale configuration
            using FSC7 = Field<7, 1>;    // Filter scale configuration
            using FSC8 = Field<8, 1>;    // Filter scale configuration
            using FSC9 = Field<9, 1>;    // Filter scale configuration
            using FSC10 = Field<10, 1>;    // Filter scale configuration
            using FSC11 = Field<11, 1>;    // Filter scale configuration
            using FSC12 = Field<12, 1>;    // Filter scale configuration
            using FSC13 = Field<13, 1>;    // Filter scale configuration
            using FSC14 = Field<14, 1>;    // Filter scale configuration
            using FSC15 = Field<15, 1>;    // Filter scale configuration
            using FSC16 = Field<16, 1>;    // Filter scale configuration
            using FSC17 = Field<17, 1>;    // Filter scale configuration
            using FSC18 = Field<18, 1>;    // Filter scale configuration
            using FSC19 = Field<19, 1>;    // Filter scale configuration
            using FSC20 = Field<20, 1>;    // Filter scale configuration
            using FSC21 = Field<21, 1>;    // Filter scale configuration
            using FSC22 = Field<22, 1>;    // Filter scale configuration
            using FSC23 = Field<23, 1>;    // Filter scale configuration
            using FSC24 = Field<24, 1>;    // Filter scale configuration
            using FSC25 = Field<25, 1>;    // Filter scale configuration
            using FSC26 = Field<26, 1>;    // Filter scale configuration
            using FSC27 = Field<27, 1>;    // Filter scale configuration
        };

        // filter FIFO assignment register
        struct FFA1R : public Register<0x40006a14> {
            using FFA0 = Field<0, 1>;    // Filter FIFO assignment for filter 0
            using FFA1 = Field<1, 1>;    // Filter FIFO assignment for filter 1
            using FFA2 = Field<2, 1>;    // Filter FIFO assignment for filter 2
            using FFA3 = Field<3, 1>;    // Filter FIFO assignment for filter 3
            using FFA4 = Field<4, 1>;    // Filter FIFO assignment for filter 4
            using FFA5 = Field<5, 1>;    // Filter FIFO assignment for filter 5
            using FFA6 = Field<6, 1>;    // Filter FIFO assignment for filter 6
            using FFA7 = Field<7, 1>;    // Filter FIFO assignment for filter 7
            using FFA8 = Field<8, 1>;    // Filter FIFO assignment for filter 8
            using FFA9 = Field<9, 1>;    // Filter FIFO assignment for filter 9
            using FFA10 = Field<10, 1>;    // Filter FIFO assignment for filter 10
            using FFA11 = Field<11, 1>;    // Filter FIFO assignment for filter 11
            using FFA12 = Field<12, 1>;    // Filter FIFO assignment for filter 12
            using FFA13 = Field<13, 1>;    // Filter FIFO assignment for filter 13
            using FFA14 = Field<14, 1>;    // Filter FIFO assignment for filter 14
            using FFA15 = Field<15, 1>;    // Filter FIFO assignment for filter 15
            using FFA16 = Field<16, 1>;    // Filter FIFO assignment for filter 16
            using FFA17 = Field<17, 1>;    // Filter FIFO assignment for filter 17
            using FFA18 = Field<18, 1>;    // Filter FIFO assignment for filter 18
            using FFA19 = Field<19, 1>;    // Filter FIFO assignment for filter 19
            using FFA20 = Field<20, 1>;    // Filter FIFO assignment for filter 20
            using FFA21 = Field<21, 1>;    // Filter FIFO assignment for filter 21
            using FFA22 = Field<22, 1>;    // Filter FIFO assignment for filter 22
            using FFA23 = Field<23, 1>;    // Filter FIFO assignment for filter 23
            using FFA24 = Field<24, 1>;    // Filter FIFO assignment for filter 24
            using FFA25 = Field<25, 1>;    // Filter FIFO assignment for filter 25
            using FFA26 = Field<26, 1>;    // Filter FIFO assignment for filter 26
            using FFA27 = Field<27, 1>;    // Filter FIFO assignment for filter 27
        };

        // filter activation register
        struct FA1R : public Register<0x40006a1c> {
            using FACT0 = Field<0, 1>;    // Filter active
            using FACT1 = Field<1, 1>;    // Filter active
            using FACT2 = Field<2, 1>;    // Filter active
            using FACT3 = Field<3, 1>;    // Filter active
            using FACT4 = Field<4, 1>;    // Filter active
            using FACT5 = Field<5, 1>;    // Filter active
            using FACT6 = Field<6, 1>;    // Filter active
            using FACT7 = Field<7, 1>;    // Filter active
            using FACT8 = Field<8, 1>;    // Filter active
            using FACT9 = Field<9, 1>;    // Filter active
            using FACT10 = Field<10, 1>;    // Filter active
            using FACT11 = Field<11, 1>;    // Filter active
            using FACT12 = Field<12, 1>;    // Filter active
            using FACT13 = Field<13, 1>;    // Filter active
            using FACT14 = Field<14, 1>;    // Filter active
            using FACT15 = Field<15, 1>;    // Filter active
            using FACT16 = Field<16, 1>;    // Filter active
            using FACT17 = Field<17, 1>;    // Filter active
            using FACT18 = Field<18, 1>;    // Filter active
            using FACT19 = Field<19, 1>;    // Filter active
            using FACT20 = Field<20, 1>;    // Filter active
            using FACT21 = Field<21, 1>;    // Filter active
            using FACT22 = Field<22, 1>;    // Filter active
            using FACT23 = Field<23, 1>;    // Filter active
            using FACT24 = Field<24, 1>;    // Filter active
            using FACT25 = Field<25, 1>;    // Filter active
            using FACT26 = Field<26, 1>;    // Filter active
            using FACT27 = Field<27, 1>;    // Filter active
        };

        // Filter bank 0 register 1
        struct F0R1 : public Register<0x40006a40> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 0 register 2
        struct F0R2 : public Register<0x40006a44> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 1 register 1
        struct F1R1 : public Register<0x40006a48> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 1 register 2
        struct F1R2 : public Register<0x40006a4c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 2 register 1
        struct F2R1 : public Register<0x40006a50> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 2 register 2
        struct F2R2 : public Register<0x40006a54> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 3 register 1
        struct F3R1 : public Register<0x40006a58> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 3 register 2
        struct F3R2 : public Register<0x40006a5c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 4 register 1
        struct F4R1 : public Register<0x40006a60> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 4 register 2
        struct F4R2 : public Register<0x40006a64> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 5 register 1
        struct F5R1 : public Register<0x40006a68> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 5 register 2
        struct F5R2 : public Register<0x40006a6c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 6 register 1
        struct F6R1 : public Register<0x40006a70> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 6 register 2
        struct F6R2 : public Register<0x40006a74> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 7 register 1
        struct F7R1 : public Register<0x40006a78> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 7 register 2
        struct F7R2 : public Register<0x40006a7c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 8 register 1
        struct F8R1 : public Register<0x40006a80> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 8 register 2
        struct F8R2 : public Register<0x40006a84> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 9 register 1
        struct F9R1 : public Register<0x40006a88> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 9 register 2
        struct F9R2 : public Register<0x40006a8c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 10 register 1
        struct F10R1 : public Register<0x40006a90> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 10 register 2
        struct F10R2 : public Register<0x40006a94> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 11 register 1
        struct F11R1 : public Register<0x40006a98> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 11 register 2
        struct F11R2 : public Register<0x40006a9c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 4 register 1
        struct F12R1 : public Register<0x40006aa0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 12 register 2
        struct F12R2 : public Register<0x40006aa4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 13 register 1
        struct F13R1 : public Register<0x40006aa8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 13 register 2
        struct F13R2 : public Register<0x40006aac> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 14 register 1
        struct F14R1 : public Register<0x40006ab0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 14 register 2
        struct F14R2 : public Register<0x40006ab4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 15 register 1
        struct F15R1 : public Register<0x40006ab8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 15 register 2
        struct F15R2 : public Register<0x40006abc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 16 register 1
        struct F16R1 : public Register<0x40006ac0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 16 register 2
        struct F16R2 : public Register<0x40006ac4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 17 register 1
        struct F17R1 : public Register<0x40006ac8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 17 register 2
        struct F17R2 : public Register<0x40006acc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 18 register 1
        struct F18R1 : public Register<0x40006ad0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 18 register 2
        struct F18R2 : public Register<0x40006ad4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 19 register 1
        struct F19R1 : public Register<0x40006ad8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 19 register 2
        struct F19R2 : public Register<0x40006adc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 20 register 1
        struct F20R1 : public Register<0x40006ae0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 20 register 2
        struct F20R2 : public Register<0x40006ae4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 21 register 1
        struct F21R1 : public Register<0x40006ae8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 21 register 2
        struct F21R2 : public Register<0x40006aec> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 22 register 1
        struct F22R1 : public Register<0x40006af0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 22 register 2
        struct F22R2 : public Register<0x40006af4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 23 register 1
        struct F23R1 : public Register<0x40006af8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 23 register 2
        struct F23R2 : public Register<0x40006afc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 24 register 1
        struct F24R1 : public Register<0x40006b00> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 24 register 2
        struct F24R2 : public Register<0x40006b04> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 25 register 1
        struct F25R1 : public Register<0x40006b08> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 25 register 2
        struct F25R2 : public Register<0x40006b0c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 26 register 1
        struct F26R1 : public Register<0x40006b10> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 26 register 2
        struct F26R2 : public Register<0x40006b14> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 27 register 1
        struct F27R1 : public Register<0x40006b18> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 27 register 2
        struct F27R2 : public Register<0x40006b1c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

    };

    // Controller area network
    struct CAN3 {
        // master control register
        struct MCR : public Register<0x40003400> {
            using DBF = Field<16, 1>;    // DBF
            using RESET = Field<15, 1>;    // RESET
            using TTCM = Field<7, 1>;    // TTCM
            using ABOM = Field<6, 1>;    // ABOM
            using AWUM = Field<5, 1>;    // AWUM
            using NART = Field<4, 1>;    // NART
            using RFLM = Field<3, 1>;    // RFLM
            using TXFP = Field<2, 1>;    // TXFP
            using SLEEP = Field<1, 1>;    // SLEEP
            using INRQ = Field<0, 1>;    // INRQ
        };

        // master status register
        struct MSR : public Register<0x40003404> {
            using RX = Field<11, 1>;    // RX
            using SAMP = Field<10, 1>;    // SAMP
            using RXM = Field<9, 1>;    // RXM
            using TXM = Field<8, 1>;    // TXM
            using SLAKI = Field<4, 1>;    // SLAKI
            using WKUI = Field<3, 1>;    // WKUI
            using ERRI = Field<2, 1>;    // ERRI
            using SLAK = Field<1, 1>;    // SLAK
            using INAK = Field<0, 1>;    // INAK
        };

        // transmit status register
        struct TSR : public Register<0x40003408> {
            using LOW2 = Field<31, 1>;    // Lowest priority flag for mailbox 2
            using LOW1 = Field<30, 1>;    // Lowest priority flag for mailbox 1
            using LOW0 = Field<29, 1>;    // Lowest priority flag for mailbox 0
            using TME2 = Field<28, 1>;    // Lowest priority flag for mailbox 2
            using TME1 = Field<27, 1>;    // Lowest priority flag for mailbox 1
            using TME0 = Field<26, 1>;    // Lowest priority flag for mailbox 0
            using CODE = Field<24, 2>;    // CODE
            using ABRQ2 = Field<23, 1>;    // ABRQ2
            using TERR2 = Field<19, 1>;    // TERR2
            using ALST2 = Field<18, 1>;    // ALST2
            using TXOK2 = Field<17, 1>;    // TXOK2
            using RQCP2 = Field<16, 1>;    // RQCP2
            using ABRQ1 = Field<15, 1>;    // ABRQ1
            using TERR1 = Field<11, 1>;    // TERR1
            using ALST1 = Field<10, 1>;    // ALST1
            using TXOK1 = Field<9, 1>;    // TXOK1
            using RQCP1 = Field<8, 1>;    // RQCP1
            using ABRQ0 = Field<7, 1>;    // ABRQ0
            using TERR0 = Field<3, 1>;    // TERR0
            using ALST0 = Field<2, 1>;    // ALST0
            using TXOK0 = Field<1, 1>;    // TXOK0
            using RQCP0 = Field<0, 1>;    // RQCP0
        };

        // receive FIFO 0 register
        struct RF0R : public Register<0x4000340c> {
            using RFOM0 = Field<5, 1>;    // RFOM0
            using FOVR0 = Field<4, 1>;    // FOVR0
            using FULL0 = Field<3, 1>;    // FULL0
            using FMP0 = Field<0, 2>;    // FMP0
        };

        // receive FIFO 1 register
        struct RF1R : public Register<0x40003410> {
            using RFOM1 = Field<5, 1>;    // RFOM1
            using FOVR1 = Field<4, 1>;    // FOVR1
            using FULL1 = Field<3, 1>;    // FULL1
            using FMP1 = Field<0, 2>;    // FMP1
        };

        // interrupt enable register
        struct IER : public Register<0x40003414> {
            using SLKIE = Field<17, 1>;    // SLKIE
            using WKUIE = Field<16, 1>;    // WKUIE
            using ERRIE = Field<15, 1>;    // ERRIE
            using LECIE = Field<11, 1>;    // LECIE
            using BOFIE = Field<10, 1>;    // BOFIE
            using EPVIE = Field<9, 1>;    // EPVIE
            using EWGIE = Field<8, 1>;    // EWGIE
            using FOVIE1 = Field<6, 1>;    // FOVIE1
            using FFIE1 = Field<5, 1>;    // FFIE1
            using FMPIE1 = Field<4, 1>;    // FMPIE1
            using FOVIE0 = Field<3, 1>;    // FOVIE0
            using FFIE0 = Field<2, 1>;    // FFIE0
            using FMPIE0 = Field<1, 1>;    // FMPIE0
            using TMEIE = Field<0, 1>;    // TMEIE
        };

        // interrupt enable register
        struct ESR : public Register<0x40003418> {
            using REC = Field<24, 8>;    // REC
            using TEC = Field<16, 8>;    // TEC
            using LEC = Field<4, 3>;    // LEC
            using BOFF = Field<2, 1>;    // BOFF
            using EPVF = Field<1, 1>;    // EPVF
            using EWGF = Field<0, 1>;    // EWGF
        };

        // bit timing register
        struct BTR : public Register<0x4000341c> {
            using SILM = Field<31, 1>;    // SILM
            using LBKM = Field<30, 1>;    // LBKM
            using SJW = Field<24, 2>;    // SJW
            using TS2 = Field<20, 3>;    // TS2
            using TS1 = Field<16, 4>;    // TS1
            using BRP = Field<0, 10>;    // BRP
        };

        // TX mailbox identifier register
        struct TI0R : public Register<0x40003580> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
            using TXRQ = Field<0, 1>;    // TXRQ
        };

        // mailbox data length control and time stamp register
        struct TDT0R : public Register<0x40003584> {
            using TIME = Field<16, 16>;    // TIME
            using TGT = Field<8, 1>;    // TGT
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data low register
        struct TDL0R : public Register<0x40003588> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct TDH0R : public Register<0x4000358c> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // mailbox identifier register
        struct TI1R : public Register<0x40003590> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
            using TXRQ = Field<0, 1>;    // TXRQ
        };

        // mailbox data length control and time stamp register
        struct TDT1R : public Register<0x40003594> {
            using TIME = Field<16, 16>;    // TIME
            using TGT = Field<8, 1>;    // TGT
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data low register
        struct TDL1R : public Register<0x40003598> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct TDH1R : public Register<0x4000359c> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // mailbox identifier register
        struct TI2R : public Register<0x400035a0> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
            using TXRQ = Field<0, 1>;    // TXRQ
        };

        // mailbox data length control and time stamp register
        struct TDT2R : public Register<0x400035a4> {
            using TIME = Field<16, 16>;    // TIME
            using TGT = Field<8, 1>;    // TGT
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data low register
        struct TDL2R : public Register<0x400035a8> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct TDH2R : public Register<0x400035ac> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // receive FIFO mailbox identifier register
        struct RI0R : public RegisterReadOnly<0x400035b0> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
        };

        // mailbox data high register
        struct RDT0R : public RegisterReadOnly<0x400035b4> {
            using TIME = Field<16, 16>;    // TIME
            using FMI = Field<8, 8>;    // FMI
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data high register
        struct RDL0R : public RegisterReadOnly<0x400035b8> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // receive FIFO mailbox data high register
        struct RDH0R : public RegisterReadOnly<0x400035bc> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // mailbox data high register
        struct RI1R : public RegisterReadOnly<0x400035c0> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
        };

        // mailbox data high register
        struct RDT1R : public RegisterReadOnly<0x400035c4> {
            using TIME = Field<16, 16>;    // TIME
            using FMI = Field<8, 8>;    // FMI
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data high register
        struct RDL1R : public RegisterReadOnly<0x400035c8> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct RDH1R : public RegisterReadOnly<0x400035cc> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // filter master register
        struct FMR : public Register<0x40003600> {
            using CAN2SB = Field<8, 6>;    // CAN2SB
            using FINIT = Field<0, 1>;    // FINIT
        };

        // filter mode register
        struct FM1R : public Register<0x40003604> {
            using FBM0 = Field<0, 1>;    // Filter mode
            using FBM1 = Field<1, 1>;    // Filter mode
            using FBM2 = Field<2, 1>;    // Filter mode
            using FBM3 = Field<3, 1>;    // Filter mode
            using FBM4 = Field<4, 1>;    // Filter mode
            using FBM5 = Field<5, 1>;    // Filter mode
            using FBM6 = Field<6, 1>;    // Filter mode
            using FBM7 = Field<7, 1>;    // Filter mode
            using FBM8 = Field<8, 1>;    // Filter mode
            using FBM9 = Field<9, 1>;    // Filter mode
            using FBM10 = Field<10, 1>;    // Filter mode
            using FBM11 = Field<11, 1>;    // Filter mode
            using FBM12 = Field<12, 1>;    // Filter mode
            using FBM13 = Field<13, 1>;    // Filter mode
            using FBM14 = Field<14, 1>;    // Filter mode
            using FBM15 = Field<15, 1>;    // Filter mode
            using FBM16 = Field<16, 1>;    // Filter mode
            using FBM17 = Field<17, 1>;    // Filter mode
            using FBM18 = Field<18, 1>;    // Filter mode
            using FBM19 = Field<19, 1>;    // Filter mode
            using FBM20 = Field<20, 1>;    // Filter mode
            using FBM21 = Field<21, 1>;    // Filter mode
            using FBM22 = Field<22, 1>;    // Filter mode
            using FBM23 = Field<23, 1>;    // Filter mode
            using FBM24 = Field<24, 1>;    // Filter mode
            using FBM25 = Field<25, 1>;    // Filter mode
            using FBM26 = Field<26, 1>;    // Filter mode
            using FBM27 = Field<27, 1>;    // Filter mode
        };

        // filter scale register
        struct FS1R : public Register<0x4000360c> {
            using FSC0 = Field<0, 1>;    // Filter scale configuration
            using FSC1 = Field<1, 1>;    // Filter scale configuration
            using FSC2 = Field<2, 1>;    // Filter scale configuration
            using FSC3 = Field<3, 1>;    // Filter scale configuration
            using FSC4 = Field<4, 1>;    // Filter scale configuration
            using FSC5 = Field<5, 1>;    // Filter scale configuration
            using FSC6 = Field<6, 1>;    // Filter scale configuration
            using FSC7 = Field<7, 1>;    // Filter scale configuration
            using FSC8 = Field<8, 1>;    // Filter scale configuration
            using FSC9 = Field<9, 1>;    // Filter scale configuration
            using FSC10 = Field<10, 1>;    // Filter scale configuration
            using FSC11 = Field<11, 1>;    // Filter scale configuration
            using FSC12 = Field<12, 1>;    // Filter scale configuration
            using FSC13 = Field<13, 1>;    // Filter scale configuration
            using FSC14 = Field<14, 1>;    // Filter scale configuration
            using FSC15 = Field<15, 1>;    // Filter scale configuration
            using FSC16 = Field<16, 1>;    // Filter scale configuration
            using FSC17 = Field<17, 1>;    // Filter scale configuration
            using FSC18 = Field<18, 1>;    // Filter scale configuration
            using FSC19 = Field<19, 1>;    // Filter scale configuration
            using FSC20 = Field<20, 1>;    // Filter scale configuration
            using FSC21 = Field<21, 1>;    // Filter scale configuration
            using FSC22 = Field<22, 1>;    // Filter scale configuration
            using FSC23 = Field<23, 1>;    // Filter scale configuration
            using FSC24 = Field<24, 1>;    // Filter scale configuration
            using FSC25 = Field<25, 1>;    // Filter scale configuration
            using FSC26 = Field<26, 1>;    // Filter scale configuration
            using FSC27 = Field<27, 1>;    // Filter scale configuration
        };

        // filter FIFO assignment register
        struct FFA1R : public Register<0x40003614> {
            using FFA0 = Field<0, 1>;    // Filter FIFO assignment for filter 0
            using FFA1 = Field<1, 1>;    // Filter FIFO assignment for filter 1
            using FFA2 = Field<2, 1>;    // Filter FIFO assignment for filter 2
            using FFA3 = Field<3, 1>;    // Filter FIFO assignment for filter 3
            using FFA4 = Field<4, 1>;    // Filter FIFO assignment for filter 4
            using FFA5 = Field<5, 1>;    // Filter FIFO assignment for filter 5
            using FFA6 = Field<6, 1>;    // Filter FIFO assignment for filter 6
            using FFA7 = Field<7, 1>;    // Filter FIFO assignment for filter 7
            using FFA8 = Field<8, 1>;    // Filter FIFO assignment for filter 8
            using FFA9 = Field<9, 1>;    // Filter FIFO assignment for filter 9
            using FFA10 = Field<10, 1>;    // Filter FIFO assignment for filter 10
            using FFA11 = Field<11, 1>;    // Filter FIFO assignment for filter 11
            using FFA12 = Field<12, 1>;    // Filter FIFO assignment for filter 12
            using FFA13 = Field<13, 1>;    // Filter FIFO assignment for filter 13
            using FFA14 = Field<14, 1>;    // Filter FIFO assignment for filter 14
            using FFA15 = Field<15, 1>;    // Filter FIFO assignment for filter 15
            using FFA16 = Field<16, 1>;    // Filter FIFO assignment for filter 16
            using FFA17 = Field<17, 1>;    // Filter FIFO assignment for filter 17
            using FFA18 = Field<18, 1>;    // Filter FIFO assignment for filter 18
            using FFA19 = Field<19, 1>;    // Filter FIFO assignment for filter 19
            using FFA20 = Field<20, 1>;    // Filter FIFO assignment for filter 20
            using FFA21 = Field<21, 1>;    // Filter FIFO assignment for filter 21
            using FFA22 = Field<22, 1>;    // Filter FIFO assignment for filter 22
            using FFA23 = Field<23, 1>;    // Filter FIFO assignment for filter 23
            using FFA24 = Field<24, 1>;    // Filter FIFO assignment for filter 24
            using FFA25 = Field<25, 1>;    // Filter FIFO assignment for filter 25
            using FFA26 = Field<26, 1>;    // Filter FIFO assignment for filter 26
            using FFA27 = Field<27, 1>;    // Filter FIFO assignment for filter 27
        };

        // filter activation register
        struct FA1R : public Register<0x4000361c> {
            using FACT0 = Field<0, 1>;    // Filter active
            using FACT1 = Field<1, 1>;    // Filter active
            using FACT2 = Field<2, 1>;    // Filter active
            using FACT3 = Field<3, 1>;    // Filter active
            using FACT4 = Field<4, 1>;    // Filter active
            using FACT5 = Field<5, 1>;    // Filter active
            using FACT6 = Field<6, 1>;    // Filter active
            using FACT7 = Field<7, 1>;    // Filter active
            using FACT8 = Field<8, 1>;    // Filter active
            using FACT9 = Field<9, 1>;    // Filter active
            using FACT10 = Field<10, 1>;    // Filter active
            using FACT11 = Field<11, 1>;    // Filter active
            using FACT12 = Field<12, 1>;    // Filter active
            using FACT13 = Field<13, 1>;    // Filter active
            using FACT14 = Field<14, 1>;    // Filter active
            using FACT15 = Field<15, 1>;    // Filter active
            using FACT16 = Field<16, 1>;    // Filter active
            using FACT17 = Field<17, 1>;    // Filter active
            using FACT18 = Field<18, 1>;    // Filter active
            using FACT19 = Field<19, 1>;    // Filter active
            using FACT20 = Field<20, 1>;    // Filter active
            using FACT21 = Field<21, 1>;    // Filter active
            using FACT22 = Field<22, 1>;    // Filter active
            using FACT23 = Field<23, 1>;    // Filter active
            using FACT24 = Field<24, 1>;    // Filter active
            using FACT25 = Field<25, 1>;    // Filter active
            using FACT26 = Field<26, 1>;    // Filter active
            using FACT27 = Field<27, 1>;    // Filter active
        };

        // Filter bank 0 register 1
        struct F0R1 : public Register<0x40003640> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 0 register 2
        struct F0R2 : public Register<0x40003644> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 1 register 1
        struct F1R1 : public Register<0x40003648> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 1 register 2
        struct F1R2 : public Register<0x4000364c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 2 register 1
        struct F2R1 : public Register<0x40003650> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 2 register 2
        struct F2R2 : public Register<0x40003654> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 3 register 1
        struct F3R1 : public Register<0x40003658> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 3 register 2
        struct F3R2 : public Register<0x4000365c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 4 register 1
        struct F4R1 : public Register<0x40003660> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 4 register 2
        struct F4R2 : public Register<0x40003664> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 5 register 1
        struct F5R1 : public Register<0x40003668> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 5 register 2
        struct F5R2 : public Register<0x4000366c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 6 register 1
        struct F6R1 : public Register<0x40003670> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 6 register 2
        struct F6R2 : public Register<0x40003674> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 7 register 1
        struct F7R1 : public Register<0x40003678> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 7 register 2
        struct F7R2 : public Register<0x4000367c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 8 register 1
        struct F8R1 : public Register<0x40003680> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 8 register 2
        struct F8R2 : public Register<0x40003684> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 9 register 1
        struct F9R1 : public Register<0x40003688> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 9 register 2
        struct F9R2 : public Register<0x4000368c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 10 register 1
        struct F10R1 : public Register<0x40003690> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 10 register 2
        struct F10R2 : public Register<0x40003694> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 11 register 1
        struct F11R1 : public Register<0x40003698> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 11 register 2
        struct F11R2 : public Register<0x4000369c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 4 register 1
        struct F12R1 : public Register<0x400036a0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 12 register 2
        struct F12R2 : public Register<0x400036a4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 13 register 1
        struct F13R1 : public Register<0x400036a8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 13 register 2
        struct F13R2 : public Register<0x400036ac> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 14 register 1
        struct F14R1 : public Register<0x400036b0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 14 register 2
        struct F14R2 : public Register<0x400036b4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 15 register 1
        struct F15R1 : public Register<0x400036b8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 15 register 2
        struct F15R2 : public Register<0x400036bc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 16 register 1
        struct F16R1 : public Register<0x400036c0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 16 register 2
        struct F16R2 : public Register<0x400036c4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 17 register 1
        struct F17R1 : public Register<0x400036c8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 17 register 2
        struct F17R2 : public Register<0x400036cc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 18 register 1
        struct F18R1 : public Register<0x400036d0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 18 register 2
        struct F18R2 : public Register<0x400036d4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 19 register 1
        struct F19R1 : public Register<0x400036d8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 19 register 2
        struct F19R2 : public Register<0x400036dc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 20 register 1
        struct F20R1 : public Register<0x400036e0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 20 register 2
        struct F20R2 : public Register<0x400036e4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 21 register 1
        struct F21R1 : public Register<0x400036e8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 21 register 2
        struct F21R2 : public Register<0x400036ec> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 22 register 1
        struct F22R1 : public Register<0x400036f0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 22 register 2
        struct F22R2 : public Register<0x400036f4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 23 register 1
        struct F23R1 : public Register<0x400036f8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 23 register 2
        struct F23R2 : public Register<0x400036fc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 24 register 1
        struct F24R1 : public Register<0x40003700> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 24 register 2
        struct F24R2 : public Register<0x40003704> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 25 register 1
        struct F25R1 : public Register<0x40003708> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 25 register 2
        struct F25R2 : public Register<0x4000370c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 26 register 1
        struct F26R1 : public Register<0x40003710> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 26 register 2
        struct F26R2 : public Register<0x40003714> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 27 register 1
        struct F27R1 : public Register<0x40003718> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 27 register 2
        struct F27R2 : public Register<0x4000371c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

    };

    // FLASH
    struct Flash {
        // Flash access control register
        struct ACR : public Register<0x40023c00> {
            using LATENCY = Field<0, 4>;    // Latency
            using PRFTEN = Field<8, 1>;    // Prefetch enable
            using ARTEN = Field<9, 1>;    // ART Accelerator Enable
            using ARTRST = Field<11, 1>;    // ART Accelerator reset
        };

        // Flash key register
        struct KEYR : public RegisterWriteOnly<0x40023c04> {
            using KEY = Field<0, 32>;    // FPEC key
        };

        // Flash option key register
        struct OPTKEYR : public RegisterWriteOnly<0x40023c08> {
            using OPTKEY = Field<0, 32>;    // Option byte key
        };

        // Status register
        struct SR : public Register<0x40023c0c> {
            using EOP = Field<0, 1>;    // End of operation
            using OPERR = Field<1, 1>;    // Operation error
            using WRPERR = Field<4, 1>;    // Write protection error
            using PGAERR = Field<5, 1>;    // Programming alignment error
            using PGPERR = Field<6, 1>;    // Programming parallelism error
            using ERSERR = Field<7, 1>;    // Programming sequence error
            using BSY = Field<16, 1>;    // Busy
        };

        // Control register
        struct CR : public Register<0x40023c10> {
            using PG = Field<0, 1>;    // Programming
            using SER = Field<1, 1>;    // Sector Erase
            using MER1 = Field<2, 1>;    // Mass Erase of sectors 0 to 11
            using SNB = Field<3, 5>;    // Sector number
            using PSIZE = Field<8, 2>;    // Program size
            using MER2 = Field<15, 1>;    // Mass Erase of sectors 12 to 23
            using STRT = Field<16, 1>;    // Start
            using EOPIE = Field<24, 1>;    // End of operation interrupt enable
            using ERRIE = Field<25, 1>;    // Error interrupt enable
            using LOCK = Field<31, 1>;    // Lock
        };

        // Flash option control register
        struct OPTCR : public Register<0x40023c14> {
            using OPTLOCK = Field<0, 1>;    // Option lock
            using OPTSTRT = Field<1, 1>;    // Option start
            using BOR_LEV = Field<2, 2>;    // BOR reset Level
            using WWDG_SW = Field<4, 1>;    // User option bytes
            using IWDG_SW = Field<5, 1>;    // User option bytes
            using nRST_STOP = Field<6, 1>;    // User option bytes
            using nRST_STDBY = Field<7, 1>;    // User option bytes
            using RDP = Field<8, 8>;    // Read protect
            using nWRP = Field<16, 12>;    // Not write protect
            using nDBOOT = Field<28, 1>;    // Dual Boot mode (valid only when nDBANK=0)
            using nDBANK = Field<29, 1>;    // Not dual bank mode
            using IWDG_STDBY = Field<30, 1>;    // Independent watchdog counter freeze in standby mode
            using IWDG_STOP = Field<31, 1>;    // Independent watchdog counter freeze in Stop mode
        };

        // Flash option control register 1
        struct OPTCR1 : public Register<0x40023c18> {
            using BOOT_ADD0 = Field<0, 16>;    // Boot base address when Boot pin =0
            using BOOT_ADD1 = Field<16, 16>;    // Boot base address when Boot pin =1
        };

    };

    // External interrupt/event controller
    struct EXTI {
        // Interrupt mask register (EXTI_IMR)
        struct IMR : public Register<0x40013c00> {
            using MR0 = Field<0, 1>;    // Interrupt Mask on line 0
            using MR1 = Field<1, 1>;    // Interrupt Mask on line 1
            using MR2 = Field<2, 1>;    // Interrupt Mask on line 2
            using MR3 = Field<3, 1>;    // Interrupt Mask on line 3
            using MR4 = Field<4, 1>;    // Interrupt Mask on line 4
            using MR5 = Field<5, 1>;    // Interrupt Mask on line 5
            using MR6 = Field<6, 1>;    // Interrupt Mask on line 6
            using MR7 = Field<7, 1>;    // Interrupt Mask on line 7
            using MR8 = Field<8, 1>;    // Interrupt Mask on line 8
            using MR9 = Field<9, 1>;    // Interrupt Mask on line 9
            using MR10 = Field<10, 1>;    // Interrupt Mask on line 10
            using MR11 = Field<11, 1>;    // Interrupt Mask on line 11
            using MR12 = Field<12, 1>;    // Interrupt Mask on line 12
            using MR13 = Field<13, 1>;    // Interrupt Mask on line 13
            using MR14 = Field<14, 1>;    // Interrupt Mask on line 14
            using MR15 = Field<15, 1>;    // Interrupt Mask on line 15
            using MR16 = Field<16, 1>;    // Interrupt Mask on line 16
            using MR17 = Field<17, 1>;    // Interrupt Mask on line 17
            using MR18 = Field<18, 1>;    // Interrupt Mask on line 18
            using MR19 = Field<19, 1>;    // Interrupt Mask on line 19
            using MR20 = Field<20, 1>;    // Interrupt Mask on line 20
            using MR21 = Field<21, 1>;    // Interrupt Mask on line 21
            using MR22 = Field<22, 1>;    // Interrupt Mask on line 22
        };

        // Event mask register (EXTI_EMR)
        struct EMR : public Register<0x40013c04> {
            using MR0 = Field<0, 1>;    // Event Mask on line 0
            using MR1 = Field<1, 1>;    // Event Mask on line 1
            using MR2 = Field<2, 1>;    // Event Mask on line 2
            using MR3 = Field<3, 1>;    // Event Mask on line 3
            using MR4 = Field<4, 1>;    // Event Mask on line 4
            using MR5 = Field<5, 1>;    // Event Mask on line 5
            using MR6 = Field<6, 1>;    // Event Mask on line 6
            using MR7 = Field<7, 1>;    // Event Mask on line 7
            using MR8 = Field<8, 1>;    // Event Mask on line 8
            using MR9 = Field<9, 1>;    // Event Mask on line 9
            using MR10 = Field<10, 1>;    // Event Mask on line 10
            using MR11 = Field<11, 1>;    // Event Mask on line 11
            using MR12 = Field<12, 1>;    // Event Mask on line 12
            using MR13 = Field<13, 1>;    // Event Mask on line 13
            using MR14 = Field<14, 1>;    // Event Mask on line 14
            using MR15 = Field<15, 1>;    // Event Mask on line 15
            using MR16 = Field<16, 1>;    // Event Mask on line 16
            using MR17 = Field<17, 1>;    // Event Mask on line 17
            using MR18 = Field<18, 1>;    // Event Mask on line 18
            using MR19 = Field<19, 1>;    // Event Mask on line 19
            using MR20 = Field<20, 1>;    // Event Mask on line 20
            using MR21 = Field<21, 1>;    // Event Mask on line 21
            using MR22 = Field<22, 1>;    // Event Mask on line 22
        };

        // Rising Trigger selection register (EXTI_RTSR)
        struct RTSR : public Register<0x40013c08> {
            using TR0 = Field<0, 1>;    // Rising trigger event configuration of line 0
            using TR1 = Field<1, 1>;    // Rising trigger event configuration of line 1
            using TR2 = Field<2, 1>;    // Rising trigger event configuration of line 2
            using TR3 = Field<3, 1>;    // Rising trigger event configuration of line 3
            using TR4 = Field<4, 1>;    // Rising trigger event configuration of line 4
            using TR5 = Field<5, 1>;    // Rising trigger event configuration of line 5
            using TR6 = Field<6, 1>;    // Rising trigger event configuration of line 6
            using TR7 = Field<7, 1>;    // Rising trigger event configuration of line 7
            using TR8 = Field<8, 1>;    // Rising trigger event configuration of line 8
            using TR9 = Field<9, 1>;    // Rising trigger event configuration of line 9
            using TR10 = Field<10, 1>;    // Rising trigger event configuration of line 10
            using TR11 = Field<11, 1>;    // Rising trigger event configuration of line 11
            using TR12 = Field<12, 1>;    // Rising trigger event configuration of line 12
            using TR13 = Field<13, 1>;    // Rising trigger event configuration of line 13
            using TR14 = Field<14, 1>;    // Rising trigger event configuration of line 14
            using TR15 = Field<15, 1>;    // Rising trigger event configuration of line 15
            using TR16 = Field<16, 1>;    // Rising trigger event configuration of line 16
            using TR17 = Field<17, 1>;    // Rising trigger event configuration of line 17
            using TR18 = Field<18, 1>;    // Rising trigger event configuration of line 18
            using TR19 = Field<19, 1>;    // Rising trigger event configuration of line 19
            using TR20 = Field<20, 1>;    // Rising trigger event configuration of line 20
            using TR21 = Field<21, 1>;    // Rising trigger event configuration of line 21
            using TR22 = Field<22, 1>;    // Rising trigger event configuration of line 22
        };

        // Falling Trigger selection register (EXTI_FTSR)
        struct FTSR : public Register<0x40013c0c> {
            using TR0 = Field<0, 1>;    // Falling trigger event configuration of line 0
            using TR1 = Field<1, 1>;    // Falling trigger event configuration of line 1
            using TR2 = Field<2, 1>;    // Falling trigger event configuration of line 2
            using TR3 = Field<3, 1>;    // Falling trigger event configuration of line 3
            using TR4 = Field<4, 1>;    // Falling trigger event configuration of line 4
            using TR5 = Field<5, 1>;    // Falling trigger event configuration of line 5
            using TR6 = Field<6, 1>;    // Falling trigger event configuration of line 6
            using TR7 = Field<7, 1>;    // Falling trigger event configuration of line 7
            using TR8 = Field<8, 1>;    // Falling trigger event configuration of line 8
            using TR9 = Field<9, 1>;    // Falling trigger event configuration of line 9
            using TR10 = Field<10, 1>;    // Falling trigger event configuration of line 10
            using TR11 = Field<11, 1>;    // Falling trigger event configuration of line 11
            using TR12 = Field<12, 1>;    // Falling trigger event configuration of line 12
            using TR13 = Field<13, 1>;    // Falling trigger event configuration of line 13
            using TR14 = Field<14, 1>;    // Falling trigger event configuration of line 14
            using TR15 = Field<15, 1>;    // Falling trigger event configuration of line 15
            using TR16 = Field<16, 1>;    // Falling trigger event configuration of line 16
            using TR17 = Field<17, 1>;    // Falling trigger event configuration of line 17
            using TR18 = Field<18, 1>;    // Falling trigger event configuration of line 18
            using TR19 = Field<19, 1>;    // Falling trigger event configuration of line 19
            using TR20 = Field<20, 1>;    // Falling trigger event configuration of line 20
            using TR21 = Field<21, 1>;    // Falling trigger event configuration of line 21
            using TR22 = Field<22, 1>;    // Falling trigger event configuration of line 22
        };

        // Software interrupt event register (EXTI_SWIER)
        struct SWIER : public Register<0x40013c10> {
            using SWIER0 = Field<0, 1>;    // Software Interrupt on line 0
            using SWIER1 = Field<1, 1>;    // Software Interrupt on line 1
            using SWIER2 = Field<2, 1>;    // Software Interrupt on line 2
            using SWIER3 = Field<3, 1>;    // Software Interrupt on line 3
            using SWIER4 = Field<4, 1>;    // Software Interrupt on line 4
            using SWIER5 = Field<5, 1>;    // Software Interrupt on line 5
            using SWIER6 = Field<6, 1>;    // Software Interrupt on line 6
            using SWIER7 = Field<7, 1>;    // Software Interrupt on line 7
            using SWIER8 = Field<8, 1>;    // Software Interrupt on line 8
            using SWIER9 = Field<9, 1>;    // Software Interrupt on line 9
            using SWIER10 = Field<10, 1>;    // Software Interrupt on line 10
            using SWIER11 = Field<11, 1>;    // Software Interrupt on line 11
            using SWIER12 = Field<12, 1>;    // Software Interrupt on line 12
            using SWIER13 = Field<13, 1>;    // Software Interrupt on line 13
            using SWIER14 = Field<14, 1>;    // Software Interrupt on line 14
            using SWIER15 = Field<15, 1>;    // Software Interrupt on line 15
            using SWIER16 = Field<16, 1>;    // Software Interrupt on line 16
            using SWIER17 = Field<17, 1>;    // Software Interrupt on line 17
            using SWIER18 = Field<18, 1>;    // Software Interrupt on line 18
            using SWIER19 = Field<19, 1>;    // Software Interrupt on line 19
            using SWIER20 = Field<20, 1>;    // Software Interrupt on line 20
            using SWIER21 = Field<21, 1>;    // Software Interrupt on line 21
            using SWIER22 = Field<22, 1>;    // Software Interrupt on line 22
        };

        // Pending register (EXTI_PR)
        struct PR : public Register<0x40013c14> {
            using PR0 = Field<0, 1>;    // Pending bit 0
            using PR1 = Field<1, 1>;    // Pending bit 1
            using PR2 = Field<2, 1>;    // Pending bit 2
            using PR3 = Field<3, 1>;    // Pending bit 3
            using PR4 = Field<4, 1>;    // Pending bit 4
            using PR5 = Field<5, 1>;    // Pending bit 5
            using PR6 = Field<6, 1>;    // Pending bit 6
            using PR7 = Field<7, 1>;    // Pending bit 7
            using PR8 = Field<8, 1>;    // Pending bit 8
            using PR9 = Field<9, 1>;    // Pending bit 9
            using PR10 = Field<10, 1>;    // Pending bit 10
            using PR11 = Field<11, 1>;    // Pending bit 11
            using PR12 = Field<12, 1>;    // Pending bit 12
            using PR13 = Field<13, 1>;    // Pending bit 13
            using PR14 = Field<14, 1>;    // Pending bit 14
            using PR15 = Field<15, 1>;    // Pending bit 15
            using PR16 = Field<16, 1>;    // Pending bit 16
            using PR17 = Field<17, 1>;    // Pending bit 17
            using PR18 = Field<18, 1>;    // Pending bit 18
            using PR19 = Field<19, 1>;    // Pending bit 19
            using PR20 = Field<20, 1>;    // Pending bit 20
            using PR21 = Field<21, 1>;    // Pending bit 21
            using PR22 = Field<22, 1>;    // Pending bit 22
        };

    };

    // LCD-TFT Controller
    struct LTDC {
        // Synchronization Size Configuration Register
        struct SSCR : public Register<0x40016808> {
            using HSW = Field<16, 10>;    // Horizontal Synchronization Width (in units of pixel clock period)
            using VSH = Field<0, 11>;    // Vertical Synchronization Height (in units of horizontal scan line)
        };

        // Back Porch Configuration Register
        struct BPCR : public Register<0x4001680c> {
            using AHBP = Field<16, 10>;    // Accumulated Horizontal back porch (in units of pixel clock period)
            using AVBP = Field<0, 11>;    // Accumulated Vertical back porch (in units of horizontal scan line)
        };

        // Active Width Configuration Register
        struct AWCR : public Register<0x40016810> {
            using AAV = Field<16, 10>;    // AAV
            using AAH = Field<0, 11>;    // Accumulated Active Height (in units of horizontal scan line)
        };

        // Total Width Configuration Register
        struct TWCR : public Register<0x40016814> {
            using TOTALW = Field<16, 10>;    // Total Width (in units of pixel clock period)
            using TOTALH = Field<0, 11>;    // Total Height (in units of horizontal scan line)
        };

        // Global Control Register
        struct GCR : public Register<0x40016818> {
            using HSPOL = Field<31, 1>;    // Horizontal Synchronization Polarity
            using VSPOL = Field<30, 1>;    // Vertical Synchronization Polarity
            using DEPOL = Field<29, 1>;    // Data Enable Polarity
            using PCPOL = Field<28, 1>;    // Pixel Clock Polarity
            using DEN = Field<16, 1>;    // Dither Enable
            using DRW = Field<12, 3>;    // Dither Red Width
            using DGW = Field<8, 3>;    // Dither Green Width
            using DBW = Field<4, 3>;    // Dither Blue Width
            using LTDCEN = Field<0, 1>;    // LCD-TFT controller enable bit
        };

        // Shadow Reload Configuration Register
        struct SRCR : public Register<0x40016824> {
            using VBR = Field<1, 1>;    // Vertical Blanking Reload
            using IMR = Field<0, 1>;    // Immediate Reload
        };

        // Background Color Configuration Register
        struct BCCR : public Register<0x4001682c> {
            using BC = Field<0, 24>;    // Background Color Red value
        };

        // Interrupt Enable Register
        struct IER : public Register<0x40016834> {
            using RRIE = Field<3, 1>;    // Register Reload interrupt enable
            using TERRIE = Field<2, 1>;    // Transfer Error Interrupt Enable
            using FUIE = Field<1, 1>;    // FIFO Underrun Interrupt Enable
            using LIE = Field<0, 1>;    // Line Interrupt Enable
        };

        // Interrupt Status Register
        struct ISR : public RegisterReadOnly<0x40016838> {
            using RRIF = Field<3, 1>;    // Register Reload Interrupt Flag
            using TERRIF = Field<2, 1>;    // Transfer Error interrupt flag
            using FUIF = Field<1, 1>;    // FIFO Underrun Interrupt flag
            using LIF = Field<0, 1>;    // Line Interrupt flag
        };

        // Interrupt Clear Register
        struct ICR : public RegisterWriteOnly<0x4001683c> {
            using CRRIF = Field<3, 1>;    // Clears Register Reload Interrupt Flag
            using CTERRIF = Field<2, 1>;    // Clears the Transfer Error Interrupt Flag
            using CFUIF = Field<1, 1>;    // Clears the FIFO Underrun Interrupt flag
            using CLIF = Field<0, 1>;    // Clears the Line Interrupt Flag
        };

        // Line Interrupt Position Configuration Register
        struct LIPCR : public Register<0x40016840> {
            using LIPOS = Field<0, 11>;    // Line Interrupt Position
        };

        // Current Position Status Register
        struct CPSR : public RegisterReadOnly<0x40016844> {
            using CXPOS = Field<16, 16>;    // Current X Position
            using CYPOS = Field<0, 16>;    // Current Y Position
        };

        // Current Display Status Register
        struct CDSR : public RegisterReadOnly<0x40016848> {
            using HSYNCS = Field<3, 1>;    // Horizontal Synchronization display Status
            using VSYNCS = Field<2, 1>;    // Vertical Synchronization display Status
            using HDES = Field<1, 1>;    // Horizontal Data Enable display Status
            using VDES = Field<0, 1>;    // Vertical Data Enable display Status
        };

        // Layerx Control Register
        struct L1CR : public Register<0x40016884> {
            using CLUTEN = Field<4, 1>;    // Color Look-Up Table Enable
            using COLKEN = Field<1, 1>;    // Color Keying Enable
            using LEN = Field<0, 1>;    // Layer Enable
        };

        // Layerx Window Horizontal Position Configuration Register
        struct L1WHPCR : public Register<0x40016888> {
            using WHSPPOS = Field<16, 12>;    // Window Horizontal Stop Position
            using WHSTPOS = Field<0, 12>;    // Window Horizontal Start Position
        };

        // Layerx Window Vertical Position Configuration Register
        struct L1WVPCR : public Register<0x4001688c> {
            using WVSPPOS = Field<16, 11>;    // Window Vertical Stop Position
            using WVSTPOS = Field<0, 11>;    // Window Vertical Start Position
        };

        // Layerx Color Keying Configuration Register
        struct L1CKCR : public Register<0x40016890> {
            using CKRED = Field<16, 8>;    // Color Key Red value
            using CKGREEN = Field<8, 8>;    // Color Key Green value
            using CKBLUE = Field<0, 8>;    // Color Key Blue value
        };

        // Layerx Pixel Format Configuration Register
        struct L1PFCR : public Register<0x40016894> {
            using PF = Field<0, 3>;    // Pixel Format
        };

        // Layerx Constant Alpha Configuration Register
        struct L1CACR : public Register<0x40016898> {
            using CONSTA = Field<0, 8>;    // Constant Alpha
        };

        // Layerx Default Color Configuration Register
        struct L1DCCR : public Register<0x4001689c> {
            using DCALPHA = Field<24, 8>;    // Default Color Alpha
            using DCRED = Field<16, 8>;    // Default Color Red
            using DCGREEN = Field<8, 8>;    // Default Color Green
            using DCBLUE = Field<0, 8>;    // Default Color Blue
        };

        // Layerx Blending Factors Configuration Register
        struct L1BFCR : public Register<0x400168a0> {
            using BF1 = Field<8, 3>;    // Blending Factor 1
            using BF2 = Field<0, 3>;    // Blending Factor 2
        };

        // Layerx Color Frame Buffer Address Register
        struct L1CFBAR : public Register<0x400168ac> {
            using CFBADD = Field<0, 32>;    // Color Frame Buffer Start Address
        };

        // Layerx Color Frame Buffer Length Register
        struct L1CFBLR : public Register<0x400168b0> {
            using CFBP = Field<16, 13>;    // Color Frame Buffer Pitch in bytes
            using CFBLL = Field<0, 13>;    // Color Frame Buffer Line Length
        };

        // Layerx ColorFrame Buffer Line Number Register
        struct L1CFBLNR : public Register<0x400168b4> {
            using CFBLNBR = Field<0, 11>;    // Frame Buffer Line Number
        };

        // Layerx CLUT Write Register
        struct L1CLUTWR : public RegisterWriteOnly<0x400168c4> {
            using CLUTADD = Field<24, 8>;    // CLUT Address
            using RED = Field<16, 8>;    // Red value
            using GREEN = Field<8, 8>;    // Green value
            using BLUE = Field<0, 8>;    // Blue value
        };

        // Layerx Control Register
        struct L2CR : public Register<0x40016904> {
            using CLUTEN = Field<4, 1>;    // Color Look-Up Table Enable
            using COLKEN = Field<1, 1>;    // Color Keying Enable
            using LEN = Field<0, 1>;    // Layer Enable
        };

        // Layerx Window Horizontal Position Configuration Register
        struct L2WHPCR : public Register<0x40016908> {
            using WHSPPOS = Field<16, 12>;    // Window Horizontal Stop Position
            using WHSTPOS = Field<0, 12>;    // Window Horizontal Start Position
        };

        // Layerx Window Vertical Position Configuration Register
        struct L2WVPCR : public Register<0x4001690c> {
            using WVSPPOS = Field<16, 11>;    // Window Vertical Stop Position
            using WVSTPOS = Field<0, 11>;    // Window Vertical Start Position
        };

        // Layerx Color Keying Configuration Register
        struct L2CKCR : public Register<0x40016910> {
            using CKRED = Field<15, 9>;    // Color Key Red value
            using CKGREEN = Field<8, 7>;    // Color Key Green value
            using CKBLUE = Field<0, 8>;    // Color Key Blue value
        };

        // Layerx Pixel Format Configuration Register
        struct L2PFCR : public Register<0x40016914> {
            using PF = Field<0, 3>;    // Pixel Format
        };

        // Layerx Constant Alpha Configuration Register
        struct L2CACR : public Register<0x40016918> {
            using CONSTA = Field<0, 8>;    // Constant Alpha
        };

        // Layerx Default Color Configuration Register
        struct L2DCCR : public Register<0x4001691c> {
            using DCALPHA = Field<24, 8>;    // Default Color Alpha
            using DCRED = Field<16, 8>;    // Default Color Red
            using DCGREEN = Field<8, 8>;    // Default Color Green
            using DCBLUE = Field<0, 8>;    // Default Color Blue
        };

        // Layerx Blending Factors Configuration Register
        struct L2BFCR : public Register<0x40016920> {
            using BF1 = Field<8, 3>;    // Blending Factor 1
            using BF2 = Field<0, 3>;    // Blending Factor 2
        };

        // Layerx Color Frame Buffer Address Register
        struct L2CFBAR : public Register<0x4001692c> {
            using CFBADD = Field<0, 32>;    // Color Frame Buffer Start Address
        };

        // Layerx Color Frame Buffer Length Register
        struct L2CFBLR : public Register<0x40016930> {
            using CFBP = Field<16, 13>;    // Color Frame Buffer Pitch in bytes
            using CFBLL = Field<0, 13>;    // Color Frame Buffer Line Length
        };

        // Layerx ColorFrame Buffer Line Number Register
        struct L2CFBLNR : public Register<0x40016934> {
            using CFBLNBR = Field<0, 11>;    // Frame Buffer Line Number
        };

        // Layerx CLUT Write Register
        struct L2CLUTWR : public RegisterWriteOnly<0x40016944> {
            using CLUTADD = Field<24, 8>;    // CLUT Address
            using RED = Field<16, 8>;    // Red value
            using GREEN = Field<8, 8>;    // Green value
            using BLUE = Field<0, 8>;    // Blue value
        };

    };

    // Serial audio interface
    struct SAI1 {
        // BConfiguration register 1
        struct BCR1 : public Register<0x40015824> {
            using MCJDIV = Field<20, 4>;    // Master clock divider
            using NODIV = Field<19, 1>;    // No divider
            using DMAEN = Field<17, 1>;    // DMA enable
            using SAIBEN = Field<16, 1>;    // Audio block B enable
            using OutDri = Field<13, 1>;    // Output drive
            using MONO = Field<12, 1>;    // Mono mode
            using SYNCEN = Field<10, 2>;    // Synchronization enable
            using CKSTR = Field<9, 1>;    // Clock strobing edge
            using LSBFIRST = Field<8, 1>;    // Least significant bit first
            using DS = Field<5, 3>;    // Data size
            using PRTCFG = Field<2, 2>;    // Protocol configuration
            using MODE = Field<0, 2>;    // Audio block mode
        };

        // BConfiguration register 2
        struct BCR2 : public Register<0x40015828> {
            using COMP = Field<14, 2>;    // Companding mode
            using CPL = Field<13, 1>;    // Complement bit
            using MUTECN = Field<7, 6>;    // Mute counter
            using MUTEVAL = Field<6, 1>;    // Mute value
            using MUTE = Field<5, 1>;    // Mute
            using TRIS = Field<4, 1>;    // Tristate management on data line
            using FFLUS = Field<3, 1>;    // FIFO flush
            using FTH = Field<0, 3>;    // FIFO threshold
        };

        // BFRCR
        struct BFRCR : public Register<0x4001582c> {
            using FSOFF = Field<18, 1>;    // Frame synchronization offset
            using FSPOL = Field<17, 1>;    // Frame synchronization polarity
            using FSDEF = Field<16, 1>;    // Frame synchronization definition
            using FSALL = Field<8, 7>;    // Frame synchronization active level length
            using FRL = Field<0, 8>;    // Frame length
        };

        // BSlot register
        struct BSLOTR : public Register<0x40015830> {
            using SLOTEN = Field<16, 16>;    // Slot enable
            using NBSLOT = Field<8, 4>;    // Number of slots in an audio frame
            using SLOTSZ = Field<6, 2>;    // Slot size
            using FBOFF = Field<0, 5>;    // First bit offset
        };

        // BInterrupt mask register2
        struct BIM : public Register<0x40015834> {
            using LFSDETIE = Field<6, 1>;    // Late frame synchronization detection interrupt enable
            using AFSDETIE = Field<5, 1>;    // Anticipated frame synchronization detection interrupt enable
            using CNRDYIE = Field<4, 1>;    // Codec not ready interrupt enable
            using FREQIE = Field<3, 1>;    // FIFO request interrupt enable
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration interrupt enable
            using MUTEDET = Field<1, 1>;    // Mute detection interrupt enable
            using OVRUDRIE = Field<0, 1>;    // Overrun/underrun interrupt enable
        };

        // BStatus register
        struct BSR : public RegisterReadOnly<0x40015838> {
            using FLVL = Field<16, 3>;    // FIFO level threshold
            using LFSDET = Field<6, 1>;    // Late frame synchronization detection
            using AFSDET = Field<5, 1>;    // Anticipated frame synchronization detection
            using CNRDY = Field<4, 1>;    // Codec not ready
            using FREQ = Field<3, 1>;    // FIFO request
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration flag
            using MUTEDET = Field<1, 1>;    // Mute detection
            using OVRUDR = Field<0, 1>;    // Overrun / underrun
        };

        // BClear flag register
        struct BCLRFR : public RegisterWriteOnly<0x4001583c> {
            using LFSDET = Field<6, 1>;    // Clear late frame synchronization detection flag
            using CAFSDET = Field<5, 1>;    // Clear anticipated frame synchronization detection flag
            using CNRDY = Field<4, 1>;    // Clear codec not ready flag
            using WCKCFG = Field<2, 1>;    // Clear wrong clock configuration flag
            using MUTEDET = Field<1, 1>;    // Mute detection flag
            using OVRUDR = Field<0, 1>;    // Clear overrun / underrun
        };

        // BData register
        struct BDR : public Register<0x40015840> {
            using DATA = Field<0, 32>;    // Data
        };

        // AConfiguration register 1
        struct ACR1 : public Register<0x40015804> {
            using MCJDIV = Field<20, 4>;    // Master clock divider
            using NODIV = Field<19, 1>;    // No divider
            using DMAEN = Field<17, 1>;    // DMA enable
            using SAIAEN = Field<16, 1>;    // Audio block A enable
            using OutDri = Field<13, 1>;    // Output drive
            using MONO = Field<12, 1>;    // Mono mode
            using SYNCEN = Field<10, 2>;    // Synchronization enable
            using CKSTR = Field<9, 1>;    // Clock strobing edge
            using LSBFIRST = Field<8, 1>;    // Least significant bit first
            using DS = Field<5, 3>;    // Data size
            using PRTCFG = Field<2, 2>;    // Protocol configuration
            using MODE = Field<0, 2>;    // Audio block mode
        };

        // AConfiguration register 2
        struct ACR2 : public Register<0x40015808> {
            using COMP = Field<14, 2>;    // Companding mode
            using CPL = Field<13, 1>;    // Complement bit
            using MUTECN = Field<7, 6>;    // Mute counter
            using MUTEVAL = Field<6, 1>;    // Mute value
            using MUTE = Field<5, 1>;    // Mute
            using TRIS = Field<4, 1>;    // Tristate management on data line
            using FFLUS = Field<3, 1>;    // FIFO flush
            using FTH = Field<0, 3>;    // FIFO threshold
        };

        // AFRCR
        struct AFRCR : public Register<0x4001580c> {
            using FSOFF = Field<18, 1>;    // Frame synchronization offset
            using FSPOL = Field<17, 1>;    // Frame synchronization polarity
            using FSDEF = Field<16, 1>;    // Frame synchronization definition
            using FSALL = Field<8, 7>;    // Frame synchronization active level length
            using FRL = Field<0, 8>;    // Frame length
        };

        // ASlot register
        struct ASLOTR : public Register<0x40015810> {
            using SLOTEN = Field<16, 16>;    // Slot enable
            using NBSLOT = Field<8, 4>;    // Number of slots in an audio frame
            using SLOTSZ = Field<6, 2>;    // Slot size
            using FBOFF = Field<0, 5>;    // First bit offset
        };

        // AInterrupt mask register2
        struct AIM : public Register<0x40015814> {
            using LFSDET = Field<6, 1>;    // Late frame synchronization detection interrupt enable
            using AFSDETIE = Field<5, 1>;    // Anticipated frame synchronization detection interrupt enable
            using CNRDYIE = Field<4, 1>;    // Codec not ready interrupt enable
            using FREQIE = Field<3, 1>;    // FIFO request interrupt enable
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration interrupt enable
            using MUTEDET = Field<1, 1>;    // Mute detection interrupt enable
            using OVRUDRIE = Field<0, 1>;    // Overrun/underrun interrupt enable
        };

        // AStatus register
        struct ASR : public Register<0x40015818> {
            using FLVL = Field<16, 3>;    // FIFO level threshold
            using LFSDET = Field<6, 1>;    // Late frame synchronization detection
            using AFSDET = Field<5, 1>;    // Anticipated frame synchronization detection
            using CNRDY = Field<4, 1>;    // Codec not ready
            using FREQ = Field<3, 1>;    // FIFO request
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration flag. This bit is read only.
            using MUTEDET = Field<1, 1>;    // Mute detection
            using OVRUDR = Field<0, 1>;    // Overrun / underrun
        };

        // AClear flag register
        struct ACLRFR : public Register<0x4001581c> {
            using LFSDET = Field<6, 1>;    // Clear late frame synchronization detection flag
            using CAFSDET = Field<5, 1>;    // Clear anticipated frame synchronization detection flag.
            using CNRDY = Field<4, 1>;    // Clear codec not ready flag
            using WCKCFG = Field<2, 1>;    // Clear wrong clock configuration flag
            using MUTEDET = Field<1, 1>;    // Mute detection flag
            using OVRUDR = Field<0, 1>;    // Clear overrun / underrun
        };

        // AData register
        struct ADR : public Register<0x40015820> {
            using DATA = Field<0, 32>;    // Data
        };

        // Global configuration register
        struct GCR : public Register<0x40015800> {
            using SYNCIN = Field<0, 2>;    // Synchronization inputs
            using SYNCOUT = Field<4, 2>;    // Synchronization outputs
        };

    };

    // Serial audio interface
    struct SAI2 {
        // BConfiguration register 1
        struct BCR1 : public Register<0x40015c24> {
            using MCJDIV = Field<20, 4>;    // Master clock divider
            using NODIV = Field<19, 1>;    // No divider
            using DMAEN = Field<17, 1>;    // DMA enable
            using SAIBEN = Field<16, 1>;    // Audio block B enable
            using OutDri = Field<13, 1>;    // Output drive
            using MONO = Field<12, 1>;    // Mono mode
            using SYNCEN = Field<10, 2>;    // Synchronization enable
            using CKSTR = Field<9, 1>;    // Clock strobing edge
            using LSBFIRST = Field<8, 1>;    // Least significant bit first
            using DS = Field<5, 3>;    // Data size
            using PRTCFG = Field<2, 2>;    // Protocol configuration
            using MODE = Field<0, 2>;    // Audio block mode
        };

        // BConfiguration register 2
        struct BCR2 : public Register<0x40015c28> {
            using COMP = Field<14, 2>;    // Companding mode
            using CPL = Field<13, 1>;    // Complement bit
            using MUTECN = Field<7, 6>;    // Mute counter
            using MUTEVAL = Field<6, 1>;    // Mute value
            using MUTE = Field<5, 1>;    // Mute
            using TRIS = Field<4, 1>;    // Tristate management on data line
            using FFLUS = Field<3, 1>;    // FIFO flush
            using FTH = Field<0, 3>;    // FIFO threshold
        };

        // BFRCR
        struct BFRCR : public Register<0x40015c2c> {
            using FSOFF = Field<18, 1>;    // Frame synchronization offset
            using FSPOL = Field<17, 1>;    // Frame synchronization polarity
            using FSDEF = Field<16, 1>;    // Frame synchronization definition
            using FSALL = Field<8, 7>;    // Frame synchronization active level length
            using FRL = Field<0, 8>;    // Frame length
        };

        // BSlot register
        struct BSLOTR : public Register<0x40015c30> {
            using SLOTEN = Field<16, 16>;    // Slot enable
            using NBSLOT = Field<8, 4>;    // Number of slots in an audio frame
            using SLOTSZ = Field<6, 2>;    // Slot size
            using FBOFF = Field<0, 5>;    // First bit offset
        };

        // BInterrupt mask register2
        struct BIM : public Register<0x40015c34> {
            using LFSDETIE = Field<6, 1>;    // Late frame synchronization detection interrupt enable
            using AFSDETIE = Field<5, 1>;    // Anticipated frame synchronization detection interrupt enable
            using CNRDYIE = Field<4, 1>;    // Codec not ready interrupt enable
            using FREQIE = Field<3, 1>;    // FIFO request interrupt enable
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration interrupt enable
            using MUTEDET = Field<1, 1>;    // Mute detection interrupt enable
            using OVRUDRIE = Field<0, 1>;    // Overrun/underrun interrupt enable
        };

        // BStatus register
        struct BSR : public RegisterReadOnly<0x40015c38> {
            using FLVL = Field<16, 3>;    // FIFO level threshold
            using LFSDET = Field<6, 1>;    // Late frame synchronization detection
            using AFSDET = Field<5, 1>;    // Anticipated frame synchronization detection
            using CNRDY = Field<4, 1>;    // Codec not ready
            using FREQ = Field<3, 1>;    // FIFO request
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration flag
            using MUTEDET = Field<1, 1>;    // Mute detection
            using OVRUDR = Field<0, 1>;    // Overrun / underrun
        };

        // BClear flag register
        struct BCLRFR : public RegisterWriteOnly<0x40015c3c> {
            using LFSDET = Field<6, 1>;    // Clear late frame synchronization detection flag
            using CAFSDET = Field<5, 1>;    // Clear anticipated frame synchronization detection flag
            using CNRDY = Field<4, 1>;    // Clear codec not ready flag
            using WCKCFG = Field<2, 1>;    // Clear wrong clock configuration flag
            using MUTEDET = Field<1, 1>;    // Mute detection flag
            using OVRUDR = Field<0, 1>;    // Clear overrun / underrun
        };

        // BData register
        struct BDR : public Register<0x40015c40> {
            using DATA = Field<0, 32>;    // Data
        };

        // AConfiguration register 1
        struct ACR1 : public Register<0x40015c04> {
            using MCJDIV = Field<20, 4>;    // Master clock divider
            using NODIV = Field<19, 1>;    // No divider
            using DMAEN = Field<17, 1>;    // DMA enable
            using SAIAEN = Field<16, 1>;    // Audio block A enable
            using OutDri = Field<13, 1>;    // Output drive
            using MONO = Field<12, 1>;    // Mono mode
            using SYNCEN = Field<10, 2>;    // Synchronization enable
            using CKSTR = Field<9, 1>;    // Clock strobing edge
            using LSBFIRST = Field<8, 1>;    // Least significant bit first
            using DS = Field<5, 3>;    // Data size
            using PRTCFG = Field<2, 2>;    // Protocol configuration
            using MODE = Field<0, 2>;    // Audio block mode
        };

        // AConfiguration register 2
        struct ACR2 : public Register<0x40015c08> {
            using COMP = Field<14, 2>;    // Companding mode
            using CPL = Field<13, 1>;    // Complement bit
            using MUTECN = Field<7, 6>;    // Mute counter
            using MUTEVAL = Field<6, 1>;    // Mute value
            using MUTE = Field<5, 1>;    // Mute
            using TRIS = Field<4, 1>;    // Tristate management on data line
            using FFLUS = Field<3, 1>;    // FIFO flush
            using FTH = Field<0, 3>;    // FIFO threshold
        };

        // AFRCR
        struct AFRCR : public Register<0x40015c0c> {
            using FSOFF = Field<18, 1>;    // Frame synchronization offset
            using FSPOL = Field<17, 1>;    // Frame synchronization polarity
            using FSDEF = Field<16, 1>;    // Frame synchronization definition
            using FSALL = Field<8, 7>;    // Frame synchronization active level length
            using FRL = Field<0, 8>;    // Frame length
        };

        // ASlot register
        struct ASLOTR : public Register<0x40015c10> {
            using SLOTEN = Field<16, 16>;    // Slot enable
            using NBSLOT = Field<8, 4>;    // Number of slots in an audio frame
            using SLOTSZ = Field<6, 2>;    // Slot size
            using FBOFF = Field<0, 5>;    // First bit offset
        };

        // AInterrupt mask register2
        struct AIM : public Register<0x40015c14> {
            using LFSDET = Field<6, 1>;    // Late frame synchronization detection interrupt enable
            using AFSDETIE = Field<5, 1>;    // Anticipated frame synchronization detection interrupt enable
            using CNRDYIE = Field<4, 1>;    // Codec not ready interrupt enable
            using FREQIE = Field<3, 1>;    // FIFO request interrupt enable
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration interrupt enable
            using MUTEDET = Field<1, 1>;    // Mute detection interrupt enable
            using OVRUDRIE = Field<0, 1>;    // Overrun/underrun interrupt enable
        };

        // AStatus register
        struct ASR : public Register<0x40015c18> {
            using FLVL = Field<16, 3>;    // FIFO level threshold
            using LFSDET = Field<6, 1>;    // Late frame synchronization detection
            using AFSDET = Field<5, 1>;    // Anticipated frame synchronization detection
            using CNRDY = Field<4, 1>;    // Codec not ready
            using FREQ = Field<3, 1>;    // FIFO request
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration flag. This bit is read only.
            using MUTEDET = Field<1, 1>;    // Mute detection
            using OVRUDR = Field<0, 1>;    // Overrun / underrun
        };

        // AClear flag register
        struct ACLRFR : public Register<0x40015c1c> {
            using LFSDET = Field<6, 1>;    // Clear late frame synchronization detection flag
            using CAFSDET = Field<5, 1>;    // Clear anticipated frame synchronization detection flag.
            using CNRDY = Field<4, 1>;    // Clear codec not ready flag
            using WCKCFG = Field<2, 1>;    // Clear wrong clock configuration flag
            using MUTEDET = Field<1, 1>;    // Mute detection flag
            using OVRUDR = Field<0, 1>;    // Clear overrun / underrun
        };

        // AData register
        struct ADR : public Register<0x40015c20> {
            using DATA = Field<0, 32>;    // Data
        };

        // Global configuration register
        struct GCR : public Register<0x40015c00> {
            using SYNCIN = Field<0, 2>;    // Synchronization inputs
            using SYNCOUT = Field<4, 2>;    // Synchronization outputs
        };

    };

    // DMA2D controller
    struct DMA2D {
        // control register
        struct CR : public Register<0x4002b000> {
            using MODE = Field<16, 2>;    // DMA2D mode
            using CEIE = Field<13, 1>;    // Configuration Error Interrupt Enable
            using CTCIE = Field<12, 1>;    // CLUT transfer complete interrupt enable
            using CAEIE = Field<11, 1>;    // CLUT access error interrupt enable
            using TWIE = Field<10, 1>;    // Transfer watermark interrupt enable
            using TCIE = Field<9, 1>;    // Transfer complete interrupt enable
            using TEIE = Field<8, 1>;    // Transfer error interrupt enable
            using ABORT = Field<2, 1>;    // Abort
            using SUSP = Field<1, 1>;    // Suspend
            using START = Field<0, 1>;    // Start
        };

        // Interrupt Status Register
        struct ISR : public RegisterReadOnly<0x4002b004> {
            using CEIF = Field<5, 1>;    // Configuration error interrupt flag
            using CTCIF = Field<4, 1>;    // CLUT transfer complete interrupt flag
            using CAEIF = Field<3, 1>;    // CLUT access error interrupt flag
            using TWIF = Field<2, 1>;    // Transfer watermark interrupt flag
            using TCIF = Field<1, 1>;    // Transfer complete interrupt flag
            using TEIF = Field<0, 1>;    // Transfer error interrupt flag
        };

        // interrupt flag clear register
        struct IFCR : public Register<0x4002b008> {
            using CCEIF = Field<5, 1>;    // Clear configuration error interrupt flag
            using CCTCIF = Field<4, 1>;    // Clear CLUT transfer complete interrupt flag
            using CAECIF = Field<3, 1>;    // Clear CLUT access error interrupt flag
            using CTWIF = Field<2, 1>;    // Clear transfer watermark interrupt flag
            using CTCIF = Field<1, 1>;    // Clear transfer complete interrupt flag
            using CTEIF = Field<0, 1>;    // Clear Transfer error interrupt flag
        };

        // foreground memory address register
        struct FGMAR : public Register<0x4002b00c> {
            using MA = Field<0, 32>;    // Memory address
        };

        // foreground offset register
        struct FGOR : public Register<0x4002b010> {
            using LO = Field<0, 14>;    // Line offset
        };

        // background memory address register
        struct BGMAR : public Register<0x4002b014> {
            using MA = Field<0, 32>;    // Memory address
        };

        // background offset register
        struct BGOR : public Register<0x4002b018> {
            using LO = Field<0, 14>;    // Line offset
        };

        // foreground PFC control register
        struct FGPFCCR : public Register<0x4002b01c> {
            using ALPHA = Field<24, 8>;    // Alpha value
            using AM = Field<16, 2>;    // Alpha mode
            using CS = Field<8, 8>;    // CLUT size
            using START = Field<5, 1>;    // Start
            using CCM = Field<4, 1>;    // CLUT color mode
            using CM = Field<0, 4>;    // Color mode
        };

        // foreground color register
        struct FGCOLR : public Register<0x4002b020> {
            using RED = Field<16, 8>;    // Red Value
            using GREEN = Field<8, 8>;    // Green Value
            using BLUE = Field<0, 8>;    // Blue Value
        };

        // background PFC control register
        struct BGPFCCR : public Register<0x4002b024> {
            using ALPHA = Field<24, 8>;    // Alpha value
            using AM = Field<16, 2>;    // Alpha mode
            using CS = Field<8, 8>;    // CLUT size
            using START = Field<5, 1>;    // Start
            using CCM = Field<4, 1>;    // CLUT Color mode
            using CM = Field<0, 4>;    // Color mode
        };

        // background color register
        struct BGCOLR : public Register<0x4002b028> {
            using RED = Field<16, 8>;    // Red Value
            using GREEN = Field<8, 8>;    // Green Value
            using BLUE = Field<0, 8>;    // Blue Value
        };

        // foreground CLUT memory address register
        struct FGCMAR : public Register<0x4002b02c> {
            using MA = Field<0, 32>;    // Memory Address
        };

        // background CLUT memory address register
        struct BGCMAR : public Register<0x4002b030> {
            using MA = Field<0, 32>;    // Memory address
        };

        // output PFC control register
        struct OPFCCR : public Register<0x4002b034> {
            using CM = Field<0, 3>;    // Color mode
        };

        // output color register
        struct OCOLR : public Register<0x4002b038> {
            using APLHA = Field<24, 8>;    // Alpha Channel Value
            using RED = Field<16, 8>;    // Red Value
            using GREEN = Field<8, 8>;    // Green Value
            using BLUE = Field<0, 8>;    // Blue Value
        };

        // output memory address register
        struct OMAR : public Register<0x4002b03c> {
            using MA = Field<0, 32>;    // Memory Address
        };

        // output offset register
        struct OOR : public Register<0x4002b040> {
            using LO = Field<0, 14>;    // Line Offset
        };

        // number of line register
        struct NLR : public Register<0x4002b044> {
            using PL = Field<16, 14>;    // Pixel per lines
            using NL = Field<0, 16>;    // Number of lines
        };

        // line watermark register
        struct LWR : public Register<0x4002b048> {
            using LW = Field<0, 16>;    // Line watermark
        };

        // AHB master timer configuration register
        struct AMTCR : public Register<0x4002b04c> {
            using DT = Field<8, 8>;    // Dead Time
            using EN = Field<0, 1>;    // Enable
        };

        // FGCLUT
        struct FGCLUT : public Register<0x4002b400> {
            using APLHA = Field<24, 8>;    // APLHA
            using RED = Field<16, 8>;    // RED
            using GREEN = Field<8, 8>;    // GREEN
            using BLUE = Field<0, 8>;    // BLUE
        };

        // BGCLUT
        struct BGCLUT : public Register<0x4002b800> {
            using APLHA = Field<24, 8>;    // APLHA
            using RED = Field<16, 8>;    // RED
            using GREEN = Field<8, 8>;    // GREEN
            using BLUE = Field<0, 8>;    // BLUE
        };

    };

    // QuadSPI interface
    struct QUADSPI {
        // control register
        struct CR : public Register<0xa0001000> {
            using PRESCALER = Field<24, 8>;    // Clock prescaler
            using PMM = Field<23, 1>;    // Polling match mode
            using APMS = Field<22, 1>;    // Automatic poll mode stop
            using TOIE = Field<20, 1>;    // TimeOut interrupt enable
            using SMIE = Field<19, 1>;    // Status match interrupt enable
            using FTIE = Field<18, 1>;    // FIFO threshold interrupt enable
            using TCIE = Field<17, 1>;    // Transfer complete interrupt enable
            using TEIE = Field<16, 1>;    // Transfer error interrupt enable
            using FTHRES = Field<8, 5>;    // IFO threshold level
            using FSEL = Field<7, 1>;    // FLASH memory selection
            using DFM = Field<6, 1>;    // Dual-flash mode
            using SSHIFT = Field<4, 1>;    // Sample shift
            using TCEN = Field<3, 1>;    // Timeout counter enable
            using DMAEN = Field<2, 1>;    // DMA enable
            using ABORT = Field<1, 1>;    // Abort request
            using EN = Field<0, 1>;    // Enable
        };

        // device configuration register
        struct DCR : public Register<0xa0001004> {
            using FSIZE = Field<16, 5>;    // FLASH memory size
            using CSHT = Field<8, 3>;    // Chip select high time
            using CKMODE = Field<0, 1>;    // Mode 0 / mode 3
        };

        // status register
        struct SR : public RegisterReadOnly<0xa0001008> {
            using FLEVEL = Field<8, 7>;    // FIFO level
            using BUSY = Field<5, 1>;    // Busy
            using TOF = Field<4, 1>;    // Timeout flag
            using SMF = Field<3, 1>;    // Status match flag
            using FTF = Field<2, 1>;    // FIFO threshold flag
            using TCF = Field<1, 1>;    // Transfer complete flag
            using TEF = Field<0, 1>;    // Transfer error flag
        };

        // flag clear register
        struct FCR : public Register<0xa000100c> {
            using CTOF = Field<4, 1>;    // Clear timeout flag
            using CSMF = Field<3, 1>;    // Clear status match flag
            using CTCF = Field<1, 1>;    // Clear transfer complete flag
            using CTEF = Field<0, 1>;    // Clear transfer error flag
        };

        // data length register
        struct DLR : public Register<0xa0001010> {
            using DL = Field<0, 32>;    // Data length
        };

        // communication configuration register
        struct CCR : public Register<0xa0001014> {
            using DDRM = Field<31, 1>;    // Double data rate mode
            using DHHC = Field<30, 1>;    // DDR hold half cycle
            using SIOO = Field<28, 1>;    // Send instruction only once mode
            using FMODE = Field<26, 2>;    // Functional mode
            using DMODE = Field<24, 2>;    // Data mode
            using DCYC = Field<18, 5>;    // Number of dummy cycles
            using ABSIZE = Field<16, 2>;    // Alternate bytes size
            using ABMODE = Field<14, 2>;    // Alternate bytes mode
            using ADSIZE = Field<12, 2>;    // Address size
            using ADMODE = Field<10, 2>;    // Address mode
            using IMODE = Field<8, 2>;    // Instruction mode
            using INSTRUCTION = Field<0, 8>;    // Instruction
        };

        // address register
        struct AR : public Register<0xa0001018> {
            using ADDRESS = Field<0, 32>;    // Address
        };

        // ABR
        struct ABR : public Register<0xa000101c> {
            using ALTERNATE = Field<0, 32>;    // ALTERNATE
        };

        // data register
        struct DR : public Register<0xa0001020> {
            using DATA = Field<0, 32>;    // Data
        };

        // polling status mask register
        struct PSMKR : public Register<0xa0001024> {
            using MASK = Field<0, 32>;    // Status mask
        };

        // polling status match register
        struct PSMAR : public Register<0xa0001028> {
            using MATCH = Field<0, 32>;    // Status match
        };

        // polling interval register
        struct PIR : public Register<0xa000102c> {
            using INTERVAL = Field<0, 16>;    // Polling interval
        };

        // low-power timeout register
        struct LPTR : public Register<0xa0001030> {
            using TIMEOUT = Field<0, 16>;    // Timeout period
        };

    };

    // HDMI-CEC controller
    struct CEC {
        // control register
        struct CR : public Register<0x40006c00> {
            using TXEOM = Field<2, 1>;    // Tx End Of Message
            using TXSOM = Field<1, 1>;    // Tx start of message
            using CECEN = Field<0, 1>;    // CEC Enable
        };

        // configuration register
        struct CFGR : public Register<0x40006c04> {
            using SFT = Field<0, 3>;    // Signal Free Time
            using RXTOL = Field<3, 1>;    // Rx-Tolerance
            using BRESTP = Field<4, 1>;    // Rx-stop on bit rising error
            using BREGEN = Field<5, 1>;    // Generate error-bit on bit rising error
            using LBPEGEN = Field<6, 1>;    // Generate Error-Bit on Long Bit Period Error
            using BRDNOGEN = Field<7, 1>;    // Avoid Error-Bit Generation in Broadcast
            using SFTOP = Field<8, 1>;    // SFT Option Bit
            using OAR = Field<16, 15>;    // Own addresses configuration
            using LSTN = Field<31, 1>;    // Listen mode
        };

        // Tx data register
        struct TXDR : public RegisterWriteOnly<0x40006c08> {
            using TXD = Field<0, 8>;    // Tx Data register
        };

        // Rx Data Register
        struct RXDR : public RegisterReadOnly<0x40006c0c> {
            using Field = Field<0, 8>;    // CEC Rx Data Register
        };

        // Interrupt and Status Register
        struct ISR : public Register<0x40006c10> {
            using TXACKE = Field<12, 1>;    // Tx-Missing acknowledge error
            using TXERR = Field<11, 1>;    // Tx-Error
            using TXUDR = Field<10, 1>;    // Tx-Buffer Underrun
            using TXEND = Field<9, 1>;    // End of Transmission
            using TXBR = Field<8, 1>;    // Tx-Byte Request
            using ARBLST = Field<7, 1>;    // Arbitration Lost
            using RXACKE = Field<6, 1>;    // Rx-Missing Acknowledge
            using LBPE = Field<5, 1>;    // Rx-Long Bit Period Error
            using SBPE = Field<4, 1>;    // Rx-Short Bit period error
            using BRE = Field<3, 1>;    // Rx-Bit rising error
            using RXOVR = Field<2, 1>;    // Rx-Overrun
            using RXEND = Field<1, 1>;    // End Of Reception
            using RXBR = Field<0, 1>;    // Rx-Byte Received
        };

        // interrupt enable register
        struct IER : public Register<0x40006c14> {
            using TXACKIE = Field<12, 1>;    // Tx-Missing Acknowledge Error Interrupt Enable
            using TXERRIE = Field<11, 1>;    // Tx-Error Interrupt Enable
            using TXUDRIE = Field<10, 1>;    // Tx-Underrun interrupt enable
            using TXENDIE = Field<9, 1>;    // Tx-End of message interrupt enable
            using TXBRIE = Field<8, 1>;    // Tx-Byte Request Interrupt Enable
            using ARBLSTIE = Field<7, 1>;    // Arbitration Lost Interrupt Enable
            using RXACKIE = Field<6, 1>;    // Rx-Missing Acknowledge Error Interrupt Enable
            using LBPEIE = Field<5, 1>;    // Long Bit Period Error Interrupt Enable
            using SBPEIE = Field<4, 1>;    // Short Bit Period Error Interrupt Enable
            using BREIE = Field<3, 1>;    // Bit Rising Error Interrupt Enable
            using RXOVRIE = Field<2, 1>;    // Rx-Buffer Overrun Interrupt Enable
            using RXENDIE = Field<1, 1>;    // End Of Reception Interrupt Enable
            using RXBRIE = Field<0, 1>;    // Rx-Byte Received Interrupt Enable
        };

    };

    // Receiver Interface
    struct SPDIFRX {
        // Control register
        struct CR : public Register<0x40004000> {
            using SPDIFEN = Field<0, 2>;    // Peripheral Block Enable
            using RXDMAEN = Field<2, 1>;    // Receiver DMA ENable for data flow
            using RXSTEO = Field<3, 1>;    // STerEO Mode
            using DRFMT = Field<4, 2>;    // RX Data format
            using PMSK = Field<6, 1>;    // Mask Parity error bit
            using VMSK = Field<7, 1>;    // Mask of Validity bit
            using CUMSK = Field<8, 1>;    // Mask of channel status and user bits
            using PTMSK = Field<9, 1>;    // Mask of Preamble Type bits
            using CBDMAEN = Field<10, 1>;    // Control Buffer DMA ENable for control flow
            using CHSEL = Field<11, 1>;    // Channel Selection
            using NBTR = Field<12, 2>;    // Maximum allowed re-tries during synchronization phase
            using WFA = Field<14, 1>;    // Wait For Activity
            using INSEL = Field<16, 3>;    // input selection
        };

        // Interrupt mask register
        struct IMR : public Register<0x40004004> {
            using RXNEIE = Field<0, 1>;    // RXNE interrupt enable
            using CSRNEIE = Field<1, 1>;    // Control Buffer Ready Interrupt Enable
            using PERRIE = Field<2, 1>;    // Parity error interrupt enable
            using OVRIE = Field<3, 1>;    // Overrun error Interrupt Enable
            using SBLKIE = Field<4, 1>;    // Synchronization Block Detected Interrupt Enable
            using SYNCDIE = Field<5, 1>;    // Synchronization Done
            using IFEIE = Field<6, 1>;    // Serial Interface Error Interrupt Enable
        };

        // Status register
        struct SR : public RegisterReadOnly<0x40004008> {
            using RXNE = Field<0, 1>;    // Read data register not empty
            using CSRNE = Field<1, 1>;    // Control Buffer register is not empty
            using PERR = Field<2, 1>;    // Parity error
            using OVR = Field<3, 1>;    // Overrun error
            using SBD = Field<4, 1>;    // Synchronization Block Detected
            using SYNCD = Field<5, 1>;    // Synchronization Done
            using FERR = Field<6, 1>;    // Framing error
            using SERR = Field<7, 1>;    // Synchronization error
            using TERR = Field<8, 1>;    // Time-out error
            using WIDTH5 = Field<16, 15>;    // Duration of 5 symbols counted with SPDIF_CLK
        };

        // Interrupt Flag Clear register
        struct IFCR : public RegisterWriteOnly<0x4000400c> {
            using PERRCF = Field<2, 1>;    // Clears the Parity error flag
            using OVRCF = Field<3, 1>;    // Clears the Overrun error flag
            using SBDCF = Field<4, 1>;    // Clears the Synchronization Block Detected flag
            using SYNCDCF = Field<5, 1>;    // Clears the Synchronization Done flag
        };

        // Data input register
        struct DR : public RegisterReadOnly<0x40004010> {
            using Field = Field<0, 24>;    // Parity Error bit
            using PE = Field<24, 1>;    // Parity Error bit
            using V = Field<25, 1>;    // Validity bit
            using U = Field<26, 1>;    // User bit
            using C = Field<27, 1>;    // Channel Status bit
            using PT = Field<28, 2>;    // Preamble Type
        };

        // Channel Status register
        struct CSR : public RegisterReadOnly<0x40004014> {
            using USR = Field<0, 16>;    // User data information
            using CS = Field<16, 8>;    // Channel A status information
            using SOB = Field<24, 1>;    // Start Of Block
        };

        // Debug Information register
        struct DIR : public RegisterReadOnly<0x40004018> {
            using THI = Field<0, 13>;    // Threshold HIGH
            using TLO = Field<16, 13>;    // Threshold LOW
        };

    };

    // Secure digital input/output interface
    struct SDMMC1 {
        // power control register
        struct POWER : public Register<0x40012c00> {
            using PWRCTRL = Field<0, 2>;    // PWRCTRL
        };

        // SDI clock control register
        struct CLKCR : public Register<0x40012c04> {
            using HWFC_EN = Field<14, 1>;    // HW Flow Control enable
            using NEGEDGE = Field<13, 1>;    // SDIO_CK dephasing selection bit
            using WIDBUS = Field<11, 2>;    // Wide bus mode enable bit
            using BYPASS = Field<10, 1>;    // Clock divider bypass enable bit
            using PWRSAV = Field<9, 1>;    // Power saving configuration bit
            using CLKEN = Field<8, 1>;    // Clock enable bit
            using CLKDIV = Field<0, 8>;    // Clock divide factor
        };

        // argument register
        struct ARG : public Register<0x40012c08> {
            using CMDARG = Field<0, 32>;    // Command argument
        };

        // command register
        struct CMD : public Register<0x40012c0c> {
            using CE_ATACMD = Field<14, 1>;    // CE-ATA command
            using nIEN = Field<13, 1>;    // not Interrupt Enable
            using ENCMDcompl = Field<12, 1>;    // Enable CMD completion
            using SDIOSuspend = Field<11, 1>;    // SD I/O suspend command
            using CPSMEN = Field<10, 1>;    // Command path state machine (CPSM) Enable bit
            using WAITPEND = Field<9, 1>;    // CPSM Waits for ends of data transfer (CmdPend internal signal)
            using WAITINT = Field<8, 1>;    // CPSM waits for interrupt request
            using WAITRESP = Field<6, 2>;    // Wait for response bits
            using CMDINDEX = Field<0, 6>;    // Command index
        };

        // command response register
        struct RESPCMD : public RegisterReadOnly<0x40012c10> {
            using Field = Field<0, 6>;    // Response command index
        };

        // response 1..4 register
        struct RESP1 : public RegisterReadOnly<0x40012c14> {
            using CARDSTATUS1 = Field<0, 32>;    // see Table 132
        };

        // response 1..4 register
        struct RESP2 : public RegisterReadOnly<0x40012c18> {
            using CARDSTATUS2 = Field<0, 32>;    // see Table 132
        };

        // response 1..4 register
        struct RESP3 : public RegisterReadOnly<0x40012c1c> {
            using CARDSTATUS3 = Field<0, 32>;    // see Table 132
        };

        // response 1..4 register
        struct RESP4 : public RegisterReadOnly<0x40012c20> {
            using CARDSTATUS4 = Field<0, 32>;    // see Table 132
        };

        // data timer register
        struct DTIMER : public Register<0x40012c24> {
            using DATATIME = Field<0, 32>;    // Data timeout period
        };

        // data length register
        struct DLEN : public Register<0x40012c28> {
            using DATALENGTH = Field<0, 25>;    // Data length value
        };

        // data control register
        struct DCTRL : public Register<0x40012c2c> {
            using SDIOEN = Field<11, 1>;    // SD I/O enable functions
            using RWMOD = Field<10, 1>;    // Read wait mode
            using RWSTOP = Field<9, 1>;    // Read wait stop
            using RWSTART = Field<8, 1>;    // Read wait start
            using DBLOCKSIZE = Field<4, 4>;    // Data block size
            using DMAEN = Field<3, 1>;    // DMA enable bit
            using DTMODE = Field<2, 1>;    // Data transfer mode selection 1: Stream or SDIO multibyte data transfer
            using DTDIR = Field<1, 1>;    // Data transfer direction selection
            using DTEN = Field<0, 1>;    // DTEN
        };

        // data counter register
        struct DCOUNT : public RegisterReadOnly<0x40012c30> {
            using DATACOUNT = Field<0, 25>;    // Data count value
        };

        // status register
        struct STA : public RegisterReadOnly<0x40012c34> {
            using CEATAEND = Field<23, 1>;    // CE-ATA command completion signal received for CMD61
            using SDIOIT = Field<22, 1>;    // SDIO interrupt received
            using RXDAVL = Field<21, 1>;    // Data available in receive FIFO
            using TXDAVL = Field<20, 1>;    // Data available in transmit FIFO
            using RXFIFOE = Field<19, 1>;    // Receive FIFO empty
            using TXFIFOE = Field<18, 1>;    // Transmit FIFO empty
            using RXFIFOF = Field<17, 1>;    // Receive FIFO full
            using TXFIFOF = Field<16, 1>;    // Transmit FIFO full
            using RXFIFOHF = Field<15, 1>;    // Receive FIFO half full: there are at least 8 words in the FIFO
            using TXFIFOHE = Field<14, 1>;    // Transmit FIFO half empty: at least 8 words can be written into the FIFO
            using RXACT = Field<13, 1>;    // Data receive in progress
            using TXACT = Field<12, 1>;    // Data transmit in progress
            using CMDACT = Field<11, 1>;    // Command transfer in progress
            using DBCKEND = Field<10, 1>;    // Data block sent/received (CRC check passed)
            using STBITERR = Field<9, 1>;    // Start bit not detected on all data signals in wide bus mode
            using DATAEND = Field<8, 1>;    // Data end (data counter, SDIDCOUNT, is zero)
            using CMDSENT = Field<7, 1>;    // Command sent (no response required)
            using CMDREND = Field<6, 1>;    // Command response received (CRC check passed)
            using RXOVERR = Field<5, 1>;    // Received FIFO overrun error
            using TXUNDERR = Field<4, 1>;    // Transmit FIFO underrun error
            using DTIMEOUT = Field<3, 1>;    // Data timeout
            using CTIMEOUT = Field<2, 1>;    // Command response timeout
            using DCRCFAIL = Field<1, 1>;    // Data block sent/received (CRC check failed)
            using CCRCFAIL = Field<0, 1>;    // Command response received (CRC check failed)
        };

        // interrupt clear register
        struct ICR : public Register<0x40012c38> {
            using CEATAENDC = Field<23, 1>;    // CEATAEND flag clear bit
            using SDIOITC = Field<22, 1>;    // SDIOIT flag clear bit
            using DBCKENDC = Field<10, 1>;    // DBCKEND flag clear bit
            using STBITERRC = Field<9, 1>;    // STBITERR flag clear bit
            using DATAENDC = Field<8, 1>;    // DATAEND flag clear bit
            using CMDSENTC = Field<7, 1>;    // CMDSENT flag clear bit
            using CMDRENDC = Field<6, 1>;    // CMDREND flag clear bit
            using RXOVERRC = Field<5, 1>;    // RXOVERR flag clear bit
            using TXUNDERRC = Field<4, 1>;    // TXUNDERR flag clear bit
            using DTIMEOUTC = Field<3, 1>;    // DTIMEOUT flag clear bit
            using CTIMEOUTC = Field<2, 1>;    // CTIMEOUT flag clear bit
            using DCRCFAILC = Field<1, 1>;    // DCRCFAIL flag clear bit
            using CCRCFAILC = Field<0, 1>;    // CCRCFAIL flag clear bit
        };

        // mask register
        struct MASK : public Register<0x40012c3c> {
            using CEATAENDIE = Field<23, 1>;    // CE-ATA command completion signal received interrupt enable
            using SDIOITIE = Field<22, 1>;    // SDIO mode interrupt received interrupt enable
            using RXDAVLIE = Field<21, 1>;    // Data available in Rx FIFO interrupt enable
            using TXDAVLIE = Field<20, 1>;    // Data available in Tx FIFO interrupt enable
            using RXFIFOEIE = Field<19, 1>;    // Rx FIFO empty interrupt enable
            using TXFIFOEIE = Field<18, 1>;    // Tx FIFO empty interrupt enable
            using RXFIFOFIE = Field<17, 1>;    // Rx FIFO full interrupt enable
            using TXFIFOFIE = Field<16, 1>;    // Tx FIFO full interrupt enable
            using RXFIFOHFIE = Field<15, 1>;    // Rx FIFO half full interrupt enable
            using TXFIFOHEIE = Field<14, 1>;    // Tx FIFO half empty interrupt enable
            using RXACTIE = Field<13, 1>;    // Data receive acting interrupt enable
            using TXACTIE = Field<12, 1>;    // Data transmit acting interrupt enable
            using CMDACTIE = Field<11, 1>;    // Command acting interrupt enable
            using DBCKENDIE = Field<10, 1>;    // Data block end interrupt enable
            using STBITERRIE = Field<9, 1>;    // Start bit error interrupt enable
            using DATAENDIE = Field<8, 1>;    // Data end interrupt enable
            using CMDSENTIE = Field<7, 1>;    // Command sent interrupt enable
            using CMDRENDIE = Field<6, 1>;    // Command response received interrupt enable
            using RXOVERRIE = Field<5, 1>;    // Rx FIFO overrun error interrupt enable
            using TXUNDERRIE = Field<4, 1>;    // Tx FIFO underrun error interrupt enable
            using DTIMEOUTIE = Field<3, 1>;    // Data timeout interrupt enable
            using CTIMEOUTIE = Field<2, 1>;    // Command timeout interrupt enable
            using DCRCFAILIE = Field<1, 1>;    // Data CRC fail interrupt enable
            using CCRCFAILIE = Field<0, 1>;    // Command CRC fail interrupt enable
        };

        // FIFO counter register
        struct FIFOCNT : public RegisterReadOnly<0x40012c48> {
            using FIFOCOUNT = Field<0, 24>;    // Remaining number of words to be written to or read from the FIFO
        };

        // data FIFO register
        struct FIFO : public Register<0x40012c80> {
            using FIFOData = Field<0, 32>;    // Receive and transmit FIFO data
        };

    };

    // Secure digital input/output interface
    struct SDMMC2 {
        // power control register
        struct POWER : public Register<0x40011c00> {
            using PWRCTRL = Field<0, 2>;    // PWRCTRL
        };

        // SDI clock control register
        struct CLKCR : public Register<0x40011c04> {
            using HWFC_EN = Field<14, 1>;    // HW Flow Control enable
            using NEGEDGE = Field<13, 1>;    // SDIO_CK dephasing selection bit
            using WIDBUS = Field<11, 2>;    // Wide bus mode enable bit
            using BYPASS = Field<10, 1>;    // Clock divider bypass enable bit
            using PWRSAV = Field<9, 1>;    // Power saving configuration bit
            using CLKEN = Field<8, 1>;    // Clock enable bit
            using CLKDIV = Field<0, 8>;    // Clock divide factor
        };

        // argument register
        struct ARG : public Register<0x40011c08> {
            using CMDARG = Field<0, 32>;    // Command argument
        };

        // command register
        struct CMD : public Register<0x40011c0c> {
            using CE_ATACMD = Field<14, 1>;    // CE-ATA command
            using nIEN = Field<13, 1>;    // not Interrupt Enable
            using ENCMDcompl = Field<12, 1>;    // Enable CMD completion
            using SDIOSuspend = Field<11, 1>;    // SD I/O suspend command
            using CPSMEN = Field<10, 1>;    // Command path state machine (CPSM) Enable bit
            using WAITPEND = Field<9, 1>;    // CPSM Waits for ends of data transfer (CmdPend internal signal)
            using WAITINT = Field<8, 1>;    // CPSM waits for interrupt request
            using WAITRESP = Field<6, 2>;    // Wait for response bits
            using CMDINDEX = Field<0, 6>;    // Command index
        };

        // command response register
        struct RESPCMD : public RegisterReadOnly<0x40011c10> {
            using Field = Field<0, 6>;    // Response command index
        };

        // response 1..4 register
        struct RESP1 : public RegisterReadOnly<0x40011c14> {
            using CARDSTATUS1 = Field<0, 32>;    // see Table 132
        };

        // response 1..4 register
        struct RESP2 : public RegisterReadOnly<0x40011c18> {
            using CARDSTATUS2 = Field<0, 32>;    // see Table 132
        };

        // response 1..4 register
        struct RESP3 : public RegisterReadOnly<0x40011c1c> {
            using CARDSTATUS3 = Field<0, 32>;    // see Table 132
        };

        // response 1..4 register
        struct RESP4 : public RegisterReadOnly<0x40011c20> {
            using CARDSTATUS4 = Field<0, 32>;    // see Table 132
        };

        // data timer register
        struct DTIMER : public Register<0x40011c24> {
            using DATATIME = Field<0, 32>;    // Data timeout period
        };

        // data length register
        struct DLEN : public Register<0x40011c28> {
            using DATALENGTH = Field<0, 25>;    // Data length value
        };

        // data control register
        struct DCTRL : public Register<0x40011c2c> {
            using SDIOEN = Field<11, 1>;    // SD I/O enable functions
            using RWMOD = Field<10, 1>;    // Read wait mode
            using RWSTOP = Field<9, 1>;    // Read wait stop
            using RWSTART = Field<8, 1>;    // Read wait start
            using DBLOCKSIZE = Field<4, 4>;    // Data block size
            using DMAEN = Field<3, 1>;    // DMA enable bit
            using DTMODE = Field<2, 1>;    // Data transfer mode selection 1: Stream or SDIO multibyte data transfer
            using DTDIR = Field<1, 1>;    // Data transfer direction selection
            using DTEN = Field<0, 1>;    // DTEN
        };

        // data counter register
        struct DCOUNT : public RegisterReadOnly<0x40011c30> {
            using DATACOUNT = Field<0, 25>;    // Data count value
        };

        // status register
        struct STA : public RegisterReadOnly<0x40011c34> {
            using CEATAEND = Field<23, 1>;    // CE-ATA command completion signal received for CMD61
            using SDIOIT = Field<22, 1>;    // SDIO interrupt received
            using RXDAVL = Field<21, 1>;    // Data available in receive FIFO
            using TXDAVL = Field<20, 1>;    // Data available in transmit FIFO
            using RXFIFOE = Field<19, 1>;    // Receive FIFO empty
            using TXFIFOE = Field<18, 1>;    // Transmit FIFO empty
            using RXFIFOF = Field<17, 1>;    // Receive FIFO full
            using TXFIFOF = Field<16, 1>;    // Transmit FIFO full
            using RXFIFOHF = Field<15, 1>;    // Receive FIFO half full: there are at least 8 words in the FIFO
            using TXFIFOHE = Field<14, 1>;    // Transmit FIFO half empty: at least 8 words can be written into the FIFO
            using RXACT = Field<13, 1>;    // Data receive in progress
            using TXACT = Field<12, 1>;    // Data transmit in progress
            using CMDACT = Field<11, 1>;    // Command transfer in progress
            using DBCKEND = Field<10, 1>;    // Data block sent/received (CRC check passed)
            using STBITERR = Field<9, 1>;    // Start bit not detected on all data signals in wide bus mode
            using DATAEND = Field<8, 1>;    // Data end (data counter, SDIDCOUNT, is zero)
            using CMDSENT = Field<7, 1>;    // Command sent (no response required)
            using CMDREND = Field<6, 1>;    // Command response received (CRC check passed)
            using RXOVERR = Field<5, 1>;    // Received FIFO overrun error
            using TXUNDERR = Field<4, 1>;    // Transmit FIFO underrun error
            using DTIMEOUT = Field<3, 1>;    // Data timeout
            using CTIMEOUT = Field<2, 1>;    // Command response timeout
            using DCRCFAIL = Field<1, 1>;    // Data block sent/received (CRC check failed)
            using CCRCFAIL = Field<0, 1>;    // Command response received (CRC check failed)
        };

        // interrupt clear register
        struct ICR : public Register<0x40011c38> {
            using CEATAENDC = Field<23, 1>;    // CEATAEND flag clear bit
            using SDIOITC = Field<22, 1>;    // SDIOIT flag clear bit
            using DBCKENDC = Field<10, 1>;    // DBCKEND flag clear bit
            using STBITERRC = Field<9, 1>;    // STBITERR flag clear bit
            using DATAENDC = Field<8, 1>;    // DATAEND flag clear bit
            using CMDSENTC = Field<7, 1>;    // CMDSENT flag clear bit
            using CMDRENDC = Field<6, 1>;    // CMDREND flag clear bit
            using RXOVERRC = Field<5, 1>;    // RXOVERR flag clear bit
            using TXUNDERRC = Field<4, 1>;    // TXUNDERR flag clear bit
            using DTIMEOUTC = Field<3, 1>;    // DTIMEOUT flag clear bit
            using CTIMEOUTC = Field<2, 1>;    // CTIMEOUT flag clear bit
            using DCRCFAILC = Field<1, 1>;    // DCRCFAIL flag clear bit
            using CCRCFAILC = Field<0, 1>;    // CCRCFAIL flag clear bit
        };

        // mask register
        struct MASK : public Register<0x40011c3c> {
            using CEATAENDIE = Field<23, 1>;    // CE-ATA command completion signal received interrupt enable
            using SDIOITIE = Field<22, 1>;    // SDIO mode interrupt received interrupt enable
            using RXDAVLIE = Field<21, 1>;    // Data available in Rx FIFO interrupt enable
            using TXDAVLIE = Field<20, 1>;    // Data available in Tx FIFO interrupt enable
            using RXFIFOEIE = Field<19, 1>;    // Rx FIFO empty interrupt enable
            using TXFIFOEIE = Field<18, 1>;    // Tx FIFO empty interrupt enable
            using RXFIFOFIE = Field<17, 1>;    // Rx FIFO full interrupt enable
            using TXFIFOFIE = Field<16, 1>;    // Tx FIFO full interrupt enable
            using RXFIFOHFIE = Field<15, 1>;    // Rx FIFO half full interrupt enable
            using TXFIFOHEIE = Field<14, 1>;    // Tx FIFO half empty interrupt enable
            using RXACTIE = Field<13, 1>;    // Data receive acting interrupt enable
            using TXACTIE = Field<12, 1>;    // Data transmit acting interrupt enable
            using CMDACTIE = Field<11, 1>;    // Command acting interrupt enable
            using DBCKENDIE = Field<10, 1>;    // Data block end interrupt enable
            using STBITERRIE = Field<9, 1>;    // Start bit error interrupt enable
            using DATAENDIE = Field<8, 1>;    // Data end interrupt enable
            using CMDSENTIE = Field<7, 1>;    // Command sent interrupt enable
            using CMDRENDIE = Field<6, 1>;    // Command response received interrupt enable
            using RXOVERRIE = Field<5, 1>;    // Rx FIFO overrun error interrupt enable
            using TXUNDERRIE = Field<4, 1>;    // Tx FIFO underrun error interrupt enable
            using DTIMEOUTIE = Field<3, 1>;    // Data timeout interrupt enable
            using CTIMEOUTIE = Field<2, 1>;    // Command timeout interrupt enable
            using DCRCFAILIE = Field<1, 1>;    // Data CRC fail interrupt enable
            using CCRCFAILIE = Field<0, 1>;    // Command CRC fail interrupt enable
        };

        // FIFO counter register
        struct FIFOCNT : public RegisterReadOnly<0x40011c48> {
            using FIFOCOUNT = Field<0, 24>;    // Remaining number of words to be written to or read from the FIFO
        };

        // data FIFO register
        struct FIFO : public Register<0x40011c80> {
            using FIFOData = Field<0, 32>;    // Receive and transmit FIFO data
        };

    };

    // Low power timer
    struct LPTIM1 {
        // Interrupt and Status Register
        struct ISR : public RegisterReadOnly<0x40002400> {
            using DOWN = Field<6, 1>;    // Counter direction change up to down
            using UP = Field<5, 1>;    // Counter direction change down to up
            using ARROK = Field<4, 1>;    // Autoreload register update OK
            using CMPOK = Field<3, 1>;    // Compare register update OK
            using EXTTRIG = Field<2, 1>;    // External trigger edge event
            using ARRM = Field<1, 1>;    // Autoreload match
            using CMPM = Field<0, 1>;    // Compare match
        };

        // Interrupt Clear Register
        struct ICR : public RegisterWriteOnly<0x40002404> {
            using DOWNCF = Field<6, 1>;    // Direction change to down Clear Flag
            using UPCF = Field<5, 1>;    // Direction change to UP Clear Flag
            using ARROKCF = Field<4, 1>;    // Autoreload register update OK Clear Flag
            using CMPOKCF = Field<3, 1>;    // Compare register update OK Clear Flag
            using EXTTRIGCF = Field<2, 1>;    // External trigger valid edge Clear Flag
            using ARRMCF = Field<1, 1>;    // Autoreload match Clear Flag
            using CMPMCF = Field<0, 1>;    // compare match Clear Flag
        };

        // Interrupt Enable Register
        struct IER : public Register<0x40002408> {
            using DOWNIE = Field<6, 1>;    // Direction change to down Interrupt Enable
            using UPIE = Field<5, 1>;    // Direction change to UP Interrupt Enable
            using ARROKIE = Field<4, 1>;    // Autoreload register update OK Interrupt Enable
            using CMPOKIE = Field<3, 1>;    // Compare register update OK Interrupt Enable
            using EXTTRIGIE = Field<2, 1>;    // External trigger valid edge Interrupt Enable
            using ARRMIE = Field<1, 1>;    // Autoreload match Interrupt Enable
            using CMPMIE = Field<0, 1>;    // Compare match Interrupt Enable
        };

        // Configuration Register
        struct CFGR : public Register<0x4000240c> {
            using ENC = Field<24, 1>;    // Encoder mode enable
            using COUNTMODE = Field<23, 1>;    // counter mode enabled
            using PRELOAD = Field<22, 1>;    // Registers update mode
            using WAVPOL = Field<21, 1>;    // Waveform shape polarity
            using WAVE = Field<20, 1>;    // Waveform shape
            using TIMOUT = Field<19, 1>;    // Timeout enable
            using TRIGEN = Field<17, 2>;    // Trigger enable and polarity
            using TRIGSEL = Field<13, 3>;    // Trigger selector
            using PRESC = Field<9, 3>;    // Clock prescaler
            using TRGFLT = Field<6, 2>;    // Configurable digital filter for trigger
            using CKFLT = Field<3, 2>;    // Configurable digital filter for external clock
            using CKPOL = Field<1, 2>;    // Clock Polarity
            using CKSEL = Field<0, 1>;    // Clock selector
        };

        // Control Register
        struct CR : public Register<0x40002410> {
            using CNTSTRT = Field<2, 1>;    // Timer start in continuous mode
            using SNGSTRT = Field<1, 1>;    // LPTIM start in single mode
            using ENABLE = Field<0, 1>;    // LPTIM Enable
        };

        // Compare Register
        struct CMP : public Register<0x40002414> {
            using Field = Field<0, 16>;    // Compare value
        };

        // Autoreload Register
        struct ARR : public Register<0x40002418> {
            using Field = Field<0, 16>;    // Auto reload value
        };

        // Counter Register
        struct CNT : public RegisterReadOnly<0x4000241c> {
            using Field = Field<0, 16>;    // Counter value
        };

    };

    // Inter-integrated circuit
    struct I2C1 {
        // Control register 1
        struct CR1 : public Register<0x40005400> {
            using PE = Field<0, 1>;    // Peripheral enable
            using TXIE = Field<1, 1>;    // TX Interrupt enable
            using RXIE = Field<2, 1>;    // RX Interrupt enable
            using ADDRIE = Field<3, 1>;    // Address match interrupt enable (slave only)
            using NACKIE = Field<4, 1>;    // Not acknowledge received interrupt enable
            using STOPIE = Field<5, 1>;    // STOP detection Interrupt enable
            using TCIE = Field<6, 1>;    // Transfer Complete interrupt enable
            using ERRIE = Field<7, 1>;    // Error interrupts enable
            using DNF = Field<8, 4>;    // Digital noise filter
            using ANFOFF = Field<12, 1>;    // Analog noise filter OFF
            using TXDMAEN = Field<14, 1>;    // DMA transmission requests enable
            using RXDMAEN = Field<15, 1>;    // DMA reception requests enable
            using SBC = Field<16, 1>;    // Slave byte control
            using NOSTRETCH = Field<17, 1>;    // Clock stretching disable
            using WUPEN = Field<18, 1>;    // Wakeup from STOP enable
            using GCEN = Field<19, 1>;    // General call enable
            using SMBHEN = Field<20, 1>;    // SMBus Host address enable
            using SMBDEN = Field<21, 1>;    // SMBus Device Default address enable
            using ALERTEN = Field<22, 1>;    // SMBUS alert enable
            using PECEN = Field<23, 1>;    // PEC enable
        };

        // Control register 2
        struct CR2 : public Register<0x40005404> {
            using PECBYTE = Field<26, 1>;    // Packet error checking byte
            using AUTOEND = Field<25, 1>;    // Automatic end mode (master mode)
            using RELOAD = Field<24, 1>;    // NBYTES reload mode
            using NBYTES = Field<16, 8>;    // Number of bytes
            using NACK = Field<15, 1>;    // NACK generation (slave mode)
            using STOP = Field<14, 1>;    // Stop generation (master mode)
            using START = Field<13, 1>;    // Start generation
            using HEAD10R = Field<12, 1>;    // 10-bit address header only read direction (master receiver mode)
            using ADD10 = Field<11, 1>;    // 10-bit addressing mode (master mode)
            using RD_WRN = Field<10, 1>;    // Transfer direction (master mode)
            using SADD = Field<0, 10>;    // Slave address bit (master mode)
        };

        // Own address register 1
        struct OAR1 : public Register<0x40005408> {
            using OA1 = Field<0, 10>;    // Interface address
            using OA1MODE = Field<10, 1>;    // Own Address 1 10-bit mode
            using OA1EN = Field<15, 1>;    // Own Address 1 enable
        };

        // Own address register 2
        struct OAR2 : public Register<0x4000540c> {
            using OA2 = Field<1, 7>;    // Interface address
            using OA2MSK = Field<8, 3>;    // Own Address 2 masks
            using OA2EN = Field<15, 1>;    // Own Address 2 enable
        };

        // Timing register
        struct TIMINGR : public Register<0x40005410> {
            using SCLL = Field<0, 8>;    // SCL low period (master mode)
            using SCLH = Field<8, 8>;    // SCL high period (master mode)
            using SDADEL = Field<16, 4>;    // Data hold time
            using SCLDEL = Field<20, 4>;    // Data setup time
            using PRESC = Field<28, 4>;    // Timing prescaler
        };

        // Status register 1
        struct TIMEOUTR : public Register<0x40005414> {
            using TIMEOUTA = Field<0, 12>;    // Bus timeout A
            using TIDLE = Field<12, 1>;    // Idle clock timeout detection
            using TIMOUTEN = Field<15, 1>;    // Clock timeout enable
            using TIMEOUTB = Field<16, 12>;    // Bus timeout B
            using TEXTEN = Field<31, 1>;    // Extended clock timeout enable
        };

        // Interrupt and Status register
        struct ISR : public Register<0x40005418> {
            using ADDCODE = Field<17, 7>;    // Address match code (Slave mode)
            using DIR = Field<16, 1>;    // Transfer direction (Slave mode)
            using BUSY = Field<15, 1>;    // Bus busy
            using ALERT = Field<13, 1>;    // SMBus alert
            using TIMEOUT = Field<12, 1>;    // Timeout or t_low detection flag
            using PECERR = Field<11, 1>;    // PEC Error in reception
            using OVR = Field<10, 1>;    // Overrun/Underrun (slave mode)
            using ARLO = Field<9, 1>;    // Arbitration lost
            using BERR = Field<8, 1>;    // Bus error
            using TCR = Field<7, 1>;    // Transfer Complete Reload
            using TC = Field<6, 1>;    // Transfer Complete (master mode)
            using STOPF = Field<5, 1>;    // Stop detection flag
            using NACKF = Field<4, 1>;    // Not acknowledge received flag
            using ADDR = Field<3, 1>;    // Address matched (slave mode)
            using RXNE = Field<2, 1>;    // Receive data register not empty (receivers)
            using TXIS = Field<1, 1>;    // Transmit interrupt status (transmitters)
            using TXE = Field<0, 1>;    // Transmit data register empty (transmitters)
        };

        // Interrupt clear register
        struct ICR : public RegisterWriteOnly<0x4000541c> {
            using ALERTCF = Field<13, 1>;    // Alert flag clear
            using TIMOUTCF = Field<12, 1>;    // Timeout detection flag clear
            using PECCF = Field<11, 1>;    // PEC Error flag clear
            using OVRCF = Field<10, 1>;    // Overrun/Underrun flag clear
            using ARLOCF = Field<9, 1>;    // Arbitration lost flag clear
            using BERRCF = Field<8, 1>;    // Bus error flag clear
            using STOPCF = Field<5, 1>;    // Stop detection flag clear
            using NACKCF = Field<4, 1>;    // Not Acknowledge flag clear
            using ADDRCF = Field<3, 1>;    // Address Matched flag clear
        };

        // PEC register
        struct PECR : public RegisterReadOnly<0x40005420> {
            using PEC = Field<0, 8>;    // Packet error checking register
        };

        // Receive data register
        struct RXDR : public RegisterReadOnly<0x40005424> {
            using RXDATA = Field<0, 8>;    // 8-bit receive data
        };

        // Transmit data register
        struct TXDR : public Register<0x40005428> {
            using TXDATA = Field<0, 8>;    // 8-bit transmit data
        };

    };

    // Inter-integrated circuit
    struct I2C2 {
        // Control register 1
        struct CR1 : public Register<0x40005800> {
            using PE = Field<0, 1>;    // Peripheral enable
            using TXIE = Field<1, 1>;    // TX Interrupt enable
            using RXIE = Field<2, 1>;    // RX Interrupt enable
            using ADDRIE = Field<3, 1>;    // Address match interrupt enable (slave only)
            using NACKIE = Field<4, 1>;    // Not acknowledge received interrupt enable
            using STOPIE = Field<5, 1>;    // STOP detection Interrupt enable
            using TCIE = Field<6, 1>;    // Transfer Complete interrupt enable
            using ERRIE = Field<7, 1>;    // Error interrupts enable
            using DNF = Field<8, 4>;    // Digital noise filter
            using ANFOFF = Field<12, 1>;    // Analog noise filter OFF
            using TXDMAEN = Field<14, 1>;    // DMA transmission requests enable
            using RXDMAEN = Field<15, 1>;    // DMA reception requests enable
            using SBC = Field<16, 1>;    // Slave byte control
            using NOSTRETCH = Field<17, 1>;    // Clock stretching disable
            using WUPEN = Field<18, 1>;    // Wakeup from STOP enable
            using GCEN = Field<19, 1>;    // General call enable
            using SMBHEN = Field<20, 1>;    // SMBus Host address enable
            using SMBDEN = Field<21, 1>;    // SMBus Device Default address enable
            using ALERTEN = Field<22, 1>;    // SMBUS alert enable
            using PECEN = Field<23, 1>;    // PEC enable
        };

        // Control register 2
        struct CR2 : public Register<0x40005804> {
            using PECBYTE = Field<26, 1>;    // Packet error checking byte
            using AUTOEND = Field<25, 1>;    // Automatic end mode (master mode)
            using RELOAD = Field<24, 1>;    // NBYTES reload mode
            using NBYTES = Field<16, 8>;    // Number of bytes
            using NACK = Field<15, 1>;    // NACK generation (slave mode)
            using STOP = Field<14, 1>;    // Stop generation (master mode)
            using START = Field<13, 1>;    // Start generation
            using HEAD10R = Field<12, 1>;    // 10-bit address header only read direction (master receiver mode)
            using ADD10 = Field<11, 1>;    // 10-bit addressing mode (master mode)
            using RD_WRN = Field<10, 1>;    // Transfer direction (master mode)
            using SADD = Field<0, 10>;    // Slave address bit (master mode)
        };

        // Own address register 1
        struct OAR1 : public Register<0x40005808> {
            using OA1 = Field<0, 10>;    // Interface address
            using OA1MODE = Field<10, 1>;    // Own Address 1 10-bit mode
            using OA1EN = Field<15, 1>;    // Own Address 1 enable
        };

        // Own address register 2
        struct OAR2 : public Register<0x4000580c> {
            using OA2 = Field<1, 7>;    // Interface address
            using OA2MSK = Field<8, 3>;    // Own Address 2 masks
            using OA2EN = Field<15, 1>;    // Own Address 2 enable
        };

        // Timing register
        struct TIMINGR : public Register<0x40005810> {
            using SCLL = Field<0, 8>;    // SCL low period (master mode)
            using SCLH = Field<8, 8>;    // SCL high period (master mode)
            using SDADEL = Field<16, 4>;    // Data hold time
            using SCLDEL = Field<20, 4>;    // Data setup time
            using PRESC = Field<28, 4>;    // Timing prescaler
        };

        // Status register 1
        struct TIMEOUTR : public Register<0x40005814> {
            using TIMEOUTA = Field<0, 12>;    // Bus timeout A
            using TIDLE = Field<12, 1>;    // Idle clock timeout detection
            using TIMOUTEN = Field<15, 1>;    // Clock timeout enable
            using TIMEOUTB = Field<16, 12>;    // Bus timeout B
            using TEXTEN = Field<31, 1>;    // Extended clock timeout enable
        };

        // Interrupt and Status register
        struct ISR : public Register<0x40005818> {
            using ADDCODE = Field<17, 7>;    // Address match code (Slave mode)
            using DIR = Field<16, 1>;    // Transfer direction (Slave mode)
            using BUSY = Field<15, 1>;    // Bus busy
            using ALERT = Field<13, 1>;    // SMBus alert
            using TIMEOUT = Field<12, 1>;    // Timeout or t_low detection flag
            using PECERR = Field<11, 1>;    // PEC Error in reception
            using OVR = Field<10, 1>;    // Overrun/Underrun (slave mode)
            using ARLO = Field<9, 1>;    // Arbitration lost
            using BERR = Field<8, 1>;    // Bus error
            using TCR = Field<7, 1>;    // Transfer Complete Reload
            using TC = Field<6, 1>;    // Transfer Complete (master mode)
            using STOPF = Field<5, 1>;    // Stop detection flag
            using NACKF = Field<4, 1>;    // Not acknowledge received flag
            using ADDR = Field<3, 1>;    // Address matched (slave mode)
            using RXNE = Field<2, 1>;    // Receive data register not empty (receivers)
            using TXIS = Field<1, 1>;    // Transmit interrupt status (transmitters)
            using TXE = Field<0, 1>;    // Transmit data register empty (transmitters)
        };

        // Interrupt clear register
        struct ICR : public RegisterWriteOnly<0x4000581c> {
            using ALERTCF = Field<13, 1>;    // Alert flag clear
            using TIMOUTCF = Field<12, 1>;    // Timeout detection flag clear
            using PECCF = Field<11, 1>;    // PEC Error flag clear
            using OVRCF = Field<10, 1>;    // Overrun/Underrun flag clear
            using ARLOCF = Field<9, 1>;    // Arbitration lost flag clear
            using BERRCF = Field<8, 1>;    // Bus error flag clear
            using STOPCF = Field<5, 1>;    // Stop detection flag clear
            using NACKCF = Field<4, 1>;    // Not Acknowledge flag clear
            using ADDRCF = Field<3, 1>;    // Address Matched flag clear
        };

        // PEC register
        struct PECR : public RegisterReadOnly<0x40005820> {
            using PEC = Field<0, 8>;    // Packet error checking register
        };

        // Receive data register
        struct RXDR : public RegisterReadOnly<0x40005824> {
            using RXDATA = Field<0, 8>;    // 8-bit receive data
        };

        // Transmit data register
        struct TXDR : public Register<0x40005828> {
            using TXDATA = Field<0, 8>;    // 8-bit transmit data
        };

    };

    // Inter-integrated circuit
    struct I2C3 {
        // Control register 1
        struct CR1 : public Register<0x40005c00> {
            using PE = Field<0, 1>;    // Peripheral enable
            using TXIE = Field<1, 1>;    // TX Interrupt enable
            using RXIE = Field<2, 1>;    // RX Interrupt enable
            using ADDRIE = Field<3, 1>;    // Address match interrupt enable (slave only)
            using NACKIE = Field<4, 1>;    // Not acknowledge received interrupt enable
            using STOPIE = Field<5, 1>;    // STOP detection Interrupt enable
            using TCIE = Field<6, 1>;    // Transfer Complete interrupt enable
            using ERRIE = Field<7, 1>;    // Error interrupts enable
            using DNF = Field<8, 4>;    // Digital noise filter
            using ANFOFF = Field<12, 1>;    // Analog noise filter OFF
            using TXDMAEN = Field<14, 1>;    // DMA transmission requests enable
            using RXDMAEN = Field<15, 1>;    // DMA reception requests enable
            using SBC = Field<16, 1>;    // Slave byte control
            using NOSTRETCH = Field<17, 1>;    // Clock stretching disable
            using WUPEN = Field<18, 1>;    // Wakeup from STOP enable
            using GCEN = Field<19, 1>;    // General call enable
            using SMBHEN = Field<20, 1>;    // SMBus Host address enable
            using SMBDEN = Field<21, 1>;    // SMBus Device Default address enable
            using ALERTEN = Field<22, 1>;    // SMBUS alert enable
            using PECEN = Field<23, 1>;    // PEC enable
        };

        // Control register 2
        struct CR2 : public Register<0x40005c04> {
            using PECBYTE = Field<26, 1>;    // Packet error checking byte
            using AUTOEND = Field<25, 1>;    // Automatic end mode (master mode)
            using RELOAD = Field<24, 1>;    // NBYTES reload mode
            using NBYTES = Field<16, 8>;    // Number of bytes
            using NACK = Field<15, 1>;    // NACK generation (slave mode)
            using STOP = Field<14, 1>;    // Stop generation (master mode)
            using START = Field<13, 1>;    // Start generation
            using HEAD10R = Field<12, 1>;    // 10-bit address header only read direction (master receiver mode)
            using ADD10 = Field<11, 1>;    // 10-bit addressing mode (master mode)
            using RD_WRN = Field<10, 1>;    // Transfer direction (master mode)
            using SADD = Field<0, 10>;    // Slave address bit (master mode)
        };

        // Own address register 1
        struct OAR1 : public Register<0x40005c08> {
            using OA1 = Field<0, 10>;    // Interface address
            using OA1MODE = Field<10, 1>;    // Own Address 1 10-bit mode
            using OA1EN = Field<15, 1>;    // Own Address 1 enable
        };

        // Own address register 2
        struct OAR2 : public Register<0x40005c0c> {
            using OA2 = Field<1, 7>;    // Interface address
            using OA2MSK = Field<8, 3>;    // Own Address 2 masks
            using OA2EN = Field<15, 1>;    // Own Address 2 enable
        };

        // Timing register
        struct TIMINGR : public Register<0x40005c10> {
            using SCLL = Field<0, 8>;    // SCL low period (master mode)
            using SCLH = Field<8, 8>;    // SCL high period (master mode)
            using SDADEL = Field<16, 4>;    // Data hold time
            using SCLDEL = Field<20, 4>;    // Data setup time
            using PRESC = Field<28, 4>;    // Timing prescaler
        };

        // Status register 1
        struct TIMEOUTR : public Register<0x40005c14> {
            using TIMEOUTA = Field<0, 12>;    // Bus timeout A
            using TIDLE = Field<12, 1>;    // Idle clock timeout detection
            using TIMOUTEN = Field<15, 1>;    // Clock timeout enable
            using TIMEOUTB = Field<16, 12>;    // Bus timeout B
            using TEXTEN = Field<31, 1>;    // Extended clock timeout enable
        };

        // Interrupt and Status register
        struct ISR : public Register<0x40005c18> {
            using ADDCODE = Field<17, 7>;    // Address match code (Slave mode)
            using DIR = Field<16, 1>;    // Transfer direction (Slave mode)
            using BUSY = Field<15, 1>;    // Bus busy
            using ALERT = Field<13, 1>;    // SMBus alert
            using TIMEOUT = Field<12, 1>;    // Timeout or t_low detection flag
            using PECERR = Field<11, 1>;    // PEC Error in reception
            using OVR = Field<10, 1>;    // Overrun/Underrun (slave mode)
            using ARLO = Field<9, 1>;    // Arbitration lost
            using BERR = Field<8, 1>;    // Bus error
            using TCR = Field<7, 1>;    // Transfer Complete Reload
            using TC = Field<6, 1>;    // Transfer Complete (master mode)
            using STOPF = Field<5, 1>;    // Stop detection flag
            using NACKF = Field<4, 1>;    // Not acknowledge received flag
            using ADDR = Field<3, 1>;    // Address matched (slave mode)
            using RXNE = Field<2, 1>;    // Receive data register not empty (receivers)
            using TXIS = Field<1, 1>;    // Transmit interrupt status (transmitters)
            using TXE = Field<0, 1>;    // Transmit data register empty (transmitters)
        };

        // Interrupt clear register
        struct ICR : public RegisterWriteOnly<0x40005c1c> {
            using ALERTCF = Field<13, 1>;    // Alert flag clear
            using TIMOUTCF = Field<12, 1>;    // Timeout detection flag clear
            using PECCF = Field<11, 1>;    // PEC Error flag clear
            using OVRCF = Field<10, 1>;    // Overrun/Underrun flag clear
            using ARLOCF = Field<9, 1>;    // Arbitration lost flag clear
            using BERRCF = Field<8, 1>;    // Bus error flag clear
            using STOPCF = Field<5, 1>;    // Stop detection flag clear
            using NACKCF = Field<4, 1>;    // Not Acknowledge flag clear
            using ADDRCF = Field<3, 1>;    // Address Matched flag clear
        };

        // PEC register
        struct PECR : public RegisterReadOnly<0x40005c20> {
            using PEC = Field<0, 8>;    // Packet error checking register
        };

        // Receive data register
        struct RXDR : public RegisterReadOnly<0x40005c24> {
            using RXDATA = Field<0, 8>;    // 8-bit receive data
        };

        // Transmit data register
        struct TXDR : public Register<0x40005c28> {
            using TXDATA = Field<0, 8>;    // 8-bit transmit data
        };

    };

    // Inter-integrated circuit
    struct I2C4 {
        // Control register 1
        struct CR1 : public Register<0x40006000> {
            using PE = Field<0, 1>;    // Peripheral enable
            using TXIE = Field<1, 1>;    // TX Interrupt enable
            using RXIE = Field<2, 1>;    // RX Interrupt enable
            using ADDRIE = Field<3, 1>;    // Address match interrupt enable (slave only)
            using NACKIE = Field<4, 1>;    // Not acknowledge received interrupt enable
            using STOPIE = Field<5, 1>;    // STOP detection Interrupt enable
            using TCIE = Field<6, 1>;    // Transfer Complete interrupt enable
            using ERRIE = Field<7, 1>;    // Error interrupts enable
            using DNF = Field<8, 4>;    // Digital noise filter
            using ANFOFF = Field<12, 1>;    // Analog noise filter OFF
            using TXDMAEN = Field<14, 1>;    // DMA transmission requests enable
            using RXDMAEN = Field<15, 1>;    // DMA reception requests enable
            using SBC = Field<16, 1>;    // Slave byte control
            using NOSTRETCH = Field<17, 1>;    // Clock stretching disable
            using WUPEN = Field<18, 1>;    // Wakeup from STOP enable
            using GCEN = Field<19, 1>;    // General call enable
            using SMBHEN = Field<20, 1>;    // SMBus Host address enable
            using SMBDEN = Field<21, 1>;    // SMBus Device Default address enable
            using ALERTEN = Field<22, 1>;    // SMBUS alert enable
            using PECEN = Field<23, 1>;    // PEC enable
        };

        // Control register 2
        struct CR2 : public Register<0x40006004> {
            using PECBYTE = Field<26, 1>;    // Packet error checking byte
            using AUTOEND = Field<25, 1>;    // Automatic end mode (master mode)
            using RELOAD = Field<24, 1>;    // NBYTES reload mode
            using NBYTES = Field<16, 8>;    // Number of bytes
            using NACK = Field<15, 1>;    // NACK generation (slave mode)
            using STOP = Field<14, 1>;    // Stop generation (master mode)
            using START = Field<13, 1>;    // Start generation
            using HEAD10R = Field<12, 1>;    // 10-bit address header only read direction (master receiver mode)
            using ADD10 = Field<11, 1>;    // 10-bit addressing mode (master mode)
            using RD_WRN = Field<10, 1>;    // Transfer direction (master mode)
            using SADD = Field<0, 10>;    // Slave address bit (master mode)
        };

        // Own address register 1
        struct OAR1 : public Register<0x40006008> {
            using OA1 = Field<0, 10>;    // Interface address
            using OA1MODE = Field<10, 1>;    // Own Address 1 10-bit mode
            using OA1EN = Field<15, 1>;    // Own Address 1 enable
        };

        // Own address register 2
        struct OAR2 : public Register<0x4000600c> {
            using OA2 = Field<1, 7>;    // Interface address
            using OA2MSK = Field<8, 3>;    // Own Address 2 masks
            using OA2EN = Field<15, 1>;    // Own Address 2 enable
        };

        // Timing register
        struct TIMINGR : public Register<0x40006010> {
            using SCLL = Field<0, 8>;    // SCL low period (master mode)
            using SCLH = Field<8, 8>;    // SCL high period (master mode)
            using SDADEL = Field<16, 4>;    // Data hold time
            using SCLDEL = Field<20, 4>;    // Data setup time
            using PRESC = Field<28, 4>;    // Timing prescaler
        };

        // Status register 1
        struct TIMEOUTR : public Register<0x40006014> {
            using TIMEOUTA = Field<0, 12>;    // Bus timeout A
            using TIDLE = Field<12, 1>;    // Idle clock timeout detection
            using TIMOUTEN = Field<15, 1>;    // Clock timeout enable
            using TIMEOUTB = Field<16, 12>;    // Bus timeout B
            using TEXTEN = Field<31, 1>;    // Extended clock timeout enable
        };

        // Interrupt and Status register
        struct ISR : public Register<0x40006018> {
            using ADDCODE = Field<17, 7>;    // Address match code (Slave mode)
            using DIR = Field<16, 1>;    // Transfer direction (Slave mode)
            using BUSY = Field<15, 1>;    // Bus busy
            using ALERT = Field<13, 1>;    // SMBus alert
            using TIMEOUT = Field<12, 1>;    // Timeout or t_low detection flag
            using PECERR = Field<11, 1>;    // PEC Error in reception
            using OVR = Field<10, 1>;    // Overrun/Underrun (slave mode)
            using ARLO = Field<9, 1>;    // Arbitration lost
            using BERR = Field<8, 1>;    // Bus error
            using TCR = Field<7, 1>;    // Transfer Complete Reload
            using TC = Field<6, 1>;    // Transfer Complete (master mode)
            using STOPF = Field<5, 1>;    // Stop detection flag
            using NACKF = Field<4, 1>;    // Not acknowledge received flag
            using ADDR = Field<3, 1>;    // Address matched (slave mode)
            using RXNE = Field<2, 1>;    // Receive data register not empty (receivers)
            using TXIS = Field<1, 1>;    // Transmit interrupt status (transmitters)
            using TXE = Field<0, 1>;    // Transmit data register empty (transmitters)
        };

        // Interrupt clear register
        struct ICR : public RegisterWriteOnly<0x4000601c> {
            using ALERTCF = Field<13, 1>;    // Alert flag clear
            using TIMOUTCF = Field<12, 1>;    // Timeout detection flag clear
            using PECCF = Field<11, 1>;    // PEC Error flag clear
            using OVRCF = Field<10, 1>;    // Overrun/Underrun flag clear
            using ARLOCF = Field<9, 1>;    // Arbitration lost flag clear
            using BERRCF = Field<8, 1>;    // Bus error flag clear
            using STOPCF = Field<5, 1>;    // Stop detection flag clear
            using NACKCF = Field<4, 1>;    // Not Acknowledge flag clear
            using ADDRCF = Field<3, 1>;    // Address Matched flag clear
        };

        // PEC register
        struct PECR : public RegisterReadOnly<0x40006020> {
            using PEC = Field<0, 8>;    // Packet error checking register
        };

        // Receive data register
        struct RXDR : public RegisterReadOnly<0x40006024> {
            using RXDATA = Field<0, 8>;    // 8-bit receive data
        };

        // Transmit data register
        struct TXDR : public Register<0x40006028> {
            using TXDATA = Field<0, 8>;    // 8-bit transmit data
        };

    };

    // Real-time clock
    struct RTC {
        // time register
        struct TR : public Register<0x40002800> {
            using PM = Field<22, 1>;    // AM/PM notation
            using HT = Field<20, 2>;    // Hour tens in BCD format
            using HU = Field<16, 4>;    // Hour units in BCD format
            using MNT = Field<12, 3>;    // Minute tens in BCD format
            using MNU = Field<8, 4>;    // Minute units in BCD format
            using ST = Field<4, 3>;    // Second tens in BCD format
            using SU = Field<0, 4>;    // Second units in BCD format
        };

        // date register
        struct DR : public Register<0x40002804> {
            using YT = Field<20, 4>;    // Year tens in BCD format
            using YU = Field<16, 4>;    // Year units in BCD format
            using WDU = Field<13, 3>;    // Week day units
            using MT = Field<12, 1>;    // Month tens in BCD format
            using MU = Field<8, 4>;    // Month units in BCD format
            using DT = Field<4, 2>;    // Date tens in BCD format
            using DU = Field<0, 4>;    // Date units in BCD format
        };

        // control register
        struct CR : public Register<0x40002808> {
            using WCKSEL = Field<0, 3>;    // Wakeup clock selection
            using TSEDGE = Field<3, 1>;    // Time-stamp event active edge
            using REFCKON = Field<4, 1>;    // Reference clock detection enable (50 or 60 Hz)
            using BYPSHAD = Field<5, 1>;    // Bypass the shadow registers
            using FMT = Field<6, 1>;    // Hour format
            using ALRAE = Field<8, 1>;    // Alarm A enable
            using ALRBE = Field<9, 1>;    // Alarm B enable
            using WUTE = Field<10, 1>;    // Wakeup timer enable
            using TSE = Field<11, 1>;    // Time stamp enable
            using ALRAIE = Field<12, 1>;    // Alarm A interrupt enable
            using ALRBIE = Field<13, 1>;    // Alarm B interrupt enable
            using WUTIE = Field<14, 1>;    // Wakeup timer interrupt enable
            using TSIE = Field<15, 1>;    // Time-stamp interrupt enable
            using ADD1H = Field<16, 1>;    // Add 1 hour (summer time change)
            using SUB1H = Field<17, 1>;    // Subtract 1 hour (winter time change)
            using BKP = Field<18, 1>;    // Backup
            using COSEL = Field<19, 1>;    // Calibration output selection
            using POL = Field<20, 1>;    // Output polarity
            using OSEL = Field<21, 2>;    // Output selection
            using COE = Field<23, 1>;    // Calibration output enable
            using ITSE = Field<24, 1>;    // timestamp on internal event enable
        };

        // initialization and status register
        struct ISR : public Register<0x4000280c> {
            using ALRAWF = Field<0, 1>;    // Alarm A write flag
            using ALRBWF = Field<1, 1>;    // Alarm B write flag
            using WUTWF = Field<2, 1>;    // Wakeup timer write flag
            using SHPF = Field<3, 1>;    // Shift operation pending
            using INITS = Field<4, 1>;    // Initialization status flag
            using RSF = Field<5, 1>;    // Registers synchronization flag
            using INITF = Field<6, 1>;    // Initialization flag
            using INIT = Field<7, 1>;    // Initialization mode
            using ALRAF = Field<8, 1>;    // Alarm A flag
            using ALRBF = Field<9, 1>;    // Alarm B flag
            using WUTF = Field<10, 1>;    // Wakeup timer flag
            using TSF = Field<11, 1>;    // Time-stamp flag
            using TSOVF = Field<12, 1>;    // Time-stamp overflow flag
            using TAMP1F = Field<13, 1>;    // Tamper detection flag
            using TAMP2F = Field<14, 1>;    // RTC_TAMP2 detection flag
            using TAMP3F = Field<15, 1>;    // RTC_TAMP3 detection flag
            using RECALPF = Field<16, 1>;    // Recalibration pending Flag
        };

        // prescaler register
        struct PRER : public Register<0x40002810> {
            using PREDIV_A = Field<16, 7>;    // Asynchronous prescaler factor
            using PREDIV_S = Field<0, 15>;    // Synchronous prescaler factor
        };

        // wakeup timer register
        struct WUTR : public Register<0x40002814> {
            using WUT = Field<0, 16>;    // Wakeup auto-reload value bits
        };

        // alarm A register
        struct ALRMAR : public Register<0x4000281c> {
            using MSK4 = Field<31, 1>;    // Alarm A date mask
            using WDSEL = Field<30, 1>;    // Week day selection
            using DT = Field<28, 2>;    // Date tens in BCD format
            using DU = Field<24, 4>;    // Date units or day in BCD format
            using MSK3 = Field<23, 1>;    // Alarm A hours mask
            using PM = Field<22, 1>;    // AM/PM notation
            using HT = Field<20, 2>;    // Hour tens in BCD format
            using HU = Field<16, 4>;    // Hour units in BCD format
            using MSK2 = Field<15, 1>;    // Alarm A minutes mask
            using MNT = Field<12, 3>;    // Minute tens in BCD format
            using MNU = Field<8, 4>;    // Minute units in BCD format
            using MSK1 = Field<7, 1>;    // Alarm A seconds mask
            using ST = Field<4, 3>;    // Second tens in BCD format
            using SU = Field<0, 4>;    // Second units in BCD format
        };

        // alarm B register
        struct ALRMBR : public Register<0x40002820> {
            using MSK4 = Field<31, 1>;    // Alarm B date mask
            using WDSEL = Field<30, 1>;    // Week day selection
            using DT = Field<28, 2>;    // Date tens in BCD format
            using DU = Field<24, 4>;    // Date units or day in BCD format
            using MSK3 = Field<23, 1>;    // Alarm B hours mask
            using PM = Field<22, 1>;    // AM/PM notation
            using HT = Field<20, 2>;    // Hour tens in BCD format
            using HU = Field<16, 4>;    // Hour units in BCD format
            using MSK2 = Field<15, 1>;    // Alarm B minutes mask
            using MNT = Field<12, 3>;    // Minute tens in BCD format
            using MNU = Field<8, 4>;    // Minute units in BCD format
            using MSK1 = Field<7, 1>;    // Alarm B seconds mask
            using ST = Field<4, 3>;    // Second tens in BCD format
            using SU = Field<0, 4>;    // Second units in BCD format
        };

        // write protection register
        struct WPR : public RegisterWriteOnly<0x40002824> {
            using KEY = Field<0, 8>;    // Write protection key
        };

        // sub second register
        struct SSR : public RegisterReadOnly<0x40002828> {
            using SS = Field<0, 16>;    // Sub second value
        };

        // shift control register
        struct SHIFTR : public RegisterWriteOnly<0x4000282c> {
            using ADD1S = Field<31, 1>;    // Add one second
            using SUBFS = Field<0, 15>;    // Subtract a fraction of a second
        };

        // time stamp time register
        struct TSTR : public RegisterReadOnly<0x40002830> {
            using SU = Field<0, 4>;    // Second units in BCD format
            using ST = Field<4, 3>;    // Second tens in BCD format
            using MNU = Field<8, 4>;    // Minute units in BCD format
            using MNT = Field<12, 3>;    // Minute tens in BCD format
            using HU = Field<16, 4>;    // Hour units in BCD format
            using HT = Field<20, 2>;    // Hour tens in BCD format
            using PM = Field<22, 1>;    // AM/PM notation
        };

        // time stamp date register
        struct TSDR : public RegisterReadOnly<0x40002834> {
            using WDU = Field<13, 3>;    // Week day units
            using MT = Field<12, 1>;    // Month tens in BCD format
            using MU = Field<8, 4>;    // Month units in BCD format
            using DT = Field<4, 2>;    // Date tens in BCD format
            using DU = Field<0, 4>;    // Date units in BCD format
        };

        // timestamp sub second register
        struct TSSSR : public RegisterReadOnly<0x40002838> {
            using SS = Field<0, 16>;    // Sub second value
        };

        // calibration register
        struct CALR : public Register<0x4000283c> {
            using CALP = Field<15, 1>;    // Increase frequency of RTC by 488.5 ppm
            using CALW8 = Field<14, 1>;    // Use an 8-second calibration cycle period
            using CALW16 = Field<13, 1>;    // Use a 16-second calibration cycle period
            using CALM = Field<0, 9>;    // Calibration minus
        };

        // tamper configuration register
        struct TAMPCR : public Register<0x40002840> {
            using TAMP1E = Field<0, 1>;    // Tamper 1 detection enable
            using TAMP1TRG = Field<1, 1>;    // Active level for tamper 1
            using TAMPIE = Field<2, 1>;    // Tamper interrupt enable
            using TAMP2E = Field<3, 1>;    // Tamper 2 detection enable
            using TAMP2TRG = Field<4, 1>;    // Active level for tamper 2
            using TAMP3E = Field<5, 1>;    // Tamper 3 detection enable
            using TAMP3TRG = Field<6, 1>;    // Active level for tamper 3
            using TAMPTS = Field<7, 1>;    // Activate timestamp on tamper detection event
            using TAMPFREQ = Field<8, 3>;    // Tamper sampling frequency
            using TAMPFLT = Field<11, 2>;    // Tamper filter count
            using TAMPPRCH = Field<13, 2>;    // Tamper precharge duration
            using TAMPPUDIS = Field<15, 1>;    // TAMPER pull-up disable
            using TAMP1IE = Field<16, 1>;    // Tamper 1 interrupt enable
            using TAMP1NOERASE = Field<17, 1>;    // Tamper 1 no erase
            using TAMP1MF = Field<18, 1>;    // Tamper 1 mask flag
            using TAMP2IE = Field<19, 1>;    // Tamper 2 interrupt enable
            using TAMP2NOERASE = Field<20, 1>;    // Tamper 2 no erase
            using TAMP2MF = Field<21, 1>;    // Tamper 2 mask flag
            using TAMP3IE = Field<22, 1>;    // Tamper 3 interrupt enable
            using TAMP3NOERASE = Field<23, 1>;    // Tamper 3 no erase
            using TAMP3MF = Field<24, 1>;    // Tamper 3 mask flag
        };

        // alarm A sub second register
        struct ALRMASSR : public Register<0x40002844> {
            using MASKSS = Field<24, 4>;    // Mask the most-significant bits starting at this bit
            using SS = Field<0, 15>;    // Sub seconds value
        };

        // alarm B sub second register
        struct ALRMBSSR : public Register<0x40002848> {
            using MASKSS = Field<24, 4>;    // Mask the most-significant bits starting at this bit
            using SS = Field<0, 15>;    // Sub seconds value
        };

        // option register
        struct OR : public Register<0x4000284c> {
            using RTC_ALARM_TYPE = Field<0, 1>;    // RTC_ALARM on PC13 output type
            using RTC_OUT_RMP = Field<1, 1>;    // RTC_OUT remap
        };

        // backup register
        struct BKP0R : public Register<0x40002850> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP1R : public Register<0x40002854> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP2R : public Register<0x40002858> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP3R : public Register<0x4000285c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP4R : public Register<0x40002860> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP5R : public Register<0x40002864> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP6R : public Register<0x40002868> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP7R : public Register<0x4000286c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP8R : public Register<0x40002870> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP9R : public Register<0x40002874> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP10R : public Register<0x40002878> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP11R : public Register<0x4000287c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP12R : public Register<0x40002880> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP13R : public Register<0x40002884> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP14R : public Register<0x40002888> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP15R : public Register<0x4000288c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP16R : public Register<0x40002890> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP17R : public Register<0x40002894> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP18R : public Register<0x40002898> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP19R : public Register<0x4000289c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP20R : public Register<0x400028a0> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP21R : public Register<0x400028a4> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP22R : public Register<0x400028a8> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP23R : public Register<0x400028ac> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP24R : public Register<0x400028b0> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP25R : public Register<0x400028b4> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP26R : public Register<0x400028b8> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP27R : public Register<0x400028bc> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP28R : public Register<0x400028c0> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP29R : public Register<0x400028c4> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP30R : public Register<0x400028c8> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP31R : public Register<0x400028cc> {
            using BKP = Field<0, 32>;    // BKP
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART6 {
        // Control register 1
        struct CR1 : public Register<0x40011400> {
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40011404> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x40011408> {
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4001140c> {
            using DIV_Mantissa = Field<4, 12>;    // DIV_Mantissa
            using DIV_Fraction = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40011410> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40011414> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x40011418> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x4001141c> {
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x40011420> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x40011424> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40011428> {
            using Field = Field<0, 9>;    // Transmit data value
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART1 {
        // Control register 1
        struct CR1 : public Register<0x40011000> {
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40011004> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x40011008> {
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4001100c> {
            using DIV_Mantissa = Field<4, 12>;    // DIV_Mantissa
            using DIV_Fraction = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40011010> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40011014> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x40011018> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x4001101c> {
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x40011020> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x40011024> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40011028> {
            using Field = Field<0, 9>;    // Transmit data value
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART3 {
        // Control register 1
        struct CR1 : public Register<0x40004800> {
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40004804> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x40004808> {
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4000480c> {
            using DIV_Mantissa = Field<4, 12>;    // DIV_Mantissa
            using DIV_Fraction = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40004810> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40004814> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x40004818> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x4000481c> {
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x40004820> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x40004824> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40004828> {
            using Field = Field<0, 9>;    // Transmit data value
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART2 {
        // Control register 1
        struct CR1 : public Register<0x40004400> {
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40004404> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x40004408> {
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4000440c> {
            using DIV_Mantissa = Field<4, 12>;    // DIV_Mantissa
            using DIV_Fraction = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40004410> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40004414> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x40004418> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x4000441c> {
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x40004420> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x40004424> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40004428> {
            using Field = Field<0, 9>;    // Transmit data value
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct UART5 {
        // Control register 1
        struct CR1 : public Register<0x40005000> {
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40005004> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x40005008> {
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4000500c> {
            using DIV_Mantissa = Field<4, 12>;    // DIV_Mantissa
            using DIV_Fraction = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40005010> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40005014> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x40005018> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x4000501c> {
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x40005020> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x40005024> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40005028> {
            using Field = Field<0, 9>;    // Transmit data value
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct UART4 {
        // Control register 1
        struct CR1 : public Register<0x40004c00> {
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40004c04> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x40004c08> {
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x40004c0c> {
            using DIV_Mantissa = Field<4, 12>;    // DIV_Mantissa
            using DIV_Fraction = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40004c10> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40004c14> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x40004c18> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x40004c1c> {
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x40004c20> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x40004c24> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40004c28> {
            using Field = Field<0, 9>;    // Transmit data value
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct UART8 {
        // Control register 1
        struct CR1 : public Register<0x40007c00> {
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40007c04> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x40007c08> {
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x40007c0c> {
            using DIV_Mantissa = Field<4, 12>;    // DIV_Mantissa
            using DIV_Fraction = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40007c10> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40007c14> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x40007c18> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x40007c1c> {
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x40007c20> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x40007c24> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40007c28> {
            using Field = Field<0, 9>;    // Transmit data value
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct UART7 {
        // Control register 1
        struct CR1 : public Register<0x40007800> {
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40007804> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x40007808> {
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4000780c> {
            using DIV_Mantissa = Field<4, 12>;    // DIV_Mantissa
            using DIV_Fraction = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40007810> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40007814> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x40007818> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x4000781c> {
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x40007820> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x40007824> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40007828> {
            using Field = Field<0, 9>;    // Transmit data value
        };

    };

    // USB on the go full speed
    struct OTG_FS_GLOBAL {
        // OTG_FS control and status register (OTG_FS_GOTGCTL)
        struct OTG_FS_GOTGCTL : public Register<0x50000000> {
            using SRQSCS = Field<0, 1>;    // Session request success
            using SRQ = Field<1, 1>;    // Session request
            using HNGSCS = Field<8, 1>;    // Host negotiation success
            using HNPRQ = Field<9, 1>;    // HNP request
            using HSHNPEN = Field<10, 1>;    // Host set HNP enable
            using DHNPEN = Field<11, 1>;    // Device HNP enabled
            using CIDSTS = Field<16, 1>;    // Connector ID status
            using DBCT = Field<17, 1>;    // Long/short debounce time
            using ASVLD = Field<18, 1>;    // A-session valid
            using BSVLD = Field<19, 1>;    // B-session valid
            using VBVALOEN = Field<2, 1>;    // VBUS valid override enable
            using VBVALOVAL = Field<3, 1>;    // VBUS valid override value
            using AVALOEN = Field<4, 1>;    // A-peripheral session valid override enable
            using AVALOVAL = Field<5, 1>;    // A-peripheral session valid override value
            using BVALOEN = Field<6, 1>;    // B-peripheral session valid override enable
            using BVALOVAL = Field<7, 1>;    // B-peripheral session valid override value
            using EHEN = Field<12, 1>;    // Embedded host enable
            using OTGVER = Field<20, 1>;    // OTG version
        };

        // OTG_FS interrupt register (OTG_FS_GOTGINT)
        struct OTG_FS_GOTGINT : public Register<0x50000004> {
            using SEDET = Field<2, 1>;    // Session end detected
            using SRSSCHG = Field<8, 1>;    // Session request success status change
            using HNSSCHG = Field<9, 1>;    // Host negotiation success status change
            using HNGDET = Field<17, 1>;    // Host negotiation detected
            using ADTOCHG = Field<18, 1>;    // A-device timeout change
            using DBCDNE = Field<19, 1>;    // Debounce done
            using IDCHNG = Field<20, 1>;    // ID input pin changed
        };

        // OTG_FS AHB configuration register (OTG_FS_GAHBCFG)
        struct OTG_FS_GAHBCFG : public Register<0x50000008> {
            using GINT = Field<0, 1>;    // Global interrupt mask
            using TXFELVL = Field<7, 1>;    // TxFIFO empty level
            using PTXFELVL = Field<8, 1>;    // Periodic TxFIFO empty level
        };

        // OTG_FS USB configuration register (OTG_FS_GUSBCFG)
        struct OTG_FS_GUSBCFG : public Register<0x5000000c> {
            using TOCAL = Field<0, 3>;    // FS timeout calibration
            using PHYSEL = Field<6, 1>;    // Full Speed serial transceiver select
            using SRPCAP = Field<8, 1>;    // SRP-capable
            using HNPCAP = Field<9, 1>;    // HNP-capable
            using TRDT = Field<10, 4>;    // USB turnaround time
            using FHMOD = Field<29, 1>;    // Force host mode
            using FDMOD = Field<30, 1>;    // Force device mode
        };

        // OTG_FS reset register (OTG_FS_GRSTCTL)
        struct OTG_FS_GRSTCTL : public Register<0x50000010> {
            using CSRST = Field<0, 1>;    // Core soft reset
            using HSRST = Field<1, 1>;    // HCLK soft reset
            using FCRST = Field<2, 1>;    // Host frame counter reset
            using RXFFLSH = Field<4, 1>;    // RxFIFO flush
            using TXFFLSH = Field<5, 1>;    // TxFIFO flush
            using TXFNUM = Field<6, 5>;    // TxFIFO number
            using AHBIDL = Field<31, 1>;    // AHB master idle
        };

        // OTG_FS core interrupt register (OTG_FS_GINTSTS)
        struct OTG_FS_GINTSTS : public Register<0x50000014> {
            using CMOD = Field<0, 1>;    // Current mode of operation
            using MMIS = Field<1, 1>;    // Mode mismatch interrupt
            using OTGINT = Field<2, 1>;    // OTG interrupt
            using SOF = Field<3, 1>;    // Start of frame
            using RXFLVL = Field<4, 1>;    // RxFIFO non-empty
            using NPTXFE = Field<5, 1>;    // Non-periodic TxFIFO empty
            using GINAKEFF = Field<6, 1>;    // Global IN non-periodic NAK effective
            using GOUTNAKEFF = Field<7, 1>;    // Global OUT NAK effective
            using ESUSP = Field<10, 1>;    // Early suspend
            using USBSUSP = Field<11, 1>;    // USB suspend
            using USBRST = Field<12, 1>;    // USB reset
            using ENUMDNE = Field<13, 1>;    // Enumeration done
            using ISOODRP = Field<14, 1>;    // Isochronous OUT packet dropped interrupt
            using EOPF = Field<15, 1>;    // End of periodic frame interrupt
            using IEPINT = Field<18, 1>;    // IN endpoint interrupt
            using OEPINT = Field<19, 1>;    // OUT endpoint interrupt
            using IISOIXFR = Field<20, 1>;    // Incomplete isochronous IN transfer
            using IPXFR_INCOMPISOOUT = Field<21, 1>;    // Incomplete periodic transfer(Host mode)/Incomplete isochronous OUT transfer(Device mode)
            using HPRTINT = Field<24, 1>;    // Host port interrupt
            using HCINT = Field<25, 1>;    // Host channels interrupt
            using PTXFE = Field<26, 1>;    // Periodic TxFIFO empty
            using CIDSCHG = Field<28, 1>;    // Connector ID status change
            using DISCINT = Field<29, 1>;    // Disconnect detected interrupt
            using SRQINT = Field<30, 1>;    // Session request/new session detected interrupt
            using WKUPINT = Field<31, 1>;    // Resume/remote wakeup detected interrupt
            using RSTDET = Field<23, 1>;    // Reset detected interrupt
        };

        // OTG_FS interrupt mask register (OTG_FS_GINTMSK)
        struct OTG_FS_GINTMSK : public Register<0x50000018> {
            using MMISM = Field<1, 1>;    // Mode mismatch interrupt mask
            using OTGINT = Field<2, 1>;    // OTG interrupt mask
            using SOFM = Field<3, 1>;    // Start of frame mask
            using RXFLVLM = Field<4, 1>;    // Receive FIFO non-empty mask
            using NPTXFEM = Field<5, 1>;    // Non-periodic TxFIFO empty mask
            using GINAKEFFM = Field<6, 1>;    // Global non-periodic IN NAK effective mask
            using GONAKEFFM = Field<7, 1>;    // Global OUT NAK effective mask
            using ESUSPM = Field<10, 1>;    // Early suspend mask
            using USBSUSPM = Field<11, 1>;    // USB suspend mask
            using USBRST = Field<12, 1>;    // USB reset mask
            using ENUMDNEM = Field<13, 1>;    // Enumeration done mask
            using ISOODRPM = Field<14, 1>;    // Isochronous OUT packet dropped interrupt mask
            using EOPFM = Field<15, 1>;    // End of periodic frame interrupt mask
            using IEPINT = Field<18, 1>;    // IN endpoints interrupt mask
            using OEPINT = Field<19, 1>;    // OUT endpoints interrupt mask
            using IISOIXFRM = Field<20, 1>;    // Incomplete isochronous IN transfer mask
            using IPXFRM_IISOOXFRM = Field<21, 1>;    // Incomplete periodic transfer mask(Host mode)/Incomplete isochronous OUT transfer mask(Device mode)
            using PRTIM = Field<24, 1>;    // Host port interrupt mask
            using HCIM = Field<25, 1>;    // Host channels interrupt mask
            using PTXFEM = Field<26, 1>;    // Periodic TxFIFO empty mask
            using CIDSCHGM = Field<28, 1>;    // Connector ID status change mask
            using DISCINT = Field<29, 1>;    // Disconnect detected interrupt mask
            using SRQIM = Field<30, 1>;    // Session request/new session detected interrupt mask
            using WUIM = Field<31, 1>;    // Resume/remote wakeup detected interrupt mask
            using RSTDETM = Field<23, 1>;    // Reset detected interrupt mask
            using LPMIN = Field<27, 1>;    // LPM interrupt mask
        };

        // OTG_FS Receive status debug read(Device mode)
        struct OTG_FS_GRXSTSR_Device : public RegisterReadOnly<0x5000001c> {
            using EPNUM = Field<0, 4>;    // Endpoint number
            using BCNT = Field<4, 11>;    // Byte count
            using DPID = Field<15, 2>;    // Data PID
            using PKTSTS = Field<17, 4>;    // Packet status
            using FRMNUM = Field<21, 4>;    // Frame number
        };

        // OTG_FS Receive status debug read(Host mode)
        struct OTG_FS_GRXSTSR_Host : public RegisterReadOnly<0x5000001c> {
            using CHNUM = Field<0, 4>;    // Endpoint number
            using BCNT = Field<4, 11>;    // Byte count
            using DPID = Field<15, 2>;    // Data PID
            using PKTSTS = Field<17, 4>;    // Packet status
        };

        // OTG_FS Receive FIFO size register (OTG_FS_GRXFSIZ)
        struct OTG_FS_GRXFSIZ : public Register<0x50000024> {
            using RXFD = Field<0, 16>;    // RxFIFO depth
        };

        // OTG_FS Endpoint 0 Transmit FIFO size
        struct OTG_FS_DIEPTXF0_Device : public Register<0x50000028> {
            using TX0FSA = Field<0, 16>;    // Endpoint 0 transmit RAM start address
            using TX0FD = Field<16, 16>;    // Endpoint 0 TxFIFO depth
        };

        // OTG_FS Host non-periodic transmit FIFO size register
        struct OTG_FS_HNPTXFSIZ_Host : public Register<0x50000028> {
            using NPTXFSA = Field<0, 16>;    // Non-periodic transmit RAM start address
            using NPTXFD = Field<16, 16>;    // Non-periodic TxFIFO depth
        };

        // OTG_FS non-periodic transmit FIFO/queue status register (OTG_FS_GNPTXSTS)
        struct OTG_FS_HNPTXSTS : public RegisterReadOnly<0x5000002c> {
            using NPTXFSAV = Field<0, 16>;    // Non-periodic TxFIFO space available
            using NPTQXSAV = Field<16, 8>;    // Non-periodic transmit request queue space available
            using NPTXQTOP = Field<24, 7>;    // Top of the non-periodic transmit request queue
        };

        // OTG_FS general core configuration register (OTG_FS_GCCFG)
        struct OTG_FS_GCCFG : public Register<0x50000038> {
            using PWRDWN = Field<16, 1>;    // Power down
            using BCDEN = Field<17, 1>;    // Battery charging detector (BCD) enable
            using DCDEN = Field<18, 1>;    // Data contact detection (DCD) mode enable
            using PDEN = Field<19, 1>;    // Primary detection (PD) mode enable
            using SDEN = Field<20, 1>;    // Secondary detection (SD) mode enable
            using VBDEN = Field<21, 1>;    // USB VBUS detection enable
            using DCDET = Field<0, 1>;    // Data contact detection (DCD) status
            using PDET = Field<1, 1>;    // Primary detection (PD) status
            using SDET = Field<2, 1>;    // Secondary detection (SD) status
            using PS2DET = Field<3, 1>;    // DM pull-up detection status
        };

        // core ID register
        struct OTG_FS_CID : public Register<0x5000003c> {
            using PRODUCT_ID = Field<0, 32>;    // Product ID field
        };

        // OTG_FS Host periodic transmit FIFO size register (OTG_FS_HPTXFSIZ)
        struct OTG_FS_HPTXFSIZ : public Register<0x50000100> {
            using PTXSA = Field<0, 16>;    // Host periodic TxFIFO start address
            using PTXFSIZ = Field<16, 16>;    // Host periodic TxFIFO depth
        };

        // OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF1)
        struct OTG_FS_DIEPTXF1 : public Register<0x50000104> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFO2 transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF2)
        struct OTG_FS_DIEPTXF2 : public Register<0x50000108> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFO3 transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF3)
        struct OTG_FS_DIEPTXF3 : public Register<0x5000010c> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFO4 transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG status read and pop register (Device mode)
        struct OTG_FS_GRXSTSP_Device : public RegisterReadOnly<0x50000020> {
            using EPNUM = Field<0, 4>;    // Endpoint number
            using BCNT = Field<4, 11>;    // Byte count
            using DPID = Field<15, 2>;    // Data PID
            using PKTSTS = Field<17, 4>;    // Packet status
            using FRMNUM = Field<21, 4>;    // Frame number
        };

        // OTG status read and pop register (Host mode)
        struct OTG_FS_GRXSTSP_Host : public RegisterReadOnly<0x50000020> {
            using CHNUM = Field<0, 4>;    // Channel number
            using BCNT = Field<4, 11>;    // Byte count
            using DPID = Field<15, 2>;    // Data PID
            using PKTSTS = Field<17, 4>;    // Packet status
        };

        // OTG I2C access register
        struct OTG_FS_GI2CCTL : public Register<0x50000030> {
            using RWDATA = Field<0, 8>;    // I2C Read/Write Data
            using REGADDR = Field<8, 8>;    // I2C Register Address
            using ADDR = Field<16, 7>;    // I2C Address
            using I2CEN = Field<23, 1>;    // I2C Enable
            using ACK = Field<24, 1>;    // I2C ACK
            using I2CDEVADR = Field<26, 2>;    // I2C Device Address
            using I2CDATSE0 = Field<28, 1>;    // I2C DatSe0 USB mode
            using RW = Field<30, 1>;    // Read/Write Indicator
            using BSYDNE = Field<31, 1>;    // I2C Busy/Done
        };

        // OTG power down register
        struct OTG_FS_GPWRDN : public Register<0x50000058> {
            using ADPMEN = Field<0, 1>;    // ADP module enable
            using ADPIF = Field<23, 1>;    // ADP interrupt flag
        };

        // OTG ADP timer, control and status register
        struct OTG_FS_GADPCTL : public Register<0x50000060> {
            using PRBDSCHG = Field<0, 2>;    // Probe discharge
            using PRBDELTA = Field<2, 2>;    // Probe delta
            using PRBPER = Field<4, 2>;    // Probe period
            using RTIM = Field<6, 11>;    // Ramp time
            using ENAPRB = Field<17, 1>;    // Enable probe
            using ENASNS = Field<18, 1>;    // Enable sense
            using ADPRST = Field<19, 1>;    // ADP reset
            using ADPEN = Field<20, 1>;    // ADP enable
            using ADPPRBIF = Field<21, 1>;    // ADP probe interrupt flag
            using ADPSNSIF = Field<22, 1>;    // ADP sense interrupt flag
            using ADPTOIF = Field<23, 1>;    // ADP timeout interrupt flag
            using ADPPRBIM = Field<24, 1>;    // ADP probe interrupt mask
            using ADPSNSIM = Field<25, 1>;    // ADP sense interrupt mask
            using ADPTOIM = Field<26, 1>;    // ADP timeout interrupt mask
            using AR = Field<27, 2>;    // Access request
        };

        // OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF4)
        struct OTG_FS_DIEPTXF4 : public Register<0x50000110> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFOx transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint Tx FIFO depth
        };

        // OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF5)
        struct OTG_FS_DIEPTXF5 : public Register<0x50000114> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFOx transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint Tx FIFO depth
        };

        // OTG core LPM configuration register
        struct OTG_FS_GLPMCFG : public Register<0x50000054> {
            using LPMEN = Field<0, 1>;    // LPM support enable
            using LPMACK = Field<1, 1>;    // LPM token acknowledge enable
            using BESL = Field<2, 4>;    // Best effort service latency
            using REMWAKE = Field<6, 1>;    // bRemoteWake value
            using L1SSEN = Field<7, 1>;    // L1 Shallow Sleep enable
            using BESLTHRS = Field<8, 4>;    // BESL threshold
            using L1DSEN = Field<12, 1>;    // L1 deep sleep enable
            using LPMRST = Field<13, 2>;    // LPM response
            using SLPSTS = Field<15, 1>;    // Port sleep status
            using L1RSMOK = Field<16, 1>;    // Sleep State Resume OK
            using LPMCHIDX = Field<17, 4>;    // LPM Channel Index
            using LPMRCNT = Field<21, 3>;    // LPM retry count
            using SNDLPM = Field<24, 1>;    // Send LPM transaction
            using LPMRCNTSTS = Field<25, 3>;    // LPM retry count status
            using ENBESL = Field<28, 1>;    // Enable best effort service latency
        };

    };

    // USB on the go high speed
    struct OTG_HS_GLOBAL {
        // OTG_HS control and status register
        struct OTG_HS_GOTGCTL : public Register<0x40040000> {
            using SRQSCS = Field<0, 1>;    // Session request success
            using SRQ = Field<1, 1>;    // Session request
            using HNGSCS = Field<8, 1>;    // Host negotiation success
            using HNPRQ = Field<9, 1>;    // HNP request
            using HSHNPEN = Field<10, 1>;    // Host set HNP enable
            using DHNPEN = Field<11, 1>;    // Device HNP enabled
            using CIDSTS = Field<16, 1>;    // Connector ID status
            using DBCT = Field<17, 1>;    // Long/short debounce time
            using ASVLD = Field<18, 1>;    // A-session valid
            using BSVLD = Field<19, 1>;    // B-session valid
            using EHEN = Field<12, 1>;    // Embedded host enable
        };

        // OTG_HS interrupt register
        struct OTG_HS_GOTGINT : public Register<0x40040004> {
            using SEDET = Field<2, 1>;    // Session end detected
            using SRSSCHG = Field<8, 1>;    // Session request success status change
            using HNSSCHG = Field<9, 1>;    // Host negotiation success status change
            using HNGDET = Field<17, 1>;    // Host negotiation detected
            using ADTOCHG = Field<18, 1>;    // A-device timeout change
            using DBCDNE = Field<19, 1>;    // Debounce done
            using IDCHNG = Field<20, 1>;    // ID input pin changed
        };

        // OTG_HS AHB configuration register
        struct OTG_HS_GAHBCFG : public Register<0x40040008> {
            using GINT = Field<0, 1>;    // Global interrupt mask
            using HBSTLEN = Field<1, 4>;    // Burst length/type
            using DMAEN = Field<5, 1>;    // DMA enable
            using TXFELVL = Field<7, 1>;    // TxFIFO empty level
            using PTXFELVL = Field<8, 1>;    // Periodic TxFIFO empty level
        };

        // OTG_HS USB configuration register
        struct OTG_HS_GUSBCFG : public Register<0x4004000c> {
            using TOCAL = Field<0, 3>;    // FS timeout calibration
            using PHYSEL = Field<6, 1>;    // USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select
            using SRPCAP = Field<8, 1>;    // SRP-capable
            using HNPCAP = Field<9, 1>;    // HNP-capable
            using TRDT = Field<10, 4>;    // USB turnaround time
            using PHYLPCS = Field<15, 1>;    // PHY Low-power clock select
            using ULPIFSLS = Field<17, 1>;    // ULPI FS/LS select
            using ULPIAR = Field<18, 1>;    // ULPI Auto-resume
            using ULPICSM = Field<19, 1>;    // ULPI Clock SuspendM
            using ULPIEVBUSD = Field<20, 1>;    // ULPI External VBUS Drive
            using ULPIEVBUSI = Field<21, 1>;    // ULPI external VBUS indicator
            using TSDPS = Field<22, 1>;    // TermSel DLine pulsing selection
            using PCCI = Field<23, 1>;    // Indicator complement
            using PTCI = Field<24, 1>;    // Indicator pass through
            using ULPIIPD = Field<25, 1>;    // ULPI interface protect disable
            using FHMOD = Field<29, 1>;    // Forced host mode
            using FDMOD = Field<30, 1>;    // Forced peripheral mode
        };

        // OTG_HS reset register
        struct OTG_HS_GRSTCTL : public Register<0x40040010> {
            using CSRST = Field<0, 1>;    // Core soft reset
            using HSRST = Field<1, 1>;    // HCLK soft reset
            using FCRST = Field<2, 1>;    // Host frame counter reset
            using RXFFLSH = Field<4, 1>;    // RxFIFO flush
            using TXFFLSH = Field<5, 1>;    // TxFIFO flush
            using TXFNUM = Field<6, 5>;    // TxFIFO number
            using AHBIDL = Field<31, 1>;    // AHB master idle
            using DMAREQ = Field<30, 1>;    // DMA request signal enabled for USB OTG HS
        };

        // OTG_HS core interrupt register
        struct OTG_HS_GINTSTS : public Register<0x40040014> {
            using CMOD = Field<0, 1>;    // Current mode of operation
            using MMIS = Field<1, 1>;    // Mode mismatch interrupt
            using OTGINT = Field<2, 1>;    // OTG interrupt
            using SOF = Field<3, 1>;    // Start of frame
            using RXFLVL = Field<4, 1>;    // RxFIFO nonempty
            using NPTXFE = Field<5, 1>;    // Nonperiodic TxFIFO empty
            using GINAKEFF = Field<6, 1>;    // Global IN nonperiodic NAK effective
            using BOUTNAKEFF = Field<7, 1>;    // Global OUT NAK effective
            using ESUSP = Field<10, 1>;    // Early suspend
            using USBSUSP = Field<11, 1>;    // USB suspend
            using USBRST = Field<12, 1>;    // USB reset
            using ENUMDNE = Field<13, 1>;    // Enumeration done
            using ISOODRP = Field<14, 1>;    // Isochronous OUT packet dropped interrupt
            using EOPF = Field<15, 1>;    // End of periodic frame interrupt
            using IEPINT = Field<18, 1>;    // IN endpoint interrupt
            using OEPINT = Field<19, 1>;    // OUT endpoint interrupt
            using IISOIXFR = Field<20, 1>;    // Incomplete isochronous IN transfer
            using PXFR_INCOMPISOOUT = Field<21, 1>;    // Incomplete periodic transfer
            using DATAFSUSP = Field<22, 1>;    // Data fetch suspended
            using HPRTINT = Field<24, 1>;    // Host port interrupt
            using HCINT = Field<25, 1>;    // Host channels interrupt
            using PTXFE = Field<26, 1>;    // Periodic TxFIFO empty
            using CIDSCHG = Field<28, 1>;    // Connector ID status change
            using DISCINT = Field<29, 1>;    // Disconnect detected interrupt
            using SRQINT = Field<30, 1>;    // Session request/new session detected interrupt
            using WKUINT = Field<31, 1>;    // Resume/remote wakeup detected interrupt
        };

        // OTG_HS interrupt mask register
        struct OTG_HS_GINTMSK : public Register<0x40040018> {
            using MMISM = Field<1, 1>;    // Mode mismatch interrupt mask
            using OTGINT = Field<2, 1>;    // OTG interrupt mask
            using SOFM = Field<3, 1>;    // Start of frame mask
            using RXFLVLM = Field<4, 1>;    // Receive FIFO nonempty mask
            using NPTXFEM = Field<5, 1>;    // Nonperiodic TxFIFO empty mask
            using GINAKEFFM = Field<6, 1>;    // Global nonperiodic IN NAK effective mask
            using GONAKEFFM = Field<7, 1>;    // Global OUT NAK effective mask
            using ESUSPM = Field<10, 1>;    // Early suspend mask
            using USBSUSPM = Field<11, 1>;    // USB suspend mask
            using USBRST = Field<12, 1>;    // USB reset mask
            using ENUMDNEM = Field<13, 1>;    // Enumeration done mask
            using ISOODRPM = Field<14, 1>;    // Isochronous OUT packet dropped interrupt mask
            using EOPFM = Field<15, 1>;    // End of periodic frame interrupt mask
            using IEPINT = Field<18, 1>;    // IN endpoints interrupt mask
            using OEPINT = Field<19, 1>;    // OUT endpoints interrupt mask
            using IISOIXFRM = Field<20, 1>;    // Incomplete isochronous IN transfer mask
            using PXFRM_IISOOXFRM = Field<21, 1>;    // Incomplete periodic transfer mask
            using FSUSPM = Field<22, 1>;    // Data fetch suspended mask
            using PRTIM = Field<24, 1>;    // Host port interrupt mask
            using HCIM = Field<25, 1>;    // Host channels interrupt mask
            using PTXFEM = Field<26, 1>;    // Periodic TxFIFO empty mask
            using CIDSCHGM = Field<28, 1>;    // Connector ID status change mask
            using DISCINT = Field<29, 1>;    // Disconnect detected interrupt mask
            using SRQIM = Field<30, 1>;    // Session request/new session detected interrupt mask
            using WUIM = Field<31, 1>;    // Resume/remote wakeup detected interrupt mask
            using RSTDE = Field<23, 1>;    // Reset detected interrupt mask
            using LPMINTM = Field<27, 1>;    // LPM interrupt mask
        };

        // OTG_HS Receive status debug read register (host mode)
        struct OTG_HS_GRXSTSR_Host : public RegisterReadOnly<0x4004001c> {
            using CHNUM = Field<0, 4>;    // Channel number
            using BCNT = Field<4, 11>;    // Byte count
            using DPID = Field<15, 2>;    // Data PID
            using PKTSTS = Field<17, 4>;    // Packet status
        };

        // OTG_HS status read and pop register (host mode)
        struct OTG_HS_GRXSTSP_Host : public RegisterReadOnly<0x40040020> {
            using CHNUM = Field<0, 4>;    // Channel number
            using BCNT = Field<4, 11>;    // Byte count
            using DPID = Field<15, 2>;    // Data PID
            using PKTSTS = Field<17, 4>;    // Packet status
        };

        // OTG_HS Receive FIFO size register
        struct OTG_HS_GRXFSIZ : public Register<0x40040024> {
            using RXFD = Field<0, 16>;    // RxFIFO depth
        };

        // OTG_HS nonperiodic transmit FIFO size register (host mode)
        struct OTG_HS_HNPTXFSIZ_Host : public Register<0x40040028> {
            using NPTXFSA = Field<0, 16>;    // Nonperiodic transmit RAM start address
            using NPTXFD = Field<16, 16>;    // Nonperiodic TxFIFO depth
        };

        // Endpoint 0 transmit FIFO size (peripheral mode)
        struct OTG_HS_DIEPTXF0_Device : public Register<0x40040028> {
            using TX0FSA = Field<0, 16>;    // Endpoint 0 transmit RAM start address
            using TX0FD = Field<16, 16>;    // Endpoint 0 TxFIFO depth
        };

        // OTG_HS nonperiodic transmit FIFO/queue status register
        struct OTG_HS_GNPTXSTS : public RegisterReadOnly<0x4004002c> {
            using NPTXFSAV = Field<0, 16>;    // Nonperiodic TxFIFO space available
            using NPTQXSAV = Field<16, 8>;    // Nonperiodic transmit request queue space available
            using NPTXQTOP = Field<24, 7>;    // Top of the nonperiodic transmit request queue
        };

        // OTG_HS general core configuration register
        struct OTG_HS_GCCFG : public Register<0x40040038> {
            using PWRDWN = Field<16, 1>;    // Power down
            using BCDEN = Field<17, 1>;    // Battery charging detector (BCD) enable
            using DCDEN = Field<18, 1>;    // Data contact detection (DCD) mode enable
            using PDEN = Field<19, 1>;    // Primary detection (PD) mode enable
            using SDEN = Field<20, 1>;    // Secondary detection (SD) mode enable
            using VBDEN = Field<21, 1>;    // USB VBUS detection enable
            using DCDET = Field<0, 1>;    // Data contact detection (DCD) status
            using PDET = Field<1, 1>;    // Primary detection (PD) status
            using SDET = Field<2, 1>;    // Secondary detection (SD) status
            using PS2DET = Field<3, 1>;    // DM pull-up detection status
        };

        // OTG_HS core ID register
        struct OTG_HS_CID : public Register<0x4004003c> {
            using PRODUCT_ID = Field<0, 32>;    // Product ID field
        };

        // OTG_HS Host periodic transmit FIFO size register
        struct OTG_HS_HPTXFSIZ : public Register<0x40040100> {
            using PTXSA = Field<0, 16>;    // Host periodic TxFIFO start address
            using PTXFD = Field<16, 16>;    // Host periodic TxFIFO depth
        };

        // OTG_HS device IN endpoint transmit FIFO size register
        struct OTG_HS_DIEPTXF1 : public Register<0x40040104> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFOx transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_HS device IN endpoint transmit FIFO size register
        struct OTG_HS_DIEPTXF2 : public Register<0x40040108> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFOx transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_HS device IN endpoint transmit FIFO size register
        struct OTG_HS_DIEPTXF3 : public Register<0x4004011c> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFOx transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_HS device IN endpoint transmit FIFO size register
        struct OTG_HS_DIEPTXF4 : public Register<0x40040120> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFOx transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_HS device IN endpoint transmit FIFO size register
        struct OTG_HS_DIEPTXF5 : public Register<0x40040124> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFOx transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_HS device IN endpoint transmit FIFO size register
        struct OTG_HS_DIEPTXF6 : public Register<0x40040128> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFOx transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_HS device IN endpoint transmit FIFO size register
        struct OTG_HS_DIEPTXF7 : public Register<0x4004012c> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFOx transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_HS Receive status debug read register (peripheral mode mode)
        struct OTG_HS_GRXSTSR_Device : public RegisterReadOnly<0x4004001c> {
            using EPNUM = Field<0, 4>;    // Endpoint number
            using BCNT = Field<4, 11>;    // Byte count
            using DPID = Field<15, 2>;    // Data PID
            using PKTSTS = Field<17, 4>;    // Packet status
            using FRMNUM = Field<21, 4>;    // Frame number
        };

        // OTG_HS status read and pop register (peripheral mode)
        struct OTG_HS_GRXSTSP_Device : public RegisterReadOnly<0x40040020> {
            using EPNUM = Field<0, 4>;    // Endpoint number
            using BCNT = Field<4, 11>;    // Byte count
            using DPID = Field<15, 2>;    // Data PID
            using PKTSTS = Field<17, 4>;    // Packet status
            using FRMNUM = Field<21, 4>;    // Frame number
        };

        // OTG core LPM configuration register
        struct OTG_HS_GLPMCFG : public Register<0x40040054> {
            using LPMEN = Field<0, 1>;    // LPM support enable
            using LPMACK = Field<1, 1>;    // LPM token acknowledge enable
            using BESL = Field<2, 4>;    // Best effort service latency
            using REMWAKE = Field<6, 1>;    // bRemoteWake value
            using L1SSEN = Field<7, 1>;    // L1 Shallow Sleep enable
            using BESLTHRS = Field<8, 4>;    // BESL threshold
            using L1DSEN = Field<12, 1>;    // L1 deep sleep enable
            using LPMRST = Field<13, 2>;    // LPM response
            using SLPSTS = Field<15, 1>;    // Port sleep status
            using L1RSMOK = Field<16, 1>;    // Sleep State Resume OK
            using LPMCHIDX = Field<17, 4>;    // LPM Channel Index
            using LPMRCNT = Field<21, 3>;    // LPM retry count
            using SNDLPM = Field<24, 1>;    // Send LPM transaction
            using LPMRCNTSTS = Field<25, 3>;    // LPM retry count status
            using ENBESL = Field<28, 1>;    // Enable best effort service latency
        };

    };

    // Management data input/output slave
    struct MDIOS {
        // MDIOS configuration register
        struct MDIOS_CR : public Register<0x40017800> {
            using EN = Field<0, 1>;    // Peripheral enable
            using WRIE = Field<1, 1>;    // Register write interrupt enable
            using RDIE = Field<2, 1>;    // Register Read Interrupt Enable
            using EIE = Field<3, 1>;    // Error interrupt enable
            using DPC = Field<7, 1>;    // Disable Preamble Check
            using PORT_ADDRESS = Field<8, 5>;    // Slaves's address
        };

        // MDIOS write flag register
        struct MDIOS_WRFR : public RegisterReadOnly<0x40017804> {
            using WRF = Field<0, 32>;    // Write flags for MDIO registers 0 to 31
        };

        // MDIOS clear write flag register
        struct MDIOS_CWRFR : public Register<0x40017808> {
            using CWRF = Field<0, 32>;    // Clear the write flag
        };

        // MDIOS read flag register
        struct MDIOS_RDFR : public RegisterReadOnly<0x4001780c> {
            using RDF = Field<0, 32>;    // Read flags for MDIO registers 0 to 31
        };

        // MDIOS clear read flag register
        struct MDIOS_CRDFR : public Register<0x40017810> {
            using CRDF = Field<0, 32>;    // Clear the read flag
        };

        // MDIOS status register
        struct MDIOS_SR : public RegisterReadOnly<0x40017814> {
            using PERF = Field<0, 1>;    // Preamble error flag
            using SERF = Field<1, 1>;    // Start error flag
            using TERF = Field<2, 1>;    // Turnaround error flag
        };

        // MDIOS clear flag register
        struct MDIOS_CLRFR : public Register<0x40017818> {
            using CPERF = Field<0, 1>;    // Clear the preamble error flag
            using CSERF = Field<1, 1>;    // Clear the start error flag
            using CTERF = Field<2, 1>;    // Clear the turnaround error flag
        };

        // MDIOS input data register 0
        struct MDIOS_DINR0 : public RegisterReadOnly<0x4001781c> {
            using DIN0 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 1
        struct MDIOS_DINR1 : public RegisterReadOnly<0x40017820> {
            using DIN1 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 2
        struct MDIOS_DINR2 : public RegisterReadOnly<0x40017824> {
            using DIN2 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 3
        struct MDIOS_DINR3 : public RegisterReadOnly<0x40017828> {
            using DIN3 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 4
        struct MDIOS_DINR4 : public RegisterReadOnly<0x4001782c> {
            using DIN4 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 5
        struct MDIOS_DINR5 : public RegisterReadOnly<0x40017830> {
            using DIN5 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 6
        struct MDIOS_DINR6 : public RegisterReadOnly<0x40017834> {
            using DIN6 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 7
        struct MDIOS_DINR7 : public RegisterReadOnly<0x40017838> {
            using DIN7 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 8
        struct MDIOS_DINR8 : public RegisterReadOnly<0x4001783c> {
            using DIN8 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 9
        struct MDIOS_DINR9 : public RegisterReadOnly<0x40017840> {
            using DIN9 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 10
        struct MDIOS_DINR10 : public RegisterReadOnly<0x40017844> {
            using DIN10 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 11
        struct MDIOS_DINR11 : public RegisterReadOnly<0x40017848> {
            using DIN11 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 12
        struct MDIOS_DINR12 : public RegisterReadOnly<0x4001784c> {
            using DIN12 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 13
        struct MDIOS_DINR13 : public RegisterReadOnly<0x40017850> {
            using DIN13 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 14
        struct MDIOS_DINR14 : public RegisterReadOnly<0x40017854> {
            using DIN14 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 15
        struct MDIOS_DINR15 : public RegisterReadOnly<0x40017858> {
            using DIN15 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 16
        struct MDIOS_DINR16 : public RegisterReadOnly<0x4001785c> {
            using DIN16 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 17
        struct MDIOS_DINR17 : public RegisterReadOnly<0x40017860> {
            using DIN17 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 18
        struct MDIOS_DINR18 : public RegisterReadOnly<0x40017864> {
            using DIN18 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 19
        struct MDIOS_DINR19 : public RegisterReadOnly<0x40017868> {
            using DIN19 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 20
        struct MDIOS_DINR20 : public RegisterReadOnly<0x4001786c> {
            using DIN20 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 21
        struct MDIOS_DINR21 : public RegisterReadOnly<0x40017870> {
            using DIN21 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 22
        struct MDIOS_DINR22 : public RegisterReadOnly<0x40017874> {
            using DIN22 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 23
        struct MDIOS_DINR23 : public RegisterReadOnly<0x40017878> {
            using DIN23 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 24
        struct MDIOS_DINR24 : public RegisterReadOnly<0x4001787c> {
            using DIN24 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 25
        struct MDIOS_DINR25 : public RegisterReadOnly<0x40017880> {
            using DIN25 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 26
        struct MDIOS_DINR26 : public RegisterReadOnly<0x40017884> {
            using DIN26 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 27
        struct MDIOS_DINR27 : public RegisterReadOnly<0x40017888> {
            using DIN27 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 28
        struct MDIOS_DINR28 : public RegisterReadOnly<0x4001788c> {
            using DIN28 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 29
        struct MDIOS_DINR29 : public RegisterReadOnly<0x40017890> {
            using DIN29 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 30
        struct MDIOS_DINR30 : public RegisterReadOnly<0x40017894> {
            using DIN30 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 31
        struct MDIOS_DINR31 : public RegisterReadOnly<0x40017898> {
            using DIN31 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS output data register 0
        struct MDIOS_DOUTR0 : public Register<0x4001789c> {
            using DOUT0 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 1
        struct MDIOS_DOUTR1 : public Register<0x400178a0> {
            using DOUT1 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 2
        struct MDIOS_DOUTR2 : public Register<0x400178a4> {
            using DOUT2 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 3
        struct MDIOS_DOUTR3 : public Register<0x400178a8> {
            using DOUT3 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 4
        struct MDIOS_DOUTR4 : public Register<0x400178ac> {
            using DOUT4 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 5
        struct MDIOS_DOUTR5 : public Register<0x400178b0> {
            using DOUT5 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 6
        struct MDIOS_DOUTR6 : public Register<0x400178b4> {
            using DOUT6 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 7
        struct MDIOS_DOUTR7 : public Register<0x400178b8> {
            using DOUT7 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 8
        struct MDIOS_DOUTR8 : public Register<0x400178bc> {
            using DOUT8 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 9
        struct MDIOS_DOUTR9 : public Register<0x400178c0> {
            using DOUT9 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 10
        struct MDIOS_DOUTR10 : public Register<0x400178c4> {
            using DOUT10 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 11
        struct MDIOS_DOUTR11 : public Register<0x400178c8> {
            using DOUT11 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 12
        struct MDIOS_DOUTR12 : public Register<0x400178cc> {
            using DOUT12 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 13
        struct MDIOS_DOUTR13 : public Register<0x400178d0> {
            using DOUT13 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 14
        struct MDIOS_DOUTR14 : public Register<0x400178d4> {
            using DOUT14 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 15
        struct MDIOS_DOUTR15 : public Register<0x400178d8> {
            using DOUT15 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 16
        struct MDIOS_DOUTR16 : public Register<0x400178dc> {
            using DOUT16 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 17
        struct MDIOS_DOUTR17 : public Register<0x400178e0> {
            using DOUT17 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 18
        struct MDIOS_DOUTR18 : public Register<0x400178e4> {
            using DOUT18 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 19
        struct MDIOS_DOUTR19 : public Register<0x400178e8> {
            using DOUT19 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 20
        struct MDIOS_DOUTR20 : public Register<0x400178ec> {
            using DOUT20 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 21
        struct MDIOS_DOUTR21 : public Register<0x400178f0> {
            using DOUT21 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 22
        struct MDIOS_DOUTR22 : public Register<0x400178f4> {
            using DOUT22 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 23
        struct MDIOS_DOUTR23 : public Register<0x400178f8> {
            using DOUT23 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 24
        struct MDIOS_DOUTR24 : public Register<0x400178fc> {
            using DOUT24 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 25
        struct MDIOS_DOUTR25 : public Register<0x40017900> {
            using DOUT25 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 26
        struct MDIOS_DOUTR26 : public Register<0x40017904> {
            using DOUT26 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 27
        struct MDIOS_DOUTR27 : public Register<0x40017908> {
            using DOUT27 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 28
        struct MDIOS_DOUTR28 : public Register<0x4001790c> {
            using DOUT28 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 29
        struct MDIOS_DOUTR29 : public Register<0x40017910> {
            using DOUT29 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 30
        struct MDIOS_DOUTR30 : public Register<0x40017914> {
            using DOUT30 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 31
        struct MDIOS_DOUTR31 : public Register<0x40017918> {
            using DOUT31 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

    };

    // Digital filter for sigma delta modulators
    struct DFSDM {
        // DFSDM channel configuration 0 register 1
        struct DFSDM_CHCFG0R1 : public Register<0x40017400> {
            using SITP = Field<0, 2>;    // Serial interface type for channel 0
            using SPICKSEL = Field<2, 2>;    // SPI clock select for channel 0
            using SCDEN = Field<5, 1>;    // Short-circuit detector enable on channel 0
            using CKABEN = Field<6, 1>;    // Clock absence detector enable on channel 0
            using CHEN = Field<7, 1>;    // Channel 0 enable
            using CHINSEL = Field<8, 1>;    // Channel inputs selection
            using DATMPX = Field<12, 2>;    // Input data multiplexer for channel 0
            using DATPACK = Field<14, 2>;    // Data packing mode in DFSDM_CHDATINyR register
            using CKOUTDIV = Field<16, 8>;    // Output serial clock divider
            using CKOUTSRC = Field<30, 1>;    // Output serial clock source selection
            using DFSDMEN = Field<31, 1>;    // Global enable for DFSDM interface
        };

        // DFSDM channel configuration 1 register 1
        struct DFSDM_CHCFG1R1 : public Register<0x40017404> {
            using SITP = Field<0, 2>;    // Serial interface type for channel 1
            using SPICKSEL = Field<2, 2>;    // SPI clock select for channel 1
            using SCDEN = Field<5, 1>;    // Short-circuit detector enable on channel 1
            using CKABEN = Field<6, 1>;    // Clock absence detector enable on channel 1
            using CHEN = Field<7, 1>;    // Channel 1 enable
            using CHINSEL = Field<8, 1>;    // Channel inputs selection
            using DATMPX = Field<12, 2>;    // Input data multiplexer for channel 1
            using DATPACK = Field<14, 2>;    // Data packing mode in DFSDM_CHDATINyR register
            using CKOUTDIV = Field<16, 8>;    // Output serial clock divider
            using CKOUTSRC = Field<30, 1>;    // Output serial clock source selection
            using DFSDMEN = Field<31, 1>;    // Global enable for DFSDM interface
        };

        // DFSDM channel configuration 2 register 1
        struct DFSDM_CHCFG2R1 : public Register<0x40017408> {
            using SITP = Field<0, 2>;    // Serial interface type for channel 2
            using SPICKSEL = Field<2, 2>;    // SPI clock select for channel 2
            using SCDEN = Field<5, 1>;    // Short-circuit detector enable on channel 2
            using CKABEN = Field<6, 1>;    // Clock absence detector enable on channel 2
            using CHEN = Field<7, 1>;    // Channel 2 enable
            using CHINSEL = Field<8, 1>;    // Channel inputs selection
            using DATMPX = Field<12, 2>;    // Input data multiplexer for channel 2
            using DATPACK = Field<14, 2>;    // Data packing mode in DFSDM_CHDATINyR register
            using CKOUTDIV = Field<16, 8>;    // Output serial clock divider
            using CKOUTSRC = Field<30, 1>;    // Output serial clock source selection
            using DFSDMEN = Field<31, 1>;    // Global enable for DFSDM interface
        };

        // DFSDM channel configuration 3 register 1
        struct DFSDM_CHCFG3R1 : public Register<0x4001740c> {
            using SITP = Field<0, 2>;    // Serial interface type for channel 3
            using SPICKSEL = Field<2, 2>;    // SPI clock select for channel 3
            using SCDEN = Field<5, 1>;    // Short-circuit detector enable on channel 3
            using CKABEN = Field<6, 1>;    // Clock absence detector enable on channel 3
            using CHEN = Field<7, 1>;    // Channel 3 enable
            using CHINSEL = Field<8, 1>;    // Channel inputs selection
            using DATMPX = Field<12, 2>;    // Input data multiplexer for channel 3
            using DATPACK = Field<14, 2>;    // Data packing mode in DFSDM_CHDATINyR register
            using CKOUTDIV = Field<16, 8>;    // Output serial clock divider
            using CKOUTSRC = Field<30, 1>;    // Output serial clock source selection
            using DFSDMEN = Field<31, 1>;    // Global enable for DFSDM interface
        };

        // DFSDM channel configuration 4 register 1
        struct DFSDM_CHCFG4R1 : public Register<0x40017410> {
            using SITP = Field<0, 2>;    // Serial interface type for channel 4
            using SPICKSEL = Field<2, 2>;    // SPI clock select for channel 4
            using SCDEN = Field<5, 1>;    // Short-circuit detector enable on channel 4
            using CKABEN = Field<6, 1>;    // Clock absence detector enable on channel 4
            using CHEN = Field<7, 1>;    // Channel 4 enable
            using CHINSEL = Field<8, 1>;    // Channel inputs selection
            using DATMPX = Field<12, 2>;    // Input data multiplexer for channel 4
            using DATPACK = Field<14, 2>;    // Data packing mode in DFSDM_CHDATINyR register
            using CKOUTDIV = Field<16, 8>;    // Output serial clock divider
            using CKOUTSRC = Field<30, 1>;    // Output serial clock source selection
            using DFSDMEN = Field<31, 1>;    // Global enable for DFSDM interface
        };

        // DFSDM channel configuration 5 register 1
        struct DFSDM_CHCFG5R1 : public Register<0x40017414> {
            using SITP = Field<0, 2>;    // Serial interface type for channel 5
            using SPICKSEL = Field<2, 2>;    // SPI clock select for channel 5
            using SCDEN = Field<5, 1>;    // Short-circuit detector enable on channel 5
            using CKABEN = Field<6, 1>;    // Clock absence detector enable on channel 5
            using CHEN = Field<7, 1>;    // Channel 5 enable
            using CHINSEL = Field<8, 1>;    // Channel inputs selection
            using DATMPX = Field<12, 2>;    // Input data multiplexer for channel 5
            using DATPACK = Field<14, 2>;    // Data packing mode in DFSDM_CHDATINyR register
            using CKOUTDIV = Field<16, 8>;    // Output serial clock divider
            using CKOUTSRC = Field<30, 1>;    // Output serial clock source selection
            using DFSDMEN = Field<31, 1>;    // Global enable for DFSDM interface
        };

        // DFSDM channel configuration 6 register 1
        struct DFSDM_CHCFG6R1 : public Register<0x40017418> {
            using SITP = Field<0, 2>;    // Serial interface type for channel 6
            using SPICKSEL = Field<2, 2>;    // SPI clock select for channel 6
            using SCDEN = Field<5, 1>;    // Short-circuit detector enable on channel 6
            using CKABEN = Field<6, 1>;    // Clock absence detector enable on channel 6
            using CHEN = Field<7, 1>;    // Channel 6 enable
            using CHINSEL = Field<8, 1>;    // Channel inputs selection
            using DATMPX = Field<12, 2>;    // Input data multiplexer for channel 6
            using DATPACK = Field<14, 2>;    // Data packing mode in DFSDM_CHDATINyR register
            using CKOUTDIV = Field<16, 8>;    // Output serial clock divider
            using CKOUTSRC = Field<30, 1>;    // Output serial clock source selection
            using DFSDMEN = Field<31, 1>;    // Global enable for DFSDM interface
        };

        // DFSDM channel configuration 7 register 1
        struct DFSDM_CHCFG7R1 : public Register<0x4001741c> {
            using SITP = Field<0, 2>;    // Serial interface type for channel 7
            using SPICKSEL = Field<2, 2>;    // SPI clock select for channel 7
            using SCDEN = Field<5, 1>;    // Short-circuit detector enable on channel 7
            using CKABEN = Field<6, 1>;    // Clock absence detector enable on channel 7
            using CHEN = Field<7, 1>;    // Channel 7 enable
            using CHINSEL = Field<8, 1>;    // Channel inputs selection
            using DATMPX = Field<12, 2>;    // Input data multiplexer for channel 7
            using DATPACK = Field<14, 2>;    // Data packing mode in DFSDM_CHDATINyR register
            using CKOUTDIV = Field<16, 8>;    // Output serial clock divider
            using CKOUTSRC = Field<30, 1>;    // Output serial clock source selection
            using DFSDMEN = Field<31, 1>;    // Global enable for DFSDM interface
        };

        // DFSDM channel configuration 0 register 2
        struct DFSDM_CHCFG0R2 : public Register<0x40017420> {
            using DTRBS = Field<3, 5>;    // Data right bit-shift for channel 0
            using OFFSET = Field<8, 24>;    // 24-bit calibration offset for channel 0
        };

        // DFSDM channel configuration 1 register 2
        struct DFSDM_CHCFG1R2 : public Register<0x40017424> {
            using DTRBS = Field<3, 5>;    // Data right bit-shift for channel 1
            using OFFSET = Field<8, 24>;    // 24-bit calibration offset for channel 1
        };

        // DFSDM channel configuration 2 register 2
        struct DFSDM_CHCFG2R2 : public Register<0x40017428> {
            using DTRBS = Field<3, 5>;    // Data right bit-shift for channel 2
            using OFFSET = Field<8, 24>;    // 24-bit calibration offset for channel 2
        };

        // DFSDM channel configuration 3 register 2
        struct DFSDM_CHCFG3R2 : public Register<0x4001742c> {
            using DTRBS = Field<3, 5>;    // Data right bit-shift for channel 3
            using OFFSET = Field<8, 24>;    // 24-bit calibration offset for channel 3
        };

        // DFSDM channel configuration 4 register 2
        struct DFSDM_CHCFG4R2 : public Register<0x40017430> {
            using DTRBS = Field<3, 5>;    // Data right bit-shift for channel 4
            using OFFSET = Field<8, 24>;    // 24-bit calibration offset for channel 4
        };

        // DFSDM channel configuration 5 register 2
        struct DFSDM_CHCFG5R2 : public Register<0x40017434> {
            using DTRBS = Field<3, 5>;    // Data right bit-shift for channel 5
            using OFFSET = Field<8, 24>;    // 24-bit calibration offset for channel 5
        };

        // DFSDM channel configuration 6 register 2
        struct DFSDM_CHCFG6R2 : public Register<0x40017438> {
            using DTRBS = Field<3, 5>;    // Data right bit-shift for channel 6
            using OFFSET = Field<8, 24>;    // 24-bit calibration offset for channel 6
        };

        // DFSDM channel configuration 7 register 2
        struct DFSDM_CHCFG7R2 : public Register<0x4001743c> {
            using DTRBS = Field<3, 5>;    // Data right bit-shift for channel 7
            using OFFSET = Field<8, 24>;    // 24-bit calibration offset for channel 7
        };

        // DFSDM analog watchdog and short-circuit detector register
        struct DFSDM_AWSCD0R : public Register<0x40017440> {
            using SCDT = Field<0, 8>;    // short-circuit detector threshold for channel 0
            using BKSCD = Field<12, 4>;    // Break signal assignment for short-circuit detector on channel 0
            using AWFOSR = Field<16, 5>;    // Analog watchdog filter oversampling ratio (decimation rate) on channel 0
            using AWFORD = Field<22, 2>;    // Analog watchdog Sinc filter order on channel 0
        };

        // DFSDM analog watchdog and short-circuit detector register
        struct DFSDM_AWSCD1R : public Register<0x40017444> {
            using SCDT = Field<0, 8>;    // short-circuit detector threshold for channel 1
            using BKSCD = Field<12, 4>;    // Break signal assignment for short-circuit detector on channel 1
            using AWFOSR = Field<16, 5>;    // Analog watchdog filter oversampling ratio (decimation rate) on channel 1
            using AWFORD = Field<22, 2>;    // Analog watchdog Sinc filter order on channel 1
        };

        // DFSDM analog watchdog and short-circuit detector register
        struct DFSDM_AWSCD2R : public Register<0x40017448> {
            using SCDT = Field<0, 8>;    // short-circuit detector threshold for channel 2
            using BKSCD = Field<12, 4>;    // Break signal assignment for short-circuit detector on channel 2
            using AWFOSR = Field<16, 5>;    // Analog watchdog filter oversampling ratio (decimation rate) on channel 2
            using AWFORD = Field<22, 2>;    // Analog watchdog Sinc filter order on channel 2
        };

        // DFSDM analog watchdog and short-circuit detector register
        struct DFSDM_AWSCD3R : public Register<0x4001744c> {
            using SCDT = Field<0, 8>;    // short-circuit detector threshold for channel 3
            using BKSCD = Field<12, 4>;    // Break signal assignment for short-circuit detector on channel 3
            using AWFOSR = Field<16, 5>;    // Analog watchdog filter oversampling ratio (decimation rate) on channel 3
            using AWFORD = Field<22, 2>;    // Analog watchdog Sinc filter order on channel 3
        };

        // DFSDM analog watchdog and short-circuit detector register
        struct DFSDM_AWSCD4R : public Register<0x40017450> {
            using SCDT = Field<0, 8>;    // short-circuit detector threshold for channel 4
            using BKSCD = Field<12, 4>;    // Break signal assignment for short-circuit detector on channel 4
            using AWFOSR = Field<16, 5>;    // Analog watchdog filter oversampling ratio (decimation rate) on channel 4
            using AWFORD = Field<22, 2>;    // Analog watchdog Sinc filter order on channel 4
        };

        // DFSDM analog watchdog and short-circuit detector register
        struct DFSDM_AWSCD5R : public Register<0x40017454> {
            using SCDT = Field<0, 8>;    // short-circuit detector threshold for channel 5
            using BKSCD = Field<12, 4>;    // Break signal assignment for short-circuit detector on channel 5
            using AWFOSR = Field<16, 5>;    // Analog watchdog filter oversampling ratio (decimation rate) on channel 5
            using AWFORD = Field<22, 2>;    // Analog watchdog Sinc filter order on channel 5
        };

        // DFSDM analog watchdog and short-circuit detector register
        struct DFSDM_AWSCD6R : public Register<0x40017458> {
            using SCDT = Field<0, 8>;    // short-circuit detector threshold for channel 6
            using BKSCD = Field<12, 4>;    // Break signal assignment for short-circuit detector on channel 6
            using AWFOSR = Field<16, 5>;    // Analog watchdog filter oversampling ratio (decimation rate) on channel 6
            using AWFORD = Field<22, 2>;    // Analog watchdog Sinc filter order on channel 6
        };

        // DFSDM analog watchdog and short-circuit detector register
        struct DFSDM_AWSCD7R : public Register<0x4001745c> {
            using SCDT = Field<0, 8>;    // short-circuit detector threshold for channel 7
            using BKSCD = Field<12, 4>;    // Break signal assignment for short-circuit detector on channel 7
            using AWFOSR = Field<16, 5>;    // Analog watchdog filter oversampling ratio (decimation rate) on channel 7
            using AWFORD = Field<22, 2>;    // Analog watchdog Sinc filter order on channel 7
        };

        // DFSDM channel watchdog filter data register
        struct DFSDM_CHWDAT0R : public RegisterReadOnly<0x40017460> {
            using WDATA = Field<0, 16>;    // Input channel y watchdog data
        };

        // DFSDM channel watchdog filter data register
        struct DFSDM_CHWDAT1R : public RegisterReadOnly<0x40017464> {
            using WDATA = Field<0, 16>;    // Input channel y watchdog data
        };

        // DFSDM channel watchdog filter data register
        struct DFSDM_CHWDAT2R : public RegisterReadOnly<0x40017468> {
            using WDATA = Field<0, 16>;    // Input channel y watchdog data
        };

        // DFSDM channel watchdog filter data register
        struct DFSDM_CHWDAT3R : public RegisterReadOnly<0x4001746c> {
            using WDATA = Field<0, 16>;    // Input channel y watchdog data
        };

        // DFSDM channel watchdog filter data register
        struct DFSDM_CHWDAT4R : public RegisterReadOnly<0x40017470> {
            using WDATA = Field<0, 16>;    // Input channel y watchdog data
        };

        // DFSDM channel watchdog filter data register
        struct DFSDM_CHWDAT5R : public RegisterReadOnly<0x40017474> {
            using WDATA = Field<0, 16>;    // Input channel y watchdog data
        };

        // DFSDM channel watchdog filter data register
        struct DFSDM_CHWDAT6R : public RegisterReadOnly<0x40017478> {
            using WDATA = Field<0, 16>;    // Input channel y watchdog data
        };

        // DFSDM channel watchdog filter data register
        struct DFSDM_CHWDAT7R : public RegisterReadOnly<0x4001747c> {
            using WDATA = Field<0, 16>;    // Input channel y watchdog data
        };

        // DFSDM channel data input register
        struct DFSDM_CHDATIN0R : public Register<0x40017480> {
            using INDAT0 = Field<0, 16>;    // Input data for channel 0
            using INDAT1 = Field<16, 16>;    // Input data for channel 1
        };

        // DFSDM channel data input register
        struct DFSDM_CHDATIN1R : public Register<0x40017484> {
            using INDAT0 = Field<0, 16>;    // Input data for channel 1
            using INDAT1 = Field<16, 16>;    // Input data for channel 2
        };

        // DFSDM channel data input register
        struct DFSDM_CHDATIN2R : public Register<0x40017488> {
            using INDAT0 = Field<0, 16>;    // Input data for channel 2
            using INDAT1 = Field<16, 16>;    // Input data for channel 3
        };

        // DFSDM channel data input register
        struct DFSDM_CHDATIN3R : public Register<0x4001748c> {
            using INDAT0 = Field<0, 16>;    // Input data for channel 3
            using INDAT1 = Field<16, 16>;    // Input data for channel 4
        };

        // DFSDM channel data input register
        struct DFSDM_CHDATIN4R : public Register<0x40017490> {
            using INDAT0 = Field<0, 16>;    // Input data for channel 4
            using INDAT1 = Field<16, 16>;    // Input data for channel 5
        };

        // DFSDM channel data input register
        struct DFSDM_CHDATIN5R : public Register<0x40017494> {
            using INDAT0 = Field<0, 16>;    // Input data for channel 5
            using INDAT1 = Field<16, 16>;    // Input data for channel 6
        };

        // DFSDM channel data input register
        struct DFSDM_CHDATIN6R : public Register<0x40017498> {
            using INDAT0 = Field<0, 16>;    // Input data for channel 6
            using INDAT1 = Field<16, 16>;    // Input data for channel 7
        };

        // DFSDM channel data input register
        struct DFSDM_CHDATIN7R : public Register<0x4001749c> {
            using INDAT0 = Field<0, 16>;    // Input data for channel 7
            using INDAT1 = Field<16, 16>;    // Input data for channel 8
        };

        // DFSDM control register 1
        struct DFSDM0_CR1 : public Register<0x400174a0> {
            using DFEN = Field<0, 1>;    // DFSDM enable
            using JSWSTART = Field<1, 1>;    // Start a conversion of the injected group of channels
            using JSYNC = Field<3, 1>;    // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
            using JSCAN = Field<4, 1>;    // Scanning conversion mode for injected conversions
            using JDMAEN = Field<5, 1>;    // DMA channel enabled to read data for the injected channel group
            using JEXTSEL = Field<8, 5>;    // Trigger signal selection for launching injected conversions
            using JEXTEN = Field<13, 2>;    // Trigger enable and trigger edge selection for injected conversions
            using RSWSTART = Field<17, 1>;    // Software start of a conversion on the regular channel
            using RCONT = Field<18, 1>;    // Continuous mode selection for regular conversions
            using RSYNC = Field<19, 1>;    // Launch regular conversion synchronously with DFSDM0
            using RDMAEN = Field<21, 1>;    // DMA channel enabled to read data for the regular conversion
            using RCH = Field<24, 3>;    // Regular channel selection
            using FAST = Field<29, 1>;    // Fast conversion mode selection for regular conversions
            using AWFSEL = Field<30, 1>;    // Analog watchdog fast mode select
        };

        // DFSDM control register 1
        struct DFSDM1_CR1 : public Register<0x400174a4> {
            using DFEN = Field<0, 1>;    // DFSDM enable
            using JSWSTART = Field<1, 1>;    // Start a conversion of the injected group of channels
            using JSYNC = Field<3, 1>;    // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
            using JSCAN = Field<4, 1>;    // Scanning conversion mode for injected conversions
            using JDMAEN = Field<5, 1>;    // DMA channel enabled to read data for the injected channel group
            using JEXTSEL = Field<8, 5>;    // Trigger signal selection for launching injected conversions
            using JEXTEN = Field<13, 2>;    // Trigger enable and trigger edge selection for injected conversions
            using RSWSTART = Field<17, 1>;    // Software start of a conversion on the regular channel
            using RCONT = Field<18, 1>;    // Continuous mode selection for regular conversions
            using RSYNC = Field<19, 1>;    // Launch regular conversion synchronously with DFSDM0
            using RDMAEN = Field<21, 1>;    // DMA channel enabled to read data for the regular conversion
            using RCH = Field<24, 3>;    // Regular channel selection
            using FAST = Field<29, 1>;    // Fast conversion mode selection for regular conversions
            using AWFSEL = Field<30, 1>;    // Analog watchdog fast mode select
        };

        // DFSDM control register 1
        struct DFSDM2_CR1 : public Register<0x400174a8> {
            using DFEN = Field<0, 1>;    // DFSDM enable
            using JSWSTART = Field<1, 1>;    // Start a conversion of the injected group of channels
            using JSYNC = Field<3, 1>;    // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
            using JSCAN = Field<4, 1>;    // Scanning conversion mode for injected conversions
            using JDMAEN = Field<5, 1>;    // DMA channel enabled to read data for the injected channel group
            using JEXTSEL = Field<8, 5>;    // Trigger signal selection for launching injected conversions
            using JEXTEN = Field<13, 2>;    // Trigger enable and trigger edge selection for injected conversions
            using RSWSTART = Field<17, 1>;    // Software start of a conversion on the regular channel
            using RCONT = Field<18, 1>;    // Continuous mode selection for regular conversions
            using RSYNC = Field<19, 1>;    // Launch regular conversion synchronously with DFSDM0
            using RDMAEN = Field<21, 1>;    // DMA channel enabled to read data for the regular conversion
            using RCH = Field<24, 3>;    // Regular channel selection
            using FAST = Field<29, 1>;    // Fast conversion mode selection for regular conversions
            using AWFSEL = Field<30, 1>;    // Analog watchdog fast mode select
        };

        // DFSDM control register 1
        struct DFSDM3_CR1 : public Register<0x400174ac> {
            using DFEN = Field<0, 1>;    // DFSDM enable
            using JSWSTART = Field<1, 1>;    // Start a conversion of the injected group of channels
            using JSYNC = Field<3, 1>;    // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
            using JSCAN = Field<4, 1>;    // Scanning conversion mode for injected conversions
            using JDMAEN = Field<5, 1>;    // DMA channel enabled to read data for the injected channel group
            using JEXTSEL = Field<8, 5>;    // Trigger signal selection for launching injected conversions
            using JEXTEN = Field<13, 2>;    // Trigger enable and trigger edge selection for injected conversions
            using RSWSTART = Field<17, 1>;    // Software start of a conversion on the regular channel
            using RCONT = Field<18, 1>;    // Continuous mode selection for regular conversions
            using RSYNC = Field<19, 1>;    // Launch regular conversion synchronously with DFSDM0
            using RDMAEN = Field<21, 1>;    // DMA channel enabled to read data for the regular conversion
            using RCH = Field<24, 3>;    // Regular channel selection
            using FAST = Field<29, 1>;    // Fast conversion mode selection for regular conversions
            using AWFSEL = Field<30, 1>;    // Analog watchdog fast mode select
        };

        // DFSDM control register 2
        struct DFSDM0_CR2 : public Register<0x400174b0> {
            using JEOCIE = Field<0, 1>;    // Injected end of conversion interrupt enable
            using REOCIE = Field<1, 1>;    // Regular end of conversion interrupt enable
            using JOVRIE = Field<2, 1>;    // Injected data overrun interrupt enable
            using ROVRIE = Field<3, 1>;    // Regular data overrun interrupt enable
            using AWDIE = Field<4, 1>;    // Analog watchdog interrupt enable
            using SCDIE = Field<5, 1>;    // Short-circuit detector interrupt enable
            using CKABIE = Field<6, 1>;    // Clock absence interrupt enable
            using EXCH = Field<8, 8>;    // Extremes detector channel selection
            using AWDCH = Field<16, 8>;    // Analog watchdog channel selection
        };

        // DFSDM control register 2
        struct DFSDM1_CR2 : public Register<0x400174b4> {
            using JEOCIE = Field<0, 1>;    // Injected end of conversion interrupt enable
            using REOCIE = Field<1, 1>;    // Regular end of conversion interrupt enable
            using JOVRIE = Field<2, 1>;    // Injected data overrun interrupt enable
            using ROVRIE = Field<3, 1>;    // Regular data overrun interrupt enable
            using AWDIE = Field<4, 1>;    // Analog watchdog interrupt enable
            using SCDIE = Field<5, 1>;    // Short-circuit detector interrupt enable
            using CKABIE = Field<6, 1>;    // Clock absence interrupt enable
            using EXCH = Field<8, 8>;    // Extremes detector channel selection
            using AWDCH = Field<16, 8>;    // Analog watchdog channel selection
        };

        // DFSDM control register 2
        struct DFSDM2_CR2 : public Register<0x400174b8> {
            using JEOCIE = Field<0, 1>;    // Injected end of conversion interrupt enable
            using REOCIE = Field<1, 1>;    // Regular end of conversion interrupt enable
            using JOVRIE = Field<2, 1>;    // Injected data overrun interrupt enable
            using ROVRIE = Field<3, 1>;    // Regular data overrun interrupt enable
            using AWDIE = Field<4, 1>;    // Analog watchdog interrupt enable
            using SCDIE = Field<5, 1>;    // Short-circuit detector interrupt enable
            using CKABIE = Field<6, 1>;    // Clock absence interrupt enable
            using EXCH = Field<8, 8>;    // Extremes detector channel selection
            using AWDCH = Field<16, 8>;    // Analog watchdog channel selection
        };

        // DFSDM control register 2
        struct DFSDM3_CR2 : public Register<0x400174bc> {
            using JEOCIE = Field<0, 1>;    // Injected end of conversion interrupt enable
            using REOCIE = Field<1, 1>;    // Regular end of conversion interrupt enable
            using JOVRIE = Field<2, 1>;    // Injected data overrun interrupt enable
            using ROVRIE = Field<3, 1>;    // Regular data overrun interrupt enable
            using AWDIE = Field<4, 1>;    // Analog watchdog interrupt enable
            using SCDIE = Field<5, 1>;    // Short-circuit detector interrupt enable
            using CKABIE = Field<6, 1>;    // Clock absence interrupt enable
            using EXCH = Field<8, 8>;    // Extremes detector channel selection
            using AWDCH = Field<16, 8>;    // Analog watchdog channel selection
        };

        // DFSDM interrupt and status register
        struct DFSDM0_ISR : public RegisterReadOnly<0x400174c0> {
            using JEOCF = Field<0, 1>;    // End of injected conversion flag
            using REOCF = Field<1, 1>;    // End of regular conversion flag
            using JOVRF = Field<2, 1>;    // Injected conversion overrun flag
            using ROVRF = Field<3, 1>;    // Regular conversion overrun flag
            using AWDF = Field<4, 1>;    // Analog watchdog
            using JCIP = Field<13, 1>;    // Injected conversion in progress status
            using RCIP = Field<14, 1>;    // Regular conversion in progress status
            using CKABF = Field<16, 8>;    // Clock absence flag
            using SCDF = Field<24, 8>;    // short-circuit detector flag
        };

        // DFSDM interrupt and status register
        struct DFSDM1_ISR : public RegisterReadOnly<0x400174c4> {
            using JEOCF = Field<0, 1>;    // End of injected conversion flag
            using REOCF = Field<1, 1>;    // End of regular conversion flag
            using JOVRF = Field<2, 1>;    // Injected conversion overrun flag
            using ROVRF = Field<3, 1>;    // Regular conversion overrun flag
            using AWDF = Field<4, 1>;    // Analog watchdog
            using JCIP = Field<13, 1>;    // Injected conversion in progress status
            using RCIP = Field<14, 1>;    // Regular conversion in progress status
            using CKABF = Field<16, 8>;    // Clock absence flag
            using SCDF = Field<24, 8>;    // short-circuit detector flag
        };

        // DFSDM interrupt and status register
        struct DFSDM2_ISR : public RegisterReadOnly<0x400174c8> {
            using JEOCF = Field<0, 1>;    // End of injected conversion flag
            using REOCF = Field<1, 1>;    // End of regular conversion flag
            using JOVRF = Field<2, 1>;    // Injected conversion overrun flag
            using ROVRF = Field<3, 1>;    // Regular conversion overrun flag
            using AWDF = Field<4, 1>;    // Analog watchdog
            using JCIP = Field<13, 1>;    // Injected conversion in progress status
            using RCIP = Field<14, 1>;    // Regular conversion in progress status
            using CKABF = Field<16, 8>;    // Clock absence flag
            using SCDF = Field<24, 8>;    // short-circuit detector flag
        };

        // DFSDM interrupt and status register
        struct DFSDM3_ISR : public RegisterReadOnly<0x400174cc> {
            using JEOCF = Field<0, 1>;    // End of injected conversion flag
            using REOCF = Field<1, 1>;    // End of regular conversion flag
            using JOVRF = Field<2, 1>;    // Injected conversion overrun flag
            using ROVRF = Field<3, 1>;    // Regular conversion overrun flag
            using AWDF = Field<4, 1>;    // Analog watchdog
            using JCIP = Field<13, 1>;    // Injected conversion in progress status
            using RCIP = Field<14, 1>;    // Regular conversion in progress status
            using CKABF = Field<16, 8>;    // Clock absence flag
            using SCDF = Field<24, 8>;    // short-circuit detector flag
        };

        // DFSDM interrupt flag clear register
        struct DFSDM0_ICR : public Register<0x400174d0> {
            using CLRJOVRF = Field<2, 1>;    // Clear the injected conversion overrun flag
            using CLRROVRF = Field<3, 1>;    // Clear the regular conversion overrun flag
            using CLRCKABF = Field<16, 8>;    // Clear the clock absence flag
            using CLRSCDF = Field<24, 8>;    // Clear the short-circuit detector flag
        };

        // DFSDM interrupt flag clear register
        struct DFSDM1_ICR : public Register<0x400174d4> {
            using CLRJOVRF = Field<2, 1>;    // Clear the injected conversion overrun flag
            using CLRROVRF = Field<3, 1>;    // Clear the regular conversion overrun flag
            using CLRCKABF = Field<16, 8>;    // Clear the clock absence flag
            using CLRSCDF = Field<24, 8>;    // Clear the short-circuit detector flag
        };

        // DFSDM interrupt flag clear register
        struct DFSDM2_ICR : public Register<0x400174d8> {
            using CLRJOVRF = Field<2, 1>;    // Clear the injected conversion overrun flag
            using CLRROVRF = Field<3, 1>;    // Clear the regular conversion overrun flag
            using CLRCKABF = Field<16, 8>;    // Clear the clock absence flag
            using CLRSCDF = Field<24, 8>;    // Clear the short-circuit detector flag
        };

        // DFSDM interrupt flag clear register
        struct DFSDM3_ICR : public Register<0x400174dc> {
            using CLRJOVRF = Field<2, 1>;    // Clear the injected conversion overrun flag
            using CLRROVRF = Field<3, 1>;    // Clear the regular conversion overrun flag
            using CLRCKABF = Field<16, 8>;    // Clear the clock absence flag
            using CLRSCDF = Field<24, 8>;    // Clear the short-circuit detector flag
        };

        // DFSDM injected channel group selection register
        struct DFSDM0_JCHGR : public Register<0x400174e0> {
            using JCHG = Field<0, 8>;    // Injected channel group selection
        };

        // DFSDM injected channel group selection register
        struct DFSDM1_JCHGR : public Register<0x400174e4> {
            using JCHG = Field<0, 8>;    // Injected channel group selection
        };

        // DFSDM injected channel group selection register
        struct DFSDM2_JCHGR : public Register<0x400174e8> {
            using JCHG = Field<0, 8>;    // Injected channel group selection
        };

        // DFSDM injected channel group selection register
        struct DFSDM3_JCHGR : public Register<0x400174ec> {
            using JCHG = Field<0, 8>;    // Injected channel group selection
        };

        // DFSDM filter control register
        struct DFSDM0_FCR : public Register<0x400174f0> {
            using IOSR = Field<0, 8>;    // Integrator oversampling ratio (averaging length)
            using FOSR = Field<16, 10>;    // Sinc filter oversampling ratio (decimation rate)
            using FORD = Field<29, 3>;    // Sinc filter order
        };

        // DFSDM filter control register
        struct DFSDM1_FCR : public Register<0x400174f4> {
            using IOSR = Field<0, 8>;    // Integrator oversampling ratio (averaging length)
            using FOSR = Field<16, 10>;    // Sinc filter oversampling ratio (decimation rate)
            using FORD = Field<29, 3>;    // Sinc filter order
        };

        // DFSDM filter control register
        struct DFSDM2_FCR : public Register<0x400174f8> {
            using IOSR = Field<0, 8>;    // Integrator oversampling ratio (averaging length)
            using FOSR = Field<16, 10>;    // Sinc filter oversampling ratio (decimation rate)
            using FORD = Field<29, 3>;    // Sinc filter order
        };

        // DFSDM filter control register
        struct DFSDM3_FCR : public Register<0x400174fc> {
            using IOSR = Field<0, 8>;    // Integrator oversampling ratio (averaging length)
            using FOSR = Field<16, 10>;    // Sinc filter oversampling ratio (decimation rate)
            using FORD = Field<29, 3>;    // Sinc filter order
        };

        // DFSDM data register for injected group
        struct DFSDM0_JDATAR : public RegisterReadOnly<0x40017500> {
            using JDATACH = Field<0, 3>;    // Injected channel most recently converted
            using JDATA = Field<8, 24>;    // Injected group conversion data
        };

        // DFSDM data register for injected group
        struct DFSDM1_JDATAR : public RegisterReadOnly<0x40017504> {
            using JDATACH = Field<0, 3>;    // Injected channel most recently converted
            using JDATA = Field<8, 24>;    // Injected group conversion data
        };

        // DFSDM data register for injected group
        struct DFSDM2_JDATAR : public RegisterReadOnly<0x40017508> {
            using JDATACH = Field<0, 3>;    // Injected channel most recently converted
            using JDATA = Field<8, 24>;    // Injected group conversion data
        };

        // DFSDM data register for injected group
        struct DFSDM3_JDATAR : public RegisterReadOnly<0x4001750c> {
            using JDATACH = Field<0, 3>;    // Injected channel most recently converted
            using JDATA = Field<8, 24>;    // Injected group conversion data
        };

        // DFSDM data register for the regular channel
        struct DFSDM0_RDATAR : public RegisterReadOnly<0x40017510> {
            using RDATACH = Field<0, 3>;    // Regular channel most recently converted
            using RPEND = Field<4, 1>;    // Regular channel pending data
            using RDATA = Field<8, 24>;    // Regular channel conversion data
        };

        // DFSDM data register for the regular channel
        struct DFSDM1_RDATAR : public RegisterReadOnly<0x40017514> {
            using RDATACH = Field<0, 3>;    // Regular channel most recently converted
            using RPEND = Field<4, 1>;    // Regular channel pending data
            using RDATA = Field<8, 24>;    // Regular channel conversion data
        };

        // DFSDM data register for the regular channel
        struct DFSDM2_RDATAR : public RegisterReadOnly<0x40017518> {
            using RDATACH = Field<0, 3>;    // Regular channel most recently converted
            using RPEND = Field<4, 1>;    // Regular channel pending data
            using RDATA = Field<8, 24>;    // Regular channel conversion data
        };

        // DFSDM data register for the regular channel
        struct DFSDM3_RDATAR : public RegisterReadOnly<0x4001751c> {
            using RDATACH = Field<0, 3>;    // Regular channel most recently converted
            using RPEND = Field<4, 1>;    // Regular channel pending data
            using RDATA = Field<8, 24>;    // Regular channel conversion data
        };

        // DFSDM analog watchdog high threshold register
        struct DFSDM0_AWHTR : public Register<0x40017520> {
            using BKAWH = Field<0, 4>;    // Break signal assignment to analog watchdog high threshold event
            using AWHT = Field<8, 24>;    // Analog watchdog high threshold
        };

        // DFSDM analog watchdog high threshold register
        struct DFSDM1_AWHTR : public Register<0x40017524> {
            using BKAWH = Field<0, 4>;    // Break signal assignment to analog watchdog high threshold event
            using AWHT = Field<8, 24>;    // Analog watchdog high threshold
        };

        // DFSDM analog watchdog high threshold register
        struct DFSDM2_AWHTR : public Register<0x40017528> {
            using BKAWH = Field<0, 4>;    // Break signal assignment to analog watchdog high threshold event
            using AWHT = Field<8, 24>;    // Analog watchdog high threshold
        };

        // DFSDM analog watchdog high threshold register
        struct DFSDM3_AWHTR : public Register<0x4001752c> {
            using BKAWH = Field<0, 4>;    // Break signal assignment to analog watchdog high threshold event
            using AWHT = Field<8, 24>;    // Analog watchdog high threshold
        };

        // DFSDM analog watchdog low threshold register
        struct DFSDM0_AWLTR : public Register<0x40017530> {
            using BKAWL = Field<0, 4>;    // Break signal assignment to analog watchdog low threshold event
            using AWLT = Field<8, 24>;    // Analog watchdog low threshold
        };

        // DFSDM analog watchdog low threshold register
        struct DFSDM1_AWLTR : public Register<0x40017534> {
            using BKAWL = Field<0, 4>;    // Break signal assignment to analog watchdog low threshold event
            using AWLT = Field<8, 24>;    // Analog watchdog low threshold
        };

        // DFSDM analog watchdog low threshold register
        struct DFSDM2_AWLTR : public Register<0x40017538> {
            using BKAWL = Field<0, 4>;    // Break signal assignment to analog watchdog low threshold event
            using AWLT = Field<8, 24>;    // Analog watchdog low threshold
        };

        // DFSDM analog watchdog low threshold register
        struct DFSDM3_AWLTR : public Register<0x4001753c> {
            using BKAWL = Field<0, 4>;    // Break signal assignment to analog watchdog low threshold event
            using AWLT = Field<8, 24>;    // Analog watchdog low threshold
        };

        // DFSDM analog watchdog status register
        struct DFSDM0_AWSR : public RegisterReadOnly<0x40017540> {
            using AWLTF = Field<0, 8>;    // Analog watchdog low threshold flag
            using AWHTF = Field<8, 8>;    // Analog watchdog high threshold flag
        };

        // DFSDM analog watchdog status register
        struct DFSDM1_AWSR : public RegisterReadOnly<0x40017544> {
            using AWLTF = Field<0, 8>;    // Analog watchdog low threshold flag
            using AWHTF = Field<8, 8>;    // Analog watchdog high threshold flag
        };

        // DFSDM analog watchdog status register
        struct DFSDM2_AWSR : public RegisterReadOnly<0x40017548> {
            using AWLTF = Field<0, 8>;    // Analog watchdog low threshold flag
            using AWHTF = Field<8, 8>;    // Analog watchdog high threshold flag
        };

        // DFSDM analog watchdog status register
        struct DFSDM3_AWSR : public RegisterReadOnly<0x4001754c> {
            using AWLTF = Field<0, 8>;    // Analog watchdog low threshold flag
            using AWHTF = Field<8, 8>;    // Analog watchdog high threshold flag
        };

        // DFSDM analog watchdog clear flag register
        struct DFSDM0_AWCFR : public Register<0x40017550> {
            using CLRAWLTF = Field<0, 8>;    // Clear the analog watchdog low threshold flag
            using CLRAWHTF = Field<8, 8>;    // Clear the analog watchdog high threshold flag
        };

        // DFSDM analog watchdog clear flag register
        struct DFSDM1_AWCFR : public Register<0x40017554> {
            using CLRAWLTF = Field<0, 8>;    // Clear the analog watchdog low threshold flag
            using CLRAWHTF = Field<8, 8>;    // Clear the analog watchdog high threshold flag
        };

        // DFSDM analog watchdog clear flag register
        struct DFSDM2_AWCFR : public Register<0x40017558> {
            using CLRAWLTF = Field<0, 8>;    // Clear the analog watchdog low threshold flag
            using CLRAWHTF = Field<8, 8>;    // Clear the analog watchdog high threshold flag
        };

        // DFSDM analog watchdog clear flag register
        struct DFSDM3_AWCFR : public Register<0x4001755c> {
            using CLRAWLTF = Field<0, 8>;    // Clear the analog watchdog low threshold flag
            using CLRAWHTF = Field<8, 8>;    // Clear the analog watchdog high threshold flag
        };

        // DFSDM Extremes detector maximum register
        struct DFSDM0_EXMAX : public RegisterReadOnly<0x40017560> {
            using EXMAXCH = Field<0, 3>;    // Extremes detector maximum data channel
            using EXMAX = Field<8, 24>;    // Extremes detector maximum value
        };

        // DFSDM Extremes detector maximum register
        struct DFSDM1_EXMAX : public RegisterReadOnly<0x40017564> {
            using EXMAXCH = Field<0, 3>;    // Extremes detector maximum data channel
            using EXMAX = Field<8, 24>;    // Extremes detector maximum value
        };

        // DFSDM Extremes detector maximum register
        struct DFSDM2_EXMAX : public RegisterReadOnly<0x40017568> {
            using EXMAXCH = Field<0, 3>;    // Extremes detector maximum data channel
            using EXMAX = Field<8, 24>;    // Extremes detector maximum value
        };

        // DFSDM Extremes detector maximum register
        struct DFSDM3_EXMAX : public RegisterReadOnly<0x4001756c> {
            using EXMAXCH = Field<0, 3>;    // Extremes detector maximum data channel
            using EXMAX = Field<8, 24>;    // Extremes detector maximum value
        };

        // DFSDM Extremes detector minimum register
        struct DFSDM0_EXMIN : public RegisterReadOnly<0x40017570> {
            using EXMINCH = Field<0, 3>;    // Extremes detector minimum data channel
            using EXMIN = Field<8, 24>;    // Extremes detector minimum value
        };

        // DFSDM Extremes detector minimum register
        struct DFSDM1_EXMIN : public RegisterReadOnly<0x40017574> {
            using EXMINCH = Field<0, 3>;    // Extremes detector minimum data channel
            using EXMIN = Field<8, 24>;    // Extremes detector minimum value
        };

        // DFSDM Extremes detector minimum register
        struct DFSDM2_EXMIN : public RegisterReadOnly<0x40017578> {
            using EXMINCH = Field<0, 3>;    // Extremes detector minimum data channel
            using EXMIN = Field<8, 24>;    // Extremes detector minimum value
        };

        // DFSDM Extremes detector minimum register
        struct DFSDM3_EXMIN : public RegisterReadOnly<0x4001757c> {
            using EXMINCH = Field<0, 3>;    // Extremes detector minimum data channel
            using EXMIN = Field<8, 24>;    // Extremes detector minimum value
        };

        // DFSDM conversion timer register
        struct DFSDM0_CNVTIMR : public RegisterReadOnly<0x40017580> {
            using CNVCNT = Field<4, 28>;    // 28-bit timer counting conversion time
        };

        // DFSDM conversion timer register
        struct DFSDM1_CNVTIMR : public RegisterReadOnly<0x40017584> {
            using CNVCNT = Field<4, 28>;    // 28-bit timer counting conversion time
        };

        // DFSDM conversion timer register
        struct DFSDM2_CNVTIMR : public RegisterReadOnly<0x40017588> {
            using CNVCNT = Field<4, 28>;    // 28-bit timer counting conversion time
        };

        // DFSDM conversion timer register
        struct DFSDM3_CNVTIMR : public RegisterReadOnly<0x4001758c> {
            using CNVCNT = Field<4, 28>;    // 28-bit timer counting conversion time
        };

    };

    // JPEG codec
    struct JPEG {
        // JPEG codec configuration register 0
        struct JPEG_CONFR0 : public RegisterWriteOnly<0x50051000> {
            using START = Field<0, 1>;    // Start
        };

        // JPEG codec configuration register 1
        struct JPEG_CONFR1 : public Register<0x50051004> {
            using NF = Field<0, 2>;    // Number of color components
            using DE = Field<3, 1>;    // Decoding Enable
            using COLORSPACE = Field<4, 2>;    // Color Space
            using NS = Field<6, 2>;    // Number of components for Scan
            using HDR = Field<8, 1>;    // Header Processing
            using YSIZE = Field<16, 16>;    // Y Size
        };

        // JPEG codec configuration register 2
        struct JPEG_CONFR2 : public Register<0x50051008> {
            using NMCU = Field<0, 26>;    // Number of MCU
        };

        // JPEG codec configuration register 3
        struct JPEG_CONFR3 : public Register<0x5005100c> {
            using XSIZE = Field<16, 16>;    // X size
        };

        // JPEG codec configuration register 4
        struct JPEG_CONFR4 : public Register<0x50051010> {
            using HD = Field<0, 1>;    // Huffman DC
            using HA = Field<1, 1>;    // Huffman AC
            using QT = Field<2, 2>;    // Quantization Table
            using NB = Field<4, 4>;    // Number of Block
            using VSF = Field<8, 4>;    // Vertical Sampling Factor
            using HSF = Field<12, 4>;    // Horizontal Sampling Factor
        };

        // JPEG codec configuration register 5
        struct JPEG_CONFR5 : public Register<0x50051014> {
            using HD = Field<0, 1>;    // Huffman DC
            using HA = Field<1, 1>;    // Huffman AC
            using QT = Field<2, 2>;    // Quantization Table
            using NB = Field<4, 4>;    // Number of Block
            using VSF = Field<8, 4>;    // Vertical Sampling Factor
            using HSF = Field<12, 4>;    // Horizontal Sampling Factor
        };

        // JPEG codec configuration register 6
        struct JPEG_CONFR6 : public Register<0x50051018> {
            using HD = Field<0, 1>;    // Huffman DC
            using HA = Field<1, 1>;    // Huffman AC
            using QT = Field<2, 2>;    // Quantization Table
            using NB = Field<4, 4>;    // Number of Block
            using VSF = Field<8, 4>;    // Vertical Sampling Factor
            using HSF = Field<12, 4>;    // Horizontal Sampling Factor
        };

        // JPEG codec configuration register 7
        struct JPEG_CONFR7 : public Register<0x5005101c> {
            using HD = Field<0, 1>;    // Huffman DC
            using HA = Field<1, 1>;    // Huffman AC
            using QT = Field<2, 2>;    // Quantization Table
            using NB = Field<4, 4>;    // Number of Block
            using VSF = Field<8, 4>;    // Vertical Sampling Factor
            using HSF = Field<12, 4>;    // Horizontal Sampling Factor
        };

        // JPEG control register
        struct JPEG_CR : public Register<0x50051030> {
            using JCEN = Field<0, 1>;    // JPEG Core Enable
            using IFTIE = Field<1, 1>;    // Input FIFO Threshold Interrupt Enable
            using IFNFIE = Field<2, 1>;    // Input FIFO Not Full Interrupt Enable
            using OFTIE = Field<3, 1>;    // Output FIFO Threshold Interrupt Enable
            using OFNEIE = Field<4, 1>;    // Output FIFO Not Empty Interrupt Enable
            using EOCIE = Field<5, 1>;    // End of Conversion Interrupt Enable
            using HPDIE = Field<6, 1>;    // Header Parsing Done Interrupt Enable
            using IDMAEN = Field<11, 1>;    // Input DMA Enable
            using ODMAEN = Field<12, 1>;    // Output DMA Enable
            using IFF = Field<13, 1>;    // Input FIFO Flush
            using OFF = Field<14, 1>;    // Output FIFO Flush
        };

        // JPEG status register
        struct JPEG_SR : public RegisterReadOnly<0x50051034> {
            using IFTF = Field<1, 1>;    // Input FIFO Threshold Flag
            using IFNFF = Field<2, 1>;    // Input FIFO Not Full Flag
            using OFTF = Field<3, 1>;    // Output FIFO Threshold Flag
            using OFNEF = Field<4, 1>;    // Output FIFO Not Empty Flag
            using EOCF = Field<5, 1>;    // End of Conversion Flag
            using HPDF = Field<6, 1>;    // Header Parsing Done Flag
            using COF = Field<7, 1>;    // Codec Operation Flag
        };

        // JPEG clear flag register
        struct JPEG_CFR : public RegisterWriteOnly<0x50051038> {
            using CEOCF = Field<5, 1>;    // Clear End of Conversion Flag
            using CHPDF = Field<6, 1>;    // Clear Header Parsing Done Flag
        };

        // JPEG data input register
        struct JPEG_DIR : public RegisterWriteOnly<0x50051040> {
            using DATAIN = Field<0, 32>;    // Data Input FIFO
        };

        // JPEG data output register
        struct JPEG_DOR : public RegisterReadOnly<0x50051044> {
            using DATAOUT = Field<0, 32>;    // Data Output FIFO
        };

        // JPEG quantization tables
        struct QMEM0_0 : public Register<0x50051050> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM0_1 : public Register<0x50051054> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM0_2 : public Register<0x50051058> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM0_3 : public Register<0x5005105c> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM0_4 : public Register<0x50051060> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM0_5 : public Register<0x50051064> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM0_6 : public Register<0x50051068> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM0_7 : public Register<0x5005106c> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM0_8 : public Register<0x50051070> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM0_9 : public Register<0x50051074> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM0_10 : public Register<0x50051078> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM0_11 : public Register<0x5005107c> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM0_12 : public Register<0x50051080> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM0_13 : public Register<0x50051084> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM0_14 : public Register<0x50051088> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM0_15 : public Register<0x5005108c> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM1_0 : public Register<0x50051090> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM1_1 : public Register<0x50051094> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM1_2 : public Register<0x50051098> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM1_3 : public Register<0x5005109c> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM1_4 : public Register<0x500510a0> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM1_5 : public Register<0x500510a4> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM1_6 : public Register<0x500510a8> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM1_7 : public Register<0x500510ac> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM1_8 : public Register<0x500510b0> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM1_9 : public Register<0x500510b4> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM1_10 : public Register<0x500510b8> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM1_11 : public Register<0x500510bc> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM1_12 : public Register<0x500510c0> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM1_13 : public Register<0x500510c4> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM1_14 : public Register<0x500510c8> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM1_15 : public Register<0x500510cc> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM2_0 : public Register<0x500510d0> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM2_1 : public Register<0x500510d4> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM2_2 : public Register<0x500510d8> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM2_3 : public Register<0x500510dc> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM2_4 : public Register<0x500510e0> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM2_5 : public Register<0x500510e4> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM2_6 : public Register<0x500510e8> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM2_7 : public Register<0x500510ec> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM2_8 : public Register<0x500510f0> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM2_9 : public Register<0x500510f4> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM2_10 : public Register<0x500510f8> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM2_11 : public Register<0x500510fc> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM2_12 : public Register<0x50051100> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM2_13 : public Register<0x50051104> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM2_14 : public Register<0x50051108> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM2_15 : public Register<0x5005110c> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM3_0 : public Register<0x50051110> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM3_1 : public Register<0x50051114> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM3_2 : public Register<0x50051118> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM3_3 : public Register<0x5005111c> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM3_4 : public Register<0x50051120> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM3_5 : public Register<0x50051124> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM3_6 : public Register<0x50051128> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM3_7 : public Register<0x5005112c> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM3_8 : public Register<0x50051130> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM3_9 : public Register<0x50051134> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM3_10 : public Register<0x50051138> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM3_11 : public Register<0x5005113c> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM3_12 : public Register<0x50051140> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM3_13 : public Register<0x50051144> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM3_14 : public Register<0x50051148> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG quantization tables
        struct QMEM3_15 : public Register<0x5005114c> {
            using QMem_RAM = Field<0, 32>;    // QMem RAM
        };

        // JPEG HuffMin tables
        struct HUFFMIN_0 : public Register<0x50051150> {
            using HuffMin_RAM = Field<0, 32>;    // HuffMin RAM
        };

        // JPEG HuffMin tables
        struct HUFFMIN_1 : public Register<0x50051154> {
            using HuffMin_RAM = Field<0, 32>;    // HuffMin RAM
        };

        // JPEG HuffMin tables
        struct HUFFMIN_2 : public Register<0x50051158> {
            using HuffMin_RAM = Field<0, 32>;    // HuffMin RAM
        };

        // JPEG HuffMin tables
        struct HUFFMIN_3 : public Register<0x5005115c> {
            using HuffMin_RAM = Field<0, 32>;    // HuffMin RAM
        };

        // JPEG HuffMin tables
        struct HUFFMIN_4 : public Register<0x50051160> {
            using HuffMin_RAM = Field<0, 32>;    // HuffMin RAM
        };

        // JPEG HuffMin tables
        struct HUFFMIN_5 : public Register<0x50051164> {
            using HuffMin_RAM = Field<0, 32>;    // HuffMin RAM
        };

        // JPEG HuffMin tables
        struct HUFFMIN_6 : public Register<0x50051168> {
            using HuffMin_RAM = Field<0, 32>;    // HuffMin RAM
        };

        // JPEG HuffMin tables
        struct HUFFMIN_7 : public Register<0x5005116c> {
            using HuffMin_RAM = Field<0, 32>;    // HuffMin RAM
        };

        // JPEG HuffMin tables
        struct HUFFMIN_8 : public Register<0x50051170> {
            using HuffMin_RAM = Field<0, 32>;    // HuffMin RAM
        };

        // JPEG HuffMin tables
        struct HUFFMIN_9 : public Register<0x50051174> {
            using HuffMin_RAM = Field<0, 32>;    // HuffMin RAM
        };

        // JPEG HuffMin tables
        struct HUFFMIN_10 : public Register<0x50051178> {
            using HuffMin_RAM = Field<0, 32>;    // HuffMin RAM
        };

        // JPEG HuffMin tables
        struct HUFFMIN_11 : public Register<0x5005117c> {
            using HuffMin_RAM = Field<0, 32>;    // HuffMin RAM
        };

        // JPEG HuffMin tables
        struct HUFFMIN_12 : public Register<0x50051180> {
            using HuffMin_RAM = Field<0, 32>;    // HuffMin RAM
        };

        // JPEG HuffMin tables
        struct HUFFMIN_13 : public Register<0x50051184> {
            using HuffMin_RAM = Field<0, 32>;    // HuffMin RAM
        };

        // JPEG HuffMin tables
        struct HUFFMIN_14 : public Register<0x50051188> {
            using HuffMin_RAM = Field<0, 32>;    // HuffMin RAM
        };

        // JPEG HuffMin tables
        struct HUFFMIN_15 : public Register<0x5005118c> {
            using HuffMin_RAM = Field<0, 32>;    // HuffMin RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE0 : public Register<0x50051190> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE1 : public Register<0x50051194> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE2 : public Register<0x50051198> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE3 : public Register<0x5005119c> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE4 : public Register<0x500511a0> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE5 : public Register<0x500511a4> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE6 : public Register<0x500511a8> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE7 : public Register<0x500511ac> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE8 : public Register<0x500511b0> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE9 : public Register<0x500511b4> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE10 : public Register<0x500511b8> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE11 : public Register<0x500511bc> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE12 : public Register<0x500511c0> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE13 : public Register<0x500511c4> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE14 : public Register<0x500511c8> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE15 : public Register<0x500511cc> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE16 : public Register<0x500511d0> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE17 : public Register<0x500511d4> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE18 : public Register<0x500511d8> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE19 : public Register<0x500511dc> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE20 : public Register<0x500511e0> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE21 : public Register<0x500511e4> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE22 : public Register<0x500511e8> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE23 : public Register<0x500511ec> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE24 : public Register<0x500511f0> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE25 : public Register<0x500511f4> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE26 : public Register<0x500511f8> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE27 : public Register<0x500511fc> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE28 : public Register<0x50051200> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE29 : public Register<0x50051204> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE30 : public Register<0x50051208> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HuffSymb tables
        struct HUFFBASE31 : public Register<0x5005120c> {
            using HuffBase_RAM_0 = Field<0, 9>;    // HuffBase RAM
            using HuffBase_RAM_1 = Field<16, 9>;    // HuffBase RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB0 : public Register<0x50051210> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB1 : public Register<0x50051214> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB2 : public Register<0x50051218> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB3 : public Register<0x5005121c> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB4 : public Register<0x50051220> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB5 : public Register<0x50051224> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB6 : public Register<0x50051228> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB7 : public Register<0x5005122c> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB8 : public Register<0x50051230> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB9 : public Register<0x50051234> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB10 : public Register<0x50051238> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB11 : public Register<0x5005123c> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB12 : public Register<0x50051240> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB13 : public Register<0x50051244> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB14 : public Register<0x50051248> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB15 : public Register<0x5005124c> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB16 : public Register<0x50051250> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB17 : public Register<0x50051254> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB18 : public Register<0x50051258> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB19 : public Register<0x5005125c> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB20 : public Register<0x50051260> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB21 : public Register<0x50051264> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB22 : public Register<0x50051268> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB23 : public Register<0x5005126c> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB24 : public Register<0x50051270> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB25 : public Register<0x50051274> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB26 : public Register<0x50051278> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB27 : public Register<0x5005127c> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB28 : public Register<0x50051280> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB29 : public Register<0x50051284> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB30 : public Register<0x50051288> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB31 : public Register<0x5005128c> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB32 : public Register<0x50051290> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB33 : public Register<0x50051294> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB34 : public Register<0x50051298> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB35 : public Register<0x5005129c> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB36 : public Register<0x500512a0> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB37 : public Register<0x500512a4> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB38 : public Register<0x500512a8> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB39 : public Register<0x500512ac> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB40 : public Register<0x500512b0> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB41 : public Register<0x500512b4> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB42 : public Register<0x500512b8> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB43 : public Register<0x500512bc> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB44 : public Register<0x500512c0> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB45 : public Register<0x500512c4> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB46 : public Register<0x500512c8> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB47 : public Register<0x500512cc> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB48 : public Register<0x500512d0> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB49 : public Register<0x500512d4> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB50 : public Register<0x500512d8> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB51 : public Register<0x500512dc> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB52 : public Register<0x500512e0> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB53 : public Register<0x500512e4> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB54 : public Register<0x500512e8> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB55 : public Register<0x500512ec> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB56 : public Register<0x500512f0> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB57 : public Register<0x500512f4> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB58 : public Register<0x500512f8> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB59 : public Register<0x500512fc> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB60 : public Register<0x50051300> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB61 : public Register<0x50051304> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB62 : public Register<0x50051308> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB63 : public Register<0x5005130c> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB64 : public Register<0x50051310> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB65 : public Register<0x50051314> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB66 : public Register<0x50051318> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB67 : public Register<0x5005131c> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB68 : public Register<0x50051320> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB69 : public Register<0x50051324> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB70 : public Register<0x50051328> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB71 : public Register<0x5005132c> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB72 : public Register<0x50051330> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB73 : public Register<0x50051334> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB74 : public Register<0x50051338> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB75 : public Register<0x5005133c> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB76 : public Register<0x50051340> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB77 : public Register<0x50051344> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB78 : public Register<0x50051348> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB79 : public Register<0x5005134c> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB80 : public Register<0x50051350> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB81 : public Register<0x50051354> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB82 : public Register<0x50051358> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG HUFFSYMB tables
        struct HUFFSYMB83 : public Register<0x5005135c> {
            using HuffSymb_RAM = Field<0, 32>;    // DHTSymb RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM0 : public Register<0x50051360> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM2 : public Register<0x50051364> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM3 : public Register<0x50051368> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM4 : public Register<0x5005136c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM5 : public Register<0x50051370> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM6 : public Register<0x50051374> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM7 : public Register<0x50051378> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM8 : public Register<0x5005137c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM9 : public Register<0x50051380> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM10 : public Register<0x50051384> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM11 : public Register<0x50051388> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM12 : public Register<0x5005138c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM13 : public Register<0x50051390> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM14 : public Register<0x50051394> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM15 : public Register<0x50051398> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM16 : public Register<0x5005139c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM17 : public Register<0x500513a0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM18 : public Register<0x500513a4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM19 : public Register<0x500513a8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM20 : public Register<0x500513ac> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM21 : public Register<0x500513b0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM22 : public Register<0x500513b4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM23 : public Register<0x500513b8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM24 : public Register<0x500513bc> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM25 : public Register<0x500513c0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM26 : public Register<0x500513c4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM27 : public Register<0x500513c8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM28 : public Register<0x500513cc> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM29 : public Register<0x500513d0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM30 : public Register<0x500513d4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM31 : public Register<0x500513d8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM32 : public Register<0x500513dc> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM33 : public Register<0x500513e0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM34 : public Register<0x500513e4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM35 : public Register<0x500513e8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM36 : public Register<0x500513ec> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM37 : public Register<0x500513f0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM38 : public Register<0x500513f4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM39 : public Register<0x500513f8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM40 : public Register<0x500513fc> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM41 : public Register<0x50051400> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM42 : public Register<0x50051404> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM43 : public Register<0x50051408> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM44 : public Register<0x5005140c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM45 : public Register<0x50051410> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM46 : public Register<0x50051414> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM47 : public Register<0x50051418> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM48 : public Register<0x5005141c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM49 : public Register<0x50051420> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM50 : public Register<0x50051424> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM51 : public Register<0x50051428> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM52 : public Register<0x5005142c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM53 : public Register<0x50051430> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM54 : public Register<0x50051434> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM55 : public Register<0x50051438> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM56 : public Register<0x5005143c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM57 : public Register<0x50051440> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM58 : public Register<0x50051444> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM59 : public Register<0x50051448> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM60 : public Register<0x5005144c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM61 : public Register<0x50051450> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM62 : public Register<0x50051454> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM63 : public Register<0x50051458> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM64 : public Register<0x5005145c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM65 : public Register<0x50051460> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM66 : public Register<0x50051464> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM67 : public Register<0x50051468> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM68 : public Register<0x5005146c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM69 : public Register<0x50051470> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM70 : public Register<0x50051474> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM71 : public Register<0x50051478> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM72 : public Register<0x5005147c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM73 : public Register<0x50051480> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM74 : public Register<0x50051484> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM75 : public Register<0x50051488> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM76 : public Register<0x5005148c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM77 : public Register<0x50051490> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM78 : public Register<0x50051494> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM79 : public Register<0x50051498> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM80 : public Register<0x5005149c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM81 : public Register<0x500514a0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM82 : public Register<0x500514a4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM83 : public Register<0x500514a8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM84 : public Register<0x500514ac> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM85 : public Register<0x500514b0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM86 : public Register<0x500514b4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM87 : public Register<0x500514b8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM88 : public Register<0x500514bc> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM89 : public Register<0x500514c0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM90 : public Register<0x500514c4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM91 : public Register<0x500514c8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM92 : public Register<0x500514cc> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM93 : public Register<0x500514d0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM94 : public Register<0x500514d4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM95 : public Register<0x500514d8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM96 : public Register<0x500514dc> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM97 : public Register<0x500514e0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM98 : public Register<0x500514e4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM99 : public Register<0x500514e8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM100 : public Register<0x500514ec> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM101 : public Register<0x500514f0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM102 : public Register<0x500514f4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG DHTMem tables
        struct DHTMEM103 : public Register<0x500514f8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_0 : public Register<0x50051500> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_1 : public Register<0x50051504> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_2 : public Register<0x50051508> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_3 : public Register<0x5005150c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_4 : public Register<0x50051510> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_5 : public Register<0x50051514> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_6 : public Register<0x50051518> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_7 : public Register<0x5005151c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_8 : public Register<0x50051520> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_9 : public Register<0x50051524> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_10 : public Register<0x50051528> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_11 : public Register<0x5005152c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_12 : public Register<0x50051530> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_13 : public Register<0x50051534> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_14 : public Register<0x50051538> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_15 : public Register<0x5005153c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_16 : public Register<0x50051540> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_17 : public Register<0x50051544> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_18 : public Register<0x50051548> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_19 : public Register<0x5005154c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_20 : public Register<0x50051550> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_21 : public Register<0x50051554> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_22 : public Register<0x50051558> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_23 : public Register<0x5005155c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_24 : public Register<0x50051560> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_25 : public Register<0x50051564> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_26 : public Register<0x50051568> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_27 : public Register<0x5005156c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_28 : public Register<0x50051570> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_29 : public Register<0x50051574> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_30 : public Register<0x50051578> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_31 : public Register<0x5005157c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_32 : public Register<0x50051580> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_33 : public Register<0x50051584> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_34 : public Register<0x50051588> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_35 : public Register<0x5005158c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_36 : public Register<0x50051590> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_37 : public Register<0x50051594> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_38 : public Register<0x50051598> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_39 : public Register<0x5005159c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_40 : public Register<0x500515a0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_41 : public Register<0x500515a4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_42 : public Register<0x500515a8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_43 : public Register<0x500515ac> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_44 : public Register<0x500515b0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_45 : public Register<0x500515b4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_46 : public Register<0x500515b8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_47 : public Register<0x500515bc> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_48 : public Register<0x500515c0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_49 : public Register<0x500515c4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_50 : public Register<0x500515c8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_51 : public Register<0x500515cc> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_52 : public Register<0x500515d0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_53 : public Register<0x500515d4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_54 : public Register<0x500515d8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_55 : public Register<0x500515dc> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_56 : public Register<0x500515e0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_57 : public Register<0x500515e4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_58 : public Register<0x500515e8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_59 : public Register<0x500515ec> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_60 : public Register<0x500515f0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_61 : public Register<0x500515f4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_62 : public Register<0x500515f8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_63 : public Register<0x500515fc> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_64 : public Register<0x50051600> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_65 : public Register<0x50051604> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_66 : public Register<0x50051608> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_67 : public Register<0x5005160c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_68 : public Register<0x50051610> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_69 : public Register<0x50051614> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_70 : public Register<0x50051618> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_71 : public Register<0x5005161c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_72 : public Register<0x50051620> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_73 : public Register<0x50051624> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_74 : public Register<0x50051628> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_75 : public Register<0x5005162c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_76 : public Register<0x50051630> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_77 : public Register<0x50051634> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_78 : public Register<0x50051638> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_79 : public Register<0x5005163c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_80 : public Register<0x50051640> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_81 : public Register<0x50051644> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_82 : public Register<0x50051648> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_83 : public Register<0x5005164c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_84 : public Register<0x50051650> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_85 : public Register<0x50051654> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_86 : public Register<0x50051658> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 0
        struct HUFFENC_AC0_87 : public Register<0x5005165c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_0 : public Register<0x50051660> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_1 : public Register<0x50051664> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_2 : public Register<0x50051668> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_3 : public Register<0x5005166c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_4 : public Register<0x50051670> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_5 : public Register<0x50051674> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_6 : public Register<0x50051678> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_7 : public Register<0x5005167c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_8 : public Register<0x50051680> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_9 : public Register<0x50051684> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_10 : public Register<0x50051688> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_11 : public Register<0x5005168c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_12 : public Register<0x50051690> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_13 : public Register<0x50051694> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_14 : public Register<0x50051698> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_15 : public Register<0x5005169c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_16 : public Register<0x500516a0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_17 : public Register<0x500516a4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_18 : public Register<0x500516a8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_19 : public Register<0x500516ac> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_20 : public Register<0x500516b0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_21 : public Register<0x500516b4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_22 : public Register<0x500516b8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_23 : public Register<0x500516bc> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_24 : public Register<0x500516c0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_25 : public Register<0x500516c4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_26 : public Register<0x500516c8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_27 : public Register<0x500516cc> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_28 : public Register<0x500516d0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_29 : public Register<0x500516d4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_30 : public Register<0x500516d8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_31 : public Register<0x500516dc> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_32 : public Register<0x500516e0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_33 : public Register<0x500516e4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_34 : public Register<0x500516e8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_35 : public Register<0x500516ec> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_36 : public Register<0x500516f0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_37 : public Register<0x500516f4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_38 : public Register<0x500516f8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_39 : public Register<0x500516fc> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_40 : public Register<0x50051700> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_41 : public Register<0x50051704> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_42 : public Register<0x50051708> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_43 : public Register<0x5005170c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_44 : public Register<0x50051710> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_45 : public Register<0x50051714> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_46 : public Register<0x50051718> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_47 : public Register<0x5005171c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_48 : public Register<0x50051720> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_49 : public Register<0x50051724> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_50 : public Register<0x50051728> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_51 : public Register<0x5005172c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_52 : public Register<0x50051730> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_53 : public Register<0x50051734> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_54 : public Register<0x50051738> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_55 : public Register<0x5005173c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_56 : public Register<0x50051740> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_57 : public Register<0x50051744> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_58 : public Register<0x50051748> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_59 : public Register<0x5005174c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_60 : public Register<0x50051750> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_61 : public Register<0x50051754> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_62 : public Register<0x50051758> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_63 : public Register<0x5005175c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_64 : public Register<0x50051760> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_65 : public Register<0x50051764> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_66 : public Register<0x50051768> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_67 : public Register<0x5005176c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_68 : public Register<0x50051770> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_69 : public Register<0x50051774> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_70 : public Register<0x50051778> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_71 : public Register<0x5005177c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_72 : public Register<0x50051780> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_73 : public Register<0x50051784> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_74 : public Register<0x50051788> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_75 : public Register<0x5005178c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_76 : public Register<0x50051790> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_77 : public Register<0x50051794> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_78 : public Register<0x50051798> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_79 : public Register<0x5005179c> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_80 : public Register<0x500517a0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_81 : public Register<0x500517a4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_82 : public Register<0x500517a8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_83 : public Register<0x500517ac> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_84 : public Register<0x500517b0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_85 : public Register<0x500517b4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_86 : public Register<0x500517b8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, AC Huffman table 1
        struct HUFFENC_AC1_87 : public Register<0x500517bc> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, DC Huffman table 0
        struct HUFFENC_DC0_0 : public Register<0x500517c0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, DC Huffman table 0
        struct HUFFENC_DC0_1 : public Register<0x500517c4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, DC Huffman table 0
        struct HUFFENC_DC0_2 : public Register<0x500517c8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, DC Huffman table 0
        struct HUFFENC_DC0_3 : public Register<0x500517cc> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, DC Huffman table 0
        struct HUFFENC_DC0_4 : public Register<0x500517d0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, DC Huffman table 0
        struct HUFFENC_DC0_5 : public Register<0x500517d4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, DC Huffman table 0
        struct HUFFENC_DC0_6 : public Register<0x500517d8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, DC Huffman table 0
        struct HUFFENC_DC0_7 : public Register<0x500517dc> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, DC Huffman table 1
        struct HUFFENC_DC1_0 : public Register<0x500517e0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, DC Huffman table 1
        struct HUFFENC_DC1_1 : public Register<0x500517e4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, DC Huffman table 1
        struct HUFFENC_DC1_2 : public Register<0x500517e8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, DC Huffman table 1
        struct HUFFENC_DC1_3 : public Register<0x500517ec> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, DC Huffman table 1
        struct HUFFENC_DC1_4 : public Register<0x500517f0> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, DC Huffman table 1
        struct HUFFENC_DC1_5 : public Register<0x500517f4> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, DC Huffman table 1
        struct HUFFENC_DC1_6 : public Register<0x500517f8> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

        // JPEG encoder, DC Huffman table 1
        struct HUFFENC_DC1_7 : public Register<0x500517fc> {
            using DHTMem_RAM = Field<0, 32>;    // DHTMem RAM
        };

    };

    // Ethernet: MAC management counters
    struct Ethernet_MMC {
        // Ethernet MMC control register
        struct MMCCR : public Register<0x40028100> {
            using CR = Field<0, 1>;    // CR
            using CSR = Field<1, 1>;    // CSR
            using ROR = Field<2, 1>;    // ROR
            using MCF = Field<3, 1>;    // MCF
            using MCP = Field<4, 1>;    // MCP
            using MCFHP = Field<5, 1>;    // MCFHP
        };

        // Ethernet MMC receive interrupt register
        struct MMCRIR : public Register<0x40028104> {
            using RFCES = Field<5, 1>;    // RFCES
            using RFAES = Field<6, 1>;    // RFAES
            using RGUFS = Field<17, 1>;    // RGUFS
        };

        // Ethernet MMC transmit interrupt register
        struct MMCTIR : public RegisterReadOnly<0x40028108> {
            using TGFSCS = Field<14, 1>;    // TGFSCS
            using TGFMSCS = Field<15, 1>;    // TGFMSCS
            using TGFS = Field<21, 1>;    // TGFS
        };

        // Ethernet MMC receive interrupt mask register
        struct MMCRIMR : public Register<0x4002810c> {
            using RFCEM = Field<5, 1>;    // RFCEM
            using RFAEM = Field<6, 1>;    // RFAEM
            using RGUFM = Field<17, 1>;    // RGUFM
        };

        // Ethernet MMC transmit interrupt mask register
        struct MMCTIMR : public Register<0x40028110> {
            using TGFSCM = Field<14, 1>;    // TGFSCM
            using TGFMSCM = Field<15, 1>;    // TGFMSCM
            using TGFM = Field<16, 1>;    // TGFM
        };

        // Ethernet MMC transmitted good frames after a single collision counter
        struct MMCTGFSCCR : public RegisterReadOnly<0x4002814c> {
            using TGFSCC = Field<0, 32>;    // TGFSCC
        };

        // Ethernet MMC transmitted good frames after more than a single collision
        struct MMCTGFMSCCR : public RegisterReadOnly<0x40028150> {
            using TGFMSCC = Field<0, 32>;    // TGFMSCC
        };

        // Ethernet MMC transmitted good frames counter register
        struct MMCTGFCR : public RegisterReadOnly<0x40028168> {
            using TGFC = Field<0, 32>;    // HTL
        };

        // Ethernet MMC received frames with CRC error counter register
        struct MMCRFCECR : public RegisterReadOnly<0x40028194> {
            using RFCFC = Field<0, 32>;    // RFCFC
        };

        // Ethernet MMC received frames with alignment error counter register
        struct MMCRFAECR : public RegisterReadOnly<0x40028198> {
            using RFAEC = Field<0, 32>;    // RFAEC
        };

        // MMC received good unicast frames counter register
        struct MMCRGUFCR : public RegisterReadOnly<0x400281c4> {
            using RGUFC = Field<0, 32>;    // RGUFC
        };

    };

    // Ethernet: Precision time protocol
    struct Ethernet_PTP {
        // Ethernet PTP time stamp control register
        struct PTPTSCR : public Register<0x40028700> {
            using TSE = Field<0, 1>;    // TSE
            using TSFCU = Field<1, 1>;    // TSFCU
            using TSPTPPSV2E = Field<10, 1>;    // TSPTPPSV2E
            using TSSPTPOEFE = Field<11, 1>;    // TSSPTPOEFE
            using TSSIPV6FE = Field<12, 1>;    // TSSIPV6FE
            using TSSIPV4FE = Field<13, 1>;    // TSSIPV4FE
            using TSSEME = Field<14, 1>;    // TSSEME
            using TSSMRME = Field<15, 1>;    // TSSMRME
            using TSCNT = Field<16, 2>;    // TSCNT
            using TSPFFMAE = Field<18, 1>;    // TSPFFMAE
            using TSSTI = Field<2, 1>;    // TSSTI
            using TSSTU = Field<3, 1>;    // TSSTU
            using TSITE = Field<4, 1>;    // TSITE
            using TTSARU = Field<5, 1>;    // TTSARU
            using TSSARFE = Field<8, 1>;    // TSSARFE
            using TSSSR = Field<9, 1>;    // TSSSR
        };

        // Ethernet PTP subsecond increment register
        struct PTPSSIR : public Register<0x40028704> {
            using STSSI = Field<0, 8>;    // STSSI
        };

        // Ethernet PTP time stamp high register
        struct PTPTSHR : public RegisterReadOnly<0x40028708> {
            using STS = Field<0, 32>;    // STS
        };

        // Ethernet PTP time stamp low register
        struct PTPTSLR : public RegisterReadOnly<0x4002870c> {
            using STSS = Field<0, 31>;    // STSS
            using STPNS = Field<31, 1>;    // STPNS
        };

        // Ethernet PTP time stamp high update register
        struct PTPTSHUR : public Register<0x40028710> {
            using TSUS = Field<0, 32>;    // TSUS
        };

        // Ethernet PTP time stamp low update register
        struct PTPTSLUR : public Register<0x40028714> {
            using TSUSS = Field<0, 31>;    // TSUSS
            using TSUPNS = Field<31, 1>;    // TSUPNS
        };

        // Ethernet PTP time stamp addend register
        struct PTPTSAR : public Register<0x40028718> {
            using TSA = Field<0, 32>;    // TSA
        };

        // Ethernet PTP target time high register
        struct PTPTTHR : public Register<0x4002871c> {
            using TTSH = Field<0, 32>;    // 0
        };

        // Ethernet PTP target time low register
        struct PTPTTLR : public Register<0x40028720> {
            using TTSL = Field<0, 32>;    // TTSL
        };

        // Ethernet PTP time stamp status register
        struct PTPTSSR : public RegisterReadOnly<0x40028728> {
            using TSSO = Field<0, 1>;    // TSSO
            using TSTTR = Field<1, 1>;    // TSTTR
        };

        // Ethernet PTP PPS control register
        struct PTPPPSCR : public RegisterReadOnly<0x4002872c> {
            using TSSO = Field<0, 1>;    // TSSO
            using TSTTR = Field<1, 1>;    // TSTTR
        };

    };

    // Ethernet: DMA controller operation
    struct Ethernet_DMA {
        // Ethernet DMA bus mode register
        struct DMABMR : public Register<0x40029000> {
            using SR = Field<0, 1>;    // SR
            using DA = Field<1, 1>;    // DA
            using DSL = Field<2, 5>;    // DSL
            using EDFE = Field<7, 1>;    // EDFE
            using PBL = Field<8, 6>;    // PBL
            using RTPR = Field<14, 2>;    // RTPR
            using FB = Field<16, 1>;    // FB
            using RDP = Field<17, 6>;    // RDP
            using USP = Field<23, 1>;    // USP
            using FPM = Field<24, 1>;    // FPM
            using AAB = Field<25, 1>;    // AAB
            using MB = Field<26, 1>;    // MB
        };

        // Ethernet DMA transmit poll demand register
        struct DMATPDR : public Register<0x40029004> {
            using TPD = Field<0, 32>;    // TPD
        };

        // EHERNET DMA receive poll demand register
        struct DMARPDR : public Register<0x40029008> {
            using RPD = Field<0, 32>;    // RPD
        };

        // Ethernet DMA receive descriptor list address register
        struct DMARDLAR : public Register<0x4002900c> {
            using SRL = Field<0, 32>;    // SRL
        };

        // Ethernet DMA transmit descriptor list address register
        struct DMATDLAR : public Register<0x40029010> {
            using STL = Field<0, 32>;    // STL
        };

        // Ethernet DMA status register
        struct DMASR : public Register<0x40029014> {
            using TS = Field<0, 1>;    // TS
            using TPSS = Field<1, 1>;    // TPSS
            using TBUS = Field<2, 1>;    // TBUS
            using TJTS = Field<3, 1>;    // TJTS
            using ROS = Field<4, 1>;    // ROS
            using TUS = Field<5, 1>;    // TUS
            using RS = Field<6, 1>;    // RS
            using RBUS = Field<7, 1>;    // RBUS
            using RPSS = Field<8, 1>;    // RPSS
            using PWTS = Field<9, 1>;    // PWTS
            using ETS = Field<10, 1>;    // ETS
            using FBES = Field<13, 1>;    // FBES
            using ERS = Field<14, 1>;    // ERS
            using AIS = Field<15, 1>;    // AIS
            using NIS = Field<16, 1>;    // NIS
            using RPS = Field<17, 3>;    // RPS
            using TPS = Field<20, 3>;    // TPS
            using EBS = Field<23, 3>;    // EBS
            using MMCS = Field<27, 1>;    // MMCS
            using PMTS = Field<28, 1>;    // PMTS
            using TSTS = Field<29, 1>;    // TSTS
        };

        // Ethernet DMA operation mode register
        struct DMAOMR : public Register<0x40029018> {
            using SR = Field<1, 1>;    // SR
            using OSF = Field<2, 1>;    // OSF
            using RTC = Field<3, 2>;    // RTC
            using FUGF = Field<6, 1>;    // FUGF
            using FEF = Field<7, 1>;    // FEF
            using ST = Field<13, 1>;    // ST
            using TTC = Field<14, 3>;    // TTC
            using FTF = Field<20, 1>;    // FTF
            using TSF = Field<21, 1>;    // TSF
            using DFRF = Field<24, 1>;    // DFRF
            using RSF = Field<25, 1>;    // RSF
            using DTCEFD = Field<26, 1>;    // DTCEFD
        };

        // Ethernet DMA interrupt enable register
        struct DMAIER : public Register<0x4002901c> {
            using TIE = Field<0, 1>;    // TIE
            using TPSIE = Field<1, 1>;    // TPSIE
            using TBUIE = Field<2, 1>;    // TBUIE
            using TJTIE = Field<3, 1>;    // TJTIE
            using ROIE = Field<4, 1>;    // ROIE
            using TUIE = Field<5, 1>;    // TUIE
            using RIE = Field<6, 1>;    // RIE
            using RBUIE = Field<7, 1>;    // RBUIE
            using RPSIE = Field<8, 1>;    // RPSIE
            using RWTIE = Field<9, 1>;    // RWTIE
            using ETIE = Field<10, 1>;    // ETIE
            using FBEIE = Field<13, 1>;    // FBEIE
            using ERIE = Field<14, 1>;    // ERIE
            using AISE = Field<15, 1>;    // AISE
            using NISE = Field<16, 1>;    // NISE
        };

        // Ethernet DMA missed frame and buffer overflow counter register
        struct DMAMFBOCR : public Register<0x40029020> {
            using MFC = Field<0, 16>;    // MFC
            using OMFC = Field<16, 1>;    // OMFC
            using MFA = Field<17, 11>;    // MFA
            using OFOC = Field<28, 1>;    // OFOC
        };

        // Ethernet DMA receive status watchdog timer register
        struct DMARSWTR : public Register<0x40029024> {
            using RSWTC = Field<0, 8>;    // RSWTC
        };

        // Ethernet DMA current host transmit descriptor register
        struct DMACHTDR : public RegisterReadOnly<0x40029048> {
            using HTDAP = Field<0, 32>;    // HTDAP
        };

        // Ethernet DMA current host receive descriptor register
        struct DMACHRDR : public RegisterReadOnly<0x4002904c> {
            using HRDAP = Field<0, 32>;    // HRDAP
        };

        // Ethernet DMA current host transmit buffer address register
        struct DMACHTBAR : public RegisterReadOnly<0x40029050> {
            using HTBAP = Field<0, 32>;    // HTBAP
        };

        // Ethernet DMA current host receive buffer address register
        struct DMACHRBAR : public RegisterReadOnly<0x40029054> {
            using HRBAP = Field<0, 32>;    // HRBAP
        };

    };

    // USB on the go full speed
    struct OTG_FS_HOST {
        // OTG_FS host configuration register (OTG_FS_HCFG)
        struct OTG_FS_HCFG : public Register<0x50000400> {
            using FSLSPCS = Field<0, 2>;    // FS/LS PHY clock select
            using FSLSS = Field<2, 1>;    // FS- and LS-only support
        };

        // OTG_FS Host frame interval register
        struct OTG_FS_HFIR : public Register<0x50000404> {
            using FRIVL = Field<0, 16>;    // Frame interval
        };

        // OTG_FS host frame number/frame time remaining register (OTG_FS_HFNUM)
        struct OTG_FS_HFNUM : public RegisterReadOnly<0x50000408> {
            using FRNUM = Field<0, 16>;    // Frame number
            using FTREM = Field<16, 16>;    // Frame time remaining
        };

        // OTG_FS_Host periodic transmit FIFO/queue status register (OTG_FS_HPTXSTS)
        struct OTG_FS_HPTXSTS : public Register<0x50000410> {
            using PTXFSAVL = Field<0, 16>;    // Periodic transmit data FIFO space available
            using PTXQSAV = Field<16, 8>;    // Periodic transmit request queue space available
            using PTXQTOP = Field<24, 8>;    // Top of the periodic transmit request queue
        };

        // OTG_FS Host all channels interrupt register
        struct OTG_FS_HAINT : public RegisterReadOnly<0x50000414> {
            using HAINT = Field<0, 16>;    // Channel interrupts
        };

        // OTG_FS host all channels interrupt mask register
        struct OTG_FS_HAINTMSK : public Register<0x50000418> {
            using HAINTM = Field<0, 16>;    // Channel interrupt mask
        };

        // OTG_FS host port control and status register (OTG_FS_HPRT)
        struct OTG_FS_HPRT : public Register<0x50000440> {
            using PCSTS = Field<0, 1>;    // Port connect status
            using PCDET = Field<1, 1>;    // Port connect detected
            using PENA = Field<2, 1>;    // Port enable
            using PENCHNG = Field<3, 1>;    // Port enable/disable change
            using POCA = Field<4, 1>;    // Port overcurrent active
            using POCCHNG = Field<5, 1>;    // Port overcurrent change
            using PRES = Field<6, 1>;    // Port resume
            using PSUSP = Field<7, 1>;    // Port suspend
            using PRST = Field<8, 1>;    // Port reset
            using PLSTS = Field<10, 2>;    // Port line status
            using PPWR = Field<12, 1>;    // Port power
            using PTCTL = Field<13, 4>;    // Port test control
            using PSPD = Field<17, 2>;    // Port speed
        };

        // OTG_FS host channel-0 characteristics register (OTG_FS_HCCHAR0)
        struct OTG_FS_HCCHAR0 : public Register<0x50000500> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-1 characteristics register (OTG_FS_HCCHAR1)
        struct OTG_FS_HCCHAR1 : public Register<0x50000520> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-2 characteristics register (OTG_FS_HCCHAR2)
        struct OTG_FS_HCCHAR2 : public Register<0x50000540> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-3 characteristics register (OTG_FS_HCCHAR3)
        struct OTG_FS_HCCHAR3 : public Register<0x50000560> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-4 characteristics register (OTG_FS_HCCHAR4)
        struct OTG_FS_HCCHAR4 : public Register<0x50000580> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-5 characteristics register (OTG_FS_HCCHAR5)
        struct OTG_FS_HCCHAR5 : public Register<0x500005a0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-6 characteristics register (OTG_FS_HCCHAR6)
        struct OTG_FS_HCCHAR6 : public Register<0x500005c0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-7 characteristics register (OTG_FS_HCCHAR7)
        struct OTG_FS_HCCHAR7 : public Register<0x500005e0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-0 interrupt register (OTG_FS_HCINT0)
        struct OTG_FS_HCINT0 : public Register<0x50000508> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-1 interrupt register (OTG_FS_HCINT1)
        struct OTG_FS_HCINT1 : public Register<0x50000528> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-2 interrupt register (OTG_FS_HCINT2)
        struct OTG_FS_HCINT2 : public Register<0x50000548> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-3 interrupt register (OTG_FS_HCINT3)
        struct OTG_FS_HCINT3 : public Register<0x50000568> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-4 interrupt register (OTG_FS_HCINT4)
        struct OTG_FS_HCINT4 : public Register<0x50000588> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-5 interrupt register (OTG_FS_HCINT5)
        struct OTG_FS_HCINT5 : public Register<0x500005a8> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-6 interrupt register (OTG_FS_HCINT6)
        struct OTG_FS_HCINT6 : public Register<0x500005c8> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-7 interrupt register (OTG_FS_HCINT7)
        struct OTG_FS_HCINT7 : public Register<0x500005e8> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-0 mask register (OTG_FS_HCINTMSK0)
        struct OTG_FS_HCINTMSK0 : public Register<0x5000050c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-1 mask register (OTG_FS_HCINTMSK1)
        struct OTG_FS_HCINTMSK1 : public Register<0x5000052c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-2 mask register (OTG_FS_HCINTMSK2)
        struct OTG_FS_HCINTMSK2 : public Register<0x5000054c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-3 mask register (OTG_FS_HCINTMSK3)
        struct OTG_FS_HCINTMSK3 : public Register<0x5000056c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-4 mask register (OTG_FS_HCINTMSK4)
        struct OTG_FS_HCINTMSK4 : public Register<0x5000058c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-5 mask register (OTG_FS_HCINTMSK5)
        struct OTG_FS_HCINTMSK5 : public Register<0x500005ac> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-6 mask register (OTG_FS_HCINTMSK6)
        struct OTG_FS_HCINTMSK6 : public Register<0x500005cc> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-7 mask register (OTG_FS_HCINTMSK7)
        struct OTG_FS_HCINTMSK7 : public Register<0x500005ec> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-0 transfer size register
        struct OTG_FS_HCTSIZ0 : public Register<0x50000510> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-1 transfer size register
        struct OTG_FS_HCTSIZ1 : public Register<0x50000530> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-2 transfer size register
        struct OTG_FS_HCTSIZ2 : public Register<0x50000550> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-3 transfer size register
        struct OTG_FS_HCTSIZ3 : public Register<0x50000570> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-x transfer size register
        struct OTG_FS_HCTSIZ4 : public Register<0x50000590> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-5 transfer size register
        struct OTG_FS_HCTSIZ5 : public Register<0x500005b0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-6 transfer size register
        struct OTG_FS_HCTSIZ6 : public Register<0x500005d0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-7 transfer size register
        struct OTG_FS_HCTSIZ7 : public Register<0x500005f0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-8 characteristics register
        struct OTG_FS_HCCHAR8 : public Register<0x500005f4> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-8 interrupt register
        struct OTG_FS_HCINT8 : public Register<0x500005f8> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-8 mask register
        struct OTG_FS_HCINTMSK8 : public Register<0x500005fc> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-8 transfer size register
        struct OTG_FS_HCTSIZ8 : public Register<0x50000600> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-9 characteristics register
        struct OTG_FS_HCCHAR9 : public Register<0x50000604> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-9 interrupt register
        struct OTG_FS_HCINT9 : public Register<0x50000608> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-9 mask register
        struct OTG_FS_HCINTMSK9 : public Register<0x5000060c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-9 transfer size register
        struct OTG_FS_HCTSIZ9 : public Register<0x50000610> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-10 characteristics register
        struct OTG_FS_HCCHAR10 : public Register<0x50000614> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-10 interrupt register
        struct OTG_FS_HCINT10 : public Register<0x50000618> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-10 mask register
        struct OTG_FS_HCINTMSK10 : public Register<0x5000061c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-10 transfer size register
        struct OTG_FS_HCTSIZ10 : public Register<0x50000620> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-11 characteristics register
        struct OTG_FS_HCCHAR11 : public Register<0x50000624> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-11 interrupt register
        struct OTG_FS_HCINT11 : public Register<0x50000628> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-11 mask register
        struct OTG_FS_HCINTMSK11 : public Register<0x5000062c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-11 transfer size register
        struct OTG_FS_HCTSIZ11 : public Register<0x50000630> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

    };

    // USB on the go full speed
    struct OTG_FS_DEVICE {
        // OTG_FS device configuration register (OTG_FS_DCFG)
        struct OTG_FS_DCFG : public Register<0x50000800> {
            using DSPD = Field<0, 2>;    // Device speed
            using NZLSOHSK = Field<2, 1>;    // Non-zero-length status OUT handshake
            using DAD = Field<4, 7>;    // Device address
            using PFIVL = Field<11, 2>;    // Periodic frame interval
        };

        // OTG_FS device control register (OTG_FS_DCTL)
        struct OTG_FS_DCTL : public Register<0x50000804> {
            using RWUSIG = Field<0, 1>;    // Remote wakeup signaling
            using SDIS = Field<1, 1>;    // Soft disconnect
            using GINSTS = Field<2, 1>;    // Global IN NAK status
            using GONSTS = Field<3, 1>;    // Global OUT NAK status
            using TCTL = Field<4, 3>;    // Test control
            using SGINAK = Field<7, 1>;    // Set global IN NAK
            using CGINAK = Field<8, 1>;    // Clear global IN NAK
            using SGONAK = Field<9, 1>;    // Set global OUT NAK
            using CGONAK = Field<10, 1>;    // Clear global OUT NAK
            using POPRGDNE = Field<11, 1>;    // Power-on programming done
        };

        // OTG_FS device status register (OTG_FS_DSTS)
        struct OTG_FS_DSTS : public RegisterReadOnly<0x50000808> {
            using SUSPSTS = Field<0, 1>;    // Suspend status
            using ENUMSPD = Field<1, 2>;    // Enumerated speed
            using EERR = Field<3, 1>;    // Erratic error
            using FNSOF = Field<8, 14>;    // Frame number of the received SOF
        };

        // OTG_FS device IN endpoint common interrupt mask register (OTG_FS_DIEPMSK)
        struct OTG_FS_DIEPMSK : public Register<0x50000810> {
            using XFRCM = Field<0, 1>;    // Transfer completed interrupt mask
            using EPDM = Field<1, 1>;    // Endpoint disabled interrupt mask
            using TOM = Field<3, 1>;    // Timeout condition mask (Non-isochronous endpoints)
            using ITTXFEMSK = Field<4, 1>;    // IN token received when TxFIFO empty mask
            using INEPNMM = Field<5, 1>;    // IN token received with EP mismatch mask
            using INEPNEM = Field<6, 1>;    // IN endpoint NAK effective mask
        };

        // OTG_FS device OUT endpoint common interrupt mask register (OTG_FS_DOEPMSK)
        struct OTG_FS_DOEPMSK : public Register<0x50000814> {
            using XFRCM = Field<0, 1>;    // Transfer completed interrupt mask
            using EPDM = Field<1, 1>;    // Endpoint disabled interrupt mask
            using STUPM = Field<3, 1>;    // SETUP phase done mask
            using OTEPDM = Field<4, 1>;    // OUT token received when endpoint disabled mask
        };

        // OTG_FS device all endpoints interrupt register (OTG_FS_DAINT)
        struct OTG_FS_DAINT : public RegisterReadOnly<0x50000818> {
            using IEPINT = Field<0, 16>;    // IN endpoint interrupt bits
            using OEPINT = Field<16, 16>;    // OUT endpoint interrupt bits
        };

        // OTG_FS all endpoints interrupt mask register (OTG_FS_DAINTMSK)
        struct OTG_FS_DAINTMSK : public Register<0x5000081c> {
            using IEPM = Field<0, 16>;    // IN EP interrupt mask bits
            using OEPINT = Field<16, 16>;    // OUT endpoint interrupt bits
        };

        // OTG_FS device VBUS discharge time register
        struct OTG_FS_DVBUSDIS : public Register<0x50000828> {
            using VBUSDT = Field<0, 16>;    // Device VBUS discharge time
        };

        // OTG_FS device VBUS pulsing time register
        struct OTG_FS_DVBUSPULSE : public Register<0x5000082c> {
            using DVBUSP = Field<0, 12>;    // Device VBUS pulsing time
        };

        // OTG_FS device IN endpoint FIFO empty interrupt mask register
        struct OTG_FS_DIEPEMPMSK : public Register<0x50000834> {
            using INEPTXFEM = Field<0, 16>;    // IN EP Tx FIFO empty interrupt mask bits
        };

        // OTG_FS device control IN endpoint 0 control register (OTG_FS_DIEPCTL0)
        struct OTG_FS_DIEPCTL0 : public Register<0x50000900> {
            using MPSIZ = Field<0, 2>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using STALL = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-1 control register
        struct OTG_FS_DIEPCTL1 : public Register<0x50000920> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SODDFRM_SD1PID = Field<29, 1>;    // SODDFRM/SD1PID
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID/SEVNFRM
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using TXFNUM = Field<22, 4>;    // TXFNUM
            using Stall = Field<21, 1>;    // Stall
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EONUM_DPID = Field<16, 1>;    // EONUM/DPID
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 11>;    // MPSIZ
        };

        // OTG device endpoint-2 control register
        struct OTG_FS_DIEPCTL2 : public Register<0x50000940> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID/SEVNFRM
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using TXFNUM = Field<22, 4>;    // TXFNUM
            using Stall = Field<21, 1>;    // Stall
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EONUM_DPID = Field<16, 1>;    // EONUM/DPID
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 11>;    // MPSIZ
        };

        // OTG device endpoint-3 control register
        struct OTG_FS_DIEPCTL3 : public Register<0x50000960> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID/SEVNFRM
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using TXFNUM = Field<22, 4>;    // TXFNUM
            using Stall = Field<21, 1>;    // Stall
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EONUM_DPID = Field<16, 1>;    // EONUM/DPID
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 11>;    // MPSIZ
        };

        // device endpoint-0 control register
        struct OTG_FS_DOEPCTL0 : public Register<0x50000b00> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using Stall = Field<21, 1>;    // Stall
            using SNPM = Field<20, 1>;    // SNPM
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 2>;    // MPSIZ
        };

        // device endpoint-1 control register
        struct OTG_FS_DOEPCTL1 : public Register<0x50000b20> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID/SEVNFRM
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using Stall = Field<21, 1>;    // Stall
            using SNPM = Field<20, 1>;    // SNPM
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EONUM_DPID = Field<16, 1>;    // EONUM/DPID
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 11>;    // MPSIZ
        };

        // device endpoint-2 control register
        struct OTG_FS_DOEPCTL2 : public Register<0x50000b40> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID/SEVNFRM
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using Stall = Field<21, 1>;    // Stall
            using SNPM = Field<20, 1>;    // SNPM
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EONUM_DPID = Field<16, 1>;    // EONUM/DPID
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 11>;    // MPSIZ
        };

        // device endpoint-3 control register
        struct OTG_FS_DOEPCTL3 : public Register<0x50000b60> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID/SEVNFRM
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using Stall = Field<21, 1>;    // Stall
            using SNPM = Field<20, 1>;    // SNPM
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EONUM_DPID = Field<16, 1>;    // EONUM/DPID
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 11>;    // MPSIZ
        };

        // device endpoint-x interrupt register
        struct OTG_FS_DIEPINT0 : public Register<0x50000908> {
            using TXFE = Field<7, 1>;    // TXFE
            using INEPNE = Field<6, 1>;    // INEPNE
            using ITTXFE = Field<4, 1>;    // ITTXFE
            using TOC = Field<3, 1>;    // TOC
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-1 interrupt register
        struct OTG_FS_DIEPINT1 : public Register<0x50000928> {
            using TXFE = Field<7, 1>;    // TXFE
            using INEPNE = Field<6, 1>;    // INEPNE
            using ITTXFE = Field<4, 1>;    // ITTXFE
            using TOC = Field<3, 1>;    // TOC
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-2 interrupt register
        struct OTG_FS_DIEPINT2 : public Register<0x50000948> {
            using TXFE = Field<7, 1>;    // TXFE
            using INEPNE = Field<6, 1>;    // INEPNE
            using ITTXFE = Field<4, 1>;    // ITTXFE
            using TOC = Field<3, 1>;    // TOC
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-3 interrupt register
        struct OTG_FS_DIEPINT3 : public Register<0x50000968> {
            using TXFE = Field<7, 1>;    // TXFE
            using INEPNE = Field<6, 1>;    // INEPNE
            using ITTXFE = Field<4, 1>;    // ITTXFE
            using TOC = Field<3, 1>;    // TOC
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-0 interrupt register
        struct OTG_FS_DOEPINT0 : public Register<0x50000b08> {
            using B2BSTUP = Field<6, 1>;    // B2BSTUP
            using OTEPDIS = Field<4, 1>;    // OTEPDIS
            using STUP = Field<3, 1>;    // STUP
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-1 interrupt register
        struct OTG_FS_DOEPINT1 : public Register<0x50000b28> {
            using B2BSTUP = Field<6, 1>;    // B2BSTUP
            using OTEPDIS = Field<4, 1>;    // OTEPDIS
            using STUP = Field<3, 1>;    // STUP
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-2 interrupt register
        struct OTG_FS_DOEPINT2 : public Register<0x50000b48> {
            using B2BSTUP = Field<6, 1>;    // B2BSTUP
            using OTEPDIS = Field<4, 1>;    // OTEPDIS
            using STUP = Field<3, 1>;    // STUP
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-3 interrupt register
        struct OTG_FS_DOEPINT3 : public Register<0x50000b68> {
            using B2BSTUP = Field<6, 1>;    // B2BSTUP
            using OTEPDIS = Field<4, 1>;    // OTEPDIS
            using STUP = Field<3, 1>;    // STUP
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-0 transfer size register
        struct OTG_FS_DIEPTSIZ0 : public Register<0x50000910> {
            using PKTCNT = Field<19, 2>;    // Packet count
            using XFRSIZ = Field<0, 7>;    // Transfer size
        };

        // device OUT endpoint-0 transfer size register
        struct OTG_FS_DOEPTSIZ0 : public Register<0x50000b10> {
            using STUPCNT = Field<29, 2>;    // SETUP packet count
            using PKTCNT = Field<19, 1>;    // Packet count
            using XFRSIZ = Field<0, 7>;    // Transfer size
        };

        // device endpoint-1 transfer size register
        struct OTG_FS_DIEPTSIZ1 : public Register<0x50000930> {
            using MCNT = Field<29, 2>;    // Multi count
            using PKTCNT = Field<19, 10>;    // Packet count
            using XFRSIZ = Field<0, 19>;    // Transfer size
        };

        // device endpoint-2 transfer size register
        struct OTG_FS_DIEPTSIZ2 : public Register<0x50000950> {
            using MCNT = Field<29, 2>;    // Multi count
            using PKTCNT = Field<19, 10>;    // Packet count
            using XFRSIZ = Field<0, 19>;    // Transfer size
        };

        // device endpoint-3 transfer size register
        struct OTG_FS_DIEPTSIZ3 : public Register<0x50000970> {
            using MCNT = Field<29, 2>;    // Multi count
            using PKTCNT = Field<19, 10>;    // Packet count
            using XFRSIZ = Field<0, 19>;    // Transfer size
        };

        // OTG_FS device IN endpoint transmit FIFO status register
        struct OTG_FS_DTXFSTS0 : public RegisterReadOnly<0x50000918> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space available
        };

        // OTG_FS device IN endpoint transmit FIFO status register
        struct OTG_FS_DTXFSTS1 : public RegisterReadOnly<0x50000938> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space available
        };

        // OTG_FS device IN endpoint transmit FIFO status register
        struct OTG_FS_DTXFSTS2 : public RegisterReadOnly<0x50000958> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space available
        };

        // OTG_FS device IN endpoint transmit FIFO status register
        struct OTG_FS_DTXFSTS3 : public RegisterReadOnly<0x50000978> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space available
        };

        // device OUT endpoint-1 transfer size register
        struct OTG_FS_DOEPTSIZ1 : public Register<0x50000b30> {
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
            using PKTCNT = Field<19, 10>;    // Packet count
            using XFRSIZ = Field<0, 19>;    // Transfer size
        };

        // device OUT endpoint-2 transfer size register
        struct OTG_FS_DOEPTSIZ2 : public Register<0x50000b50> {
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
            using PKTCNT = Field<19, 10>;    // Packet count
            using XFRSIZ = Field<0, 19>;    // Transfer size
        };

        // device OUT endpoint-3 transfer size register
        struct OTG_FS_DOEPTSIZ3 : public Register<0x50000b70> {
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
            using PKTCNT = Field<19, 10>;    // Packet count
            using XFRSIZ = Field<0, 19>;    // Transfer size
        };

        // OTG device endpoint-4 control register
        struct OTG_FS_DIEPCTL4 : public Register<0x50000980> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID/SEVNFRM
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using TXFNUM = Field<22, 4>;    // TXFNUM
            using Stall = Field<21, 1>;    // Stall
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EONUM_DPID = Field<16, 1>;    // EONUM/DPID
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 11>;    // MPSIZ
        };

        // device endpoint-4 interrupt register
        struct OTG_FS_DIEPINT4 : public Register<0x50000988> {
            using TXFE = Field<7, 1>;    // TXFE
            using INEPNE = Field<6, 1>;    // INEPNE
            using ITTXFE = Field<4, 1>;    // ITTXFE
            using TOC = Field<3, 1>;    // TOC
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-4 transfer size register
        struct OTG_FS_DIEPTSIZ4 : public Register<0x50000994> {
            using MCNT = Field<29, 2>;    // Multi count
            using PKTCNT = Field<19, 10>;    // Packet count
            using XFRSIZ = Field<0, 19>;    // Transfer size
        };

        // OTG_FS device IN endpoint transmit FIFO status register
        struct OTG_FS_DTXFSTS4 : public Register<0x5000099c> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space available
        };

        // OTG device endpoint-5 control register
        struct OTG_FS_DIEPCTL5 : public Register<0x500009a0> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID/SEVNFRM
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using TXFNUM = Field<22, 4>;    // TXFNUM
            using Stall = Field<21, 1>;    // Stall
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EONUM_DPID = Field<16, 1>;    // EONUM/DPID
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 11>;    // MPSIZ
        };

        // device endpoint-5 interrupt register
        struct OTG_FS_DIEPINT5 : public Register<0x500009a8> {
            using TXFE = Field<7, 1>;    // TXFE
            using INEPNE = Field<6, 1>;    // INEPNE
            using ITTXFE = Field<4, 1>;    // ITTXFE
            using TOC = Field<3, 1>;    // TOC
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-5 transfer size register
        struct OTG_FS_DIEPTSIZ55 : public Register<0x500009b0> {
            using MCNT = Field<29, 2>;    // Multi count
            using PKTCNT = Field<19, 10>;    // Packet count
            using XFRSIZ = Field<0, 19>;    // Transfer size
        };

        // OTG_FS device IN endpoint transmit FIFO status register
        struct OTG_FS_DTXFSTS55 : public Register<0x500009b8> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space available
        };

        // device endpoint-4 control register
        struct OTG_FS_DOEPCTL4 : public Register<0x50000b78> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID/SEVNFRM
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using Stall = Field<21, 1>;    // Stall
            using SNPM = Field<20, 1>;    // SNPM
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EONUM_DPID = Field<16, 1>;    // EONUM/DPID
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 11>;    // MPSIZ
        };

        // device endpoint-4 interrupt register
        struct OTG_FS_DOEPINT4 : public Register<0x50000b80> {
            using B2BSTUP = Field<6, 1>;    // B2BSTUP
            using OTEPDIS = Field<4, 1>;    // OTEPDIS
            using STUP = Field<3, 1>;    // STUP
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device OUT endpoint-4 transfer size register
        struct OTG_FS_DOEPTSIZ4 : public Register<0x50000b88> {
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
            using PKTCNT = Field<19, 10>;    // Packet count
            using XFRSIZ = Field<0, 19>;    // Transfer size
        };

        // device endpoint-5 control register
        struct OTG_FS_DOEPCTL5 : public Register<0x50000b90> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID/SEVNFRM
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using Stall = Field<21, 1>;    // Stall
            using SNPM = Field<20, 1>;    // SNPM
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EONUM_DPID = Field<16, 1>;    // EONUM/DPID
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 11>;    // MPSIZ
        };

        // device endpoint-5 interrupt register
        struct OTG_FS_DOEPINT5 : public Register<0x50000b98> {
            using B2BSTUP = Field<6, 1>;    // B2BSTUP
            using OTEPDIS = Field<4, 1>;    // OTEPDIS
            using STUP = Field<3, 1>;    // STUP
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device OUT endpoint-5 transfer size register
        struct OTG_FS_DOEPTSIZ5 : public Register<0x50000ba0> {
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
            using PKTCNT = Field<19, 10>;    // Packet count
            using XFRSIZ = Field<0, 19>;    // Transfer size
        };

    };

    // USB on the go full speed
    struct OTG_FS_PWRCLK {
        // OTG_FS power and clock gating control register (OTG_FS_PCGCCTL)
        struct OTG_FS_PCGCCTL : public Register<0x50000e00> {
            using STPPCLK = Field<0, 1>;    // Stop PHY clock
            using GATEHCLK = Field<1, 1>;    // Gate HCLK
            using PHYSUSP = Field<4, 1>;    // PHY Suspended
        };

    };

    // USB on the go high speed
    struct OTG_HS_HOST {
        // OTG_HS host configuration register
        struct OTG_HS_HCFG : public Register<0x40040400> {
            using FSLSPCS = Field<0, 2>;    // FS/LS PHY clock select
            using FSLSS = Field<2, 1>;    // FS- and LS-only support
        };

        // OTG_HS Host frame interval register
        struct OTG_HS_HFIR : public Register<0x40040404> {
            using FRIVL = Field<0, 16>;    // Frame interval
        };

        // OTG_HS host frame number/frame time remaining register
        struct OTG_HS_HFNUM : public RegisterReadOnly<0x40040408> {
            using FRNUM = Field<0, 16>;    // Frame number
            using FTREM = Field<16, 16>;    // Frame time remaining
        };

        // OTG_HS_Host periodic transmit FIFO/queue status register
        struct OTG_HS_HPTXSTS : public Register<0x40040410> {
            using PTXFSAVL = Field<0, 16>;    // Periodic transmit data FIFO space available
            using PTXQSAV = Field<16, 8>;    // Periodic transmit request queue space available
            using PTXQTOP = Field<24, 8>;    // Top of the periodic transmit request queue
        };

        // OTG_HS Host all channels interrupt register
        struct OTG_HS_HAINT : public RegisterReadOnly<0x40040414> {
            using HAINT = Field<0, 16>;    // Channel interrupts
        };

        // OTG_HS host all channels interrupt mask register
        struct OTG_HS_HAINTMSK : public Register<0x40040418> {
            using HAINTM = Field<0, 16>;    // Channel interrupt mask
        };

        // OTG_HS host port control and status register
        struct OTG_HS_HPRT : public Register<0x40040440> {
            using PCSTS = Field<0, 1>;    // Port connect status
            using PCDET = Field<1, 1>;    // Port connect detected
            using PENA = Field<2, 1>;    // Port enable
            using PENCHNG = Field<3, 1>;    // Port enable/disable change
            using POCA = Field<4, 1>;    // Port overcurrent active
            using POCCHNG = Field<5, 1>;    // Port overcurrent change
            using PRES = Field<6, 1>;    // Port resume
            using PSUSP = Field<7, 1>;    // Port suspend
            using PRST = Field<8, 1>;    // Port reset
            using PLSTS = Field<10, 2>;    // Port line status
            using PPWR = Field<12, 1>;    // Port power
            using PTCTL = Field<13, 4>;    // Port test control
            using PSPD = Field<17, 2>;    // Port speed
        };

        // OTG_HS host channel-0 characteristics register
        struct OTG_HS_HCCHAR0 : public Register<0x40040500> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-1 characteristics register
        struct OTG_HS_HCCHAR1 : public Register<0x40040520> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-2 characteristics register
        struct OTG_HS_HCCHAR2 : public Register<0x40040540> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-3 characteristics register
        struct OTG_HS_HCCHAR3 : public Register<0x40040560> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-4 characteristics register
        struct OTG_HS_HCCHAR4 : public Register<0x40040580> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-5 characteristics register
        struct OTG_HS_HCCHAR5 : public Register<0x400405a0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-6 characteristics register
        struct OTG_HS_HCCHAR6 : public Register<0x400405c0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-7 characteristics register
        struct OTG_HS_HCCHAR7 : public Register<0x400405e0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-8 characteristics register
        struct OTG_HS_HCCHAR8 : public Register<0x40040600> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-9 characteristics register
        struct OTG_HS_HCCHAR9 : public Register<0x40040620> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-10 characteristics register
        struct OTG_HS_HCCHAR10 : public Register<0x40040640> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-11 characteristics register
        struct OTG_HS_HCCHAR11 : public Register<0x40040660> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-0 split control register
        struct OTG_HS_HCSPLT0 : public Register<0x40040504> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-1 split control register
        struct OTG_HS_HCSPLT1 : public Register<0x40040524> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-2 split control register
        struct OTG_HS_HCSPLT2 : public Register<0x40040544> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-3 split control register
        struct OTG_HS_HCSPLT3 : public Register<0x40040564> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-4 split control register
        struct OTG_HS_HCSPLT4 : public Register<0x40040584> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-5 split control register
        struct OTG_HS_HCSPLT5 : public Register<0x400405a4> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-6 split control register
        struct OTG_HS_HCSPLT6 : public Register<0x400405c4> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-7 split control register
        struct OTG_HS_HCSPLT7 : public Register<0x400405e4> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-8 split control register
        struct OTG_HS_HCSPLT8 : public Register<0x40040604> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-9 split control register
        struct OTG_HS_HCSPLT9 : public Register<0x40040624> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-10 split control register
        struct OTG_HS_HCSPLT10 : public Register<0x40040644> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-11 split control register
        struct OTG_HS_HCSPLT11 : public Register<0x40040664> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-11 interrupt register
        struct OTG_HS_HCINT0 : public Register<0x40040508> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-1 interrupt register
        struct OTG_HS_HCINT1 : public Register<0x40040528> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-2 interrupt register
        struct OTG_HS_HCINT2 : public Register<0x40040548> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-3 interrupt register
        struct OTG_HS_HCINT3 : public Register<0x40040568> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-4 interrupt register
        struct OTG_HS_HCINT4 : public Register<0x40040588> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-5 interrupt register
        struct OTG_HS_HCINT5 : public Register<0x400405a8> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-6 interrupt register
        struct OTG_HS_HCINT6 : public Register<0x400405c8> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-7 interrupt register
        struct OTG_HS_HCINT7 : public Register<0x400405e8> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-8 interrupt register
        struct OTG_HS_HCINT8 : public Register<0x40040608> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-9 interrupt register
        struct OTG_HS_HCINT9 : public Register<0x40040628> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-10 interrupt register
        struct OTG_HS_HCINT10 : public Register<0x40040648> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-11 interrupt register
        struct OTG_HS_HCINT11 : public Register<0x40040668> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-11 interrupt mask register
        struct OTG_HS_HCINTMSK0 : public Register<0x4004050c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-1 interrupt mask register
        struct OTG_HS_HCINTMSK1 : public Register<0x4004052c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-2 interrupt mask register
        struct OTG_HS_HCINTMSK2 : public Register<0x4004054c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-3 interrupt mask register
        struct OTG_HS_HCINTMSK3 : public Register<0x4004056c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-4 interrupt mask register
        struct OTG_HS_HCINTMSK4 : public Register<0x4004058c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-5 interrupt mask register
        struct OTG_HS_HCINTMSK5 : public Register<0x400405ac> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-6 interrupt mask register
        struct OTG_HS_HCINTMSK6 : public Register<0x400405cc> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-7 interrupt mask register
        struct OTG_HS_HCINTMSK7 : public Register<0x400405ec> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-8 interrupt mask register
        struct OTG_HS_HCINTMSK8 : public Register<0x4004060c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-9 interrupt mask register
        struct OTG_HS_HCINTMSK9 : public Register<0x4004062c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-10 interrupt mask register
        struct OTG_HS_HCINTMSK10 : public Register<0x4004064c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-11 interrupt mask register
        struct OTG_HS_HCINTMSK11 : public Register<0x4004066c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-11 transfer size register
        struct OTG_HS_HCTSIZ0 : public Register<0x40040510> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-1 transfer size register
        struct OTG_HS_HCTSIZ1 : public Register<0x40040530> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-2 transfer size register
        struct OTG_HS_HCTSIZ2 : public Register<0x40040550> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-3 transfer size register
        struct OTG_HS_HCTSIZ3 : public Register<0x40040570> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-4 transfer size register
        struct OTG_HS_HCTSIZ4 : public Register<0x40040590> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-5 transfer size register
        struct OTG_HS_HCTSIZ5 : public Register<0x400405b0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-6 transfer size register
        struct OTG_HS_HCTSIZ6 : public Register<0x400405d0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-7 transfer size register
        struct OTG_HS_HCTSIZ7 : public Register<0x400405f0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-8 transfer size register
        struct OTG_HS_HCTSIZ8 : public Register<0x40040610> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-9 transfer size register
        struct OTG_HS_HCTSIZ9 : public Register<0x40040630> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-10 transfer size register
        struct OTG_HS_HCTSIZ10 : public Register<0x40040650> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-11 transfer size register
        struct OTG_HS_HCTSIZ11 : public Register<0x40040670> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-0 DMA address register
        struct OTG_HS_HCDMA0 : public Register<0x40040514> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-1 DMA address register
        struct OTG_HS_HCDMA1 : public Register<0x40040534> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-2 DMA address register
        struct OTG_HS_HCDMA2 : public Register<0x40040554> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-3 DMA address register
        struct OTG_HS_HCDMA3 : public Register<0x40040574> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-4 DMA address register
        struct OTG_HS_HCDMA4 : public Register<0x40040594> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-5 DMA address register
        struct OTG_HS_HCDMA5 : public Register<0x400405b4> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-6 DMA address register
        struct OTG_HS_HCDMA6 : public Register<0x400405d4> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-7 DMA address register
        struct OTG_HS_HCDMA7 : public Register<0x400405f4> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-8 DMA address register
        struct OTG_HS_HCDMA8 : public Register<0x40040614> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-9 DMA address register
        struct OTG_HS_HCDMA9 : public Register<0x40040634> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-10 DMA address register
        struct OTG_HS_HCDMA10 : public Register<0x40040654> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-11 DMA address register
        struct OTG_HS_HCDMA11 : public Register<0x40040674> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-12 characteristics register
        struct OTG_HS_HCCHAR12 : public Register<0x40040678> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-12 split control register
        struct OTG_HS_HCSPLT12 : public Register<0x4004067c> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-12 interrupt register
        struct OTG_HS_HCINT12 : public Register<0x40040680> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-12 interrupt mask register
        struct OTG_HS_HCINTMSK12 : public Register<0x40040684> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERRM = Field<7, 1>;    // Transaction error
            using BBERRM = Field<8, 1>;    // Babble error
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-12 transfer size register
        struct OTG_HS_HCTSIZ12 : public Register<0x40040688> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-12 DMA address register
        struct OTG_HS_HCDMA12 : public Register<0x4004068c> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-13 characteristics register
        struct OTG_HS_HCCHAR13 : public Register<0x40040690> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-13 split control register
        struct OTG_HS_HCSPLT13 : public Register<0x40040694> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-13 interrupt register
        struct OTG_HS_HCINT13 : public Register<0x40040698> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-13 interrupt mask register
        struct OTG_HS_HCINTMSK13 : public Register<0x4004069c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALLM response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERRM = Field<7, 1>;    // Transaction error
            using BBERRM = Field<8, 1>;    // Babble error
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-13 transfer size register
        struct OTG_HS_HCTSIZ13 : public Register<0x400406a0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-13 DMA address register
        struct OTG_HS_HCDMA13 : public Register<0x400406a4> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-14 characteristics register
        struct OTG_HS_HCCHAR14 : public Register<0x400406a8> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-14 split control register
        struct OTG_HS_HCSPLT14 : public Register<0x400406ac> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-14 interrupt register
        struct OTG_HS_HCINT14 : public Register<0x400406b0> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-14 interrupt mask register
        struct OTG_HS_HCINTMSK14 : public Register<0x400406b4> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAKM response received interrupt mask
            using ACKM = Field<5, 1>;    // ACKM response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERRM = Field<7, 1>;    // Transaction error
            using BBERRM = Field<8, 1>;    // Babble error
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-14 transfer size register
        struct OTG_HS_HCTSIZ14 : public Register<0x400406b8> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-14 DMA address register
        struct OTG_HS_HCDMA14 : public Register<0x400406bc> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-15 characteristics register
        struct OTG_HS_HCCHAR15 : public Register<0x400406c0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-15 split control register
        struct OTG_HS_HCSPLT15 : public Register<0x400406c4> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-15 interrupt register
        struct OTG_HS_HCINT15 : public Register<0x400406c8> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-15 interrupt mask register
        struct OTG_HS_HCINTMSK15 : public Register<0x400406cc> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERRM = Field<7, 1>;    // Transaction error
            using BBERRM = Field<8, 1>;    // Babble error
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-15 transfer size register
        struct OTG_HS_HCTSIZ15 : public Register<0x400406d0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-15 DMA address register
        struct OTG_HS_HCDMA15 : public Register<0x400406d4> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

    };

    // USB on the go high speed
    struct OTG_HS_DEVICE {
        // OTG_HS device configuration register
        struct OTG_HS_DCFG : public Register<0x40040800> {
            using DSPD = Field<0, 2>;    // Device speed
            using NZLSOHSK = Field<2, 1>;    // Nonzero-length status OUT handshake
            using DAD = Field<4, 7>;    // Device address
            using PFIVL = Field<11, 2>;    // Periodic (micro)frame interval
            using PERSCHIVL = Field<24, 2>;    // Periodic scheduling interval
        };

        // OTG_HS device control register
        struct OTG_HS_DCTL : public Register<0x40040804> {
            using RWUSIG = Field<0, 1>;    // Remote wakeup signaling
            using SDIS = Field<1, 1>;    // Soft disconnect
            using GINSTS = Field<2, 1>;    // Global IN NAK status
            using GONSTS = Field<3, 1>;    // Global OUT NAK status
            using TCTL = Field<4, 3>;    // Test control
            using SGINAK = Field<7, 1>;    // Set global IN NAK
            using CGINAK = Field<8, 1>;    // Clear global IN NAK
            using SGONAK = Field<9, 1>;    // Set global OUT NAK
            using CGONAK = Field<10, 1>;    // Clear global OUT NAK
            using POPRGDNE = Field<11, 1>;    // Power-on programming done
        };

        // OTG_HS device status register
        struct OTG_HS_DSTS : public RegisterReadOnly<0x40040808> {
            using SUSPSTS = Field<0, 1>;    // Suspend status
            using ENUMSPD = Field<1, 2>;    // Enumerated speed
            using EERR = Field<3, 1>;    // Erratic error
            using FNSOF = Field<8, 14>;    // Frame number of the received SOF
        };

        // OTG_HS device IN endpoint common interrupt mask register
        struct OTG_HS_DIEPMSK : public Register<0x40040810> {
            using XFRCM = Field<0, 1>;    // Transfer completed interrupt mask
            using EPDM = Field<1, 1>;    // Endpoint disabled interrupt mask
            using TOM = Field<3, 1>;    // Timeout condition mask (nonisochronous endpoints)
            using ITTXFEMSK = Field<4, 1>;    // IN token received when TxFIFO empty mask
            using INEPNMM = Field<5, 1>;    // IN token received with EP mismatch mask
            using INEPNEM = Field<6, 1>;    // IN endpoint NAK effective mask
            using TXFURM = Field<8, 1>;    // FIFO underrun mask
            using BIM = Field<9, 1>;    // BNA interrupt mask
        };

        // OTG_HS device OUT endpoint common interrupt mask register
        struct OTG_HS_DOEPMSK : public Register<0x40040814> {
            using XFRCM = Field<0, 1>;    // Transfer completed interrupt mask
            using EPDM = Field<1, 1>;    // Endpoint disabled interrupt mask
            using STUPM = Field<3, 1>;    // SETUP phase done mask
            using OTEPDM = Field<4, 1>;    // OUT token received when endpoint disabled mask
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received mask
            using OPEM = Field<8, 1>;    // OUT packet error mask
            using BOIM = Field<9, 1>;    // BNA interrupt mask
        };

        // OTG_HS device all endpoints interrupt register
        struct OTG_HS_DAINT : public RegisterReadOnly<0x40040818> {
            using IEPINT = Field<0, 16>;    // IN endpoint interrupt bits
            using OEPINT = Field<16, 16>;    // OUT endpoint interrupt bits
        };

        // OTG_HS all endpoints interrupt mask register
        struct OTG_HS_DAINTMSK : public Register<0x4004081c> {
            using IEPM = Field<0, 16>;    // IN EP interrupt mask bits
            using OEPM = Field<16, 16>;    // OUT EP interrupt mask bits
        };

        // OTG_HS device VBUS discharge time register
        struct OTG_HS_DVBUSDIS : public Register<0x40040828> {
            using VBUSDT = Field<0, 16>;    // Device VBUS discharge time
        };

        // OTG_HS device VBUS pulsing time register
        struct OTG_HS_DVBUSPULSE : public Register<0x4004082c> {
            using DVBUSP = Field<0, 12>;    // Device VBUS pulsing time
        };

        // OTG_HS Device threshold control register
        struct OTG_HS_DTHRCTL : public Register<0x40040830> {
            using NONISOTHREN = Field<0, 1>;    // Nonisochronous IN endpoints threshold enable
            using ISOTHREN = Field<1, 1>;    // ISO IN endpoint threshold enable
            using TXTHRLEN = Field<2, 9>;    // Transmit threshold length
            using RXTHREN = Field<16, 1>;    // Receive threshold enable
            using RXTHRLEN = Field<17, 9>;    // Receive threshold length
            using ARPEN = Field<27, 1>;    // Arbiter parking enable
        };

        // OTG_HS device IN endpoint FIFO empty interrupt mask register
        struct OTG_HS_DIEPEMPMSK : public Register<0x40040834> {
            using INEPTXFEM = Field<0, 16>;    // IN EP Tx FIFO empty interrupt mask bits
        };

        // OTG_HS device each endpoint interrupt register
        struct OTG_HS_DEACHINT : public Register<0x40040838> {
            using IEP1INT = Field<1, 1>;    // IN endpoint 1interrupt bit
            using OEP1INT = Field<17, 1>;    // OUT endpoint 1 interrupt bit
        };

        // OTG_HS device each endpoint interrupt register mask
        struct OTG_HS_DEACHINTMSK : public Register<0x4004083c> {
            using IEP1INTM = Field<1, 1>;    // IN Endpoint 1 interrupt mask bit
            using OEP1INTM = Field<17, 1>;    // OUT Endpoint 1 interrupt mask bit
        };

        // OTG device endpoint-0 control register
        struct OTG_HS_DIEPCTL0 : public Register<0x40040900> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-1 control register
        struct OTG_HS_DIEPCTL1 : public Register<0x40040920> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-2 control register
        struct OTG_HS_DIEPCTL2 : public Register<0x40040940> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-3 control register
        struct OTG_HS_DIEPCTL3 : public Register<0x40040960> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-4 control register
        struct OTG_HS_DIEPCTL4 : public Register<0x40040980> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-5 control register
        struct OTG_HS_DIEPCTL5 : public Register<0x400409a0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-6 control register
        struct OTG_HS_DIEPCTL6 : public Register<0x400409c0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-7 control register
        struct OTG_HS_DIEPCTL7 : public Register<0x400409e0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-0 interrupt register
        struct OTG_HS_DIEPINT0 : public Register<0x40040908> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG device endpoint-1 interrupt register
        struct OTG_HS_DIEPINT1 : public Register<0x40040928> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG device endpoint-2 interrupt register
        struct OTG_HS_DIEPINT2 : public Register<0x40040948> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG device endpoint-3 interrupt register
        struct OTG_HS_DIEPINT3 : public Register<0x40040968> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG device endpoint-4 interrupt register
        struct OTG_HS_DIEPINT4 : public Register<0x40040988> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG device endpoint-5 interrupt register
        struct OTG_HS_DIEPINT5 : public Register<0x400409a8> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG device endpoint-6 interrupt register
        struct OTG_HS_DIEPINT6 : public Register<0x400409c8> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG device endpoint-7 interrupt register
        struct OTG_HS_DIEPINT7 : public Register<0x400409e8> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG_HS device IN endpoint 0 transfer size register
        struct OTG_HS_DIEPTSIZ0 : public Register<0x40040910> {
            using XFRSIZ = Field<0, 7>;    // Transfer size
            using PKTCNT = Field<19, 2>;    // Packet count
        };

        // OTG_HS device endpoint-1 DMA address register
        struct OTG_HS_DIEPDMA1 : public Register<0x40040914> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS device endpoint-2 DMA address register
        struct OTG_HS_DIEPDMA2 : public Register<0x40040934> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS device endpoint-3 DMA address register
        struct OTG_HS_DIEPDMA3 : public Register<0x40040954> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS device endpoint-4 DMA address register
        struct OTG_HS_DIEPDMA4 : public Register<0x40040974> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS device endpoint-5 DMA address register
        struct OTG_HS_DIEPDMA5 : public Register<0x40040994> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS0 : public RegisterReadOnly<0x40040918> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS1 : public RegisterReadOnly<0x40040938> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS2 : public RegisterReadOnly<0x40040958> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS3 : public RegisterReadOnly<0x40040978> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS4 : public RegisterReadOnly<0x40040998> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS5 : public RegisterReadOnly<0x400409b8> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG_HS device endpoint transfer size register
        struct OTG_HS_DIEPTSIZ1 : public Register<0x40040930> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using MCNT = Field<29, 2>;    // Multi count
        };

        // OTG_HS device endpoint transfer size register
        struct OTG_HS_DIEPTSIZ2 : public Register<0x40040950> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using MCNT = Field<29, 2>;    // Multi count
        };

        // OTG_HS device endpoint transfer size register
        struct OTG_HS_DIEPTSIZ3 : public Register<0x40040970> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using MCNT = Field<29, 2>;    // Multi count
        };

        // OTG_HS device endpoint transfer size register
        struct OTG_HS_DIEPTSIZ4 : public Register<0x40040990> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using MCNT = Field<29, 2>;    // Multi count
        };

        // OTG_HS device endpoint transfer size register
        struct OTG_HS_DIEPTSIZ5 : public Register<0x400409b0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using MCNT = Field<29, 2>;    // Multi count
        };

        // OTG_HS device control OUT endpoint 0 control register
        struct OTG_HS_DOEPCTL0 : public Register<0x40040b00> {
            using MPSIZ = Field<0, 2>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-1 control register
        struct OTG_HS_DOEPCTL1 : public Register<0x40040b20> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even odd frame/Endpoint data PID
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID/Set even frame
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-2 control register
        struct OTG_HS_DOEPCTL2 : public Register<0x40040b40> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even odd frame/Endpoint data PID
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID/Set even frame
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-3 control register
        struct OTG_HS_DOEPCTL3 : public Register<0x40040b60> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even odd frame/Endpoint data PID
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID/Set even frame
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG_HS device endpoint-0 interrupt register
        struct OTG_HS_DOEPINT0 : public Register<0x40040b08> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-1 interrupt register
        struct OTG_HS_DOEPINT1 : public Register<0x40040b28> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-2 interrupt register
        struct OTG_HS_DOEPINT2 : public Register<0x40040b48> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-3 interrupt register
        struct OTG_HS_DOEPINT3 : public Register<0x40040b68> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-4 interrupt register
        struct OTG_HS_DOEPINT4 : public Register<0x40040b88> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-5 interrupt register
        struct OTG_HS_DOEPINT5 : public Register<0x40040ba8> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-6 interrupt register
        struct OTG_HS_DOEPINT6 : public Register<0x40040bc8> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-7 interrupt register
        struct OTG_HS_DOEPINT7 : public Register<0x40040be8> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-0 transfer size register
        struct OTG_HS_DOEPTSIZ0 : public Register<0x40040b10> {
            using XFRSIZ = Field<0, 7>;    // Transfer size
            using PKTCNT = Field<19, 1>;    // Packet count
            using STUPCNT = Field<29, 2>;    // SETUP packet count
        };

        // OTG_HS device endpoint-1 transfer size register
        struct OTG_HS_DOEPTSIZ1 : public Register<0x40040b30> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
        };

        // OTG_HS device endpoint-2 transfer size register
        struct OTG_HS_DOEPTSIZ2 : public Register<0x40040b50> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
        };

        // OTG_HS device endpoint-3 transfer size register
        struct OTG_HS_DOEPTSIZ3 : public Register<0x40040b70> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
        };

        // OTG_HS device endpoint-4 transfer size register
        struct OTG_HS_DOEPTSIZ4 : public Register<0x40040b90> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
        };

        // OTG_HS device endpoint transfer size register
        struct OTG_HS_DIEPTSIZ6 : public Register<0x400409a0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using MCNT = Field<29, 2>;    // Multi count
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS6 : public Register<0x400409a4> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG_HS device endpoint transfer size register
        struct OTG_HS_DIEPTSIZ7 : public Register<0x400409a8> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using MCNT = Field<29, 2>;    // Multi count
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS7 : public Register<0x400409ac> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG device endpoint-4 control register
        struct OTG_HS_DOEPCTL4 : public Register<0x40040b80> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even odd frame/Endpoint data PID
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID/Set even frame
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-5 control register
        struct OTG_HS_DOEPCTL5 : public Register<0x40040ba0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even odd frame/Endpoint data PID
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID/Set even frame
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-6 control register
        struct OTG_HS_DOEPCTL6 : public Register<0x40040bc0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even odd frame/Endpoint data PID
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID/Set even frame
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-7 control register
        struct OTG_HS_DOEPCTL7 : public Register<0x40040be0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even odd frame/Endpoint data PID
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID/Set even frame
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG_HS device endpoint-5 transfer size register
        struct OTG_HS_DOEPTSIZ5 : public Register<0x40040bb0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
        };

        // OTG_HS device endpoint-6 transfer size register
        struct OTG_HS_DOEPTSIZ6 : public Register<0x40040bd0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
        };

        // OTG_HS device endpoint-7 transfer size register
        struct OTG_HS_DOEPTSIZ7 : public Register<0x40040bf0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
        };

    };

    // USB on the go high speed
    struct OTG_HS_PWRCLK {
        // Power and clock gating control register
        struct OTG_HS_PCGCR : public Register<0x40040e00> {
            using STPPCLK = Field<0, 1>;    // Stop PHY clock
            using GATEHCLK = Field<1, 1>;    // Gate HCLK
            using PHYSUSP = Field<4, 1>;    // PHY suspended
        };

    };

    // DSI Host
    struct DSI {
        // DSI Host Version Register
        struct DSI_VR : public RegisterReadOnly<0x40016c00> {
            using VERSION = Field<0, 32>;    // Version of the DSI Host
        };

        // DSI Host Control Register
        struct DSI_CR : public Register<0x40016c04> {
            using EN = Field<0, 1>;    // Enable
        };

        // DSI HOST Clock Control Register
        struct DSI_CCR : public Register<0x40016c08> {
            using TXECKDIV = Field<0, 8>;    // TX Escape Clock Division
            using TOCKDIV = Field<8, 8>;    // Timeout Clock Division
        };

        // DSI Host LTDC VCID Register
        struct DSI_LVCIDR : public Register<0x40016c0c> {
            using VCID = Field<0, 2>;    // Virtual Channel ID
        };

        // DSI Host LTDC Color Coding Register
        struct DSI_LCOLCR : public Register<0x40016c10> {
            using COLC = Field<0, 4>;    // Color Coding
            using LPE = Field<8, 1>;    // Loosely Packet Enable
        };

        // DSI Host LTDC Polarity Configuration Register
        struct DSI_LPCR : public Register<0x40016c14> {
            using DEP = Field<0, 1>;    // Data Enable Polarity
            using VSP = Field<1, 1>;    // VSYNC Polarity
            using HSP = Field<2, 1>;    // HSYNC Polarity
        };

        // DSI Host Low-Power mode Configuration Register
        struct DSI_LPMCR : public Register<0x40016c18> {
            using VLPSIZE = Field<0, 8>;    // VACT Largest Packet Size
            using LPSIZE = Field<16, 8>;    // Largest Packet Size
        };

        // DSI Host Protocol Configuration Register
        struct DSI_PCR : public Register<0x40016c2c> {
            using ETTXE = Field<0, 1>;    // EoTp Transmission Enable
            using ETRXE = Field<1, 1>;    // EoTp Reception Enable
            using BTAE = Field<2, 1>;    // Bus Turn Around Enable
            using ECCRXE = Field<3, 1>;    // ECC Reception Enable
            using CRCRXE = Field<4, 1>;    // CRC Reception Enable
        };

        // DSI Host Generic VCID Register
        struct DSI_GVCIDR : public Register<0x40016c30> {
            using VCID = Field<0, 2>;    // Virtual Channel ID
        };

        // DSI Host mode Configuration Register
        struct DSI_MCR : public Register<0x40016c34> {
            using CMDM = Field<0, 1>;    // Command mode
        };

        // DSI Host Video mode Configuration Register
        struct DSI_VMCR : public Register<0x40016c38> {
            using VMT = Field<0, 2>;    // Video mode Type
            using LPVSAE = Field<8, 1>;    // Low-Power Vertical Sync Active Enable
            using LPVBPE = Field<9, 1>;    // Low-power Vertical Back-Porch Enable
            using LPVFPE = Field<10, 1>;    // Low-power Vertical Front-porch Enable
            using LPVAE = Field<11, 1>;    // Low-Power Vertical Active Enable
            using LPHBPE = Field<12, 1>;    // Low-Power Horizontal Back-Porch Enable
            using LPHFPE = Field<13, 1>;    // Low-Power Horizontal Front-Porch Enable
            using FBTAAE = Field<14, 1>;    // Frame Bus-Turn-Around Acknowledge Enable
            using LPCE = Field<15, 1>;    // Low-Power Command Enable
            using PGE = Field<16, 1>;    // Pattern Generator Enable
            using PGM = Field<20, 1>;    // Pattern Generator mode
            using PGO = Field<24, 1>;    // Pattern Generator Orientation
        };

        // DSI Host Video Packet Configuration Register
        struct DSI_VPCR : public Register<0x40016c3c> {
            using VPSIZE = Field<0, 14>;    // Video Packet Size
        };

        // DSI Host Video Chunks Configuration Register
        struct DSI_VCCR : public Register<0x40016c40> {
            using NUMC = Field<0, 13>;    // Number of Chunks
        };

        // DSI Host Video Null Packet Configuration Register
        struct DSI_VNPCR : public Register<0x40016c44> {
            using NPSIZE = Field<0, 13>;    // Null Packet Size
        };

        // DSI Host Video HSA Configuration Register
        struct DSI_VHSACR : public Register<0x40016c48> {
            using HSA = Field<0, 12>;    // Horizontal Synchronism Active duration
        };

        // DSI Host Video HBP Configuration Register
        struct DSI_VHBPCR : public Register<0x40016c4c> {
            using HBP = Field<0, 12>;    // Horizontal Back-Porch duration
        };

        // DSI Host Video Line Configuration Register
        struct DSI_VLCR : public Register<0x40016c50> {
            using HLINE = Field<0, 15>;    // Horizontal Line duration
        };

        // DSI Host Video VSA Configuration Register
        struct DSI_VVSACR : public Register<0x40016c54> {
            using VSA = Field<0, 10>;    // Vertical Synchronism Active duration
        };

        // DSI Host Video VBP Configuration Register
        struct DSI_VVBPCR : public Register<0x40016c58> {
            using VBP = Field<0, 10>;    // Vertical Back-Porch duration
        };

        // DSI Host Video VFP Configuration Register
        struct DSI_VVFPCR : public Register<0x40016c5c> {
            using VFP = Field<0, 10>;    // Vertical Front-Porch duration
        };

        // DSI Host Video VA Configuration Register
        struct DSI_VVACR : public Register<0x40016c60> {
            using VA = Field<0, 14>;    // Vertical Active duration
        };

        // DSI Host LTDC Command Configuration Register
        struct DSI_LCCR : public Register<0x40016c64> {
            using CMDSIZE = Field<0, 16>;    // Command Size
        };

        // DSI Host Command mode Configuration Register
        struct DSI_CMCR : public Register<0x40016c68> {
            using TEARE = Field<0, 1>;    // Tearing Effect Acknowledge Request Enable
            using ARE = Field<1, 1>;    // Acknowledge Request Enable
            using GSW0TX = Field<8, 1>;    // Generic Short Write Zero parameters Transmission
            using GSW1TX = Field<9, 1>;    // Generic Short Write One parameters Transmission
            using GSW2TX = Field<10, 1>;    // Generic Short Write Two parameters Transmission
            using GSR0TX = Field<11, 1>;    // Generic Short Read Zero parameters Transmission
            using GSR1TX = Field<12, 1>;    // Generic Short Read One parameters Transmission
            using GSR2TX = Field<13, 1>;    // Generic Short Read Two parameters Transmission
            using GLWTX = Field<14, 1>;    // Generic Long Write Transmission
            using DSW0TX = Field<16, 1>;    // DCS Short Write Zero parameter Transmission
            using DSW1TX = Field<17, 1>;    // DCS Short Read One parameter Transmission
            using DSR0TX = Field<18, 1>;    // DCS Short Read Zero parameter Transmission
            using DLWTX = Field<19, 1>;    // DCS Long Write Transmission
            using MRDPS = Field<24, 1>;    // Maximum Read Packet Size
        };

        // DSI Host Generic Header Configuration Register
        struct DSI_GHCR : public Register<0x40016c6c> {
            using DT = Field<0, 6>;    // Type
            using VCID = Field<6, 2>;    // Channel
            using WCLSB = Field<8, 8>;    // WordCount LSB
            using WCMSB = Field<16, 8>;    // WordCount MSB
        };

        // DSI Host Generic Payload Data Register
        struct DSI_GPDR : public Register<0x40016c70> {
            using DATA1 = Field<0, 8>;    // Payload Byte 1
            using DATA2 = Field<8, 8>;    // Payload Byte 2
            using DATA3 = Field<16, 8>;    // Payload Byte 3
            using DATA4 = Field<24, 8>;    // Payload Byte 4
        };

        // DSI Host Generic Packet Status Register
        struct DSI_GPSR : public RegisterReadOnly<0x40016c74> {
            using CMDFE = Field<0, 1>;    // Command FIFO Empty
            using CMDFF = Field<1, 1>;    // Command FIFO Full
            using PWRFE = Field<2, 1>;    // Payload Write FIFO Empty
            using PWRFF = Field<3, 1>;    // Payload Write FIFO Full
            using PRDFE = Field<4, 1>;    // Payload Read FIFO Empty
            using PRDFF = Field<5, 1>;    // Payload Read FIFO Full
            using RCB = Field<6, 1>;    // Read Command Busy
        };

        // DSI Host Timeout Counter Configuration Register 0
        struct DSI_TCCR0 : public Register<0x40016c78> {
            using LPRX_TOCNT = Field<0, 16>;    // Low-power Reception Timeout Counter
            using HSTX_TOCNT = Field<16, 16>;    // High-Speed Transmission Timeout Counter
        };

        // DSI Host Timeout Counter Configuration Register 1
        struct DSI_TCCR1 : public Register<0x40016c7c> {
            using HSRD_TOCNT = Field<0, 16>;    // High-Speed Read Timeout Counter
        };

        // DSI Host Timeout Counter Configuration Register 2
        struct DSI_TCCR2 : public Register<0x40016c80> {
            using LPRD_TOCNT = Field<0, 16>;    // Low-Power Read Timeout Counter
        };

        // DSI Host Timeout Counter Configuration Register 3
        struct DSI_TCCR3 : public Register<0x40016c84> {
            using HSWR_TOCNT = Field<0, 16>;    // High-Speed Write Timeout Counter
            using PM = Field<24, 1>;    // Presp mode
        };

        // DSI Host Timeout Counter Configuration Register 4
        struct DSI_TCCR4 : public Register<0x40016c88> {
            using LSWR_TOCNT = Field<0, 16>;    // Low-Power Write Timeout Counter
        };

        // DSI Host Timeout Counter Configuration Register 5
        struct DSI_TCCR5 : public Register<0x40016c8c> {
            using BTA_TOCNT = Field<0, 16>;    // Bus-Turn-Around Timeout Counter
        };

        // DSI Host Clock Lane Configuration Register
        struct DSI_CLCR : public Register<0x40016c94> {
            using DPCC = Field<0, 1>;    // D-PHY Clock Control
            using ACR = Field<1, 1>;    // Automatic Clock lane Control
        };

        // DSI Host Clock Lane Timer Configuration Register
        struct DSI_CLTCR : public Register<0x40016c98> {
            using LP2HS_TIME = Field<0, 10>;    // Low-Power to High-Speed Time
            using HS2LP_TIME = Field<16, 10>;    // High-Speed to Low-Power Time
        };

        // DSI Host Data Lane Timer Configuration Register
        struct DSI_DLTCR : public Register<0x40016c9c> {
            using MRD_TIME = Field<0, 15>;    // Maximum Read Time
            using LP2HS_TIME = Field<16, 8>;    // Low-Power To High-Speed Time
            using HS2LP_TIME = Field<24, 8>;    // High-Speed To Low-Power Time
        };

        // DSI Host PHY Control Register
        struct DSI_PCTLR : public Register<0x40016ca0> {
            using DEN = Field<1, 1>;    // Digital Enable
            using CKE = Field<2, 1>;    // Clock Enable
        };

        // DSI Host PHY Configuration Register
        struct DSI_PCONFR : public Register<0x40016ca4> {
            using NL = Field<0, 2>;    // Number of Lanes
            using SW_TIME = Field<8, 8>;    // Stop Wait Time
        };

        // DSI Host PHY ULPS Control Register
        struct DSI_PUCR : public Register<0x40016ca8> {
            using URCL = Field<0, 1>;    // ULPS Request on Clock Lane
            using UECL = Field<1, 1>;    // ULPS Exit on Clock Lane
            using URDL = Field<2, 1>;    // ULPS Request on Data Lane
            using UEDL = Field<3, 1>;    // ULPS Exit on Data Lane
        };

        // DSI Host PHY TX Triggers Configuration Register
        struct DSI_PTTCR : public Register<0x40016cac> {
            using TX_TRIG = Field<0, 4>;    // Transmission Trigger
        };

        // DSI Host PHY Status Register
        struct DSI_PSR : public RegisterReadOnly<0x40016cb0> {
            using PD = Field<1, 1>;    // PHY Direction
            using PSSC = Field<2, 1>;    // PHY Stop State Clock lane
            using UANC = Field<3, 1>;    // ULPS Active Not Clock lane
            using PSS0 = Field<4, 1>;    // PHY Stop State lane 0
            using UAN0 = Field<5, 1>;    // ULPS Active Not lane 1
            using RUE0 = Field<6, 1>;    // RX ULPS Escape lane 0
            using PSS1 = Field<7, 1>;    // PHY Stop State lane 1
            using UAN1 = Field<8, 1>;    // ULPS Active Not lane 1
        };

        // DSI Host Interrupt & Status Register 0
        struct DSI_ISR0 : public RegisterReadOnly<0x40016cbc> {
            using AE0 = Field<0, 1>;    // Acknowledge Error 0
            using AE1 = Field<1, 1>;    // Acknowledge Error 1
            using AE2 = Field<2, 1>;    // Acknowledge Error 2
            using AE3 = Field<3, 1>;    // Acknowledge Error 3
            using AE4 = Field<4, 1>;    // Acknowledge Error 4
            using AE5 = Field<5, 1>;    // Acknowledge Error 5
            using AE6 = Field<6, 1>;    // Acknowledge Error 6
            using AE7 = Field<7, 1>;    // Acknowledge Error 7
            using AE8 = Field<8, 1>;    // Acknowledge Error 8
            using AE9 = Field<9, 1>;    // Acknowledge Error 9
            using AE10 = Field<10, 1>;    // Acknowledge Error 10
            using AE11 = Field<11, 1>;    // Acknowledge Error 11
            using AE12 = Field<12, 1>;    // Acknowledge Error 12
            using AE13 = Field<13, 1>;    // Acknowledge Error 13
            using AE14 = Field<14, 1>;    // Acknowledge Error 14
            using AE15 = Field<15, 1>;    // Acknowledge Error 15
            using PE0 = Field<16, 1>;    // PHY Error 0
            using PE1 = Field<17, 1>;    // PHY Error 1
            using PE2 = Field<18, 1>;    // PHY Error 2
            using PE3 = Field<19, 1>;    // PHY Error 3
            using PE4 = Field<20, 1>;    // PHY Error 4
        };

        // DSI Host Interrupt & Status Register 1
        struct DSI_ISR1 : public RegisterReadOnly<0x40016cc0> {
            using TOHSTX = Field<0, 1>;    // Timeout High-Speed Transmission
            using TOLPRX = Field<1, 1>;    // Timeout Low-Power Reception
            using ECCSE = Field<2, 1>;    // ECC Single-bit Error
            using ECCME = Field<3, 1>;    // ECC Multi-bit Error
            using CRCE = Field<4, 1>;    // CRC Error
            using PSE = Field<5, 1>;    // Packet Size Error
            using EOTPE = Field<6, 1>;    // EoTp Error
            using LPWRE = Field<7, 1>;    // LTDC Payload Write Error
            using GCWRE = Field<8, 1>;    // Generic Command Write Error
            using GPWRE = Field<9, 1>;    // Generic Payload Write Error
            using GPTXE = Field<10, 1>;    // Generic Payload Transmit Error
            using GPRDE = Field<11, 1>;    // Generic Payload Read Error
            using GPRXE = Field<12, 1>;    // Generic Payload Receive Error
        };

        // DSI Host Interrupt Enable Register 0
        struct DSI_IER0 : public Register<0x40016cc4> {
            using AE0IE = Field<0, 1>;    // Acknowledge Error 0 Interrupt Enable
            using AE1IE = Field<1, 1>;    // Acknowledge Error 1 Interrupt Enable
            using AE2IE = Field<2, 1>;    // Acknowledge Error 2 Interrupt Enable
            using AE3IE = Field<3, 1>;    // Acknowledge Error 3 Interrupt Enable
            using AE4IE = Field<4, 1>;    // Acknowledge Error 4 Interrupt Enable
            using AE5IE = Field<5, 1>;    // Acknowledge Error 5 Interrupt Enable
            using AE6IE = Field<6, 1>;    // Acknowledge Error 6 Interrupt Enable
            using AE7IE = Field<7, 1>;    // Acknowledge Error 7 Interrupt Enable
            using AE8IE = Field<8, 1>;    // Acknowledge Error 8 Interrupt Enable
            using AE9IE = Field<9, 1>;    // Acknowledge Error 9 Interrupt Enable
            using AE10IE = Field<10, 1>;    // Acknowledge Error 10 Interrupt Enable
            using AE11IE = Field<11, 1>;    // Acknowledge Error 11 Interrupt Enable
            using AE12IE = Field<12, 1>;    // Acknowledge Error 12 Interrupt Enable
            using AE13IE = Field<13, 1>;    // Acknowledge Error 13 Interrupt Enable
            using AE14IE = Field<14, 1>;    // Acknowledge Error 14 Interrupt Enable
            using AE15IE = Field<15, 1>;    // Acknowledge Error 15 Interrupt Enable
            using PE0IE = Field<16, 1>;    // PHY Error 0 Interrupt Enable
            using PE1IE = Field<17, 1>;    // PHY Error 1 Interrupt Enable
            using PE2IE = Field<18, 1>;    // PHY Error 2 Interrupt Enable
            using PE3IE = Field<19, 1>;    // PHY Error 3 Interrupt Enable
            using PE4IE = Field<20, 1>;    // PHY Error 4 Interrupt Enable
        };

        // DSI Host Interrupt Enable Register 1
        struct DSI_IER1 : public Register<0x40016cc8> {
            using TOHSTXIE = Field<0, 1>;    // Timeout High-Speed Transmission Interrupt Enable
            using TOLPRXIE = Field<1, 1>;    // Timeout Low-Power Reception Interrupt Enable
            using ECCSEIE = Field<2, 1>;    // ECC Single-bit Error Interrupt Enable
            using ECCMEIE = Field<3, 1>;    // ECC Multi-bit Error Interrupt Enable
            using CRCEIE = Field<4, 1>;    // CRC Error Interrupt Enable
            using PSEIE = Field<5, 1>;    // Packet Size Error Interrupt Enable
            using EOTPEIE = Field<6, 1>;    // EoTp Error Interrupt Enable
            using LPWREIE = Field<7, 1>;    // LTDC Payload Write Error Interrupt Enable
            using GCWREIE = Field<8, 1>;    // Generic Command Write Error Interrupt Enable
            using GPWREIE = Field<9, 1>;    // Generic Payload Write Error Interrupt Enable
            using GPTXEIE = Field<10, 1>;    // Generic Payload Transmit Error Interrupt Enable
            using GPRDEIE = Field<11, 1>;    // Generic Payload Read Error Interrupt Enable
            using GPRXEIE = Field<12, 1>;    // Generic Payload Receive Error Interrupt Enable
        };

        // DSI Host Force Interrupt Register 0
        struct DSI_FIR0 : public RegisterWriteOnly<0x40016cd8> {
            using FAE0 = Field<0, 1>;    // Force Acknowledge Error 0
            using FAE1 = Field<1, 1>;    // Force Acknowledge Error 1
            using FAE2 = Field<2, 1>;    // Force Acknowledge Error 2
            using FAE3 = Field<3, 1>;    // Force Acknowledge Error 3
            using FAE4 = Field<4, 1>;    // Force Acknowledge Error 4
            using FAE5 = Field<5, 1>;    // Force Acknowledge Error 5
            using FAE6 = Field<6, 1>;    // Force Acknowledge Error 6
            using FAE7 = Field<7, 1>;    // Force Acknowledge Error 7
            using FAE8 = Field<8, 1>;    // Force Acknowledge Error 8
            using FAE9 = Field<9, 1>;    // Force Acknowledge Error 9
            using FAE10 = Field<10, 1>;    // Force Acknowledge Error 10
            using FAE11 = Field<11, 1>;    // Force Acknowledge Error 11
            using FAE12 = Field<12, 1>;    // Force Acknowledge Error 12
            using FAE13 = Field<13, 1>;    // Force Acknowledge Error 13
            using FAE14 = Field<14, 1>;    // Force Acknowledge Error 14
            using FAE15 = Field<15, 1>;    // Force Acknowledge Error 15
            using FPE0 = Field<16, 1>;    // Force PHY Error 0
            using FPE1 = Field<17, 1>;    // Force PHY Error 1
            using FPE2 = Field<18, 1>;    // Force PHY Error 2
            using FPE3 = Field<19, 1>;    // Force PHY Error 3
            using FPE4 = Field<20, 1>;    // Force PHY Error 4
        };

        // DSI Host Force Interrupt Register 1
        struct DSI_FIR1 : public RegisterWriteOnly<0x40016cdc> {
            using FTOHSTX = Field<0, 1>;    // Force Timeout High-Speed Transmission
            using FTOLPRX = Field<1, 1>;    // Force Timeout Low-Power Reception
            using FECCSE = Field<2, 1>;    // Force ECC Single-bit Error
            using FECCME = Field<3, 1>;    // Force ECC Multi-bit Error
            using FCRCE = Field<4, 1>;    // Force CRC Error
            using FPSE = Field<5, 1>;    // Force Packet Size Error
            using FEOTPE = Field<6, 1>;    // Force EoTp Error
            using FLPWRE = Field<7, 1>;    // Force LTDC Payload Write Error
            using FGCWRE = Field<8, 1>;    // Force Generic Command Write Error
            using FGPWRE = Field<9, 1>;    // Force Generic Payload Write Error
            using FGPTXE = Field<10, 1>;    // Force Generic Payload Transmit Error
            using FGPRDE = Field<11, 1>;    // Force Generic Payload Read Error
            using FGPRXE = Field<12, 1>;    // Force Generic Payload Receive Error
        };

        // DSI Host Video Shadow Control Register
        struct DSI_VSCR : public Register<0x40016d00> {
            using EN = Field<0, 1>;    // Enable
            using UR = Field<8, 1>;    // Update Register
        };

        // DSI Host LTDC Current VCID Register
        struct DSI_LCVCIDR : public RegisterReadOnly<0x40016d0c> {
            using VCID = Field<0, 2>;    // Virtual Channel ID
        };

        // DSI Host LTDC Current Color Coding Register
        struct DSI_LCCCR : public RegisterReadOnly<0x40016d10> {
            using COLC = Field<0, 4>;    // Color Coding
            using LPE = Field<8, 1>;    // Loosely Packed Enable
        };

        // DSI Host Low-Power mode Current Configuration Register
        struct DSI_LPMCCR : public RegisterReadOnly<0x40016d18> {
            using VLPSIZE = Field<0, 8>;    // VACT Largest Packet Size
            using LPSIZE = Field<16, 8>;    // Largest Packet Size
        };

        // DSI Host Video mode Current Configuration Register
        struct DSI_VMCCR : public RegisterReadOnly<0x40016d38> {
            using VMT = Field<0, 2>;    // Video mode Type
            using LPVSAE = Field<2, 1>;    // Low-Power Vertical Sync time Enable
            using LPVBPE = Field<3, 1>;    // Low-power Vertical Back-Porch Enable
            using LPVFPE = Field<4, 1>;    // Low-power Vertical Front-Porch Enable
            using LPVAE = Field<5, 1>;    // Low-Power Vertical Active Enable
            using LPHBPE = Field<6, 1>;    // Low-power Horizontal Back-Porch Enable
            using LPHFE = Field<7, 1>;    // Low-Power Horizontal Front-Porch Enable
            using FBTAAE = Field<8, 1>;    // Frame BTA Acknowledge Enable
            using LPCE = Field<9, 1>;    // Low-Power Command Enable
        };

        // DSI Host Video Packet Current Configuration Register
        struct DSI_VPCCR : public RegisterReadOnly<0x40016d3c> {
            using VPSIZE = Field<0, 14>;    // Video Packet Size
        };

        // DSI Host Video Chunks Current Configuration Register
        struct DSI_VCCCR : public RegisterReadOnly<0x40016d40> {
            using NUMC = Field<0, 13>;    // Number of Chunks
        };

        // DSI Host Video Null Packet Current Configuration Register
        struct DSI_VNPCCR : public RegisterReadOnly<0x40016d44> {
            using NPSIZE = Field<0, 13>;    // Null Packet Size
        };

        // DSI Host Video HSA Current Configuration Register
        struct DSI_VHSACCR : public RegisterReadOnly<0x40016d48> {
            using HSA = Field<0, 12>;    // Horizontal Synchronism Active duration
        };

        // DSI Host Video HBP Current Configuration Register
        struct DSI_VHBPCCR : public RegisterReadOnly<0x40016d4c> {
            using HBP = Field<0, 12>;    // Horizontal Back-Porch duration
        };

        // DSI Host Video Line Current Configuration Register
        struct DSI_VLCCR : public RegisterReadOnly<0x40016d50> {
            using HLINE = Field<0, 15>;    // Horizontal Line duration
        };

        // DSI Host Video VSA Current Configuration Register
        struct DSI_VVSACCR : public RegisterReadOnly<0x40016d54> {
            using VSA = Field<0, 10>;    // Vertical Synchronism Active duration
        };

        // DSI Host Video VBP Current Configuration Register
        struct DSI_VVBPCCR : public RegisterReadOnly<0x40016d58> {
            using VBP = Field<0, 10>;    // Vertical Back-Porch duration
        };

        // DSI Host Video VFP Current Configuration Register
        struct DSI_VVFPCCR : public RegisterReadOnly<0x40016d5c> {
            using VFP = Field<0, 10>;    // Vertical Front-Porch duration
        };

        // DSI Host Video VA Current Configuration Register
        struct DSI_VVACCR : public RegisterReadOnly<0x40016d60> {
            using VA = Field<0, 14>;    // Vertical Active duration
        };

        // DSI Wrapper Configuration Register
        struct DSI_WCFGR : public Register<0x40017000> {
            using VSPOL = Field<7, 1>;    // VSync Polarity
            using AR = Field<6, 1>;    // Automatic Refresh
            using TEPOL = Field<5, 1>;    // TE Polarity
            using TESRC = Field<4, 1>;    // TE Source
            using COLMUX = Field<1, 3>;    // Color Multiplexing
            using DSIM = Field<0, 1>;    // DSI Mode
        };

        // DSI Wrapper Control Register
        struct DSI_WCR : public Register<0x40017004> {
            using DSIEN = Field<3, 1>;    // DSI Enable
            using LTDCEN = Field<2, 1>;    // LTDC Enable
            using SHTDN = Field<1, 1>;    // Shutdown
            using COLM = Field<0, 1>;    // Color Mode
        };

        // DSI Wrapper Interrupt Enable Register
        struct DSI_WIER : public Register<0x40017008> {
            using RRIE = Field<13, 1>;    // Regulator Ready Interrupt Enable
            using PLLUIE = Field<10, 1>;    // PLL Unlock Interrupt Enable
            using PLLLIE = Field<9, 1>;    // PLL Lock Interrupt Enable
            using ERIE = Field<1, 1>;    // End of Refresh Interrupt Enable
            using TEIE = Field<0, 1>;    // Tearing Effect Interrupt Enable
        };

        // DSI Wrapper Interrupt & Status Register
        struct DSI_WISR : public RegisterReadOnly<0x4001700c> {
            using RRIF = Field<13, 1>;    // Regulator Ready Interrupt Flag
            using RRS = Field<12, 1>;    // Regulator Ready Status
            using PLLUIF = Field<10, 1>;    // PLL Unlock Interrupt Flag
            using PLLLIF = Field<9, 1>;    // PLL Lock Interrupt Flag
            using PLLLS = Field<8, 1>;    // PLL Lock Status
            using BUSY = Field<2, 1>;    // Busy Flag
            using ERIF = Field<1, 1>;    // End of Refresh Interrupt Flag
            using TEIF = Field<0, 1>;    // Tearing Effect Interrupt Flag
        };

        // DSI Wrapper Interrupt Flag Clear Register
        struct DSI_WIFCR : public Register<0x40017010> {
            using CRRIF = Field<13, 1>;    // Clear Regulator Ready Interrupt Flag
            using CPLLUIF = Field<10, 1>;    // Clear PLL Unlock Interrupt Flag
            using CPLLLIF = Field<9, 1>;    // Clear PLL Lock Interrupt Flag
            using CERIF = Field<1, 1>;    // Clear End of Refresh Interrupt Flag
            using CTEIF = Field<0, 1>;    // Clear Tearing Effect Interrupt Flag
        };

        // DSI Wrapper PHY Configuration Register 1
        struct DSI_WPCR1 : public Register<0x40017018> {
            using TCLKPOSTEN = Field<27, 1>;    // custom time for tCLK-POST Enable
            using TLPXCEN = Field<26, 1>;    // custom time for tLPX for Clock lane Enable
            using THSEXITEN = Field<25, 1>;    // custom time for tHS-EXIT Enable
            using TLPXDEN = Field<24, 1>;    // custom time for tLPX for Data lanes Enable
            using THSZEROEN = Field<23, 1>;    // custom time for tHS-ZERO Enable
            using THSTRAILEN = Field<22, 1>;    // custom time for tHS-TRAIL Enable
            using THSPREPEN = Field<21, 1>;    // custom time for tHS-PREPARE Enable
            using TCLKZEROEN = Field<20, 1>;    // custom time for tCLK-ZERO Enable
            using TCLKPREPEN = Field<19, 1>;    // custom time for tCLK-PREPARE Enable
            using PDEN = Field<18, 1>;    // Pull-Down Enable
            using TDDL = Field<16, 1>;    // Turn Disable Data Lanes
            using CDOFFDL = Field<14, 1>;    // Contention Detection OFF on Data Lanes
            using FTXSMDL = Field<13, 1>;    // Force in TX Stop Mode the Data Lanes
            using FTXSMCL = Field<12, 1>;    // Force in TX Stop Mode the Clock Lane
            using HSIDL1 = Field<11, 1>;    // Invert the High-Speed data signal on Data Lane 1
            using HSIDL0 = Field<10, 1>;    // Invert the Hight-Speed data signal on Data Lane 0
            using HSICL = Field<9, 1>;    // Invert Hight-Speed data signal on Clock Lane
            using SWDL1 = Field<8, 1>;    // Swap Data Lane 1 pins
            using SWDL0 = Field<7, 1>;    // Swap Data Lane 0 pins
            using SWCL = Field<6, 1>;    // Swap Clock Lane pins
            using UIX4 = Field<0, 6>;    // Unit Interval multiplied by 4
        };

        // DSI Wrapper PHY Configuration Register 2
        struct DSI_WPCR2 : public Register<0x4001701c> {
            using LPRXFT = Field<25, 2>;    // Low-Power RX low-pass Filtering Tuning
            using FLPRXLPM = Field<22, 1>;    // Forces LP Receiver in Low-Power Mode
            using HSTXSRCDL = Field<18, 2>;    // High-Speed Transmission Slew Rate Control on Data Lanes
            using HSTXSRCCL = Field<16, 2>;    // High-Speed Transmission Slew Rate Control on Clock Lane
            using SDCC = Field<12, 1>;    // SDD Control
            using LPSRDL = Field<8, 2>;    // Low-Power transmission Slew Rate Compensation on Data Lanes
            using LPSRCL = Field<6, 2>;    // Low-Power transmission Slew Rate Compensation on Clock Lane
            using HSTXDLL = Field<2, 2>;    // High-Speed Transmission Delay on Data Lanes
            using HSTXDCL = Field<0, 2>;    // High-Speed Transmission Delay on Clock Lane
        };

        // DSI Wrapper PHY Configuration Register 3
        struct DSI_WPCR3 : public Register<0x40017020> {
            using THSTRAIL = Field<24, 8>;    // tHSTRAIL
            using THSPREP = Field<16, 8>;    // tHS-PREPARE
            using TCLKZEO = Field<8, 8>;    // tCLK-ZERO
            using TCLKPREP = Field<0, 8>;    // tCLK-PREPARE
        };

        // DSI_WPCR4
        struct DSI_WPCR4 : public Register<0x40017024> {
            using TLPXC = Field<24, 8>;    // tLPXC for Clock lane
            using THSEXIT = Field<16, 8>;    // tHSEXIT
            using TLPXD = Field<8, 8>;    // tLPX for Data lanes
            using THSZERO = Field<0, 8>;    // tHS-ZERO
        };

        // DSI Wrapper PHY Configuration Register 5
        struct DSI_WPCR5 : public Register<0x40017028> {
            using THSZERO = Field<0, 8>;    // tCLK-POST
        };

        // DSI Wrapper Regulator and PLL Control Register
        struct DSI_WRPCR : public Register<0x40017030> {
            using REGEN = Field<24, 1>;    // Regulator Enable
            using ODF = Field<16, 2>;    // PLL Output Division Factor
            using IDF = Field<11, 4>;    // PLL Input Division Factor
            using NDIV = Field<2, 7>;    // PLL Loop Division Factor
            using PLLEN = Field<0, 1>;    // PLL Enable
        };

    };

    // Nested Vectored Interrupt Controller
    struct NVIC {
        // Interrupt Set-Enable Register
        struct ISER0 : public Register<0xe000e100> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Set-Enable Register
        struct ISER1 : public Register<0xe000e104> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Set-Enable Register
        struct ISER2 : public Register<0xe000e108> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Clear-Enable Register
        struct ICER0 : public Register<0xe000e180> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Clear-Enable Register
        struct ICER1 : public Register<0xe000e184> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Clear-Enable Register
        struct ICER2 : public Register<0xe000e188> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Set-Pending Register
        struct ISPR0 : public Register<0xe000e200> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Set-Pending Register
        struct ISPR1 : public Register<0xe000e204> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Set-Pending Register
        struct ISPR2 : public Register<0xe000e208> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR0 : public Register<0xe000e280> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR1 : public Register<0xe000e284> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR2 : public Register<0xe000e288> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Active Bit Register
        struct IABR0 : public RegisterReadOnly<0xe000e300> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Active Bit Register
        struct IABR1 : public RegisterReadOnly<0xe000e304> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Active Bit Register
        struct IABR2 : public RegisterReadOnly<0xe000e308> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Priority Register
        struct IPR0 : public Register<0xe000e400> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR1 : public Register<0xe000e404> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR2 : public Register<0xe000e408> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR3 : public Register<0xe000e40c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR4 : public Register<0xe000e410> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR5 : public Register<0xe000e414> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR6 : public Register<0xe000e418> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR7 : public Register<0xe000e41c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR8 : public Register<0xe000e420> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR9 : public Register<0xe000e424> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR10 : public Register<0xe000e428> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR11 : public Register<0xe000e42c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR12 : public Register<0xe000e430> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR13 : public Register<0xe000e434> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR14 : public Register<0xe000e438> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR15 : public Register<0xe000e43c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR16 : public Register<0xe000e440> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR17 : public Register<0xe000e444> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR18 : public Register<0xe000e448> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR19 : public Register<0xe000e44c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR20 : public Register<0xe000e450> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR21 : public Register<0xe000e454> {
        };

        // Interrupt Priority Register
        struct IPR22 : public Register<0xe000e458> {
        };

        // Interrupt Priority Register
        struct IPR23 : public Register<0xe000e45c> {
        };

        // Interrupt Priority Register
        struct IPR24 : public Register<0xe000e460> {
        };

        // Interrupt Priority Register
        struct IPR25 : public Register<0xe000e464> {
        };

        // Interrupt Priority Register
        struct IPR26 : public Register<0xe000e468> {
        };

        // Interrupt Priority Register
        struct IPR27 : public Register<0xe000e46c> {
        };

        // Interrupt Priority Register
        struct IPR28 : public Register<0xe000e470> {
        };

    };

    // Memory protection unit
    struct MPU {
        // MPU type register
        struct MPU_TYPER : public RegisterReadOnly<0xe000ed90> {
            using SEPARATE = Field<0, 1>;    // Separate flag
            using DREGION = Field<8, 8>;    // Number of MPU data regions
            using IREGION = Field<16, 8>;    // Number of MPU instruction regions
        };

        // MPU control register
        struct MPU_CTRL : public RegisterReadOnly<0xe000ed94> {
            using ENABLE = Field<0, 1>;    // Enables the MPU
            using HFNMIENA = Field<1, 1>;    // Enables the operation of MPU during hard fault
            using PRIVDEFENA = Field<2, 1>;    // Enable priviliged software access to default memory map
        };

        // MPU region number register
        struct MPU_RNR : public Register<0xe000ed98> {
            using REGION = Field<0, 8>;    // MPU region
        };

        // MPU region base address register
        struct MPU_RBAR : public Register<0xe000ed9c> {
            using REGION = Field<0, 4>;    // MPU region field
            using VALID = Field<4, 1>;    // MPU region number valid
            using ADDR = Field<5, 27>;    // Region base address field
        };

        // MPU region attribute and size register
        struct MPU_RASR : public Register<0xe000eda0> {
            using ENABLE = Field<0, 1>;    // Region enable bit.
            using SIZE = Field<1, 5>;    // Size of the MPU protection region
            using SRD = Field<8, 8>;    // Subregion disable bits
            using B = Field<16, 1>;    // memory attribute
            using C = Field<17, 1>;    // memory attribute
            using S = Field<18, 1>;    // Shareable memory attribute
            using TEX = Field<19, 3>;    // memory attribute
            using AP = Field<24, 3>;    // Access permission
            using XN = Field<28, 1>;    // Instruction access disable bit
        };

    };

    // SysTick timer
    struct STK {
        // SysTick control and status register
        struct CSR : public Register<0xe000e010> {
            using ENABLE = Field<0, 1>;    // Counter enable
            using TICKINT = Field<1, 1>;    // SysTick exception request enable
            using CLKSOURCE = Field<2, 1>;    // Clock source selection
            using COUNTFLAG = Field<16, 1>;    // COUNTFLAG
        };

        // SysTick reload value register
        struct RVR : public Register<0xe000e014> {
            using RELOAD = Field<0, 24>;    // RELOAD value
        };

        // SysTick current value register
        struct CVR : public Register<0xe000e018> {
            using CURRENT = Field<0, 24>;    // Current counter value
        };

        // SysTick calibration value register
        struct CALIB : public Register<0xe000e01c> {
            using TENMS = Field<0, 24>;    // Calibration value
            using SKEW = Field<30, 1>;    // SKEW flag: Indicates whether the TENMS value is exact
            using NOREF = Field<31, 1>;    // NOREF flag. Reads as zero
        };

    };

    // Nested vectored interrupt controller
    struct NVIC_STIR {
        // Software trigger interrupt register
        struct STIR : public Register<0xe000ef00> {
            using INTID = Field<0, 9>;    // Software generated interrupt ID
        };

    };

    // Floating point unit CPACR
    struct FPU_CPACR {
        // Coprocessor access control register
        struct CPACR : public Register<0xe000ed88> {
            using CP = Field<20, 4>;    // CP
        };

    };

    // System control block ACTLR
    struct SCB_ACTRL {
        // Auxiliary control register
        struct ACTRL : public Register<0xe000e008> {
            using DISFOLD = Field<2, 1>;    // DISFOLD
            using FPEXCODIS = Field<10, 1>;    // FPEXCODIS
            using DISRAMODE = Field<11, 1>;    // DISRAMODE
            using DISITMATBFLUSH = Field<12, 1>;    // DISITMATBFLUSH
        };

    };

    // Floting point unit
    struct FPU {
        // Floating-point context control register
        struct FPCCR : public Register<0xe000ef34> {
            using LSPACT = Field<0, 1>;    // LSPACT
            using USER = Field<1, 1>;    // USER
            using THREAD = Field<3, 1>;    // THREAD
            using HFRDY = Field<4, 1>;    // HFRDY
            using MMRDY = Field<5, 1>;    // MMRDY
            using BFRDY = Field<6, 1>;    // BFRDY
            using MONRDY = Field<8, 1>;    // MONRDY
            using LSPEN = Field<30, 1>;    // LSPEN
            using ASPEN = Field<31, 1>;    // ASPEN
        };

        // Floating-point context address register
        struct FPCAR : public Register<0xe000ef38> {
            using ADDRESS = Field<3, 29>;    // Location of unpopulated floating-point
        };

        // Floating-point status control register
        struct FPSCR : public Register<0xe000ef3c> {
            using IOC = Field<0, 1>;    // Invalid operation cumulative exception bit
            using DZC = Field<1, 1>;    // Division by zero cumulative exception bit.
            using OFC = Field<2, 1>;    // Overflow cumulative exception bit
            using UFC = Field<3, 1>;    // Underflow cumulative exception bit
            using IXC = Field<4, 1>;    // Inexact cumulative exception bit
            using IDC = Field<7, 1>;    // Input denormal cumulative exception bit.
            using RMode = Field<22, 2>;    // Rounding Mode control field
            using FZ = Field<24, 1>;    // Flush-to-zero mode control bit:
            using DN = Field<25, 1>;    // Default NaN mode control bit
            using AHP = Field<26, 1>;    // Alternative half-precision control bit
            using V = Field<28, 1>;    // Overflow condition code flag
            using C = Field<29, 1>;    // Carry condition code flag
            using Z = Field<30, 1>;    // Zero condition code flag
            using N = Field<31, 1>;    // Negative condition code flag
        };

    };

    // System control block
    struct SCB {
        // CPUID base register
        struct CPUID : public RegisterReadOnly<0xe000ed00> {
            using Revision = Field<0, 4>;    // Revision number
            using PartNo = Field<4, 12>;    // Part number of the processor
            using Constant = Field<16, 4>;    // Reads as 0xF
            using Variant = Field<20, 4>;    // Variant number
            using Implementer = Field<24, 8>;    // Implementer code
        };

        // Interrupt control and state register
        struct ICSR : public Register<0xe000ed04> {
            using VECTACTIVE = Field<0, 9>;    // Active vector
            using RETTOBASE = Field<11, 1>;    // Return to base level
            using VECTPENDING = Field<12, 7>;    // Pending vector
            using ISRPENDING = Field<22, 1>;    // Interrupt pending flag
            using PENDSTCLR = Field<25, 1>;    // SysTick exception clear-pending bit
            using PENDSTSET = Field<26, 1>;    // SysTick exception set-pending bit
            using PENDSVCLR = Field<27, 1>;    // PendSV clear-pending bit
            using PENDSVSET = Field<28, 1>;    // PendSV set-pending bit
            using NMIPENDSET = Field<31, 1>;    // NMI set-pending bit.
        };

        // Vector table offset register
        struct VTOR : public Register<0xe000ed08> {
            using TBLOFF = Field<9, 21>;    // Vector table base offset field
        };

        // Application interrupt and reset control register
        struct AIRCR : public Register<0xe000ed0c> {
            using VECTRESET = Field<0, 1>;    // VECTRESET
            using VECTCLRACTIVE = Field<1, 1>;    // VECTCLRACTIVE
            using SYSRESETREQ = Field<2, 1>;    // SYSRESETREQ
            using PRIGROUP = Field<8, 3>;    // PRIGROUP
            using ENDIANESS = Field<15, 1>;    // ENDIANESS
            using VECTKEYSTAT = Field<16, 16>;    // Register key
        };

        // System control register
        struct SCR : public Register<0xe000ed10> {
            using SLEEPONEXIT = Field<1, 1>;    // SLEEPONEXIT
            using SLEEPDEEP = Field<2, 1>;    // SLEEPDEEP
            using SEVEONPEND = Field<4, 1>;    // Send Event on Pending bit
        };

        // Configuration and control register
        struct CCR : public Register<0xe000ed14> {
            using NONBASETHRDENA = Field<0, 1>;    // Configures how the processor enters Thread mode
            using USERSETMPEND = Field<1, 1>;    // USERSETMPEND
            using UNALIGN__TRP = Field<3, 1>;    // UNALIGN_ TRP
            using DIV_0_TRP = Field<4, 1>;    // DIV_0_TRP
            using BFHFNMIGN = Field<8, 1>;    // BFHFNMIGN
            using STKALIGN = Field<9, 1>;    // STKALIGN
            using DC = Field<16, 1>;    // DC
            using IC = Field<17, 1>;    // IC
            using BP = Field<18, 1>;    // BP
        };

        // System handler priority registers
        struct SHPR1 : public Register<0xe000ed18> {
            using PRI_4 = Field<0, 8>;    // Priority of system handler 4
            using PRI_5 = Field<8, 8>;    // Priority of system handler 5
            using PRI_6 = Field<16, 8>;    // Priority of system handler 6
        };

        // System handler priority registers
        struct SHPR2 : public Register<0xe000ed1c> {
            using PRI_11 = Field<24, 8>;    // Priority of system handler 11
        };

        // System handler priority registers
        struct SHPR3 : public Register<0xe000ed20> {
            using PRI_14 = Field<16, 8>;    // Priority of system handler 14
            using PRI_15 = Field<24, 8>;    // Priority of system handler 15
        };

        // System handler control and state register
        struct SHCRS : public Register<0xe000ed24> {
            using MEMFAULTACT = Field<0, 1>;    // Memory management fault exception active bit
            using BUSFAULTACT = Field<1, 1>;    // Bus fault exception active bit
            using USGFAULTACT = Field<3, 1>;    // Usage fault exception active bit
            using SVCALLACT = Field<7, 1>;    // SVC call active bit
            using MONITORACT = Field<8, 1>;    // Debug monitor active bit
            using PENDSVACT = Field<10, 1>;    // PendSV exception active bit
            using SYSTICKACT = Field<11, 1>;    // SysTick exception active bit
            using USGFAULTPENDED = Field<12, 1>;    // Usage fault exception pending bit
            using MEMFAULTPENDED = Field<13, 1>;    // Memory management fault exception pending bit
            using BUSFAULTPENDED = Field<14, 1>;    // Bus fault exception pending bit
            using SVCALLPENDED = Field<15, 1>;    // SVC call pending bit
            using MEMFAULTENA = Field<16, 1>;    // Memory management fault enable bit
            using BUSFAULTENA = Field<17, 1>;    // Bus fault enable bit
            using USGFAULTENA = Field<18, 1>;    // Usage fault enable bit
        };

        // Configurable fault status register
        struct CFSR_UFSR_BFSR_MMFSR : public Register<0xe000ed28> {
            using IACCVIOL = Field<0, 1>;    // IACCVIOL
            using DACCVIOL = Field<1, 1>;    // DACCVIOL
            using MUNSTKERR = Field<3, 1>;    // MUNSTKERR
            using MSTKERR = Field<4, 1>;    // MSTKERR
            using MLSPERR = Field<5, 1>;    // MLSPERR
            using MMARVALID = Field<7, 1>;    // MMARVALID
            using IBUSERR = Field<8, 1>;    // Instruction bus error
            using PRECISERR = Field<9, 1>;    // Precise data bus error
            using IMPRECISERR = Field<10, 1>;    // Imprecise data bus error
            using UNSTKERR = Field<11, 1>;    // Bus fault on unstacking for a return from exception
            using STKERR = Field<12, 1>;    // Bus fault on stacking for exception entry
            using LSPERR = Field<13, 1>;    // Bus fault on floating-point lazy state preservation
            using BFARVALID = Field<15, 1>;    // Bus Fault Address Register (BFAR) valid flag
            using UNDEFINSTR = Field<16, 1>;    // Undefined instruction usage fault
            using INVSTATE = Field<17, 1>;    // Invalid state usage fault
            using INVPC = Field<18, 1>;    // Invalid PC load usage fault
            using NOCP = Field<19, 1>;    // No coprocessor usage fault.
            using UNALIGNED = Field<24, 1>;    // Unaligned access usage fault
            using DIVBYZERO = Field<25, 1>;    // Divide by zero usage fault
        };

        // Hard fault status register
        struct HFSR : public Register<0xe000ed2c> {
            using VECTTBL = Field<1, 1>;    // Vector table hard fault
            using FORCED = Field<30, 1>;    // Forced hard fault
            using DEBUG_VT = Field<31, 1>;    // Reserved for Debug use
        };

        // Memory management fault address register
        struct MMFAR : public Register<0xe000ed34> {
            using ADDRESS = Field<0, 32>;    // Memory management fault address
        };

        // Bus fault address register
        struct BFAR : public Register<0xe000ed38> {
            using ADDRESS = Field<0, 32>;    // Bus fault address
        };

    };

    // Processor features
    struct PF {
        // Cache Level ID register
        struct CLIDR : public RegisterReadOnly<0xe000ed78> {
            using CL1 = Field<0, 3>;    // CL1
            using CL2 = Field<3, 3>;    // CL2
            using CL3 = Field<6, 3>;    // CL3
            using CL4 = Field<9, 3>;    // CL4
            using CL5 = Field<12, 3>;    // CL5
            using CL6 = Field<15, 3>;    // CL6
            using CL7 = Field<18, 3>;    // CL7
            using LoUIS = Field<21, 3>;    // LoUIS
            using LoC = Field<24, 3>;    // LoC
            using LoU = Field<27, 3>;    // LoU
        };

        // Cache Type register
        struct CTR : public RegisterReadOnly<0xe000ed7c> {
            using _IminLine = Field<0, 4>;    // IminLine
            using DMinLine = Field<16, 4>;    // DMinLine
            using ERG = Field<20, 4>;    // ERG
            using CWG = Field<24, 4>;    // CWG
            using Format = Field<29, 3>;    // Format
        };

        // Cache Size ID register
        struct CCSIDR : public RegisterReadOnly<0xe000ed80> {
            using LineSize = Field<0, 3>;    // LineSize
            using Associativity = Field<3, 10>;    // Associativity
            using NumSets = Field<13, 15>;    // NumSets
            using WA = Field<28, 1>;    // WA
            using RA = Field<29, 1>;    // RA
            using WB = Field<30, 1>;    // WB
            using WT = Field<31, 1>;    // WT
        };

    };

    // Access control
    struct AC {
        // Instruction and Data Tightly-Coupled Memory Control Registers
        struct ITCMCR : public Register<0xe000ef90> {
            using EN = Field<0, 1>;    // EN
            using RMW = Field<1, 1>;    // RMW
            using RETEN = Field<2, 1>;    // RETEN
            using SZ = Field<3, 4>;    // SZ
        };

        // Instruction and Data Tightly-Coupled Memory Control Registers
        struct DTCMCR : public Register<0xe000ef94> {
            using EN = Field<0, 1>;    // EN
            using RMW = Field<1, 1>;    // RMW
            using RETEN = Field<2, 1>;    // RETEN
            using SZ = Field<3, 4>;    // SZ
        };

        // AHBP Control register
        struct AHBPCR : public Register<0xe000ef98> {
            using EN = Field<0, 1>;    // EN
            using SZ = Field<1, 3>;    // SZ
        };

        // Auxiliary Cache Control register
        struct CACR : public Register<0xe000ef9c> {
            using SIWT = Field<0, 1>;    // SIWT
            using ECCEN = Field<1, 1>;    // ECCEN
            using FORCEWT = Field<2, 1>;    // FORCEWT
        };

        // AHB Slave Control register
        struct AHBSCR : public Register<0xe000efa0> {
            using CTL = Field<0, 2>;    // CTL
            using TPRI = Field<2, 9>;    // TPRI
            using INITCOUNT = Field<11, 5>;    // INITCOUNT
        };

        // Auxiliary Bus Fault Status register
        struct ABFSR : public Register<0xe000efa8> {
            using ITCM = Field<0, 1>;    // ITCM
            using DTCM = Field<1, 1>;    // DTCM
            using AHBP = Field<2, 1>;    // AHBP
            using AXIM = Field<3, 1>;    // AXIM
            using EPPB = Field<4, 1>;    // EPPB
            using AXIMTYPE = Field<8, 2>;    // AXIMTYPE
        };

    };

    static std::uint32_t const numInterrupts = 110;

    enum class Interrupts: std::uint32_t {
        WWDG = 0,
        PVD = 1,
        TAMP_STAMP = 2,
        RTC_WKUP = 3,
        FLASH = 4,
        RCC = 5,
        EXTI0 = 6,
        EXTI1 = 7,
        EXTI2 = 8,
        EXTI3 = 9,
        EXTI4 = 10,
        DMA1_Stream0 = 11,
        DMA1_Stream1 = 12,
        DMA1_Stream2 = 13,
        DMA1_Stream3 = 14,
        DMA1_Stream4 = 15,
        DMA1_Stream5 = 16,
        DMA1_Stream6 = 17,
        ADC = 18,
        CAN1_TX = 19,
        CAN1_RX0 = 20,
        CAN1_RX1 = 21,
        CAN1_SCE = 22,
        EXTI9_5 = 23,
        TIM1_BRK_TIM9 = 24,
        TIM1_UP_TIM10 = 25,
        TIM1_TRG_COM_TIM11 = 26,
        TIM1_CC = 27,
        TIM2 = 28,
        TIM3 = 29,
        TIM4 = 30,
        I2C1_EV = 31,
        I2C1_ER = 32,
        I2C2_EV = 33,
        I2C2_ER = 34,
        SPI1 = 35,
        SPI2 = 36,
        USART1 = 37,
        USART2 = 38,
        USART3 = 39,
        EXTI15_10 = 40,
        RTC_ALARM = 41,
        OTG_FS_WKUP = 42,
        TIM8_BRK_TIM12 = 43,
        TIM8_UP_TIM13 = 44,
        TIM8_TRG_COM_TIM14 = 45,
        TIM8_CC = 46,
        DMA1_Stream7 = 47,
        FMC = 48,
        SDMMC1 = 49,
        TIM5 = 50,
        SPI3 = 51,
        UART4 = 52,
        UART5 = 53,
        TIM6_DAC = 54,
        TIM7 = 55,
        DMA2_Stream0 = 56,
        DMA2_Stream1 = 57,
        DMA2_Stream2 = 58,
        DMA2_Stream3 = 59,
        DMA2_Stream4 = 60,
        ETH = 61,
        ETH_WKUP = 62,
        CAN2_TX = 63,
        CAN2_RX0 = 64,
        CAN2_RX1 = 65,
        CAN2_SCE = 66,
        OTG_FS = 67,
        DMA2_Stream5 = 68,
        DMA2_Stream6 = 69,
        DMA2_Stream7 = 70,
        USART6 = 71,
        I2C3_EV = 72,
        I2C3_ER = 73,
        OTG_HS_EP1_OUT = 74,
        OTG_HS_EP1_IN = 75,
        OTG_HS_WKUP = 76,
        OTG_HS = 77,
        DCMI = 78,
        CRYP = 79,
        HASH_RNG = 80,
        FPU = 81,
        UART7 = 82,
        UART8 = 83,
        SPI4 = 84,
        SPI5 = 85,
        SPI6 = 86,
        SAI1 = 87,
        LCD_TFT = 88,
        LCD_TFT = 89,
        DMA2D = 90,
        SAI2 = 91,
        QuadSPI = 92,
        LPTimer1 = 93,
        HDMI_CEC = 94,
        I2C4_EV = 95,
        I2C4_ER = 96,
        SPDIFRX = 97,
        DSIHOST = 98,
        DFSDM1_FLT0 = 99,
        DFSDM1_FLT1 = 100,
        DFSDM1_FLT2 = 101,
        DFSDM1_FLT3 = 102,
        SDMMC2 = 103,
        CAN3_TX = 104,
        CAN3_RX0 = 105,
        CAN3_RX1 = 106,
        CAN3_SCE = 107,
        JPEG = 108,
        MDIOS = 109,
    };

};
