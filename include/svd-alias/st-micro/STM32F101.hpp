// This is a file generated by svd-alias.

#pragma once

#include "svd-alias/bit-field.hpp"
#include "svd-alias/register.hpp"

struct STM32F101 {
    // Flexible static memory controller
    struct FSMC {
        // SRAM/NOR-Flash chip-select control register 1
        struct BCR1 : public Register<0xa0000000> {
            using CBURSTRW = Field<19, 1>;    // CBURSTRW
            using ASYNCWAIT = Field<15, 1>;    // ASYNCWAIT
            using EXTMOD = Field<14, 1>;    // EXTMOD
            using WAITEN = Field<13, 1>;    // WAITEN
            using WREN = Field<12, 1>;    // WREN
            using WAITCFG = Field<11, 1>;    // WAITCFG
            using WAITPOL = Field<9, 1>;    // WAITPOL
            using BURSTEN = Field<8, 1>;    // BURSTEN
            using FACCEN = Field<6, 1>;    // FACCEN
            using MWID = Field<4, 2>;    // MWID
            using MTYP = Field<2, 2>;    // MTYP
            using MUXEN = Field<1, 1>;    // MUXEN
            using MBKEN = Field<0, 1>;    // MBKEN
        };

        // SRAM/NOR-Flash chip-select timing register 1
        struct BTR1 : public Register<0xa0000004> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // SRAM/NOR-Flash chip-select control register 2
        struct BCR2 : public Register<0xa0000008> {
            using CBURSTRW = Field<19, 1>;    // CBURSTRW
            using ASYNCWAIT = Field<15, 1>;    // ASYNCWAIT
            using EXTMOD = Field<14, 1>;    // EXTMOD
            using WAITEN = Field<13, 1>;    // WAITEN
            using WREN = Field<12, 1>;    // WREN
            using WAITCFG = Field<11, 1>;    // WAITCFG
            using WRAPMOD = Field<10, 1>;    // WRAPMOD
            using WAITPOL = Field<9, 1>;    // WAITPOL
            using BURSTEN = Field<8, 1>;    // BURSTEN
            using FACCEN = Field<6, 1>;    // FACCEN
            using MWID = Field<4, 2>;    // MWID
            using MTYP = Field<2, 2>;    // MTYP
            using MUXEN = Field<1, 1>;    // MUXEN
            using MBKEN = Field<0, 1>;    // MBKEN
        };

        // SRAM/NOR-Flash chip-select timing register 2
        struct BTR2 : public Register<0xa000000c> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // SRAM/NOR-Flash chip-select control register 3
        struct BCR3 : public Register<0xa0000010> {
            using CBURSTRW = Field<19, 1>;    // CBURSTRW
            using ASYNCWAIT = Field<15, 1>;    // ASYNCWAIT
            using EXTMOD = Field<14, 1>;    // EXTMOD
            using WAITEN = Field<13, 1>;    // WAITEN
            using WREN = Field<12, 1>;    // WREN
            using WAITCFG = Field<11, 1>;    // WAITCFG
            using WRAPMOD = Field<10, 1>;    // WRAPMOD
            using WAITPOL = Field<9, 1>;    // WAITPOL
            using BURSTEN = Field<8, 1>;    // BURSTEN
            using FACCEN = Field<6, 1>;    // FACCEN
            using MWID = Field<4, 2>;    // MWID
            using MTYP = Field<2, 2>;    // MTYP
            using MUXEN = Field<1, 1>;    // MUXEN
            using MBKEN = Field<0, 1>;    // MBKEN
        };

        // SRAM/NOR-Flash chip-select timing register 3
        struct BTR3 : public Register<0xa0000014> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // SRAM/NOR-Flash chip-select control register 4
        struct BCR4 : public Register<0xa0000018> {
            using CBURSTRW = Field<19, 1>;    // CBURSTRW
            using ASYNCWAIT = Field<15, 1>;    // ASYNCWAIT
            using EXTMOD = Field<14, 1>;    // EXTMOD
            using WAITEN = Field<13, 1>;    // WAITEN
            using WREN = Field<12, 1>;    // WREN
            using WAITCFG = Field<11, 1>;    // WAITCFG
            using WRAPMOD = Field<10, 1>;    // WRAPMOD
            using WAITPOL = Field<9, 1>;    // WAITPOL
            using BURSTEN = Field<8, 1>;    // BURSTEN
            using FACCEN = Field<6, 1>;    // FACCEN
            using MWID = Field<4, 2>;    // MWID
            using MTYP = Field<2, 2>;    // MTYP
            using MUXEN = Field<1, 1>;    // MUXEN
            using MBKEN = Field<0, 1>;    // MBKEN
        };

        // SRAM/NOR-Flash chip-select timing register 4
        struct BTR4 : public Register<0xa000001c> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // PC Card/NAND Flash control register 2
        struct PCR2 : public Register<0xa0000060> {
            using ECCPS = Field<17, 3>;    // ECCPS
            using TAR = Field<13, 4>;    // TAR
            using TCLR = Field<9, 4>;    // TCLR
            using ECCEN = Field<6, 1>;    // ECCEN
            using PWID = Field<4, 2>;    // PWID
            using PTYP = Field<3, 1>;    // PTYP
            using PBKEN = Field<2, 1>;    // PBKEN
            using PWAITEN = Field<1, 1>;    // PWAITEN
        };

        // FIFO status and interrupt register 2
        struct SR2 : public Register<0xa0000064> {
            using FEMPT = Field<6, 1>;    // FEMPT
            using IFEN = Field<5, 1>;    // IFEN
            using ILEN = Field<4, 1>;    // ILEN
            using IREN = Field<3, 1>;    // IREN
            using IFS = Field<2, 1>;    // IFS
            using ILS = Field<1, 1>;    // ILS
            using IRS = Field<0, 1>;    // IRS
        };

        // Common memory space timing register 2
        struct PMEM2 : public Register<0xa0000068> {
            using MEMHIZx = Field<24, 8>;    // MEMHIZx
            using MEMHOLDx = Field<16, 8>;    // MEMHOLDx
            using MEMWAITx = Field<8, 8>;    // MEMWAITx
            using MEMSETx = Field<0, 8>;    // MEMSETx
        };

        // Attribute memory space timing register 2
        struct PATT2 : public Register<0xa000006c> {
            using ATTHIZx = Field<24, 8>;    // Attribute memory x databus HiZ time
            using ATTHOLDx = Field<16, 8>;    // Attribute memory x hold time
            using ATTWAITx = Field<8, 8>;    // Attribute memory x wait time
            using ATTSETx = Field<0, 8>;    // Attribute memory x setup time
        };

        // ECC result register 2
        struct ECCR2 : public RegisterReadOnly<0xa0000074> {
            using ECCx = Field<0, 32>;    // ECC result
        };

        // PC Card/NAND Flash control register 3
        struct PCR3 : public Register<0xa0000080> {
            using ECCPS = Field<17, 3>;    // ECCPS
            using TAR = Field<13, 4>;    // TAR
            using TCLR = Field<9, 4>;    // TCLR
            using ECCEN = Field<6, 1>;    // ECCEN
            using PWID = Field<4, 2>;    // PWID
            using PTYP = Field<3, 1>;    // PTYP
            using PBKEN = Field<2, 1>;    // PBKEN
            using PWAITEN = Field<1, 1>;    // PWAITEN
        };

        // FIFO status and interrupt register 3
        struct SR3 : public Register<0xa0000084> {
            using FEMPT = Field<6, 1>;    // FEMPT
            using IFEN = Field<5, 1>;    // IFEN
            using ILEN = Field<4, 1>;    // ILEN
            using IREN = Field<3, 1>;    // IREN
            using IFS = Field<2, 1>;    // IFS
            using ILS = Field<1, 1>;    // ILS
            using IRS = Field<0, 1>;    // IRS
        };

        // Common memory space timing register 3
        struct PMEM3 : public Register<0xa0000088> {
            using MEMHIZx = Field<24, 8>;    // MEMHIZx
            using MEMHOLDx = Field<16, 8>;    // MEMHOLDx
            using MEMWAITx = Field<8, 8>;    // MEMWAITx
            using MEMSETx = Field<0, 8>;    // MEMSETx
        };

        // Attribute memory space timing register 3
        struct PATT3 : public Register<0xa000008c> {
            using ATTHIZx = Field<24, 8>;    // ATTHIZx
            using ATTHOLDx = Field<16, 8>;    // ATTHOLDx
            using ATTWAITx = Field<8, 8>;    // ATTWAITx
            using ATTSETx = Field<0, 8>;    // ATTSETx
        };

        // ECC result register 3
        struct ECCR3 : public RegisterReadOnly<0xa0000094> {
            using ECCx = Field<0, 32>;    // ECCx
        };

        // PC Card/NAND Flash control register 4
        struct PCR4 : public Register<0xa00000a0> {
            using ECCPS = Field<17, 3>;    // ECCPS
            using TAR = Field<13, 4>;    // TAR
            using TCLR = Field<9, 4>;    // TCLR
            using ECCEN = Field<6, 1>;    // ECCEN
            using PWID = Field<4, 2>;    // PWID
            using PTYP = Field<3, 1>;    // PTYP
            using PBKEN = Field<2, 1>;    // PBKEN
            using PWAITEN = Field<1, 1>;    // PWAITEN
        };

        // FIFO status and interrupt register 4
        struct SR4 : public Register<0xa00000a4> {
            using FEMPT = Field<6, 1>;    // FEMPT
            using IFEN = Field<5, 1>;    // IFEN
            using ILEN = Field<4, 1>;    // ILEN
            using IREN = Field<3, 1>;    // IREN
            using IFS = Field<2, 1>;    // IFS
            using ILS = Field<1, 1>;    // ILS
            using IRS = Field<0, 1>;    // IRS
        };

        // Common memory space timing register 4
        struct PMEM4 : public Register<0xa00000a8> {
            using MEMHIZx = Field<24, 8>;    // MEMHIZx
            using MEMHOLDx = Field<16, 8>;    // MEMHOLDx
            using MEMWAITx = Field<8, 8>;    // MEMWAITx
            using MEMSETx = Field<0, 8>;    // MEMSETx
        };

        // Attribute memory space timing register 4
        struct PATT4 : public Register<0xa00000ac> {
            using ATTHIZx = Field<24, 8>;    // ATTHIZx
            using ATTHOLDx = Field<16, 8>;    // ATTHOLDx
            using ATTWAITx = Field<8, 8>;    // ATTWAITx
            using ATTSETx = Field<0, 8>;    // ATTSETx
        };

        // I/O space timing register 4
        struct PIO4 : public Register<0xa00000b0> {
            using IOHIZx = Field<24, 8>;    // IOHIZx
            using IOHOLDx = Field<16, 8>;    // IOHOLDx
            using IOWAITx = Field<8, 8>;    // IOWAITx
            using IOSETx = Field<0, 8>;    // IOSETx
        };

        // SRAM/NOR-Flash write timing registers 1
        struct BWTR1 : public Register<0xa0000104> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // SRAM/NOR-Flash write timing registers 2
        struct BWTR2 : public Register<0xa000010c> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // SRAM/NOR-Flash write timing registers 3
        struct BWTR3 : public Register<0xa0000114> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // SRAM/NOR-Flash write timing registers 4
        struct BWTR4 : public Register<0xa000011c> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

    };

    // Power control
    struct PWR {
        // Power control register (PWR_CR)
        struct CR : public Register<0x40007000> {
            using LPDS = Field<0, 1>;    // Low Power Deep Sleep
            using PDDS = Field<1, 1>;    // Power Down Deep Sleep
            using CWUF = Field<2, 1>;    // Clear Wake-up Flag
            using CSBF = Field<3, 1>;    // Clear STANDBY Flag
            using PVDE = Field<4, 1>;    // Power Voltage Detector Enable
            using PLS = Field<5, 3>;    // PVD Level Selection
            using DBP = Field<8, 1>;    // Disable Backup Domain write protection
        };

        // Power control register (PWR_CR)
        struct CSR : public Register<0x40007004> {
            using WUF = Field<0, 1>;    // Wake-Up Flag
            using SBF = Field<1, 1>;    // STANDBY Flag
            using PVDO = Field<2, 1>;    // PVD Output
            using EWUP = Field<8, 1>;    // Enable WKUP pin
        };

    };

    // Reset and clock control
    struct RCC {
        // Clock control register
        struct CR : public Register<0x40021000> {
            using HSION = Field<0, 1>;    // Internal High Speed clock enable
            using HSIRDY = Field<1, 1>;    // Internal High Speed clock ready flag
            using HSITRIM = Field<3, 5>;    // Internal High Speed clock trimming
            using HSICAL = Field<8, 8>;    // Internal High Speed clock Calibration
            using HSEON = Field<16, 1>;    // External High Speed clock enable
            using HSERDY = Field<17, 1>;    // External High Speed clock ready flag
            using HSEBYP = Field<18, 1>;    // External High Speed clock Bypass
            using CSSON = Field<19, 1>;    // Clock Security System enable
            using PLLON = Field<24, 1>;    // PLL enable
            using PLLRDY = Field<25, 1>;    // PLL clock ready flag
        };

        // Clock configuration register (RCC_CFGR)
        struct CFGR : public Register<0x40021004> {
            using SW = Field<0, 2>;    // System clock Switch
            using SWS = Field<2, 2>;    // System Clock Switch Status
            using HPRE = Field<4, 4>;    // AHB prescaler
            using PPRE1 = Field<8, 3>;    // APB Low speed prescaler (APB1)
            using PPRE2 = Field<11, 3>;    // APB High speed prescaler (APB2)
            using ADCPRE = Field<14, 2>;    // ADC prescaler
            using PLLSRC = Field<16, 1>;    // PLL entry clock source
            using PLLXTPRE = Field<17, 1>;    // HSE divider for PLL entry
            using PLLMUL = Field<18, 4>;    // PLL Multiplication Factor
            using MCO = Field<24, 3>;    // Microcontroller clock output
        };

        // Clock interrupt register (RCC_CIR)
        struct CIR : public Register<0x40021008> {
            using LSIRDYF = Field<0, 1>;    // LSI Ready Interrupt flag
            using LSERDYF = Field<1, 1>;    // LSE Ready Interrupt flag
            using HSIRDYF = Field<2, 1>;    // HSI Ready Interrupt flag
            using HSERDYF = Field<3, 1>;    // HSE Ready Interrupt flag
            using PLLRDYF = Field<4, 1>;    // PLL Ready Interrupt flag
            using CSSF = Field<7, 1>;    // Clock Security System Interrupt flag
            using LSIRDYIE = Field<8, 1>;    // LSI Ready Interrupt Enable
            using LSERDYIE = Field<9, 1>;    // LSE Ready Interrupt Enable
            using HSIRDYIE = Field<10, 1>;    // HSI Ready Interrupt Enable
            using HSERDYIE = Field<11, 1>;    // HSE Ready Interrupt Enable
            using PLLRDYIE = Field<12, 1>;    // PLL Ready Interrupt Enable
            using LSIRDYC = Field<16, 1>;    // LSI Ready Interrupt Clear
            using LSERDYC = Field<17, 1>;    // LSE Ready Interrupt Clear
            using HSIRDYC = Field<18, 1>;    // HSI Ready Interrupt Clear
            using HSERDYC = Field<19, 1>;    // HSE Ready Interrupt Clear
            using PLLRDYC = Field<20, 1>;    // PLL Ready Interrupt Clear
            using CSSC = Field<23, 1>;    // Clock security system interrupt clear
        };

        // APB2 peripheral reset register (RCC_APB2RSTR)
        struct APB2RSTR : public Register<0x4002100c> {
            using AFIORST = Field<0, 1>;    // Alternate function I/O reset
            using IOPARST = Field<2, 1>;    // IO port A reset
            using IOPBRST = Field<3, 1>;    // IO port B reset
            using IOPCRST = Field<4, 1>;    // IO port C reset
            using IOPDRST = Field<5, 1>;    // IO port D reset
            using IOPERST = Field<6, 1>;    // IO port E reset
            using ADC1RST = Field<9, 1>;    // ADC 1 interface reset
            using ADC2RST = Field<10, 1>;    // ADC 2 interface reset
            using SPI1RST = Field<12, 1>;    // SPI 1 reset
            using USART1RST = Field<14, 1>;    // USART1 reset
            using TIM9RST = Field<19, 1>;    // TIM9 timer reset
            using TIM10RST = Field<20, 1>;    // TIM10 timer reset
            using TIM11RST = Field<21, 1>;    // TIM11 timer reset
            using IOPFRST = Field<7, 1>;    // IO port F reset
            using IOPGRST = Field<8, 1>;    // IO port G reset
        };

        // APB1 peripheral reset register (RCC_APB1RSTR)
        struct APB1RSTR : public Register<0x40021010> {
            using TIM2RST = Field<0, 1>;    // Timer 2 reset
            using TIM3RST = Field<1, 1>;    // Timer 3 reset
            using TIM4RST = Field<2, 1>;    // Timer 4 reset
            using TIM5RST = Field<3, 1>;    // Timer 5 reset
            using TIM6RST = Field<4, 1>;    // Timer 6 reset
            using TIM7RST = Field<5, 1>;    // Timer 7 reset
            using TIM12RST = Field<6, 1>;    // Timer 12 reset
            using TIM13RST = Field<7, 1>;    // Timer 13 reset
            using TIM14RST = Field<8, 1>;    // Timer 14 reset
            using WWDGRST = Field<11, 1>;    // Window watchdog reset
            using SPI2RST = Field<14, 1>;    // SPI2 reset
            using SPI3RST = Field<15, 1>;    // SPI3 reset
            using USART2RST = Field<17, 1>;    // USART 2 reset
            using USART3RST = Field<18, 1>;    // USART 3 reset
            using UART4RST = Field<19, 1>;    // UART 4 reset
            using UART5RST = Field<20, 1>;    // UART 5 reset
            using I2C1RST = Field<21, 1>;    // I2C1 reset
            using I2C2RST = Field<22, 1>;    // I2C2 reset
            using BKPRST = Field<27, 1>;    // Backup interface reset
            using PWRRST = Field<28, 1>;    // Power interface reset
            using DACRST = Field<29, 1>;    // DAC interface reset
        };

        // AHB Peripheral Clock enable register (RCC_AHBENR)
        struct AHBENR : public Register<0x40021014> {
            using DMA1EN = Field<0, 1>;    // DMA1 clock enable
            using DMA2EN = Field<1, 1>;    // DMA2 clock enable
            using SRAMEN = Field<2, 1>;    // SRAM interface clock enable
            using FLITFEN = Field<4, 1>;    // FLITF clock enable
            using CRCEN = Field<6, 1>;    // CRC clock enable
            using FSMCEN = Field<8, 1>;    // FSMC clock enable
        };

        // APB2 peripheral clock enable register (RCC_APB2ENR)
        struct APB2ENR : public Register<0x40021018> {
            using AFIOEN = Field<0, 1>;    // Alternate function I/O clock enable
            using IOPAEN = Field<2, 1>;    // I/O port A clock enable
            using IOPBEN = Field<3, 1>;    // I/O port B clock enable
            using IOPCEN = Field<4, 1>;    // I/O port C clock enable
            using IOPDEN = Field<5, 1>;    // I/O port D clock enable
            using IOPEEN = Field<6, 1>;    // I/O port E clock enable
            using IOPFEN = Field<7, 1>;    // I/O port F clock enable
            using IOPGEN = Field<8, 1>;    // I/O port G clock enable
            using ADC1EN = Field<9, 1>;    // ADC 1 interface clock enable
            using SPI1EN = Field<12, 1>;    // SPI 1 clock enable
            using USART1EN = Field<14, 1>;    // USART1 clock enable
            using TIM9EN = Field<19, 1>;    // TIM9 Timer clock enable
            using TIM10EN = Field<20, 1>;    // TIM10 Timer clock enable
            using TIM11EN = Field<21, 1>;    // TIM11 Timer clock enable
        };

        // APB1 peripheral clock enable register (RCC_APB1ENR)
        struct APB1ENR : public Register<0x4002101c> {
            using TIM2EN = Field<0, 1>;    // Timer 2 clock enable
            using TIM3EN = Field<1, 1>;    // Timer 3 clock enable
            using TIM4EN = Field<2, 1>;    // Timer 4 clock enable
            using TIM5EN = Field<3, 1>;    // Timer 5 clock enable
            using TIM6EN = Field<4, 1>;    // Timer 6 clock enable
            using TIM7EN = Field<5, 1>;    // Timer 7 clock enable
            using TIM12EN = Field<6, 1>;    // Timer 12 clock enable
            using TIM13EN = Field<7, 1>;    // Timer 13 clock enable
            using TIM14EN = Field<8, 1>;    // Timer 14 clock enable
            using WWDGEN = Field<11, 1>;    // Window watchdog clock enable
            using SPI2EN = Field<14, 1>;    // SPI 2 clock enable
            using SPI3EN = Field<15, 1>;    // SPI 3 clock enable
            using USART2EN = Field<17, 1>;    // USART 2 clock enable
            using USART3EN = Field<18, 1>;    // USART 3 clock enable
            using UART4EN = Field<19, 1>;    // UART 4 clock enable
            using UART5EN = Field<20, 1>;    // UART 5 clock enable
            using I2C1EN = Field<21, 1>;    // I2C 1 clock enable
            using I2C2EN = Field<22, 1>;    // I2C 2 clock enable
            using BKPEN = Field<27, 1>;    // Backup interface clock enable
            using PWREN = Field<28, 1>;    // Power interface clock enable
            using DACEN = Field<29, 1>;    // DAC interface clock enable
        };

        // Backup domain control register (RCC_BDCR)
        struct BDCR : public Register<0x40021020> {
            using LSEON = Field<0, 1>;    // External Low Speed oscillator enable
            using LSERDY = Field<1, 1>;    // External Low Speed oscillator ready
            using LSEBYP = Field<2, 1>;    // External Low Speed oscillator bypass
            using RTCSEL = Field<8, 2>;    // RTC clock source selection
            using RTCEN = Field<15, 1>;    // RTC clock enable
            using BDRST = Field<16, 1>;    // Backup domain software reset
        };

        // Control/status register (RCC_CSR)
        struct CSR : public Register<0x40021024> {
            using LSION = Field<0, 1>;    // Internal low speed oscillator enable
            using LSIRDY = Field<1, 1>;    // Internal low speed oscillator ready
            using RMVF = Field<24, 1>;    // Remove reset flag
            using PINRSTF = Field<26, 1>;    // PIN reset flag
            using PORRSTF = Field<27, 1>;    // POR/PDR reset flag
            using SFTRSTF = Field<28, 1>;    // Software reset flag
            using IWDGRSTF = Field<29, 1>;    // Independent watchdog reset flag
            using WWDGRSTF = Field<30, 1>;    // Window watchdog reset flag
            using LPWRRSTF = Field<31, 1>;    // Low-power reset flag
        };

    };

    // General purpose I/O
    struct GPIOA {
        // Port configuration register low (GPIOn_CRL)
        struct CRL : public Register<0x40010800> {
            using MODE0 = Field<0, 2>;    // Port n.0 mode bits
            using CNF0 = Field<2, 2>;    // Port n.0 configuration bits
            using MODE1 = Field<4, 2>;    // Port n.1 mode bits
            using CNF1 = Field<6, 2>;    // Port n.1 configuration bits
            using MODE2 = Field<8, 2>;    // Port n.2 mode bits
            using CNF2 = Field<10, 2>;    // Port n.2 configuration bits
            using MODE3 = Field<12, 2>;    // Port n.3 mode bits
            using CNF3 = Field<14, 2>;    // Port n.3 configuration bits
            using MODE4 = Field<16, 2>;    // Port n.4 mode bits
            using CNF4 = Field<18, 2>;    // Port n.4 configuration bits
            using MODE5 = Field<20, 2>;    // Port n.5 mode bits
            using CNF5 = Field<22, 2>;    // Port n.5 configuration bits
            using MODE6 = Field<24, 2>;    // Port n.6 mode bits
            using CNF6 = Field<26, 2>;    // Port n.6 configuration bits
            using MODE7 = Field<28, 2>;    // Port n.7 mode bits
            using CNF7 = Field<30, 2>;    // Port n.7 configuration bits
        };

        // Port configuration register high (GPIOn_CRL)
        struct CRH : public Register<0x40010804> {
            using MODE8 = Field<0, 2>;    // Port n.8 mode bits
            using CNF8 = Field<2, 2>;    // Port n.8 configuration bits
            using MODE9 = Field<4, 2>;    // Port n.9 mode bits
            using CNF9 = Field<6, 2>;    // Port n.9 configuration bits
            using MODE10 = Field<8, 2>;    // Port n.10 mode bits
            using CNF10 = Field<10, 2>;    // Port n.10 configuration bits
            using MODE11 = Field<12, 2>;    // Port n.11 mode bits
            using CNF11 = Field<14, 2>;    // Port n.11 configuration bits
            using MODE12 = Field<16, 2>;    // Port n.12 mode bits
            using CNF12 = Field<18, 2>;    // Port n.12 configuration bits
            using MODE13 = Field<20, 2>;    // Port n.13 mode bits
            using CNF13 = Field<22, 2>;    // Port n.13 configuration bits
            using MODE14 = Field<24, 2>;    // Port n.14 mode bits
            using CNF14 = Field<26, 2>;    // Port n.14 configuration bits
            using MODE15 = Field<28, 2>;    // Port n.15 mode bits
            using CNF15 = Field<30, 2>;    // Port n.15 configuration bits
        };

        // Port input data register (GPIOn_IDR)
        struct IDR : public RegisterReadOnly<0x40010808> {
            using IDR0 = Field<0, 1>;    // Port input data
            using IDR1 = Field<1, 1>;    // Port input data
            using IDR2 = Field<2, 1>;    // Port input data
            using IDR3 = Field<3, 1>;    // Port input data
            using IDR4 = Field<4, 1>;    // Port input data
            using IDR5 = Field<5, 1>;    // Port input data
            using IDR6 = Field<6, 1>;    // Port input data
            using IDR7 = Field<7, 1>;    // Port input data
            using IDR8 = Field<8, 1>;    // Port input data
            using IDR9 = Field<9, 1>;    // Port input data
            using IDR10 = Field<10, 1>;    // Port input data
            using IDR11 = Field<11, 1>;    // Port input data
            using IDR12 = Field<12, 1>;    // Port input data
            using IDR13 = Field<13, 1>;    // Port input data
            using IDR14 = Field<14, 1>;    // Port input data
            using IDR15 = Field<15, 1>;    // Port input data
        };

        // Port output data register (GPIOn_ODR)
        struct ODR : public Register<0x4001080c> {
            using ODR0 = Field<0, 1>;    // Port output data
            using ODR1 = Field<1, 1>;    // Port output data
            using ODR2 = Field<2, 1>;    // Port output data
            using ODR3 = Field<3, 1>;    // Port output data
            using ODR4 = Field<4, 1>;    // Port output data
            using ODR5 = Field<5, 1>;    // Port output data
            using ODR6 = Field<6, 1>;    // Port output data
            using ODR7 = Field<7, 1>;    // Port output data
            using ODR8 = Field<8, 1>;    // Port output data
            using ODR9 = Field<9, 1>;    // Port output data
            using ODR10 = Field<10, 1>;    // Port output data
            using ODR11 = Field<11, 1>;    // Port output data
            using ODR12 = Field<12, 1>;    // Port output data
            using ODR13 = Field<13, 1>;    // Port output data
            using ODR14 = Field<14, 1>;    // Port output data
            using ODR15 = Field<15, 1>;    // Port output data
        };

        // Port bit set/reset register (GPIOn_BSRR)
        struct BSRR : public RegisterWriteOnly<0x40010810> {
            using BS0 = Field<0, 1>;    // Set bit 0
            using BS1 = Field<1, 1>;    // Set bit 1
            using BS2 = Field<2, 1>;    // Set bit 1
            using BS3 = Field<3, 1>;    // Set bit 3
            using BS4 = Field<4, 1>;    // Set bit 4
            using BS5 = Field<5, 1>;    // Set bit 5
            using BS6 = Field<6, 1>;    // Set bit 6
            using BS7 = Field<7, 1>;    // Set bit 7
            using BS8 = Field<8, 1>;    // Set bit 8
            using BS9 = Field<9, 1>;    // Set bit 9
            using BS10 = Field<10, 1>;    // Set bit 10
            using BS11 = Field<11, 1>;    // Set bit 11
            using BS12 = Field<12, 1>;    // Set bit 12
            using BS13 = Field<13, 1>;    // Set bit 13
            using BS14 = Field<14, 1>;    // Set bit 14
            using BS15 = Field<15, 1>;    // Set bit 15
            using BR0 = Field<16, 1>;    // Reset bit 0
            using BR1 = Field<17, 1>;    // Reset bit 1
            using BR2 = Field<18, 1>;    // Reset bit 2
            using BR3 = Field<19, 1>;    // Reset bit 3
            using BR4 = Field<20, 1>;    // Reset bit 4
            using BR5 = Field<21, 1>;    // Reset bit 5
            using BR6 = Field<22, 1>;    // Reset bit 6
            using BR7 = Field<23, 1>;    // Reset bit 7
            using BR8 = Field<24, 1>;    // Reset bit 8
            using BR9 = Field<25, 1>;    // Reset bit 9
            using BR10 = Field<26, 1>;    // Reset bit 10
            using BR11 = Field<27, 1>;    // Reset bit 11
            using BR12 = Field<28, 1>;    // Reset bit 12
            using BR13 = Field<29, 1>;    // Reset bit 13
            using BR14 = Field<30, 1>;    // Reset bit 14
            using BR15 = Field<31, 1>;    // Reset bit 15
        };

        // Port bit reset register (GPIOn_BRR)
        struct BRR : public RegisterWriteOnly<0x40010814> {
            using BR0 = Field<0, 1>;    // Reset bit 0
            using BR1 = Field<1, 1>;    // Reset bit 1
            using BR2 = Field<2, 1>;    // Reset bit 1
            using BR3 = Field<3, 1>;    // Reset bit 3
            using BR4 = Field<4, 1>;    // Reset bit 4
            using BR5 = Field<5, 1>;    // Reset bit 5
            using BR6 = Field<6, 1>;    // Reset bit 6
            using BR7 = Field<7, 1>;    // Reset bit 7
            using BR8 = Field<8, 1>;    // Reset bit 8
            using BR9 = Field<9, 1>;    // Reset bit 9
            using BR10 = Field<10, 1>;    // Reset bit 10
            using BR11 = Field<11, 1>;    // Reset bit 11
            using BR12 = Field<12, 1>;    // Reset bit 12
            using BR13 = Field<13, 1>;    // Reset bit 13
            using BR14 = Field<14, 1>;    // Reset bit 14
            using BR15 = Field<15, 1>;    // Reset bit 15
        };

        // Port configuration lock register
        struct LCKR : public Register<0x40010818> {
            using LCK0 = Field<0, 1>;    // Port A Lock bit 0
            using LCK1 = Field<1, 1>;    // Port A Lock bit 1
            using LCK2 = Field<2, 1>;    // Port A Lock bit 2
            using LCK3 = Field<3, 1>;    // Port A Lock bit 3
            using LCK4 = Field<4, 1>;    // Port A Lock bit 4
            using LCK5 = Field<5, 1>;    // Port A Lock bit 5
            using LCK6 = Field<6, 1>;    // Port A Lock bit 6
            using LCK7 = Field<7, 1>;    // Port A Lock bit 7
            using LCK8 = Field<8, 1>;    // Port A Lock bit 8
            using LCK9 = Field<9, 1>;    // Port A Lock bit 9
            using LCK10 = Field<10, 1>;    // Port A Lock bit 10
            using LCK11 = Field<11, 1>;    // Port A Lock bit 11
            using LCK12 = Field<12, 1>;    // Port A Lock bit 12
            using LCK13 = Field<13, 1>;    // Port A Lock bit 13
            using LCK14 = Field<14, 1>;    // Port A Lock bit 14
            using LCK15 = Field<15, 1>;    // Port A Lock bit 15
            using LCKK = Field<16, 1>;    // Lock key
        };

    };

    // General purpose I/O
    struct GPIOB {
        // Port configuration register low (GPIOn_CRL)
        struct CRL : public Register<0x40010c00> {
            using MODE0 = Field<0, 2>;    // Port n.0 mode bits
            using CNF0 = Field<2, 2>;    // Port n.0 configuration bits
            using MODE1 = Field<4, 2>;    // Port n.1 mode bits
            using CNF1 = Field<6, 2>;    // Port n.1 configuration bits
            using MODE2 = Field<8, 2>;    // Port n.2 mode bits
            using CNF2 = Field<10, 2>;    // Port n.2 configuration bits
            using MODE3 = Field<12, 2>;    // Port n.3 mode bits
            using CNF3 = Field<14, 2>;    // Port n.3 configuration bits
            using MODE4 = Field<16, 2>;    // Port n.4 mode bits
            using CNF4 = Field<18, 2>;    // Port n.4 configuration bits
            using MODE5 = Field<20, 2>;    // Port n.5 mode bits
            using CNF5 = Field<22, 2>;    // Port n.5 configuration bits
            using MODE6 = Field<24, 2>;    // Port n.6 mode bits
            using CNF6 = Field<26, 2>;    // Port n.6 configuration bits
            using MODE7 = Field<28, 2>;    // Port n.7 mode bits
            using CNF7 = Field<30, 2>;    // Port n.7 configuration bits
        };

        // Port configuration register high (GPIOn_CRL)
        struct CRH : public Register<0x40010c04> {
            using MODE8 = Field<0, 2>;    // Port n.8 mode bits
            using CNF8 = Field<2, 2>;    // Port n.8 configuration bits
            using MODE9 = Field<4, 2>;    // Port n.9 mode bits
            using CNF9 = Field<6, 2>;    // Port n.9 configuration bits
            using MODE10 = Field<8, 2>;    // Port n.10 mode bits
            using CNF10 = Field<10, 2>;    // Port n.10 configuration bits
            using MODE11 = Field<12, 2>;    // Port n.11 mode bits
            using CNF11 = Field<14, 2>;    // Port n.11 configuration bits
            using MODE12 = Field<16, 2>;    // Port n.12 mode bits
            using CNF12 = Field<18, 2>;    // Port n.12 configuration bits
            using MODE13 = Field<20, 2>;    // Port n.13 mode bits
            using CNF13 = Field<22, 2>;    // Port n.13 configuration bits
            using MODE14 = Field<24, 2>;    // Port n.14 mode bits
            using CNF14 = Field<26, 2>;    // Port n.14 configuration bits
            using MODE15 = Field<28, 2>;    // Port n.15 mode bits
            using CNF15 = Field<30, 2>;    // Port n.15 configuration bits
        };

        // Port input data register (GPIOn_IDR)
        struct IDR : public RegisterReadOnly<0x40010c08> {
            using IDR0 = Field<0, 1>;    // Port input data
            using IDR1 = Field<1, 1>;    // Port input data
            using IDR2 = Field<2, 1>;    // Port input data
            using IDR3 = Field<3, 1>;    // Port input data
            using IDR4 = Field<4, 1>;    // Port input data
            using IDR5 = Field<5, 1>;    // Port input data
            using IDR6 = Field<6, 1>;    // Port input data
            using IDR7 = Field<7, 1>;    // Port input data
            using IDR8 = Field<8, 1>;    // Port input data
            using IDR9 = Field<9, 1>;    // Port input data
            using IDR10 = Field<10, 1>;    // Port input data
            using IDR11 = Field<11, 1>;    // Port input data
            using IDR12 = Field<12, 1>;    // Port input data
            using IDR13 = Field<13, 1>;    // Port input data
            using IDR14 = Field<14, 1>;    // Port input data
            using IDR15 = Field<15, 1>;    // Port input data
        };

        // Port output data register (GPIOn_ODR)
        struct ODR : public Register<0x40010c0c> {
            using ODR0 = Field<0, 1>;    // Port output data
            using ODR1 = Field<1, 1>;    // Port output data
            using ODR2 = Field<2, 1>;    // Port output data
            using ODR3 = Field<3, 1>;    // Port output data
            using ODR4 = Field<4, 1>;    // Port output data
            using ODR5 = Field<5, 1>;    // Port output data
            using ODR6 = Field<6, 1>;    // Port output data
            using ODR7 = Field<7, 1>;    // Port output data
            using ODR8 = Field<8, 1>;    // Port output data
            using ODR9 = Field<9, 1>;    // Port output data
            using ODR10 = Field<10, 1>;    // Port output data
            using ODR11 = Field<11, 1>;    // Port output data
            using ODR12 = Field<12, 1>;    // Port output data
            using ODR13 = Field<13, 1>;    // Port output data
            using ODR14 = Field<14, 1>;    // Port output data
            using ODR15 = Field<15, 1>;    // Port output data
        };

        // Port bit set/reset register (GPIOn_BSRR)
        struct BSRR : public RegisterWriteOnly<0x40010c10> {
            using BS0 = Field<0, 1>;    // Set bit 0
            using BS1 = Field<1, 1>;    // Set bit 1
            using BS2 = Field<2, 1>;    // Set bit 1
            using BS3 = Field<3, 1>;    // Set bit 3
            using BS4 = Field<4, 1>;    // Set bit 4
            using BS5 = Field<5, 1>;    // Set bit 5
            using BS6 = Field<6, 1>;    // Set bit 6
            using BS7 = Field<7, 1>;    // Set bit 7
            using BS8 = Field<8, 1>;    // Set bit 8
            using BS9 = Field<9, 1>;    // Set bit 9
            using BS10 = Field<10, 1>;    // Set bit 10
            using BS11 = Field<11, 1>;    // Set bit 11
            using BS12 = Field<12, 1>;    // Set bit 12
            using BS13 = Field<13, 1>;    // Set bit 13
            using BS14 = Field<14, 1>;    // Set bit 14
            using BS15 = Field<15, 1>;    // Set bit 15
            using BR0 = Field<16, 1>;    // Reset bit 0
            using BR1 = Field<17, 1>;    // Reset bit 1
            using BR2 = Field<18, 1>;    // Reset bit 2
            using BR3 = Field<19, 1>;    // Reset bit 3
            using BR4 = Field<20, 1>;    // Reset bit 4
            using BR5 = Field<21, 1>;    // Reset bit 5
            using BR6 = Field<22, 1>;    // Reset bit 6
            using BR7 = Field<23, 1>;    // Reset bit 7
            using BR8 = Field<24, 1>;    // Reset bit 8
            using BR9 = Field<25, 1>;    // Reset bit 9
            using BR10 = Field<26, 1>;    // Reset bit 10
            using BR11 = Field<27, 1>;    // Reset bit 11
            using BR12 = Field<28, 1>;    // Reset bit 12
            using BR13 = Field<29, 1>;    // Reset bit 13
            using BR14 = Field<30, 1>;    // Reset bit 14
            using BR15 = Field<31, 1>;    // Reset bit 15
        };

        // Port bit reset register (GPIOn_BRR)
        struct BRR : public RegisterWriteOnly<0x40010c14> {
            using BR0 = Field<0, 1>;    // Reset bit 0
            using BR1 = Field<1, 1>;    // Reset bit 1
            using BR2 = Field<2, 1>;    // Reset bit 1
            using BR3 = Field<3, 1>;    // Reset bit 3
            using BR4 = Field<4, 1>;    // Reset bit 4
            using BR5 = Field<5, 1>;    // Reset bit 5
            using BR6 = Field<6, 1>;    // Reset bit 6
            using BR7 = Field<7, 1>;    // Reset bit 7
            using BR8 = Field<8, 1>;    // Reset bit 8
            using BR9 = Field<9, 1>;    // Reset bit 9
            using BR10 = Field<10, 1>;    // Reset bit 10
            using BR11 = Field<11, 1>;    // Reset bit 11
            using BR12 = Field<12, 1>;    // Reset bit 12
            using BR13 = Field<13, 1>;    // Reset bit 13
            using BR14 = Field<14, 1>;    // Reset bit 14
            using BR15 = Field<15, 1>;    // Reset bit 15
        };

        // Port configuration lock register
        struct LCKR : public Register<0x40010c18> {
            using LCK0 = Field<0, 1>;    // Port A Lock bit 0
            using LCK1 = Field<1, 1>;    // Port A Lock bit 1
            using LCK2 = Field<2, 1>;    // Port A Lock bit 2
            using LCK3 = Field<3, 1>;    // Port A Lock bit 3
            using LCK4 = Field<4, 1>;    // Port A Lock bit 4
            using LCK5 = Field<5, 1>;    // Port A Lock bit 5
            using LCK6 = Field<6, 1>;    // Port A Lock bit 6
            using LCK7 = Field<7, 1>;    // Port A Lock bit 7
            using LCK8 = Field<8, 1>;    // Port A Lock bit 8
            using LCK9 = Field<9, 1>;    // Port A Lock bit 9
            using LCK10 = Field<10, 1>;    // Port A Lock bit 10
            using LCK11 = Field<11, 1>;    // Port A Lock bit 11
            using LCK12 = Field<12, 1>;    // Port A Lock bit 12
            using LCK13 = Field<13, 1>;    // Port A Lock bit 13
            using LCK14 = Field<14, 1>;    // Port A Lock bit 14
            using LCK15 = Field<15, 1>;    // Port A Lock bit 15
            using LCKK = Field<16, 1>;    // Lock key
        };

    };

    // General purpose I/O
    struct GPIOC {
        // Port configuration register low (GPIOn_CRL)
        struct CRL : public Register<0x40011000> {
            using MODE0 = Field<0, 2>;    // Port n.0 mode bits
            using CNF0 = Field<2, 2>;    // Port n.0 configuration bits
            using MODE1 = Field<4, 2>;    // Port n.1 mode bits
            using CNF1 = Field<6, 2>;    // Port n.1 configuration bits
            using MODE2 = Field<8, 2>;    // Port n.2 mode bits
            using CNF2 = Field<10, 2>;    // Port n.2 configuration bits
            using MODE3 = Field<12, 2>;    // Port n.3 mode bits
            using CNF3 = Field<14, 2>;    // Port n.3 configuration bits
            using MODE4 = Field<16, 2>;    // Port n.4 mode bits
            using CNF4 = Field<18, 2>;    // Port n.4 configuration bits
            using MODE5 = Field<20, 2>;    // Port n.5 mode bits
            using CNF5 = Field<22, 2>;    // Port n.5 configuration bits
            using MODE6 = Field<24, 2>;    // Port n.6 mode bits
            using CNF6 = Field<26, 2>;    // Port n.6 configuration bits
            using MODE7 = Field<28, 2>;    // Port n.7 mode bits
            using CNF7 = Field<30, 2>;    // Port n.7 configuration bits
        };

        // Port configuration register high (GPIOn_CRL)
        struct CRH : public Register<0x40011004> {
            using MODE8 = Field<0, 2>;    // Port n.8 mode bits
            using CNF8 = Field<2, 2>;    // Port n.8 configuration bits
            using MODE9 = Field<4, 2>;    // Port n.9 mode bits
            using CNF9 = Field<6, 2>;    // Port n.9 configuration bits
            using MODE10 = Field<8, 2>;    // Port n.10 mode bits
            using CNF10 = Field<10, 2>;    // Port n.10 configuration bits
            using MODE11 = Field<12, 2>;    // Port n.11 mode bits
            using CNF11 = Field<14, 2>;    // Port n.11 configuration bits
            using MODE12 = Field<16, 2>;    // Port n.12 mode bits
            using CNF12 = Field<18, 2>;    // Port n.12 configuration bits
            using MODE13 = Field<20, 2>;    // Port n.13 mode bits
            using CNF13 = Field<22, 2>;    // Port n.13 configuration bits
            using MODE14 = Field<24, 2>;    // Port n.14 mode bits
            using CNF14 = Field<26, 2>;    // Port n.14 configuration bits
            using MODE15 = Field<28, 2>;    // Port n.15 mode bits
            using CNF15 = Field<30, 2>;    // Port n.15 configuration bits
        };

        // Port input data register (GPIOn_IDR)
        struct IDR : public RegisterReadOnly<0x40011008> {
            using IDR0 = Field<0, 1>;    // Port input data
            using IDR1 = Field<1, 1>;    // Port input data
            using IDR2 = Field<2, 1>;    // Port input data
            using IDR3 = Field<3, 1>;    // Port input data
            using IDR4 = Field<4, 1>;    // Port input data
            using IDR5 = Field<5, 1>;    // Port input data
            using IDR6 = Field<6, 1>;    // Port input data
            using IDR7 = Field<7, 1>;    // Port input data
            using IDR8 = Field<8, 1>;    // Port input data
            using IDR9 = Field<9, 1>;    // Port input data
            using IDR10 = Field<10, 1>;    // Port input data
            using IDR11 = Field<11, 1>;    // Port input data
            using IDR12 = Field<12, 1>;    // Port input data
            using IDR13 = Field<13, 1>;    // Port input data
            using IDR14 = Field<14, 1>;    // Port input data
            using IDR15 = Field<15, 1>;    // Port input data
        };

        // Port output data register (GPIOn_ODR)
        struct ODR : public Register<0x4001100c> {
            using ODR0 = Field<0, 1>;    // Port output data
            using ODR1 = Field<1, 1>;    // Port output data
            using ODR2 = Field<2, 1>;    // Port output data
            using ODR3 = Field<3, 1>;    // Port output data
            using ODR4 = Field<4, 1>;    // Port output data
            using ODR5 = Field<5, 1>;    // Port output data
            using ODR6 = Field<6, 1>;    // Port output data
            using ODR7 = Field<7, 1>;    // Port output data
            using ODR8 = Field<8, 1>;    // Port output data
            using ODR9 = Field<9, 1>;    // Port output data
            using ODR10 = Field<10, 1>;    // Port output data
            using ODR11 = Field<11, 1>;    // Port output data
            using ODR12 = Field<12, 1>;    // Port output data
            using ODR13 = Field<13, 1>;    // Port output data
            using ODR14 = Field<14, 1>;    // Port output data
            using ODR15 = Field<15, 1>;    // Port output data
        };

        // Port bit set/reset register (GPIOn_BSRR)
        struct BSRR : public RegisterWriteOnly<0x40011010> {
            using BS0 = Field<0, 1>;    // Set bit 0
            using BS1 = Field<1, 1>;    // Set bit 1
            using BS2 = Field<2, 1>;    // Set bit 1
            using BS3 = Field<3, 1>;    // Set bit 3
            using BS4 = Field<4, 1>;    // Set bit 4
            using BS5 = Field<5, 1>;    // Set bit 5
            using BS6 = Field<6, 1>;    // Set bit 6
            using BS7 = Field<7, 1>;    // Set bit 7
            using BS8 = Field<8, 1>;    // Set bit 8
            using BS9 = Field<9, 1>;    // Set bit 9
            using BS10 = Field<10, 1>;    // Set bit 10
            using BS11 = Field<11, 1>;    // Set bit 11
            using BS12 = Field<12, 1>;    // Set bit 12
            using BS13 = Field<13, 1>;    // Set bit 13
            using BS14 = Field<14, 1>;    // Set bit 14
            using BS15 = Field<15, 1>;    // Set bit 15
            using BR0 = Field<16, 1>;    // Reset bit 0
            using BR1 = Field<17, 1>;    // Reset bit 1
            using BR2 = Field<18, 1>;    // Reset bit 2
            using BR3 = Field<19, 1>;    // Reset bit 3
            using BR4 = Field<20, 1>;    // Reset bit 4
            using BR5 = Field<21, 1>;    // Reset bit 5
            using BR6 = Field<22, 1>;    // Reset bit 6
            using BR7 = Field<23, 1>;    // Reset bit 7
            using BR8 = Field<24, 1>;    // Reset bit 8
            using BR9 = Field<25, 1>;    // Reset bit 9
            using BR10 = Field<26, 1>;    // Reset bit 10
            using BR11 = Field<27, 1>;    // Reset bit 11
            using BR12 = Field<28, 1>;    // Reset bit 12
            using BR13 = Field<29, 1>;    // Reset bit 13
            using BR14 = Field<30, 1>;    // Reset bit 14
            using BR15 = Field<31, 1>;    // Reset bit 15
        };

        // Port bit reset register (GPIOn_BRR)
        struct BRR : public RegisterWriteOnly<0x40011014> {
            using BR0 = Field<0, 1>;    // Reset bit 0
            using BR1 = Field<1, 1>;    // Reset bit 1
            using BR2 = Field<2, 1>;    // Reset bit 1
            using BR3 = Field<3, 1>;    // Reset bit 3
            using BR4 = Field<4, 1>;    // Reset bit 4
            using BR5 = Field<5, 1>;    // Reset bit 5
            using BR6 = Field<6, 1>;    // Reset bit 6
            using BR7 = Field<7, 1>;    // Reset bit 7
            using BR8 = Field<8, 1>;    // Reset bit 8
            using BR9 = Field<9, 1>;    // Reset bit 9
            using BR10 = Field<10, 1>;    // Reset bit 10
            using BR11 = Field<11, 1>;    // Reset bit 11
            using BR12 = Field<12, 1>;    // Reset bit 12
            using BR13 = Field<13, 1>;    // Reset bit 13
            using BR14 = Field<14, 1>;    // Reset bit 14
            using BR15 = Field<15, 1>;    // Reset bit 15
        };

        // Port configuration lock register
        struct LCKR : public Register<0x40011018> {
            using LCK0 = Field<0, 1>;    // Port A Lock bit 0
            using LCK1 = Field<1, 1>;    // Port A Lock bit 1
            using LCK2 = Field<2, 1>;    // Port A Lock bit 2
            using LCK3 = Field<3, 1>;    // Port A Lock bit 3
            using LCK4 = Field<4, 1>;    // Port A Lock bit 4
            using LCK5 = Field<5, 1>;    // Port A Lock bit 5
            using LCK6 = Field<6, 1>;    // Port A Lock bit 6
            using LCK7 = Field<7, 1>;    // Port A Lock bit 7
            using LCK8 = Field<8, 1>;    // Port A Lock bit 8
            using LCK9 = Field<9, 1>;    // Port A Lock bit 9
            using LCK10 = Field<10, 1>;    // Port A Lock bit 10
            using LCK11 = Field<11, 1>;    // Port A Lock bit 11
            using LCK12 = Field<12, 1>;    // Port A Lock bit 12
            using LCK13 = Field<13, 1>;    // Port A Lock bit 13
            using LCK14 = Field<14, 1>;    // Port A Lock bit 14
            using LCK15 = Field<15, 1>;    // Port A Lock bit 15
            using LCKK = Field<16, 1>;    // Lock key
        };

    };

    // General purpose I/O
    struct GPIOD {
        // Port configuration register low (GPIOn_CRL)
        struct CRL : public Register<0x40011400> {
            using MODE0 = Field<0, 2>;    // Port n.0 mode bits
            using CNF0 = Field<2, 2>;    // Port n.0 configuration bits
            using MODE1 = Field<4, 2>;    // Port n.1 mode bits
            using CNF1 = Field<6, 2>;    // Port n.1 configuration bits
            using MODE2 = Field<8, 2>;    // Port n.2 mode bits
            using CNF2 = Field<10, 2>;    // Port n.2 configuration bits
            using MODE3 = Field<12, 2>;    // Port n.3 mode bits
            using CNF3 = Field<14, 2>;    // Port n.3 configuration bits
            using MODE4 = Field<16, 2>;    // Port n.4 mode bits
            using CNF4 = Field<18, 2>;    // Port n.4 configuration bits
            using MODE5 = Field<20, 2>;    // Port n.5 mode bits
            using CNF5 = Field<22, 2>;    // Port n.5 configuration bits
            using MODE6 = Field<24, 2>;    // Port n.6 mode bits
            using CNF6 = Field<26, 2>;    // Port n.6 configuration bits
            using MODE7 = Field<28, 2>;    // Port n.7 mode bits
            using CNF7 = Field<30, 2>;    // Port n.7 configuration bits
        };

        // Port configuration register high (GPIOn_CRL)
        struct CRH : public Register<0x40011404> {
            using MODE8 = Field<0, 2>;    // Port n.8 mode bits
            using CNF8 = Field<2, 2>;    // Port n.8 configuration bits
            using MODE9 = Field<4, 2>;    // Port n.9 mode bits
            using CNF9 = Field<6, 2>;    // Port n.9 configuration bits
            using MODE10 = Field<8, 2>;    // Port n.10 mode bits
            using CNF10 = Field<10, 2>;    // Port n.10 configuration bits
            using MODE11 = Field<12, 2>;    // Port n.11 mode bits
            using CNF11 = Field<14, 2>;    // Port n.11 configuration bits
            using MODE12 = Field<16, 2>;    // Port n.12 mode bits
            using CNF12 = Field<18, 2>;    // Port n.12 configuration bits
            using MODE13 = Field<20, 2>;    // Port n.13 mode bits
            using CNF13 = Field<22, 2>;    // Port n.13 configuration bits
            using MODE14 = Field<24, 2>;    // Port n.14 mode bits
            using CNF14 = Field<26, 2>;    // Port n.14 configuration bits
            using MODE15 = Field<28, 2>;    // Port n.15 mode bits
            using CNF15 = Field<30, 2>;    // Port n.15 configuration bits
        };

        // Port input data register (GPIOn_IDR)
        struct IDR : public RegisterReadOnly<0x40011408> {
            using IDR0 = Field<0, 1>;    // Port input data
            using IDR1 = Field<1, 1>;    // Port input data
            using IDR2 = Field<2, 1>;    // Port input data
            using IDR3 = Field<3, 1>;    // Port input data
            using IDR4 = Field<4, 1>;    // Port input data
            using IDR5 = Field<5, 1>;    // Port input data
            using IDR6 = Field<6, 1>;    // Port input data
            using IDR7 = Field<7, 1>;    // Port input data
            using IDR8 = Field<8, 1>;    // Port input data
            using IDR9 = Field<9, 1>;    // Port input data
            using IDR10 = Field<10, 1>;    // Port input data
            using IDR11 = Field<11, 1>;    // Port input data
            using IDR12 = Field<12, 1>;    // Port input data
            using IDR13 = Field<13, 1>;    // Port input data
            using IDR14 = Field<14, 1>;    // Port input data
            using IDR15 = Field<15, 1>;    // Port input data
        };

        // Port output data register (GPIOn_ODR)
        struct ODR : public Register<0x4001140c> {
            using ODR0 = Field<0, 1>;    // Port output data
            using ODR1 = Field<1, 1>;    // Port output data
            using ODR2 = Field<2, 1>;    // Port output data
            using ODR3 = Field<3, 1>;    // Port output data
            using ODR4 = Field<4, 1>;    // Port output data
            using ODR5 = Field<5, 1>;    // Port output data
            using ODR6 = Field<6, 1>;    // Port output data
            using ODR7 = Field<7, 1>;    // Port output data
            using ODR8 = Field<8, 1>;    // Port output data
            using ODR9 = Field<9, 1>;    // Port output data
            using ODR10 = Field<10, 1>;    // Port output data
            using ODR11 = Field<11, 1>;    // Port output data
            using ODR12 = Field<12, 1>;    // Port output data
            using ODR13 = Field<13, 1>;    // Port output data
            using ODR14 = Field<14, 1>;    // Port output data
            using ODR15 = Field<15, 1>;    // Port output data
        };

        // Port bit set/reset register (GPIOn_BSRR)
        struct BSRR : public RegisterWriteOnly<0x40011410> {
            using BS0 = Field<0, 1>;    // Set bit 0
            using BS1 = Field<1, 1>;    // Set bit 1
            using BS2 = Field<2, 1>;    // Set bit 1
            using BS3 = Field<3, 1>;    // Set bit 3
            using BS4 = Field<4, 1>;    // Set bit 4
            using BS5 = Field<5, 1>;    // Set bit 5
            using BS6 = Field<6, 1>;    // Set bit 6
            using BS7 = Field<7, 1>;    // Set bit 7
            using BS8 = Field<8, 1>;    // Set bit 8
            using BS9 = Field<9, 1>;    // Set bit 9
            using BS10 = Field<10, 1>;    // Set bit 10
            using BS11 = Field<11, 1>;    // Set bit 11
            using BS12 = Field<12, 1>;    // Set bit 12
            using BS13 = Field<13, 1>;    // Set bit 13
            using BS14 = Field<14, 1>;    // Set bit 14
            using BS15 = Field<15, 1>;    // Set bit 15
            using BR0 = Field<16, 1>;    // Reset bit 0
            using BR1 = Field<17, 1>;    // Reset bit 1
            using BR2 = Field<18, 1>;    // Reset bit 2
            using BR3 = Field<19, 1>;    // Reset bit 3
            using BR4 = Field<20, 1>;    // Reset bit 4
            using BR5 = Field<21, 1>;    // Reset bit 5
            using BR6 = Field<22, 1>;    // Reset bit 6
            using BR7 = Field<23, 1>;    // Reset bit 7
            using BR8 = Field<24, 1>;    // Reset bit 8
            using BR9 = Field<25, 1>;    // Reset bit 9
            using BR10 = Field<26, 1>;    // Reset bit 10
            using BR11 = Field<27, 1>;    // Reset bit 11
            using BR12 = Field<28, 1>;    // Reset bit 12
            using BR13 = Field<29, 1>;    // Reset bit 13
            using BR14 = Field<30, 1>;    // Reset bit 14
            using BR15 = Field<31, 1>;    // Reset bit 15
        };

        // Port bit reset register (GPIOn_BRR)
        struct BRR : public RegisterWriteOnly<0x40011414> {
            using BR0 = Field<0, 1>;    // Reset bit 0
            using BR1 = Field<1, 1>;    // Reset bit 1
            using BR2 = Field<2, 1>;    // Reset bit 1
            using BR3 = Field<3, 1>;    // Reset bit 3
            using BR4 = Field<4, 1>;    // Reset bit 4
            using BR5 = Field<5, 1>;    // Reset bit 5
            using BR6 = Field<6, 1>;    // Reset bit 6
            using BR7 = Field<7, 1>;    // Reset bit 7
            using BR8 = Field<8, 1>;    // Reset bit 8
            using BR9 = Field<9, 1>;    // Reset bit 9
            using BR10 = Field<10, 1>;    // Reset bit 10
            using BR11 = Field<11, 1>;    // Reset bit 11
            using BR12 = Field<12, 1>;    // Reset bit 12
            using BR13 = Field<13, 1>;    // Reset bit 13
            using BR14 = Field<14, 1>;    // Reset bit 14
            using BR15 = Field<15, 1>;    // Reset bit 15
        };

        // Port configuration lock register
        struct LCKR : public Register<0x40011418> {
            using LCK0 = Field<0, 1>;    // Port A Lock bit 0
            using LCK1 = Field<1, 1>;    // Port A Lock bit 1
            using LCK2 = Field<2, 1>;    // Port A Lock bit 2
            using LCK3 = Field<3, 1>;    // Port A Lock bit 3
            using LCK4 = Field<4, 1>;    // Port A Lock bit 4
            using LCK5 = Field<5, 1>;    // Port A Lock bit 5
            using LCK6 = Field<6, 1>;    // Port A Lock bit 6
            using LCK7 = Field<7, 1>;    // Port A Lock bit 7
            using LCK8 = Field<8, 1>;    // Port A Lock bit 8
            using LCK9 = Field<9, 1>;    // Port A Lock bit 9
            using LCK10 = Field<10, 1>;    // Port A Lock bit 10
            using LCK11 = Field<11, 1>;    // Port A Lock bit 11
            using LCK12 = Field<12, 1>;    // Port A Lock bit 12
            using LCK13 = Field<13, 1>;    // Port A Lock bit 13
            using LCK14 = Field<14, 1>;    // Port A Lock bit 14
            using LCK15 = Field<15, 1>;    // Port A Lock bit 15
            using LCKK = Field<16, 1>;    // Lock key
        };

    };

    // General purpose I/O
    struct GPIOE {
        // Port configuration register low (GPIOn_CRL)
        struct CRL : public Register<0x40011800> {
            using MODE0 = Field<0, 2>;    // Port n.0 mode bits
            using CNF0 = Field<2, 2>;    // Port n.0 configuration bits
            using MODE1 = Field<4, 2>;    // Port n.1 mode bits
            using CNF1 = Field<6, 2>;    // Port n.1 configuration bits
            using MODE2 = Field<8, 2>;    // Port n.2 mode bits
            using CNF2 = Field<10, 2>;    // Port n.2 configuration bits
            using MODE3 = Field<12, 2>;    // Port n.3 mode bits
            using CNF3 = Field<14, 2>;    // Port n.3 configuration bits
            using MODE4 = Field<16, 2>;    // Port n.4 mode bits
            using CNF4 = Field<18, 2>;    // Port n.4 configuration bits
            using MODE5 = Field<20, 2>;    // Port n.5 mode bits
            using CNF5 = Field<22, 2>;    // Port n.5 configuration bits
            using MODE6 = Field<24, 2>;    // Port n.6 mode bits
            using CNF6 = Field<26, 2>;    // Port n.6 configuration bits
            using MODE7 = Field<28, 2>;    // Port n.7 mode bits
            using CNF7 = Field<30, 2>;    // Port n.7 configuration bits
        };

        // Port configuration register high (GPIOn_CRL)
        struct CRH : public Register<0x40011804> {
            using MODE8 = Field<0, 2>;    // Port n.8 mode bits
            using CNF8 = Field<2, 2>;    // Port n.8 configuration bits
            using MODE9 = Field<4, 2>;    // Port n.9 mode bits
            using CNF9 = Field<6, 2>;    // Port n.9 configuration bits
            using MODE10 = Field<8, 2>;    // Port n.10 mode bits
            using CNF10 = Field<10, 2>;    // Port n.10 configuration bits
            using MODE11 = Field<12, 2>;    // Port n.11 mode bits
            using CNF11 = Field<14, 2>;    // Port n.11 configuration bits
            using MODE12 = Field<16, 2>;    // Port n.12 mode bits
            using CNF12 = Field<18, 2>;    // Port n.12 configuration bits
            using MODE13 = Field<20, 2>;    // Port n.13 mode bits
            using CNF13 = Field<22, 2>;    // Port n.13 configuration bits
            using MODE14 = Field<24, 2>;    // Port n.14 mode bits
            using CNF14 = Field<26, 2>;    // Port n.14 configuration bits
            using MODE15 = Field<28, 2>;    // Port n.15 mode bits
            using CNF15 = Field<30, 2>;    // Port n.15 configuration bits
        };

        // Port input data register (GPIOn_IDR)
        struct IDR : public RegisterReadOnly<0x40011808> {
            using IDR0 = Field<0, 1>;    // Port input data
            using IDR1 = Field<1, 1>;    // Port input data
            using IDR2 = Field<2, 1>;    // Port input data
            using IDR3 = Field<3, 1>;    // Port input data
            using IDR4 = Field<4, 1>;    // Port input data
            using IDR5 = Field<5, 1>;    // Port input data
            using IDR6 = Field<6, 1>;    // Port input data
            using IDR7 = Field<7, 1>;    // Port input data
            using IDR8 = Field<8, 1>;    // Port input data
            using IDR9 = Field<9, 1>;    // Port input data
            using IDR10 = Field<10, 1>;    // Port input data
            using IDR11 = Field<11, 1>;    // Port input data
            using IDR12 = Field<12, 1>;    // Port input data
            using IDR13 = Field<13, 1>;    // Port input data
            using IDR14 = Field<14, 1>;    // Port input data
            using IDR15 = Field<15, 1>;    // Port input data
        };

        // Port output data register (GPIOn_ODR)
        struct ODR : public Register<0x4001180c> {
            using ODR0 = Field<0, 1>;    // Port output data
            using ODR1 = Field<1, 1>;    // Port output data
            using ODR2 = Field<2, 1>;    // Port output data
            using ODR3 = Field<3, 1>;    // Port output data
            using ODR4 = Field<4, 1>;    // Port output data
            using ODR5 = Field<5, 1>;    // Port output data
            using ODR6 = Field<6, 1>;    // Port output data
            using ODR7 = Field<7, 1>;    // Port output data
            using ODR8 = Field<8, 1>;    // Port output data
            using ODR9 = Field<9, 1>;    // Port output data
            using ODR10 = Field<10, 1>;    // Port output data
            using ODR11 = Field<11, 1>;    // Port output data
            using ODR12 = Field<12, 1>;    // Port output data
            using ODR13 = Field<13, 1>;    // Port output data
            using ODR14 = Field<14, 1>;    // Port output data
            using ODR15 = Field<15, 1>;    // Port output data
        };

        // Port bit set/reset register (GPIOn_BSRR)
        struct BSRR : public RegisterWriteOnly<0x40011810> {
            using BS0 = Field<0, 1>;    // Set bit 0
            using BS1 = Field<1, 1>;    // Set bit 1
            using BS2 = Field<2, 1>;    // Set bit 1
            using BS3 = Field<3, 1>;    // Set bit 3
            using BS4 = Field<4, 1>;    // Set bit 4
            using BS5 = Field<5, 1>;    // Set bit 5
            using BS6 = Field<6, 1>;    // Set bit 6
            using BS7 = Field<7, 1>;    // Set bit 7
            using BS8 = Field<8, 1>;    // Set bit 8
            using BS9 = Field<9, 1>;    // Set bit 9
            using BS10 = Field<10, 1>;    // Set bit 10
            using BS11 = Field<11, 1>;    // Set bit 11
            using BS12 = Field<12, 1>;    // Set bit 12
            using BS13 = Field<13, 1>;    // Set bit 13
            using BS14 = Field<14, 1>;    // Set bit 14
            using BS15 = Field<15, 1>;    // Set bit 15
            using BR0 = Field<16, 1>;    // Reset bit 0
            using BR1 = Field<17, 1>;    // Reset bit 1
            using BR2 = Field<18, 1>;    // Reset bit 2
            using BR3 = Field<19, 1>;    // Reset bit 3
            using BR4 = Field<20, 1>;    // Reset bit 4
            using BR5 = Field<21, 1>;    // Reset bit 5
            using BR6 = Field<22, 1>;    // Reset bit 6
            using BR7 = Field<23, 1>;    // Reset bit 7
            using BR8 = Field<24, 1>;    // Reset bit 8
            using BR9 = Field<25, 1>;    // Reset bit 9
            using BR10 = Field<26, 1>;    // Reset bit 10
            using BR11 = Field<27, 1>;    // Reset bit 11
            using BR12 = Field<28, 1>;    // Reset bit 12
            using BR13 = Field<29, 1>;    // Reset bit 13
            using BR14 = Field<30, 1>;    // Reset bit 14
            using BR15 = Field<31, 1>;    // Reset bit 15
        };

        // Port bit reset register (GPIOn_BRR)
        struct BRR : public RegisterWriteOnly<0x40011814> {
            using BR0 = Field<0, 1>;    // Reset bit 0
            using BR1 = Field<1, 1>;    // Reset bit 1
            using BR2 = Field<2, 1>;    // Reset bit 1
            using BR3 = Field<3, 1>;    // Reset bit 3
            using BR4 = Field<4, 1>;    // Reset bit 4
            using BR5 = Field<5, 1>;    // Reset bit 5
            using BR6 = Field<6, 1>;    // Reset bit 6
            using BR7 = Field<7, 1>;    // Reset bit 7
            using BR8 = Field<8, 1>;    // Reset bit 8
            using BR9 = Field<9, 1>;    // Reset bit 9
            using BR10 = Field<10, 1>;    // Reset bit 10
            using BR11 = Field<11, 1>;    // Reset bit 11
            using BR12 = Field<12, 1>;    // Reset bit 12
            using BR13 = Field<13, 1>;    // Reset bit 13
            using BR14 = Field<14, 1>;    // Reset bit 14
            using BR15 = Field<15, 1>;    // Reset bit 15
        };

        // Port configuration lock register
        struct LCKR : public Register<0x40011818> {
            using LCK0 = Field<0, 1>;    // Port A Lock bit 0
            using LCK1 = Field<1, 1>;    // Port A Lock bit 1
            using LCK2 = Field<2, 1>;    // Port A Lock bit 2
            using LCK3 = Field<3, 1>;    // Port A Lock bit 3
            using LCK4 = Field<4, 1>;    // Port A Lock bit 4
            using LCK5 = Field<5, 1>;    // Port A Lock bit 5
            using LCK6 = Field<6, 1>;    // Port A Lock bit 6
            using LCK7 = Field<7, 1>;    // Port A Lock bit 7
            using LCK8 = Field<8, 1>;    // Port A Lock bit 8
            using LCK9 = Field<9, 1>;    // Port A Lock bit 9
            using LCK10 = Field<10, 1>;    // Port A Lock bit 10
            using LCK11 = Field<11, 1>;    // Port A Lock bit 11
            using LCK12 = Field<12, 1>;    // Port A Lock bit 12
            using LCK13 = Field<13, 1>;    // Port A Lock bit 13
            using LCK14 = Field<14, 1>;    // Port A Lock bit 14
            using LCK15 = Field<15, 1>;    // Port A Lock bit 15
            using LCKK = Field<16, 1>;    // Lock key
        };

    };

    // General purpose I/O
    struct GPIOF {
        // Port configuration register low (GPIOn_CRL)
        struct CRL : public Register<0x40011c00> {
            using MODE0 = Field<0, 2>;    // Port n.0 mode bits
            using CNF0 = Field<2, 2>;    // Port n.0 configuration bits
            using MODE1 = Field<4, 2>;    // Port n.1 mode bits
            using CNF1 = Field<6, 2>;    // Port n.1 configuration bits
            using MODE2 = Field<8, 2>;    // Port n.2 mode bits
            using CNF2 = Field<10, 2>;    // Port n.2 configuration bits
            using MODE3 = Field<12, 2>;    // Port n.3 mode bits
            using CNF3 = Field<14, 2>;    // Port n.3 configuration bits
            using MODE4 = Field<16, 2>;    // Port n.4 mode bits
            using CNF4 = Field<18, 2>;    // Port n.4 configuration bits
            using MODE5 = Field<20, 2>;    // Port n.5 mode bits
            using CNF5 = Field<22, 2>;    // Port n.5 configuration bits
            using MODE6 = Field<24, 2>;    // Port n.6 mode bits
            using CNF6 = Field<26, 2>;    // Port n.6 configuration bits
            using MODE7 = Field<28, 2>;    // Port n.7 mode bits
            using CNF7 = Field<30, 2>;    // Port n.7 configuration bits
        };

        // Port configuration register high (GPIOn_CRL)
        struct CRH : public Register<0x40011c04> {
            using MODE8 = Field<0, 2>;    // Port n.8 mode bits
            using CNF8 = Field<2, 2>;    // Port n.8 configuration bits
            using MODE9 = Field<4, 2>;    // Port n.9 mode bits
            using CNF9 = Field<6, 2>;    // Port n.9 configuration bits
            using MODE10 = Field<8, 2>;    // Port n.10 mode bits
            using CNF10 = Field<10, 2>;    // Port n.10 configuration bits
            using MODE11 = Field<12, 2>;    // Port n.11 mode bits
            using CNF11 = Field<14, 2>;    // Port n.11 configuration bits
            using MODE12 = Field<16, 2>;    // Port n.12 mode bits
            using CNF12 = Field<18, 2>;    // Port n.12 configuration bits
            using MODE13 = Field<20, 2>;    // Port n.13 mode bits
            using CNF13 = Field<22, 2>;    // Port n.13 configuration bits
            using MODE14 = Field<24, 2>;    // Port n.14 mode bits
            using CNF14 = Field<26, 2>;    // Port n.14 configuration bits
            using MODE15 = Field<28, 2>;    // Port n.15 mode bits
            using CNF15 = Field<30, 2>;    // Port n.15 configuration bits
        };

        // Port input data register (GPIOn_IDR)
        struct IDR : public RegisterReadOnly<0x40011c08> {
            using IDR0 = Field<0, 1>;    // Port input data
            using IDR1 = Field<1, 1>;    // Port input data
            using IDR2 = Field<2, 1>;    // Port input data
            using IDR3 = Field<3, 1>;    // Port input data
            using IDR4 = Field<4, 1>;    // Port input data
            using IDR5 = Field<5, 1>;    // Port input data
            using IDR6 = Field<6, 1>;    // Port input data
            using IDR7 = Field<7, 1>;    // Port input data
            using IDR8 = Field<8, 1>;    // Port input data
            using IDR9 = Field<9, 1>;    // Port input data
            using IDR10 = Field<10, 1>;    // Port input data
            using IDR11 = Field<11, 1>;    // Port input data
            using IDR12 = Field<12, 1>;    // Port input data
            using IDR13 = Field<13, 1>;    // Port input data
            using IDR14 = Field<14, 1>;    // Port input data
            using IDR15 = Field<15, 1>;    // Port input data
        };

        // Port output data register (GPIOn_ODR)
        struct ODR : public Register<0x40011c0c> {
            using ODR0 = Field<0, 1>;    // Port output data
            using ODR1 = Field<1, 1>;    // Port output data
            using ODR2 = Field<2, 1>;    // Port output data
            using ODR3 = Field<3, 1>;    // Port output data
            using ODR4 = Field<4, 1>;    // Port output data
            using ODR5 = Field<5, 1>;    // Port output data
            using ODR6 = Field<6, 1>;    // Port output data
            using ODR7 = Field<7, 1>;    // Port output data
            using ODR8 = Field<8, 1>;    // Port output data
            using ODR9 = Field<9, 1>;    // Port output data
            using ODR10 = Field<10, 1>;    // Port output data
            using ODR11 = Field<11, 1>;    // Port output data
            using ODR12 = Field<12, 1>;    // Port output data
            using ODR13 = Field<13, 1>;    // Port output data
            using ODR14 = Field<14, 1>;    // Port output data
            using ODR15 = Field<15, 1>;    // Port output data
        };

        // Port bit set/reset register (GPIOn_BSRR)
        struct BSRR : public RegisterWriteOnly<0x40011c10> {
            using BS0 = Field<0, 1>;    // Set bit 0
            using BS1 = Field<1, 1>;    // Set bit 1
            using BS2 = Field<2, 1>;    // Set bit 1
            using BS3 = Field<3, 1>;    // Set bit 3
            using BS4 = Field<4, 1>;    // Set bit 4
            using BS5 = Field<5, 1>;    // Set bit 5
            using BS6 = Field<6, 1>;    // Set bit 6
            using BS7 = Field<7, 1>;    // Set bit 7
            using BS8 = Field<8, 1>;    // Set bit 8
            using BS9 = Field<9, 1>;    // Set bit 9
            using BS10 = Field<10, 1>;    // Set bit 10
            using BS11 = Field<11, 1>;    // Set bit 11
            using BS12 = Field<12, 1>;    // Set bit 12
            using BS13 = Field<13, 1>;    // Set bit 13
            using BS14 = Field<14, 1>;    // Set bit 14
            using BS15 = Field<15, 1>;    // Set bit 15
            using BR0 = Field<16, 1>;    // Reset bit 0
            using BR1 = Field<17, 1>;    // Reset bit 1
            using BR2 = Field<18, 1>;    // Reset bit 2
            using BR3 = Field<19, 1>;    // Reset bit 3
            using BR4 = Field<20, 1>;    // Reset bit 4
            using BR5 = Field<21, 1>;    // Reset bit 5
            using BR6 = Field<22, 1>;    // Reset bit 6
            using BR7 = Field<23, 1>;    // Reset bit 7
            using BR8 = Field<24, 1>;    // Reset bit 8
            using BR9 = Field<25, 1>;    // Reset bit 9
            using BR10 = Field<26, 1>;    // Reset bit 10
            using BR11 = Field<27, 1>;    // Reset bit 11
            using BR12 = Field<28, 1>;    // Reset bit 12
            using BR13 = Field<29, 1>;    // Reset bit 13
            using BR14 = Field<30, 1>;    // Reset bit 14
            using BR15 = Field<31, 1>;    // Reset bit 15
        };

        // Port bit reset register (GPIOn_BRR)
        struct BRR : public RegisterWriteOnly<0x40011c14> {
            using BR0 = Field<0, 1>;    // Reset bit 0
            using BR1 = Field<1, 1>;    // Reset bit 1
            using BR2 = Field<2, 1>;    // Reset bit 1
            using BR3 = Field<3, 1>;    // Reset bit 3
            using BR4 = Field<4, 1>;    // Reset bit 4
            using BR5 = Field<5, 1>;    // Reset bit 5
            using BR6 = Field<6, 1>;    // Reset bit 6
            using BR7 = Field<7, 1>;    // Reset bit 7
            using BR8 = Field<8, 1>;    // Reset bit 8
            using BR9 = Field<9, 1>;    // Reset bit 9
            using BR10 = Field<10, 1>;    // Reset bit 10
            using BR11 = Field<11, 1>;    // Reset bit 11
            using BR12 = Field<12, 1>;    // Reset bit 12
            using BR13 = Field<13, 1>;    // Reset bit 13
            using BR14 = Field<14, 1>;    // Reset bit 14
            using BR15 = Field<15, 1>;    // Reset bit 15
        };

        // Port configuration lock register
        struct LCKR : public Register<0x40011c18> {
            using LCK0 = Field<0, 1>;    // Port A Lock bit 0
            using LCK1 = Field<1, 1>;    // Port A Lock bit 1
            using LCK2 = Field<2, 1>;    // Port A Lock bit 2
            using LCK3 = Field<3, 1>;    // Port A Lock bit 3
            using LCK4 = Field<4, 1>;    // Port A Lock bit 4
            using LCK5 = Field<5, 1>;    // Port A Lock bit 5
            using LCK6 = Field<6, 1>;    // Port A Lock bit 6
            using LCK7 = Field<7, 1>;    // Port A Lock bit 7
            using LCK8 = Field<8, 1>;    // Port A Lock bit 8
            using LCK9 = Field<9, 1>;    // Port A Lock bit 9
            using LCK10 = Field<10, 1>;    // Port A Lock bit 10
            using LCK11 = Field<11, 1>;    // Port A Lock bit 11
            using LCK12 = Field<12, 1>;    // Port A Lock bit 12
            using LCK13 = Field<13, 1>;    // Port A Lock bit 13
            using LCK14 = Field<14, 1>;    // Port A Lock bit 14
            using LCK15 = Field<15, 1>;    // Port A Lock bit 15
            using LCKK = Field<16, 1>;    // Lock key
        };

    };

    // General purpose I/O
    struct GPIOG {
        // Port configuration register low (GPIOn_CRL)
        struct CRL : public Register<0x40012000> {
            using MODE0 = Field<0, 2>;    // Port n.0 mode bits
            using CNF0 = Field<2, 2>;    // Port n.0 configuration bits
            using MODE1 = Field<4, 2>;    // Port n.1 mode bits
            using CNF1 = Field<6, 2>;    // Port n.1 configuration bits
            using MODE2 = Field<8, 2>;    // Port n.2 mode bits
            using CNF2 = Field<10, 2>;    // Port n.2 configuration bits
            using MODE3 = Field<12, 2>;    // Port n.3 mode bits
            using CNF3 = Field<14, 2>;    // Port n.3 configuration bits
            using MODE4 = Field<16, 2>;    // Port n.4 mode bits
            using CNF4 = Field<18, 2>;    // Port n.4 configuration bits
            using MODE5 = Field<20, 2>;    // Port n.5 mode bits
            using CNF5 = Field<22, 2>;    // Port n.5 configuration bits
            using MODE6 = Field<24, 2>;    // Port n.6 mode bits
            using CNF6 = Field<26, 2>;    // Port n.6 configuration bits
            using MODE7 = Field<28, 2>;    // Port n.7 mode bits
            using CNF7 = Field<30, 2>;    // Port n.7 configuration bits
        };

        // Port configuration register high (GPIOn_CRL)
        struct CRH : public Register<0x40012004> {
            using MODE8 = Field<0, 2>;    // Port n.8 mode bits
            using CNF8 = Field<2, 2>;    // Port n.8 configuration bits
            using MODE9 = Field<4, 2>;    // Port n.9 mode bits
            using CNF9 = Field<6, 2>;    // Port n.9 configuration bits
            using MODE10 = Field<8, 2>;    // Port n.10 mode bits
            using CNF10 = Field<10, 2>;    // Port n.10 configuration bits
            using MODE11 = Field<12, 2>;    // Port n.11 mode bits
            using CNF11 = Field<14, 2>;    // Port n.11 configuration bits
            using MODE12 = Field<16, 2>;    // Port n.12 mode bits
            using CNF12 = Field<18, 2>;    // Port n.12 configuration bits
            using MODE13 = Field<20, 2>;    // Port n.13 mode bits
            using CNF13 = Field<22, 2>;    // Port n.13 configuration bits
            using MODE14 = Field<24, 2>;    // Port n.14 mode bits
            using CNF14 = Field<26, 2>;    // Port n.14 configuration bits
            using MODE15 = Field<28, 2>;    // Port n.15 mode bits
            using CNF15 = Field<30, 2>;    // Port n.15 configuration bits
        };

        // Port input data register (GPIOn_IDR)
        struct IDR : public RegisterReadOnly<0x40012008> {
            using IDR0 = Field<0, 1>;    // Port input data
            using IDR1 = Field<1, 1>;    // Port input data
            using IDR2 = Field<2, 1>;    // Port input data
            using IDR3 = Field<3, 1>;    // Port input data
            using IDR4 = Field<4, 1>;    // Port input data
            using IDR5 = Field<5, 1>;    // Port input data
            using IDR6 = Field<6, 1>;    // Port input data
            using IDR7 = Field<7, 1>;    // Port input data
            using IDR8 = Field<8, 1>;    // Port input data
            using IDR9 = Field<9, 1>;    // Port input data
            using IDR10 = Field<10, 1>;    // Port input data
            using IDR11 = Field<11, 1>;    // Port input data
            using IDR12 = Field<12, 1>;    // Port input data
            using IDR13 = Field<13, 1>;    // Port input data
            using IDR14 = Field<14, 1>;    // Port input data
            using IDR15 = Field<15, 1>;    // Port input data
        };

        // Port output data register (GPIOn_ODR)
        struct ODR : public Register<0x4001200c> {
            using ODR0 = Field<0, 1>;    // Port output data
            using ODR1 = Field<1, 1>;    // Port output data
            using ODR2 = Field<2, 1>;    // Port output data
            using ODR3 = Field<3, 1>;    // Port output data
            using ODR4 = Field<4, 1>;    // Port output data
            using ODR5 = Field<5, 1>;    // Port output data
            using ODR6 = Field<6, 1>;    // Port output data
            using ODR7 = Field<7, 1>;    // Port output data
            using ODR8 = Field<8, 1>;    // Port output data
            using ODR9 = Field<9, 1>;    // Port output data
            using ODR10 = Field<10, 1>;    // Port output data
            using ODR11 = Field<11, 1>;    // Port output data
            using ODR12 = Field<12, 1>;    // Port output data
            using ODR13 = Field<13, 1>;    // Port output data
            using ODR14 = Field<14, 1>;    // Port output data
            using ODR15 = Field<15, 1>;    // Port output data
        };

        // Port bit set/reset register (GPIOn_BSRR)
        struct BSRR : public RegisterWriteOnly<0x40012010> {
            using BS0 = Field<0, 1>;    // Set bit 0
            using BS1 = Field<1, 1>;    // Set bit 1
            using BS2 = Field<2, 1>;    // Set bit 1
            using BS3 = Field<3, 1>;    // Set bit 3
            using BS4 = Field<4, 1>;    // Set bit 4
            using BS5 = Field<5, 1>;    // Set bit 5
            using BS6 = Field<6, 1>;    // Set bit 6
            using BS7 = Field<7, 1>;    // Set bit 7
            using BS8 = Field<8, 1>;    // Set bit 8
            using BS9 = Field<9, 1>;    // Set bit 9
            using BS10 = Field<10, 1>;    // Set bit 10
            using BS11 = Field<11, 1>;    // Set bit 11
            using BS12 = Field<12, 1>;    // Set bit 12
            using BS13 = Field<13, 1>;    // Set bit 13
            using BS14 = Field<14, 1>;    // Set bit 14
            using BS15 = Field<15, 1>;    // Set bit 15
            using BR0 = Field<16, 1>;    // Reset bit 0
            using BR1 = Field<17, 1>;    // Reset bit 1
            using BR2 = Field<18, 1>;    // Reset bit 2
            using BR3 = Field<19, 1>;    // Reset bit 3
            using BR4 = Field<20, 1>;    // Reset bit 4
            using BR5 = Field<21, 1>;    // Reset bit 5
            using BR6 = Field<22, 1>;    // Reset bit 6
            using BR7 = Field<23, 1>;    // Reset bit 7
            using BR8 = Field<24, 1>;    // Reset bit 8
            using BR9 = Field<25, 1>;    // Reset bit 9
            using BR10 = Field<26, 1>;    // Reset bit 10
            using BR11 = Field<27, 1>;    // Reset bit 11
            using BR12 = Field<28, 1>;    // Reset bit 12
            using BR13 = Field<29, 1>;    // Reset bit 13
            using BR14 = Field<30, 1>;    // Reset bit 14
            using BR15 = Field<31, 1>;    // Reset bit 15
        };

        // Port bit reset register (GPIOn_BRR)
        struct BRR : public RegisterWriteOnly<0x40012014> {
            using BR0 = Field<0, 1>;    // Reset bit 0
            using BR1 = Field<1, 1>;    // Reset bit 1
            using BR2 = Field<2, 1>;    // Reset bit 1
            using BR3 = Field<3, 1>;    // Reset bit 3
            using BR4 = Field<4, 1>;    // Reset bit 4
            using BR5 = Field<5, 1>;    // Reset bit 5
            using BR6 = Field<6, 1>;    // Reset bit 6
            using BR7 = Field<7, 1>;    // Reset bit 7
            using BR8 = Field<8, 1>;    // Reset bit 8
            using BR9 = Field<9, 1>;    // Reset bit 9
            using BR10 = Field<10, 1>;    // Reset bit 10
            using BR11 = Field<11, 1>;    // Reset bit 11
            using BR12 = Field<12, 1>;    // Reset bit 12
            using BR13 = Field<13, 1>;    // Reset bit 13
            using BR14 = Field<14, 1>;    // Reset bit 14
            using BR15 = Field<15, 1>;    // Reset bit 15
        };

        // Port configuration lock register
        struct LCKR : public Register<0x40012018> {
            using LCK0 = Field<0, 1>;    // Port A Lock bit 0
            using LCK1 = Field<1, 1>;    // Port A Lock bit 1
            using LCK2 = Field<2, 1>;    // Port A Lock bit 2
            using LCK3 = Field<3, 1>;    // Port A Lock bit 3
            using LCK4 = Field<4, 1>;    // Port A Lock bit 4
            using LCK5 = Field<5, 1>;    // Port A Lock bit 5
            using LCK6 = Field<6, 1>;    // Port A Lock bit 6
            using LCK7 = Field<7, 1>;    // Port A Lock bit 7
            using LCK8 = Field<8, 1>;    // Port A Lock bit 8
            using LCK9 = Field<9, 1>;    // Port A Lock bit 9
            using LCK10 = Field<10, 1>;    // Port A Lock bit 10
            using LCK11 = Field<11, 1>;    // Port A Lock bit 11
            using LCK12 = Field<12, 1>;    // Port A Lock bit 12
            using LCK13 = Field<13, 1>;    // Port A Lock bit 13
            using LCK14 = Field<14, 1>;    // Port A Lock bit 14
            using LCK15 = Field<15, 1>;    // Port A Lock bit 15
            using LCKK = Field<16, 1>;    // Lock key
        };

    };

    // Alternate function I/O
    struct AFIO {
        // Event Control Register (AFIO_EVCR)
        struct EVCR : public Register<0x40010000> {
            using PIN = Field<0, 4>;    // Pin selection
            using PORT = Field<4, 3>;    // Port selection
            using EVOE = Field<7, 1>;    // Event Output Enable
        };

        // AF remap and debug I/O configuration register (AFIO_MAPR)
        struct MAPR : public Register<0x40010004> {
            using SPI1_REMAP = Field<0, 1>;    // SPI1 remapping
            using I2C1_REMAP = Field<1, 1>;    // I2C1 remapping
            using USART1_REMAP = Field<2, 1>;    // USART1 remapping
            using USART2_REMAP = Field<3, 1>;    // USART2 remapping
            using USART3_REMAP = Field<4, 2>;    // USART3 remapping
            using TIM1_REMAP = Field<6, 2>;    // TIM1 remapping
            using TIM2_REMAP = Field<8, 2>;    // TIM2 remapping
            using TIM3_REMAP = Field<10, 2>;    // TIM3 remapping
            using TIM4_REMAP = Field<12, 1>;    // TIM4 remapping
            using CAN_REMAP = Field<13, 2>;    // CAN1 remapping
            using PD01_REMAP = Field<15, 1>;    // Port D0/Port D1 mapping on OSCIN/OSCOUT
            using TIM5CH4_IREMAP = Field<16, 1>;    // Set and cleared by software
            using ADC1_ETRGINJ_REMAP = Field<17, 1>;    // ADC 1 External trigger injected conversion remapping
            using ADC1_ETRGREG_REMAP = Field<18, 1>;    // ADC 1 external trigger regular conversion remapping
            using ADC2_ETRGINJ_REMAP = Field<19, 1>;    // ADC 2 external trigger injected conversion remapping
            using ADC2_ETRGREG_REMAP = Field<20, 1>;    // ADC 2 external trigger regular conversion remapping
            using SWJ_CFG = Field<24, 3>;    // Serial wire JTAG configuration
        };

        // External interrupt configuration register 1 (AFIO_EXTICR1)
        struct EXTICR1 : public Register<0x40010008> {
            using EXTI0 = Field<0, 4>;    // EXTI0 configuration
            using EXTI1 = Field<4, 4>;    // EXTI1 configuration
            using EXTI2 = Field<8, 4>;    // EXTI2 configuration
            using EXTI3 = Field<12, 4>;    // EXTI3 configuration
        };

        // External interrupt configuration register 2 (AFIO_EXTICR2)
        struct EXTICR2 : public Register<0x4001000c> {
            using EXTI4 = Field<0, 4>;    // EXTI4 configuration
            using EXTI5 = Field<4, 4>;    // EXTI5 configuration
            using EXTI6 = Field<8, 4>;    // EXTI6 configuration
            using EXTI7 = Field<12, 4>;    // EXTI7 configuration
        };

        // External interrupt configuration register 3 (AFIO_EXTICR3)
        struct EXTICR3 : public Register<0x40010010> {
            using EXTI8 = Field<0, 4>;    // EXTI8 configuration
            using EXTI9 = Field<4, 4>;    // EXTI9 configuration
            using EXTI10 = Field<8, 4>;    // EXTI10 configuration
            using EXTI11 = Field<12, 4>;    // EXTI11 configuration
        };

        // External interrupt configuration register 4 (AFIO_EXTICR4)
        struct EXTICR4 : public Register<0x40010014> {
            using EXTI12 = Field<0, 4>;    // EXTI12 configuration
            using EXTI13 = Field<4, 4>;    // EXTI13 configuration
            using EXTI14 = Field<8, 4>;    // EXTI14 configuration
            using EXTI15 = Field<12, 4>;    // EXTI15 configuration
        };

        // AF remap and debug I/O configuration register
        struct MAPR2 : public Register<0x4001001c> {
            using TIM9_REMAP = Field<5, 1>;    // TIM9 remapping
            using TIM10_REMAP = Field<6, 1>;    // TIM10 remapping
            using TIM11_REMAP = Field<7, 1>;    // TIM11 remapping
            using TIM13_REMAP = Field<8, 1>;    // TIM13 remapping
            using TIM14_REMAP = Field<9, 1>;    // TIM14 remapping
            using FSMC_NADV = Field<10, 1>;    // NADV connect/disconnect
        };

    };

    // EXTI
    struct EXTI {
        // Interrupt mask register (EXTI_IMR)
        struct IMR : public Register<0x40010400> {
            using MR0 = Field<0, 1>;    // Interrupt Mask on line 0
            using MR1 = Field<1, 1>;    // Interrupt Mask on line 1
            using MR2 = Field<2, 1>;    // Interrupt Mask on line 2
            using MR3 = Field<3, 1>;    // Interrupt Mask on line 3
            using MR4 = Field<4, 1>;    // Interrupt Mask on line 4
            using MR5 = Field<5, 1>;    // Interrupt Mask on line 5
            using MR6 = Field<6, 1>;    // Interrupt Mask on line 6
            using MR7 = Field<7, 1>;    // Interrupt Mask on line 7
            using MR8 = Field<8, 1>;    // Interrupt Mask on line 8
            using MR9 = Field<9, 1>;    // Interrupt Mask on line 9
            using MR10 = Field<10, 1>;    // Interrupt Mask on line 10
            using MR11 = Field<11, 1>;    // Interrupt Mask on line 11
            using MR12 = Field<12, 1>;    // Interrupt Mask on line 12
            using MR13 = Field<13, 1>;    // Interrupt Mask on line 13
            using MR14 = Field<14, 1>;    // Interrupt Mask on line 14
            using MR15 = Field<15, 1>;    // Interrupt Mask on line 15
            using MR16 = Field<16, 1>;    // Interrupt Mask on line 16
            using MR17 = Field<17, 1>;    // Interrupt Mask on line 17
            using MR18 = Field<18, 1>;    // Interrupt Mask on line 18
        };

        // Event mask register (EXTI_EMR)
        struct EMR : public Register<0x40010404> {
            using MR0 = Field<0, 1>;    // Event Mask on line 0
            using MR1 = Field<1, 1>;    // Event Mask on line 1
            using MR2 = Field<2, 1>;    // Event Mask on line 2
            using MR3 = Field<3, 1>;    // Event Mask on line 3
            using MR4 = Field<4, 1>;    // Event Mask on line 4
            using MR5 = Field<5, 1>;    // Event Mask on line 5
            using MR6 = Field<6, 1>;    // Event Mask on line 6
            using MR7 = Field<7, 1>;    // Event Mask on line 7
            using MR8 = Field<8, 1>;    // Event Mask on line 8
            using MR9 = Field<9, 1>;    // Event Mask on line 9
            using MR10 = Field<10, 1>;    // Event Mask on line 10
            using MR11 = Field<11, 1>;    // Event Mask on line 11
            using MR12 = Field<12, 1>;    // Event Mask on line 12
            using MR13 = Field<13, 1>;    // Event Mask on line 13
            using MR14 = Field<14, 1>;    // Event Mask on line 14
            using MR15 = Field<15, 1>;    // Event Mask on line 15
            using MR16 = Field<16, 1>;    // Event Mask on line 16
            using MR17 = Field<17, 1>;    // Event Mask on line 17
            using MR18 = Field<18, 1>;    // Event Mask on line 18
        };

        // Rising Trigger selection register (EXTI_RTSR)
        struct RTSR : public Register<0x40010408> {
            using TR0 = Field<0, 1>;    // Rising trigger event configuration of line 0
            using TR1 = Field<1, 1>;    // Rising trigger event configuration of line 1
            using TR2 = Field<2, 1>;    // Rising trigger event configuration of line 2
            using TR3 = Field<3, 1>;    // Rising trigger event configuration of line 3
            using TR4 = Field<4, 1>;    // Rising trigger event configuration of line 4
            using TR5 = Field<5, 1>;    // Rising trigger event configuration of line 5
            using TR6 = Field<6, 1>;    // Rising trigger event configuration of line 6
            using TR7 = Field<7, 1>;    // Rising trigger event configuration of line 7
            using TR8 = Field<8, 1>;    // Rising trigger event configuration of line 8
            using TR9 = Field<9, 1>;    // Rising trigger event configuration of line 9
            using TR10 = Field<10, 1>;    // Rising trigger event configuration of line 10
            using TR11 = Field<11, 1>;    // Rising trigger event configuration of line 11
            using TR12 = Field<12, 1>;    // Rising trigger event configuration of line 12
            using TR13 = Field<13, 1>;    // Rising trigger event configuration of line 13
            using TR14 = Field<14, 1>;    // Rising trigger event configuration of line 14
            using TR15 = Field<15, 1>;    // Rising trigger event configuration of line 15
            using TR16 = Field<16, 1>;    // Rising trigger event configuration of line 16
            using TR17 = Field<17, 1>;    // Rising trigger event configuration of line 17
            using TR18 = Field<18, 1>;    // Rising trigger event configuration of line 18
        };

        // Falling Trigger selection register (EXTI_FTSR)
        struct FTSR : public Register<0x4001040c> {
            using TR0 = Field<0, 1>;    // Falling trigger event configuration of line 0
            using TR1 = Field<1, 1>;    // Falling trigger event configuration of line 1
            using TR2 = Field<2, 1>;    // Falling trigger event configuration of line 2
            using TR3 = Field<3, 1>;    // Falling trigger event configuration of line 3
            using TR4 = Field<4, 1>;    // Falling trigger event configuration of line 4
            using TR5 = Field<5, 1>;    // Falling trigger event configuration of line 5
            using TR6 = Field<6, 1>;    // Falling trigger event configuration of line 6
            using TR7 = Field<7, 1>;    // Falling trigger event configuration of line 7
            using TR8 = Field<8, 1>;    // Falling trigger event configuration of line 8
            using TR9 = Field<9, 1>;    // Falling trigger event configuration of line 9
            using TR10 = Field<10, 1>;    // Falling trigger event configuration of line 10
            using TR11 = Field<11, 1>;    // Falling trigger event configuration of line 11
            using TR12 = Field<12, 1>;    // Falling trigger event configuration of line 12
            using TR13 = Field<13, 1>;    // Falling trigger event configuration of line 13
            using TR14 = Field<14, 1>;    // Falling trigger event configuration of line 14
            using TR15 = Field<15, 1>;    // Falling trigger event configuration of line 15
            using TR16 = Field<16, 1>;    // Falling trigger event configuration of line 16
            using TR17 = Field<17, 1>;    // Falling trigger event configuration of line 17
            using TR18 = Field<18, 1>;    // Falling trigger event configuration of line 18
        };

        // Software interrupt event register (EXTI_SWIER)
        struct SWIER : public Register<0x40010410> {
            using SWIER0 = Field<0, 1>;    // Software Interrupt on line 0
            using SWIER1 = Field<1, 1>;    // Software Interrupt on line 1
            using SWIER2 = Field<2, 1>;    // Software Interrupt on line 2
            using SWIER3 = Field<3, 1>;    // Software Interrupt on line 3
            using SWIER4 = Field<4, 1>;    // Software Interrupt on line 4
            using SWIER5 = Field<5, 1>;    // Software Interrupt on line 5
            using SWIER6 = Field<6, 1>;    // Software Interrupt on line 6
            using SWIER7 = Field<7, 1>;    // Software Interrupt on line 7
            using SWIER8 = Field<8, 1>;    // Software Interrupt on line 8
            using SWIER9 = Field<9, 1>;    // Software Interrupt on line 9
            using SWIER10 = Field<10, 1>;    // Software Interrupt on line 10
            using SWIER11 = Field<11, 1>;    // Software Interrupt on line 11
            using SWIER12 = Field<12, 1>;    // Software Interrupt on line 12
            using SWIER13 = Field<13, 1>;    // Software Interrupt on line 13
            using SWIER14 = Field<14, 1>;    // Software Interrupt on line 14
            using SWIER15 = Field<15, 1>;    // Software Interrupt on line 15
            using SWIER16 = Field<16, 1>;    // Software Interrupt on line 16
            using SWIER17 = Field<17, 1>;    // Software Interrupt on line 17
            using SWIER18 = Field<18, 1>;    // Software Interrupt on line 18
        };

        // Pending register (EXTI_PR)
        struct PR : public Register<0x40010414> {
            using PR0 = Field<0, 1>;    // Pending bit 0
            using PR1 = Field<1, 1>;    // Pending bit 1
            using PR2 = Field<2, 1>;    // Pending bit 2
            using PR3 = Field<3, 1>;    // Pending bit 3
            using PR4 = Field<4, 1>;    // Pending bit 4
            using PR5 = Field<5, 1>;    // Pending bit 5
            using PR6 = Field<6, 1>;    // Pending bit 6
            using PR7 = Field<7, 1>;    // Pending bit 7
            using PR8 = Field<8, 1>;    // Pending bit 8
            using PR9 = Field<9, 1>;    // Pending bit 9
            using PR10 = Field<10, 1>;    // Pending bit 10
            using PR11 = Field<11, 1>;    // Pending bit 11
            using PR12 = Field<12, 1>;    // Pending bit 12
            using PR13 = Field<13, 1>;    // Pending bit 13
            using PR14 = Field<14, 1>;    // Pending bit 14
            using PR15 = Field<15, 1>;    // Pending bit 15
            using PR16 = Field<16, 1>;    // Pending bit 16
            using PR17 = Field<17, 1>;    // Pending bit 17
            using PR18 = Field<18, 1>;    // Pending bit 18
        };

    };

    // DMA controller
    struct DMA1 {
        // DMA interrupt status register (DMA_ISR)
        struct ISR : public RegisterReadOnly<0x40020000> {
            using GIF1 = Field<0, 1>;    // Channel 1 Global interrupt flag
            using TCIF1 = Field<1, 1>;    // Channel 1 Transfer Complete flag
            using HTIF1 = Field<2, 1>;    // Channel 1 Half Transfer Complete flag
            using TEIF1 = Field<3, 1>;    // Channel 1 Transfer Error flag
            using GIF2 = Field<4, 1>;    // Channel 2 Global interrupt flag
            using TCIF2 = Field<5, 1>;    // Channel 2 Transfer Complete flag
            using HTIF2 = Field<6, 1>;    // Channel 2 Half Transfer Complete flag
            using TEIF2 = Field<7, 1>;    // Channel 2 Transfer Error flag
            using GIF3 = Field<8, 1>;    // Channel 3 Global interrupt flag
            using TCIF3 = Field<9, 1>;    // Channel 3 Transfer Complete flag
            using HTIF3 = Field<10, 1>;    // Channel 3 Half Transfer Complete flag
            using TEIF3 = Field<11, 1>;    // Channel 3 Transfer Error flag
            using GIF4 = Field<12, 1>;    // Channel 4 Global interrupt flag
            using TCIF4 = Field<13, 1>;    // Channel 4 Transfer Complete flag
            using HTIF4 = Field<14, 1>;    // Channel 4 Half Transfer Complete flag
            using TEIF4 = Field<15, 1>;    // Channel 4 Transfer Error flag
            using GIF5 = Field<16, 1>;    // Channel 5 Global interrupt flag
            using TCIF5 = Field<17, 1>;    // Channel 5 Transfer Complete flag
            using HTIF5 = Field<18, 1>;    // Channel 5 Half Transfer Complete flag
            using TEIF5 = Field<19, 1>;    // Channel 5 Transfer Error flag
            using GIF6 = Field<20, 1>;    // Channel 6 Global interrupt flag
            using TCIF6 = Field<21, 1>;    // Channel 6 Transfer Complete flag
            using HTIF6 = Field<22, 1>;    // Channel 6 Half Transfer Complete flag
            using TEIF6 = Field<23, 1>;    // Channel 6 Transfer Error flag
            using GIF7 = Field<24, 1>;    // Channel 7 Global interrupt flag
            using TCIF7 = Field<25, 1>;    // Channel 7 Transfer Complete flag
            using HTIF7 = Field<26, 1>;    // Channel 7 Half Transfer Complete flag
            using TEIF7 = Field<27, 1>;    // Channel 7 Transfer Error flag
        };

        // DMA interrupt flag clear register (DMA_IFCR)
        struct IFCR : public RegisterWriteOnly<0x40020004> {
            using CGIF1 = Field<0, 1>;    // Channel 1 Global interrupt clear
            using CGIF2 = Field<4, 1>;    // Channel 2 Global interrupt clear
            using CGIF3 = Field<8, 1>;    // Channel 3 Global interrupt clear
            using CGIF4 = Field<12, 1>;    // Channel 4 Global interrupt clear
            using CGIF5 = Field<16, 1>;    // Channel 5 Global interrupt clear
            using CGIF6 = Field<20, 1>;    // Channel 6 Global interrupt clear
            using CGIF7 = Field<24, 1>;    // Channel 7 Global interrupt clear
            using CTCIF1 = Field<1, 1>;    // Channel 1 Transfer Complete clear
            using CTCIF2 = Field<5, 1>;    // Channel 2 Transfer Complete clear
            using CTCIF3 = Field<9, 1>;    // Channel 3 Transfer Complete clear
            using CTCIF4 = Field<13, 1>;    // Channel 4 Transfer Complete clear
            using CTCIF5 = Field<17, 1>;    // Channel 5 Transfer Complete clear
            using CTCIF6 = Field<21, 1>;    // Channel 6 Transfer Complete clear
            using CTCIF7 = Field<25, 1>;    // Channel 7 Transfer Complete clear
            using CHTIF1 = Field<2, 1>;    // Channel 1 Half Transfer clear
            using CHTIF2 = Field<6, 1>;    // Channel 2 Half Transfer clear
            using CHTIF3 = Field<10, 1>;    // Channel 3 Half Transfer clear
            using CHTIF4 = Field<14, 1>;    // Channel 4 Half Transfer clear
            using CHTIF5 = Field<18, 1>;    // Channel 5 Half Transfer clear
            using CHTIF6 = Field<22, 1>;    // Channel 6 Half Transfer clear
            using CHTIF7 = Field<26, 1>;    // Channel 7 Half Transfer clear
            using CTEIF1 = Field<3, 1>;    // Channel 1 Transfer Error clear
            using CTEIF2 = Field<7, 1>;    // Channel 2 Transfer Error clear
            using CTEIF3 = Field<11, 1>;    // Channel 3 Transfer Error clear
            using CTEIF4 = Field<15, 1>;    // Channel 4 Transfer Error clear
            using CTEIF5 = Field<19, 1>;    // Channel 5 Transfer Error clear
            using CTEIF6 = Field<23, 1>;    // Channel 6 Transfer Error clear
            using CTEIF7 = Field<27, 1>;    // Channel 7 Transfer Error clear
        };

        // DMA channel configuration register (DMA_CCR)
        struct CCR1 : public Register<0x40020008> {
            using EN = Field<0, 1>;    // Channel enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<2, 1>;    // Half Transfer interrupt enable
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using DIR = Field<4, 1>;    // Data transfer direction
            using CIRC = Field<5, 1>;    // Circular mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using MINC = Field<7, 1>;    // Memory increment mode
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MSIZE = Field<10, 2>;    // Memory size
            using PL = Field<12, 2>;    // Channel Priority level
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
        };

        // DMA channel 1 number of data register
        struct CNDTR1 : public Register<0x4002000c> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // DMA channel 1 peripheral address register
        struct CPAR1 : public Register<0x40020010> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel 1 memory address register
        struct CMAR1 : public Register<0x40020014> {
            using MA = Field<0, 32>;    // Memory address
        };

        // DMA channel configuration register (DMA_CCR)
        struct CCR2 : public Register<0x4002001c> {
            using EN = Field<0, 1>;    // Channel enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<2, 1>;    // Half Transfer interrupt enable
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using DIR = Field<4, 1>;    // Data transfer direction
            using CIRC = Field<5, 1>;    // Circular mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using MINC = Field<7, 1>;    // Memory increment mode
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MSIZE = Field<10, 2>;    // Memory size
            using PL = Field<12, 2>;    // Channel Priority level
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
        };

        // DMA channel 2 number of data register
        struct CNDTR2 : public Register<0x40020020> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // DMA channel 2 peripheral address register
        struct CPAR2 : public Register<0x40020024> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel 2 memory address register
        struct CMAR2 : public Register<0x40020028> {
            using MA = Field<0, 32>;    // Memory address
        };

        // DMA channel configuration register (DMA_CCR)
        struct CCR3 : public Register<0x40020030> {
            using EN = Field<0, 1>;    // Channel enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<2, 1>;    // Half Transfer interrupt enable
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using DIR = Field<4, 1>;    // Data transfer direction
            using CIRC = Field<5, 1>;    // Circular mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using MINC = Field<7, 1>;    // Memory increment mode
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MSIZE = Field<10, 2>;    // Memory size
            using PL = Field<12, 2>;    // Channel Priority level
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
        };

        // DMA channel 3 number of data register
        struct CNDTR3 : public Register<0x40020034> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // DMA channel 3 peripheral address register
        struct CPAR3 : public Register<0x40020038> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel 3 memory address register
        struct CMAR3 : public Register<0x4002003c> {
            using MA = Field<0, 32>;    // Memory address
        };

        // DMA channel configuration register (DMA_CCR)
        struct CCR4 : public Register<0x40020044> {
            using EN = Field<0, 1>;    // Channel enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<2, 1>;    // Half Transfer interrupt enable
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using DIR = Field<4, 1>;    // Data transfer direction
            using CIRC = Field<5, 1>;    // Circular mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using MINC = Field<7, 1>;    // Memory increment mode
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MSIZE = Field<10, 2>;    // Memory size
            using PL = Field<12, 2>;    // Channel Priority level
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
        };

        // DMA channel 4 number of data register
        struct CNDTR4 : public Register<0x40020048> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // DMA channel 4 peripheral address register
        struct CPAR4 : public Register<0x4002004c> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel 4 memory address register
        struct CMAR4 : public Register<0x40020050> {
            using MA = Field<0, 32>;    // Memory address
        };

        // DMA channel configuration register (DMA_CCR)
        struct CCR5 : public Register<0x40020058> {
            using EN = Field<0, 1>;    // Channel enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<2, 1>;    // Half Transfer interrupt enable
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using DIR = Field<4, 1>;    // Data transfer direction
            using CIRC = Field<5, 1>;    // Circular mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using MINC = Field<7, 1>;    // Memory increment mode
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MSIZE = Field<10, 2>;    // Memory size
            using PL = Field<12, 2>;    // Channel Priority level
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
        };

        // DMA channel 5 number of data register
        struct CNDTR5 : public Register<0x4002005c> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // DMA channel 5 peripheral address register
        struct CPAR5 : public Register<0x40020060> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel 5 memory address register
        struct CMAR5 : public Register<0x40020064> {
            using MA = Field<0, 32>;    // Memory address
        };

        // DMA channel configuration register (DMA_CCR)
        struct CCR6 : public Register<0x4002006c> {
            using EN = Field<0, 1>;    // Channel enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<2, 1>;    // Half Transfer interrupt enable
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using DIR = Field<4, 1>;    // Data transfer direction
            using CIRC = Field<5, 1>;    // Circular mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using MINC = Field<7, 1>;    // Memory increment mode
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MSIZE = Field<10, 2>;    // Memory size
            using PL = Field<12, 2>;    // Channel Priority level
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
        };

        // DMA channel 6 number of data register
        struct CNDTR6 : public Register<0x40020070> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // DMA channel 6 peripheral address register
        struct CPAR6 : public Register<0x40020074> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel 6 memory address register
        struct CMAR6 : public Register<0x40020078> {
            using MA = Field<0, 32>;    // Memory address
        };

        // DMA channel configuration register (DMA_CCR)
        struct CCR7 : public Register<0x40020080> {
            using EN = Field<0, 1>;    // Channel enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<2, 1>;    // Half Transfer interrupt enable
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using DIR = Field<4, 1>;    // Data transfer direction
            using CIRC = Field<5, 1>;    // Circular mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using MINC = Field<7, 1>;    // Memory increment mode
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MSIZE = Field<10, 2>;    // Memory size
            using PL = Field<12, 2>;    // Channel Priority level
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
        };

        // DMA channel 7 number of data register
        struct CNDTR7 : public Register<0x40020084> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // DMA channel 7 peripheral address register
        struct CPAR7 : public Register<0x40020088> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel 7 memory address register
        struct CMAR7 : public Register<0x4002008c> {
            using MA = Field<0, 32>;    // Memory address
        };

    };

    // DMA controller
    struct DMA2 {
        // DMA interrupt status register (DMA_ISR)
        struct ISR : public RegisterReadOnly<0x40020400> {
            using GIF1 = Field<0, 1>;    // Channel 1 Global interrupt flag
            using TCIF1 = Field<1, 1>;    // Channel 1 Transfer Complete flag
            using HTIF1 = Field<2, 1>;    // Channel 1 Half Transfer Complete flag
            using TEIF1 = Field<3, 1>;    // Channel 1 Transfer Error flag
            using GIF2 = Field<4, 1>;    // Channel 2 Global interrupt flag
            using TCIF2 = Field<5, 1>;    // Channel 2 Transfer Complete flag
            using HTIF2 = Field<6, 1>;    // Channel 2 Half Transfer Complete flag
            using TEIF2 = Field<7, 1>;    // Channel 2 Transfer Error flag
            using GIF3 = Field<8, 1>;    // Channel 3 Global interrupt flag
            using TCIF3 = Field<9, 1>;    // Channel 3 Transfer Complete flag
            using HTIF3 = Field<10, 1>;    // Channel 3 Half Transfer Complete flag
            using TEIF3 = Field<11, 1>;    // Channel 3 Transfer Error flag
            using GIF4 = Field<12, 1>;    // Channel 4 Global interrupt flag
            using TCIF4 = Field<13, 1>;    // Channel 4 Transfer Complete flag
            using HTIF4 = Field<14, 1>;    // Channel 4 Half Transfer Complete flag
            using TEIF4 = Field<15, 1>;    // Channel 4 Transfer Error flag
            using GIF5 = Field<16, 1>;    // Channel 5 Global interrupt flag
            using TCIF5 = Field<17, 1>;    // Channel 5 Transfer Complete flag
            using HTIF5 = Field<18, 1>;    // Channel 5 Half Transfer Complete flag
            using TEIF5 = Field<19, 1>;    // Channel 5 Transfer Error flag
            using GIF6 = Field<20, 1>;    // Channel 6 Global interrupt flag
            using TCIF6 = Field<21, 1>;    // Channel 6 Transfer Complete flag
            using HTIF6 = Field<22, 1>;    // Channel 6 Half Transfer Complete flag
            using TEIF6 = Field<23, 1>;    // Channel 6 Transfer Error flag
            using GIF7 = Field<24, 1>;    // Channel 7 Global interrupt flag
            using TCIF7 = Field<25, 1>;    // Channel 7 Transfer Complete flag
            using HTIF7 = Field<26, 1>;    // Channel 7 Half Transfer Complete flag
            using TEIF7 = Field<27, 1>;    // Channel 7 Transfer Error flag
        };

        // DMA interrupt flag clear register (DMA_IFCR)
        struct IFCR : public RegisterWriteOnly<0x40020404> {
            using CGIF1 = Field<0, 1>;    // Channel 1 Global interrupt clear
            using CGIF2 = Field<4, 1>;    // Channel 2 Global interrupt clear
            using CGIF3 = Field<8, 1>;    // Channel 3 Global interrupt clear
            using CGIF4 = Field<12, 1>;    // Channel 4 Global interrupt clear
            using CGIF5 = Field<16, 1>;    // Channel 5 Global interrupt clear
            using CGIF6 = Field<20, 1>;    // Channel 6 Global interrupt clear
            using CGIF7 = Field<24, 1>;    // Channel 7 Global interrupt clear
            using CTCIF1 = Field<1, 1>;    // Channel 1 Transfer Complete clear
            using CTCIF2 = Field<5, 1>;    // Channel 2 Transfer Complete clear
            using CTCIF3 = Field<9, 1>;    // Channel 3 Transfer Complete clear
            using CTCIF4 = Field<13, 1>;    // Channel 4 Transfer Complete clear
            using CTCIF5 = Field<17, 1>;    // Channel 5 Transfer Complete clear
            using CTCIF6 = Field<21, 1>;    // Channel 6 Transfer Complete clear
            using CTCIF7 = Field<25, 1>;    // Channel 7 Transfer Complete clear
            using CHTIF1 = Field<2, 1>;    // Channel 1 Half Transfer clear
            using CHTIF2 = Field<6, 1>;    // Channel 2 Half Transfer clear
            using CHTIF3 = Field<10, 1>;    // Channel 3 Half Transfer clear
            using CHTIF4 = Field<14, 1>;    // Channel 4 Half Transfer clear
            using CHTIF5 = Field<18, 1>;    // Channel 5 Half Transfer clear
            using CHTIF6 = Field<22, 1>;    // Channel 6 Half Transfer clear
            using CHTIF7 = Field<26, 1>;    // Channel 7 Half Transfer clear
            using CTEIF1 = Field<3, 1>;    // Channel 1 Transfer Error clear
            using CTEIF2 = Field<7, 1>;    // Channel 2 Transfer Error clear
            using CTEIF3 = Field<11, 1>;    // Channel 3 Transfer Error clear
            using CTEIF4 = Field<15, 1>;    // Channel 4 Transfer Error clear
            using CTEIF5 = Field<19, 1>;    // Channel 5 Transfer Error clear
            using CTEIF6 = Field<23, 1>;    // Channel 6 Transfer Error clear
            using CTEIF7 = Field<27, 1>;    // Channel 7 Transfer Error clear
        };

        // DMA channel configuration register (DMA_CCR)
        struct CCR1 : public Register<0x40020408> {
            using EN = Field<0, 1>;    // Channel enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<2, 1>;    // Half Transfer interrupt enable
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using DIR = Field<4, 1>;    // Data transfer direction
            using CIRC = Field<5, 1>;    // Circular mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using MINC = Field<7, 1>;    // Memory increment mode
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MSIZE = Field<10, 2>;    // Memory size
            using PL = Field<12, 2>;    // Channel Priority level
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
        };

        // DMA channel 1 number of data register
        struct CNDTR1 : public Register<0x4002040c> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // DMA channel 1 peripheral address register
        struct CPAR1 : public Register<0x40020410> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel 1 memory address register
        struct CMAR1 : public Register<0x40020414> {
            using MA = Field<0, 32>;    // Memory address
        };

        // DMA channel configuration register (DMA_CCR)
        struct CCR2 : public Register<0x4002041c> {
            using EN = Field<0, 1>;    // Channel enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<2, 1>;    // Half Transfer interrupt enable
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using DIR = Field<4, 1>;    // Data transfer direction
            using CIRC = Field<5, 1>;    // Circular mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using MINC = Field<7, 1>;    // Memory increment mode
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MSIZE = Field<10, 2>;    // Memory size
            using PL = Field<12, 2>;    // Channel Priority level
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
        };

        // DMA channel 2 number of data register
        struct CNDTR2 : public Register<0x40020420> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // DMA channel 2 peripheral address register
        struct CPAR2 : public Register<0x40020424> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel 2 memory address register
        struct CMAR2 : public Register<0x40020428> {
            using MA = Field<0, 32>;    // Memory address
        };

        // DMA channel configuration register (DMA_CCR)
        struct CCR3 : public Register<0x40020430> {
            using EN = Field<0, 1>;    // Channel enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<2, 1>;    // Half Transfer interrupt enable
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using DIR = Field<4, 1>;    // Data transfer direction
            using CIRC = Field<5, 1>;    // Circular mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using MINC = Field<7, 1>;    // Memory increment mode
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MSIZE = Field<10, 2>;    // Memory size
            using PL = Field<12, 2>;    // Channel Priority level
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
        };

        // DMA channel 3 number of data register
        struct CNDTR3 : public Register<0x40020434> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // DMA channel 3 peripheral address register
        struct CPAR3 : public Register<0x40020438> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel 3 memory address register
        struct CMAR3 : public Register<0x4002043c> {
            using MA = Field<0, 32>;    // Memory address
        };

        // DMA channel configuration register (DMA_CCR)
        struct CCR4 : public Register<0x40020444> {
            using EN = Field<0, 1>;    // Channel enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<2, 1>;    // Half Transfer interrupt enable
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using DIR = Field<4, 1>;    // Data transfer direction
            using CIRC = Field<5, 1>;    // Circular mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using MINC = Field<7, 1>;    // Memory increment mode
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MSIZE = Field<10, 2>;    // Memory size
            using PL = Field<12, 2>;    // Channel Priority level
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
        };

        // DMA channel 4 number of data register
        struct CNDTR4 : public Register<0x40020448> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // DMA channel 4 peripheral address register
        struct CPAR4 : public Register<0x4002044c> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel 4 memory address register
        struct CMAR4 : public Register<0x40020450> {
            using MA = Field<0, 32>;    // Memory address
        };

        // DMA channel configuration register (DMA_CCR)
        struct CCR5 : public Register<0x40020458> {
            using EN = Field<0, 1>;    // Channel enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<2, 1>;    // Half Transfer interrupt enable
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using DIR = Field<4, 1>;    // Data transfer direction
            using CIRC = Field<5, 1>;    // Circular mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using MINC = Field<7, 1>;    // Memory increment mode
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MSIZE = Field<10, 2>;    // Memory size
            using PL = Field<12, 2>;    // Channel Priority level
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
        };

        // DMA channel 5 number of data register
        struct CNDTR5 : public Register<0x4002045c> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // DMA channel 5 peripheral address register
        struct CPAR5 : public Register<0x40020460> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel 5 memory address register
        struct CMAR5 : public Register<0x40020464> {
            using MA = Field<0, 32>;    // Memory address
        };

        // DMA channel configuration register (DMA_CCR)
        struct CCR6 : public Register<0x4002046c> {
            using EN = Field<0, 1>;    // Channel enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<2, 1>;    // Half Transfer interrupt enable
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using DIR = Field<4, 1>;    // Data transfer direction
            using CIRC = Field<5, 1>;    // Circular mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using MINC = Field<7, 1>;    // Memory increment mode
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MSIZE = Field<10, 2>;    // Memory size
            using PL = Field<12, 2>;    // Channel Priority level
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
        };

        // DMA channel 6 number of data register
        struct CNDTR6 : public Register<0x40020470> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // DMA channel 6 peripheral address register
        struct CPAR6 : public Register<0x40020474> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel 6 memory address register
        struct CMAR6 : public Register<0x40020478> {
            using MA = Field<0, 32>;    // Memory address
        };

        // DMA channel configuration register (DMA_CCR)
        struct CCR7 : public Register<0x40020480> {
            using EN = Field<0, 1>;    // Channel enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<2, 1>;    // Half Transfer interrupt enable
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using DIR = Field<4, 1>;    // Data transfer direction
            using CIRC = Field<5, 1>;    // Circular mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using MINC = Field<7, 1>;    // Memory increment mode
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MSIZE = Field<10, 2>;    // Memory size
            using PL = Field<12, 2>;    // Channel Priority level
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
        };

        // DMA channel 7 number of data register
        struct CNDTR7 : public Register<0x40020484> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // DMA channel 7 peripheral address register
        struct CPAR7 : public Register<0x40020488> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel 7 memory address register
        struct CMAR7 : public Register<0x4002048c> {
            using MA = Field<0, 32>;    // Memory address
        };

    };

    // Real time clock
    struct RTC {
        // RTC Control Register High
        struct CRH : public Register<0x40002800> {
            using SECIE = Field<0, 1>;    // Second interrupt Enable
            using ALRIE = Field<1, 1>;    // Alarm interrupt Enable
            using OWIE = Field<2, 1>;    // Overflow interrupt Enable
        };

        // RTC Control Register Low
        struct CRL : public Register<0x40002804> {
            using SECF = Field<0, 1>;    // Second Flag
            using ALRF = Field<1, 1>;    // Alarm Flag
            using OWF = Field<2, 1>;    // Overflow Flag
            using RSF = Field<3, 1>;    // Registers Synchronized Flag
            using CNF = Field<4, 1>;    // Configuration Flag
            using RTOFF = Field<5, 1>;    // RTC operation OFF
        };

        // RTC Prescaler Load Register High
        struct PRLH : public RegisterWriteOnly<0x40002808> {
            using Field = Field<0, 4>;    // RTC Prescaler Load Register High
        };

        // RTC Prescaler Load Register Low
        struct PRLL : public RegisterWriteOnly<0x4000280c> {
            using Field = Field<0, 16>;    // RTC Prescaler Divider Register Low
        };

        // RTC Prescaler Divider Register High
        struct DIVH : public RegisterReadOnly<0x40002810> {
            using Field = Field<0, 4>;    // RTC prescaler divider register high
        };

        // RTC Prescaler Divider Register Low
        struct DIVL : public RegisterReadOnly<0x40002814> {
            using Field = Field<0, 16>;    // RTC prescaler divider register Low
        };

        // RTC Counter Register High
        struct CNTH : public Register<0x40002818> {
            using Field = Field<0, 16>;    // RTC counter register high
        };

        // RTC Counter Register Low
        struct CNTL : public Register<0x4000281c> {
            using Field = Field<0, 16>;    // RTC counter register Low
        };

        // RTC Alarm Register High
        struct ALRH : public RegisterWriteOnly<0x40002820> {
            using Field = Field<0, 16>;    // RTC alarm register high
        };

        // RTC Alarm Register Low
        struct ALRL : public RegisterWriteOnly<0x40002824> {
            using Field = Field<0, 16>;    // RTC alarm register low
        };

    };

    // Independent watchdog
    struct IWDG {
        // Key register (IWDG_KR)
        struct KR : public RegisterWriteOnly<0x40003000> {
            using KEY = Field<0, 16>;    // Key value
        };

        // Prescaler register (IWDG_PR)
        struct PR : public Register<0x40003004> {
            using Field = Field<0, 3>;    // Prescaler divider
        };

        // Reload register (IWDG_RLR)
        struct RLR : public Register<0x40003008> {
            using RL = Field<0, 12>;    // Watchdog counter reload value
        };

        // Status register (IWDG_SR)
        struct SR : public RegisterReadOnly<0x4000300c> {
            using PVU = Field<0, 1>;    // Watchdog prescaler value update
            using RVU = Field<1, 1>;    // Watchdog counter reload value update
        };

    };

    // Window watchdog
    struct WWDG {
        // Control register (WWDG_CR)
        struct CR : public Register<0x40002c00> {
            using T = Field<0, 7>;    // 7-bit counter (MSB to LSB)
            using WDGA = Field<7, 1>;    // Activation bit
        };

        // Configuration register (WWDG_CFR)
        struct CFR : public Register<0x40002c04> {
            using W = Field<0, 7>;    // 7-bit window value
            using WDGTB = Field<7, 2>;    // Timer Base
            using EWI = Field<9, 1>;    // Early Wakeup Interrupt
        };

        // Status register (WWDG_SR)
        struct SR : public Register<0x40002c08> {
            using EWI = Field<0, 1>;    // Early Wakeup Interrupt
        };

    };

    // General purpose timer
    struct TIM2 {
        // control register 1
        struct CR1 : public Register<0x40000000> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000004> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000008> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000000c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000010> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40000014> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40000018> {
            using OC2CE = Field<15, 1>;    // Output compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output compare 2 mode
            using OC2PE = Field<11, 1>;    // Output compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output compare 1 mode
            using OC1PE = Field<3, 1>;    // Output compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000018> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4000001c> {
            using O24CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000001c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000020> {
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000024> {
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40000028> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000002c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000034> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40000038> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4000003c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40000040> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40000048> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4000004c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

    };

    // General purpose timer
    struct TIM3 {
        // control register 1
        struct CR1 : public Register<0x40000400> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000404> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000408> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000040c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000410> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40000414> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40000418> {
            using OC2CE = Field<15, 1>;    // Output compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output compare 2 mode
            using OC2PE = Field<11, 1>;    // Output compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output compare 1 mode
            using OC1PE = Field<3, 1>;    // Output compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000418> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4000041c> {
            using O24CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000041c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000420> {
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000424> {
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40000428> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000042c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000434> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40000438> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4000043c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40000440> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40000448> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4000044c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

    };

    // General purpose timer
    struct TIM4 {
        // control register 1
        struct CR1 : public Register<0x40000800> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000804> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000808> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000080c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000810> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40000814> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40000818> {
            using OC2CE = Field<15, 1>;    // Output compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output compare 2 mode
            using OC2PE = Field<11, 1>;    // Output compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output compare 1 mode
            using OC1PE = Field<3, 1>;    // Output compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000818> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4000081c> {
            using O24CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000081c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000820> {
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000824> {
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40000828> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000082c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000834> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40000838> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4000083c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40000840> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40000848> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4000084c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

    };

    // General purpose timer
    struct TIM5 {
        // control register 1
        struct CR1 : public Register<0x40000c00> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000c04> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000c08> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x40000c0c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000c10> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40000c14> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40000c18> {
            using OC2CE = Field<15, 1>;    // Output compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output compare 2 mode
            using OC2PE = Field<11, 1>;    // Output compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output compare 1 mode
            using OC1PE = Field<3, 1>;    // Output compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000c18> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x40000c1c> {
            using O24CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x40000c1c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000c20> {
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000c24> {
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40000c28> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x40000c2c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000c34> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40000c38> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x40000c3c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40000c40> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40000c48> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x40000c4c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

    };

    // General purpose timer
    struct TIM9 {
        // control register 1
        struct CR1 : public Register<0x40014c00> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40014c04> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40014c08> {
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x40014c0c> {
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40014c10> {
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40014c14> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40014c18> {
            using OC2M = Field<12, 3>;    // Output Compare 2 mode
            using OC2PE = Field<11, 1>;    // Output Compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output Compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40014c18> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40014c20> {
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40014c24> {
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40014c28> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x40014c2c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40014c34> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40014c38> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

    };

    // General purpose timer
    struct TIM12 {
        // control register 1
        struct CR1 : public Register<0x40001800> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40001804> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40001808> {
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000180c> {
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40001810> {
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40001814> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40001818> {
            using OC2M = Field<12, 3>;    // Output Compare 2 mode
            using OC2PE = Field<11, 1>;    // Output Compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output Compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40001818> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40001820> {
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40001824> {
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40001828> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000182c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40001834> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40001838> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

    };

    // General purpose timer
    struct TIM10 {
        // control register 1
        struct CR1 : public Register<0x40015000> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40015004> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001500c> {
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40015010> {
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40015014> {
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register (output mode)
        struct CCMR1_Output : public Register<0x40015018> {
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register (input mode)
        struct CCMR1_Input : public Register<0x40015018> {
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40015020> {
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40015024> {
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40015028> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001502c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40015034> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

    };

    // General purpose timer
    struct TIM11 {
        // control register 1
        struct CR1 : public Register<0x40015400> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40015404> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001540c> {
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40015410> {
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40015414> {
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register (output mode)
        struct CCMR1_Output : public Register<0x40015418> {
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register (input mode)
        struct CCMR1_Input : public Register<0x40015418> {
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40015420> {
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40015424> {
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40015428> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001542c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40015434> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

    };

    // General purpose timer
    struct TIM13 {
        // control register 1
        struct CR1 : public Register<0x40001c00> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40001c04> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x40001c0c> {
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40001c10> {
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40001c14> {
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register (output mode)
        struct CCMR1_Output : public Register<0x40001c18> {
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register (input mode)
        struct CCMR1_Input : public Register<0x40001c18> {
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40001c20> {
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40001c24> {
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40001c28> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x40001c2c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40001c34> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

    };

    // General purpose timer
    struct TIM14 {
        // control register 1
        struct CR1 : public Register<0x40002000> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40002004> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000200c> {
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40002010> {
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40002014> {
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register (output mode)
        struct CCMR1_Output : public Register<0x40002018> {
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register (input mode)
        struct CCMR1_Input : public Register<0x40002018> {
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40002020> {
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40002024> {
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40002028> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000202c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40002034> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

    };

    // Basic timer
    struct TIM6 {
        // control register 1
        struct CR1 : public Register<0x40001000> {
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40001004> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000100c> {
            using UDE = Field<8, 1>;    // Update DMA request enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40001010> {
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40001014> {
            using UG = Field<0, 1>;    // Update generation
        };

        // counter
        struct CNT : public Register<0x40001024> {
            using Field = Field<0, 16>;    // Low counter value
        };

        // prescaler
        struct PSC : public Register<0x40001028> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000102c> {
            using Field = Field<0, 16>;    // Low Auto-reload value
        };

    };

    // Basic timer
    struct TIM7 {
        // control register 1
        struct CR1 : public Register<0x40001400> {
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40001404> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000140c> {
            using UDE = Field<8, 1>;    // Update DMA request enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40001410> {
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40001414> {
            using UG = Field<0, 1>;    // Update generation
        };

        // counter
        struct CNT : public Register<0x40001424> {
            using Field = Field<0, 16>;    // Low counter value
        };

        // prescaler
        struct PSC : public Register<0x40001428> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000142c> {
            using Field = Field<0, 16>;    // Low Auto-reload value
        };

    };

    // Inter integrated circuit
    struct I2C1 {
        // Control register 1
        struct CR1 : public Register<0x40005400> {
            using SWRST = Field<15, 1>;    // Software reset
            using ALERT = Field<13, 1>;    // SMBus alert
            using PEC = Field<12, 1>;    // Packet error checking
            using POS = Field<11, 1>;    // Acknowledge/PEC Position (for data reception)
            using ACK = Field<10, 1>;    // Acknowledge enable
            using STOP = Field<9, 1>;    // Stop generation
            using START = Field<8, 1>;    // Start generation
            using NOSTRETCH = Field<7, 1>;    // Clock stretching disable (Slave mode)
            using ENGC = Field<6, 1>;    // General call enable
            using ENPEC = Field<5, 1>;    // PEC enable
            using ENARP = Field<4, 1>;    // ARP enable
            using SMBTYPE = Field<3, 1>;    // SMBus type
            using SMBUS = Field<1, 1>;    // SMBus mode
            using PE = Field<0, 1>;    // Peripheral enable
        };

        // Control register 2
        struct CR2 : public Register<0x40005404> {
            using LAST = Field<12, 1>;    // DMA last transfer
            using DMAEN = Field<11, 1>;    // DMA requests enable
            using ITBUFEN = Field<10, 1>;    // Buffer interrupt enable
            using ITEVTEN = Field<9, 1>;    // Event interrupt enable
            using ITERREN = Field<8, 1>;    // Error interrupt enable
            using FREQ = Field<0, 6>;    // Peripheral clock frequency
        };

        // Own address register 1
        struct OAR1 : public Register<0x40005408> {
            using ADDMODE = Field<15, 1>;    // Addressing mode (slave mode)
            using ADD10 = Field<8, 2>;    // Interface address
            using ADD7 = Field<1, 7>;    // Interface address
            using ADD0 = Field<0, 1>;    // Interface address
        };

        // Own address register 2
        struct OAR2 : public Register<0x4000540c> {
            using ADD2 = Field<1, 7>;    // Interface address
            using ENDUAL = Field<0, 1>;    // Dual addressing mode enable
        };

        // Data register
        struct DR : public Register<0x40005410> {
            using Field = Field<0, 8>;    // 8-bit data register
        };

        // Status register 1
        struct SR1 : public Register<0x40005414> {
            using SMBALERT = Field<15, 1>;    // SMBus alert
            using TIMEOUT = Field<14, 1>;    // Timeout or Tlow error
            using PECERR = Field<12, 1>;    // PEC Error in reception
            using OVR = Field<11, 1>;    // Overrun/Underrun
            using AF = Field<10, 1>;    // Acknowledge failure
            using ARLO = Field<9, 1>;    // Arbitration lost (master mode)
            using BERR = Field<8, 1>;    // Bus error
            using TxE = Field<7, 1>;    // Data register empty (transmitters)
            using RxNE = Field<6, 1>;    // Data register not empty (receivers)
            using STOPF = Field<4, 1>;    // Stop detection (slave mode)
            using ADD10 = Field<3, 1>;    // 10-bit header sent (Master mode)
            using BTF = Field<2, 1>;    // Byte transfer finished
            using ADDR = Field<1, 1>;    // Address sent (master mode)/matched (slave mode)
            using SB = Field<0, 1>;    // Start bit (Master mode)
        };

        // Status register 2
        struct SR2 : public RegisterReadOnly<0x40005418> {
            using PEC = Field<8, 8>;    // acket error checking register
            using DUALF = Field<7, 1>;    // Dual flag (Slave mode)
            using SMBHOST = Field<6, 1>;    // SMBus host header (Slave mode)
            using SMBDEFAULT = Field<5, 1>;    // SMBus device default address (Slave mode)
            using GENCALL = Field<4, 1>;    // General call address (Slave mode)
            using TRA = Field<2, 1>;    // Transmitter/receiver
            using BUSY = Field<1, 1>;    // Bus busy
            using MSL = Field<0, 1>;    // Master/slave
        };

        // Clock control register
        struct CCR : public Register<0x4000541c> {
            using F_S = Field<15, 1>;    // I2C master mode selection
            using DUTY = Field<14, 1>;    // Fast mode duty cycle
            using Field = Field<0, 12>;    // Clock control register in Fast/Standard mode (Master mode)
        };

        // TRISE register
        struct TRISE : public Register<0x40005420> {
            using Field = Field<0, 6>;    // Maximum rise time in Fast/Standard mode (Master mode)
        };

    };

    // Inter integrated circuit
    struct I2C2 {
        // Control register 1
        struct CR1 : public Register<0x40005800> {
            using SWRST = Field<15, 1>;    // Software reset
            using ALERT = Field<13, 1>;    // SMBus alert
            using PEC = Field<12, 1>;    // Packet error checking
            using POS = Field<11, 1>;    // Acknowledge/PEC Position (for data reception)
            using ACK = Field<10, 1>;    // Acknowledge enable
            using STOP = Field<9, 1>;    // Stop generation
            using START = Field<8, 1>;    // Start generation
            using NOSTRETCH = Field<7, 1>;    // Clock stretching disable (Slave mode)
            using ENGC = Field<6, 1>;    // General call enable
            using ENPEC = Field<5, 1>;    // PEC enable
            using ENARP = Field<4, 1>;    // ARP enable
            using SMBTYPE = Field<3, 1>;    // SMBus type
            using SMBUS = Field<1, 1>;    // SMBus mode
            using PE = Field<0, 1>;    // Peripheral enable
        };

        // Control register 2
        struct CR2 : public Register<0x40005804> {
            using LAST = Field<12, 1>;    // DMA last transfer
            using DMAEN = Field<11, 1>;    // DMA requests enable
            using ITBUFEN = Field<10, 1>;    // Buffer interrupt enable
            using ITEVTEN = Field<9, 1>;    // Event interrupt enable
            using ITERREN = Field<8, 1>;    // Error interrupt enable
            using FREQ = Field<0, 6>;    // Peripheral clock frequency
        };

        // Own address register 1
        struct OAR1 : public Register<0x40005808> {
            using ADDMODE = Field<15, 1>;    // Addressing mode (slave mode)
            using ADD10 = Field<8, 2>;    // Interface address
            using ADD7 = Field<1, 7>;    // Interface address
            using ADD0 = Field<0, 1>;    // Interface address
        };

        // Own address register 2
        struct OAR2 : public Register<0x4000580c> {
            using ADD2 = Field<1, 7>;    // Interface address
            using ENDUAL = Field<0, 1>;    // Dual addressing mode enable
        };

        // Data register
        struct DR : public Register<0x40005810> {
            using Field = Field<0, 8>;    // 8-bit data register
        };

        // Status register 1
        struct SR1 : public Register<0x40005814> {
            using SMBALERT = Field<15, 1>;    // SMBus alert
            using TIMEOUT = Field<14, 1>;    // Timeout or Tlow error
            using PECERR = Field<12, 1>;    // PEC Error in reception
            using OVR = Field<11, 1>;    // Overrun/Underrun
            using AF = Field<10, 1>;    // Acknowledge failure
            using ARLO = Field<9, 1>;    // Arbitration lost (master mode)
            using BERR = Field<8, 1>;    // Bus error
            using TxE = Field<7, 1>;    // Data register empty (transmitters)
            using RxNE = Field<6, 1>;    // Data register not empty (receivers)
            using STOPF = Field<4, 1>;    // Stop detection (slave mode)
            using ADD10 = Field<3, 1>;    // 10-bit header sent (Master mode)
            using BTF = Field<2, 1>;    // Byte transfer finished
            using ADDR = Field<1, 1>;    // Address sent (master mode)/matched (slave mode)
            using SB = Field<0, 1>;    // Start bit (Master mode)
        };

        // Status register 2
        struct SR2 : public RegisterReadOnly<0x40005818> {
            using PEC = Field<8, 8>;    // acket error checking register
            using DUALF = Field<7, 1>;    // Dual flag (Slave mode)
            using SMBHOST = Field<6, 1>;    // SMBus host header (Slave mode)
            using SMBDEFAULT = Field<5, 1>;    // SMBus device default address (Slave mode)
            using GENCALL = Field<4, 1>;    // General call address (Slave mode)
            using TRA = Field<2, 1>;    // Transmitter/receiver
            using BUSY = Field<1, 1>;    // Bus busy
            using MSL = Field<0, 1>;    // Master/slave
        };

        // Clock control register
        struct CCR : public Register<0x4000581c> {
            using F_S = Field<15, 1>;    // I2C master mode selection
            using DUTY = Field<14, 1>;    // Fast mode duty cycle
            using Field = Field<0, 12>;    // Clock control register in Fast/Standard mode (Master mode)
        };

        // TRISE register
        struct TRISE : public Register<0x40005820> {
            using Field = Field<0, 6>;    // Maximum rise time in Fast/Standard mode (Master mode)
        };

    };

    // Serial peripheral interface
    struct SPI1 {
        // control register 1
        struct CR1 : public Register<0x40013000> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using DFF = Field<11, 1>;    // Data frame format
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40013004> {
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using SSOE = Field<2, 1>;    // SS output enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
        };

        // status register
        struct SR : public Register<0x40013008> {
            using BSY = Field<7, 1>;    // Busy flag
            using OVR = Field<6, 1>;    // Overrun flag
            using MODF = Field<5, 1>;    // Mode fault
            using CRCERR = Field<4, 1>;    // CRC error flag
            using UDR = Field<3, 1>;    // Underrun flag
            using CHSIDE = Field<2, 1>;    // Channel side
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using RXNE = Field<0, 1>;    // Receive buffer not empty
        };

        // data register
        struct DR : public Register<0x4001300c> {
            using Field = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40013010> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public RegisterReadOnly<0x40013014> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public RegisterReadOnly<0x40013018> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

        // I2S configuration register
        struct I2SCFGR : public Register<0x4001301c> {
            using I2SMOD = Field<11, 1>;    // I2S mode selection
            using I2SE = Field<10, 1>;    // I2S Enable
            using I2SCFG = Field<8, 2>;    // I2S configuration mode
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using CKPOL = Field<3, 1>;    // Steady state clock polarity
            using DATLEN = Field<1, 2>;    // Data length to be transferred
            using CHLEN = Field<0, 1>;    // Channel length (number of bits per audio channel)
        };

        // I2S prescaler register
        struct I2SPR : public Register<0x40013020> {
            using MCKOE = Field<9, 1>;    // Master clock output enable
            using ODD = Field<8, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<0, 8>;    // I2S Linear prescaler
        };

    };

    // Serial peripheral interface
    struct SPI2 {
        // control register 1
        struct CR1 : public Register<0x40003800> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using DFF = Field<11, 1>;    // Data frame format
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40003804> {
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using SSOE = Field<2, 1>;    // SS output enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
        };

        // status register
        struct SR : public Register<0x40003808> {
            using BSY = Field<7, 1>;    // Busy flag
            using OVR = Field<6, 1>;    // Overrun flag
            using MODF = Field<5, 1>;    // Mode fault
            using CRCERR = Field<4, 1>;    // CRC error flag
            using UDR = Field<3, 1>;    // Underrun flag
            using CHSIDE = Field<2, 1>;    // Channel side
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using RXNE = Field<0, 1>;    // Receive buffer not empty
        };

        // data register
        struct DR : public Register<0x4000380c> {
            using Field = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40003810> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public RegisterReadOnly<0x40003814> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public RegisterReadOnly<0x40003818> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

        // I2S configuration register
        struct I2SCFGR : public Register<0x4000381c> {
            using I2SMOD = Field<11, 1>;    // I2S mode selection
            using I2SE = Field<10, 1>;    // I2S Enable
            using I2SCFG = Field<8, 2>;    // I2S configuration mode
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using CKPOL = Field<3, 1>;    // Steady state clock polarity
            using DATLEN = Field<1, 2>;    // Data length to be transferred
            using CHLEN = Field<0, 1>;    // Channel length (number of bits per audio channel)
        };

        // I2S prescaler register
        struct I2SPR : public Register<0x40003820> {
            using MCKOE = Field<9, 1>;    // Master clock output enable
            using ODD = Field<8, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<0, 8>;    // I2S Linear prescaler
        };

    };

    // Serial peripheral interface
    struct SPI3 {
        // control register 1
        struct CR1 : public Register<0x40003c00> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using DFF = Field<11, 1>;    // Data frame format
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40003c04> {
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using SSOE = Field<2, 1>;    // SS output enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
        };

        // status register
        struct SR : public Register<0x40003c08> {
            using BSY = Field<7, 1>;    // Busy flag
            using OVR = Field<6, 1>;    // Overrun flag
            using MODF = Field<5, 1>;    // Mode fault
            using CRCERR = Field<4, 1>;    // CRC error flag
            using UDR = Field<3, 1>;    // Underrun flag
            using CHSIDE = Field<2, 1>;    // Channel side
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using RXNE = Field<0, 1>;    // Receive buffer not empty
        };

        // data register
        struct DR : public Register<0x40003c0c> {
            using Field = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40003c10> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public RegisterReadOnly<0x40003c14> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public RegisterReadOnly<0x40003c18> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

        // I2S configuration register
        struct I2SCFGR : public Register<0x40003c1c> {
            using I2SMOD = Field<11, 1>;    // I2S mode selection
            using I2SE = Field<10, 1>;    // I2S Enable
            using I2SCFG = Field<8, 2>;    // I2S configuration mode
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using CKPOL = Field<3, 1>;    // Steady state clock polarity
            using DATLEN = Field<1, 2>;    // Data length to be transferred
            using CHLEN = Field<0, 1>;    // Channel length (number of bits per audio channel)
        };

        // I2S prescaler register
        struct I2SPR : public Register<0x40003c20> {
            using MCKOE = Field<9, 1>;    // Master clock output enable
            using ODD = Field<8, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<0, 8>;    // I2S Linear prescaler
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART1 {
        // Status register
        struct SR : public Register<0x40013800> {
            using CTS = Field<9, 1>;    // CTS flag
            using LBD = Field<8, 1>;    // LIN break detection flag
            using TXE = Field<7, 1>;    // Transmit data register empty
            using TC = Field<6, 1>;    // Transmission complete
            using RXNE = Field<5, 1>;    // Read data register not empty
            using IDLE = Field<4, 1>;    // IDLE line detected
            using ORE = Field<3, 1>;    // Overrun error
            using NE = Field<2, 1>;    // Noise error flag
            using FE = Field<1, 1>;    // Framing error
            using PE = Field<0, 1>;    // Parity error
        };

        // Data register
        struct DR : public Register<0x40013804> {
            using Field = Field<0, 9>;    // Data value
        };

        // Baud rate register
        struct BRR : public Register<0x40013808> {
            using DIV_Mantissa = Field<4, 12>;    // mantissa of USARTDIV
            using DIV_Fraction = Field<0, 4>;    // fraction of USARTDIV
        };

        // Control register 1
        struct CR1 : public Register<0x4001380c> {
            using UE = Field<13, 1>;    // USART enable
            using M = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // TXE interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using RWU = Field<1, 1>;    // Receiver wakeup
            using SBK = Field<0, 1>;    // Send break
        };

        // Control register 2
        struct CR2 : public Register<0x40013810> {
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // lin break detection length
            using ADD = Field<0, 4>;    // Address of the USART node
        };

        // Control register 3
        struct CR3 : public Register<0x40013814> {
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // IrDA low-power
            using IREN = Field<1, 1>;    // IrDA mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40013818> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART2 {
        // Status register
        struct SR : public Register<0x40004400> {
            using CTS = Field<9, 1>;    // CTS flag
            using LBD = Field<8, 1>;    // LIN break detection flag
            using TXE = Field<7, 1>;    // Transmit data register empty
            using TC = Field<6, 1>;    // Transmission complete
            using RXNE = Field<5, 1>;    // Read data register not empty
            using IDLE = Field<4, 1>;    // IDLE line detected
            using ORE = Field<3, 1>;    // Overrun error
            using NE = Field<2, 1>;    // Noise error flag
            using FE = Field<1, 1>;    // Framing error
            using PE = Field<0, 1>;    // Parity error
        };

        // Data register
        struct DR : public Register<0x40004404> {
            using Field = Field<0, 9>;    // Data value
        };

        // Baud rate register
        struct BRR : public Register<0x40004408> {
            using DIV_Mantissa = Field<4, 12>;    // mantissa of USARTDIV
            using DIV_Fraction = Field<0, 4>;    // fraction of USARTDIV
        };

        // Control register 1
        struct CR1 : public Register<0x4000440c> {
            using UE = Field<13, 1>;    // USART enable
            using M = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // TXE interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using RWU = Field<1, 1>;    // Receiver wakeup
            using SBK = Field<0, 1>;    // Send break
        };

        // Control register 2
        struct CR2 : public Register<0x40004410> {
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // lin break detection length
            using ADD = Field<0, 4>;    // Address of the USART node
        };

        // Control register 3
        struct CR3 : public Register<0x40004414> {
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // IrDA low-power
            using IREN = Field<1, 1>;    // IrDA mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40004418> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART3 {
        // Status register
        struct SR : public Register<0x40004800> {
            using CTS = Field<9, 1>;    // CTS flag
            using LBD = Field<8, 1>;    // LIN break detection flag
            using TXE = Field<7, 1>;    // Transmit data register empty
            using TC = Field<6, 1>;    // Transmission complete
            using RXNE = Field<5, 1>;    // Read data register not empty
            using IDLE = Field<4, 1>;    // IDLE line detected
            using ORE = Field<3, 1>;    // Overrun error
            using NE = Field<2, 1>;    // Noise error flag
            using FE = Field<1, 1>;    // Framing error
            using PE = Field<0, 1>;    // Parity error
        };

        // Data register
        struct DR : public Register<0x40004804> {
            using Field = Field<0, 9>;    // Data value
        };

        // Baud rate register
        struct BRR : public Register<0x40004808> {
            using DIV_Mantissa = Field<4, 12>;    // mantissa of USARTDIV
            using DIV_Fraction = Field<0, 4>;    // fraction of USARTDIV
        };

        // Control register 1
        struct CR1 : public Register<0x4000480c> {
            using UE = Field<13, 1>;    // USART enable
            using M = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // TXE interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using RWU = Field<1, 1>;    // Receiver wakeup
            using SBK = Field<0, 1>;    // Send break
        };

        // Control register 2
        struct CR2 : public Register<0x40004810> {
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // lin break detection length
            using ADD = Field<0, 4>;    // Address of the USART node
        };

        // Control register 3
        struct CR3 : public Register<0x40004814> {
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // IrDA low-power
            using IREN = Field<1, 1>;    // IrDA mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40004818> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

    };

    // Digital to analog converter
    struct DAC {
        // Control register (DAC_CR)
        struct CR : public Register<0x40007400> {
            using EN1 = Field<0, 1>;    // DAC channel1 enable
            using BOFF1 = Field<1, 1>;    // DAC channel1 output buffer disable
            using TEN1 = Field<2, 1>;    // DAC channel1 trigger enable
            using TSEL1 = Field<3, 3>;    // DAC channel1 trigger selection
            using WAVE1 = Field<6, 2>;    // DAC channel1 noise/triangle wave generation enable
            using MAMP1 = Field<8, 4>;    // DAC channel1 mask/amplitude selector
            using DMAEN1 = Field<12, 1>;    // DAC channel1 DMA enable
            using EN2 = Field<16, 1>;    // DAC channel2 enable
            using BOFF2 = Field<17, 1>;    // DAC channel2 output buffer disable
            using TEN2 = Field<18, 1>;    // DAC channel2 trigger enable
            using TSEL2 = Field<19, 3>;    // DAC channel2 trigger selection
            using WAVE2 = Field<22, 2>;    // DAC channel2 noise/triangle wave generation enable
            using MAMP2 = Field<24, 4>;    // DAC channel2 mask/amplitude selector
            using DMAEN2 = Field<28, 1>;    // DAC channel2 DMA enable
        };

        // DAC software trigger register (DAC_SWTRIGR)
        struct SWTRIGR : public RegisterWriteOnly<0x40007404> {
            using SWTRIG1 = Field<0, 1>;    // DAC channel1 software trigger
            using SWTRIG2 = Field<1, 1>;    // DAC channel2 software trigger
        };

        // DAC channel1 12-bit right-aligned data holding register(DAC_DHR12R1)
        struct DHR12R1 : public Register<0x40007408> {
            using DACC1DHR = Field<0, 12>;    // DAC channel1 12-bit right-aligned data
        };

        // DAC channel1 12-bit left aligned data holding register (DAC_DHR12L1)
        struct DHR12L1 : public Register<0x4000740c> {
            using DACC1DHR = Field<4, 12>;    // DAC channel1 12-bit left-aligned data
        };

        // DAC channel1 8-bit right aligned data holding register (DAC_DHR8R1)
        struct DHR8R1 : public Register<0x40007410> {
            using DACC1DHR = Field<0, 8>;    // DAC channel1 8-bit right-aligned data
        };

        // DAC channel2 12-bit right aligned data holding register (DAC_DHR12R2)
        struct DHR12R2 : public Register<0x40007414> {
            using DACC2DHR = Field<0, 12>;    // DAC channel2 12-bit right-aligned data
        };

        // DAC channel2 12-bit left aligned data holding register (DAC_DHR12L2)
        struct DHR12L2 : public Register<0x40007418> {
            using DACC2DHR = Field<4, 12>;    // DAC channel2 12-bit left-aligned data
        };

        // DAC channel2 8-bit right-aligned data holding register (DAC_DHR8R2)
        struct DHR8R2 : public Register<0x4000741c> {
            using DACC2DHR = Field<0, 8>;    // DAC channel2 8-bit right-aligned data
        };

        // Dual DAC 12-bit right-aligned data holding register (DAC_DHR12RD), Bits 31:28 Reserved, Bits 15:12 Reserved
        struct DHR12RD : public Register<0x40007420> {
            using DACC1DHR = Field<0, 12>;    // DAC channel1 12-bit right-aligned data
            using DACC2DHR = Field<16, 12>;    // DAC channel2 12-bit right-aligned data
        };

        // DUAL DAC 12-bit left aligned data holding register (DAC_DHR12LD), Bits 19:16 Reserved, Bits 3:0 Reserved
        struct DHR12LD : public Register<0x40007424> {
            using DACC1DHR = Field<4, 12>;    // DAC channel1 12-bit left-aligned data
            using DACC2DHR = Field<20, 12>;    // DAC channel2 12-bit right-aligned data
        };

        // DUAL DAC 8-bit right aligned data holding register (DAC_DHR8RD), Bits 31:16 Reserved
        struct DHR8RD : public Register<0x40007428> {
            using DACC1DHR = Field<0, 8>;    // DAC channel1 8-bit right-aligned data
            using DACC2DHR = Field<8, 8>;    // DAC channel2 8-bit right-aligned data
        };

        // DAC channel1 data output register (DAC_DOR1)
        struct DOR1 : public RegisterReadOnly<0x4000742c> {
            using DACC1DOR = Field<0, 12>;    // DAC channel1 data output
        };

        // DAC channel2 data output register (DAC_DOR2)
        struct DOR2 : public RegisterReadOnly<0x40007430> {
            using DACC2DOR = Field<0, 12>;    // DAC channel2 data output
        };

    };

    // Debug support
    struct DBG {
        // DBGMCU_IDCODE
        struct IDCODE : public RegisterReadOnly<0xe0042000> {
            using DEV_ID = Field<0, 12>;    // DEV_ID
            using REV_ID = Field<16, 16>;    // REV_ID
        };

        // DBGMCU_CR
        struct CR : public Register<0xe0042004> {
            using DBG_SLEEP = Field<0, 1>;    // DBG_SLEEP
            using DBG_STOP = Field<1, 1>;    // DBG_STOP
            using DBG_STANDBY = Field<2, 1>;    // DBG_STANDBY
            using TRACE_IOEN = Field<5, 1>;    // TRACE_IOEN
            using TRACE_MODE = Field<6, 2>;    // TRACE_MODE
            using DBG_IWDG_STOP = Field<8, 1>;    // DBG_IWDG_STOP
            using DBG_WWDG_STOP = Field<9, 1>;    // DBG_WWDG_STOP
            using DBG_TIM1_STOP = Field<10, 1>;    // DBG_TIM1_STOP
            using DBG_TIM2_STOP = Field<11, 1>;    // DBG_TIM2_STOP
            using DBG_TIM3_STOP = Field<12, 1>;    // DBG_TIM3_STOP
            using DBG_TIM4_STOP = Field<13, 1>;    // DBG_TIM4_STOP
            using DBG_I2C1_SMBUS_TIMEOUT = Field<15, 1>;    // DBG_I2C1_SMBUS_TIMEOUT
            using DBG_I2C2_SMBUS_TIMEOUT = Field<16, 1>;    // DBG_I2C2_SMBUS_TIMEOUT
            using DBG_TIM5_STOP = Field<18, 1>;    // DBG_TIM5_STOP
            using DBG_TIM6_STOP = Field<19, 1>;    // DBG_TIM6_STOP
            using DBG_TIM7_STOP = Field<20, 1>;    // DBG_TIM7_STOP
            using DBG_TIM15_STOP = Field<22, 1>;    // TIM15 counter stopped when core is halted
            using DBG_TIM16_STOP = Field<23, 1>;    // TIM16 counter stopped when core is halted
            using DBG_TIM17_STOP = Field<24, 1>;    // TIM17 counter stopped when core is halted
            using DBG_TIM12_STOP = Field<25, 1>;    // TIM12 counter stopped when core is halted
            using DBG_TIM13_STOP = Field<26, 1>;    // TIM13 counter stopped when core is halted
            using DBG_TIM14_STOP = Field<27, 1>;    // TIM14 counter stopped when core is halted
        };

    };

    // Universal asynchronous receiver transmitter
    struct UART4 {
        // UART4_SR
        struct SR : public Register<0x40004c00> {
            using PE = Field<0, 1>;    // Parity error
            using FE = Field<1, 1>;    // Framing error
            using NE = Field<2, 1>;    // Noise error flag
            using ORE = Field<3, 1>;    // Overrun error
            using IDLE = Field<4, 1>;    // IDLE line detected
            using RXNE = Field<5, 1>;    // Read data register not empty
            using TC = Field<6, 1>;    // Transmission complete
            using TXE = Field<7, 1>;    // Transmit data register empty
            using LBD = Field<8, 1>;    // LIN break detection flag
        };

        // UART4_DR
        struct DR : public Register<0x40004c04> {
            using Field = Field<0, 9>;    // DR
        };

        // UART4_BRR
        struct BRR : public Register<0x40004c08> {
            using DIV_Fraction = Field<0, 4>;    // DIV_Fraction
            using DIV_Mantissa = Field<4, 12>;    // DIV_Mantissa
        };

        // UART4_CR1
        struct CR1 : public Register<0x40004c0c> {
            using SBK = Field<0, 1>;    // Send break
            using RWU = Field<1, 1>;    // Receiver wakeup
            using RE = Field<2, 1>;    // Receiver enable
            using TE = Field<3, 1>;    // Transmitter enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using TXEIE = Field<7, 1>;    // TXE interrupt enable
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using PS = Field<9, 1>;    // Parity selection
            using PCE = Field<10, 1>;    // Parity control enable
            using WAKE = Field<11, 1>;    // Wakeup method
            using M = Field<12, 1>;    // Word length
            using UE = Field<13, 1>;    // USART enable
        };

        // UART4_CR2
        struct CR2 : public Register<0x40004c10> {
            using ADD = Field<0, 4>;    // Address of the USART node
            using LBDL = Field<5, 1>;    // lin break detection length
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using STOP = Field<12, 2>;    // STOP bits
            using LINEN = Field<14, 1>;    // LIN mode enable
        };

        // UART4_CR3
        struct CR3 : public Register<0x40004c14> {
            using EIE = Field<0, 1>;    // Error interrupt enable
            using IREN = Field<1, 1>;    // IrDA mode enable
            using IRLP = Field<2, 1>;    // IrDA low-power
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using DMAT = Field<7, 1>;    // DMA enable transmitter
        };

    };

    // Universal asynchronous receiver transmitter
    struct UART5 {
        // UART4_SR
        struct SR : public Register<0x40005000> {
            using PE = Field<0, 1>;    // PE
            using FE = Field<1, 1>;    // FE
            using NE = Field<2, 1>;    // NE
            using ORE = Field<3, 1>;    // ORE
            using IDLE = Field<4, 1>;    // IDLE
            using RXNE = Field<5, 1>;    // RXNE
            using TC = Field<6, 1>;    // TC
            using TXE = Field<7, 1>;    // TXE
            using LBD = Field<8, 1>;    // LBD
        };

        // UART4_DR
        struct DR : public Register<0x40005004> {
            using Field = Field<0, 9>;    // DR
        };

        // UART4_BRR
        struct BRR : public Register<0x40005008> {
            using DIV_Fraction = Field<0, 4>;    // DIV_Fraction
            using DIV_Mantissa = Field<4, 12>;    // DIV_Mantissa
        };

        // UART4_CR1
        struct CR1 : public Register<0x4000500c> {
            using SBK = Field<0, 1>;    // SBK
            using RWU = Field<1, 1>;    // RWU
            using RE = Field<2, 1>;    // RE
            using TE = Field<3, 1>;    // TE
            using IDLEIE = Field<4, 1>;    // IDLEIE
            using RXNEIE = Field<5, 1>;    // RXNEIE
            using TCIE = Field<6, 1>;    // TCIE
            using TXEIE = Field<7, 1>;    // TXEIE
            using PEIE = Field<8, 1>;    // PEIE
            using PS = Field<9, 1>;    // PS
            using PCE = Field<10, 1>;    // PCE
            using WAKE = Field<11, 1>;    // WAKE
            using M = Field<12, 1>;    // M
            using UE = Field<13, 1>;    // UE
        };

        // UART4_CR2
        struct CR2 : public Register<0x40005010> {
            using ADD = Field<0, 4>;    // ADD
            using LBDL = Field<5, 1>;    // LBDL
            using LBDIE = Field<6, 1>;    // LBDIE
            using STOP = Field<12, 2>;    // STOP
            using LINEN = Field<14, 1>;    // LINEN
        };

        // UART4_CR3
        struct CR3 : public Register<0x40005014> {
            using EIE = Field<0, 1>;    // Error interrupt enable
            using IREN = Field<1, 1>;    // IrDA mode enable
            using IRLP = Field<2, 1>;    // IrDA low-power
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using DMAT = Field<7, 1>;    // DMA enable transmitter
        };

    };

    // CRC calculation unit
    struct CRC {
        // Data register
        struct DR : public Register<0x40023000> {
            using Field = Field<0, 32>;    // Data Register
        };

        // Independent Data register
        struct IDR : public Register<0x40023004> {
            using Field = Field<0, 8>;    // Independent Data register
        };

        // Control register
        struct CR : public RegisterWriteOnly<0x40023008> {
            using RESET = Field<0, 1>;    // Reset bit
        };

    };

    // FLASH
    struct FLASH {
        // Flash access control register
        struct ACR : public Register<0x40022000> {
            using LATENCY = Field<0, 3>;    // Latency
            using HLFCYA = Field<3, 1>;    // Flash half cycle access enable
            using PRFTBE = Field<4, 1>;    // Prefetch buffer enable
            using PRFTBS = Field<5, 1>;    // Prefetch buffer status
        };

        // Flash key register
        struct KEYR : public RegisterWriteOnly<0x40022004> {
            using KEY = Field<0, 32>;    // FPEC key
        };

        // Flash option key register
        struct OPTKEYR : public RegisterWriteOnly<0x40022008> {
            using OPTKEY = Field<0, 32>;    // Option byte key
        };

        // Status register
        struct SR : public Register<0x4002200c> {
            using EOP = Field<5, 1>;    // End of operation
            using WRPRTERR = Field<4, 1>;    // Write protection error
            using PGERR = Field<2, 1>;    // Programming error
            using BSY = Field<0, 1>;    // Busy
        };

        // Control register
        struct CR : public Register<0x40022010> {
            using PG = Field<0, 1>;    // Programming
            using PER = Field<1, 1>;    // Page Erase
            using MER = Field<2, 1>;    // Mass Erase
            using OPTPG = Field<4, 1>;    // Option byte programming
            using OPTER = Field<5, 1>;    // Option byte erase
            using STRT = Field<6, 1>;    // Start
            using LOCK = Field<7, 1>;    // Lock
            using OPTWRE = Field<9, 1>;    // Option bytes write enable
            using ERRIE = Field<10, 1>;    // Error interrupt enable
            using EOPIE = Field<12, 1>;    // End of operation interrupt enable
        };

        // Flash address register
        struct AR : public RegisterWriteOnly<0x40022014> {
            using FAR = Field<0, 32>;    // Flash Address
        };

        // Option byte register
        struct OBR : public RegisterReadOnly<0x4002201c> {
            using OPTERR = Field<0, 1>;    // Option byte error
            using RDPRT = Field<1, 1>;    // Read protection
            using WDG_SW = Field<2, 1>;    // WDG_SW
            using nRST_STOP = Field<3, 1>;    // nRST_STOP
            using nRST_STDBY = Field<4, 1>;    // nRST_STDBY
            using Data0 = Field<10, 8>;    // Data0
            using Data1 = Field<18, 8>;    // Data1
        };

        // Write protection register
        struct WRPR : public RegisterReadOnly<0x40022020> {
            using WRP = Field<0, 32>;    // Write protect
        };

    };

    // Backup registers
    struct BKP {
        // Backup data register (BKP_DR)
        struct DR1 : public Register<0x40006c00> {
            using D1 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR2 : public Register<0x40006c04> {
            using D2 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR3 : public Register<0x40006c08> {
            using D3 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR4 : public Register<0x40006c0c> {
            using D4 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR5 : public Register<0x40006c10> {
            using D5 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR6 : public Register<0x40006c14> {
            using D6 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR7 : public Register<0x40006c18> {
            using D7 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR8 : public Register<0x40006c1c> {
            using D8 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR9 : public Register<0x40006c20> {
            using D9 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR10 : public Register<0x40006c24> {
            using D10 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR11 : public Register<0x40006c3c> {
            using Field = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR12 : public Register<0x40006c40> {
            using Field = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR13 : public Register<0x40006c44> {
            using Field = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR14 : public Register<0x40006c48> {
            using D14 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR15 : public Register<0x40006c4c> {
            using D15 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR16 : public Register<0x40006c50> {
            using D16 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR17 : public Register<0x40006c54> {
            using D17 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR18 : public Register<0x40006c58> {
            using D18 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR19 : public Register<0x40006c5c> {
            using D19 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR20 : public Register<0x40006c60> {
            using D20 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR21 : public Register<0x40006c64> {
            using D21 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR22 : public Register<0x40006c68> {
            using D22 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR23 : public Register<0x40006c6c> {
            using D23 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR24 : public Register<0x40006c70> {
            using D24 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR25 : public Register<0x40006c74> {
            using D25 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR26 : public Register<0x40006c78> {
            using D26 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR27 : public Register<0x40006c7c> {
            using D27 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR28 : public Register<0x40006c80> {
            using D28 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR29 : public Register<0x40006c84> {
            using D29 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR30 : public Register<0x40006c88> {
            using D30 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR31 : public Register<0x40006c8c> {
            using D31 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR32 : public Register<0x40006c90> {
            using D32 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR33 : public Register<0x40006c94> {
            using D33 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR34 : public Register<0x40006c98> {
            using D34 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR35 : public Register<0x40006c9c> {
            using D35 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR36 : public Register<0x40006ca0> {
            using D36 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR37 : public Register<0x40006ca4> {
            using D37 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR38 : public Register<0x40006ca8> {
            using D38 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR39 : public Register<0x40006cac> {
            using D39 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR40 : public Register<0x40006cb0> {
            using D40 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR41 : public Register<0x40006cb4> {
            using D41 = Field<0, 16>;    // Backup data
        };

        // Backup data register (BKP_DR)
        struct DR42 : public Register<0x40006cb8> {
            using D42 = Field<0, 16>;    // Backup data
        };

        // RTC clock calibration register (BKP_RTCCR)
        struct RTCCR : public Register<0x40006c28> {
            using CAL = Field<0, 7>;    // Calibration value
            using CCO = Field<7, 1>;    // Calibration Clock Output
            using ASOE = Field<8, 1>;    // Alarm or second output enable
            using ASOS = Field<9, 1>;    // Alarm or second output selection
        };

        // Backup control register (BKP_CR)
        struct CR : public Register<0x40006c2c> {
            using TPE = Field<0, 1>;    // Tamper pin enable
            using TPAL = Field<1, 1>;    // Tamper pin active level
        };

        // BKP_CSR control/status register (BKP_CSR)
        struct CSR : public Register<0x40006c30> {
            using CTE = Field<0, 1>;    // Clear Tamper event
            using CTI = Field<1, 1>;    // Clear Tamper Interrupt
            using TPIE = Field<2, 1>;    // Tamper Pin interrupt enable
            using TEF = Field<8, 1>;    // Tamper Event Flag
            using TIF = Field<9, 1>;    // Tamper Interrupt Flag
        };

    };

    // Analog to digital converter
    struct ADC1 {
        // status register
        struct SR : public Register<0x40012400> {
            using STRT = Field<4, 1>;    // Regular channel start flag
            using JSTRT = Field<3, 1>;    // Injected channel start flag
            using JEOC = Field<2, 1>;    // Injected channel end of conversion
            using EOC = Field<1, 1>;    // Regular channel end of conversion
            using AWD = Field<0, 1>;    // Analog watchdog flag
        };

        // control register 1
        struct CR1 : public Register<0x40012404> {
            using AWDEN = Field<23, 1>;    // Analog watchdog enable on regular channels
            using JAWDEN = Field<22, 1>;    // Analog watchdog enable on injected channels
            using DUALMOD = Field<16, 4>;    // Dual mode selection
            using DISCNUM = Field<13, 3>;    // Discontinuous mode channel count
            using JDISCEN = Field<12, 1>;    // Discontinuous mode on injected channels
            using DISCEN = Field<11, 1>;    // Discontinuous mode on regular channels
            using JAUTO = Field<10, 1>;    // Automatic injected group conversion
            using AWDSGL = Field<9, 1>;    // Enable the watchdog on a single channel in scan mode
            using SCAN = Field<8, 1>;    // Scan mode
            using JEOCIE = Field<7, 1>;    // Interrupt enable for injected channels
            using AWDIE = Field<6, 1>;    // Analog watchdog interrupt enable
            using EOCIE = Field<5, 1>;    // Interrupt enable for EOC
            using AWDCH = Field<0, 5>;    // Analog watchdog channel select bits
        };

        // control register 2
        struct CR2 : public Register<0x40012408> {
            using TSVREFE = Field<23, 1>;    // Temperature sensor and VREFINT enable
            using SWSTART = Field<22, 1>;    // Start conversion of regular channels
            using JSWSTART = Field<21, 1>;    // Start conversion of injected channels
            using EXTTRIG = Field<20, 1>;    // External trigger conversion mode for regular channels
            using EXTSEL = Field<17, 3>;    // External event select for regular group
            using JEXTTRIG = Field<15, 1>;    // External trigger conversion mode for injected channels
            using JEXTSEL = Field<12, 3>;    // External event select for injected group
            using ALIGN = Field<11, 1>;    // Data alignment
            using DMA = Field<8, 1>;    // Direct memory access mode
            using RSTCAL = Field<3, 1>;    // Reset calibration
            using CAL = Field<2, 1>;    // A/D calibration
            using CONT = Field<1, 1>;    // Continuous conversion
            using ADON = Field<0, 1>;    // A/D converter ON / OFF
        };

        // sample time register 1
        struct SMPR1 : public Register<0x4001240c> {
            using SMP10 = Field<0, 3>;    // Channel 10 sample time selection
            using SMP11 = Field<3, 3>;    // Channel 11 sample time selection
            using SMP12 = Field<6, 3>;    // Channel 12 sample time selection
            using SMP13 = Field<9, 3>;    // Channel 13 sample time selection
            using SMP14 = Field<12, 3>;    // Channel 14 sample time selection
            using SMP15 = Field<15, 3>;    // Channel 15 sample time selection
            using SMP16 = Field<18, 3>;    // Channel 16 sample time selection
            using SMP17 = Field<21, 3>;    // Channel 17 sample time selection
        };

        // sample time register 2
        struct SMPR2 : public Register<0x40012410> {
            using SMP0 = Field<0, 3>;    // Channel 0 sample time selection
            using SMP1 = Field<3, 3>;    // Channel 1 sample time selection
            using SMP2 = Field<6, 3>;    // Channel 2 sample time selection
            using SMP3 = Field<9, 3>;    // Channel 3 sample time selection
            using SMP4 = Field<12, 3>;    // Channel 4 sample time selection
            using SMP5 = Field<15, 3>;    // Channel 5 sample time selection
            using SMP6 = Field<18, 3>;    // Channel 6 sample time selection
            using SMP7 = Field<21, 3>;    // Channel 7 sample time selection
            using SMP8 = Field<24, 3>;    // Channel 8 sample time selection
            using SMP9 = Field<27, 3>;    // Channel 9 sample time selection
        };

        // injected channel data offset register x
        struct JOFR1 : public Register<0x40012414> {
            using JOFFSET1 = Field<0, 12>;    // Data offset for injected channel x
        };

        // injected channel data offset register x
        struct JOFR2 : public Register<0x40012418> {
            using JOFFSET2 = Field<0, 12>;    // Data offset for injected channel x
        };

        // injected channel data offset register x
        struct JOFR3 : public Register<0x4001241c> {
            using JOFFSET3 = Field<0, 12>;    // Data offset for injected channel x
        };

        // injected channel data offset register x
        struct JOFR4 : public Register<0x40012420> {
            using JOFFSET4 = Field<0, 12>;    // Data offset for injected channel x
        };

        // watchdog higher threshold register
        struct HTR : public Register<0x40012424> {
            using HT = Field<0, 12>;    // Analog watchdog higher threshold
        };

        // watchdog lower threshold register
        struct LTR : public Register<0x40012428> {
            using LT = Field<0, 12>;    // Analog watchdog lower threshold
        };

        // regular sequence register 1
        struct SQR1 : public Register<0x4001242c> {
            using L = Field<20, 4>;    // Regular channel sequence length
            using SQ16 = Field<15, 5>;    // 16th conversion in regular sequence
            using SQ15 = Field<10, 5>;    // 15th conversion in regular sequence
            using SQ14 = Field<5, 5>;    // 14th conversion in regular sequence
            using SQ13 = Field<0, 5>;    // 13th conversion in regular sequence
        };

        // regular sequence register 2
        struct SQR2 : public Register<0x40012430> {
            using SQ12 = Field<25, 5>;    // 12th conversion in regular sequence
            using SQ11 = Field<20, 5>;    // 11th conversion in regular sequence
            using SQ10 = Field<15, 5>;    // 10th conversion in regular sequence
            using SQ9 = Field<10, 5>;    // 9th conversion in regular sequence
            using SQ8 = Field<5, 5>;    // 8th conversion in regular sequence
            using SQ7 = Field<0, 5>;    // 7th conversion in regular sequence
        };

        // regular sequence register 3
        struct SQR3 : public Register<0x40012434> {
            using SQ6 = Field<25, 5>;    // 6th conversion in regular sequence
            using SQ5 = Field<20, 5>;    // 5th conversion in regular sequence
            using SQ4 = Field<15, 5>;    // 4th conversion in regular sequence
            using SQ3 = Field<10, 5>;    // 3rd conversion in regular sequence
            using SQ2 = Field<5, 5>;    // 2nd conversion in regular sequence
            using SQ1 = Field<0, 5>;    // 1st conversion in regular sequence
        };

        // injected sequence register
        struct JSQR : public Register<0x40012438> {
            using JL = Field<20, 2>;    // Injected sequence length
            using JSQ4 = Field<15, 5>;    // 4th conversion in injected sequence
            using JSQ3 = Field<10, 5>;    // 3rd conversion in injected sequence
            using JSQ2 = Field<5, 5>;    // 2nd conversion in injected sequence
            using JSQ1 = Field<0, 5>;    // 1st conversion in injected sequence
        };

        // injected data register x
        struct JDR1 : public RegisterReadOnly<0x4001243c> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // injected data register x
        struct JDR2 : public RegisterReadOnly<0x40012440> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // injected data register x
        struct JDR3 : public RegisterReadOnly<0x40012444> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // injected data register x
        struct JDR4 : public RegisterReadOnly<0x40012448> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // regular data register
        struct DR : public RegisterReadOnly<0x4001244c> {
            using DATA = Field<0, 16>;    // Regular data
        };

    };

    // USB on the go full speed
    struct OTG_FS_DEVICE {
        // OTG_FS device configuration register (OTG_FS_DCFG)
        struct FS_DCFG : public Register<0x50000800> {
            using DSPD = Field<0, 2>;    // Device speed
            using NZLSOHSK = Field<2, 1>;    // Non-zero-length status OUT handshake
            using DAD = Field<4, 7>;    // Device address
            using PFIVL = Field<11, 2>;    // Periodic frame interval
        };

        // OTG_FS device control register (OTG_FS_DCTL)
        struct FS_DCTL : public Register<0x50000804> {
            using RWUSIG = Field<0, 1>;    // Remote wakeup signaling
            using SDIS = Field<1, 1>;    // Soft disconnect
            using GINSTS = Field<2, 1>;    // Global IN NAK status
            using GONSTS = Field<3, 1>;    // Global OUT NAK status
            using TCTL = Field<4, 3>;    // Test control
            using SGINAK = Field<7, 1>;    // Set global IN NAK
            using CGINAK = Field<8, 1>;    // Clear global IN NAK
            using SGONAK = Field<9, 1>;    // Set global OUT NAK
            using CGONAK = Field<10, 1>;    // Clear global OUT NAK
            using POPRGDNE = Field<11, 1>;    // Power-on programming done
        };

        // OTG_FS device status register (OTG_FS_DSTS)
        struct FS_DSTS : public RegisterReadOnly<0x50000808> {
            using SUSPSTS = Field<0, 1>;    // Suspend status
            using ENUMSPD = Field<1, 2>;    // Enumerated speed
            using EERR = Field<3, 1>;    // Erratic error
            using FNSOF = Field<8, 14>;    // Frame number of the received SOF
        };

        // OTG_FS device IN endpoint common interrupt mask register (OTG_FS_DIEPMSK)
        struct FS_DIEPMSK : public Register<0x50000810> {
            using XFRCM = Field<0, 1>;    // Transfer completed interrupt mask
            using EPDM = Field<1, 1>;    // Endpoint disabled interrupt mask
            using TOM = Field<3, 1>;    // Timeout condition mask (Non-isochronous endpoints)
            using ITTXFEMSK = Field<4, 1>;    // IN token received when TxFIFO empty mask
            using INEPNMM = Field<5, 1>;    // IN token received with EP mismatch mask
            using INEPNEM = Field<6, 1>;    // IN endpoint NAK effective mask
        };

        // OTG_FS device OUT endpoint common interrupt mask register (OTG_FS_DOEPMSK)
        struct FS_DOEPMSK : public Register<0x50000814> {
            using XFRCM = Field<0, 1>;    // Transfer completed interrupt mask
            using EPDM = Field<1, 1>;    // Endpoint disabled interrupt mask
            using STUPM = Field<3, 1>;    // SETUP phase done mask
            using OTEPDM = Field<4, 1>;    // OUT token received when endpoint disabled mask
        };

        // OTG_FS device all endpoints interrupt register (OTG_FS_DAINT)
        struct FS_DAINT : public RegisterReadOnly<0x50000818> {
            using IEPINT = Field<0, 16>;    // IN endpoint interrupt bits
            using OEPINT = Field<16, 16>;    // OUT endpoint interrupt bits
        };

        // OTG_FS all endpoints interrupt mask register (OTG_FS_DAINTMSK)
        struct FS_DAINTMSK : public Register<0x5000081c> {
            using IEPM = Field<0, 16>;    // IN EP interrupt mask bits
            using OEPINT = Field<16, 16>;    // OUT endpoint interrupt bits
        };

        // OTG_FS device VBUS discharge time register
        struct DVBUSDIS : public Register<0x50000828> {
            using VBUSDT = Field<0, 16>;    // Device VBUS discharge time
        };

        // OTG_FS device VBUS pulsing time register
        struct DVBUSPULSE : public Register<0x5000082c> {
            using DVBUSP = Field<0, 12>;    // Device VBUS pulsing time
        };

        // OTG_FS device IN endpoint FIFO empty interrupt mask register
        struct DIEPEMPMSK : public Register<0x50000834> {
            using INEPTXFEM = Field<0, 16>;    // IN EP Tx FIFO empty interrupt mask bits
        };

        // OTG_FS device control IN endpoint 0 control register (OTG_FS_DIEPCTL0)
        struct FS_DIEPCTL0 : public Register<0x50000900> {
            using MPSIZ = Field<0, 2>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using STALL = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-1 control register
        struct DIEPCTL1 : public Register<0x50000920> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SODDFRM_SD1PID = Field<29, 1>;    // SODDFRM/SD1PID
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID/SEVNFRM
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using TXFNUM = Field<22, 4>;    // TXFNUM
            using Stall = Field<21, 1>;    // Stall
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EONUM_DPID = Field<16, 1>;    // EONUM/DPID
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 11>;    // MPSIZ
        };

        // OTG device endpoint-2 control register
        struct DIEPCTL2 : public Register<0x50000940> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID/SEVNFRM
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using TXFNUM = Field<22, 4>;    // TXFNUM
            using Stall = Field<21, 1>;    // Stall
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EONUM_DPID = Field<16, 1>;    // EONUM/DPID
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 11>;    // MPSIZ
        };

        // OTG device endpoint-3 control register
        struct DIEPCTL3 : public Register<0x50000960> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID/SEVNFRM
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using TXFNUM = Field<22, 4>;    // TXFNUM
            using Stall = Field<21, 1>;    // Stall
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EONUM_DPID = Field<16, 1>;    // EONUM/DPID
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 11>;    // MPSIZ
        };

        // device endpoint-0 control register
        struct DOEPCTL0 : public Register<0x50000b00> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using Stall = Field<21, 1>;    // Stall
            using SNPM = Field<20, 1>;    // SNPM
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 2>;    // MPSIZ
        };

        // device endpoint-1 control register
        struct DOEPCTL1 : public Register<0x50000b20> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID/SEVNFRM
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using Stall = Field<21, 1>;    // Stall
            using SNPM = Field<20, 1>;    // SNPM
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EONUM_DPID = Field<16, 1>;    // EONUM/DPID
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 11>;    // MPSIZ
        };

        // device endpoint-2 control register
        struct DOEPCTL2 : public Register<0x50000b40> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID/SEVNFRM
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using Stall = Field<21, 1>;    // Stall
            using SNPM = Field<20, 1>;    // SNPM
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EONUM_DPID = Field<16, 1>;    // EONUM/DPID
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 11>;    // MPSIZ
        };

        // device endpoint-3 control register
        struct DOEPCTL3 : public Register<0x50000b60> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID/SEVNFRM
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using Stall = Field<21, 1>;    // Stall
            using SNPM = Field<20, 1>;    // SNPM
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EONUM_DPID = Field<16, 1>;    // EONUM/DPID
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 11>;    // MPSIZ
        };

        // device endpoint-x interrupt register
        struct DIEPINT0 : public Register<0x50000908> {
            using TXFE = Field<7, 1>;    // TXFE
            using INEPNE = Field<6, 1>;    // INEPNE
            using ITTXFE = Field<4, 1>;    // ITTXFE
            using TOC = Field<3, 1>;    // TOC
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-1 interrupt register
        struct DIEPINT1 : public Register<0x50000928> {
            using TXFE = Field<7, 1>;    // TXFE
            using INEPNE = Field<6, 1>;    // INEPNE
            using ITTXFE = Field<4, 1>;    // ITTXFE
            using TOC = Field<3, 1>;    // TOC
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-2 interrupt register
        struct DIEPINT2 : public Register<0x50000948> {
            using TXFE = Field<7, 1>;    // TXFE
            using INEPNE = Field<6, 1>;    // INEPNE
            using ITTXFE = Field<4, 1>;    // ITTXFE
            using TOC = Field<3, 1>;    // TOC
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-3 interrupt register
        struct DIEPINT3 : public Register<0x50000968> {
            using TXFE = Field<7, 1>;    // TXFE
            using INEPNE = Field<6, 1>;    // INEPNE
            using ITTXFE = Field<4, 1>;    // ITTXFE
            using TOC = Field<3, 1>;    // TOC
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-0 interrupt register
        struct DOEPINT0 : public Register<0x50000b08> {
            using B2BSTUP = Field<6, 1>;    // B2BSTUP
            using OTEPDIS = Field<4, 1>;    // OTEPDIS
            using STUP = Field<3, 1>;    // STUP
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-1 interrupt register
        struct DOEPINT1 : public Register<0x50000b28> {
            using B2BSTUP = Field<6, 1>;    // B2BSTUP
            using OTEPDIS = Field<4, 1>;    // OTEPDIS
            using STUP = Field<3, 1>;    // STUP
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-2 interrupt register
        struct DOEPINT2 : public Register<0x50000b48> {
            using B2BSTUP = Field<6, 1>;    // B2BSTUP
            using OTEPDIS = Field<4, 1>;    // OTEPDIS
            using STUP = Field<3, 1>;    // STUP
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-3 interrupt register
        struct DOEPINT3 : public Register<0x50000b68> {
            using B2BSTUP = Field<6, 1>;    // B2BSTUP
            using OTEPDIS = Field<4, 1>;    // OTEPDIS
            using STUP = Field<3, 1>;    // STUP
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-0 transfer size register
        struct DIEPTSIZ0 : public Register<0x50000910> {
            using PKTCNT = Field<19, 2>;    // Packet count
            using XFRSIZ = Field<0, 7>;    // Transfer size
        };

        // device OUT endpoint-0 transfer size register
        struct DOEPTSIZ0 : public Register<0x50000b10> {
            using STUPCNT = Field<29, 2>;    // SETUP packet count
            using PKTCNT = Field<19, 1>;    // Packet count
            using XFRSIZ = Field<0, 7>;    // Transfer size
        };

        // device endpoint-1 transfer size register
        struct DIEPTSIZ1 : public Register<0x50000930> {
            using MCNT = Field<29, 2>;    // Multi count
            using PKTCNT = Field<19, 10>;    // Packet count
            using XFRSIZ = Field<0, 19>;    // Transfer size
        };

        // device endpoint-2 transfer size register
        struct DIEPTSIZ2 : public Register<0x50000950> {
            using MCNT = Field<29, 2>;    // Multi count
            using PKTCNT = Field<19, 10>;    // Packet count
            using XFRSIZ = Field<0, 19>;    // Transfer size
        };

        // device endpoint-3 transfer size register
        struct DIEPTSIZ3 : public Register<0x50000970> {
            using MCNT = Field<29, 2>;    // Multi count
            using PKTCNT = Field<19, 10>;    // Packet count
            using XFRSIZ = Field<0, 19>;    // Transfer size
        };

        // OTG_FS device IN endpoint transmit FIFO status register
        struct DTXFSTS0 : public RegisterReadOnly<0x50000918> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space available
        };

        // OTG_FS device IN endpoint transmit FIFO status register
        struct DTXFSTS1 : public RegisterReadOnly<0x50000938> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space available
        };

        // OTG_FS device IN endpoint transmit FIFO status register
        struct DTXFSTS2 : public RegisterReadOnly<0x50000958> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space available
        };

        // OTG_FS device IN endpoint transmit FIFO status register
        struct DTXFSTS3 : public RegisterReadOnly<0x50000978> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space available
        };

        // device OUT endpoint-1 transfer size register
        struct DOEPTSIZ1 : public Register<0x50000b30> {
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
            using PKTCNT = Field<19, 10>;    // Packet count
            using XFRSIZ = Field<0, 19>;    // Transfer size
        };

        // device OUT endpoint-2 transfer size register
        struct DOEPTSIZ2 : public Register<0x50000b50> {
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
            using PKTCNT = Field<19, 10>;    // Packet count
            using XFRSIZ = Field<0, 19>;    // Transfer size
        };

        // device OUT endpoint-3 transfer size register
        struct DOEPTSIZ3 : public Register<0x50000b70> {
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
            using PKTCNT = Field<19, 10>;    // Packet count
            using XFRSIZ = Field<0, 19>;    // Transfer size
        };

    };

    // USB on the go full speed
    struct OTG_FS_GLOBAL {
        // OTG_FS control and status register (OTG_FS_GOTGCTL)
        struct FS_GOTGCTL : public Register<0x50000000> {
            using SRQSCS = Field<0, 1>;    // Session request success
            using SRQ = Field<1, 1>;    // Session request
            using HNGSCS = Field<8, 1>;    // Host negotiation success
            using HNPRQ = Field<9, 1>;    // HNP request
            using HSHNPEN = Field<10, 1>;    // Host set HNP enable
            using DHNPEN = Field<11, 1>;    // Device HNP enabled
            using CIDSTS = Field<16, 1>;    // Connector ID status
            using DBCT = Field<17, 1>;    // Long/short debounce time
            using ASVLD = Field<18, 1>;    // A-session valid
            using BSVLD = Field<19, 1>;    // B-session valid
        };

        // OTG_FS interrupt register (OTG_FS_GOTGINT)
        struct FS_GOTGINT : public Register<0x50000004> {
            using SEDET = Field<2, 1>;    // Session end detected
            using SRSSCHG = Field<8, 1>;    // Session request success status change
            using HNSSCHG = Field<9, 1>;    // Host negotiation success status change
            using HNGDET = Field<17, 1>;    // Host negotiation detected
            using ADTOCHG = Field<18, 1>;    // A-device timeout change
            using DBCDNE = Field<19, 1>;    // Debounce done
        };

        // OTG_FS AHB configuration register (OTG_FS_GAHBCFG)
        struct FS_GAHBCFG : public Register<0x50000008> {
            using GINT = Field<0, 1>;    // Global interrupt mask
            using TXFELVL = Field<7, 1>;    // TxFIFO empty level
            using PTXFELVL = Field<8, 1>;    // Periodic TxFIFO empty level
        };

        // OTG_FS USB configuration register (OTG_FS_GUSBCFG)
        struct FS_GUSBCFG : public Register<0x5000000c> {
            using TOCAL = Field<0, 3>;    // FS timeout calibration
            using PHYSEL = Field<6, 1>;    // Full Speed serial transceiver select
            using SRPCAP = Field<8, 1>;    // SRP-capable
            using HNPCAP = Field<9, 1>;    // HNP-capable
            using TRDT = Field<10, 4>;    // USB turnaround time
            using FHMOD = Field<29, 1>;    // Force host mode
            using FDMOD = Field<30, 1>;    // Force device mode
            using CTXPKT = Field<31, 1>;    // Corrupt Tx packet
        };

        // OTG_FS reset register (OTG_FS_GRSTCTL)
        struct FS_GRSTCTL : public Register<0x50000010> {
            using CSRST = Field<0, 1>;    // Core soft reset
            using HSRST = Field<1, 1>;    // HCLK soft reset
            using FCRST = Field<2, 1>;    // Host frame counter reset
            using RXFFLSH = Field<4, 1>;    // RxFIFO flush
            using TXFFLSH = Field<5, 1>;    // TxFIFO flush
            using TXFNUM = Field<6, 5>;    // TxFIFO number
            using AHBIDL = Field<31, 1>;    // AHB master idle
        };

        // OTG_FS core interrupt register (OTG_FS_GINTSTS)
        struct FS_GINTSTS : public Register<0x50000014> {
            using CMOD = Field<0, 1>;    // Current mode of operation
            using MMIS = Field<1, 1>;    // Mode mismatch interrupt
            using OTGINT = Field<2, 1>;    // OTG interrupt
            using SOF = Field<3, 1>;    // Start of frame
            using RXFLVL = Field<4, 1>;    // RxFIFO non-empty
            using NPTXFE = Field<5, 1>;    // Non-periodic TxFIFO empty
            using GINAKEFF = Field<6, 1>;    // Global IN non-periodic NAK effective
            using GOUTNAKEFF = Field<7, 1>;    // Global OUT NAK effective
            using ESUSP = Field<10, 1>;    // Early suspend
            using USBSUSP = Field<11, 1>;    // USB suspend
            using USBRST = Field<12, 1>;    // USB reset
            using ENUMDNE = Field<13, 1>;    // Enumeration done
            using ISOODRP = Field<14, 1>;    // Isochronous OUT packet dropped interrupt
            using EOPF = Field<15, 1>;    // End of periodic frame interrupt
            using IEPINT = Field<18, 1>;    // IN endpoint interrupt
            using OEPINT = Field<19, 1>;    // OUT endpoint interrupt
            using IISOIXFR = Field<20, 1>;    // Incomplete isochronous IN transfer
            using IPXFR_INCOMPISOOUT = Field<21, 1>;    // Incomplete periodic transfer(Host mode)/Incomplete isochronous OUT transfer(Device mode)
            using HPRTINT = Field<24, 1>;    // Host port interrupt
            using HCINT = Field<25, 1>;    // Host channels interrupt
            using PTXFE = Field<26, 1>;    // Periodic TxFIFO empty
            using CIDSCHG = Field<28, 1>;    // Connector ID status change
            using DISCINT = Field<29, 1>;    // Disconnect detected interrupt
            using SRQINT = Field<30, 1>;    // Session request/new session detected interrupt
            using WKUPINT = Field<31, 1>;    // Resume/remote wakeup detected interrupt
        };

        // OTG_FS interrupt mask register (OTG_FS_GINTMSK)
        struct FS_GINTMSK : public Register<0x50000018> {
            using MMISM = Field<1, 1>;    // Mode mismatch interrupt mask
            using OTGINT = Field<2, 1>;    // OTG interrupt mask
            using SOFM = Field<3, 1>;    // Start of frame mask
            using RXFLVLM = Field<4, 1>;    // Receive FIFO non-empty mask
            using NPTXFEM = Field<5, 1>;    // Non-periodic TxFIFO empty mask
            using GINAKEFFM = Field<6, 1>;    // Global non-periodic IN NAK effective mask
            using GONAKEFFM = Field<7, 1>;    // Global OUT NAK effective mask
            using ESUSPM = Field<10, 1>;    // Early suspend mask
            using USBSUSPM = Field<11, 1>;    // USB suspend mask
            using USBRST = Field<12, 1>;    // USB reset mask
            using ENUMDNEM = Field<13, 1>;    // Enumeration done mask
            using ISOODRPM = Field<14, 1>;    // Isochronous OUT packet dropped interrupt mask
            using EOPFM = Field<15, 1>;    // End of periodic frame interrupt mask
            using EPMISM = Field<17, 1>;    // Endpoint mismatch interrupt mask
            using IEPINT = Field<18, 1>;    // IN endpoints interrupt mask
            using OEPINT = Field<19, 1>;    // OUT endpoints interrupt mask
            using IISOIXFRM = Field<20, 1>;    // Incomplete isochronous IN transfer mask
            using IPXFRM_IISOOXFRM = Field<21, 1>;    // Incomplete periodic transfer mask(Host mode)/Incomplete isochronous OUT transfer mask(Device mode)
            using PRTIM = Field<24, 1>;    // Host port interrupt mask
            using HCIM = Field<25, 1>;    // Host channels interrupt mask
            using PTXFEM = Field<26, 1>;    // Periodic TxFIFO empty mask
            using CIDSCHGM = Field<28, 1>;    // Connector ID status change mask
            using DISCINT = Field<29, 1>;    // Disconnect detected interrupt mask
            using SRQIM = Field<30, 1>;    // Session request/new session detected interrupt mask
            using WUIM = Field<31, 1>;    // Resume/remote wakeup detected interrupt mask
        };

        // OTG_FS Receive status debug read(Device mode)
        struct FS_GRXSTSR_Device : public RegisterReadOnly<0x5000001c> {
            using EPNUM = Field<0, 4>;    // Endpoint number
            using BCNT = Field<4, 11>;    // Byte count
            using DPID = Field<15, 2>;    // Data PID
            using PKTSTS = Field<17, 4>;    // Packet status
            using FRMNUM = Field<21, 4>;    // Frame number
        };

        // OTG_FS Receive status debug read(Host mode)
        struct FS_GRXSTSR_Host : public RegisterReadOnly<0x5000001c> {
            using EPNUM = Field<0, 4>;    // Endpoint number
            using BCNT = Field<4, 11>;    // Byte count
            using DPID = Field<15, 2>;    // Data PID
            using PKTSTS = Field<17, 4>;    // Packet status
            using FRMNUM = Field<21, 4>;    // Frame number
        };

        // OTG_FS Receive FIFO size register (OTG_FS_GRXFSIZ)
        struct FS_GRXFSIZ : public Register<0x50000024> {
            using RXFD = Field<0, 16>;    // RxFIFO depth
        };

        // OTG_FS non-periodic transmit FIFO size register (Device mode)
        struct FS_GNPTXFSIZ_Device : public Register<0x50000028> {
            using TX0FSA = Field<0, 16>;    // Endpoint 0 transmit RAM start address
            using TX0FD = Field<16, 16>;    // Endpoint 0 TxFIFO depth
        };

        // OTG_FS non-periodic transmit FIFO size register (Host mode)
        struct FS_GNPTXFSIZ_Host : public Register<0x50000028> {
            using NPTXFSA = Field<0, 16>;    // Non-periodic transmit RAM start address
            using NPTXFD = Field<16, 16>;    // Non-periodic TxFIFO depth
        };

        // OTG_FS non-periodic transmit FIFO/queue status register (OTG_FS_GNPTXSTS)
        struct FS_GNPTXSTS : public RegisterReadOnly<0x5000002c> {
            using NPTXFSAV = Field<0, 16>;    // Non-periodic TxFIFO space available
            using NPTQXSAV = Field<16, 8>;    // Non-periodic transmit request queue space available
            using NPTXQTOP = Field<24, 7>;    // Top of the non-periodic transmit request queue
        };

        // OTG_FS general core configuration register (OTG_FS_GCCFG)
        struct FS_GCCFG : public Register<0x50000038> {
            using PWRDWN = Field<16, 1>;    // Power down
            using VBUSASEN = Field<18, 1>;    // Enable the VBUS sensing device
            using VBUSBSEN = Field<19, 1>;    // Enable the VBUS sensing device
            using SOFOUTEN = Field<20, 1>;    // SOF output enable
        };

        // core ID register
        struct FS_CID : public Register<0x5000003c> {
            using PRODUCT_ID = Field<0, 32>;    // Product ID field
        };

        // OTG_FS Host periodic transmit FIFO size register (OTG_FS_HPTXFSIZ)
        struct FS_HPTXFSIZ : public Register<0x50000100> {
            using PTXSA = Field<0, 16>;    // Host periodic TxFIFO start address
            using PTXFSIZ = Field<16, 16>;    // Host periodic TxFIFO depth
        };

        // OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF2)
        struct FS_DIEPTXF1 : public Register<0x50000104> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFO2 transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF3)
        struct FS_DIEPTXF2 : public Register<0x50000108> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFO3 transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF4)
        struct FS_DIEPTXF3 : public Register<0x5000010c> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFO4 transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

    };

    // USB on the go full speed
    struct OTG_FS_HOST {
        // OTG_FS host configuration register (OTG_FS_HCFG)
        struct FS_HCFG : public Register<0x50000400> {
            using FSLSPCS = Field<0, 2>;    // FS/LS PHY clock select
            using FSLSS = Field<2, 1>;    // FS- and LS-only support
        };

        // OTG_FS Host frame interval register
        struct HFIR : public Register<0x50000404> {
            using FRIVL = Field<0, 16>;    // Frame interval
        };

        // OTG_FS host frame number/frame time remaining register (OTG_FS_HFNUM)
        struct FS_HFNUM : public RegisterReadOnly<0x50000408> {
            using FRNUM = Field<0, 16>;    // Frame number
            using FTREM = Field<16, 16>;    // Frame time remaining
        };

        // OTG_FS_Host periodic transmit FIFO/queue status register (OTG_FS_HPTXSTS)
        struct FS_HPTXSTS : public Register<0x50000410> {
            using PTXFSAVL = Field<0, 16>;    // Periodic transmit data FIFO space available
            using PTXQSAV = Field<16, 8>;    // Periodic transmit request queue space available
            using PTXQTOP = Field<24, 8>;    // Top of the periodic transmit request queue
        };

        // OTG_FS Host all channels interrupt register
        struct HAINT : public RegisterReadOnly<0x50000414> {
            using Field = Field<0, 16>;    // Channel interrupts
        };

        // OTG_FS host all channels interrupt mask register
        struct HAINTMSK : public Register<0x50000418> {
            using HAINTM = Field<0, 16>;    // Channel interrupt mask
        };

        // OTG_FS host port control and status register (OTG_FS_HPRT)
        struct FS_HPRT : public Register<0x50000440> {
            using PCSTS = Field<0, 1>;    // Port connect status
            using PCDET = Field<1, 1>;    // Port connect detected
            using PENA = Field<2, 1>;    // Port enable
            using PENCHNG = Field<3, 1>;    // Port enable/disable change
            using POCA = Field<4, 1>;    // Port overcurrent active
            using POCCHNG = Field<5, 1>;    // Port overcurrent change
            using PRES = Field<6, 1>;    // Port resume
            using PSUSP = Field<7, 1>;    // Port suspend
            using PRST = Field<8, 1>;    // Port reset
            using PLSTS = Field<10, 2>;    // Port line status
            using PPWR = Field<12, 1>;    // Port power
            using PTCTL = Field<13, 4>;    // Port test control
            using PSPD = Field<17, 2>;    // Port speed
        };

        // OTG_FS host channel-0 characteristics register (OTG_FS_HCCHAR0)
        struct FS_HCCHAR0 : public Register<0x50000500> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-1 characteristics register (OTG_FS_HCCHAR1)
        struct FS_HCCHAR1 : public Register<0x50000520> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-2 characteristics register (OTG_FS_HCCHAR2)
        struct FS_HCCHAR2 : public Register<0x50000540> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-3 characteristics register (OTG_FS_HCCHAR3)
        struct FS_HCCHAR3 : public Register<0x50000560> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-4 characteristics register (OTG_FS_HCCHAR4)
        struct FS_HCCHAR4 : public Register<0x50000580> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-5 characteristics register (OTG_FS_HCCHAR5)
        struct FS_HCCHAR5 : public Register<0x500005a0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-6 characteristics register (OTG_FS_HCCHAR6)
        struct FS_HCCHAR6 : public Register<0x500005c0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-7 characteristics register (OTG_FS_HCCHAR7)
        struct FS_HCCHAR7 : public Register<0x500005e0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-0 interrupt register (OTG_FS_HCINT0)
        struct FS_HCINT0 : public Register<0x50000508> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-1 interrupt register (OTG_FS_HCINT1)
        struct FS_HCINT1 : public Register<0x50000528> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-2 interrupt register (OTG_FS_HCINT2)
        struct FS_HCINT2 : public Register<0x50000548> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-3 interrupt register (OTG_FS_HCINT3)
        struct FS_HCINT3 : public Register<0x50000568> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-4 interrupt register (OTG_FS_HCINT4)
        struct FS_HCINT4 : public Register<0x50000588> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-5 interrupt register (OTG_FS_HCINT5)
        struct FS_HCINT5 : public Register<0x500005a8> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-6 interrupt register (OTG_FS_HCINT6)
        struct FS_HCINT6 : public Register<0x500005c8> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-7 interrupt register (OTG_FS_HCINT7)
        struct FS_HCINT7 : public Register<0x500005e8> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-0 mask register (OTG_FS_HCINTMSK0)
        struct FS_HCINTMSK0 : public Register<0x5000050c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-1 mask register (OTG_FS_HCINTMSK1)
        struct FS_HCINTMSK1 : public Register<0x5000052c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-2 mask register (OTG_FS_HCINTMSK2)
        struct FS_HCINTMSK2 : public Register<0x5000054c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-3 mask register (OTG_FS_HCINTMSK3)
        struct FS_HCINTMSK3 : public Register<0x5000056c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-4 mask register (OTG_FS_HCINTMSK4)
        struct FS_HCINTMSK4 : public Register<0x5000058c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-5 mask register (OTG_FS_HCINTMSK5)
        struct FS_HCINTMSK5 : public Register<0x500005ac> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-6 mask register (OTG_FS_HCINTMSK6)
        struct FS_HCINTMSK6 : public Register<0x500005cc> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-7 mask register (OTG_FS_HCINTMSK7)
        struct FS_HCINTMSK7 : public Register<0x500005ec> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-0 transfer size register
        struct FS_HCTSIZ0 : public Register<0x50000510> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-1 transfer size register
        struct FS_HCTSIZ1 : public Register<0x50000530> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-2 transfer size register
        struct FS_HCTSIZ2 : public Register<0x50000550> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-3 transfer size register
        struct FS_HCTSIZ3 : public Register<0x50000570> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-x transfer size register
        struct FS_HCTSIZ4 : public Register<0x50000590> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-5 transfer size register
        struct FS_HCTSIZ5 : public Register<0x500005b0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-6 transfer size register
        struct FS_HCTSIZ6 : public Register<0x500005d0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-7 transfer size register
        struct FS_HCTSIZ7 : public Register<0x500005f0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

    };

    // USB on the go full speed
    struct OTG_FS_PWRCLK {
        // OTG_FS power and clock gating control register
        struct FS_PCGCCTL : public Register<0x50000e00> {
            using STPPCLK = Field<0, 1>;    // Stop PHY clock
            using GATEHCLK = Field<1, 1>;    // Gate HCLK
            using PHYSUSP = Field<4, 1>;    // PHY Suspended
        };

    };

    // Controller area network
    struct CAN1 {
        // master control register
        struct MCR : public Register<0x40006400> {
            using DBF = Field<16, 1>;    // DBF
            using RESET = Field<15, 1>;    // RESET
            using TTCM = Field<7, 1>;    // TTCM
            using ABOM = Field<6, 1>;    // ABOM
            using AWUM = Field<5, 1>;    // AWUM
            using NART = Field<4, 1>;    // NART
            using RFLM = Field<3, 1>;    // RFLM
            using TXFP = Field<2, 1>;    // TXFP
            using SLEEP = Field<1, 1>;    // SLEEP
            using INRQ = Field<0, 1>;    // INRQ
        };

        // master status register
        struct MSR : public Register<0x40006404> {
            using RX = Field<11, 1>;    // RX
            using SAMP = Field<10, 1>;    // SAMP
            using RXM = Field<9, 1>;    // RXM
            using TXM = Field<8, 1>;    // TXM
            using SLAKI = Field<4, 1>;    // SLAKI
            using WKUI = Field<3, 1>;    // WKUI
            using ERRI = Field<2, 1>;    // ERRI
            using SLAK = Field<1, 1>;    // SLAK
            using INAK = Field<0, 1>;    // INAK
        };

        // transmit status register
        struct TSR : public Register<0x40006408> {
            using LOW2 = Field<31, 1>;    // Lowest priority flag for mailbox 2
            using LOW1 = Field<30, 1>;    // Lowest priority flag for mailbox 1
            using LOW0 = Field<29, 1>;    // Lowest priority flag for mailbox 0
            using TME2 = Field<28, 1>;    // Lowest priority flag for mailbox 2
            using TME1 = Field<27, 1>;    // Lowest priority flag for mailbox 1
            using TME0 = Field<26, 1>;    // Lowest priority flag for mailbox 0
            using CODE = Field<24, 2>;    // CODE
            using ABRQ2 = Field<23, 1>;    // ABRQ2
            using TERR2 = Field<19, 1>;    // TERR2
            using ALST2 = Field<18, 1>;    // ALST2
            using TXOK2 = Field<17, 1>;    // TXOK2
            using RQCP2 = Field<16, 1>;    // RQCP2
            using ABRQ1 = Field<15, 1>;    // ABRQ1
            using TERR1 = Field<11, 1>;    // TERR1
            using ALST1 = Field<10, 1>;    // ALST1
            using TXOK1 = Field<9, 1>;    // TXOK1
            using RQCP1 = Field<8, 1>;    // RQCP1
            using ABRQ0 = Field<7, 1>;    // ABRQ0
            using TERR0 = Field<3, 1>;    // TERR0
            using ALST0 = Field<2, 1>;    // ALST0
            using TXOK0 = Field<1, 1>;    // TXOK0
            using RQCP0 = Field<0, 1>;    // RQCP0
        };

        // receive FIFO 0 register
        struct RF0R : public Register<0x4000640c> {
            using RFOM0 = Field<5, 1>;    // RFOM0
            using FOVR0 = Field<4, 1>;    // FOVR0
            using FULL0 = Field<3, 1>;    // FULL0
            using FMP0 = Field<0, 2>;    // FMP0
        };

        // receive FIFO 1 register
        struct RF1R : public Register<0x40006410> {
            using RFOM1 = Field<5, 1>;    // RFOM1
            using FOVR1 = Field<4, 1>;    // FOVR1
            using FULL1 = Field<3, 1>;    // FULL1
            using FMP1 = Field<0, 2>;    // FMP1
        };

        // interrupt enable register
        struct IER : public Register<0x40006414> {
            using SLKIE = Field<17, 1>;    // SLKIE
            using WKUIE = Field<16, 1>;    // WKUIE
            using ERRIE = Field<15, 1>;    // ERRIE
            using LECIE = Field<11, 1>;    // LECIE
            using BOFIE = Field<10, 1>;    // BOFIE
            using EPVIE = Field<9, 1>;    // EPVIE
            using EWGIE = Field<8, 1>;    // EWGIE
            using FOVIE1 = Field<6, 1>;    // FOVIE1
            using FFIE1 = Field<5, 1>;    // FFIE1
            using FMPIE1 = Field<4, 1>;    // FMPIE1
            using FOVIE0 = Field<3, 1>;    // FOVIE0
            using FFIE0 = Field<2, 1>;    // FFIE0
            using FMPIE0 = Field<1, 1>;    // FMPIE0
            using TMEIE = Field<0, 1>;    // TMEIE
        };

        // error status register
        struct ESR : public Register<0x40006418> {
            using REC = Field<24, 8>;    // REC
            using TEC = Field<16, 8>;    // TEC
            using LEC = Field<4, 3>;    // LEC
            using BOFF = Field<2, 1>;    // BOFF
            using EPVF = Field<1, 1>;    // EPVF
            using EWGF = Field<0, 1>;    // EWGF
        };

        // bit timing register
        struct BTR : public Register<0x4000641c> {
            using SILM = Field<31, 1>;    // SILM
            using LBKM = Field<30, 1>;    // LBKM
            using SJW = Field<24, 2>;    // SJW
            using TS2 = Field<20, 3>;    // TS2
            using TS1 = Field<16, 4>;    // TS1
            using BRP = Field<0, 10>;    // BRP
        };

        // TX mailbox identifier register
        struct TI0R : public Register<0x40006580> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
            using TXRQ = Field<0, 1>;    // TXRQ
        };

        // mailbox data length control and time stamp register
        struct TDT0R : public Register<0x40006584> {
            using TIME = Field<16, 16>;    // TIME
            using TGT = Field<8, 1>;    // TGT
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data low register
        struct TDL0R : public Register<0x40006588> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct TDH0R : public Register<0x4000658c> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // mailbox identifier register
        struct TI1R : public Register<0x40006590> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
            using TXRQ = Field<0, 1>;    // TXRQ
        };

        // mailbox data length control and time stamp register
        struct TDT1R : public Register<0x40006594> {
            using TIME = Field<16, 16>;    // TIME
            using TGT = Field<8, 1>;    // TGT
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data low register
        struct TDL1R : public Register<0x40006598> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct TDH1R : public Register<0x4000659c> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // mailbox identifier register
        struct TI2R : public Register<0x400065a0> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
            using TXRQ = Field<0, 1>;    // TXRQ
        };

        // mailbox data length control and time stamp register
        struct TDT2R : public Register<0x400065a4> {
            using TIME = Field<16, 16>;    // TIME
            using TGT = Field<8, 1>;    // TGT
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data low register
        struct TDL2R : public Register<0x400065a8> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct TDH2R : public Register<0x400065ac> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // receive FIFO mailbox identifier register
        struct RI0R : public RegisterReadOnly<0x400065b0> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
        };

        // mailbox data high register
        struct RDT0R : public RegisterReadOnly<0x400065b4> {
            using TIME = Field<16, 16>;    // TIME
            using FMI = Field<8, 8>;    // FMI
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data high register
        struct RDL0R : public RegisterReadOnly<0x400065b8> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // receive FIFO mailbox data high register
        struct RDH0R : public RegisterReadOnly<0x400065bc> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // mailbox data high register
        struct RI1R : public RegisterReadOnly<0x400065c0> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
        };

        // mailbox data high register
        struct RDT1R : public RegisterReadOnly<0x400065c4> {
            using TIME = Field<16, 16>;    // TIME
            using FMI = Field<8, 8>;    // FMI
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data high register
        struct RDL1R : public RegisterReadOnly<0x400065c8> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct RDH1R : public RegisterReadOnly<0x400065cc> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // filter master register
        struct FMR : public Register<0x40006600> {
            using CAN2SB = Field<8, 6>;    // CAN2SB
            using FINIT = Field<0, 1>;    // FINIT
        };

        // filter mode register
        struct FM1R : public Register<0x40006604> {
            using FBM0 = Field<0, 1>;    // Filter mode
            using FBM1 = Field<1, 1>;    // Filter mode
            using FBM2 = Field<2, 1>;    // Filter mode
            using FBM3 = Field<3, 1>;    // Filter mode
            using FBM4 = Field<4, 1>;    // Filter mode
            using FBM5 = Field<5, 1>;    // Filter mode
            using FBM6 = Field<6, 1>;    // Filter mode
            using FBM7 = Field<7, 1>;    // Filter mode
            using FBM8 = Field<8, 1>;    // Filter mode
            using FBM9 = Field<9, 1>;    // Filter mode
            using FBM10 = Field<10, 1>;    // Filter mode
            using FBM11 = Field<11, 1>;    // Filter mode
            using FBM12 = Field<12, 1>;    // Filter mode
            using FBM13 = Field<13, 1>;    // Filter mode
            using FBM14 = Field<14, 1>;    // Filter mode
            using FBM15 = Field<15, 1>;    // Filter mode
            using FBM16 = Field<16, 1>;    // Filter mode
            using FBM17 = Field<17, 1>;    // Filter mode
            using FBM18 = Field<18, 1>;    // Filter mode
            using FBM19 = Field<19, 1>;    // Filter mode
            using FBM20 = Field<20, 1>;    // Filter mode
            using FBM21 = Field<21, 1>;    // Filter mode
            using FBM22 = Field<22, 1>;    // Filter mode
            using FBM23 = Field<23, 1>;    // Filter mode
            using FBM24 = Field<24, 1>;    // Filter mode
            using FBM25 = Field<25, 1>;    // Filter mode
            using FBM26 = Field<26, 1>;    // Filter mode
            using FBM27 = Field<27, 1>;    // Filter mode
        };

        // filter scale register
        struct FS1R : public Register<0x4000660c> {
            using FSC0 = Field<0, 1>;    // Filter scale configuration
            using FSC1 = Field<1, 1>;    // Filter scale configuration
            using FSC2 = Field<2, 1>;    // Filter scale configuration
            using FSC3 = Field<3, 1>;    // Filter scale configuration
            using FSC4 = Field<4, 1>;    // Filter scale configuration
            using FSC5 = Field<5, 1>;    // Filter scale configuration
            using FSC6 = Field<6, 1>;    // Filter scale configuration
            using FSC7 = Field<7, 1>;    // Filter scale configuration
            using FSC8 = Field<8, 1>;    // Filter scale configuration
            using FSC9 = Field<9, 1>;    // Filter scale configuration
            using FSC10 = Field<10, 1>;    // Filter scale configuration
            using FSC11 = Field<11, 1>;    // Filter scale configuration
            using FSC12 = Field<12, 1>;    // Filter scale configuration
            using FSC13 = Field<13, 1>;    // Filter scale configuration
            using FSC14 = Field<14, 1>;    // Filter scale configuration
            using FSC15 = Field<15, 1>;    // Filter scale configuration
            using FSC16 = Field<16, 1>;    // Filter scale configuration
            using FSC17 = Field<17, 1>;    // Filter scale configuration
            using FSC18 = Field<18, 1>;    // Filter scale configuration
            using FSC19 = Field<19, 1>;    // Filter scale configuration
            using FSC20 = Field<20, 1>;    // Filter scale configuration
            using FSC21 = Field<21, 1>;    // Filter scale configuration
            using FSC22 = Field<22, 1>;    // Filter scale configuration
            using FSC23 = Field<23, 1>;    // Filter scale configuration
            using FSC24 = Field<24, 1>;    // Filter scale configuration
            using FSC25 = Field<25, 1>;    // Filter scale configuration
            using FSC26 = Field<26, 1>;    // Filter scale configuration
            using FSC27 = Field<27, 1>;    // Filter scale configuration
        };

        // filter FIFO assignment register
        struct FFA1R : public Register<0x40006614> {
            using FFA0 = Field<0, 1>;    // Filter FIFO assignment for filter 0
            using FFA1 = Field<1, 1>;    // Filter FIFO assignment for filter 1
            using FFA2 = Field<2, 1>;    // Filter FIFO assignment for filter 2
            using FFA3 = Field<3, 1>;    // Filter FIFO assignment for filter 3
            using FFA4 = Field<4, 1>;    // Filter FIFO assignment for filter 4
            using FFA5 = Field<5, 1>;    // Filter FIFO assignment for filter 5
            using FFA6 = Field<6, 1>;    // Filter FIFO assignment for filter 6
            using FFA7 = Field<7, 1>;    // Filter FIFO assignment for filter 7
            using FFA8 = Field<8, 1>;    // Filter FIFO assignment for filter 8
            using FFA9 = Field<9, 1>;    // Filter FIFO assignment for filter 9
            using FFA10 = Field<10, 1>;    // Filter FIFO assignment for filter 10
            using FFA11 = Field<11, 1>;    // Filter FIFO assignment for filter 11
            using FFA12 = Field<12, 1>;    // Filter FIFO assignment for filter 12
            using FFA13 = Field<13, 1>;    // Filter FIFO assignment for filter 13
            using FFA14 = Field<14, 1>;    // Filter FIFO assignment for filter 14
            using FFA15 = Field<15, 1>;    // Filter FIFO assignment for filter 15
            using FFA16 = Field<16, 1>;    // Filter FIFO assignment for filter 16
            using FFA17 = Field<17, 1>;    // Filter FIFO assignment for filter 17
            using FFA18 = Field<18, 1>;    // Filter FIFO assignment for filter 18
            using FFA19 = Field<19, 1>;    // Filter FIFO assignment for filter 19
            using FFA20 = Field<20, 1>;    // Filter FIFO assignment for filter 20
            using FFA21 = Field<21, 1>;    // Filter FIFO assignment for filter 21
            using FFA22 = Field<22, 1>;    // Filter FIFO assignment for filter 22
            using FFA23 = Field<23, 1>;    // Filter FIFO assignment for filter 23
            using FFA24 = Field<24, 1>;    // Filter FIFO assignment for filter 24
            using FFA25 = Field<25, 1>;    // Filter FIFO assignment for filter 25
            using FFA26 = Field<26, 1>;    // Filter FIFO assignment for filter 26
            using FFA27 = Field<27, 1>;    // Filter FIFO assignment for filter 27
        };

        // filter activation register
        struct FA1R : public Register<0x4000661c> {
            using FACT0 = Field<0, 1>;    // Filter active
            using FACT1 = Field<1, 1>;    // Filter active
            using FACT2 = Field<2, 1>;    // Filter active
            using FACT3 = Field<3, 1>;    // Filter active
            using FACT4 = Field<4, 1>;    // Filter active
            using FACT5 = Field<5, 1>;    // Filter active
            using FACT6 = Field<6, 1>;    // Filter active
            using FACT7 = Field<7, 1>;    // Filter active
            using FACT8 = Field<8, 1>;    // Filter active
            using FACT9 = Field<9, 1>;    // Filter active
            using FACT10 = Field<10, 1>;    // Filter active
            using FACT11 = Field<11, 1>;    // Filter active
            using FACT12 = Field<12, 1>;    // Filter active
            using FACT13 = Field<13, 1>;    // Filter active
            using FACT14 = Field<14, 1>;    // Filter active
            using FACT15 = Field<15, 1>;    // Filter active
            using FACT16 = Field<16, 1>;    // Filter active
            using FACT17 = Field<17, 1>;    // Filter active
            using FACT18 = Field<18, 1>;    // Filter active
            using FACT19 = Field<19, 1>;    // Filter active
            using FACT20 = Field<20, 1>;    // Filter active
            using FACT21 = Field<21, 1>;    // Filter active
            using FACT22 = Field<22, 1>;    // Filter active
            using FACT23 = Field<23, 1>;    // Filter active
            using FACT24 = Field<24, 1>;    // Filter active
            using FACT25 = Field<25, 1>;    // Filter active
            using FACT26 = Field<26, 1>;    // Filter active
            using FACT27 = Field<27, 1>;    // Filter active
        };

        // Filter bank 0 register 1
        struct F0R1 : public Register<0x40006640> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 0 register 2
        struct F0R2 : public Register<0x40006644> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 1 register 1
        struct F1R1 : public Register<0x40006648> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 1 register 2
        struct F1R2 : public Register<0x4000664c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 2 register 1
        struct F2R1 : public Register<0x40006650> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 2 register 2
        struct F2R2 : public Register<0x40006654> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 3 register 1
        struct F3R1 : public Register<0x40006658> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 3 register 2
        struct F3R2 : public Register<0x4000665c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 4 register 1
        struct F4R1 : public Register<0x40006660> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 4 register 2
        struct F4R2 : public Register<0x40006664> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 5 register 1
        struct F5R1 : public Register<0x40006668> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 5 register 2
        struct F5R2 : public Register<0x4000666c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 6 register 1
        struct F6R1 : public Register<0x40006670> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 6 register 2
        struct F6R2 : public Register<0x40006674> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 7 register 1
        struct F7R1 : public Register<0x40006678> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 7 register 2
        struct F7R2 : public Register<0x4000667c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 8 register 1
        struct F8R1 : public Register<0x40006680> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 8 register 2
        struct F8R2 : public Register<0x40006684> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 9 register 1
        struct F9R1 : public Register<0x40006688> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 9 register 2
        struct F9R2 : public Register<0x4000668c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 10 register 1
        struct F10R1 : public Register<0x40006690> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 10 register 2
        struct F10R2 : public Register<0x40006694> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 11 register 1
        struct F11R1 : public Register<0x40006698> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 11 register 2
        struct F11R2 : public Register<0x4000669c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 4 register 1
        struct F12R1 : public Register<0x400066a0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 12 register 2
        struct F12R2 : public Register<0x400066a4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 13 register 1
        struct F13R1 : public Register<0x400066a8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 13 register 2
        struct F13R2 : public Register<0x400066ac> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 14 register 1
        struct F14R1 : public Register<0x400066b0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 14 register 2
        struct F14R2 : public Register<0x400066b4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 15 register 1
        struct F15R1 : public Register<0x400066b8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 15 register 2
        struct F15R2 : public Register<0x400066bc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 16 register 1
        struct F16R1 : public Register<0x400066c0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 16 register 2
        struct F16R2 : public Register<0x400066c4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 17 register 1
        struct F17R1 : public Register<0x400066c8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 17 register 2
        struct F17R2 : public Register<0x400066cc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 18 register 1
        struct F18R1 : public Register<0x400066d0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 18 register 2
        struct F18R2 : public Register<0x400066d4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 19 register 1
        struct F19R1 : public Register<0x400066d8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 19 register 2
        struct F19R2 : public Register<0x400066dc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 20 register 1
        struct F20R1 : public Register<0x400066e0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 20 register 2
        struct F20R2 : public Register<0x400066e4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 21 register 1
        struct F21R1 : public Register<0x400066e8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 21 register 2
        struct F21R2 : public Register<0x400066ec> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 22 register 1
        struct F22R1 : public Register<0x400066f0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 22 register 2
        struct F22R2 : public Register<0x400066f4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 23 register 1
        struct F23R1 : public Register<0x400066f8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 23 register 2
        struct F23R2 : public Register<0x400066fc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 24 register 1
        struct F24R1 : public Register<0x40006700> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 24 register 2
        struct F24R2 : public Register<0x40006704> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 25 register 1
        struct F25R1 : public Register<0x40006708> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 25 register 2
        struct F25R2 : public Register<0x4000670c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 26 register 1
        struct F26R1 : public Register<0x40006710> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 26 register 2
        struct F26R2 : public Register<0x40006714> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 27 register 1
        struct F27R1 : public Register<0x40006718> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 27 register 2
        struct F27R2 : public Register<0x4000671c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

    };

    // Controller area network
    struct CAN2 {
        // master control register
        struct MCR : public Register<0x40006800> {
            using DBF = Field<16, 1>;    // DBF
            using RESET = Field<15, 1>;    // RESET
            using TTCM = Field<7, 1>;    // TTCM
            using ABOM = Field<6, 1>;    // ABOM
            using AWUM = Field<5, 1>;    // AWUM
            using NART = Field<4, 1>;    // NART
            using RFLM = Field<3, 1>;    // RFLM
            using TXFP = Field<2, 1>;    // TXFP
            using SLEEP = Field<1, 1>;    // SLEEP
            using INRQ = Field<0, 1>;    // INRQ
        };

        // master status register
        struct MSR : public Register<0x40006804> {
            using RX = Field<11, 1>;    // RX
            using SAMP = Field<10, 1>;    // SAMP
            using RXM = Field<9, 1>;    // RXM
            using TXM = Field<8, 1>;    // TXM
            using SLAKI = Field<4, 1>;    // SLAKI
            using WKUI = Field<3, 1>;    // WKUI
            using ERRI = Field<2, 1>;    // ERRI
            using SLAK = Field<1, 1>;    // SLAK
            using INAK = Field<0, 1>;    // INAK
        };

        // transmit status register
        struct TSR : public Register<0x40006808> {
            using LOW2 = Field<31, 1>;    // Lowest priority flag for mailbox 2
            using LOW1 = Field<30, 1>;    // Lowest priority flag for mailbox 1
            using LOW0 = Field<29, 1>;    // Lowest priority flag for mailbox 0
            using TME2 = Field<28, 1>;    // Lowest priority flag for mailbox 2
            using TME1 = Field<27, 1>;    // Lowest priority flag for mailbox 1
            using TME0 = Field<26, 1>;    // Lowest priority flag for mailbox 0
            using CODE = Field<24, 2>;    // CODE
            using ABRQ2 = Field<23, 1>;    // ABRQ2
            using TERR2 = Field<19, 1>;    // TERR2
            using ALST2 = Field<18, 1>;    // ALST2
            using TXOK2 = Field<17, 1>;    // TXOK2
            using RQCP2 = Field<16, 1>;    // RQCP2
            using ABRQ1 = Field<15, 1>;    // ABRQ1
            using TERR1 = Field<11, 1>;    // TERR1
            using ALST1 = Field<10, 1>;    // ALST1
            using TXOK1 = Field<9, 1>;    // TXOK1
            using RQCP1 = Field<8, 1>;    // RQCP1
            using ABRQ0 = Field<7, 1>;    // ABRQ0
            using TERR0 = Field<3, 1>;    // TERR0
            using ALST0 = Field<2, 1>;    // ALST0
            using TXOK0 = Field<1, 1>;    // TXOK0
            using RQCP0 = Field<0, 1>;    // RQCP0
        };

        // receive FIFO 0 register
        struct RF0R : public Register<0x4000680c> {
            using RFOM0 = Field<5, 1>;    // RFOM0
            using FOVR0 = Field<4, 1>;    // FOVR0
            using FULL0 = Field<3, 1>;    // FULL0
            using FMP0 = Field<0, 2>;    // FMP0
        };

        // receive FIFO 1 register
        struct RF1R : public Register<0x40006810> {
            using RFOM1 = Field<5, 1>;    // RFOM1
            using FOVR1 = Field<4, 1>;    // FOVR1
            using FULL1 = Field<3, 1>;    // FULL1
            using FMP1 = Field<0, 2>;    // FMP1
        };

        // interrupt enable register
        struct IER : public Register<0x40006814> {
            using SLKIE = Field<17, 1>;    // SLKIE
            using WKUIE = Field<16, 1>;    // WKUIE
            using ERRIE = Field<15, 1>;    // ERRIE
            using LECIE = Field<11, 1>;    // LECIE
            using BOFIE = Field<10, 1>;    // BOFIE
            using EPVIE = Field<9, 1>;    // EPVIE
            using EWGIE = Field<8, 1>;    // EWGIE
            using FOVIE1 = Field<6, 1>;    // FOVIE1
            using FFIE1 = Field<5, 1>;    // FFIE1
            using FMPIE1 = Field<4, 1>;    // FMPIE1
            using FOVIE0 = Field<3, 1>;    // FOVIE0
            using FFIE0 = Field<2, 1>;    // FFIE0
            using FMPIE0 = Field<1, 1>;    // FMPIE0
            using TMEIE = Field<0, 1>;    // TMEIE
        };

        // error status register
        struct ESR : public Register<0x40006818> {
            using REC = Field<24, 8>;    // REC
            using TEC = Field<16, 8>;    // TEC
            using LEC = Field<4, 3>;    // LEC
            using BOFF = Field<2, 1>;    // BOFF
            using EPVF = Field<1, 1>;    // EPVF
            using EWGF = Field<0, 1>;    // EWGF
        };

        // bit timing register
        struct BTR : public Register<0x4000681c> {
            using SILM = Field<31, 1>;    // SILM
            using LBKM = Field<30, 1>;    // LBKM
            using SJW = Field<24, 2>;    // SJW
            using TS2 = Field<20, 3>;    // TS2
            using TS1 = Field<16, 4>;    // TS1
            using BRP = Field<0, 10>;    // BRP
        };

        // TX mailbox identifier register
        struct TI0R : public Register<0x40006980> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
            using TXRQ = Field<0, 1>;    // TXRQ
        };

        // mailbox data length control and time stamp register
        struct TDT0R : public Register<0x40006984> {
            using TIME = Field<16, 16>;    // TIME
            using TGT = Field<8, 1>;    // TGT
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data low register
        struct TDL0R : public Register<0x40006988> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct TDH0R : public Register<0x4000698c> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // mailbox identifier register
        struct TI1R : public Register<0x40006990> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
            using TXRQ = Field<0, 1>;    // TXRQ
        };

        // mailbox data length control and time stamp register
        struct TDT1R : public Register<0x40006994> {
            using TIME = Field<16, 16>;    // TIME
            using TGT = Field<8, 1>;    // TGT
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data low register
        struct TDL1R : public Register<0x40006998> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct TDH1R : public Register<0x4000699c> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // mailbox identifier register
        struct TI2R : public Register<0x400069a0> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
            using TXRQ = Field<0, 1>;    // TXRQ
        };

        // mailbox data length control and time stamp register
        struct TDT2R : public Register<0x400069a4> {
            using TIME = Field<16, 16>;    // TIME
            using TGT = Field<8, 1>;    // TGT
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data low register
        struct TDL2R : public Register<0x400069a8> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct TDH2R : public Register<0x400069ac> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // receive FIFO mailbox identifier register
        struct RI0R : public RegisterReadOnly<0x400069b0> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
        };

        // mailbox data high register
        struct RDT0R : public RegisterReadOnly<0x400069b4> {
            using TIME = Field<16, 16>;    // TIME
            using FMI = Field<8, 8>;    // FMI
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data high register
        struct RDL0R : public RegisterReadOnly<0x400069b8> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // receive FIFO mailbox data high register
        struct RDH0R : public RegisterReadOnly<0x400069bc> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // mailbox data high register
        struct RI1R : public RegisterReadOnly<0x400069c0> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
        };

        // mailbox data high register
        struct RDT1R : public RegisterReadOnly<0x400069c4> {
            using TIME = Field<16, 16>;    // TIME
            using FMI = Field<8, 8>;    // FMI
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data high register
        struct RDL1R : public RegisterReadOnly<0x400069c8> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct RDH1R : public RegisterReadOnly<0x400069cc> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // filter master register
        struct FMR : public Register<0x40006a00> {
            using CAN2SB = Field<8, 6>;    // CAN2SB
            using FINIT = Field<0, 1>;    // FINIT
        };

        // filter mode register
        struct FM1R : public Register<0x40006a04> {
            using FBM0 = Field<0, 1>;    // Filter mode
            using FBM1 = Field<1, 1>;    // Filter mode
            using FBM2 = Field<2, 1>;    // Filter mode
            using FBM3 = Field<3, 1>;    // Filter mode
            using FBM4 = Field<4, 1>;    // Filter mode
            using FBM5 = Field<5, 1>;    // Filter mode
            using FBM6 = Field<6, 1>;    // Filter mode
            using FBM7 = Field<7, 1>;    // Filter mode
            using FBM8 = Field<8, 1>;    // Filter mode
            using FBM9 = Field<9, 1>;    // Filter mode
            using FBM10 = Field<10, 1>;    // Filter mode
            using FBM11 = Field<11, 1>;    // Filter mode
            using FBM12 = Field<12, 1>;    // Filter mode
            using FBM13 = Field<13, 1>;    // Filter mode
            using FBM14 = Field<14, 1>;    // Filter mode
            using FBM15 = Field<15, 1>;    // Filter mode
            using FBM16 = Field<16, 1>;    // Filter mode
            using FBM17 = Field<17, 1>;    // Filter mode
            using FBM18 = Field<18, 1>;    // Filter mode
            using FBM19 = Field<19, 1>;    // Filter mode
            using FBM20 = Field<20, 1>;    // Filter mode
            using FBM21 = Field<21, 1>;    // Filter mode
            using FBM22 = Field<22, 1>;    // Filter mode
            using FBM23 = Field<23, 1>;    // Filter mode
            using FBM24 = Field<24, 1>;    // Filter mode
            using FBM25 = Field<25, 1>;    // Filter mode
            using FBM26 = Field<26, 1>;    // Filter mode
            using FBM27 = Field<27, 1>;    // Filter mode
        };

        // filter scale register
        struct FS1R : public Register<0x40006a0c> {
            using FSC0 = Field<0, 1>;    // Filter scale configuration
            using FSC1 = Field<1, 1>;    // Filter scale configuration
            using FSC2 = Field<2, 1>;    // Filter scale configuration
            using FSC3 = Field<3, 1>;    // Filter scale configuration
            using FSC4 = Field<4, 1>;    // Filter scale configuration
            using FSC5 = Field<5, 1>;    // Filter scale configuration
            using FSC6 = Field<6, 1>;    // Filter scale configuration
            using FSC7 = Field<7, 1>;    // Filter scale configuration
            using FSC8 = Field<8, 1>;    // Filter scale configuration
            using FSC9 = Field<9, 1>;    // Filter scale configuration
            using FSC10 = Field<10, 1>;    // Filter scale configuration
            using FSC11 = Field<11, 1>;    // Filter scale configuration
            using FSC12 = Field<12, 1>;    // Filter scale configuration
            using FSC13 = Field<13, 1>;    // Filter scale configuration
            using FSC14 = Field<14, 1>;    // Filter scale configuration
            using FSC15 = Field<15, 1>;    // Filter scale configuration
            using FSC16 = Field<16, 1>;    // Filter scale configuration
            using FSC17 = Field<17, 1>;    // Filter scale configuration
            using FSC18 = Field<18, 1>;    // Filter scale configuration
            using FSC19 = Field<19, 1>;    // Filter scale configuration
            using FSC20 = Field<20, 1>;    // Filter scale configuration
            using FSC21 = Field<21, 1>;    // Filter scale configuration
            using FSC22 = Field<22, 1>;    // Filter scale configuration
            using FSC23 = Field<23, 1>;    // Filter scale configuration
            using FSC24 = Field<24, 1>;    // Filter scale configuration
            using FSC25 = Field<25, 1>;    // Filter scale configuration
            using FSC26 = Field<26, 1>;    // Filter scale configuration
            using FSC27 = Field<27, 1>;    // Filter scale configuration
        };

        // filter FIFO assignment register
        struct FFA1R : public Register<0x40006a14> {
            using FFA0 = Field<0, 1>;    // Filter FIFO assignment for filter 0
            using FFA1 = Field<1, 1>;    // Filter FIFO assignment for filter 1
            using FFA2 = Field<2, 1>;    // Filter FIFO assignment for filter 2
            using FFA3 = Field<3, 1>;    // Filter FIFO assignment for filter 3
            using FFA4 = Field<4, 1>;    // Filter FIFO assignment for filter 4
            using FFA5 = Field<5, 1>;    // Filter FIFO assignment for filter 5
            using FFA6 = Field<6, 1>;    // Filter FIFO assignment for filter 6
            using FFA7 = Field<7, 1>;    // Filter FIFO assignment for filter 7
            using FFA8 = Field<8, 1>;    // Filter FIFO assignment for filter 8
            using FFA9 = Field<9, 1>;    // Filter FIFO assignment for filter 9
            using FFA10 = Field<10, 1>;    // Filter FIFO assignment for filter 10
            using FFA11 = Field<11, 1>;    // Filter FIFO assignment for filter 11
            using FFA12 = Field<12, 1>;    // Filter FIFO assignment for filter 12
            using FFA13 = Field<13, 1>;    // Filter FIFO assignment for filter 13
            using FFA14 = Field<14, 1>;    // Filter FIFO assignment for filter 14
            using FFA15 = Field<15, 1>;    // Filter FIFO assignment for filter 15
            using FFA16 = Field<16, 1>;    // Filter FIFO assignment for filter 16
            using FFA17 = Field<17, 1>;    // Filter FIFO assignment for filter 17
            using FFA18 = Field<18, 1>;    // Filter FIFO assignment for filter 18
            using FFA19 = Field<19, 1>;    // Filter FIFO assignment for filter 19
            using FFA20 = Field<20, 1>;    // Filter FIFO assignment for filter 20
            using FFA21 = Field<21, 1>;    // Filter FIFO assignment for filter 21
            using FFA22 = Field<22, 1>;    // Filter FIFO assignment for filter 22
            using FFA23 = Field<23, 1>;    // Filter FIFO assignment for filter 23
            using FFA24 = Field<24, 1>;    // Filter FIFO assignment for filter 24
            using FFA25 = Field<25, 1>;    // Filter FIFO assignment for filter 25
            using FFA26 = Field<26, 1>;    // Filter FIFO assignment for filter 26
            using FFA27 = Field<27, 1>;    // Filter FIFO assignment for filter 27
        };

        // filter activation register
        struct FA1R : public Register<0x40006a1c> {
            using FACT0 = Field<0, 1>;    // Filter active
            using FACT1 = Field<1, 1>;    // Filter active
            using FACT2 = Field<2, 1>;    // Filter active
            using FACT3 = Field<3, 1>;    // Filter active
            using FACT4 = Field<4, 1>;    // Filter active
            using FACT5 = Field<5, 1>;    // Filter active
            using FACT6 = Field<6, 1>;    // Filter active
            using FACT7 = Field<7, 1>;    // Filter active
            using FACT8 = Field<8, 1>;    // Filter active
            using FACT9 = Field<9, 1>;    // Filter active
            using FACT10 = Field<10, 1>;    // Filter active
            using FACT11 = Field<11, 1>;    // Filter active
            using FACT12 = Field<12, 1>;    // Filter active
            using FACT13 = Field<13, 1>;    // Filter active
            using FACT14 = Field<14, 1>;    // Filter active
            using FACT15 = Field<15, 1>;    // Filter active
            using FACT16 = Field<16, 1>;    // Filter active
            using FACT17 = Field<17, 1>;    // Filter active
            using FACT18 = Field<18, 1>;    // Filter active
            using FACT19 = Field<19, 1>;    // Filter active
            using FACT20 = Field<20, 1>;    // Filter active
            using FACT21 = Field<21, 1>;    // Filter active
            using FACT22 = Field<22, 1>;    // Filter active
            using FACT23 = Field<23, 1>;    // Filter active
            using FACT24 = Field<24, 1>;    // Filter active
            using FACT25 = Field<25, 1>;    // Filter active
            using FACT26 = Field<26, 1>;    // Filter active
            using FACT27 = Field<27, 1>;    // Filter active
        };

        // Filter bank 0 register 1
        struct F0R1 : public Register<0x40006a40> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 0 register 2
        struct F0R2 : public Register<0x40006a44> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 1 register 1
        struct F1R1 : public Register<0x40006a48> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 1 register 2
        struct F1R2 : public Register<0x40006a4c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 2 register 1
        struct F2R1 : public Register<0x40006a50> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 2 register 2
        struct F2R2 : public Register<0x40006a54> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 3 register 1
        struct F3R1 : public Register<0x40006a58> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 3 register 2
        struct F3R2 : public Register<0x40006a5c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 4 register 1
        struct F4R1 : public Register<0x40006a60> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 4 register 2
        struct F4R2 : public Register<0x40006a64> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 5 register 1
        struct F5R1 : public Register<0x40006a68> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 5 register 2
        struct F5R2 : public Register<0x40006a6c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 6 register 1
        struct F6R1 : public Register<0x40006a70> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 6 register 2
        struct F6R2 : public Register<0x40006a74> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 7 register 1
        struct F7R1 : public Register<0x40006a78> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 7 register 2
        struct F7R2 : public Register<0x40006a7c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 8 register 1
        struct F8R1 : public Register<0x40006a80> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 8 register 2
        struct F8R2 : public Register<0x40006a84> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 9 register 1
        struct F9R1 : public Register<0x40006a88> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 9 register 2
        struct F9R2 : public Register<0x40006a8c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 10 register 1
        struct F10R1 : public Register<0x40006a90> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 10 register 2
        struct F10R2 : public Register<0x40006a94> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 11 register 1
        struct F11R1 : public Register<0x40006a98> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 11 register 2
        struct F11R2 : public Register<0x40006a9c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 4 register 1
        struct F12R1 : public Register<0x40006aa0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 12 register 2
        struct F12R2 : public Register<0x40006aa4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 13 register 1
        struct F13R1 : public Register<0x40006aa8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 13 register 2
        struct F13R2 : public Register<0x40006aac> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 14 register 1
        struct F14R1 : public Register<0x40006ab0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 14 register 2
        struct F14R2 : public Register<0x40006ab4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 15 register 1
        struct F15R1 : public Register<0x40006ab8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 15 register 2
        struct F15R2 : public Register<0x40006abc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 16 register 1
        struct F16R1 : public Register<0x40006ac0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 16 register 2
        struct F16R2 : public Register<0x40006ac4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 17 register 1
        struct F17R1 : public Register<0x40006ac8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 17 register 2
        struct F17R2 : public Register<0x40006acc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 18 register 1
        struct F18R1 : public Register<0x40006ad0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 18 register 2
        struct F18R2 : public Register<0x40006ad4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 19 register 1
        struct F19R1 : public Register<0x40006ad8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 19 register 2
        struct F19R2 : public Register<0x40006adc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 20 register 1
        struct F20R1 : public Register<0x40006ae0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 20 register 2
        struct F20R2 : public Register<0x40006ae4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 21 register 1
        struct F21R1 : public Register<0x40006ae8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 21 register 2
        struct F21R2 : public Register<0x40006aec> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 22 register 1
        struct F22R1 : public Register<0x40006af0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 22 register 2
        struct F22R2 : public Register<0x40006af4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 23 register 1
        struct F23R1 : public Register<0x40006af8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 23 register 2
        struct F23R2 : public Register<0x40006afc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 24 register 1
        struct F24R1 : public Register<0x40006b00> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 24 register 2
        struct F24R2 : public Register<0x40006b04> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 25 register 1
        struct F25R1 : public Register<0x40006b08> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 25 register 2
        struct F25R2 : public Register<0x40006b0c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 26 register 1
        struct F26R1 : public Register<0x40006b10> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 26 register 2
        struct F26R2 : public Register<0x40006b14> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 27 register 1
        struct F27R1 : public Register<0x40006b18> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 27 register 2
        struct F27R2 : public Register<0x40006b1c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

    };

    // Ethernet: MAC management counters
    struct ETHERNET_MMC {
        // Ethernet MMC control register (ETH_MMCCR)
        struct MMCCR : public Register<0x40028100> {
            using CR = Field<0, 1>;    // Counter reset
            using CSR = Field<1, 1>;    // Counter stop rollover
            using ROR = Field<2, 1>;    // Reset on read
            using MCF = Field<31, 1>;    // MMC counter freeze
        };

        // Ethernet MMC receive interrupt register (ETH_MMCRIR)
        struct MMCRIR : public Register<0x40028104> {
            using RFCES = Field<5, 1>;    // Received frames CRC error status
            using RFAES = Field<6, 1>;    // Received frames alignment error status
            using RGUFS = Field<17, 1>;    // Received Good Unicast Frames Status
        };

        // Ethernet MMC transmit interrupt register (ETH_MMCTIR)
        struct MMCTIR : public Register<0x40028108> {
            using TGFSCS = Field<14, 1>;    // Transmitted good frames single collision status
            using TGFMSCS = Field<15, 1>;    // Transmitted good frames more single collision status
            using TGFS = Field<21, 1>;    // Transmitted good frames status
        };

        // Ethernet MMC receive interrupt mask register (ETH_MMCRIMR)
        struct MMCRIMR : public Register<0x4002810c> {
            using RFCEM = Field<5, 1>;    // Received frame CRC error mask
            using RFAEM = Field<6, 1>;    // Received frames alignment error mask
            using RGUFM = Field<17, 1>;    // Received good unicast frames mask
        };

        // Ethernet MMC transmit interrupt mask register (ETH_MMCTIMR)
        struct MMCTIMR : public Register<0x40028110> {
            using TGFSCM = Field<14, 1>;    // Transmitted good frames single collision mask
            using TGFMSCM = Field<15, 1>;    // Transmitted good frames more single collision mask
            using TGFM = Field<21, 1>;    // Transmitted good frames mask
        };

        // Ethernet MMC transmitted good frames after a single collision counter
        struct MMCTGFSCCR : public RegisterReadOnly<0x4002814c> {
            using TGFSCC = Field<0, 32>;    // Transmitted good frames after a single collision counter
        };

        // Ethernet MMC transmitted good frames after more than a single collision
        struct MMCTGFMSCCR : public RegisterReadOnly<0x40028150> {
            using TGFMSCC = Field<0, 32>;    // Transmitted good frames after more than a single collision counter
        };

        // Ethernet MMC transmitted good frames counter register
        struct MMCTGFCR : public RegisterReadOnly<0x40028168> {
            using TGFC = Field<0, 32>;    // Transmitted good frames counter
        };

        // Ethernet MMC received frames with CRC error counter register
        struct MMCRFCECR : public RegisterReadOnly<0x40028194> {
            using RFCFC = Field<0, 32>;    // Received frames with CRC error counter
        };

        // Ethernet MMC received frames with alignment error counter register
        struct MMCRFAECR : public RegisterReadOnly<0x40028198> {
            using RFAEC = Field<0, 32>;    // Received frames with alignment error counter
        };

        // MMC received good unicast frames counter register
        struct MMCRGUFCR : public RegisterReadOnly<0x400281c4> {
            using RGUFC = Field<0, 32>;    // Received good unicast frames counter
        };

    };

    // Ethernet: media access control
    struct ETHERNET_MAC {
        // Ethernet MAC configuration register (ETH_MACCR)
        struct MACCR : public Register<0x40028000> {
            using RE = Field<2, 1>;    // Receiver enable
            using TE = Field<3, 1>;    // Transmitter enable
            using DC = Field<4, 1>;    // Deferral check
            using BL = Field<5, 2>;    // Back-off limit
            using APCS = Field<7, 1>;    // Automatic pad/CRC stripping
            using RD = Field<9, 1>;    // Retry disable
            using IPCO = Field<10, 1>;    // IPv4 checksum offload
            using DM = Field<11, 1>;    // Duplex mode
            using LM = Field<12, 1>;    // Loopback mode
            using ROD = Field<13, 1>;    // Receive own disable
            using FES = Field<14, 1>;    // Fast Ethernet speed
            using CSD = Field<16, 1>;    // Carrier sense disable
            using IFG = Field<17, 3>;    // Interframe gap
            using JD = Field<22, 1>;    // Jabber disable
            using WD = Field<23, 1>;    // Watchdog disable
        };

        // Ethernet MAC frame filter register (ETH_MACCFFR)
        struct MACFFR : public Register<0x40028004> {
            using PM = Field<0, 1>;    // Promiscuous mode
            using HU = Field<1, 1>;    // Hash unicast
            using HM = Field<2, 1>;    // Hash multicast
            using DAIF = Field<3, 1>;    // Destination address inverse filtering
            using PAM = Field<4, 1>;    // Pass all multicast
            using BFD = Field<5, 1>;    // Broadcast frames disable
            using PCF = Field<6, 2>;    // Pass control frames
            using SAIF = Field<8, 1>;    // Source address inverse filtering
            using SAF = Field<9, 1>;    // Source address filter
            using HPF = Field<10, 1>;    // Hash or perfect filter
            using RA = Field<31, 1>;    // Receive all
        };

        // Ethernet MAC hash table high register
        struct MACHTHR : public Register<0x40028008> {
            using HTH = Field<0, 32>;    // Hash table high
        };

        // Ethernet MAC hash table low register
        struct MACHTLR : public Register<0x4002800c> {
            using HTL = Field<0, 32>;    // Hash table low
        };

        // Ethernet MAC MII address register (ETH_MACMIIAR)
        struct MACMIIAR : public Register<0x40028010> {
            using MB = Field<0, 1>;    // MII busy
            using MW = Field<1, 1>;    // MII write
            using CR = Field<2, 3>;    // Clock range
            using MR = Field<6, 5>;    // MII register
            using PA = Field<11, 5>;    // PHY address
        };

        // Ethernet MAC MII data register (ETH_MACMIIDR)
        struct MACMIIDR : public Register<0x40028014> {
            using MD = Field<0, 16>;    // MII data
        };

        // Ethernet MAC flow control register (ETH_MACFCR)
        struct MACFCR : public Register<0x40028018> {
            using FCB_BPA = Field<0, 1>;    // Flow control busy/back pressure activate
            using TFCE = Field<1, 1>;    // Transmit flow control enable
            using RFCE = Field<2, 1>;    // Receive flow control enable
            using UPFD = Field<3, 1>;    // Unicast pause frame detect
            using PLT = Field<4, 2>;    // Pause low threshold
            using ZQPD = Field<7, 1>;    // Zero-quanta pause disable
            using PT = Field<16, 16>;    // Pass control frames
        };

        // Ethernet MAC VLAN tag register (ETH_MACVLANTR)
        struct MACVLANTR : public Register<0x4002801c> {
            using VLANTI = Field<0, 16>;    // VLAN tag identifier (for receive frames)
            using VLANTC = Field<16, 1>;    // 12-bit VLAN tag comparison
        };

        // Ethernet MAC remote wakeup frame filter register (ETH_MACRWUFFR)
        struct MACRWUFFR : public Register<0x40028028> {
        };

        // Ethernet MAC PMT control and status register (ETH_MACPMTCSR)
        struct MACPMTCSR : public Register<0x4002802c> {
            using PD = Field<0, 1>;    // Power down
            using MPE = Field<1, 1>;    // Magic Packet enable
            using WFE = Field<2, 1>;    // Wakeup frame enable
            using MPR = Field<5, 1>;    // Magic packet received
            using WFR = Field<6, 1>;    // Wakeup frame received
            using GU = Field<9, 1>;    // Global unicast
            using WFFRPR = Field<31, 1>;    // Wakeup frame filter register pointer reset
        };

        // Ethernet MAC interrupt status register (ETH_MACSR)
        struct MACSR : public Register<0x40028038> {
            using PMTS = Field<3, 1>;    // PMT status
            using MMCS = Field<4, 1>;    // MMC status
            using MMCRS = Field<5, 1>;    // MMC receive status
            using MMCTS = Field<6, 1>;    // MMC transmit status
            using TSTS = Field<9, 1>;    // Time stamp trigger status
        };

        // Ethernet MAC interrupt mask register (ETH_MACIMR)
        struct MACIMR : public Register<0x4002803c> {
            using PMTIM = Field<3, 1>;    // PMT interrupt mask
            using TSTIM = Field<9, 1>;    // Time stamp trigger interrupt mask
        };

        // Ethernet MAC address 0 high register (ETH_MACA0HR)
        struct MACA0HR : public Register<0x40028040> {
            using MACA0H = Field<0, 16>;    // MAC address0 high
            using MO = Field<31, 1>;    // Always 1
        };

        // Ethernet MAC address 0 low register
        struct MACA0LR : public Register<0x40028044> {
            using MACA0L = Field<0, 32>;    // MAC address0 low
        };

        // Ethernet MAC address 1 high register (ETH_MACA1HR)
        struct MACA1HR : public Register<0x40028048> {
            using MACA1H = Field<0, 16>;    // MAC address1 high
            using MBC = Field<24, 6>;    // Mask byte control
            using SA = Field<30, 1>;    // Source address
            using AE = Field<31, 1>;    // Address enable
        };

        // Ethernet MAC address1 low register
        struct MACA1LR : public Register<0x4002804c> {
            using MACA1L = Field<0, 32>;    // MAC address1 low
        };

        // Ethernet MAC address 2 high register (ETH_MACA2HR)
        struct MACA2HR : public Register<0x40028050> {
            using ETH_MACA2HR = Field<0, 16>;    // Ethernet MAC address 2 high register
            using MBC = Field<24, 6>;    // Mask byte control
            using SA = Field<30, 1>;    // Source address
            using AE = Field<31, 1>;    // Address enable
        };

        // Ethernet MAC address 2 low register
        struct MACA2LR : public Register<0x40028054> {
            using MACA2L = Field<0, 31>;    // MAC address2 low
        };

        // Ethernet MAC address 3 high register (ETH_MACA3HR)
        struct MACA3HR : public Register<0x40028058> {
            using MACA3H = Field<0, 16>;    // MAC address3 high
            using MBC = Field<24, 6>;    // Mask byte control
            using SA = Field<30, 1>;    // Source address
            using AE = Field<31, 1>;    // Address enable
        };

        // Ethernet MAC address 3 low register
        struct MACA3LR : public Register<0x4002805c> {
            using MBCA3L = Field<0, 32>;    // MAC address3 low
        };

    };

    // Ethernet: Precision time protocol
    struct ETHERNET_PTP {
        // Ethernet PTP time stamp control register (ETH_PTPTSCR)
        struct PTPTSCR : public Register<0x40028700> {
            using TSE = Field<0, 1>;    // Time stamp enable
            using TSFCU = Field<1, 1>;    // Time stamp fine or coarse update
            using TSSTI = Field<2, 1>;    // Time stamp system time initialize
            using TSSTU = Field<3, 1>;    // Time stamp system time update
            using TSITE = Field<4, 1>;    // Time stamp interrupt trigger enable
            using TSARU = Field<5, 1>;    // Time stamp addend register update
        };

        // Ethernet PTP subsecond increment register
        struct PTPSSIR : public Register<0x40028704> {
            using STSSI = Field<0, 8>;    // System time subsecond increment
        };

        // Ethernet PTP time stamp high register
        struct PTPTSHR : public RegisterReadOnly<0x40028708> {
            using STS = Field<0, 32>;    // System time second
        };

        // Ethernet PTP time stamp low register (ETH_PTPTSLR)
        struct PTPTSLR : public RegisterReadOnly<0x4002870c> {
            using STSS = Field<0, 31>;    // System time subseconds
            using STPNS = Field<31, 1>;    // System time positive or negative sign
        };

        // Ethernet PTP time stamp high update register
        struct PTPTSHUR : public Register<0x40028710> {
            using TSUS = Field<0, 32>;    // Time stamp update second
        };

        // Ethernet PTP time stamp low update register (ETH_PTPTSLUR)
        struct PTPTSLUR : public Register<0x40028714> {
            using TSUSS = Field<0, 31>;    // Time stamp update subseconds
            using TSUPNS = Field<31, 1>;    // Time stamp update positive or negative sign
        };

        // Ethernet PTP time stamp addend register
        struct PTPTSAR : public Register<0x40028718> {
            using TSA = Field<0, 32>;    // Time stamp addend
        };

        // Ethernet PTP target time high register
        struct PTPTTHR : public Register<0x4002871c> {
            using TTSH = Field<0, 32>;    // Target time stamp high
        };

        // Ethernet PTP target time low register
        struct PTPTTLR : public Register<0x40028720> {
            using TTSL = Field<0, 32>;    // Target time stamp low
        };

    };

    // Ethernet: DMA controller operation
    struct ETHERNET_DMA {
        // Ethernet DMA bus mode register
        struct DMABMR : public Register<0x40029000> {
            using SR = Field<0, 1>;    // Software reset
            using DA = Field<1, 1>;    // DMA Arbitration
            using DSL = Field<2, 5>;    // Descriptor skip length
            using PBL = Field<8, 6>;    // Programmable burst length
            using RTPR = Field<14, 2>;    // Rx Tx priority ratio
            using FB = Field<16, 1>;    // Fixed burst
            using RDP = Field<17, 6>;    // Rx DMA PBL
            using USP = Field<23, 1>;    // Use separate PBL
            using FPM = Field<24, 1>;    // 4xPBL mode
            using AAB = Field<25, 1>;    // Address-aligned beats
        };

        // Ethernet DMA transmit poll demand register
        struct DMATPDR : public Register<0x40029004> {
            using TPD = Field<0, 32>;    // Transmit poll demand
        };

        // EHERNET DMA receive poll demand register
        struct DMARPDR : public Register<0x40029008> {
            using RPD = Field<0, 32>;    // Receive poll demand
        };

        // Ethernet DMA receive descriptor list address register
        struct DMARDLAR : public Register<0x4002900c> {
            using SRL = Field<0, 32>;    // Start of receive list
        };

        // Ethernet DMA transmit descriptor list address register
        struct DMATDLAR : public Register<0x40029010> {
            using STL = Field<0, 32>;    // Start of transmit list
        };

        // Ethernet DMA status register
        struct DMASR : public Register<0x40029014> {
            using TS = Field<0, 1>;    // Transmit status
            using TPSS = Field<1, 1>;    // Transmit process stopped status
            using TBUS = Field<2, 1>;    // Transmit buffer unavailable status
            using TJTS = Field<3, 1>;    // Transmit jabber timeout status
            using ROS = Field<4, 1>;    // Receive overflow status
            using TUS = Field<5, 1>;    // Transmit underflow status
            using RS = Field<6, 1>;    // Receive status
            using RBUS = Field<7, 1>;    // Receive buffer unavailable status
            using RPSS = Field<8, 1>;    // Receive process stopped status
            using PWTS = Field<9, 1>;    // Receive watchdog timeout status
            using ETS = Field<10, 1>;    // Early transmit status
            using FBES = Field<13, 1>;    // Fatal bus error status
            using ERS = Field<14, 1>;    // Early receive status
            using AIS = Field<15, 1>;    // Abnormal interrupt summary
            using NIS = Field<16, 1>;    // Normal interrupt summary
            using RPS = Field<17, 3>;    // Receive process state
            using TPS = Field<20, 3>;    // Transmit process state
            using EBS = Field<23, 3>;    // Error bits status
            using MMCS = Field<27, 1>;    // MMC status
            using PMTS = Field<28, 1>;    // PMT status
            using TSTS = Field<29, 1>;    // Time stamp trigger status
        };

        // Ethernet DMA operation mode register
        struct DMAOMR : public Register<0x40029018> {
            using SR = Field<1, 1>;    // SR
            using OSF = Field<2, 1>;    // OSF
            using RTC = Field<3, 2>;    // RTC
            using FUGF = Field<6, 1>;    // FUGF
            using FEF = Field<7, 1>;    // FEF
            using ST = Field<13, 1>;    // ST
            using TTC = Field<14, 3>;    // TTC
            using FTF = Field<20, 1>;    // FTF
            using TSF = Field<21, 1>;    // TSF
            using DFRF = Field<24, 1>;    // DFRF
            using RSF = Field<25, 1>;    // RSF
            using DTCEFD = Field<26, 1>;    // DTCEFD
        };

        // Ethernet DMA interrupt enable register
        struct DMAIER : public Register<0x4002901c> {
            using TIE = Field<0, 1>;    // Transmit interrupt enable
            using TPSIE = Field<1, 1>;    // Transmit process stopped interrupt enable
            using TBUIE = Field<2, 1>;    // Transmit buffer unavailable interrupt enable
            using TJTIE = Field<3, 1>;    // Transmit jabber timeout interrupt enable
            using ROIE = Field<4, 1>;    // Overflow interrupt enable
            using TUIE = Field<5, 1>;    // Underflow interrupt enable
            using RIE = Field<6, 1>;    // Receive interrupt enable
            using RBUIE = Field<7, 1>;    // Receive buffer unavailable interrupt enable
            using RPSIE = Field<8, 1>;    // Receive process stopped interrupt enable
            using RWTIE = Field<9, 1>;    // receive watchdog timeout interrupt enable
            using ETIE = Field<10, 1>;    // Early transmit interrupt enable
            using FBEIE = Field<13, 1>;    // Fatal bus error interrupt enable
            using ERIE = Field<14, 1>;    // Early receive interrupt enable
            using AISE = Field<15, 1>;    // Abnormal interrupt summary enable
            using NISE = Field<16, 1>;    // Normal interrupt summary enable
        };

        // Ethernet DMA missed frame and buffer overflow counter register
        struct DMAMFBOCR : public RegisterReadOnly<0x40029020> {
            using MFC = Field<0, 16>;    // Missed frames by the controller
            using OMFC = Field<16, 1>;    // Overflow bit for missed frame counter
            using MFA = Field<17, 11>;    // Missed frames by the application
            using OFOC = Field<28, 1>;    // Overflow bit for FIFO overflow counter
        };

        // Ethernet DMA current host transmit descriptor register
        struct DMACHTDR : public RegisterReadOnly<0x40029048> {
            using HTDAP = Field<0, 32>;    // Host transmit descriptor address pointer
        };

        // Ethernet DMA current host receive descriptor register
        struct DMACHRDR : public RegisterReadOnly<0x4002904c> {
            using HRDAP = Field<0, 32>;    // Host receive descriptor address pointer
        };

        // Ethernet DMA current host transmit buffer address register
        struct DMACHTBAR : public RegisterReadOnly<0x40029050> {
            using HTBAP = Field<0, 32>;    // Host transmit buffer address pointer
        };

        // Ethernet DMA current host receive buffer address register
        struct DMACHRBAR : public RegisterReadOnly<0x40029054> {
            using HRBAP = Field<0, 32>;    // Host receive buffer address pointer
        };

    };

    // Universal serial bus full-speed device interface
    struct USB {
        // endpoint 0 register
        struct EP0R : public Register<0x40005c00> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // endpoint 1 register
        struct EP1R : public Register<0x40005c04> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // endpoint 2 register
        struct EP2R : public Register<0x40005c08> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // endpoint 3 register
        struct EP3R : public Register<0x40005c0c> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // endpoint 4 register
        struct EP4R : public Register<0x40005c10> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // endpoint 5 register
        struct EP5R : public Register<0x40005c14> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // endpoint 6 register
        struct EP6R : public Register<0x40005c18> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // endpoint 7 register
        struct EP7R : public Register<0x40005c1c> {
            using EA = Field<0, 4>;    // Endpoint address
            using STAT_TX = Field<4, 2>;    // Status bits, for transmission transfers
            using DTOG_TX = Field<6, 1>;    // Data Toggle, for transmission transfers
            using CTR_TX = Field<7, 1>;    // Correct Transfer for transmission
            using EP_KIND = Field<8, 1>;    // Endpoint kind
            using EP_TYPE = Field<9, 2>;    // Endpoint type
            using SETUP = Field<11, 1>;    // Setup transaction completed
            using STAT_RX = Field<12, 2>;    // Status bits, for reception transfers
            using DTOG_RX = Field<14, 1>;    // Data Toggle, for reception transfers
            using CTR_RX = Field<15, 1>;    // Correct transfer for reception
        };

        // control register
        struct CNTR : public Register<0x40005c40> {
            using FRES = Field<0, 1>;    // Force USB Reset
            using PDWN = Field<1, 1>;    // Power down
            using LPMODE = Field<2, 1>;    // Low-power mode
            using FSUSP = Field<3, 1>;    // Force suspend
            using RESUME = Field<4, 1>;    // Resume request
            using ESOFM = Field<8, 1>;    // Expected start of frame interrupt mask
            using SOFM = Field<9, 1>;    // Start of frame interrupt mask
            using RESETM = Field<10, 1>;    // USB reset interrupt mask
            using SUSPM = Field<11, 1>;    // Suspend mode interrupt mask
            using WKUPM = Field<12, 1>;    // Wakeup interrupt mask
            using ERRM = Field<13, 1>;    // Error interrupt mask
            using PMAOVRM = Field<14, 1>;    // Packet memory area over / underrun interrupt mask
            using CTRM = Field<15, 1>;    // Correct transfer interrupt mask
        };

        // interrupt status register
        struct ISTR : public Register<0x40005c44> {
            using EP_ID = Field<0, 4>;    // Endpoint Identifier
            using DIR = Field<4, 1>;    // Direction of transaction
            using ESOF = Field<8, 1>;    // Expected start frame
            using SOF = Field<9, 1>;    // start of frame
            using RESET = Field<10, 1>;    // reset request
            using SUSP = Field<11, 1>;    // Suspend mode request
            using WKUP = Field<12, 1>;    // Wakeup
            using ERR = Field<13, 1>;    // Error
            using PMAOVR = Field<14, 1>;    // Packet memory area over / underrun
            using CTR = Field<15, 1>;    // Correct transfer
        };

        // frame number register
        struct FNR : public RegisterReadOnly<0x40005c48> {
            using FN = Field<0, 11>;    // Frame number
            using LSOF = Field<11, 2>;    // Lost SOF
            using LCK = Field<13, 1>;    // Locked
            using RXDM = Field<14, 1>;    // Receive data - line status
            using RXDP = Field<15, 1>;    // Receive data + line status
        };

        // device address
        struct DADDR : public Register<0x40005c4c> {
            using ADD = Field<0, 7>;    // Device address
            using EF = Field<7, 1>;    // Enable function
        };

        // Buffer table address
        struct BTABLE : public Register<0x40005c50> {
            using Field = Field<3, 13>;    // Buffer table
        };

    };

    // Analog to digital converter
    struct ADC2 {
        // status register
        struct SR : public Register<0x40012800> {
            using STRT = Field<4, 1>;    // Regular channel start flag
            using JSTRT = Field<3, 1>;    // Injected channel start flag
            using JEOC = Field<2, 1>;    // Injected channel end of conversion
            using EOC = Field<1, 1>;    // Regular channel end of conversion
            using AWD = Field<0, 1>;    // Analog watchdog flag
        };

        // control register 1
        struct CR1 : public Register<0x40012804> {
            using AWDEN = Field<23, 1>;    // Analog watchdog enable on regular channels
            using JAWDEN = Field<22, 1>;    // Analog watchdog enable on injected channels
            using DUALMOD = Field<16, 4>;    // Dual mode selection
            using DISCNUM = Field<13, 3>;    // Discontinuous mode channel count
            using JDISCEN = Field<12, 1>;    // Discontinuous mode on injected channels
            using DISCEN = Field<11, 1>;    // Discontinuous mode on regular channels
            using JAUTO = Field<10, 1>;    // Automatic injected group conversion
            using AWDSGL = Field<9, 1>;    // Enable the watchdog on a single channel in scan mode
            using SCAN = Field<8, 1>;    // Scan mode
            using JEOCIE = Field<7, 1>;    // Interrupt enable for injected channels
            using AWDIE = Field<6, 1>;    // Analog watchdog interrupt enable
            using EOCIE = Field<5, 1>;    // Interrupt enable for EOC
            using AWDCH = Field<0, 5>;    // Analog watchdog channel select bits
        };

        // control register 2
        struct CR2 : public Register<0x40012808> {
            using TSVREFE = Field<23, 1>;    // Temperature sensor and VREFINT enable
            using SWSTART = Field<22, 1>;    // Start conversion of regular channels
            using JSWSTART = Field<21, 1>;    // Start conversion of injected channels
            using EXTTRIG = Field<20, 1>;    // External trigger conversion mode for regular channels
            using EXTSEL = Field<17, 3>;    // External event select for regular group
            using JEXTTRIG = Field<15, 1>;    // External trigger conversion mode for injected channels
            using JEXTSEL = Field<12, 3>;    // External event select for injected group
            using ALIGN = Field<11, 1>;    // Data alignment
            using DMA = Field<8, 1>;    // Direct memory access mode
            using RSTCAL = Field<3, 1>;    // Reset calibration
            using CAL = Field<2, 1>;    // A/D calibration
            using CONT = Field<1, 1>;    // Continuous conversion
            using ADON = Field<0, 1>;    // A/D converter ON / OFF
        };

        // sample time register 1
        struct SMPR1 : public Register<0x4001280c> {
            using SMPx_x = Field<0, 32>;    // Sample time bits
        };

        // sample time register 2
        struct SMPR2 : public Register<0x40012810> {
            using SMPx_x = Field<0, 32>;    // Sample time bits
        };

        // injected channel data offset register x
        struct JOFR1 : public Register<0x40012814> {
            using JOFFSET1 = Field<0, 12>;    // Data offset for injected channel x
        };

        // injected channel data offset register x
        struct JOFR2 : public Register<0x40012818> {
            using JOFFSET2 = Field<0, 12>;    // Data offset for injected channel x
        };

        // injected channel data offset register x
        struct JOFR3 : public Register<0x4001281c> {
            using JOFFSET3 = Field<0, 12>;    // Data offset for injected channel x
        };

        // injected channel data offset register x
        struct JOFR4 : public Register<0x40012820> {
            using JOFFSET4 = Field<0, 12>;    // Data offset for injected channel x
        };

        // watchdog higher threshold register
        struct HTR : public Register<0x40012824> {
            using HT = Field<0, 12>;    // Analog watchdog higher threshold
        };

        // watchdog lower threshold register
        struct LTR : public Register<0x40012828> {
            using LT = Field<0, 12>;    // Analog watchdog lower threshold
        };

        // regular sequence register 1
        struct SQR1 : public Register<0x4001282c> {
            using L = Field<20, 4>;    // Regular channel sequence length
            using SQ16 = Field<15, 5>;    // 16th conversion in regular sequence
            using SQ15 = Field<10, 5>;    // 15th conversion in regular sequence
            using SQ14 = Field<5, 5>;    // 14th conversion in regular sequence
            using SQ13 = Field<0, 5>;    // 13th conversion in regular sequence
        };

        // regular sequence register 2
        struct SQR2 : public Register<0x40012830> {
            using SQ12 = Field<25, 5>;    // 12th conversion in regular sequence
            using SQ11 = Field<20, 5>;    // 11th conversion in regular sequence
            using SQ10 = Field<15, 5>;    // 10th conversion in regular sequence
            using SQ9 = Field<10, 5>;    // 9th conversion in regular sequence
            using SQ8 = Field<5, 5>;    // 8th conversion in regular sequence
            using SQ7 = Field<0, 5>;    // 7th conversion in regular sequence
        };

        // regular sequence register 3
        struct SQR3 : public Register<0x40012834> {
            using SQ6 = Field<25, 5>;    // 6th conversion in regular sequence
            using SQ5 = Field<20, 5>;    // 5th conversion in regular sequence
            using SQ4 = Field<15, 5>;    // 4th conversion in regular sequence
            using SQ3 = Field<10, 5>;    // 3rd conversion in regular sequence
            using SQ2 = Field<5, 5>;    // 2nd conversion in regular sequence
            using SQ1 = Field<0, 5>;    // 1st conversion in regular sequence
        };

        // injected sequence register
        struct JSQR : public Register<0x40012838> {
            using JL = Field<20, 2>;    // Injected sequence length
            using JSQ4 = Field<15, 5>;    // 4th conversion in injected sequence
            using JSQ3 = Field<10, 5>;    // 3rd conversion in injected sequence
            using JSQ2 = Field<5, 5>;    // 2nd conversion in injected sequence
            using JSQ1 = Field<0, 5>;    // 1st conversion in injected sequence
        };

        // injected data register x
        struct JDR1 : public RegisterReadOnly<0x4001283c> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // injected data register x
        struct JDR2 : public RegisterReadOnly<0x40012840> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // injected data register x
        struct JDR3 : public RegisterReadOnly<0x40012844> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // injected data register x
        struct JDR4 : public RegisterReadOnly<0x40012848> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // regular data register
        struct DR : public RegisterReadOnly<0x4001284c> {
            using DATA = Field<0, 16>;    // Regular data
        };

    };

    // Analog to digital converter
    struct ADC3 {
        // status register
        struct SR : public Register<0x40013c00> {
            using STRT = Field<4, 1>;    // Regular channel start flag
            using JSTRT = Field<3, 1>;    // Injected channel start flag
            using JEOC = Field<2, 1>;    // Injected channel end of conversion
            using EOC = Field<1, 1>;    // Regular channel end of conversion
            using AWD = Field<0, 1>;    // Analog watchdog flag
        };

        // control register 1
        struct CR1 : public Register<0x40013c04> {
            using AWDEN = Field<23, 1>;    // Analog watchdog enable on regular channels
            using JAWDEN = Field<22, 1>;    // Analog watchdog enable on injected channels
            using DUALMOD = Field<16, 4>;    // Dual mode selection
            using DISCNUM = Field<13, 3>;    // Discontinuous mode channel count
            using JDISCEN = Field<12, 1>;    // Discontinuous mode on injected channels
            using DISCEN = Field<11, 1>;    // Discontinuous mode on regular channels
            using JAUTO = Field<10, 1>;    // Automatic injected group conversion
            using AWDSGL = Field<9, 1>;    // Enable the watchdog on a single channel in scan mode
            using SCAN = Field<8, 1>;    // Scan mode
            using JEOCIE = Field<7, 1>;    // Interrupt enable for injected channels
            using AWDIE = Field<6, 1>;    // Analog watchdog interrupt enable
            using EOCIE = Field<5, 1>;    // Interrupt enable for EOC
            using AWDCH = Field<0, 5>;    // Analog watchdog channel select bits
        };

        // control register 2
        struct CR2 : public Register<0x40013c08> {
            using TSVREFE = Field<23, 1>;    // Temperature sensor and VREFINT enable
            using SWSTART = Field<22, 1>;    // Start conversion of regular channels
            using JSWSTART = Field<21, 1>;    // Start conversion of injected channels
            using EXTTRIG = Field<20, 1>;    // External trigger conversion mode for regular channels
            using EXTSEL = Field<17, 3>;    // External event select for regular group
            using JEXTTRIG = Field<15, 1>;    // External trigger conversion mode for injected channels
            using JEXTSEL = Field<12, 3>;    // External event select for injected group
            using ALIGN = Field<11, 1>;    // Data alignment
            using DMA = Field<8, 1>;    // Direct memory access mode
            using RSTCAL = Field<3, 1>;    // Reset calibration
            using CAL = Field<2, 1>;    // A/D calibration
            using CONT = Field<1, 1>;    // Continuous conversion
            using ADON = Field<0, 1>;    // A/D converter ON / OFF
        };

        // sample time register 1
        struct SMPR1 : public Register<0x40013c0c> {
            using SMPx_x = Field<0, 32>;    // Sample time bits
        };

        // sample time register 2
        struct SMPR2 : public Register<0x40013c10> {
            using SMPx_x = Field<0, 32>;    // Sample time bits
        };

        // injected channel data offset register x
        struct JOFR1 : public Register<0x40013c14> {
            using JOFFSET1 = Field<0, 12>;    // Data offset for injected channel x
        };

        // injected channel data offset register x
        struct JOFR2 : public Register<0x40013c18> {
            using JOFFSET2 = Field<0, 12>;    // Data offset for injected channel x
        };

        // injected channel data offset register x
        struct JOFR3 : public Register<0x40013c1c> {
            using JOFFSET3 = Field<0, 12>;    // Data offset for injected channel x
        };

        // injected channel data offset register x
        struct JOFR4 : public Register<0x40013c20> {
            using JOFFSET4 = Field<0, 12>;    // Data offset for injected channel x
        };

        // watchdog higher threshold register
        struct HTR : public Register<0x40013c24> {
            using HT = Field<0, 12>;    // Analog watchdog higher threshold
        };

        // watchdog lower threshold register
        struct LTR : public Register<0x40013c28> {
            using LT = Field<0, 12>;    // Analog watchdog lower threshold
        };

        // regular sequence register 1
        struct SQR1 : public Register<0x40013c2c> {
            using L = Field<20, 4>;    // Regular channel sequence length
            using SQ16 = Field<15, 5>;    // 16th conversion in regular sequence
            using SQ15 = Field<10, 5>;    // 15th conversion in regular sequence
            using SQ14 = Field<5, 5>;    // 14th conversion in regular sequence
            using SQ13 = Field<0, 5>;    // 13th conversion in regular sequence
        };

        // regular sequence register 2
        struct SQR2 : public Register<0x40013c30> {
            using SQ12 = Field<25, 5>;    // 12th conversion in regular sequence
            using SQ11 = Field<20, 5>;    // 11th conversion in regular sequence
            using SQ10 = Field<15, 5>;    // 10th conversion in regular sequence
            using SQ9 = Field<10, 5>;    // 9th conversion in regular sequence
            using SQ8 = Field<5, 5>;    // 8th conversion in regular sequence
            using SQ7 = Field<0, 5>;    // 7th conversion in regular sequence
        };

        // regular sequence register 3
        struct SQR3 : public Register<0x40013c34> {
            using SQ6 = Field<25, 5>;    // 6th conversion in regular sequence
            using SQ5 = Field<20, 5>;    // 5th conversion in regular sequence
            using SQ4 = Field<15, 5>;    // 4th conversion in regular sequence
            using SQ3 = Field<10, 5>;    // 3rd conversion in regular sequence
            using SQ2 = Field<5, 5>;    // 2nd conversion in regular sequence
            using SQ1 = Field<0, 5>;    // 1st conversion in regular sequence
        };

        // injected sequence register
        struct JSQR : public Register<0x40013c38> {
            using JL = Field<20, 2>;    // Injected sequence length
            using JSQ4 = Field<15, 5>;    // 4th conversion in injected sequence
            using JSQ3 = Field<10, 5>;    // 3rd conversion in injected sequence
            using JSQ2 = Field<5, 5>;    // 2nd conversion in injected sequence
            using JSQ1 = Field<0, 5>;    // 1st conversion in injected sequence
        };

        // injected data register x
        struct JDR1 : public RegisterReadOnly<0x40013c3c> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // injected data register x
        struct JDR2 : public RegisterReadOnly<0x40013c40> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // injected data register x
        struct JDR3 : public RegisterReadOnly<0x40013c44> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // injected data register x
        struct JDR4 : public RegisterReadOnly<0x40013c48> {
            using JDATA = Field<0, 16>;    // Injected data
        };

        // regular data register
        struct DR : public RegisterReadOnly<0x40013c4c> {
            using DATA = Field<0, 16>;    // Regular data
        };

    };

    // Advanced timer
    struct TIM1 {
        // control register 1
        struct CR1 : public Register<0x40012c00> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40012c04> {
            using OIS4 = Field<14, 1>;    // Output Idle state 4
            using OIS3N = Field<13, 1>;    // Output Idle state 3
            using OIS3 = Field<12, 1>;    // Output Idle state 3
            using OIS2N = Field<11, 1>;    // Output Idle state 2
            using OIS2 = Field<10, 1>;    // Output Idle state 2
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
        };

        // slave mode control register
        struct SMCR : public Register<0x40012c08> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x40012c0c> {
            using UIE = Field<0, 1>;    // Update interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using TDE = Field<14, 1>;    // Trigger DMA request enable
        };

        // status register
        struct SR : public Register<0x40012c10> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40012c14> {
            using BG = Field<7, 1>;    // Break generation
            using TG = Field<6, 1>;    // Trigger generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register (output mode)
        struct CCMR1_Output : public Register<0x40012c18> {
            using OC2CE = Field<15, 1>;    // Output Compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output Compare 2 mode
            using OC2PE = Field<11, 1>;    // Output Compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output Compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output Compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40012c18> {
            using IC2F = Field<15, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register (output mode)
        struct CCMR2_Output : public Register<0x40012c1c> {
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x40012c1c> {
            using IC4F = Field<15, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40012c20> {
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3NE = Field<10, 1>;    // Capture/Compare 3 complementary output enable
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2NE = Field<6, 1>;    // Capture/Compare 2 complementary output enable
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40012c24> {
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40012c28> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x40012c2c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40012c34> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40012c38> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x40012c3c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40012c40> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40012c48> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x40012c4c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // repetition counter register
        struct RCR : public Register<0x40012c30> {
            using REP = Field<0, 8>;    // Repetition counter value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40012c44> {
            using MOE = Field<15, 1>;    // Main output enable
            using AOE = Field<14, 1>;    // Automatic output enable
            using BKP = Field<13, 1>;    // Break polarity
            using BKE = Field<12, 1>;    // Break enable
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using LOCK = Field<8, 2>;    // Lock configuration
            using DTG = Field<0, 8>;    // Dead-time generator setup
        };

    };

    // Advanced timer
    struct TIM8 {
        // control register 1
        struct CR1 : public Register<0x40013400> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40013404> {
            using OIS4 = Field<14, 1>;    // Output Idle state 4
            using OIS3N = Field<13, 1>;    // Output Idle state 3
            using OIS3 = Field<12, 1>;    // Output Idle state 3
            using OIS2N = Field<11, 1>;    // Output Idle state 2
            using OIS2 = Field<10, 1>;    // Output Idle state 2
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
        };

        // slave mode control register
        struct SMCR : public Register<0x40013408> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001340c> {
            using UIE = Field<0, 1>;    // Update interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using TDE = Field<14, 1>;    // Trigger DMA request enable
        };

        // status register
        struct SR : public Register<0x40013410> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40013414> {
            using BG = Field<7, 1>;    // Break generation
            using TG = Field<6, 1>;    // Trigger generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register (output mode)
        struct CCMR1_Output : public Register<0x40013418> {
            using OC2CE = Field<15, 1>;    // Output Compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output Compare 2 mode
            using OC2PE = Field<11, 1>;    // Output Compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output Compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output Compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40013418> {
            using IC2F = Field<15, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register (output mode)
        struct CCMR2_Output : public Register<0x4001341c> {
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4001341c> {
            using IC4F = Field<15, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40013420> {
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3NE = Field<10, 1>;    // Capture/Compare 3 complementary output enable
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2NE = Field<6, 1>;    // Capture/Compare 2 complementary output enable
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40013424> {
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40013428> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001342c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40013434> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40013438> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4001343c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40013440> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40013448> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4001344c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // repetition counter register
        struct RCR : public Register<0x40013430> {
            using REP = Field<0, 8>;    // Repetition counter value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40013444> {
            using MOE = Field<15, 1>;    // Main output enable
            using AOE = Field<14, 1>;    // Automatic output enable
            using BKP = Field<13, 1>;    // Break polarity
            using BKE = Field<12, 1>;    // Break enable
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using LOCK = Field<8, 2>;    // Lock configuration
            using DTG = Field<0, 8>;    // Dead-time generator setup
        };

    };

    // Secure digital input/output interface
    struct SDIO {
        // Bits 1:0 = PWRCTRL: Power supply control bits
        struct POWER : public Register<0x40018000> {
            using PWRCTRL = Field<0, 2>;    // PWRCTRL
        };

        // SDI clock control register (SDIO_CLKCR)
        struct CLKCR : public Register<0x40018004> {
            using CLKDIV = Field<0, 8>;    // Clock divide factor
            using CLKEN = Field<8, 1>;    // Clock enable bit
            using PWRSAV = Field<9, 1>;    // Power saving configuration bit
            using BYPASS = Field<10, 1>;    // Clock divider bypass enable bit
            using WIDBUS = Field<11, 2>;    // Wide bus mode enable bit
            using NEGEDGE = Field<13, 1>;    // SDIO_CK dephasing selection bit
            using HWFC_EN = Field<14, 1>;    // HW Flow Control enable
        };

        // Bits 31:0 = : Command argument
        struct ARG : public Register<0x40018008> {
            using CMDARG = Field<0, 32>;    // Command argument
        };

        // SDIO command register (SDIO_CMD)
        struct CMD : public Register<0x4001800c> {
            using CMDINDEX = Field<0, 6>;    // CMDINDEX
            using WAITRESP = Field<6, 2>;    // WAITRESP
            using WAITINT = Field<8, 1>;    // WAITINT
            using WAITPEND = Field<9, 1>;    // WAITPEND
            using CPSMEN = Field<10, 1>;    // CPSMEN
            using SDIOSuspend = Field<11, 1>;    // SDIOSuspend
            using ENCMDcompl = Field<12, 1>;    // ENCMDcompl
            using nIEN = Field<13, 1>;    // nIEN
            using CE_ATACMD = Field<14, 1>;    // CE_ATACMD
        };

        // SDIO command register
        struct RESPCMD : public RegisterReadOnly<0x40018010> {
            using Field = Field<0, 6>;    // RESPCMD
        };

        // Bits 31:0 = CARDSTATUS1
        struct RESPI1 : public RegisterReadOnly<0x40018014> {
            using CARDSTATUS1 = Field<0, 32>;    // CARDSTATUS1
        };

        // Bits 31:0 = CARDSTATUS2
        struct RESP2 : public RegisterReadOnly<0x40018018> {
            using CARDSTATUS2 = Field<0, 32>;    // CARDSTATUS2
        };

        // Bits 31:0 = CARDSTATUS3
        struct RESP3 : public RegisterReadOnly<0x4001801c> {
            using CARDSTATUS3 = Field<0, 32>;    // CARDSTATUS3
        };

        // Bits 31:0 = CARDSTATUS4
        struct RESP4 : public RegisterReadOnly<0x40018020> {
            using CARDSTATUS4 = Field<0, 32>;    // CARDSTATUS4
        };

        // Bits 31:0 = DATATIME: Data timeout period
        struct DTIMER : public Register<0x40018024> {
            using DATATIME = Field<0, 32>;    // Data timeout period
        };

        // Bits 24:0 = DATALENGTH: Data length value
        struct DLEN : public Register<0x40018028> {
            using DATALENGTH = Field<0, 25>;    // Data length value
        };

        // SDIO data control register (SDIO_DCTRL)
        struct DCTRL : public Register<0x4001802c> {
            using DTEN = Field<0, 1>;    // DTEN
            using DTDIR = Field<1, 1>;    // DTDIR
            using DTMODE = Field<2, 1>;    // DTMODE
            using DMAEN = Field<3, 1>;    // DMAEN
            using DBLOCKSIZE = Field<4, 4>;    // DBLOCKSIZE
            using PWSTART = Field<8, 1>;    // PWSTART
            using PWSTOP = Field<9, 1>;    // PWSTOP
            using RWMOD = Field<10, 1>;    // RWMOD
            using SDIOEN = Field<11, 1>;    // SDIOEN
        };

        // Bits 24:0 = DATACOUNT: Data count value
        struct DCOUNT : public RegisterReadOnly<0x40018030> {
            using DATACOUNT = Field<0, 25>;    // Data count value
        };

        // SDIO status register (SDIO_STA)
        struct STA : public RegisterReadOnly<0x40018034> {
            using CCRCFAIL = Field<0, 1>;    // CCRCFAIL
            using DCRCFAIL = Field<1, 1>;    // DCRCFAIL
            using CTIMEOUT = Field<2, 1>;    // CTIMEOUT
            using DTIMEOUT = Field<3, 1>;    // DTIMEOUT
            using TXUNDERR = Field<4, 1>;    // TXUNDERR
            using RXOVERR = Field<5, 1>;    // RXOVERR
            using CMDREND = Field<6, 1>;    // CMDREND
            using CMDSENT = Field<7, 1>;    // CMDSENT
            using DATAEND = Field<8, 1>;    // DATAEND
            using STBITERR = Field<9, 1>;    // STBITERR
            using DBCKEND = Field<10, 1>;    // DBCKEND
            using CMDACT = Field<11, 1>;    // CMDACT
            using TXACT = Field<12, 1>;    // TXACT
            using RXACT = Field<13, 1>;    // RXACT
            using TXFIFOHE = Field<14, 1>;    // TXFIFOHE
            using RXFIFOHF = Field<15, 1>;    // RXFIFOHF
            using TXFIFOF = Field<16, 1>;    // TXFIFOF
            using RXFIFOF = Field<17, 1>;    // RXFIFOF
            using TXFIFOE = Field<18, 1>;    // TXFIFOE
            using RXFIFOE = Field<19, 1>;    // RXFIFOE
            using TXDAVL = Field<20, 1>;    // TXDAVL
            using RXDAVL = Field<21, 1>;    // RXDAVL
            using SDIOIT = Field<22, 1>;    // SDIOIT
            using CEATAEND = Field<23, 1>;    // CEATAEND
        };

        // SDIO interrupt clear register (SDIO_ICR)
        struct ICR : public Register<0x40018038> {
            using CCRCFAILC = Field<0, 1>;    // CCRCFAILC
            using DCRCFAILC = Field<1, 1>;    // DCRCFAILC
            using CTIMEOUTC = Field<2, 1>;    // CTIMEOUTC
            using DTIMEOUTC = Field<3, 1>;    // DTIMEOUTC
            using TXUNDERRC = Field<4, 1>;    // TXUNDERRC
            using RXOVERRC = Field<5, 1>;    // RXOVERRC
            using CMDRENDC = Field<6, 1>;    // CMDRENDC
            using CMDSENTC = Field<7, 1>;    // CMDSENTC
            using DATAENDC = Field<8, 1>;    // DATAENDC
            using STBITERRC = Field<9, 1>;    // STBITERRC
            using DBCKENDC = Field<10, 1>;    // DBCKENDC
            using SDIOITC = Field<22, 1>;    // SDIOITC
            using CEATAENDC = Field<23, 1>;    // CEATAENDC
        };

        // SDIO mask register (SDIO_MASK)
        struct MASK : public Register<0x4001803c> {
            using CCRCFAILIE = Field<0, 1>;    // CCRCFAILIE
            using DCRCFAILIE = Field<1, 1>;    // DCRCFAILIE
            using CTIMEOUTIE = Field<2, 1>;    // CTIMEOUTIE
            using DTIMEOUTIE = Field<3, 1>;    // DTIMEOUTIE
            using TXUNDERRIE = Field<4, 1>;    // TXUNDERRIE
            using RXOVERRIE = Field<5, 1>;    // RXOVERRIE
            using CMDRENDIE = Field<6, 1>;    // CMDRENDIE
            using CMDSENTIE = Field<7, 1>;    // CMDSENTIE
            using DATAENDIE = Field<8, 1>;    // DATAENDIE
            using STBITERRIE = Field<9, 1>;    // STBITERRIE
            using DBACKENDIE = Field<10, 1>;    // DBACKENDIE
            using CMDACTIE = Field<11, 1>;    // CMDACTIE
            using TXACTIE = Field<12, 1>;    // TXACTIE
            using RXACTIE = Field<13, 1>;    // RXACTIE
            using TXFIFOHEIE = Field<14, 1>;    // TXFIFOHEIE
            using RXFIFOHFIE = Field<15, 1>;    // RXFIFOHFIE
            using TXFIFOFIE = Field<16, 1>;    // TXFIFOFIE
            using RXFIFOFIE = Field<17, 1>;    // RXFIFOFIE
            using TXFIFOEIE = Field<18, 1>;    // TXFIFOEIE
            using RXFIFOEIE = Field<19, 1>;    // RXFIFOEIE
            using TXDAVLIE = Field<20, 1>;    // TXDAVLIE
            using RXDAVLIE = Field<21, 1>;    // RXDAVLIE
            using SDIOITIE = Field<22, 1>;    // SDIOITIE
            using CEATENDIE = Field<23, 1>;    // CEATENDIE
        };

        // Bits 23:0 = FIFOCOUNT: Remaining number of words to be written to or read from the FIFO
        struct FIFOCNT : public RegisterReadOnly<0x40018048> {
            using FIF0COUNT = Field<0, 24>;    // FIF0COUNT
        };

        // bits 31:0 = FIFOData: Receive and transmit FIFO data
        struct FIFO : public Register<0x40018080> {
            using FIFOData = Field<0, 32>;    // FIFOData
        };

    };

    // Nested Vectored Interrupt Controller
    struct NVIC {
        // Interrupt Set-Enable Register
        struct ISER0 : public Register<0xe000e100> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Set-Enable Register
        struct ISER1 : public Register<0xe000e104> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Clear-Enable Register
        struct ICER0 : public Register<0xe000e180> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Clear-Enable Register
        struct ICER1 : public Register<0xe000e184> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Set-Pending Register
        struct ISPR0 : public Register<0xe000e200> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Set-Pending Register
        struct ISPR1 : public Register<0xe000e204> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR0 : public Register<0xe000e280> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR1 : public Register<0xe000e284> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Active Bit Register
        struct IABR0 : public RegisterReadOnly<0xe000e300> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Active Bit Register
        struct IABR1 : public RegisterReadOnly<0xe000e304> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Priority Register
        struct IPR0 : public Register<0xe000e400> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR1 : public Register<0xe000e404> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR2 : public Register<0xe000e408> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR3 : public Register<0xe000e40c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR4 : public Register<0xe000e410> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR5 : public Register<0xe000e414> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR6 : public Register<0xe000e418> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR7 : public Register<0xe000e41c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR8 : public Register<0xe000e420> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR9 : public Register<0xe000e424> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR10 : public Register<0xe000e428> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR11 : public Register<0xe000e42c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR12 : public Register<0xe000e430> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR13 : public Register<0xe000e434> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR14 : public Register<0xe000e438> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

    };

    // Memory protection unit
    struct MPU {
        // MPU type register
        struct MPU_TYPER : public RegisterReadOnly<0xe000ed90> {
            using SEPARATE = Field<0, 1>;    // Separate flag
            using DREGION = Field<8, 8>;    // Number of MPU data regions
            using IREGION = Field<16, 8>;    // Number of MPU instruction regions
        };

        // MPU control register
        struct MPU_CTRL : public RegisterReadOnly<0xe000ed94> {
            using ENABLE = Field<0, 1>;    // Enables the MPU
            using HFNMIENA = Field<1, 1>;    // Enables the operation of MPU during hard fault
            using PRIVDEFENA = Field<2, 1>;    // Enable priviliged software access to default memory map
        };

        // MPU region number register
        struct MPU_RNR : public Register<0xe000ed98> {
            using REGION = Field<0, 8>;    // MPU region
        };

        // MPU region base address register
        struct MPU_RBAR : public Register<0xe000ed9c> {
            using REGION = Field<0, 4>;    // MPU region field
            using VALID = Field<4, 1>;    // MPU region number valid
            using ADDR = Field<5, 27>;    // Region base address field
        };

        // MPU region attribute and size register
        struct MPU_RASR : public Register<0xe000eda0> {
            using ENABLE = Field<0, 1>;    // Region enable bit.
            using SIZE = Field<1, 5>;    // Size of the MPU protection region
            using SRD = Field<8, 8>;    // Subregion disable bits
            using B = Field<16, 1>;    // memory attribute
            using C = Field<17, 1>;    // memory attribute
            using S = Field<18, 1>;    // Shareable memory attribute
            using TEX = Field<19, 3>;    // memory attribute
            using AP = Field<24, 3>;    // Access permission
            using XN = Field<28, 1>;    // Instruction access disable bit
        };

    };

    // System control block ACTLR
    struct SCB_ACTRL {
        // Auxiliary control register
        struct ACTRL : public Register<0xe000e008> {
            using DISFOLD = Field<2, 1>;    // DISFOLD
            using FPEXCODIS = Field<10, 1>;    // FPEXCODIS
            using DISRAMODE = Field<11, 1>;    // DISRAMODE
            using DISITMATBFLUSH = Field<12, 1>;    // DISITMATBFLUSH
        };

    };

    // Nested vectored interrupt controller
    struct NVIC_STIR {
        // Software trigger interrupt register
        struct STIR : public Register<0xe000ef00> {
            using INTID = Field<0, 9>;    // Software generated interrupt ID
        };

    };

    // System control block
    struct SCB {
        // CPUID base register
        struct CPUID : public RegisterReadOnly<0xe000ed00> {
            using Revision = Field<0, 4>;    // Revision number
            using PartNo = Field<4, 12>;    // Part number of the processor
            using Constant = Field<16, 4>;    // Reads as 0xF
            using Variant = Field<20, 4>;    // Variant number
            using Implementer = Field<24, 8>;    // Implementer code
        };

        // Interrupt control and state register
        struct ICSR : public Register<0xe000ed04> {
            using VECTACTIVE = Field<0, 9>;    // Active vector
            using RETTOBASE = Field<11, 1>;    // Return to base level
            using VECTPENDING = Field<12, 7>;    // Pending vector
            using ISRPENDING = Field<22, 1>;    // Interrupt pending flag
            using PENDSTCLR = Field<25, 1>;    // SysTick exception clear-pending bit
            using PENDSTSET = Field<26, 1>;    // SysTick exception set-pending bit
            using PENDSVCLR = Field<27, 1>;    // PendSV clear-pending bit
            using PENDSVSET = Field<28, 1>;    // PendSV set-pending bit
            using NMIPENDSET = Field<31, 1>;    // NMI set-pending bit.
        };

        // Vector table offset register
        struct VTOR : public Register<0xe000ed08> {
            using TBLOFF = Field<9, 21>;    // Vector table base offset field
        };

        // Application interrupt and reset control register
        struct AIRCR : public Register<0xe000ed0c> {
            using VECTRESET = Field<0, 1>;    // VECTRESET
            using VECTCLRACTIVE = Field<1, 1>;    // VECTCLRACTIVE
            using SYSRESETREQ = Field<2, 1>;    // SYSRESETREQ
            using PRIGROUP = Field<8, 3>;    // PRIGROUP
            using ENDIANESS = Field<15, 1>;    // ENDIANESS
            using VECTKEYSTAT = Field<16, 16>;    // Register key
        };

        // System control register
        struct SCR : public Register<0xe000ed10> {
            using SLEEPONEXIT = Field<1, 1>;    // SLEEPONEXIT
            using SLEEPDEEP = Field<2, 1>;    // SLEEPDEEP
            using SEVEONPEND = Field<4, 1>;    // Send Event on Pending bit
        };

        // Configuration and control register
        struct CCR : public Register<0xe000ed14> {
            using NONBASETHRDENA = Field<0, 1>;    // Configures how the processor enters Thread mode
            using USERSETMPEND = Field<1, 1>;    // USERSETMPEND
            using UNALIGN__TRP = Field<3, 1>;    // UNALIGN_ TRP
            using DIV_0_TRP = Field<4, 1>;    // DIV_0_TRP
            using BFHFNMIGN = Field<8, 1>;    // BFHFNMIGN
            using STKALIGN = Field<9, 1>;    // STKALIGN
        };

        // System handler priority registers
        struct SHPR1 : public Register<0xe000ed18> {
            using PRI_4 = Field<0, 8>;    // Priority of system handler 4
            using PRI_5 = Field<8, 8>;    // Priority of system handler 5
            using PRI_6 = Field<16, 8>;    // Priority of system handler 6
        };

        // System handler priority registers
        struct SHPR2 : public Register<0xe000ed1c> {
            using PRI_11 = Field<24, 8>;    // Priority of system handler 11
        };

        // System handler priority registers
        struct SHPR3 : public Register<0xe000ed20> {
            using PRI_14 = Field<16, 8>;    // Priority of system handler 14
            using PRI_15 = Field<24, 8>;    // Priority of system handler 15
        };

        // System handler control and state register
        struct SHCRS : public Register<0xe000ed24> {
            using MEMFAULTACT = Field<0, 1>;    // Memory management fault exception active bit
            using BUSFAULTACT = Field<1, 1>;    // Bus fault exception active bit
            using USGFAULTACT = Field<3, 1>;    // Usage fault exception active bit
            using SVCALLACT = Field<7, 1>;    // SVC call active bit
            using MONITORACT = Field<8, 1>;    // Debug monitor active bit
            using PENDSVACT = Field<10, 1>;    // PendSV exception active bit
            using SYSTICKACT = Field<11, 1>;    // SysTick exception active bit
            using USGFAULTPENDED = Field<12, 1>;    // Usage fault exception pending bit
            using MEMFAULTPENDED = Field<13, 1>;    // Memory management fault exception pending bit
            using BUSFAULTPENDED = Field<14, 1>;    // Bus fault exception pending bit
            using SVCALLPENDED = Field<15, 1>;    // SVC call pending bit
            using MEMFAULTENA = Field<16, 1>;    // Memory management fault enable bit
            using BUSFAULTENA = Field<17, 1>;    // Bus fault enable bit
            using USGFAULTENA = Field<18, 1>;    // Usage fault enable bit
        };

        // Configurable fault status register
        struct CFSR_UFSR_BFSR_MMFSR : public Register<0xe000ed28> {
            using IACCVIOL = Field<0, 1>;    // IACCVIOL
            using DACCVIOL = Field<1, 1>;    // DACCVIOL
            using MUNSTKERR = Field<3, 1>;    // MUNSTKERR
            using MSTKERR = Field<4, 1>;    // MSTKERR
            using MLSPERR = Field<5, 1>;    // MLSPERR
            using MMARVALID = Field<7, 1>;    // MMARVALID
            using IBUSERR = Field<8, 1>;    // Instruction bus error
            using PRECISERR = Field<9, 1>;    // Precise data bus error
            using IMPRECISERR = Field<10, 1>;    // Imprecise data bus error
            using UNSTKERR = Field<11, 1>;    // Bus fault on unstacking for a return from exception
            using STKERR = Field<12, 1>;    // Bus fault on stacking for exception entry
            using LSPERR = Field<13, 1>;    // Bus fault on floating-point lazy state preservation
            using BFARVALID = Field<15, 1>;    // Bus Fault Address Register (BFAR) valid flag
            using UNDEFINSTR = Field<16, 1>;    // Undefined instruction usage fault
            using INVSTATE = Field<17, 1>;    // Invalid state usage fault
            using INVPC = Field<18, 1>;    // Invalid PC load usage fault
            using NOCP = Field<19, 1>;    // No coprocessor usage fault.
            using UNALIGNED = Field<24, 1>;    // Unaligned access usage fault
            using DIVBYZERO = Field<25, 1>;    // Divide by zero usage fault
        };

        // Hard fault status register
        struct HFSR : public Register<0xe000ed2c> {
            using VECTTBL = Field<1, 1>;    // Vector table hard fault
            using FORCED = Field<30, 1>;    // Forced hard fault
            using DEBUG_VT = Field<31, 1>;    // Reserved for Debug use
        };

        // Memory management fault address register
        struct MMFAR : public Register<0xe000ed34> {
            using Field = Field<0, 32>;    // Memory management fault address
        };

        // Bus fault address register
        struct BFAR : public Register<0xe000ed38> {
            using Field = Field<0, 32>;    // Bus fault address
        };

    };

    // SysTick timer
    struct STK {
        // SysTick control and status register
        struct CTRL : public Register<0xe000e010> {
            using ENABLE = Field<0, 1>;    // Counter enable
            using TICKINT = Field<1, 1>;    // SysTick exception request enable
            using CLKSOURCE = Field<2, 1>;    // Clock source selection
            using COUNTFLAG = Field<16, 1>;    // COUNTFLAG
        };

        // SysTick reload value register
        struct LOAD_ : public Register<0xe000e014> {
            using RELOAD = Field<0, 24>;    // RELOAD value
        };

        // SysTick current value register
        struct VAL : public Register<0xe000e018> {
            using CURRENT = Field<0, 24>;    // Current counter value
        };

        // SysTick calibration value register
        struct CALIB : public Register<0xe000e01c> {
            using TENMS = Field<0, 24>;    // Calibration value
        };

    };

    static std::uint32_t const numInterrupts = 60;

    enum class Interrupts: std::uint32_t {
        WWDG = 0,
        PVD = 1,
        TAMPER = 2,
        RTC = 3,
        FLASH = 4,
        RCC = 5,
        EXTI0 = 6,
        EXTI1 = 7,
        EXTI2 = 8,
        EXTI3 = 9,
        EXTI4 = 10,
        DMA1_Channel1 = 11,
        DMA1_Channel2 = 12,
        DMA1_Channel3 = 13,
        DMA1_Channel4 = 14,
        DMA1_Channel5 = 15,
        DMA1_Channel6 = 16,
        DMA1_Channel7 = 17,
        ADC1_2 = 18,
        USB_HP_CAN_TX = 19,
        USB_LP_CAN_RX0 = 20,
        CAN1_RX1 = 21,
        CAN1_SCE = 22,
        EXTI9_5 = 23,
        TIM1_BRK = 24,
        TIM1_UP = 25,
        TIM1_TRG_COM = 26,
        TIM1_CC = 27,
        TIM2 = 28,
        TIM3 = 29,
        TIM4 = 30,
        I2C1_EV = 31,
        I2C1_ER = 32,
        I2C2_EV = 33,
        I2C2_ER = 34,
        SPI1 = 35,
        SPI2 = 36,
        USART1 = 37,
        USART2 = 38,
        USART3 = 39,
        EXTI15_10 = 40,
        RTC_Alarm = 41,
        USBWakeup = 42,
        TIM8_BRK = 43,
        TIM8_UP = 44,
        TIM8_TRG_COM = 45,
        TIM8_CC = 46,
        ADC3 = 47,
        FSMC = 48,
        SDIO = 49,
        TIM5 = 50,
        SPI3 = 51,
        UART4 = 52,
        UART5 = 53,
        TIM6 = 54,
        TIM7 = 55,
        DMA2_CH1 = 56,
        DMA2_CH2 = 57,
        DMA2_CH3 = 58,
        DMA2_Channel4_5 = 59,
    };

};
