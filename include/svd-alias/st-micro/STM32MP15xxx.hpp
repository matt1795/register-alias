// This is a file generated by svd-alias.

#pragma once

#include "svd-alias/bit-field.hpp"
#include "svd-alias/register.hpp"

struct STM32MP15xxx {
    // ADC2
    struct ADC2 {
        // ADC interrupt and status register
        struct ADC_ISR : public Register<0x48003100> {
            using ADRDY = Field<0, 1>;    // ADRDY
            using EOSMP = Field<1, 1>;    // EOSMP
            using EOC = Field<2, 1>;    // EOC
            using EOS = Field<3, 1>;    // EOS
            using OVR = Field<4, 1>;    // OVR
            using JEOC = Field<5, 1>;    // JEOC
            using JEOS = Field<6, 1>;    // JEOS
            using AWD1 = Field<7, 1>;    // AWD1
            using AWD2 = Field<8, 1>;    // AWD2
            using AWD3 = Field<9, 1>;    // AWD3
            using JQOVF = Field<10, 1>;    // JQOVF
        };

        // ADC interrupt enable register
        struct ADC_IER : public Register<0x48003104> {
            using ADRDYIE = Field<0, 1>;    // ADRDYIE
            using EOSMPIE = Field<1, 1>;    // EOSMPIE
            using EOCIE = Field<2, 1>;    // EOCIE
            using EOSIE = Field<3, 1>;    // EOSIE
            using OVRIE = Field<4, 1>;    // OVRIE
            using JEOCIE = Field<5, 1>;    // JEOCIE
            using JEOSIE = Field<6, 1>;    // JEOSIE
            using AWD1IE = Field<7, 1>;    // AWD1IE
            using AWD2IE = Field<8, 1>;    // AWD2IE
            using AWD3IE = Field<9, 1>;    // AWD3IE
            using JQOVFIE = Field<10, 1>;    // JQOVFIE
        };

        // ADC control register
        struct ADC_CR : public Register<0x48003108> {
            using ADEN = Field<0, 1>;    // ADEN
            using ADDIS = Field<1, 1>;    // ADDIS
            using ADSTART = Field<2, 1>;    // ADSTART
            using JADSTART = Field<3, 1>;    // JADSTART
            using ADSTP = Field<4, 1>;    // ADSTP
            using JADSTP = Field<5, 1>;    // JADSTP
            using BOOST = Field<8, 1>;    // BOOST
            using ADCALLIN = Field<16, 1>;    // ADCALLIN
            using LINCALRDYW1 = Field<22, 1>;    // LINCALRDYW1
            using LINCALRDYW2 = Field<23, 1>;    // LINCALRDYW2
            using LINCALRDYW3 = Field<24, 1>;    // LINCALRDYW3
            using LINCALRDYW4 = Field<25, 1>;    // LINCALRDYW4
            using LINCALRDYW5 = Field<26, 1>;    // LINCALRDYW5
            using LINCALRDYW6 = Field<27, 1>;    // LINCALRDYW6
            using ADVREGEN = Field<28, 1>;    // ADVREGEN
            using DEEPPWD = Field<29, 1>;    // DEEPPWD
            using ADCALDIF = Field<30, 1>;    // ADCALDIF
            using ADCAL = Field<31, 1>;    // ADCAL
        };

        // ADC configuration register
        struct ADC_CFGR : public Register<0x4800310c> {
            using DMNGT = Field<0, 2>;    // DMNGT
            using RES = Field<2, 3>;    // RES
            using EXTSEL = Field<5, 5>;    // EXTSEL
            using EXTEN = Field<10, 2>;    // EXTEN
            using OVRMOD = Field<12, 1>;    // OVRMOD
            using CONT = Field<13, 1>;    // CONT
            using AUTDLY = Field<14, 1>;    // AUTDLY
            using DISCEN = Field<16, 1>;    // DISCEN
            using DISCNUM = Field<17, 3>;    // DISCNUM
            using JDISCEN = Field<20, 1>;    // JDISCEN
            using JQM = Field<21, 1>;    // JQM
            using AWD1SGL = Field<22, 1>;    // AWD1SGL
            using AWD1EN = Field<23, 1>;    // AWD1EN
            using JAWD1EN = Field<24, 1>;    // JAWD1EN
            using JAUTO = Field<25, 1>;    // JAUTO
            using AWD1CH = Field<26, 5>;    // AWD1CH
            using JQDIS = Field<31, 1>;    // JQDIS
        };

        // ADC configuration register 2
        struct ADC_CFGR2 : public Register<0x48003110> {
            using ROVSE = Field<0, 1>;    // ROVSE
            using JOVSE = Field<1, 1>;    // JOVSE
            using OVSS = Field<5, 4>;    // OVSS
            using TROVS = Field<9, 1>;    // TROVS
            using ROVSM = Field<10, 1>;    // ROVSM
            using RSHIFT1 = Field<11, 1>;    // RSHIFT1
            using RSHIFT2 = Field<12, 1>;    // RSHIFT2
            using RSHIFT3 = Field<13, 1>;    // RSHIFT3
            using RSHIFT4 = Field<14, 1>;    // RSHIFT4
            using OSVR = Field<16, 10>;    // OSVR
            using LSHIFT = Field<28, 4>;    // LSHIFT
        };

        // ADC sample time register 1
        struct ADC_SMPR1 : public Register<0x48003114> {
            using SMP0 = Field<0, 3>;    // SMP0
            using SMP1 = Field<3, 3>;    // SMP1
            using SMP2 = Field<6, 3>;    // SMP2
            using SMP3 = Field<9, 3>;    // SMP3
            using SMP4 = Field<12, 3>;    // SMP4
            using SMP5 = Field<15, 3>;    // SMP5
            using SMP6 = Field<18, 3>;    // SMP6
            using SMP7 = Field<21, 3>;    // SMP7
            using SMP8 = Field<24, 3>;    // SMP8
            using SMP9 = Field<27, 3>;    // SMP9
        };

        // ADC sample time register 2
        struct ADC_SMPR2 : public Register<0x48003118> {
            using SMP10 = Field<0, 3>;    // SMP10
            using SMP11 = Field<3, 3>;    // SMP11
            using SMP12 = Field<6, 3>;    // SMP12
            using SMP13 = Field<9, 3>;    // SMP13
            using SMP14 = Field<12, 3>;    // SMP14
            using SMP15 = Field<15, 3>;    // SMP15
            using SMP16 = Field<18, 3>;    // SMP16
            using SMP17 = Field<21, 3>;    // SMP17
            using SMP18 = Field<24, 3>;    // SMP18
            using SMP19 = Field<27, 3>;    // SMP19
        };

        // ADC channel preselection register
        struct ADC_PCSEL : public Register<0x4800311c> {
            using PCSEL0 = Field<0, 1>;    // PCSEL0
            using PCSEL1 = Field<1, 1>;    // PCSEL1
            using PCSEL2 = Field<2, 1>;    // PCSEL2
            using PCSEL3 = Field<3, 1>;    // PCSEL3
            using PCSEL4 = Field<4, 1>;    // PCSEL4
            using PCSEL5 = Field<5, 1>;    // PCSEL5
            using PCSEL6 = Field<6, 1>;    // PCSEL6
            using PCSEL7 = Field<7, 1>;    // PCSEL7
            using PCSEL8 = Field<8, 1>;    // PCSEL8
            using PCSEL9 = Field<9, 1>;    // PCSEL9
            using PCSEL10 = Field<10, 1>;    // PCSEL10
            using PCSEL11 = Field<11, 1>;    // PCSEL11
            using PCSEL12 = Field<12, 1>;    // PCSEL12
            using PCSEL13 = Field<13, 1>;    // PCSEL13
            using PCSEL14 = Field<14, 1>;    // PCSEL14
            using PCSEL15 = Field<15, 1>;    // PCSEL15
            using PCSEL16 = Field<16, 1>;    // PCSEL16
            using PCSEL17 = Field<17, 1>;    // PCSEL17
            using PCSEL18 = Field<18, 1>;    // PCSEL18
            using PCSEL19 = Field<19, 1>;    // PCSEL19
        };

        // ADC watchdog threshold register 1
        struct ADC_LTR1 : public Register<0x48003120> {
            using LTR1 = Field<0, 26>;    // LTR1
        };

        // ADC watchdog threshold register 1
        struct ADC_HTR1 : public Register<0x48003124> {
            using HTR1 = Field<0, 26>;    // HTR1
        };

        // ADC regular sequence register 1
        struct ADC_SQR1 : public Register<0x48003130> {
            using L = Field<0, 4>;    // L
            using SQ1 = Field<6, 5>;    // SQ1
            using SQ2 = Field<12, 5>;    // SQ2
            using SQ3 = Field<18, 5>;    // SQ3
            using SQ4 = Field<24, 5>;    // SQ4
        };

        // ADC regular sequence register 2
        struct ADC_SQR2 : public Register<0x48003134> {
            using SQ5 = Field<0, 5>;    // SQ5
            using SQ6 = Field<6, 5>;    // SQ6
            using SQ7 = Field<12, 5>;    // SQ7
            using SQ8 = Field<18, 5>;    // SQ8
            using SQ9 = Field<24, 5>;    // SQ9
        };

        // ADC regular sequence register 3
        struct ADC_SQR3 : public Register<0x48003138> {
            using SQ10 = Field<0, 5>;    // SQ10
            using SQ11 = Field<6, 5>;    // SQ11
            using SQ12 = Field<12, 5>;    // SQ12
            using SQ13 = Field<18, 5>;    // SQ13
            using SQ14 = Field<24, 5>;    // SQ14
        };

        // ADC regular sequence register 4
        struct ADC_SQR4 : public Register<0x4800313c> {
            using SQ15 = Field<0, 5>;    // SQ15
            using SQ16 = Field<6, 5>;    // SQ16
        };

        // ADC regular Data Register
        struct ADC_DR : public RegisterReadOnly<0x48003140> {
            using RDATA = Field<0, 32>;    // RDATA
        };

        // ADC injected sequence register
        struct ADC_JSQR : public Register<0x4800314c> {
            using JL = Field<0, 2>;    // JL
            using JEXTSEL = Field<2, 5>;    // JEXTSEL
            using JEXTEN = Field<7, 2>;    // JEXTEN
            using JSQ1 = Field<9, 5>;    // JSQ1
            using JSQ2 = Field<15, 5>;    // JSQ2
            using JSQ3 = Field<21, 5>;    // JSQ3
            using JSQ4 = Field<27, 5>;    // JSQ4
        };

        // ADC offset register
        struct ADC_OFR1 : public Register<0x48003160> {
            using OFFSET1 = Field<0, 26>;    // OFFSET1
            using OFFSET1_CH = Field<26, 5>;    // OFFSET1_CH
            using SSATE = Field<31, 1>;    // SSATE
        };

        // ADC offset register
        struct ADC_OFR2 : public Register<0x48003164> {
            using OFFSET2 = Field<0, 26>;    // OFFSET2
            using OFFSET2_CH = Field<26, 5>;    // OFFSET2_CH
            using SSATE = Field<31, 1>;    // SSATE
        };

        // ADC offset register
        struct ADC_OFR3 : public Register<0x48003168> {
            using OFFSET3 = Field<0, 26>;    // OFFSET3
            using OFFSET3_CH = Field<26, 5>;    // OFFSET3_CH
            using SSATE = Field<31, 1>;    // SSATE
        };

        // ADC offset register
        struct ADC_OFR4 : public Register<0x4800316c> {
            using OFFSET4 = Field<0, 26>;    // OFFSET4
            using OFFSET4_CH = Field<26, 5>;    // OFFSET4_CH
            using SSATE = Field<31, 1>;    // SSATE
        };

        // ADC injected data register
        struct ADC_JDR1 : public RegisterReadOnly<0x48003180> {
            using JDATA = Field<0, 32>;    // JDATA
        };

        // ADC injected data register
        struct ADC_JDR2 : public RegisterReadOnly<0x48003184> {
            using JDATA = Field<0, 32>;    // JDATA
        };

        // ADC injected data register
        struct ADC_JDR3 : public RegisterReadOnly<0x48003188> {
            using JDATA = Field<0, 32>;    // JDATA
        };

        // ADC injected data register
        struct ADC_JDR4 : public RegisterReadOnly<0x4800318c> {
            using JDATA = Field<0, 32>;    // JDATA
        };

        // ADC analog watchdog 2 configuration register
        struct ADC_AWD2CR : public Register<0x480031a0> {
            using AWD2CH = Field<0, 20>;    // AWD2CH
        };

        // ADC analog watchdog 3 configuration register
        struct ADC_AWD3CR : public Register<0x480031a4> {
            using AWD3CH = Field<0, 20>;    // AWD3CH
        };

        // ADC watchdog lower threshold register 2
        struct ADC_LTR2 : public Register<0x480031b0> {
            using LTR2 = Field<0, 26>;    // LTR2
        };

        // ADC watchdog higher threshold register 2
        struct ADC_HTR2 : public Register<0x480031b4> {
            using HTR2 = Field<0, 26>;    // HTR2
        };

        // ADC watchdog lower threshold register 3
        struct ADC_LTR3 : public Register<0x480031b8> {
            using LTR3 = Field<0, 26>;    // LTR3
        };

        // ADC watchdog higher threshold register 3
        struct ADC_HTR3 : public Register<0x480031bc> {
            using HTR3 = Field<0, 26>;    // HTR3
        };

        // ADC differential mode selection register
        struct ADC_DIFSEL : public Register<0x480031c0> {
            using DIFSEL = Field<0, 20>;    // DIFSEL
        };

        // ADC calibration factors register
        struct ADC_CALFACT : public Register<0x480031c4> {
            using CALFACT_S = Field<0, 11>;    // CALFACT_S
            using CALFACT_D = Field<16, 11>;    // CALFACT_D
        };

        // ADC calibration factor register 2
        struct ADC_CALFACT2 : public Register<0x480031c8> {
            using LINCALFACT = Field<0, 30>;    // LINCALFACT
        };

        // ADC2 option register
        struct ADC2_OR : public Register<0x480031d0> {
            using VDDCOREEN = Field<0, 1>;    // VDDCOREEN
        };

    };

    // ADC
    struct ADC {
        // ADC interrupt and status register
        struct ADC_ISR : public Register<0x48003000> {
            using ADRDY = Field<0, 1>;    // ADRDY
            using EOSMP = Field<1, 1>;    // EOSMP
            using EOC = Field<2, 1>;    // EOC
            using EOS = Field<3, 1>;    // EOS
            using OVR = Field<4, 1>;    // OVR
            using JEOC = Field<5, 1>;    // JEOC
            using JEOS = Field<6, 1>;    // JEOS
            using AWD1 = Field<7, 1>;    // AWD1
            using AWD2 = Field<8, 1>;    // AWD2
            using AWD3 = Field<9, 1>;    // AWD3
            using JQOVF = Field<10, 1>;    // JQOVF
        };

        // ADC interrupt enable register
        struct ADC_IER : public Register<0x48003004> {
            using ADRDYIE = Field<0, 1>;    // ADRDYIE
            using EOSMPIE = Field<1, 1>;    // EOSMPIE
            using EOCIE = Field<2, 1>;    // EOCIE
            using EOSIE = Field<3, 1>;    // EOSIE
            using OVRIE = Field<4, 1>;    // OVRIE
            using JEOCIE = Field<5, 1>;    // JEOCIE
            using JEOSIE = Field<6, 1>;    // JEOSIE
            using AWD1IE = Field<7, 1>;    // AWD1IE
            using AWD2IE = Field<8, 1>;    // AWD2IE
            using AWD3IE = Field<9, 1>;    // AWD3IE
            using JQOVFIE = Field<10, 1>;    // JQOVFIE
        };

        // ADC control register
        struct ADC_CR : public Register<0x48003008> {
            using ADEN = Field<0, 1>;    // ADEN
            using ADDIS = Field<1, 1>;    // ADDIS
            using ADSTART = Field<2, 1>;    // ADSTART
            using JADSTART = Field<3, 1>;    // JADSTART
            using ADSTP = Field<4, 1>;    // ADSTP
            using JADSTP = Field<5, 1>;    // JADSTP
            using BOOST = Field<8, 1>;    // BOOST
            using ADCALLIN = Field<16, 1>;    // ADCALLIN
            using LINCALRDYW1 = Field<22, 1>;    // LINCALRDYW1
            using LINCALRDYW2 = Field<23, 1>;    // LINCALRDYW2
            using LINCALRDYW3 = Field<24, 1>;    // LINCALRDYW3
            using LINCALRDYW4 = Field<25, 1>;    // LINCALRDYW4
            using LINCALRDYW5 = Field<26, 1>;    // LINCALRDYW5
            using LINCALRDYW6 = Field<27, 1>;    // LINCALRDYW6
            using ADVREGEN = Field<28, 1>;    // ADVREGEN
            using DEEPPWD = Field<29, 1>;    // DEEPPWD
            using ADCALDIF = Field<30, 1>;    // ADCALDIF
            using ADCAL = Field<31, 1>;    // ADCAL
        };

        // ADC configuration register
        struct ADC_CFGR : public Register<0x4800300c> {
            using DMNGT = Field<0, 2>;    // DMNGT
            using RES = Field<2, 3>;    // RES
            using EXTSEL = Field<5, 5>;    // EXTSEL
            using EXTEN = Field<10, 2>;    // EXTEN
            using OVRMOD = Field<12, 1>;    // OVRMOD
            using CONT = Field<13, 1>;    // CONT
            using AUTDLY = Field<14, 1>;    // AUTDLY
            using DISCEN = Field<16, 1>;    // DISCEN
            using DISCNUM = Field<17, 3>;    // DISCNUM
            using JDISCEN = Field<20, 1>;    // JDISCEN
            using JQM = Field<21, 1>;    // JQM
            using AWD1SGL = Field<22, 1>;    // AWD1SGL
            using AWD1EN = Field<23, 1>;    // AWD1EN
            using JAWD1EN = Field<24, 1>;    // JAWD1EN
            using JAUTO = Field<25, 1>;    // JAUTO
            using AWD1CH = Field<26, 5>;    // AWD1CH
            using JQDIS = Field<31, 1>;    // JQDIS
        };

        // ADC configuration register 2
        struct ADC_CFGR2 : public Register<0x48003010> {
            using ROVSE = Field<0, 1>;    // ROVSE
            using JOVSE = Field<1, 1>;    // JOVSE
            using OVSS = Field<5, 4>;    // OVSS
            using TROVS = Field<9, 1>;    // TROVS
            using ROVSM = Field<10, 1>;    // ROVSM
            using RSHIFT1 = Field<11, 1>;    // RSHIFT1
            using RSHIFT2 = Field<12, 1>;    // RSHIFT2
            using RSHIFT3 = Field<13, 1>;    // RSHIFT3
            using RSHIFT4 = Field<14, 1>;    // RSHIFT4
            using OSVR = Field<16, 10>;    // OSVR
            using LSHIFT = Field<28, 4>;    // LSHIFT
        };

        // ADC sample time register 1
        struct ADC_SMPR1 : public Register<0x48003014> {
            using SMP0 = Field<0, 3>;    // SMP0
            using SMP1 = Field<3, 3>;    // SMP1
            using SMP2 = Field<6, 3>;    // SMP2
            using SMP3 = Field<9, 3>;    // SMP3
            using SMP4 = Field<12, 3>;    // SMP4
            using SMP5 = Field<15, 3>;    // SMP5
            using SMP6 = Field<18, 3>;    // SMP6
            using SMP7 = Field<21, 3>;    // SMP7
            using SMP8 = Field<24, 3>;    // SMP8
            using SMP9 = Field<27, 3>;    // SMP9
        };

        // ADC sample time register 2
        struct ADC_SMPR2 : public Register<0x48003018> {
            using SMP10 = Field<0, 3>;    // SMP10
            using SMP11 = Field<3, 3>;    // SMP11
            using SMP12 = Field<6, 3>;    // SMP12
            using SMP13 = Field<9, 3>;    // SMP13
            using SMP14 = Field<12, 3>;    // SMP14
            using SMP15 = Field<15, 3>;    // SMP15
            using SMP16 = Field<18, 3>;    // SMP16
            using SMP17 = Field<21, 3>;    // SMP17
            using SMP18 = Field<24, 3>;    // SMP18
            using SMP19 = Field<27, 3>;    // SMP19
        };

        // ADC channel preselection register
        struct ADC_PCSEL : public Register<0x4800301c> {
            using PCSEL0 = Field<0, 1>;    // PCSEL0
            using PCSEL1 = Field<1, 1>;    // PCSEL1
            using PCSEL2 = Field<2, 1>;    // PCSEL2
            using PCSEL3 = Field<3, 1>;    // PCSEL3
            using PCSEL4 = Field<4, 1>;    // PCSEL4
            using PCSEL5 = Field<5, 1>;    // PCSEL5
            using PCSEL6 = Field<6, 1>;    // PCSEL6
            using PCSEL7 = Field<7, 1>;    // PCSEL7
            using PCSEL8 = Field<8, 1>;    // PCSEL8
            using PCSEL9 = Field<9, 1>;    // PCSEL9
            using PCSEL10 = Field<10, 1>;    // PCSEL10
            using PCSEL11 = Field<11, 1>;    // PCSEL11
            using PCSEL12 = Field<12, 1>;    // PCSEL12
            using PCSEL13 = Field<13, 1>;    // PCSEL13
            using PCSEL14 = Field<14, 1>;    // PCSEL14
            using PCSEL15 = Field<15, 1>;    // PCSEL15
            using PCSEL16 = Field<16, 1>;    // PCSEL16
            using PCSEL17 = Field<17, 1>;    // PCSEL17
            using PCSEL18 = Field<18, 1>;    // PCSEL18
            using PCSEL19 = Field<19, 1>;    // PCSEL19
        };

        // ADC watchdog threshold register 1
        struct ADC_LTR1 : public Register<0x48003020> {
            using LTR1 = Field<0, 26>;    // LTR1
        };

        // ADC watchdog threshold register 1
        struct ADC_HTR1 : public Register<0x48003024> {
            using HTR1 = Field<0, 26>;    // HTR1
        };

        // ADC regular sequence register 1
        struct ADC_SQR1 : public Register<0x48003030> {
            using L = Field<0, 4>;    // L
            using SQ1 = Field<6, 5>;    // SQ1
            using SQ2 = Field<12, 5>;    // SQ2
            using SQ3 = Field<18, 5>;    // SQ3
            using SQ4 = Field<24, 5>;    // SQ4
        };

        // ADC regular sequence register 2
        struct ADC_SQR2 : public Register<0x48003034> {
            using SQ5 = Field<0, 5>;    // SQ5
            using SQ6 = Field<6, 5>;    // SQ6
            using SQ7 = Field<12, 5>;    // SQ7
            using SQ8 = Field<18, 5>;    // SQ8
            using SQ9 = Field<24, 5>;    // SQ9
        };

        // ADC regular sequence register 3
        struct ADC_SQR3 : public Register<0x48003038> {
            using SQ10 = Field<0, 5>;    // SQ10
            using SQ11 = Field<6, 5>;    // SQ11
            using SQ12 = Field<12, 5>;    // SQ12
            using SQ13 = Field<18, 5>;    // SQ13
            using SQ14 = Field<24, 5>;    // SQ14
        };

        // ADC regular sequence register 4
        struct ADC_SQR4 : public Register<0x4800303c> {
            using SQ15 = Field<0, 5>;    // SQ15
            using SQ16 = Field<6, 5>;    // SQ16
        };

        // ADC regular Data Register
        struct ADC_DR : public RegisterReadOnly<0x48003040> {
            using RDATA = Field<0, 32>;    // RDATA
        };

        // ADC injected sequence register
        struct ADC_JSQR : public Register<0x4800304c> {
            using JL = Field<0, 2>;    // JL
            using JEXTSEL = Field<2, 5>;    // JEXTSEL
            using JEXTEN = Field<7, 2>;    // JEXTEN
            using JSQ1 = Field<9, 5>;    // JSQ1
            using JSQ2 = Field<15, 5>;    // JSQ2
            using JSQ3 = Field<21, 5>;    // JSQ3
            using JSQ4 = Field<27, 5>;    // JSQ4
        };

        // ADC offset register
        struct ADC_OFR1 : public Register<0x48003060> {
            using OFFSET1 = Field<0, 26>;    // OFFSET1
            using OFFSET1_CH = Field<26, 5>;    // OFFSET1_CH
            using SSATE = Field<31, 1>;    // SSATE
        };

        // ADC offset register
        struct ADC_OFR2 : public Register<0x48003064> {
            using OFFSET2 = Field<0, 26>;    // OFFSET2
            using OFFSET2_CH = Field<26, 5>;    // OFFSET2_CH
            using SSATE = Field<31, 1>;    // SSATE
        };

        // ADC offset register
        struct ADC_OFR3 : public Register<0x48003068> {
            using OFFSET3 = Field<0, 26>;    // OFFSET3
            using OFFSET3_CH = Field<26, 5>;    // OFFSET3_CH
            using SSATE = Field<31, 1>;    // SSATE
        };

        // ADC offset register
        struct ADC_OFR4 : public Register<0x4800306c> {
            using OFFSET4 = Field<0, 26>;    // OFFSET4
            using OFFSET4_CH = Field<26, 5>;    // OFFSET4_CH
            using SSATE = Field<31, 1>;    // SSATE
        };

        // ADC injected data register
        struct ADC_JDR1 : public RegisterReadOnly<0x48003080> {
            using JDATA = Field<0, 32>;    // JDATA
        };

        // ADC injected data register
        struct ADC_JDR2 : public RegisterReadOnly<0x48003084> {
            using JDATA = Field<0, 32>;    // JDATA
        };

        // ADC injected data register
        struct ADC_JDR3 : public RegisterReadOnly<0x48003088> {
            using JDATA = Field<0, 32>;    // JDATA
        };

        // ADC injected data register
        struct ADC_JDR4 : public RegisterReadOnly<0x4800308c> {
            using JDATA = Field<0, 32>;    // JDATA
        };

        // ADC analog watchdog 2 configuration register
        struct ADC_AWD2CR : public Register<0x480030a0> {
            using AWD2CH = Field<0, 20>;    // AWD2CH
        };

        // ADC analog watchdog 3 configuration register
        struct ADC_AWD3CR : public Register<0x480030a4> {
            using AWD3CH = Field<0, 20>;    // AWD3CH
        };

        // ADC watchdog lower threshold register 2
        struct ADC_LTR2 : public Register<0x480030b0> {
            using LTR2 = Field<0, 26>;    // LTR2
        };

        // ADC watchdog higher threshold register 2
        struct ADC_HTR2 : public Register<0x480030b4> {
            using HTR2 = Field<0, 26>;    // HTR2
        };

        // ADC watchdog lower threshold register 3
        struct ADC_LTR3 : public Register<0x480030b8> {
            using LTR3 = Field<0, 26>;    // LTR3
        };

        // ADC watchdog higher threshold register 3
        struct ADC_HTR3 : public Register<0x480030bc> {
            using HTR3 = Field<0, 26>;    // HTR3
        };

        // ADC differential mode selection register
        struct ADC_DIFSEL : public Register<0x480030c0> {
            using DIFSEL = Field<0, 20>;    // DIFSEL
        };

        // ADC calibration factors register
        struct ADC_CALFACT : public Register<0x480030c4> {
            using CALFACT_S = Field<0, 11>;    // CALFACT_S
            using CALFACT_D = Field<16, 11>;    // CALFACT_D
        };

        // ADC calibration factor register 2
        struct ADC_CALFACT2 : public Register<0x480030c8> {
            using LINCALFACT = Field<0, 30>;    // LINCALFACT
        };

    };

    // Analog-to-Digital Converter
    struct ADC_common {
        // ADC Common status register
        struct CSR : public RegisterReadOnly<0x48003300> {
            using ADDRDY_MST = Field<0, 1>;    // ADDRDY_MST
            using EOSMP_MST = Field<1, 1>;    // EOSMP_MST
            using EOC_MST = Field<2, 1>;    // EOC_MST
            using EOS_MST = Field<3, 1>;    // EOS_MST
            using OVR_MST = Field<4, 1>;    // OVR_MST
            using JEOC_MST = Field<5, 1>;    // JEOC_MST
            using JEOS_MST = Field<6, 1>;    // JEOS_MST
            using AWD1_MST = Field<7, 1>;    // AWD1_MST
            using AWD2_MST = Field<8, 1>;    // AWD2_MST
            using AWD3_MST = Field<9, 1>;    // AWD3_MST
            using JQOVF_MST = Field<10, 1>;    // JQOVF_MST
            using ADRDY_SLV = Field<16, 1>;    // ADRDY_SLV
            using EOSMP_SLV = Field<17, 1>;    // EOSMP_SLV
            using EOC_SLV = Field<18, 1>;    // EOC_SLV
            using EOS_SLV = Field<19, 1>;    // EOS_SLV
            using OVR_SLV = Field<20, 1>;    // OVR_SLV
            using JEOC_SLV = Field<21, 1>;    // JEOC_SLV
            using JEOS_SLV = Field<22, 1>;    // JEOS_SLV
            using AWD1_SLV = Field<23, 1>;    // AWD1_SLV
            using AWD2_SLV = Field<24, 1>;    // AWD2_SLV
            using AWD3_SLV = Field<25, 1>;    // AWD3_SLV
            using JQOVF_SLV = Field<26, 1>;    // JQOVF_SLV
        };

        // ADC common control register
        struct CCR : public Register<0x48003308> {
            using CKMODE = Field<16, 2>;    // ADC clock mode
            using PRESC = Field<18, 4>;    // ADC prescaler
            using VREFEN = Field<22, 1>;    // VREFINT enable
            using CH17SEL = Field<23, 1>;    // CH17SEL
            using CH18SEL = Field<24, 1>;    // CH18SEL
            using MDMA = Field<14, 2>;    // MDMA
            using DMACFG = Field<13, 1>;    // DMACFG
            using DELAY = Field<8, 3>;    // DELAY
            using DUAL = Field<0, 5>;    // DUAL
        };

        // Common regular data register for dual mode
        struct CDR : public RegisterReadOnly<0x4800330c> {
            using RDATA_MST = Field<0, 16>;    // RDATA_MST
            using RDATA_SLV = Field<16, 16>;    // RDATA_SLV
        };

        // Common regular data register for dual mode
        struct CDR2 : public RegisterReadOnly<0x48003310> {
            using RDATA_ALT = Field<0, 32>;    // RDATA_ALT
        };

    };

    // BSEC2
    struct BSEC {
        // BSEC OTP configuration register
        struct BSEC_OTP_CONFIG : public Register<0x5c005000> {
            using PWRUP = Field<0, 1>;    // PWRUP
            using FRC = Field<1, 2>;    // FRC
            using PRGWIDTH = Field<3, 4>;    // PRGWIDTH
            using TREAD = Field<7, 2>;    // TREAD
        };

        // BSEC OTP control register
        struct BSEC_OTP_CONTROL : public Register<0x5c005004> {
            using ADDR = Field<0, 7>;    // ADDR
            using PROG = Field<8, 1>;    // PROG
            using LOCK = Field<9, 1>;    // LOCK
        };

        // BSEC OTP write data register
        struct BSEC_OTP_WRDATA : public Register<0x5c005008> {
            using WRDATA = Field<0, 32>;    // WRDATA
        };

        // BSEC OTP status register
        struct BSEC_OTP_STATUS : public RegisterReadOnly<0x5c00500c> {
            using SECURE = Field<0, 1>;    // SECURE
            using FULLDBG = Field<1, 1>;    // FULLDBG
            using INVALID = Field<2, 1>;    // INVALID
            using BUSY = Field<3, 1>;    // BUSY
            using PROGFAIL = Field<4, 1>;    // PROGFAIL
            using PWRON = Field<5, 1>;    // PWRON
            using BIST1LOCK = Field<6, 1>;    // BIST1LOCK
            using BIST2LOCK = Field<7, 1>;    // BIST2LOCK
        };

        // BSEC OTP lock configuration register
        struct BSEC_OTP_LOCK : public Register<0x5c005010> {
            using OTP = Field<0, 1>;    // OTP
            using ROMLOCK = Field<1, 1>;    // ROMLOCK
            using DENREG = Field<2, 1>;    // DENREG
            using GPLOCK = Field<4, 1>;    // GPLOCK
        };

        // reset value depends on OTP secure mode according toTable18: BSEC_DENABLE default values after reset on page181.
        struct BSEC_DENABLE : public Register<0x5c005014> {
            using DFTEN = Field<0, 1>;    // DFTEN
            using DBGEN = Field<1, 1>;    // DBGEN
            using NIDEN = Field<2, 1>;    // NIDEN
            using DEVICEEN = Field<3, 1>;    // DEVICEEN
            using HDPEN = Field<4, 1>;    // HDPEN
            using SPIDEN = Field<5, 1>;    // SPIDEN
            using SPNIDEN = Field<6, 1>;    // SPNIDEN
            using CP15SDISABLE = Field<7, 2>;    // CP15SDISABLE
            using CFGSDISABLE = Field<9, 1>;    // CFGSDISABLE
            using DBGSWENABLE = Field<10, 1>;    // DBGSWENABLE
        };

        // BSEC_OTP_DISTURBED0 is used to report disturbed state of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 (lower 1Kbits OTP). BSEC_OTP_DISTURBED1 is used to report disturbed state of BSEC_OTP_DATA32 to BSEC_OTP_DATA63. BSEC_OTP_DISTURBED2 is used to report disturbed state of BSEC_OTP_DATA64 to BSEC_OTP_DATA95.
        struct BSEC_OTP_DISTURBED0 : public RegisterReadOnly<0x5c00501c> {
            using DIS = Field<0, 32>;    // DIS
        };

        // BSEC_OTP_DISTURBED0 is used to report disturbed state of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 (lower 1Kbits OTP). BSEC_OTP_DISTURBED1 is used to report disturbed state of BSEC_OTP_DATA32 to BSEC_OTP_DATA63. BSEC_OTP_DISTURBED2 is used to report disturbed state of BSEC_OTP_DATA64 to BSEC_OTP_DATA95.
        struct BSEC_OTP_DISTURBED1 : public RegisterReadOnly<0x5c005020> {
            using DIS = Field<0, 32>;    // DIS
        };

        // BSEC_OTP_DISTURBED0 is used to report disturbed state of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 (lower 1Kbits OTP). BSEC_OTP_DISTURBED1 is used to report disturbed state of BSEC_OTP_DATA32 to BSEC_OTP_DATA63. BSEC_OTP_DISTURBED2 is used to report disturbed state of BSEC_OTP_DATA64 to BSEC_OTP_DATA95.
        struct BSEC_OTP_DISTURBED2 : public RegisterReadOnly<0x5c005024> {
            using DIS = Field<0, 32>;    // DIS
        };

        // BSEC_OTP_ERROR0 is used to report error state of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 (lower 1Kbits OTP which are protected by 2:1 redundancy). BSEC_OTP_ERROR1 is used to report error state of BSEC_OTP_DATA32 to BSEC_OTP_DATA63 which are protected by 6-bit ECC. BSEC_OTP_ERROR2 is used to report error state of BSEC_OTP_DATA64 to BSEC_OTP_DATA95 which are protected by 6-bit ECC.
        struct BSEC_OTP_ERROR0 : public RegisterReadOnly<0x5c005034> {
            using ERR = Field<0, 32>;    // ERR
        };

        // BSEC_OTP_ERROR0 is used to report error state of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 (lower 1Kbits OTP which are protected by 2:1 redundancy). BSEC_OTP_ERROR1 is used to report error state of BSEC_OTP_DATA32 to BSEC_OTP_DATA63 which are protected by 6-bit ECC. BSEC_OTP_ERROR2 is used to report error state of BSEC_OTP_DATA64 to BSEC_OTP_DATA95 which are protected by 6-bit ECC.
        struct BSEC_OTP_ERROR1 : public RegisterReadOnly<0x5c005038> {
            using ERR = Field<0, 32>;    // ERR
        };

        // BSEC_OTP_ERROR0 is used to report error state of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 (lower 1Kbits OTP which are protected by 2:1 redundancy). BSEC_OTP_ERROR1 is used to report error state of BSEC_OTP_DATA32 to BSEC_OTP_DATA63 which are protected by 6-bit ECC. BSEC_OTP_ERROR2 is used to report error state of BSEC_OTP_DATA64 to BSEC_OTP_DATA95 which are protected by 6-bit ECC.
        struct BSEC_OTP_ERROR2 : public RegisterReadOnly<0x5c00503c> {
            using ERR = Field<0, 32>;    // ERR
        };

        // BSEC_OTP_WLOCK0 is used to report permanent write lock of BSEC_OTP_DATA0 to BSEC_OTP_DATA31. BSEC_OTP_WLOCK1 is used to report permanent write lock of BSEC_OTP_DATA32 to BSEC_OTP_DATA63. BSEC_OTP_WLOCK2 is used to report permanent write lock of BSEC_OTP_DATA64 to BSEC_OTP_DATA95. Permanent write lock requires a programming sequence to lock a word (see section:Section3.3.6: OTP operations on page178).
        struct BSEC_OTP_WRLOCK0 : public RegisterReadOnly<0x5c00504c> {
            using WRLOCK = Field<0, 32>;    // WRLOCK
        };

        // BSEC_OTP_WLOCK0 is used to report permanent write lock of BSEC_OTP_DATA0 to BSEC_OTP_DATA31. BSEC_OTP_WLOCK1 is used to report permanent write lock of BSEC_OTP_DATA32 to BSEC_OTP_DATA63. BSEC_OTP_WLOCK2 is used to report permanent write lock of BSEC_OTP_DATA64 to BSEC_OTP_DATA95. Permanent write lock requires a programming sequence to lock a word (see section:Section3.3.6: OTP operations on page178).
        struct BSEC_OTP_WRLOCK1 : public RegisterReadOnly<0x5c005050> {
            using WRLOCK = Field<0, 32>;    // WRLOCK
        };

        // BSEC_OTP_WLOCK0 is used to report permanent write lock of BSEC_OTP_DATA0 to BSEC_OTP_DATA31. BSEC_OTP_WLOCK1 is used to report permanent write lock of BSEC_OTP_DATA32 to BSEC_OTP_DATA63. BSEC_OTP_WLOCK2 is used to report permanent write lock of BSEC_OTP_DATA64 to BSEC_OTP_DATA95. Permanent write lock requires a programming sequence to lock a word (see section:Section3.3.6: OTP operations on page178).
        struct BSEC_OTP_WRLOCK2 : public RegisterReadOnly<0x5c005054> {
            using WRLOCK = Field<0, 32>;    // WRLOCK
        };

        // BSEC_OTP_SPLOCK0 is used to lock the programming of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 until next system-reset BSEC_OTP_SPLOCK1 is used to lock the programming of BSEC_OTP_DATA32 to BSEC_OTP_DATA63 until next system-reset BSEC_OTP_SPLOCK2 is used to lock the programming of BSEC_OTP_DATA64 to BSEC_OTP_DATA95 until next system-reset Attempt to sticky program locked OTP word are silently ignored.
        struct BSEC_OTP_SPLOCK0 : public Register<0x5c005064> {
            using SPLOCK = Field<0, 32>;    // SPLOCK
        };

        // BSEC_OTP_SPLOCK0 is used to lock the programming of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 until next system-reset BSEC_OTP_SPLOCK1 is used to lock the programming of BSEC_OTP_DATA32 to BSEC_OTP_DATA63 until next system-reset BSEC_OTP_SPLOCK2 is used to lock the programming of BSEC_OTP_DATA64 to BSEC_OTP_DATA95 until next system-reset Attempt to sticky program locked OTP word are silently ignored.
        struct BSEC_OTP_SPLOCK1 : public Register<0x5c005068> {
            using SPLOCK = Field<0, 32>;    // SPLOCK
        };

        // BSEC_OTP_SPLOCK0 is used to lock the programming of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 until next system-reset BSEC_OTP_SPLOCK1 is used to lock the programming of BSEC_OTP_DATA32 to BSEC_OTP_DATA63 until next system-reset BSEC_OTP_SPLOCK2 is used to lock the programming of BSEC_OTP_DATA64 to BSEC_OTP_DATA95 until next system-reset Attempt to sticky program locked OTP word are silently ignored.
        struct BSEC_OTP_SPLOCK2 : public Register<0x5c00506c> {
            using SPLOCK = Field<0, 32>;    // SPLOCK
        };

        // BSEC_OTP_SWLOCK0 is used to prevent writing to BSEC_OTP_DATA0 to BSEC_OTP_DATA31 until next system-reset. BSEC_OTP_SWLOCK1 is used to prevent writing to BSEC_OTP_DATA32 to BSEC_OTP_DATA63 until next system-reset. BSEC_OTP_SWLOCK2 is used to prevent writing to BSEC_OTP_DATA64 to BSEC_OTP_DATA95 until next system-reset. Write to shadow write locked BSEC_OTP_DATA word are silently ignored. Writing to OTP word 0 shadow is always prevented.
        struct BSEC_OTP_SWLOCK0 : public Register<0x5c00507c> {
            using SWLOCK = Field<0, 32>;    // SWLOCK
        };

        // BSEC_OTP_SWLOCK0 is used to prevent writing to BSEC_OTP_DATA0 to BSEC_OTP_DATA31 until next system-reset. BSEC_OTP_SWLOCK1 is used to prevent writing to BSEC_OTP_DATA32 to BSEC_OTP_DATA63 until next system-reset. BSEC_OTP_SWLOCK2 is used to prevent writing to BSEC_OTP_DATA64 to BSEC_OTP_DATA95 until next system-reset. Write to shadow write locked BSEC_OTP_DATA word are silently ignored. Writing to OTP word 0 shadow is always prevented.
        struct BSEC_OTP_SWLOCK1 : public Register<0x5c005080> {
            using SWLOCK = Field<0, 32>;    // SWLOCK
        };

        // BSEC_OTP_SWLOCK0 is used to prevent writing to BSEC_OTP_DATA0 to BSEC_OTP_DATA31 until next system-reset. BSEC_OTP_SWLOCK1 is used to prevent writing to BSEC_OTP_DATA32 to BSEC_OTP_DATA63 until next system-reset. BSEC_OTP_SWLOCK2 is used to prevent writing to BSEC_OTP_DATA64 to BSEC_OTP_DATA95 until next system-reset. Write to shadow write locked BSEC_OTP_DATA word are silently ignored. Writing to OTP word 0 shadow is always prevented.
        struct BSEC_OTP_SWLOCK2 : public Register<0x5c005084> {
            using SWLOCK = Field<0, 32>;    // SWLOCK
        };

        // BSEC_OTP_SRLOCK0 is used to prevent reloading of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 until next system-reset. BSEC_OTP_SRLOCK1 is used to prevent reloading of BSEC_OTP_DATA32 to BSEC_OTP_DATA63 until next system-reset. BSEC_OTP_SRLOCK2 is used to prevent reloading of BSEC_OTP_DATA64 to BSEC_OTP_DATA95 until next system-reset. Setting SRLOCK bits or attempt to reload a locked OTP do not clear the corresponding BSEC_OTP_DATAx shadow register. BSEC_OTP_SRLOCK0 bit 0 is controlled by hardware according to fuse_ok, writing to this bit has no effect.
        struct BSEC_OTP_SRLOCK0 : public Register<0x5c005094> {
            using SRLOCK = Field<0, 32>;    // SRLOCK
        };

        // BSEC_OTP_SRLOCK0 is used to prevent reloading of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 until next system-reset. BSEC_OTP_SRLOCK1 is used to prevent reloading of BSEC_OTP_DATA32 to BSEC_OTP_DATA63 until next system-reset. BSEC_OTP_SRLOCK2 is used to prevent reloading of BSEC_OTP_DATA64 to BSEC_OTP_DATA95 until next system-reset. Setting SRLOCK bits or attempt to reload a locked OTP do not clear the corresponding BSEC_OTP_DATAx shadow register. BSEC_OTP_SRLOCK0 bit 0 is controlled by hardware according to fuse_ok, writing to this bit has no effect.
        struct BSEC_OTP_SRLOCK1 : public Register<0x5c005098> {
            using SRLOCK = Field<0, 32>;    // SRLOCK
        };

        // BSEC_OTP_SRLOCK0 is used to prevent reloading of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 until next system-reset. BSEC_OTP_SRLOCK1 is used to prevent reloading of BSEC_OTP_DATA32 to BSEC_OTP_DATA63 until next system-reset. BSEC_OTP_SRLOCK2 is used to prevent reloading of BSEC_OTP_DATA64 to BSEC_OTP_DATA95 until next system-reset. Setting SRLOCK bits or attempt to reload a locked OTP do not clear the corresponding BSEC_OTP_DATAx shadow register. BSEC_OTP_SRLOCK0 bit 0 is controlled by hardware according to fuse_ok, writing to this bit has no effect.
        struct BSEC_OTP_SRLOCK2 : public Register<0x5c00509c> {
            using SRLOCK = Field<0, 32>;    // SRLOCK
        };

        // BSEC JTAG input register
        struct BSEC_JTAGIN : public RegisterReadOnly<0x5c0050ac> {
            using DATA = Field<0, 16>;    // DATA
        };

        // BSEC JTAG output register
        struct BSEC_JTAGOUT : public Register<0x5c0050b0> {
            using DATA = Field<0, 16>;    // DATA
        };

        // BSEC scratch register
        struct BSEC_SCRATCH : public Register<0x5c0050b4> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA0 : public Register<0x5c005200> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA1 : public Register<0x5c005204> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA2 : public Register<0x5c005208> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA3 : public Register<0x5c00520c> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA4 : public Register<0x5c005210> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA5 : public Register<0x5c005214> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA6 : public Register<0x5c005218> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA7 : public Register<0x5c00521c> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA8 : public Register<0x5c005220> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA9 : public Register<0x5c005224> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA10 : public Register<0x5c005228> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA11 : public Register<0x5c00522c> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA12 : public Register<0x5c005230> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA13 : public Register<0x5c005234> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA14 : public Register<0x5c005238> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA15 : public Register<0x5c00523c> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA16 : public Register<0x5c005240> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA17 : public Register<0x5c005244> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA18 : public Register<0x5c005248> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA19 : public Register<0x5c00524c> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA20 : public Register<0x5c005250> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA21 : public Register<0x5c005254> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA22 : public Register<0x5c005258> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA23 : public Register<0x5c00525c> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA24 : public Register<0x5c005260> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA25 : public Register<0x5c005264> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA26 : public Register<0x5c005268> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA27 : public Register<0x5c00526c> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA28 : public Register<0x5c005270> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA29 : public Register<0x5c005274> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA30 : public Register<0x5c005278> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA31 : public Register<0x5c00527c> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA32 : public Register<0x5c005280> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA33 : public Register<0x5c005284> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA34 : public Register<0x5c005288> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA35 : public Register<0x5c00528c> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA36 : public Register<0x5c005290> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA37 : public Register<0x5c005294> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA38 : public Register<0x5c005298> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA39 : public Register<0x5c00529c> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA40 : public Register<0x5c0052a0> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA41 : public Register<0x5c0052a4> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA42 : public Register<0x5c0052a8> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA43 : public Register<0x5c0052ac> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA44 : public Register<0x5c0052b0> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA45 : public Register<0x5c0052b4> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA46 : public Register<0x5c0052b8> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA47 : public Register<0x5c0052bc> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA48 : public Register<0x5c0052c0> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA49 : public Register<0x5c0052c4> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA50 : public Register<0x5c0052c8> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA51 : public Register<0x5c0052cc> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA52 : public Register<0x5c0052d0> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA53 : public Register<0x5c0052d4> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA54 : public Register<0x5c0052d8> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA55 : public Register<0x5c0052dc> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA56 : public Register<0x5c0052e0> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA57 : public Register<0x5c0052e4> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA58 : public Register<0x5c0052e8> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA59 : public Register<0x5c0052ec> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA60 : public Register<0x5c0052f0> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA61 : public Register<0x5c0052f4> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA62 : public Register<0x5c0052f8> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA63 : public Register<0x5c0052fc> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA64 : public Register<0x5c005300> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA65 : public Register<0x5c005304> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA66 : public Register<0x5c005308> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA67 : public Register<0x5c00530c> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA68 : public Register<0x5c005310> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA69 : public Register<0x5c005314> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA70 : public Register<0x5c005318> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA71 : public Register<0x5c00531c> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA72 : public Register<0x5c005320> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA73 : public Register<0x5c005324> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA74 : public Register<0x5c005328> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA75 : public Register<0x5c00532c> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA76 : public Register<0x5c005330> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA77 : public Register<0x5c005334> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA78 : public Register<0x5c005338> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA79 : public Register<0x5c00533c> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA80 : public Register<0x5c005340> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA81 : public Register<0x5c005344> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA82 : public Register<0x5c005348> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA83 : public Register<0x5c00534c> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA84 : public Register<0x5c005350> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA85 : public Register<0x5c005354> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA86 : public Register<0x5c005358> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA87 : public Register<0x5c00535c> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA88 : public Register<0x5c005360> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA89 : public Register<0x5c005364> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA90 : public Register<0x5c005368> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA91 : public Register<0x5c00536c> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA92 : public Register<0x5c005370> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA93 : public Register<0x5c005374> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA94 : public Register<0x5c005378> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
        struct BSEC_OTP_DATA95 : public Register<0x5c00537c> {
            using DATA = Field<0, 32>;    // DATA
        };

        // BSEC hardware configuration register
        struct BSEC_HWCFGR : public RegisterReadOnly<0x5c005ff0> {
            using SIZE = Field<0, 4>;    // SIZE
            using ECC_USE = Field<4, 4>;    // ECC_USE
        };

        // BSEC version register
        struct BSEC_VERR : public RegisterReadOnly<0x5c005ff4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // BSEC identification register
        struct BSEC_IPIDR : public RegisterReadOnly<0x5c005ff8> {
            using ID = Field<0, 32>;    // ID
        };

        // BSEC size identification register
        struct BSEC_SIDR : public RegisterReadOnly<0x5c005ffc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // DCMI
    struct DCMI {
        // DCMI control register
        struct DCMI_CR : public Register<0x4c006000> {
            using CAPTURE = Field<0, 1>;    // CAPTURE
            using CM = Field<1, 1>;    // CM
            using CROP = Field<2, 1>;    // CROP
            using JPEG = Field<3, 1>;    // JPEG
            using ESS = Field<4, 1>;    // ESS
            using PCKPOL = Field<5, 1>;    // PCKPOL
            using HSPOL = Field<6, 1>;    // HSPOL
            using VSPOL = Field<7, 1>;    // VSPOL
            using FCRC = Field<8, 2>;    // FCRC
            using EDM = Field<10, 2>;    // EDM
            using ENABLE = Field<14, 1>;    // ENABLE
            using BSM = Field<16, 2>;    // BSM
            using OEBS = Field<18, 1>;    // OEBS
            using LSM = Field<19, 1>;    // LSM
            using OELS = Field<20, 1>;    // OELS
        };

        // DCMI status register
        struct DCMI_SR : public RegisterReadOnly<0x4c006004> {
            using HSYNC = Field<0, 1>;    // HSYNC
            using VSYNC = Field<1, 1>;    // VSYNC
            using FNE = Field<2, 1>;    // FNE
        };

        // DCMI_RIS gives the raw interrupt status and is accessible in read only. When read, this register returns the status of the corresponding interrupt before masking with the DCMI_IER register value.
        struct DCMI_RIS : public RegisterReadOnly<0x4c006008> {
            using FRAME_RIS = Field<0, 1>;    // FRAME_RIS
            using OVR_RIS = Field<1, 1>;    // OVR_RIS
            using ERR_RIS = Field<2, 1>;    // ERR_RIS
            using VSYNC_RIS = Field<3, 1>;    // VSYNC_RIS
            using LINE_RIS = Field<4, 1>;    // LINE_RIS
        };

        // The DCMI_IER register is used to enable interrupts. When one of the DCMI_IER bits is set, the corresponding interrupt is enabled. This register is accessible in both read and write.
        struct DCMI_IER : public Register<0x4c00600c> {
            using FRAME_IE = Field<0, 1>;    // FRAME_IE
            using OVR_IE = Field<1, 1>;    // OVR_IE
            using ERR_IE = Field<2, 1>;    // ERR_IE
            using VSYNC_IE = Field<3, 1>;    // VSYNC_IE
            using LINE_IE = Field<4, 1>;    // LINE_IE
        };

        // This DCMI_MIS register is a read-only register. When read, it returns the current masked status value (depending on the value in DCMI_IER) of the corresponding interrupt. A bit in this register is set if the corresponding enable bit in DCMI_IER is set and the corresponding bit in DCMI_RIS is set.
        struct DCMI_MIS : public RegisterReadOnly<0x4c006010> {
            using FRAME_MIS = Field<0, 1>;    // FRAME_MIS
            using OVR_MIS = Field<1, 1>;    // OVR_MIS
            using ERR_MIS = Field<2, 1>;    // ERR_MIS
            using VSYNC_MIS = Field<3, 1>;    // VSYNC_MIS
            using LINE_MIS = Field<4, 1>;    // LINE_MIS
        };

        // The DCMI_ICR register is write-only.
        struct DCMI_ICR : public RegisterWriteOnly<0x4c006014> {
            using FRAME_ISC = Field<0, 1>;    // FRAME_ISC
            using OVR_ISC = Field<1, 1>;    // OVR_ISC
            using ERR_ISC = Field<2, 1>;    // ERR_ISC
            using VSYNC_ISC = Field<3, 1>;    // VSYNC_ISC
            using LINE_ISC = Field<4, 1>;    // LINE_ISC
        };

        // DCMI embedded synchronization code register
        struct DCMI_ESCR : public Register<0x4c006018> {
            using FSC = Field<0, 8>;    // FSC
            using LSC = Field<8, 8>;    // LSC
            using LEC = Field<16, 8>;    // LEC
            using FEC = Field<24, 8>;    // FEC
        };

        // DCMI embedded synchronization unmask register
        struct DCMI_ESUR : public Register<0x4c00601c> {
            using FSU = Field<0, 8>;    // FSU
            using LSU = Field<8, 8>;    // LSU
            using LEU = Field<16, 8>;    // LEU
            using FEU = Field<24, 8>;    // FEU
        };

        // DCMI crop window start
        struct DCMI_CWSTRT : public Register<0x4c006020> {
            using HOFFCNT = Field<0, 14>;    // HOFFCNT
            using VST = Field<16, 13>;    // VST
        };

        // DCMI crop window size
        struct DCMI_CWSIZE : public Register<0x4c006024> {
            using CAPCNT = Field<0, 14>;    // CAPCNT
            using VLINE = Field<16, 14>;    // VLINE
        };

        // DCMI data register
        struct DCMI_DR : public RegisterReadOnly<0x4c006028> {
            using Byte0 = Field<0, 8>;    // Byte0
            using Byte1 = Field<8, 8>;    // Byte1
            using Byte2 = Field<16, 8>;    // Byte2
            using Byte3 = Field<24, 8>;    // Byte3
        };

    };

    // CRYP1
    struct CRYP1 {
        // CRYP control register
        struct CRYP_CR : public Register<0x54001000> {
            using ALGODIR = Field<2, 1>;    // ALGODIR
            using ALGOMODE = Field<3, 3>;    // ALGOMODE
            using DATATYPE = Field<6, 2>;    // DATATYPE
            using KEYSIZE = Field<8, 2>;    // KEYSIZE
            using FFLUSH = Field<14, 1>;    // FFLUSH
            using CRYPEN = Field<15, 1>;    // CRYPEN
            using GCM_CCMPH = Field<16, 2>;    // GCM_CCMPH
            using ALGOMODE3 = Field<19, 1>;    // ALGOMODE3
            using NPBLB = Field<20, 4>;    // NPBLB
        };

        // CRYP status register
        struct CRYP_SR : public RegisterReadOnly<0x54001004> {
            using IFEM = Field<0, 1>;    // IFEM
            using IFNF = Field<1, 1>;    // IFNF
            using OFNE = Field<2, 1>;    // OFNE
            using OFFU = Field<3, 1>;    // OFFU
            using BUSY = Field<4, 1>;    // BUSY
        };

        // The CRYP_DIN register is the data input register. It is 32-bit wide. It is used to enter into the input FIFO up to four 64-bit blocks (TDES) or two 128-bit blocks (AES) of plaintext (when encrypting) or ciphertext (when decrypting), one 32-bit word at a time. To fit different data sizes, the data can be swapped after processing by configuring the DATATYPE bits in the CRYP_CR register. Refer to Section39.3.16: CRYP data registers and data swapping for more details. When CRYP_DIN register is written to the data are pushed into the input FIFO. If CRYPEN = 1, when at least two 32-bit words in the DES/TDES mode have been pushed into the input FIFO (four words in the AES mode), and when at least two words are free in the output FIFO (four words in the AES mode), the CRYP engine starts an encrypting or decrypting process. When CRYP_DIN register is read: If CRYPEN = 0, the FIFO is popped, and then the data present in the Input FIFO are returned, from the oldest one (first reading) to the newest one (last reading). The IFEM flag must be checked before each read operation to make sure that the FIFO is not empty. if CRYPEN = 1, an undefined value is returned. After the CRYP_DIN register has been read once or several times, the FIFO must be flushed by setting the FFLUSH bit prior to processing new data.
        struct CRYP_DIN : public Register<0x54001008> {
            using DATAIN = Field<0, 32>;    // DATAIN
        };

        // The CRYP_DOUT register is the data output register. It is read-only and 32-bit wide. It is used to retrieve from the output FIFO up to four 64-bit blocks (TDES) or two 128-bit blocks (AES) of plaintext (when encrypting) or ciphertext (when decrypting), one 32-bit word at a time. To fit different data sizes, the data can be swapped after processing by configuring the DATATYPE bits in the CRYP_CR register. Refer to Section39.3.16: CRYP data registers and data swapping for more details. When CRYP_DOUT register is read, the last data entered into the output FIFO (pointed to by the read pointer) is returned.
        struct CRYP_DOUT : public RegisterReadOnly<0x5400100c> {
            using DATAOUT = Field<0, 32>;    // DATAOUT
        };

        // CRYP DMA control register
        struct CRYP_DMACR : public Register<0x54001010> {
            using DIEN = Field<0, 1>;    // DIEN
            using DOEN = Field<1, 1>;    // DOEN
        };

        // The CRYP_IMSCR register is the interrupt mask set or clear register. It is a read/write register. When a read operation is performed, this register gives the current value of the mask applied to the relevant interrupt. Writing 1 to the particular bit sets the mask, thus enabling the interrupt to be read. Writing 0 to this bit clears the corresponding mask. All the bits are cleared to 0 when the peripheral is reset.
        struct CRYP_IMSCR : public Register<0x54001014> {
            using INIM = Field<0, 1>;    // INIM
            using OUTIM = Field<1, 1>;    // OUTIM
        };

        // The CRYP_RISR register is the raw interrupt status register. It is a read-only register. When a read operation is performed, this register gives the current raw status of the corresponding interrupt, i.e. the interrupt information without taking CRYP_IMSCR mask into account. Write operations have no effect.
        struct CRYP_RISR : public RegisterReadOnly<0x54001018> {
            using INRIS = Field<0, 1>;    // INRIS
            using OUTRIS = Field<1, 1>;    // OUTRIS
        };

        // The CRYP_MISR register is the masked interrupt status register. It is a read-only register. When a read operation is performed, this register gives the current masked status of the corresponding interrupt, i.e. the interrupt information taking CRYP_IMSCR mask into account. Write operations have no effect.
        struct CRYP_MISR : public RegisterReadOnly<0x5400101c> {
            using INMIS = Field<0, 1>;    // INMIS
            using OUTMIS = Field<1, 1>;    // OUTMIS
        };

        // CRYP key registers contain the cryptographic keys. In DES/TDES mode, the keys are 64-bit binary values (number from left to right, that is the leftmost bit is bit 1) and named K1, K2 and K3 (K0 is not used). Each key consists of 56 information bits and 8 parity bits. In AES mode, the key is considered as a single 128, 192 or 256 bits long sequence K0K1K2...K127/191/255. The AES key is entered into the registers as follows: for AES-128: K0..K127 corresponds to b127..b0 (b255..b128 are not used), for AES-192: K0..K191 corresponds to b191..b0 (b255..b192 are not used), for AES-256: K0..K255 corresponds to b255..b0. In all cases key bit K0 is the leftmost bit in CRYP inner memory and register bit b0 is the rightmost bit in corresponding CRYP_KxLR key register. For more information refer to Section39.3.17: CRYP key registers. Write accesses to these registers are disregarded when the cryptographic processor is busy (bit BUSY = 1 in the CRYP_SR register)
        struct CRYP_K0LR : public RegisterWriteOnly<0x54001020> {
            using K = Field<0, 32>;    // K
        };

        // Refer to Section39.6.9: CRYP key register 0L (CRYP_K0LR) for details.
        struct CRYP_K0RR : public RegisterWriteOnly<0x54001024> {
            using K = Field<0, 32>;    // K
        };

        // Refer to Section39.6.9: CRYP key register 0L (CRYP_K0LR) for details.
        struct CRYP_K1LR : public RegisterWriteOnly<0x54001028> {
            using K = Field<0, 32>;    // K
        };

        // Refer to Section39.6.9: CRYP key register 0L (CRYP_K0LR) for details.
        struct CRYP_K1RR : public RegisterWriteOnly<0x5400102c> {
            using K = Field<0, 32>;    // K
        };

        // Refer to Section39.6.9: CRYP key register 0L (CRYP_K0LR) for details.
        struct CRYP_K2LR : public RegisterWriteOnly<0x54001030> {
            using K = Field<0, 32>;    // K
        };

        // Refer to Section39.6.9: CRYP key register 0L (CRYP_K0LR) for details.
        struct CRYP_K2RR : public RegisterWriteOnly<0x54001034> {
            using K = Field<0, 32>;    // K
        };

        // Refer to Section39.6.9: CRYP key register 0L (CRYP_K0LR) for details.
        struct CRYP_K3LR : public RegisterWriteOnly<0x54001038> {
            using K = Field<0, 32>;    // K
        };

        // Refer to Section39.6.9: CRYP key register 0L (CRYP_K0LR) for details.
        struct CRYP_K3RR : public RegisterWriteOnly<0x5400103c> {
            using K = Field<0, 32>;    // K
        };

        // The CRYP_IV0...1(L/R)R are the left-word and right-word registers for the initialization vector (64 bits for DES/TDES and 128 bits for AES). For more information refer to Section39.3.18: CRYP initialization vector registers. IV0 is the leftmost bit whereas IV63 (DES, TDES) or IV127 (AES) are the rightmost bits of the initialization vector. IV1(L/R)R is used only in the AES. Only CRYP_IV0(L/R) is used in DES/TDES. Write access to these registers are disregarded when the cryptographic processor is busy (bit BUSY = 1 in the CRYP_SR register).
        struct CRYP_IV0LR : public Register<0x54001040> {
            using IV31 = Field<0, 1>;    // IV31
            using IV30 = Field<1, 1>;    // IV30
            using IV29 = Field<2, 1>;    // IV29
            using IV28 = Field<3, 1>;    // IV28
            using IV27 = Field<4, 1>;    // IV27
            using IV26 = Field<5, 1>;    // IV26
            using IV25 = Field<6, 1>;    // IV25
            using IV24 = Field<7, 1>;    // IV24
            using IV23 = Field<8, 1>;    // IV23
            using IV22 = Field<9, 1>;    // IV22
            using IV21 = Field<10, 1>;    // IV21
            using IV20 = Field<11, 1>;    // IV20
            using IV19 = Field<12, 1>;    // IV19
            using IV18 = Field<13, 1>;    // IV18
            using IV17 = Field<14, 1>;    // IV17
            using IV16 = Field<15, 1>;    // IV16
            using IV15 = Field<16, 1>;    // IV15
            using IV14 = Field<17, 1>;    // IV14
            using IV13 = Field<18, 1>;    // IV13
            using IV12 = Field<19, 1>;    // IV12
            using IV11 = Field<20, 1>;    // IV11
            using IV10 = Field<21, 1>;    // IV10
            using IV9 = Field<22, 1>;    // IV9
            using IV8 = Field<23, 1>;    // IV8
            using IV7 = Field<24, 1>;    // IV7
            using IV6 = Field<25, 1>;    // IV6
            using IV5 = Field<26, 1>;    // IV5
            using IV4 = Field<27, 1>;    // IV4
            using IV3 = Field<28, 1>;    // IV3
            using IV2 = Field<29, 1>;    // IV2
            using IV1 = Field<30, 1>;    // IV1
            using IV0 = Field<31, 1>;    // IV0
        };

        // Refer to Section39.6.17: CRYP initialization vector register 0L (CRYP_IV0LR) for details.
        struct CRYP_IV0RR : public Register<0x54001044> {
            using IV63 = Field<0, 1>;    // IV63
            using IV62 = Field<1, 1>;    // IV62
            using IV61 = Field<2, 1>;    // IV61
            using IV60 = Field<3, 1>;    // IV60
            using IV59 = Field<4, 1>;    // IV59
            using IV58 = Field<5, 1>;    // IV58
            using IV57 = Field<6, 1>;    // IV57
            using IV56 = Field<7, 1>;    // IV56
            using IV55 = Field<8, 1>;    // IV55
            using IV54 = Field<9, 1>;    // IV54
            using IV53 = Field<10, 1>;    // IV53
            using IV52 = Field<11, 1>;    // IV52
            using IV51 = Field<12, 1>;    // IV51
            using IV50 = Field<13, 1>;    // IV50
            using IV49 = Field<14, 1>;    // IV49
            using IV48 = Field<15, 1>;    // IV48
            using IV47 = Field<16, 1>;    // IV47
            using IV46 = Field<17, 1>;    // IV46
            using IV45 = Field<18, 1>;    // IV45
            using IV44 = Field<19, 1>;    // IV44
            using IV43 = Field<20, 1>;    // IV43
            using IV42 = Field<21, 1>;    // IV42
            using IV41 = Field<22, 1>;    // IV41
            using IV40 = Field<23, 1>;    // IV40
            using IV39 = Field<24, 1>;    // IV39
            using IV38 = Field<25, 1>;    // IV38
            using IV37 = Field<26, 1>;    // IV37
            using IV36 = Field<27, 1>;    // IV36
            using IV35 = Field<28, 1>;    // IV35
            using IV34 = Field<29, 1>;    // IV34
            using IV33 = Field<30, 1>;    // IV33
            using IV32 = Field<31, 1>;    // IV32
        };

        // Refer to Section39.6.17: CRYP initialization vector register 0L (CRYP_IV0LR) for details.
        struct CRYP_IV1LR : public Register<0x54001048> {
            using IV95 = Field<0, 1>;    // IV95
            using IV94 = Field<1, 1>;    // IV94
            using IV93 = Field<2, 1>;    // IV93
            using IV92 = Field<3, 1>;    // IV92
            using IV91 = Field<4, 1>;    // IV91
            using IV90 = Field<5, 1>;    // IV90
            using IV89 = Field<6, 1>;    // IV89
            using IV88 = Field<7, 1>;    // IV88
            using IV87 = Field<8, 1>;    // IV87
            using IV86 = Field<9, 1>;    // IV86
            using IV85 = Field<10, 1>;    // IV85
            using IV84 = Field<11, 1>;    // IV84
            using IV83 = Field<12, 1>;    // IV83
            using IV82 = Field<13, 1>;    // IV82
            using IV81 = Field<14, 1>;    // IV81
            using IV80 = Field<15, 1>;    // IV80
            using IV79 = Field<16, 1>;    // IV79
            using IV78 = Field<17, 1>;    // IV78
            using IV77 = Field<18, 1>;    // IV77
            using IV76 = Field<19, 1>;    // IV76
            using IV75 = Field<20, 1>;    // IV75
            using IV74 = Field<21, 1>;    // IV74
            using IV73 = Field<22, 1>;    // IV73
            using IV72 = Field<23, 1>;    // IV72
            using IV71 = Field<24, 1>;    // IV71
            using IV70 = Field<25, 1>;    // IV70
            using IV69 = Field<26, 1>;    // IV69
            using IV68 = Field<27, 1>;    // IV68
            using IV67 = Field<28, 1>;    // IV67
            using IV66 = Field<29, 1>;    // IV66
            using IV65 = Field<30, 1>;    // IV65
            using IV64 = Field<31, 1>;    // IV64
        };

        // Refer to Section39.6.17: CRYP initialization vector register 0L (CRYP_IV0LR) for details.
        struct CRYP_IV1RR : public Register<0x5400104c> {
            using IV127 = Field<0, 1>;    // IV127
            using IV126 = Field<1, 1>;    // IV126
            using IV125 = Field<2, 1>;    // IV125
            using IV124 = Field<3, 1>;    // IV124
            using IV123 = Field<4, 1>;    // IV123
            using IV122 = Field<5, 1>;    // IV122
            using IV121 = Field<6, 1>;    // IV121
            using IV120 = Field<7, 1>;    // IV120
            using IV119 = Field<8, 1>;    // IV119
            using IV118 = Field<9, 1>;    // IV118
            using IV117 = Field<10, 1>;    // IV117
            using IV116 = Field<11, 1>;    // IV116
            using IV115 = Field<12, 1>;    // IV115
            using IV114 = Field<13, 1>;    // IV114
            using IV113 = Field<14, 1>;    // IV113
            using IV112 = Field<15, 1>;    // IV112
            using IV111 = Field<16, 1>;    // IV111
            using IV110 = Field<17, 1>;    // IV110
            using IV109 = Field<18, 1>;    // IV109
            using IV108 = Field<19, 1>;    // IV108
            using IV107 = Field<20, 1>;    // IV107
            using IV106 = Field<21, 1>;    // IV106
            using IV105 = Field<22, 1>;    // IV105
            using IV104 = Field<23, 1>;    // IV104
            using IV103 = Field<24, 1>;    // IV103
            using IV102 = Field<25, 1>;    // IV102
            using IV101 = Field<26, 1>;    // IV101
            using IV100 = Field<27, 1>;    // IV100
            using IV99 = Field<28, 1>;    // IV99
            using IV98 = Field<29, 1>;    // IV98
            using IV97 = Field<30, 1>;    // IV97
            using IV96 = Field<31, 1>;    // IV96
        };

        // These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
        struct CRYP_CSGCMCCM0R : public Register<0x54001050> {
            using CSGCMCCM0 = Field<0, 32>;    // CSGCMCCM0
        };

        // These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
        struct CRYP_CSGCMCCM1R : public Register<0x54001054> {
            using CSGCMCCM1 = Field<0, 32>;    // CSGCMCCM1
        };

        // These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
        struct CRYP_CSGCMCCM2R : public Register<0x54001058> {
            using CSGCMCCM2 = Field<0, 32>;    // CSGCMCCM2
        };

        // These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
        struct CRYP_CSGCMCCM3R : public Register<0x5400105c> {
            using CSGCMCCM3 = Field<0, 32>;    // CSGCMCCM3
        };

        // These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
        struct CRYP_CSGCMCCM4R : public Register<0x54001060> {
            using CSGCMCCM4 = Field<0, 32>;    // CSGCMCCM4
        };

        // These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
        struct CRYP_CSGCMCCM5R : public Register<0x54001064> {
            using CSGCMCCM5 = Field<0, 32>;    // CSGCMCCM5
        };

        // These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
        struct CRYP_CSGCMCCM6R : public Register<0x54001068> {
            using CSGCMCCM6 = Field<0, 32>;    // CSGCMCCM6
        };

        // These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
        struct CRYP_CSGCMCCM7R : public Register<0x5400106c> {
            using CSGCMCCM7 = Field<0, 32>;    // CSGCMCCM7
        };

        // Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
        struct CRYP_CSGCM0R : public Register<0x54001070> {
            using CSGCM0 = Field<0, 32>;    // CSGCM0
        };

        // Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
        struct CRYP_CSGCM1R : public Register<0x54001074> {
            using CSGCM1 = Field<0, 32>;    // CSGCM1
        };

        // Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
        struct CRYP_CSGCM2R : public Register<0x54001078> {
            using CSGCM2 = Field<0, 32>;    // CSGCM2
        };

        // Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
        struct CRYP_CSGCM3R : public Register<0x5400107c> {
            using CSGCM3 = Field<0, 32>;    // CSGCM3
        };

        // Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
        struct CRYP_CSGCM4R : public Register<0x54001080> {
            using CSGCM4 = Field<0, 32>;    // CSGCM4
        };

        // Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
        struct CRYP_CSGCM5R : public Register<0x54001084> {
            using CSGCM5 = Field<0, 32>;    // CSGCM5
        };

        // Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
        struct CRYP_CSGCM6R : public Register<0x54001088> {
            using CSGCM6 = Field<0, 32>;    // CSGCM6
        };

        // Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
        struct CRYP_CSGCM7R : public Register<0x5400108c> {
            using CSGCM7 = Field<0, 32>;    // CSGCM7
        };

        // CRYP hardware configuration register
        struct CRYP_HWCFGR : public RegisterReadOnly<0x540013f0> {
            using CFG1 = Field<0, 4>;    // CFG1
            using CFG2 = Field<4, 4>;    // CFG2
            using CFG3 = Field<8, 4>;    // CFG3
            using CFG4 = Field<12, 4>;    // CFG4
        };

        // CRYP HW Version Register
        struct CRYP_VERR : public RegisterReadOnly<0x540013f4> {
            using VER = Field<0, 8>;    // VER
        };

        // CRYP Identification
        struct CRYP_IPIDR : public RegisterReadOnly<0x540013f8> {
            using ID = Field<0, 32>;    // ID
        };

        // CRYP HW Magic ID
        struct CRYP_MID : public RegisterReadOnly<0x540013fc> {
            using MID = Field<0, 32>;    // MID
        };

    };

    // CRYP1
    struct CRYP2 {
        // CRYP control register
        struct CRYP_CR : public Register<0x4c005000> {
            using ALGODIR = Field<2, 1>;    // ALGODIR
            using ALGOMODE = Field<3, 3>;    // ALGOMODE
            using DATATYPE = Field<6, 2>;    // DATATYPE
            using KEYSIZE = Field<8, 2>;    // KEYSIZE
            using FFLUSH = Field<14, 1>;    // FFLUSH
            using CRYPEN = Field<15, 1>;    // CRYPEN
            using GCM_CCMPH = Field<16, 2>;    // GCM_CCMPH
            using ALGOMODE3 = Field<19, 1>;    // ALGOMODE3
            using NPBLB = Field<20, 4>;    // NPBLB
        };

        // CRYP status register
        struct CRYP_SR : public RegisterReadOnly<0x4c005004> {
            using IFEM = Field<0, 1>;    // IFEM
            using IFNF = Field<1, 1>;    // IFNF
            using OFNE = Field<2, 1>;    // OFNE
            using OFFU = Field<3, 1>;    // OFFU
            using BUSY = Field<4, 1>;    // BUSY
        };

        // The CRYP_DIN register is the data input register. It is 32-bit wide. It is used to enter into the input FIFO up to four 64-bit blocks (TDES) or two 128-bit blocks (AES) of plaintext (when encrypting) or ciphertext (when decrypting), one 32-bit word at a time. To fit different data sizes, the data can be swapped after processing by configuring the DATATYPE bits in the CRYP_CR register. Refer to Section39.3.16: CRYP data registers and data swapping for more details. When CRYP_DIN register is written to the data are pushed into the input FIFO. If CRYPEN = 1, when at least two 32-bit words in the DES/TDES mode have been pushed into the input FIFO (four words in the AES mode), and when at least two words are free in the output FIFO (four words in the AES mode), the CRYP engine starts an encrypting or decrypting process. When CRYP_DIN register is read: If CRYPEN = 0, the FIFO is popped, and then the data present in the Input FIFO are returned, from the oldest one (first reading) to the newest one (last reading). The IFEM flag must be checked before each read operation to make sure that the FIFO is not empty. if CRYPEN = 1, an undefined value is returned. After the CRYP_DIN register has been read once or several times, the FIFO must be flushed by setting the FFLUSH bit prior to processing new data.
        struct CRYP_DIN : public Register<0x4c005008> {
            using DATAIN = Field<0, 32>;    // DATAIN
        };

        // The CRYP_DOUT register is the data output register. It is read-only and 32-bit wide. It is used to retrieve from the output FIFO up to four 64-bit blocks (TDES) or two 128-bit blocks (AES) of plaintext (when encrypting) or ciphertext (when decrypting), one 32-bit word at a time. To fit different data sizes, the data can be swapped after processing by configuring the DATATYPE bits in the CRYP_CR register. Refer to Section39.3.16: CRYP data registers and data swapping for more details. When CRYP_DOUT register is read, the last data entered into the output FIFO (pointed to by the read pointer) is returned.
        struct CRYP_DOUT : public RegisterReadOnly<0x4c00500c> {
            using DATAOUT = Field<0, 32>;    // DATAOUT
        };

        // CRYP DMA control register
        struct CRYP_DMACR : public Register<0x4c005010> {
            using DIEN = Field<0, 1>;    // DIEN
            using DOEN = Field<1, 1>;    // DOEN
        };

        // The CRYP_IMSCR register is the interrupt mask set or clear register. It is a read/write register. When a read operation is performed, this register gives the current value of the mask applied to the relevant interrupt. Writing 1 to the particular bit sets the mask, thus enabling the interrupt to be read. Writing 0 to this bit clears the corresponding mask. All the bits are cleared to 0 when the peripheral is reset.
        struct CRYP_IMSCR : public Register<0x4c005014> {
            using INIM = Field<0, 1>;    // INIM
            using OUTIM = Field<1, 1>;    // OUTIM
        };

        // The CRYP_RISR register is the raw interrupt status register. It is a read-only register. When a read operation is performed, this register gives the current raw status of the corresponding interrupt, i.e. the interrupt information without taking CRYP_IMSCR mask into account. Write operations have no effect.
        struct CRYP_RISR : public RegisterReadOnly<0x4c005018> {
            using INRIS = Field<0, 1>;    // INRIS
            using OUTRIS = Field<1, 1>;    // OUTRIS
        };

        // The CRYP_MISR register is the masked interrupt status register. It is a read-only register. When a read operation is performed, this register gives the current masked status of the corresponding interrupt, i.e. the interrupt information taking CRYP_IMSCR mask into account. Write operations have no effect.
        struct CRYP_MISR : public RegisterReadOnly<0x4c00501c> {
            using INMIS = Field<0, 1>;    // INMIS
            using OUTMIS = Field<1, 1>;    // OUTMIS
        };

        // CRYP key registers contain the cryptographic keys. In DES/TDES mode, the keys are 64-bit binary values (number from left to right, that is the leftmost bit is bit 1) and named K1, K2 and K3 (K0 is not used). Each key consists of 56 information bits and 8 parity bits. In AES mode, the key is considered as a single 128, 192 or 256 bits long sequence K0K1K2...K127/191/255. The AES key is entered into the registers as follows: for AES-128: K0..K127 corresponds to b127..b0 (b255..b128 are not used), for AES-192: K0..K191 corresponds to b191..b0 (b255..b192 are not used), for AES-256: K0..K255 corresponds to b255..b0. In all cases key bit K0 is the leftmost bit in CRYP inner memory and register bit b0 is the rightmost bit in corresponding CRYP_KxLR key register. For more information refer to Section39.3.17: CRYP key registers. Write accesses to these registers are disregarded when the cryptographic processor is busy (bit BUSY = 1 in the CRYP_SR register)
        struct CRYP_K0LR : public RegisterWriteOnly<0x4c005020> {
            using K = Field<0, 32>;    // K
        };

        // Refer to Section39.6.9: CRYP key register 0L (CRYP_K0LR) for details.
        struct CRYP_K0RR : public RegisterWriteOnly<0x4c005024> {
            using K = Field<0, 32>;    // K
        };

        // Refer to Section39.6.9: CRYP key register 0L (CRYP_K0LR) for details.
        struct CRYP_K1LR : public RegisterWriteOnly<0x4c005028> {
            using K = Field<0, 32>;    // K
        };

        // Refer to Section39.6.9: CRYP key register 0L (CRYP_K0LR) for details.
        struct CRYP_K1RR : public RegisterWriteOnly<0x4c00502c> {
            using K = Field<0, 32>;    // K
        };

        // Refer to Section39.6.9: CRYP key register 0L (CRYP_K0LR) for details.
        struct CRYP_K2LR : public RegisterWriteOnly<0x4c005030> {
            using K = Field<0, 32>;    // K
        };

        // Refer to Section39.6.9: CRYP key register 0L (CRYP_K0LR) for details.
        struct CRYP_K2RR : public RegisterWriteOnly<0x4c005034> {
            using K = Field<0, 32>;    // K
        };

        // Refer to Section39.6.9: CRYP key register 0L (CRYP_K0LR) for details.
        struct CRYP_K3LR : public RegisterWriteOnly<0x4c005038> {
            using K = Field<0, 32>;    // K
        };

        // Refer to Section39.6.9: CRYP key register 0L (CRYP_K0LR) for details.
        struct CRYP_K3RR : public RegisterWriteOnly<0x4c00503c> {
            using K = Field<0, 32>;    // K
        };

        // The CRYP_IV0...1(L/R)R are the left-word and right-word registers for the initialization vector (64 bits for DES/TDES and 128 bits for AES). For more information refer to Section39.3.18: CRYP initialization vector registers. IV0 is the leftmost bit whereas IV63 (DES, TDES) or IV127 (AES) are the rightmost bits of the initialization vector. IV1(L/R)R is used only in the AES. Only CRYP_IV0(L/R) is used in DES/TDES. Write access to these registers are disregarded when the cryptographic processor is busy (bit BUSY = 1 in the CRYP_SR register).
        struct CRYP_IV0LR : public Register<0x4c005040> {
            using IV31 = Field<0, 1>;    // IV31
            using IV30 = Field<1, 1>;    // IV30
            using IV29 = Field<2, 1>;    // IV29
            using IV28 = Field<3, 1>;    // IV28
            using IV27 = Field<4, 1>;    // IV27
            using IV26 = Field<5, 1>;    // IV26
            using IV25 = Field<6, 1>;    // IV25
            using IV24 = Field<7, 1>;    // IV24
            using IV23 = Field<8, 1>;    // IV23
            using IV22 = Field<9, 1>;    // IV22
            using IV21 = Field<10, 1>;    // IV21
            using IV20 = Field<11, 1>;    // IV20
            using IV19 = Field<12, 1>;    // IV19
            using IV18 = Field<13, 1>;    // IV18
            using IV17 = Field<14, 1>;    // IV17
            using IV16 = Field<15, 1>;    // IV16
            using IV15 = Field<16, 1>;    // IV15
            using IV14 = Field<17, 1>;    // IV14
            using IV13 = Field<18, 1>;    // IV13
            using IV12 = Field<19, 1>;    // IV12
            using IV11 = Field<20, 1>;    // IV11
            using IV10 = Field<21, 1>;    // IV10
            using IV9 = Field<22, 1>;    // IV9
            using IV8 = Field<23, 1>;    // IV8
            using IV7 = Field<24, 1>;    // IV7
            using IV6 = Field<25, 1>;    // IV6
            using IV5 = Field<26, 1>;    // IV5
            using IV4 = Field<27, 1>;    // IV4
            using IV3 = Field<28, 1>;    // IV3
            using IV2 = Field<29, 1>;    // IV2
            using IV1 = Field<30, 1>;    // IV1
            using IV0 = Field<31, 1>;    // IV0
        };

        // Refer to Section39.6.17: CRYP initialization vector register 0L (CRYP_IV0LR) for details.
        struct CRYP_IV0RR : public Register<0x4c005044> {
            using IV63 = Field<0, 1>;    // IV63
            using IV62 = Field<1, 1>;    // IV62
            using IV61 = Field<2, 1>;    // IV61
            using IV60 = Field<3, 1>;    // IV60
            using IV59 = Field<4, 1>;    // IV59
            using IV58 = Field<5, 1>;    // IV58
            using IV57 = Field<6, 1>;    // IV57
            using IV56 = Field<7, 1>;    // IV56
            using IV55 = Field<8, 1>;    // IV55
            using IV54 = Field<9, 1>;    // IV54
            using IV53 = Field<10, 1>;    // IV53
            using IV52 = Field<11, 1>;    // IV52
            using IV51 = Field<12, 1>;    // IV51
            using IV50 = Field<13, 1>;    // IV50
            using IV49 = Field<14, 1>;    // IV49
            using IV48 = Field<15, 1>;    // IV48
            using IV47 = Field<16, 1>;    // IV47
            using IV46 = Field<17, 1>;    // IV46
            using IV45 = Field<18, 1>;    // IV45
            using IV44 = Field<19, 1>;    // IV44
            using IV43 = Field<20, 1>;    // IV43
            using IV42 = Field<21, 1>;    // IV42
            using IV41 = Field<22, 1>;    // IV41
            using IV40 = Field<23, 1>;    // IV40
            using IV39 = Field<24, 1>;    // IV39
            using IV38 = Field<25, 1>;    // IV38
            using IV37 = Field<26, 1>;    // IV37
            using IV36 = Field<27, 1>;    // IV36
            using IV35 = Field<28, 1>;    // IV35
            using IV34 = Field<29, 1>;    // IV34
            using IV33 = Field<30, 1>;    // IV33
            using IV32 = Field<31, 1>;    // IV32
        };

        // Refer to Section39.6.17: CRYP initialization vector register 0L (CRYP_IV0LR) for details.
        struct CRYP_IV1LR : public Register<0x4c005048> {
            using IV95 = Field<0, 1>;    // IV95
            using IV94 = Field<1, 1>;    // IV94
            using IV93 = Field<2, 1>;    // IV93
            using IV92 = Field<3, 1>;    // IV92
            using IV91 = Field<4, 1>;    // IV91
            using IV90 = Field<5, 1>;    // IV90
            using IV89 = Field<6, 1>;    // IV89
            using IV88 = Field<7, 1>;    // IV88
            using IV87 = Field<8, 1>;    // IV87
            using IV86 = Field<9, 1>;    // IV86
            using IV85 = Field<10, 1>;    // IV85
            using IV84 = Field<11, 1>;    // IV84
            using IV83 = Field<12, 1>;    // IV83
            using IV82 = Field<13, 1>;    // IV82
            using IV81 = Field<14, 1>;    // IV81
            using IV80 = Field<15, 1>;    // IV80
            using IV79 = Field<16, 1>;    // IV79
            using IV78 = Field<17, 1>;    // IV78
            using IV77 = Field<18, 1>;    // IV77
            using IV76 = Field<19, 1>;    // IV76
            using IV75 = Field<20, 1>;    // IV75
            using IV74 = Field<21, 1>;    // IV74
            using IV73 = Field<22, 1>;    // IV73
            using IV72 = Field<23, 1>;    // IV72
            using IV71 = Field<24, 1>;    // IV71
            using IV70 = Field<25, 1>;    // IV70
            using IV69 = Field<26, 1>;    // IV69
            using IV68 = Field<27, 1>;    // IV68
            using IV67 = Field<28, 1>;    // IV67
            using IV66 = Field<29, 1>;    // IV66
            using IV65 = Field<30, 1>;    // IV65
            using IV64 = Field<31, 1>;    // IV64
        };

        // Refer to Section39.6.17: CRYP initialization vector register 0L (CRYP_IV0LR) for details.
        struct CRYP_IV1RR : public Register<0x4c00504c> {
            using IV127 = Field<0, 1>;    // IV127
            using IV126 = Field<1, 1>;    // IV126
            using IV125 = Field<2, 1>;    // IV125
            using IV124 = Field<3, 1>;    // IV124
            using IV123 = Field<4, 1>;    // IV123
            using IV122 = Field<5, 1>;    // IV122
            using IV121 = Field<6, 1>;    // IV121
            using IV120 = Field<7, 1>;    // IV120
            using IV119 = Field<8, 1>;    // IV119
            using IV118 = Field<9, 1>;    // IV118
            using IV117 = Field<10, 1>;    // IV117
            using IV116 = Field<11, 1>;    // IV116
            using IV115 = Field<12, 1>;    // IV115
            using IV114 = Field<13, 1>;    // IV114
            using IV113 = Field<14, 1>;    // IV113
            using IV112 = Field<15, 1>;    // IV112
            using IV111 = Field<16, 1>;    // IV111
            using IV110 = Field<17, 1>;    // IV110
            using IV109 = Field<18, 1>;    // IV109
            using IV108 = Field<19, 1>;    // IV108
            using IV107 = Field<20, 1>;    // IV107
            using IV106 = Field<21, 1>;    // IV106
            using IV105 = Field<22, 1>;    // IV105
            using IV104 = Field<23, 1>;    // IV104
            using IV103 = Field<24, 1>;    // IV103
            using IV102 = Field<25, 1>;    // IV102
            using IV101 = Field<26, 1>;    // IV101
            using IV100 = Field<27, 1>;    // IV100
            using IV99 = Field<28, 1>;    // IV99
            using IV98 = Field<29, 1>;    // IV98
            using IV97 = Field<30, 1>;    // IV97
            using IV96 = Field<31, 1>;    // IV96
        };

        // These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
        struct CRYP_CSGCMCCM0R : public Register<0x4c005050> {
            using CSGCMCCM0 = Field<0, 32>;    // CSGCMCCM0
        };

        // These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
        struct CRYP_CSGCMCCM1R : public Register<0x4c005054> {
            using CSGCMCCM1 = Field<0, 32>;    // CSGCMCCM1
        };

        // These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
        struct CRYP_CSGCMCCM2R : public Register<0x4c005058> {
            using CSGCMCCM2 = Field<0, 32>;    // CSGCMCCM2
        };

        // These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
        struct CRYP_CSGCMCCM3R : public Register<0x4c00505c> {
            using CSGCMCCM3 = Field<0, 32>;    // CSGCMCCM3
        };

        // These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
        struct CRYP_CSGCMCCM4R : public Register<0x4c005060> {
            using CSGCMCCM4 = Field<0, 32>;    // CSGCMCCM4
        };

        // These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
        struct CRYP_CSGCMCCM5R : public Register<0x4c005064> {
            using CSGCMCCM5 = Field<0, 32>;    // CSGCMCCM5
        };

        // These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
        struct CRYP_CSGCMCCM6R : public Register<0x4c005068> {
            using CSGCMCCM6 = Field<0, 32>;    // CSGCMCCM6
        };

        // These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
        struct CRYP_CSGCMCCM7R : public Register<0x4c00506c> {
            using CSGCMCCM7 = Field<0, 32>;    // CSGCMCCM7
        };

        // Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
        struct CRYP_CSGCM0R : public Register<0x4c005070> {
            using CSGCM0 = Field<0, 32>;    // CSGCM0
        };

        // Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
        struct CRYP_CSGCM1R : public Register<0x4c005074> {
            using CSGCM1 = Field<0, 32>;    // CSGCM1
        };

        // Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
        struct CRYP_CSGCM2R : public Register<0x4c005078> {
            using CSGCM2 = Field<0, 32>;    // CSGCM2
        };

        // Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
        struct CRYP_CSGCM3R : public Register<0x4c00507c> {
            using CSGCM3 = Field<0, 32>;    // CSGCM3
        };

        // Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
        struct CRYP_CSGCM4R : public Register<0x4c005080> {
            using CSGCM4 = Field<0, 32>;    // CSGCM4
        };

        // Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
        struct CRYP_CSGCM5R : public Register<0x4c005084> {
            using CSGCM5 = Field<0, 32>;    // CSGCM5
        };

        // Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
        struct CRYP_CSGCM6R : public Register<0x4c005088> {
            using CSGCM6 = Field<0, 32>;    // CSGCM6
        };

        // Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
        struct CRYP_CSGCM7R : public Register<0x4c00508c> {
            using CSGCM7 = Field<0, 32>;    // CSGCM7
        };

        // CRYP hardware configuration register
        struct CRYP_HWCFGR : public RegisterReadOnly<0x4c0053f0> {
            using CFG1 = Field<0, 4>;    // CFG1
            using CFG2 = Field<4, 4>;    // CFG2
            using CFG3 = Field<8, 4>;    // CFG3
            using CFG4 = Field<12, 4>;    // CFG4
        };

        // CRYP HW Version Register
        struct CRYP_VERR : public RegisterReadOnly<0x4c0053f4> {
            using VER = Field<0, 8>;    // VER
        };

        // CRYP Identification
        struct CRYP_IPIDR : public RegisterReadOnly<0x4c0053f8> {
            using ID = Field<0, 32>;    // ID
        };

        // CRYP HW Magic ID
        struct CRYP_MID : public RegisterReadOnly<0x4c0053fc> {
            using MID = Field<0, 32>;    // MID
        };

    };

    // DAC1
    struct DAC1 {
        // DAC control register
        struct DAC_CR : public Register<0x40017000> {
            using EN1 = Field<0, 1>;    // EN1
            using TEN1 = Field<1, 1>;    // TEN1
            using TSEL10 = Field<2, 1>;    // TSEL10
            using TSEL11 = Field<3, 1>;    // TSEL11
            using TSEL12 = Field<4, 1>;    // TSEL12
            using TSEL13 = Field<5, 1>;    // TSEL13
            using WAVE1 = Field<6, 2>;    // WAVE1
            using MAMP1 = Field<8, 4>;    // MAMP1
            using DMAEN1 = Field<12, 1>;    // DMAEN1
            using DMAUDRIE1 = Field<13, 1>;    // DMAUDRIE1
            using CEN1 = Field<14, 1>;    // CEN1
            using HFSEL = Field<15, 1>;    // HFSEL
            using EN2 = Field<16, 1>;    // EN2
            using TEN2 = Field<17, 1>;    // TEN2
            using TSEL20 = Field<18, 1>;    // TSEL20
            using TSEL21 = Field<19, 1>;    // TSEL21
            using TSEL22 = Field<20, 1>;    // TSEL22
            using TSEL23 = Field<21, 1>;    // TSEL23
            using WAVE2 = Field<22, 2>;    // WAVE2
            using MAMP2 = Field<24, 4>;    // MAMP2
            using DMAEN2 = Field<28, 1>;    // DMAEN2
            using DMAUDRIE2 = Field<29, 1>;    // DMAUDRIE2
            using CEN2 = Field<30, 1>;    // CEN2
        };

        // DAC software trigger register
        struct DAC_SWTRGR : public RegisterWriteOnly<0x40017004> {
            using SWTRIG1 = Field<0, 1>;    // SWTRIG1
            using SWTRIG2 = Field<1, 1>;    // SWTRIG2
        };

        // DAC channel1 12-bit right-aligned data holding register
        struct DAC_DHR12R1 : public Register<0x40017008> {
            using DACC1DHR = Field<0, 12>;    // DACC1DHR
        };

        // DAC channel1 12-bit left aligned data holding register
        struct DAC_DHR12L1 : public Register<0x4001700c> {
            using DACC1DHR = Field<4, 12>;    // DACC1DHR
        };

        // DAC channel1 8-bit right aligned data holding register
        struct DAC_DHR8R1 : public Register<0x40017010> {
            using DACC1DHR = Field<0, 8>;    // DACC1DHR
        };

        // This register is available only on dual-channel DACs. Refer to Section29.3: DAC implementation.
        struct DAC_DHR12R2 : public Register<0x40017014> {
            using DACC2DHR = Field<0, 12>;    // DACC2DHR
        };

        // This register is available only on dual-channel DACs. Refer to Section29.3: DAC implementation.
        struct DAC_DHR12L2 : public Register<0x40017018> {
            using DACC2DHR = Field<4, 12>;    // DACC2DHR
        };

        // This register is available only on dual-channel DACs. Refer to Section29.3: DAC implementation.
        struct DAC_DHR8R2 : public Register<0x4001701c> {
            using DACC2DHR = Field<0, 8>;    // DACC2DHR
        };

        // Dual DAC 12-bit right-aligned data holding register
        struct DAC_DHR12RD : public Register<0x40017020> {
            using DACC1DHR = Field<0, 12>;    // DACC1DHR
            using DACC2DHR = Field<16, 12>;    // DACC2DHR
        };

        // Dual DAC 12-bit left aligned data holding register
        struct DAC_DHR12LD : public Register<0x40017024> {
            using DACC1DHR = Field<4, 12>;    // DACC1DHR
            using DACC2DHR = Field<20, 12>;    // DACC2DHR
        };

        // Dual DAC 8-bit right aligned data holding register
        struct DAC_DHR8RD : public Register<0x40017028> {
            using DACC1DHR = Field<0, 8>;    // DACC1DHR
            using DACC2DHR = Field<8, 8>;    // DACC2DHR
        };

        // DAC channel1 data output register
        struct DAC_DOR1 : public RegisterReadOnly<0x4001702c> {
            using DACC1DOR = Field<0, 12>;    // DACC1DOR
        };

        // This register is available only on dual-channel DACs. Refer to Section29.3: DAC implementation.
        struct DAC_DOR2 : public RegisterReadOnly<0x40017030> {
            using DACC2DOR = Field<0, 12>;    // DACC2DOR
        };

        // DAC status register
        struct DAC_SR : public Register<0x40017034> {
            using DMAUDR1 = Field<13, 1>;    // DMAUDR1
            using CAL_FLAG1 = Field<14, 1>;    // CAL_FLAG1
            using BWST1 = Field<15, 1>;    // BWST1
            using DMAUDR2 = Field<29, 1>;    // DMAUDR2
            using CAL_FLAG2 = Field<30, 1>;    // CAL_FLAG2
            using BWST2 = Field<31, 1>;    // BWST2
        };

        // DAC calibration control register
        struct DAC_CCR : public Register<0x40017038> {
            using OTRIM1 = Field<0, 5>;    // OTRIM1
            using OTRIM2 = Field<16, 5>;    // OTRIM2
        };

        // DAC mode control register
        struct DAC_MCR : public Register<0x4001703c> {
            using MODE1 = Field<0, 3>;    // MODE1
            using MODE2 = Field<16, 3>;    // MODE2
        };

        // DAC channel 1 sample and hold sample time register
        struct DAC_SHSR1 : public Register<0x40017040> {
            using TSAMPLE1 = Field<0, 10>;    // TSAMPLE1
        };

        // This register is available only on dual-channel DACs. Refer to Section29.3: DAC implementation.
        struct DAC_SHSR2 : public Register<0x40017044> {
            using TSAMPLE2 = Field<0, 10>;    // TSAMPLE2
        };

        // DAC sample and hold time register
        struct DAC_SHHR : public Register<0x40017048> {
            using THOLD1 = Field<0, 10>;    // THOLD1
            using THOLD2 = Field<16, 10>;    // THOLD2
        };

        // DAC sample and hold refresh time register
        struct DAC_SHRR : public Register<0x4001704c> {
            using TREFRESH1 = Field<0, 8>;    // TREFRESH1
            using TREFRESH2 = Field<16, 8>;    // TREFRESH2
        };

        // DAC IP hardware configuration register
        struct DAC_HWCFGR0 : public RegisterReadOnly<0x400173f0> {
            using DUAL = Field<0, 4>;    // DUAL
            using LFSR = Field<4, 4>;    // LFSR
            using TRIANGLE = Field<8, 4>;    // TRIANGLE
            using SAMPLE = Field<12, 4>;    // SAMPLE
            using OR_CFG = Field<16, 8>;    // OR_CFG
        };

        // No
        struct DAC_VERR : public RegisterReadOnly<0x400173f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // No
        struct DAC_IPIDR : public RegisterReadOnly<0x400173f8> {
            using ID = Field<0, 32>;    // ID
        };

        // No
        struct DAC_SIDR : public RegisterReadOnly<0x400173fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // DDRCTRL
    struct DDRCTRL {
        // DDRCTRL master register 0
        struct DDRCTRL_MSTR : public Register<0x5a003000> {
            using DDR3 = Field<0, 1>;    // DDR3
            using LPDDR2 = Field<2, 1>;    // LPDDR2
            using LPDDR3 = Field<3, 1>;    // LPDDR3
            using BURSTCHOP = Field<9, 1>;    // BURSTCHOP
            using EN_2T_TIMING_MODE = Field<10, 1>;    // EN_2T_TIMING_MODE
            using DATA_BUS_WIDTH = Field<12, 2>;    // DATA_BUS_WIDTH
            using DLL_OFF_MODE = Field<15, 1>;    // DLL_OFF_MODE
            using BURST_RDWR = Field<16, 4>;    // BURST_RDWR
        };

        // DDRCTRL operating mode status register
        struct DDRCTRL_STAT : public RegisterReadOnly<0x5a003004> {
            using OPERATING_MODE = Field<0, 3>;    // OPERATING_MODE
            using SELFREF_TYPE = Field<4, 2>;    // SELFREF_TYPE
            using SELFREF_CAM_NOT_EMPTY = Field<12, 1>;    // SELFREF_CAM_NOT_EMPTY
        };

        // Mode Register Read/Write Control Register 0. Do not enable more than one of the following fields simultaneously: sw_init_int pda_en mpr_en
        struct DDRCTRL_MRCTRL0 : public Register<0x5a003010> {
            using MR_TYPE = Field<0, 1>;    // MR_TYPE
            using MR_RANK = Field<4, 1>;    // MR_RANK
            using MR_ADDR = Field<12, 4>;    // MR_ADDR
            using MR_WR = Field<31, 1>;    // MR_WR
        };

        // DDRCTRL mode register read/write control register 1
        struct DDRCTRL_MRCTRL1 : public Register<0x5a003014> {
            using MR_DATA = Field<0, 16>;    // MR_DATA
        };

        // DDRCTRL mode register read/write status register
        struct DDRCTRL_MRSTAT : public RegisterReadOnly<0x5a003018> {
            using MR_WR_BUSY = Field<0, 1>;    // MR_WR_BUSY
        };

        // DDRCTRL temperature derate enable register
        struct DDRCTRL_DERATEEN : public Register<0x5a003020> {
            using DERATE_ENABLE = Field<0, 1>;    // DERATE_ENABLE
            using DERATE_VALUE = Field<1, 2>;    // DERATE_VALUE
            using DERATE_BYTE = Field<4, 4>;    // DERATE_BYTE
        };

        // DDRCTRL temperature derate interval register
        struct DDRCTRL_DERATEINT : public Register<0x5a003024> {
            using MR4_READ_INTERVAL = Field<0, 32>;    // MR4_READ_INTERVAL
        };

        // DDRCTRL low power control register
        struct DDRCTRL_PWRCTL : public Register<0x5a003030> {
            using SELFREF_EN = Field<0, 1>;    // SELFREF_EN
            using POWERDOWN_EN = Field<1, 1>;    // POWERDOWN_EN
            using DEEPPOWERDOWN_EN = Field<2, 1>;    // DEEPPOWERDOWN_EN
            using EN_DFI_DRAM_CLK_DISABLE = Field<3, 1>;    // EN_DFI_DRAM_CLK_DISABLE
            using SELFREF_SW = Field<5, 1>;    // SELFREF_SW
            using DIS_CAM_DRAIN_SELFREF = Field<7, 1>;    // DIS_CAM_DRAIN_SELFREF
        };

        // DDRCTRL low power timing register
        struct DDRCTRL_PWRTMG : public Register<0x5a003034> {
            using POWERDOWN_TO_X32 = Field<0, 5>;    // POWERDOWN_TO_X32
            using T_DPD_X4096 = Field<8, 8>;    // T_DPD_X4096
            using SELFREF_TO_X32 = Field<16, 8>;    // SELFREF_TO_X32
        };

        // DDRCTRL hardware low power control register
        struct DDRCTRL_HWLPCTL : public Register<0x5a003038> {
            using HW_LP_EN = Field<0, 1>;    // HW_LP_EN
            using HW_LP_EXIT_IDLE_EN = Field<1, 1>;    // HW_LP_EXIT_IDLE_EN
            using HW_LP_IDLE_X32 = Field<16, 12>;    // HW_LP_IDLE_X32
        };

        // DDRCTRL refresh control register 0
        struct DDRCTRL_RFSHCTL0 : public Register<0x5a003050> {
            using PER_BANK_REFRESH = Field<2, 1>;    // PER_BANK_REFRESH
            using REFRESH_BURST = Field<4, 5>;    // REFRESH_BURST
            using REFRESH_TO_X32 = Field<12, 5>;    // REFRESH_TO_X32
            using REFRESH_MARGIN = Field<20, 4>;    // REFRESH_MARGIN
        };

        // DDRCTRL refresh control register 3
        struct DDRCTRL_RFSHCTL3 : public Register<0x5a003060> {
            using DIS_AUTO_REFRESH = Field<0, 1>;    // DIS_AUTO_REFRESH
            using REFRESH_UPDATE_LEVEL = Field<1, 1>;    // REFRESH_UPDATE_LEVEL
        };

        // DDRCTRL refresh timing register
        struct DDRCTRL_RFSHTMG : public Register<0x5a003064> {
            using T_RFC_MIN = Field<0, 10>;    // T_RFC_MIN
            using LPDDR3_TREFBW_EN = Field<15, 1>;    // LPDDR3_TREFBW_EN
            using T_RFC_NOM_X1_X32 = Field<16, 12>;    // T_RFC_NOM_X1_X32
            using T_RFC_NOM_X1_SEL = Field<31, 1>;    // T_RFC_NOM_X1_SEL
        };

        // DDRCTRL CRC parity control register 0
        struct DDRCTRL_CRCPARCTL0 : public Register<0x5a0030c0> {
            using DFI_ALERT_ERR_INT_EN = Field<0, 1>;    // DFI_ALERT_ERR_INT_EN
            using DFI_ALERT_ERR_INT_CLR = Field<1, 1>;    // DFI_ALERT_ERR_INT_CLR
            using DFI_ALERT_ERR_CNT_CLR = Field<2, 1>;    // DFI_ALERT_ERR_CNT_CLR
        };

        // DDRCTRL CRC parity status register
        struct DDRCTRL_CRCPARSTAT : public RegisterReadOnly<0x5a0030cc> {
            using DFI_ALERT_ERR_CNT = Field<0, 16>;    // DFI_ALERT_ERR_CNT
            using DFI_ALERT_ERR_INT = Field<16, 1>;    // DFI_ALERT_ERR_INT
        };

        // DDRCTRL SDRAM initialization register 0
        struct DDRCTRL_INIT0 : public Register<0x5a0030d0> {
            using PRE_CKE_X1024 = Field<0, 12>;    // PRE_CKE_X1024
            using POST_CKE_X1024 = Field<16, 10>;    // POST_CKE_X1024
            using SKIP_DRAM_INIT = Field<30, 2>;    // SKIP_DRAM_INIT
        };

        // DDRCTRL SDRAM initialization register 1
        struct DDRCTRL_INIT1 : public Register<0x5a0030d4> {
            using PRE_OCD_X32 = Field<0, 4>;    // PRE_OCD_X32
            using DRAM_RSTN_X1024 = Field<16, 9>;    // DRAM_RSTN_X1024
        };

        // DDRCTRL SDRAM initialization register 2
        struct DDRCTRL_INIT2 : public Register<0x5a0030d8> {
            using MIN_STABLE_CLOCK_X1 = Field<0, 4>;    // MIN_STABLE_CLOCK_X1
            using IDLE_AFTER_RESET_X32 = Field<8, 8>;    // IDLE_AFTER_RESET_X32
        };

        // DDRCTRL SDRAM initialization register 3
        struct DDRCTRL_INIT3 : public Register<0x5a0030dc> {
            using EMR = Field<0, 16>;    // EMR
            using MR = Field<16, 16>;    // MR
        };

        // DDRCTRL SDRAM initialization register 4
        struct DDRCTRL_INIT4 : public Register<0x5a0030e0> {
            using EMR3 = Field<0, 16>;    // EMR3
            using EMR2 = Field<16, 16>;    // EMR2
        };

        // DDRCTRL SDRAM initialization register 5
        struct DDRCTRL_INIT5 : public Register<0x5a0030e4> {
            using MAX_AUTO_INIT_X1024 = Field<0, 10>;    // MAX_AUTO_INIT_X1024
            using DEV_ZQINIT_X32 = Field<16, 8>;    // DEV_ZQINIT_X32
        };

        // DDRCTRL DIMM control register
        struct DDRCTRL_DIMMCTL : public Register<0x5a0030f0> {
            using DIMM_STAGGER_CS_EN = Field<0, 1>;    // DIMM_STAGGER_CS_EN
            using DIMM_ADDR_MIRR_EN = Field<1, 1>;    // DIMM_ADDR_MIRR_EN
        };

        // DDRCTRL SDRAM timing register 0
        struct DDRCTRL_DRAMTMG0 : public Register<0x5a003100> {
            using T_RAS_MIN = Field<0, 6>;    // T_RAS_MIN
            using T_RAS_MAX = Field<8, 7>;    // T_RAS_MAX
            using T_FAW = Field<16, 6>;    // T_FAW
            using WR2PRE = Field<24, 7>;    // WR2PRE
        };

        // DDRCTRL SDRAM timing register 1
        struct DDRCTRL_DRAMTMG1 : public Register<0x5a003104> {
            using T_RC = Field<0, 7>;    // T_RC
            using RD2PRE = Field<8, 6>;    // RD2PRE
            using T_XP = Field<16, 5>;    // T_XP
        };

        // DDRCTRL SDRAM timing register 2
        struct DDRCTRL_DRAMTMG2 : public Register<0x5a003108> {
            using WR2RD = Field<0, 6>;    // WR2RD
            using RD2WR = Field<8, 6>;    // RD2WR
            using READ_LATENCY = Field<16, 6>;    // READ_LATENCY
            using WRITE_LATENCY = Field<24, 6>;    // WRITE_LATENCY
        };

        // DDRCTRL SDRAM timing register 3
        struct DDRCTRL_DRAMTMG3 : public Register<0x5a00310c> {
            using T_MOD = Field<0, 10>;    // T_MOD
            using T_MRD = Field<12, 6>;    // T_MRD
            using T_MRW = Field<20, 10>;    // T_MRW
        };

        // DDRCTRL SDRAM timing register 4
        struct DDRCTRL_DRAMTMG4 : public Register<0x5a003110> {
            using T_RP = Field<0, 5>;    // T_RP
            using T_RRD = Field<8, 4>;    // T_RRD
            using T_CCD = Field<16, 4>;    // T_CCD
            using T_RCD = Field<24, 5>;    // T_RCD
        };

        // DDRCTRL SDRAM timing register 5
        struct DDRCTRL_DRAMTMG5 : public Register<0x5a003114> {
            using T_CKE = Field<0, 5>;    // T_CKE
            using T_CKESR = Field<8, 6>;    // T_CKESR
            using T_CKSRE = Field<16, 4>;    // T_CKSRE
            using T_CKSRX = Field<24, 4>;    // T_CKSRX
        };

        // DDRCTRL SDRAM timing register 6
        struct DDRCTRL_DRAMTMG6 : public Register<0x5a003118> {
            using T_CKCSX = Field<0, 4>;    // T_CKCSX
            using T_CKDPDX = Field<16, 4>;    // T_CKDPDX
            using T_CKDPDE = Field<24, 4>;    // T_CKDPDE
        };

        // DDRCTRL SDRAM timing register 7
        struct DDRCTRL_DRAMTMG7 : public Register<0x5a00311c> {
            using T_CKPDX = Field<0, 4>;    // T_CKPDX
            using T_CKPDE = Field<8, 4>;    // T_CKPDE
        };

        // DDRCTRL SDRAM timing register 8
        struct DDRCTRL_DRAMTMG8 : public Register<0x5a003120> {
            using T_XS_X32 = Field<0, 7>;    // T_XS_X32
            using T_XS_DLL_X32 = Field<8, 7>;    // T_XS_DLL_X32
        };

        // DDRCTRL SDRAM timing register 14
        struct DDRCTRL_DRAMTMG14 : public Register<0x5a003138> {
            using T_XSR = Field<0, 12>;    // T_XSR
        };

        // DDRCTRL SDRAM timing register 15
        struct DDRCTRL_DRAMTMG15 : public Register<0x5a00313c> {
            using T_STAB_X32 = Field<0, 8>;    // T_STAB_X32
            using EN_DFI_LP_T_STAB = Field<31, 1>;    // EN_DFI_LP_T_STAB
        };

        // DDRCTRL ZQ control register 0
        struct DDRCTRL_ZQCTL0 : public Register<0x5a003180> {
            using T_ZQ_SHORT_NOP = Field<0, 10>;    // T_ZQ_SHORT_NOP
            using T_ZQ_LONG_NOP = Field<16, 11>;    // T_ZQ_LONG_NOP
            using ZQ_RESISTOR_SHARED = Field<29, 1>;    // ZQ_RESISTOR_SHARED
            using DIS_SRX_ZQCL = Field<30, 1>;    // DIS_SRX_ZQCL
            using DIS_AUTO_ZQ = Field<31, 1>;    // DIS_AUTO_ZQ
        };

        // DDRCTRL ZQ control register 1
        struct DDRCTRL_ZQCTL1 : public Register<0x5a003184> {
            using T_ZQ_SHORT_INTERVAL_X1024 = Field<0, 20>;    // T_ZQ_SHORT_INTERVAL_X1024
            using T_ZQ_RESET_NOP = Field<20, 10>;    // T_ZQ_RESET_NOP
        };

        // DDRCTRL ZQ control register 2
        struct DDRCTRL_ZQCTL2 : public Register<0x5a003188> {
            using ZQ_RESET = Field<0, 1>;    // ZQ_RESET
        };

        // DDRCTRL ZQ status register
        struct DDRCTRL_ZQSTAT : public RegisterReadOnly<0x5a00318c> {
            using ZQ_RESET_BUSY = Field<0, 1>;    // ZQ_RESET_BUSY
        };

        // DDRCTRL DFI timing register 0
        struct DDRCTRL_DFITMG0 : public Register<0x5a003190> {
            using DFI_TPHY_WRLAT = Field<0, 6>;    // DFI_TPHY_WRLAT
            using DFI_TPHY_WRDATA = Field<8, 6>;    // DFI_TPHY_WRDATA
            using DFI_T_RDDATA_EN = Field<16, 7>;    // DFI_T_RDDATA_EN
            using DFI_T_CTRL_DELAY = Field<24, 5>;    // DFI_T_CTRL_DELAY
        };

        // DDRCTRL DFI timing register 1
        struct DDRCTRL_DFITMG1 : public Register<0x5a003194> {
            using DFI_T_DRAM_CLK_ENABLE = Field<0, 5>;    // DFI_T_DRAM_CLK_ENABLE
            using DFI_T_DRAM_CLK_DISABLE = Field<8, 5>;    // DFI_T_DRAM_CLK_DISABLE
            using DFI_T_WRDATA_DELAY = Field<16, 5>;    // DFI_T_WRDATA_DELAY
        };

        // DDRCTRL low power configuration register 0
        struct DDRCTRL_DFILPCFG0 : public Register<0x5a003198> {
            using DFI_LP_EN_PD = Field<0, 1>;    // DFI_LP_EN_PD
            using DFI_LP_WAKEUP_PD = Field<4, 4>;    // DFI_LP_WAKEUP_PD
            using DFI_LP_EN_SR = Field<8, 1>;    // DFI_LP_EN_SR
            using DFI_LP_WAKEUP_SR = Field<12, 4>;    // DFI_LP_WAKEUP_SR
            using DFI_LP_EN_DPD = Field<16, 1>;    // DFI_LP_EN_DPD
            using DFI_LP_WAKEUP_DPD = Field<20, 4>;    // DFI_LP_WAKEUP_DPD
            using DFI_TLP_RESP = Field<24, 5>;    // DFI_TLP_RESP
        };

        // DDRCTRL DFI update register 0
        struct DDRCTRL_DFIUPD0 : public Register<0x5a0031a0> {
            using DFI_T_CTRLUP_MIN = Field<0, 10>;    // DFI_T_CTRLUP_MIN
            using DFI_T_CTRLUP_MAX = Field<16, 10>;    // DFI_T_CTRLUP_MAX
            using CTRLUPD_PRE_SRX = Field<29, 1>;    // CTRLUPD_PRE_SRX
            using DIS_AUTO_CTRLUPD_SRX = Field<30, 1>;    // DIS_AUTO_CTRLUPD_SRX
            using DIS_AUTO_CTRLUPD = Field<31, 1>;    // DIS_AUTO_CTRLUPD
        };

        // DDRCTRL DFI update register 1
        struct DDRCTRL_DFIUPD1 : public Register<0x5a0031a4> {
            using DFI_T_CTRLUPD_INTERVAL_MAX_X1024 = Field<0, 8>;    // DFI_T_CTRLUPD_INTERVAL_MAX_X1024
            using DFI_T_CTRLUPD_INTERVAL_MIN_X1024 = Field<16, 8>;    // DFI_T_CTRLUPD_INTERVAL_MIN_X1024
        };

        // DDRCTRL DFI update register 2
        struct DDRCTRL_DFIUPD2 : public Register<0x5a0031a8> {
            using DFI_PHYUPD_EN = Field<31, 1>;    // DFI_PHYUPD_EN
        };

        // DDRCTRL DFI miscellaneous control register
        struct DDRCTRL_DFIMISC : public Register<0x5a0031b0> {
            using DFI_INIT_COMPLETE_EN = Field<0, 1>;    // DFI_INIT_COMPLETE_EN
            using CTL_IDLE_EN = Field<4, 1>;    // CTL_IDLE_EN
            using DFI_INIT_START = Field<5, 1>;    // DFI_INIT_START
            using DFI_FREQUENCY = Field<8, 5>;    // DFI_FREQUENCY
        };

        // DDRCTRL DFI status register
        struct DDRCTRL_DFISTAT : public RegisterReadOnly<0x5a0031bc> {
            using DFI_INIT_COMPLETE = Field<0, 1>;    // DFI_INIT_COMPLETE
            using DFI_LP_ACK = Field<1, 1>;    // DFI_LP_ACK
        };

        // DDRCTRL DFI PHY master register
        struct DDRCTRL_DFIPHYMSTR : public Register<0x5a0031c4> {
            using DFI_PHYMSTR_EN = Field<0, 1>;    // DFI_PHYMSTR_EN
        };

        // DDRCTRL address map register 1
        struct DDRCTRL_ADDRMAP1 : public Register<0x5a003204> {
            using ADDRMAP_BANK_B0 = Field<0, 6>;    // ADDRMAP_BANK_B0
            using ADDRMAP_BANK_B1 = Field<8, 6>;    // ADDRMAP_BANK_B1
            using ADDRMAP_BANK_B2 = Field<16, 6>;    // ADDRMAP_BANK_B2
        };

        // DDRCTRL address map register 2
        struct DDRCTRL_ADDRMAP2 : public Register<0x5a003208> {
            using ADDRMAP_COL_B2 = Field<0, 4>;    // ADDRMAP_COL_B2
            using ADDRMAP_COL_B3 = Field<8, 4>;    // ADDRMAP_COL_B3
            using ADDRMAP_COL_B4 = Field<16, 4>;    // ADDRMAP_COL_B4
            using ADDRMAP_COL_B5 = Field<24, 4>;    // ADDRMAP_COL_B5
        };

        // DDRCTRL address map register 3
        struct DDRCTRL_ADDRMAP3 : public Register<0x5a00320c> {
            using ADDRMAP_COL_B6 = Field<0, 4>;    // ADDRMAP_COL_B6
            using ADDRMAP_COL_B7 = Field<8, 5>;    // ADDRMAP_COL_B7
            using ADDRMAP_COL_B8 = Field<16, 5>;    // ADDRMAP_COL_B8
            using ADDRMAP_COL_B9 = Field<24, 5>;    // ADDRMAP_COL_B9
        };

        // DDRCTRL address map register 4
        struct DDRCTRL_ADDRMAP4 : public Register<0x5a003210> {
            using ADDRMAP_COL_B10 = Field<0, 5>;    // ADDRMAP_COL_B10
            using ADDRMAP_COL_B11 = Field<8, 5>;    // ADDRMAP_COL_B11
        };

        // DDRCTRL address map register 5
        struct DDRCTRL_ADDRMAP5 : public Register<0x5a003214> {
            using ADDRMAP_ROW_B0 = Field<0, 4>;    // ADDRMAP_ROW_B0
            using ADDRMAP_ROW_B1 = Field<8, 4>;    // ADDRMAP_ROW_B1
            using ADDRMAP_ROW_B2_10 = Field<16, 4>;    // ADDRMAP_ROW_B2_10
            using ADDRMAP_ROW_B11 = Field<24, 4>;    // ADDRMAP_ROW_B11
        };

        // DDRCTRL address register 6
        struct DDRCTRL_ADDRMAP6 : public Register<0x5a003218> {
            using ADDRMAP_ROW_B12 = Field<0, 4>;    // ADDRMAP_ROW_B12
            using ADDRMAP_ROW_B13 = Field<8, 4>;    // ADDRMAP_ROW_B13
            using ADDRMAP_ROW_B14 = Field<16, 4>;    // ADDRMAP_ROW_B14
            using ADDRMAP_ROW_B15 = Field<24, 4>;    // ADDRMAP_ROW_B15
            using LPDDR3_6GB_12GB = Field<31, 1>;    // LPDDR3_6GB_12GB
        };

        // DDRCTRL address map register 9
        struct DDRCTRL_ADDRMAP9 : public Register<0x5a003224> {
            using ADDRMAP_ROW_B2 = Field<0, 4>;    // ADDRMAP_ROW_B2
            using ADDRMAP_ROW_B3 = Field<8, 4>;    // ADDRMAP_ROW_B3
            using ADDRMAP_ROW_B4 = Field<16, 4>;    // ADDRMAP_ROW_B4
            using ADDRMAP_ROW_B5 = Field<24, 4>;    // ADDRMAP_ROW_B5
        };

        // DDRCTRL address map register 10
        struct DDRCTRL_ADDRMAP10 : public Register<0x5a003228> {
            using ADDRMAP_ROW_B6 = Field<0, 4>;    // ADDRMAP_ROW_B6
            using ADDRMAP_ROW_B7 = Field<8, 4>;    // ADDRMAP_ROW_B7
            using ADDRMAP_ROW_B8 = Field<16, 4>;    // ADDRMAP_ROW_B8
            using ADDRMAP_ROW_B9 = Field<24, 4>;    // ADDRMAP_ROW_B9
        };

        // DDRCTRL address map register 11
        struct DDRCTRL_ADDRMAP11 : public Register<0x5a00322c> {
            using ADDRMAP_ROW_B10 = Field<0, 4>;    // ADDRMAP_ROW_B10
        };

        // DDRCTRL ODT configuration register
        struct DDRCTRL_ODTCFG : public Register<0x5a003240> {
            using RD_ODT_DELAY = Field<2, 5>;    // RD_ODT_DELAY
            using RD_ODT_HOLD = Field<8, 4>;    // RD_ODT_HOLD
            using WR_ODT_DELAY = Field<16, 5>;    // WR_ODT_DELAY
            using WR_ODT_HOLD = Field<24, 4>;    // WR_ODT_HOLD
        };

        // DDRCTRL ODT/Rank map register
        struct DDRCTRL_ODTMAP : public Register<0x5a003244> {
            using RANK0_WR_ODT = Field<0, 1>;    // RANK0_WR_ODT
            using RANK0_RD_ODT = Field<4, 1>;    // RANK0_RD_ODT
        };

        // DDRCTRL scheduler control register
        struct DDRCTRL_SCHED : public Register<0x5a003250> {
            using FORCE_LOW_PRI_N = Field<0, 1>;    // FORCE_LOW_PRI_N
            using PREFER_WRITE = Field<1, 1>;    // PREFER_WRITE
            using PAGECLOSE = Field<2, 1>;    // PAGECLOSE
            using LPR_NUM_ENTRIES = Field<8, 4>;    // LPR_NUM_ENTRIES
            using GO2CRITICAL_HYSTERESIS = Field<16, 8>;    // GO2CRITICAL_HYSTERESIS
            using RDWR_IDLE_GAP = Field<24, 7>;    // RDWR_IDLE_GAP
        };

        // DDRCTRL scheduler control register 1
        struct DDRCTRL_SCHED1 : public Register<0x5a003254> {
            using PAGECLOSE_TIMER = Field<0, 8>;    // PAGECLOSE_TIMER
        };

        // DDRCTRL high priority read CAM register 1
        struct DDRCTRL_PERFHPR1 : public Register<0x5a00325c> {
            using HPR_MAX_STARVE = Field<0, 16>;    // HPR_MAX_STARVE
            using HPR_XACT_RUN_LENGTH = Field<24, 8>;    // HPR_XACT_RUN_LENGTH
        };

        // DDRCTRL low priority read CAM register 1
        struct DDRCTRL_PERFLPR1 : public Register<0x5a003264> {
            using LPR_MAX_STARVE = Field<0, 16>;    // LPR_MAX_STARVE
            using LPR_XACT_RUN_LENGTH = Field<24, 8>;    // LPR_XACT_RUN_LENGTH
        };

        // DDRCTRL write CAM register 1
        struct DDRCTRL_PERFWR1 : public Register<0x5a00326c> {
            using W_MAX_STARVE = Field<0, 16>;    // W_MAX_STARVE
            using W_XACT_RUN_LENGTH = Field<24, 8>;    // W_XACT_RUN_LENGTH
        };

        // DDRCTRL debug register 0
        struct DDRCTRL_DBG0 : public Register<0x5a003300> {
            using DIS_WC = Field<0, 1>;    // DIS_WC
            using DIS_COLLISION_PAGE_OPT = Field<4, 1>;    // DIS_COLLISION_PAGE_OPT
        };

        // DDRCTRL debug register 1
        struct DDRCTRL_DBG1 : public Register<0x5a003304> {
            using DIS_DQ = Field<0, 1>;    // DIS_DQ
            using DIS_HIF = Field<1, 1>;    // DIS_HIF
        };

        // DDRCTRL CAM debug register
        struct DDRCTRL_DBGCAM : public RegisterReadOnly<0x5a003308> {
            using DBG_HPR_Q_DEPTH = Field<0, 5>;    // DBG_HPR_Q_DEPTH
            using DBG_LPR_Q_DEPTH = Field<8, 5>;    // DBG_LPR_Q_DEPTH
            using DBG_W_Q_DEPTH = Field<16, 5>;    // DBG_W_Q_DEPTH
            using DBG_STALL = Field<24, 1>;    // DBG_STALL
            using DBG_RD_Q_EMPTY = Field<25, 1>;    // DBG_RD_Q_EMPTY
            using DBG_WR_Q_EMPTY = Field<26, 1>;    // DBG_WR_Q_EMPTY
            using RD_DATA_PIPELINE_EMPTY = Field<28, 1>;    // RD_DATA_PIPELINE_EMPTY
            using WR_DATA_PIPELINE_EMPTY = Field<29, 1>;    // WR_DATA_PIPELINE_EMPTY
        };

        // DDRCTRL command debug register
        struct DDRCTRL_DBGCMD : public Register<0x5a00330c> {
            using RANK0_REFRESH = Field<0, 1>;    // RANK0_REFRESH
            using ZQ_CALIB_SHORT = Field<4, 1>;    // ZQ_CALIB_SHORT
            using CTRLUPD = Field<5, 1>;    // CTRLUPD
        };

        // DDRCTRL status debug register
        struct DDRCTRL_DBGSTAT : public RegisterReadOnly<0x5a003310> {
            using RANK0_REFRESH_BUSY = Field<0, 1>;    // RANK0_REFRESH_BUSY
            using ZQ_CALIB_SHORT_BUSY = Field<4, 1>;    // ZQ_CALIB_SHORT_BUSY
            using CTRLUPD_BUSY = Field<5, 1>;    // CTRLUPD_BUSY
        };

        // DDRCTRL software register programming control enable
        struct DDRCTRL_SWCTL : public Register<0x5a003320> {
            using SW_DONE = Field<0, 1>;    // SW_DONE
        };

        // DDRCTRL software register programming control status
        struct DDRCTRL_SWSTAT : public RegisterReadOnly<0x5a003324> {
            using SW_DONE_ACK = Field<0, 1>;    // SW_DONE_ACK
        };

        // AXI Poison configuration register common for all AXI ports.
        struct DDRCTRL_POISONCFG : public Register<0x5a00336c> {
            using WR_POISON_SLVERR_EN = Field<0, 1>;    // WR_POISON_SLVERR_EN
            using WR_POISON_INTR_EN = Field<4, 1>;    // WR_POISON_INTR_EN
            using WR_POISON_INTR_CLR = Field<8, 1>;    // WR_POISON_INTR_CLR
            using RD_POISON_SLVERR_EN = Field<16, 1>;    // RD_POISON_SLVERR_EN
            using RD_POISON_INTR_EN = Field<20, 1>;    // RD_POISON_INTR_EN
            using RD_POISON_INTR_CLR = Field<24, 1>;    // RD_POISON_INTR_CLR
        };

        // DDRCTRL AXI Poison status register
        struct DDRCTRL_POISONSTAT : public RegisterReadOnly<0x5a003370> {
            using WR_POISON_INTR_0 = Field<0, 1>;    // WR_POISON_INTR_0
            using WR_POISON_INTR_1 = Field<1, 1>;    // WR_POISON_INTR_1
            using RD_POISON_INTR_0 = Field<16, 1>;    // RD_POISON_INTR_0
            using RD_POISON_INTR_1 = Field<17, 1>;    // RD_POISON_INTR_1
        };

        // DDRCTRL port status register
        struct DDRCTRL_PSTAT : public RegisterReadOnly<0x5a0033fc> {
            using RD_PORT_BUSY_0 = Field<0, 1>;    // RD_PORT_BUSY_0
            using RD_PORT_BUSY_1 = Field<1, 1>;    // RD_PORT_BUSY_1
            using WR_PORT_BUSY_0 = Field<16, 1>;    // WR_PORT_BUSY_0
            using WR_PORT_BUSY_1 = Field<17, 1>;    // WR_PORT_BUSY_1
        };

        // DDRCTRL port common configuration register
        struct DDRCTRL_PCCFG : public Register<0x5a003400> {
            using GO2CRITICAL_EN = Field<0, 1>;    // GO2CRITICAL_EN
            using PAGEMATCH_LIMIT = Field<4, 1>;    // PAGEMATCH_LIMIT
            using BL_EXP_MODE = Field<8, 1>;    // BL_EXP_MODE
        };

        // DDRCTRL port 0 configuration read register
        struct DDRCTRL_PCFGR_0 : public Register<0x5a003404> {
            using RD_PORT_PRIORITY = Field<0, 10>;    // RD_PORT_PRIORITY
            using RD_PORT_AGING_EN = Field<12, 1>;    // RD_PORT_AGING_EN
            using RD_PORT_URGENT_EN = Field<13, 1>;    // RD_PORT_URGENT_EN
            using RD_PORT_PAGEMATCH_EN = Field<14, 1>;    // RD_PORT_PAGEMATCH_EN
            using RDWR_ORDERED_EN = Field<16, 1>;    // RDWR_ORDERED_EN
        };

        // DDRCTRL port 0 configuration write register
        struct DDRCTRL_PCFGW_0 : public Register<0x5a003408> {
            using WR_PORT_PRIORITY = Field<0, 10>;    // WR_PORT_PRIORITY
            using WR_PORT_AGING_EN = Field<12, 1>;    // WR_PORT_AGING_EN
            using WR_PORT_URGENT_EN = Field<13, 1>;    // WR_PORT_URGENT_EN
            using WR_PORT_PAGEMATCH_EN = Field<14, 1>;    // WR_PORT_PAGEMATCH_EN
        };

        // DDRCTRL port 0 control register
        struct DDRCTRL_PCTRL_0 : public Register<0x5a003490> {
            using PORT_EN = Field<0, 1>;    // PORT_EN
        };

        // DDRCTRL port 0 read Q0S configuration register 0
        struct DDRCTRL_PCFGQOS0_0 : public Register<0x5a003494> {
            using RQOS_MAP_LEVEL1 = Field<0, 4>;    // RQOS_MAP_LEVEL1
            using RQOS_MAP_LEVEL2 = Field<8, 4>;    // RQOS_MAP_LEVEL2
            using RQOS_MAP_REGION0 = Field<16, 2>;    // RQOS_MAP_REGION0
            using RQOS_MAP_REGION1 = Field<20, 2>;    // RQOS_MAP_REGION1
            using RQOS_MAP_REGION2 = Field<24, 2>;    // RQOS_MAP_REGION2
        };

        // DDRCTRL port 0 read Q0S configuration register 1
        struct DDRCTRL_PCFGQOS1_0 : public Register<0x5a003498> {
            using RQOS_MAP_TIMEOUTB = Field<0, 11>;    // RQOS_MAP_TIMEOUTB
            using RQOS_MAP_TIMEOUTR = Field<16, 11>;    // RQOS_MAP_TIMEOUTR
        };

        // DDRCTRL port 0 write Q0S configuration register 0
        struct DDRCTRL_PCFGWQOS0_0 : public Register<0x5a00349c> {
            using WQOS_MAP_LEVEL1 = Field<0, 4>;    // WQOS_MAP_LEVEL1
            using WQOS_MAP_LEVEL2 = Field<8, 4>;    // WQOS_MAP_LEVEL2
            using WQOS_MAP_REGION0 = Field<16, 2>;    // WQOS_MAP_REGION0
            using WQOS_MAP_REGION1 = Field<20, 2>;    // WQOS_MAP_REGION1
            using WQOS_MAP_REGION2 = Field<24, 2>;    // WQOS_MAP_REGION2
        };

        // DDRCTRL port 0 write Q0S configuration register 1
        struct DDRCTRL_PCFGWQOS1_0 : public Register<0x5a0034a0> {
            using WQOS_MAP_TIMEOUT1 = Field<0, 11>;    // WQOS_MAP_TIMEOUT1
            using WQOS_MAP_TIMEOUT2 = Field<16, 11>;    // WQOS_MAP_TIMEOUT2
        };

        // DDRCTRL port 1 configuration read register
        struct DDRCTRL_PCFGR_1 : public Register<0x5a0034b4> {
            using RD_PORT_PRIORITY = Field<0, 10>;    // RD_PORT_PRIORITY
            using RD_PORT_AGING_EN = Field<12, 1>;    // RD_PORT_AGING_EN
            using RD_PORT_URGENT_EN = Field<13, 1>;    // RD_PORT_URGENT_EN
            using RD_PORT_PAGEMATCH_EN = Field<14, 1>;    // RD_PORT_PAGEMATCH_EN
            using RDWR_ORDERED_EN = Field<16, 1>;    // RDWR_ORDERED_EN
        };

        // DDRCTRL port 1 configuration write register
        struct DDRCTRL_PCFGW_1 : public Register<0x5a0034b8> {
            using WR_PORT_PRIORITY = Field<0, 10>;    // WR_PORT_PRIORITY
            using WR_PORT_AGING_EN = Field<12, 1>;    // WR_PORT_AGING_EN
            using WR_PORT_URGENT_EN = Field<13, 1>;    // WR_PORT_URGENT_EN
            using WR_PORT_PAGEMATCH_EN = Field<14, 1>;    // WR_PORT_PAGEMATCH_EN
        };

        // DDRCTRL port 1 control register
        struct DDRCTRL_PCTRL_1 : public Register<0x5a003540> {
            using PORT_EN = Field<0, 1>;    // PORT_EN
        };

        // DDRCTRL port 1 read Q0S configuration register 0
        struct DDRCTRL_PCFGQOS0_1 : public Register<0x5a003544> {
            using RQOS_MAP_LEVEL1 = Field<0, 4>;    // RQOS_MAP_LEVEL1
            using RQOS_MAP_LEVEL2 = Field<8, 4>;    // RQOS_MAP_LEVEL2
            using RQOS_MAP_REGION0 = Field<16, 2>;    // RQOS_MAP_REGION0
            using RQOS_MAP_REGION1 = Field<20, 2>;    // RQOS_MAP_REGION1
            using RQOS_MAP_REGION2 = Field<24, 2>;    // RQOS_MAP_REGION2
        };

        // DDRCTRL port 1 read Q0S configuration register 1
        struct DDRCTRL_PCFGQOS1_1 : public Register<0x5a003548> {
            using RQOS_MAP_TIMEOUTB = Field<0, 11>;    // RQOS_MAP_TIMEOUTB
            using RQOS_MAP_TIMEOUTR = Field<16, 11>;    // RQOS_MAP_TIMEOUTR
        };

        // DDRCTRL port 1 write Q0S configuration register 0
        struct DDRCTRL_PCFGWQOS0_1 : public Register<0x5a00354c> {
            using WQOS_MAP_LEVEL1 = Field<0, 4>;    // WQOS_MAP_LEVEL1
            using WQOS_MAP_LEVEL2 = Field<8, 4>;    // WQOS_MAP_LEVEL2
            using WQOS_MAP_REGION0 = Field<16, 2>;    // WQOS_MAP_REGION0
            using WQOS_MAP_REGION1 = Field<20, 2>;    // WQOS_MAP_REGION1
            using WQOS_MAP_REGION2 = Field<24, 2>;    // WQOS_MAP_REGION2
        };

        // DDRCTRL port 1 write Q0S configuration register 1
        struct DDRCTRL_PCFGWQOS1_1 : public Register<0x5a003550> {
            using WQOS_MAP_TIMEOUT1 = Field<0, 11>;    // WQOS_MAP_TIMEOUT1
            using WQOS_MAP_TIMEOUT2 = Field<16, 11>;    // WQOS_MAP_TIMEOUT2
        };

    };

    // DDRPERFM
    struct DDRPERFM {
        // Write-only register. A read request returns all zeros.
        struct DDRPERFM_CTL : public RegisterWriteOnly<0x5a007000> {
            using START = Field<0, 1>;    // START
            using STOP = Field<1, 1>;    // STOP
        };

        // DDRPERFM configurationl register
        struct DDRPERFM_CFG : public Register<0x5a007004> {
            using EN = Field<0, 4>;    // EN
            using SEL = Field<16, 2>;    // SEL
        };

        // DDRPERFM status register
        struct DDRPERFM_STATUS : public RegisterReadOnly<0x5a007008> {
            using COVF = Field<0, 4>;    // COVF
            using BUSY = Field<16, 1>;    // BUSY
            using TOVF = Field<31, 1>;    // TOVF
        };

        // Write-only register. A read request returns all zeros
        struct DDRPERFM_CCR : public RegisterWriteOnly<0x5a00700c> {
            using CCLR = Field<0, 4>;    // CCLR
            using TCLR = Field<31, 1>;    // TCLR
        };

        // DDRPERFM interrupt enable register
        struct DDRPERFM_IER : public Register<0x5a007010> {
            using OVFIE = Field<0, 1>;    // OVFIE
        };

        // DDRPERFM interrupt status register
        struct DDRPERFM_ISR : public RegisterReadOnly<0x5a007014> {
            using OVFF = Field<0, 1>;    // OVFF
        };

        // Write-only register. A read request returns all zeros
        struct DDRPERFM_ICR : public RegisterWriteOnly<0x5a007018> {
            using OVF = Field<0, 1>;    // OVF
        };

        // DDRPERFM time counter register
        struct DDRPERFM_TCNT : public RegisterReadOnly<0x5a007020> {
            using CNT = Field<0, 32>;    // CNT
        };

        // DDRPERFM event counter 0 register
        struct DDRPERFM_CNT0 : public RegisterReadOnly<0x5a007060> {
            using CNT = Field<0, 32>;    // CNT
        };

        // DDRPERFM event counter 1 register
        struct DDRPERFM_CNT1 : public RegisterReadOnly<0x5a007068> {
            using CNT = Field<0, 32>;    // CNT
        };

        // DDRPERFM event counter 2 register
        struct DDRPERFM_CNT2 : public RegisterReadOnly<0x5a007070> {
            using CNT = Field<0, 32>;    // CNT
        };

        // DDRPERFM event counter 3 register
        struct DDRPERFM_CNT3 : public RegisterReadOnly<0x5a007078> {
            using CNT = Field<0, 32>;    // CNT
        };

        // DDRPERFM hardware configuration register
        struct DDRPERFM_HWCFG : public RegisterReadOnly<0x5a0073f0> {
            using NCNT = Field<0, 4>;    // NCNT
        };

        // DDRPERFM version register
        struct DDRPERFM_VER : public RegisterReadOnly<0x5a0073f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // DDRPERFM ID register
        struct DDRPERFM_ID : public RegisterReadOnly<0x5a0073f8> {
            using ID = Field<0, 32>;    // ID
        };

        // DDRPERFM magic ID register
        struct DDRPERFM_SID : public RegisterReadOnly<0x5a0073fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // DDRPHYC
    struct DDRPHYC {
        // DDRPHYC revision ID register
        struct DDRPHYC_RIDR : public RegisterReadOnly<0x5a004000> {
            using PUBMNR = Field<0, 4>;    // PUBMNR
            using PUBMDR = Field<4, 4>;    // PUBMDR
            using PUBMJR = Field<8, 4>;    // PUBMJR
            using PHYMNR = Field<12, 4>;    // PHYMNR
            using PHYMDR = Field<16, 4>;    // PHYMDR
            using PHYMJR = Field<20, 4>;    // PHYMJR
            using UDRID = Field<24, 8>;    // UDRID
        };

        // DDRPHYC PHY initialization register
        struct DDRPHYC_PIR : public RegisterWriteOnly<0x5a004004> {
            using INIT = Field<0, 1>;    // INIT
            using DLLSRST = Field<1, 1>;    // DLLSRST
            using DLLLOCK = Field<2, 1>;    // DLLLOCK
            using ZCAL = Field<3, 1>;    // ZCAL
            using ITMSRST = Field<4, 1>;    // ITMSRST
            using DRAMRST = Field<5, 1>;    // DRAMRST
            using DRAMINIT = Field<6, 1>;    // DRAMINIT
            using QSTRN = Field<7, 1>;    // QSTRN
            using RVTRN = Field<8, 1>;    // RVTRN
            using ICPC = Field<16, 1>;    // ICPC
            using DLLBYP = Field<17, 1>;    // DLLBYP
            using CTLDINIT = Field<18, 1>;    // CTLDINIT
            using CLRSR = Field<28, 1>;    // CLRSR
            using LOCKBYP = Field<29, 1>;    // LOCKBYP
            using ZCALBYP = Field<30, 1>;    // ZCALBYP
            using INITBYP = Field<31, 1>;    // INITBYP
        };

        // DDRPHYC PHY global control register
        struct DDRPHYC_PGCR : public Register<0x5a004008> {
            using ITMDMD = Field<0, 1>;    // ITMDMD
            using DQSCFG = Field<1, 1>;    // DQSCFG
            using DFTCMP = Field<2, 1>;    // DFTCMP
            using DFTLMT = Field<3, 2>;    // DFTLMT
            using DTOSEL = Field<5, 4>;    // DTOSEL
            using CKEN = Field<9, 3>;    // CKEN
            using CKDV = Field<12, 2>;    // CKDV
            using CKINV = Field<14, 1>;    // CKINV
            using IOLB = Field<15, 1>;    // IOLB
            using IODDRM = Field<16, 2>;    // IODDRM
            using RANKEN = Field<18, 4>;    // RANKEN
            using ZKSEL = Field<22, 2>;    // ZKSEL
            using PDDISDX = Field<24, 1>;    // PDDISDX
            using RFSHDT = Field<25, 4>;    // RFSHDT
            using LBDQSS = Field<29, 1>;    // LBDQSS
            using LBGDQS = Field<30, 1>;    // LBGDQS
            using LBMODE = Field<31, 1>;    // LBMODE
        };

        // DDRPHYC PHY global status register
        struct DDRPHYC_PGSR : public RegisterReadOnly<0x5a00400c> {
            using IDONE = Field<0, 1>;    // IDONE
            using DLDONE = Field<1, 1>;    // DLDONE
            using ZCDDONE = Field<2, 1>;    // ZCDDONE
            using DIDONE = Field<3, 1>;    // DIDONE
            using DTDONE = Field<4, 1>;    // DTDONE
            using DTERR = Field<5, 1>;    // DTERR
            using DTIERR = Field<6, 1>;    // DTIERR
            using DFTERR = Field<7, 1>;    // DFTERR
            using RVERR = Field<8, 1>;    // RVERR
            using RVEIRR = Field<9, 1>;    // RVEIRR
            using TQ = Field<31, 1>;    // TQ
        };

        // DDRPHYC DDR global control register
        struct DDRPHYC_DLLGCR : public Register<0x5a004010> {
            using DRES = Field<0, 2>;    // DRES
            using IPUMP = Field<2, 3>;    // IPUMP
            using TESTEN = Field<5, 1>;    // TESTEN
            using DTC = Field<6, 3>;    // DTC
            using ATC = Field<9, 2>;    // ATC
            using TESTSW = Field<11, 1>;    // TESTSW
            using MBIAS = Field<12, 8>;    // MBIAS
            using SBIAS2_0 = Field<20, 3>;    // SBIAS2_0
            using BPS200 = Field<23, 1>;    // BPS200
            using SBIAS5_3 = Field<24, 3>;    // SBIAS5_3
            using FDTRMSL = Field<27, 2>;    // FDTRMSL
            using LOCKDET = Field<29, 1>;    // LOCKDET
            using DLLRSVD2 = Field<30, 2>;    // DLLRSVD2
        };

        // DDRPHYC AC DLL control register
        struct DDRPHYC_ACDLLCR : public Register<0x5a004014> {
            using MFBDLY = Field<6, 3>;    // MFBDLY
            using MFWDLY = Field<9, 3>;    // MFWDLY
            using ATESTEN = Field<18, 1>;    // ATESTEN
            using DLLSRST = Field<30, 1>;    // DLLSRST
            using DLLDIS = Field<31, 1>;    // DLLDIS
        };

        // DDRPHYC PT register 0
        struct DDRPHYC_PTR0 : public Register<0x5a004018> {
            using TDLLSRST = Field<0, 6>;    // TDLLSRST
            using TDLLLOCK = Field<6, 12>;    // TDLLLOCK
            using TITMSRST = Field<18, 4>;    // TITMSRST
        };

        // DDRPHYC PT register 1
        struct DDRPHYC_PTR1 : public Register<0x5a00401c> {
            using TDINIT0 = Field<0, 19>;    // TDINIT0
            using TDINIT1 = Field<19, 8>;    // TDINIT1
        };

        // DDRPHYC PT register 2
        struct DDRPHYC_PTR2 : public Register<0x5a004020> {
            using TDINIT2 = Field<0, 17>;    // TDINIT2
            using TDINIT3 = Field<17, 10>;    // TDINIT3
        };

        // DDRPHYC ACIOC register
        struct DDRPHYC_ACIOCR : public Register<0x5a004024> {
            using ACIOM = Field<0, 1>;    // ACIOM
            using ACOE = Field<1, 1>;    // ACOE
            using ACODT = Field<2, 1>;    // ACODT
            using ACPDD = Field<3, 1>;    // ACPDD
            using ACPDR = Field<4, 1>;    // ACPDR
            using CKODT = Field<5, 3>;    // CKODT
            using CKPDD = Field<8, 3>;    // CKPDD
            using CKPDR = Field<11, 3>;    // CKPDR
            using RANKODT = Field<14, 1>;    // RANKODT
            using CSPDD = Field<18, 1>;    // CSPDD
            using RANKPDR = Field<22, 1>;    // RANKPDR
            using RSTODT = Field<26, 1>;    // RSTODT
            using RSTPDD = Field<27, 1>;    // RSTPDD
            using RSTPDR = Field<28, 1>;    // RSTPDR
            using RSTIOM = Field<29, 1>;    // RSTIOM
            using ACSR = Field<30, 2>;    // ACSR
        };

        // DDRPHYC DXCC register
        struct DDRPHYC_DXCCR : public Register<0x5a004028> {
            using DXODT = Field<0, 1>;    // DXODT
            using DXIOM = Field<1, 1>;    // DXIOM
            using DXPDD = Field<2, 1>;    // DXPDD
            using DXPDR = Field<3, 1>;    // DXPDR
            using DQSRES = Field<4, 4>;    // DQSRES
            using DQSNRES = Field<8, 4>;    // DQSNRES
            using DQSNRST = Field<14, 1>;    // DQSNRST
            using RVSEL = Field<15, 1>;    // RVSEL
            using AWDT = Field<16, 1>;    // AWDT
        };

        // DDRPHYC DSGC register
        struct DDRPHYC_DSGCR : public Register<0x5a00402c> {
            using PUREN = Field<0, 1>;    // PUREN
            using BDISEN = Field<1, 1>;    // BDISEN
            using ZUEN = Field<2, 1>;    // ZUEN
            using LPIOPD = Field<3, 1>;    // LPIOPD
            using LPDLLPD = Field<4, 1>;    // LPDLLPD
            using DQSGX = Field<5, 3>;    // DQSGX
            using DQSGE = Field<8, 3>;    // DQSGE
            using NOBUB = Field<11, 1>;    // NOBUB
            using FXDLAT = Field<12, 1>;    // FXDLAT
            using CKEPDD = Field<16, 1>;    // CKEPDD
            using ODTPDD = Field<20, 1>;    // ODTPDD
            using NL2PD = Field<24, 1>;    // NL2PD
            using NL2OE = Field<25, 1>;    // NL2OE
            using TPDPD = Field<26, 1>;    // TPDPD
            using TPDOE = Field<27, 1>;    // TPDOE
            using CKOE = Field<28, 1>;    // CKOE
            using ODTOE = Field<29, 1>;    // ODTOE
            using RSTOE = Field<30, 1>;    // RSTOE
            using CKEOE = Field<31, 1>;    // CKEOE
        };

        // DDRPHYC DC register
        struct DDRPHYC_DCR : public Register<0x5a004030> {
            using DDRMD = Field<0, 3>;    // DDRMD
            using DDR8BNK = Field<3, 1>;    // DDR8BNK
            using PDQ = Field<4, 3>;    // PDQ
            using MPRDQ = Field<7, 1>;    // MPRDQ
            using DDRTYPE = Field<8, 2>;    // DDRTYPE
            using NOSRA = Field<27, 1>;    // NOSRA
            using DDR2T = Field<28, 1>;    // DDR2T
            using UDIMM = Field<29, 1>;    // UDIMM
            using RDIMM = Field<30, 1>;    // RDIMM
            using TPD = Field<31, 1>;    // TPD
        };

        // DDRPHYC DTP register 0
        struct DDRPHYC_DTPR0 : public Register<0x5a004034> {
            using TMRD = Field<0, 2>;    // TMRD
            using TRTP = Field<2, 3>;    // TRTP
            using TWTR = Field<5, 3>;    // TWTR
            using TRP = Field<8, 4>;    // TRP
            using TRCD = Field<12, 4>;    // TRCD
            using TRAS = Field<16, 5>;    // TRAS
            using TRRD = Field<21, 4>;    // TRRD
            using TRC = Field<25, 6>;    // TRC
            using TCCD = Field<31, 1>;    // TCCD
        };

        // DDRPHYC DTP register 1
        struct DDRPHYC_DTPR1 : public Register<0x5a004038> {
            using TAOND = Field<0, 2>;    // TAOND
            using TRTW = Field<2, 1>;    // TRTW
            using TFAW = Field<3, 6>;    // TFAW
            using TMOD = Field<9, 2>;    // TMOD
            using TRTODT = Field<11, 1>;    // TRTODT
            using TRFC = Field<16, 8>;    // TRFC
            using TDQSCKMIN = Field<24, 3>;    // TDQSCKMIN
            using TDQSCKMAX = Field<27, 3>;    // TDQSCKMAX
        };

        // DDRPHYC DTP register 2
        struct DDRPHYC_DTPR2 : public Register<0x5a00403c> {
            using TXS = Field<0, 10>;    // TXS
            using TXP = Field<10, 5>;    // TXP
            using TCKE = Field<15, 4>;    // TCKE
            using TDLLK = Field<19, 10>;    // TDLLK
        };

        // DDRPHYC MR0 register for DDR3
        struct DDRPHYC_DDR3_MR0 : public Register<0x5a004040> {
            using BL = Field<0, 2>;    // BL
            using CL0 = Field<2, 1>;    // CL0
            using BT = Field<3, 1>;    // BT
            using CL = Field<4, 3>;    // CL
            using TM = Field<7, 1>;    // TM
            using DR = Field<8, 1>;    // DR
            using WR = Field<9, 3>;    // WR
            using PD = Field<12, 1>;    // PD
            using RSVD = Field<13, 3>;    // RSVD
        };

        // DDRPHYC MR1 register for DDR3
        struct DDRPHYC_DDR3_MR1 : public Register<0x5a004044> {
            using DE = Field<0, 1>;    // DE
            using DIC0 = Field<1, 1>;    // DIC0
            using RTT0 = Field<2, 1>;    // RTT0
            using AL = Field<3, 2>;    // AL
            using DIC1 = Field<5, 1>;    // DIC1
            using RTT1 = Field<6, 1>;    // RTT1
            using LEVEL = Field<7, 1>;    // LEVEL
            using RTT2 = Field<9, 1>;    // RTT2
            using TDQS = Field<11, 1>;    // TDQS
            using QOFF = Field<12, 1>;    // QOFF
        };

        // DDRPHYC MR2 register for DDR3
        struct DDRPHYC_DDR3_MR2 : public Register<0x5a004048> {
            using PASR = Field<0, 3>;    // PASR
            using CWL = Field<3, 3>;    // CWL
            using ASR = Field<6, 1>;    // ASR
            using SRT = Field<7, 1>;    // SRT
            using RTTWR = Field<9, 2>;    // RTTWR
        };

        // DDRPHYC MR3 register for DDR3
        struct DDRPHYC_DDR3_MR3 : public Register<0x5a00404c> {
            using MPRLOC = Field<0, 2>;    // MPRLOC
            using MPR = Field<2, 1>;    // MPR
        };

        // DDRPHYC ODTC register
        struct DDRPHYC_ODTCR : public Register<0x5a004050> {
            using RDODT = Field<0, 1>;    // RDODT
            using WRODT = Field<16, 1>;    // WRODT
        };

        // DDRPHYC DTA register
        struct DDRPHYC_DTAR : public Register<0x5a004054> {
            using DTCOL = Field<0, 12>;    // DTCOL
            using DTROW = Field<12, 16>;    // DTROW
            using DTBANK = Field<28, 3>;    // DTBANK
            using DTMPR = Field<31, 1>;    // DTMPR
        };

        // DDRPHYC DTD register 0
        struct DDRPHYC_DTDR0 : public Register<0x5a004058> {
            using DTBYTE0 = Field<0, 8>;    // DTBYTE0
            using DTBYTE1 = Field<8, 8>;    // DTBYTE1
            using DTBYTE2 = Field<16, 8>;    // DTBYTE2
            using DTBYTE3 = Field<24, 8>;    // DTBYTE3
        };

        // DDRPHYC DTD register 1
        struct DDRPHYC_DTDR1 : public Register<0x5a00405c> {
            using DTBYTE4 = Field<0, 8>;    // DTBYTE4
            using DTBYTE5 = Field<8, 8>;    // DTBYTE5
            using DTBYTE6 = Field<16, 8>;    // DTBYTE6
            using DTBYTE7 = Field<24, 8>;    // DTBYTE7
        };

        // DDRPHYC general purpose register 0
        struct DDRPHYC_GPR0 : public Register<0x5a004178> {
            using GPR0 = Field<0, 32>;    // GPR0
        };

        // DDRPHYC general purpose register 1
        struct DDRPHYC_GPR1 : public Register<0x5a00417c> {
            using GPR1 = Field<0, 32>;    // GPR1
        };

        // DDRPHYC ZQ0C register 0
        struct DDRPHYC_ZQ0CR0 : public Register<0x5a004180> {
            using ZDATA = Field<0, 20>;    // ZDATA
            using ZDEN = Field<28, 1>;    // ZDEN
            using ZCALBYP = Field<29, 1>;    // ZCALBYP
            using ZCAL = Field<30, 1>;    // ZCAL
            using ZQPD = Field<31, 1>;    // ZQPD
        };

        // DDRPHYC ZQ0CR1 register
        struct DDRPHYC_ZQ0CR1 : public Register<0x5a004184> {
            using ZPROG = Field<0, 8>;    // ZPROG
        };

        // DDRPHYC ZQ0S register 0
        struct DDRPHYC_ZQ0SR0 : public RegisterReadOnly<0x5a004188> {
            using ZCTRL = Field<0, 20>;    // ZCTRL
            using ZERR = Field<30, 1>;    // ZERR
            using ZDONE = Field<31, 1>;    // ZDONE
        };

        // DDRPHYC ZQ0S register 1
        struct DDRPHYC_ZQ0SR1 : public RegisterReadOnly<0x5a00418c> {
            using ZPD = Field<0, 2>;    // ZPD
            using ZPU = Field<2, 2>;    // ZPU
            using OPD = Field<4, 2>;    // OPD
            using OPU = Field<6, 2>;    // OPU
        };

        // DDRPHYC byte lane 0 GC register
        struct DDRPHYC_DX0GCR : public Register<0x5a0041c0> {
            using DXEN = Field<0, 1>;    // DXEN
            using DQSODT = Field<1, 1>;    // DQSODT
            using DQODT = Field<2, 1>;    // DQODT
            using DXIOM = Field<3, 1>;    // DXIOM
            using DXPDD = Field<4, 1>;    // DXPDD
            using DXPDR = Field<5, 1>;    // DXPDR
            using DQSRPD = Field<6, 1>;    // DQSRPD
            using DSEN = Field<7, 2>;    // DSEN
            using DQSRTT = Field<9, 1>;    // DQSRTT
            using DQRTT = Field<10, 1>;    // DQRTT
            using RTTOH = Field<11, 2>;    // RTTOH
            using RTTOAL = Field<13, 1>;    // RTTOAL
            using R0RVSL = Field<14, 3>;    // R0RVSL
        };

        // DDRPHYC byte lane 0 GS register 0
        struct DDRPHYC_DX0GSR0 : public RegisterReadOnly<0x5a0041c4> {
            using DTDONE = Field<0, 1>;    // DTDONE
            using DTERR = Field<4, 1>;    // DTERR
            using DTIERR = Field<8, 1>;    // DTIERR
            using DTPASS = Field<13, 3>;    // DTPASS
        };

        // DDRPHYC byte lane 0 GS register 1
        struct DDRPHYC_DX0GSR1 : public RegisterReadOnly<0x5a0041c8> {
            using DFTERR = Field<0, 1>;    // DFTERR
            using DQSDFT = Field<4, 2>;    // DQSDFT
            using RVERR = Field<12, 1>;    // RVERR
            using RVIERR = Field<16, 1>;    // RVIERR
            using RVPASS = Field<20, 3>;    // RVPASS
        };

        // DDRPHYC byte lane 0 DLLC register
        struct DDRPHYC_DX0DLLCR : public Register<0x5a0041cc> {
            using SFBDLY = Field<0, 3>;    // SFBDLY
            using SFWDLY = Field<3, 3>;    // SFWDLY
            using MFBDLY = Field<6, 3>;    // MFBDLY
            using MFWDLY = Field<9, 3>;    // MFWDLY
            using SSTART = Field<12, 2>;    // SSTART
            using SDPHASE = Field<14, 4>;    // SDPHASE
            using ATESTEN = Field<18, 1>;    // ATESTEN
            using SDLBMODE = Field<19, 1>;    // SDLBMODE
            using DLLSRST = Field<30, 1>;    // DLLSRST
            using DLLDIS = Field<31, 1>;    // DLLDIS
        };

        // DDRPHYC byte lane 0 DQT register
        struct DDRPHYC_DX0DQTR : public Register<0x5a0041d0> {
            using DQDLY0 = Field<0, 4>;    // DQDLY0
            using DQDLY1 = Field<4, 4>;    // DQDLY1
            using DQDLY2 = Field<8, 4>;    // DQDLY2
            using DQDLY3 = Field<12, 4>;    // DQDLY3
            using DQDLY4 = Field<16, 4>;    // DQDLY4
            using DQDLY5 = Field<20, 4>;    // DQDLY5
            using DQDLY6 = Field<24, 4>;    // DQDLY6
            using DQDLY7 = Field<28, 4>;    // DQDLY7
        };

        // DDRPHYC byte lane 0 DQST register
        struct DDRPHYC_DX0DQSTR : public Register<0x5a0041d4> {
            using R0DGSL = Field<0, 3>;    // R0DGSL
            using R0DGPS = Field<12, 2>;    // R0DGPS
            using DQSDLY = Field<20, 3>;    // DQSDLY
            using DQSNDLY = Field<23, 3>;    // DQSNDLY
            using DMDLY = Field<26, 4>;    // DMDLY
        };

        // DDRPHYC byte lane 1 GC register
        struct DDRPHYC_DX1GCR : public Register<0x5a004200> {
            using DXEN = Field<0, 1>;    // DXEN
            using DQSODT = Field<1, 1>;    // DQSODT
            using DQODT = Field<2, 1>;    // DQODT
            using DXIOM = Field<3, 1>;    // DXIOM
            using DXPDD = Field<4, 1>;    // DXPDD
            using DXPDR = Field<5, 1>;    // DXPDR
            using DQSRPD = Field<6, 1>;    // DQSRPD
            using DSEN = Field<7, 2>;    // DSEN
            using DQSRTT = Field<9, 1>;    // DQSRTT
            using DQRTT = Field<10, 1>;    // DQRTT
            using RTTOH = Field<11, 2>;    // RTTOH
            using RTTOAL = Field<13, 1>;    // RTTOAL
            using R0RVSL = Field<14, 3>;    // R0RVSL
        };

        // DDRPHYC byte lane 1 GS register 0
        struct DDRPHYC_DX1GSR0 : public RegisterReadOnly<0x5a004204> {
            using DTDONE = Field<0, 1>;    // DTDONE
            using DTERR = Field<4, 1>;    // DTERR
            using DTIERR = Field<8, 1>;    // DTIERR
            using DTPASS = Field<13, 3>;    // DTPASS
        };

        // DDRPHYC byte lane 1 GS register 1
        struct DDRPHYC_DX1GSR1 : public RegisterReadOnly<0x5a004208> {
            using DFTERR = Field<0, 1>;    // DFTERR
            using DQSDFT = Field<4, 2>;    // DQSDFT
            using RVERR = Field<12, 1>;    // RVERR
            using RVIERR = Field<16, 1>;    // RVIERR
            using RVPASS = Field<20, 3>;    // RVPASS
        };

        // DDRPHYC byte lane 1 DLLC register
        struct DDRPHYC_DX1DLLCR : public Register<0x5a00420c> {
            using SFBDLY = Field<0, 3>;    // SFBDLY
            using SFWDLY = Field<3, 3>;    // SFWDLY
            using MFBDLY = Field<6, 3>;    // MFBDLY
            using MFWDLY = Field<9, 3>;    // MFWDLY
            using SSTART = Field<12, 2>;    // SSTART
            using SDPHASE = Field<14, 4>;    // SDPHASE
            using ATESTEN = Field<18, 1>;    // ATESTEN
            using SDLBMODE = Field<19, 1>;    // SDLBMODE
            using DLLSRST = Field<30, 1>;    // DLLSRST
            using DLLDIS = Field<31, 1>;    // DLLDIS
        };

        // DDRPHYC byte lane 1 DQT register
        struct DDRPHYC_DX1DQTR : public Register<0x5a004210> {
            using DQDLY0 = Field<0, 4>;    // DQDLY0
            using DQDLY1 = Field<4, 4>;    // DQDLY1
            using DQDLY2 = Field<8, 4>;    // DQDLY2
            using DQDLY3 = Field<12, 4>;    // DQDLY3
            using DQDLY4 = Field<16, 4>;    // DQDLY4
            using DQDLY5 = Field<20, 4>;    // DQDLY5
            using DQDLY6 = Field<24, 4>;    // DQDLY6
            using DQDLY7 = Field<28, 4>;    // DQDLY7
        };

        // DDRPHYC byte lane 1 DQST register
        struct DDRPHYC_DX1DQSTR : public Register<0x5a004214> {
            using R0DGSL = Field<0, 3>;    // R0DGSL
            using R0DGPS = Field<12, 2>;    // R0DGPS
            using DQSDLY = Field<20, 3>;    // DQSDLY
            using DQSNDLY = Field<23, 3>;    // DQSNDLY
            using DMDLY = Field<26, 4>;    // DMDLY
        };

        // DDRPHYC byte lane 2 GC register
        struct DDRPHYC_DX2GCR : public Register<0x5a004240> {
            using DXEN = Field<0, 1>;    // DXEN
            using DQSODT = Field<1, 1>;    // DQSODT
            using DQODT = Field<2, 1>;    // DQODT
            using DXIOM = Field<3, 1>;    // DXIOM
            using DXPDD = Field<4, 1>;    // DXPDD
            using DXPDR = Field<5, 1>;    // DXPDR
            using DQSRPD = Field<6, 1>;    // DQSRPD
            using DSEN = Field<7, 2>;    // DSEN
            using DQSRTT = Field<9, 1>;    // DQSRTT
            using DQRTT = Field<10, 1>;    // DQRTT
            using RTTOH = Field<11, 2>;    // RTTOH
            using RTTOAL = Field<13, 1>;    // RTTOAL
            using R0RVSL = Field<14, 3>;    // R0RVSL
        };

        // DDRPHYC byte lane 2 GS register 0
        struct DDRPHYC_DX2GSR0 : public RegisterReadOnly<0x5a004244> {
            using DTDONE = Field<0, 1>;    // DTDONE
            using DTERR = Field<4, 1>;    // DTERR
            using DTIERR = Field<8, 1>;    // DTIERR
            using DTPASS = Field<13, 3>;    // DTPASS
        };

        // DDRPHYC byte lane 2 GS register 1
        struct DDRPHYC_DX2GSR1 : public RegisterReadOnly<0x5a004248> {
            using DFTERR = Field<0, 1>;    // DFTERR
            using DQSDFT = Field<4, 2>;    // DQSDFT
            using RVERR = Field<12, 1>;    // RVERR
            using RVIERR = Field<16, 1>;    // RVIERR
            using RVPASS = Field<20, 3>;    // RVPASS
        };

        // DDRPHYC byte lane 2 DLLC register
        struct DDRPHYC_DX2DLLCR : public Register<0x5a00424c> {
            using SFBDLY = Field<0, 3>;    // SFBDLY
            using SFWDLY = Field<3, 3>;    // SFWDLY
            using MFBDLY = Field<6, 3>;    // MFBDLY
            using MFWDLY = Field<9, 3>;    // MFWDLY
            using SSTART = Field<12, 2>;    // SSTART
            using SDPHASE = Field<14, 4>;    // SDPHASE
            using ATESTEN = Field<18, 1>;    // ATESTEN
            using SDLBMODE = Field<19, 1>;    // SDLBMODE
            using DLLSRST = Field<30, 1>;    // DLLSRST
            using DLLDIS = Field<31, 1>;    // DLLDIS
        };

        // DDRPHYC byte lane 2 DQT register
        struct DDRPHYC_DX2DQTR : public Register<0x5a004250> {
            using DQDLY0 = Field<0, 4>;    // DQDLY0
            using DQDLY1 = Field<4, 4>;    // DQDLY1
            using DQDLY2 = Field<8, 4>;    // DQDLY2
            using DQDLY3 = Field<12, 4>;    // DQDLY3
            using DQDLY4 = Field<16, 4>;    // DQDLY4
            using DQDLY5 = Field<20, 4>;    // DQDLY5
            using DQDLY6 = Field<24, 4>;    // DQDLY6
            using DQDLY7 = Field<28, 4>;    // DQDLY7
        };

        // DDRPHYC byte lane 2 DQST register
        struct DDRPHYC_DX2DQSTR : public Register<0x5a004254> {
            using R0DGSL = Field<0, 3>;    // R0DGSL
            using R0DGPS = Field<12, 2>;    // R0DGPS
            using DQSDLY = Field<20, 3>;    // DQSDLY
            using DQSNDLY = Field<23, 3>;    // DQSNDLY
            using DMDLY = Field<26, 4>;    // DMDLY
        };

        // DDRPHYC byte lane 3 GC register
        struct DDRPHYC_DX3GCR : public Register<0x5a004280> {
            using DXEN = Field<0, 1>;    // DXEN
            using DQSODT = Field<1, 1>;    // DQSODT
            using DQODT = Field<2, 1>;    // DQODT
            using DXIOM = Field<3, 1>;    // DXIOM
            using DXPDD = Field<4, 1>;    // DXPDD
            using DXPDR = Field<5, 1>;    // DXPDR
            using DQSRPD = Field<6, 1>;    // DQSRPD
            using DSEN = Field<7, 2>;    // DSEN
            using DQSRTT = Field<9, 1>;    // DQSRTT
            using DQRTT = Field<10, 1>;    // DQRTT
            using RTTOH = Field<11, 2>;    // RTTOH
            using RTTOAL = Field<13, 1>;    // RTTOAL
            using R0RVSL = Field<14, 3>;    // R0RVSL
        };

        // DDRPHYC byte lane 3 GS register 0
        struct DDRPHYC_DX3GSR0 : public RegisterReadOnly<0x5a004284> {
            using DTDONE = Field<0, 1>;    // DTDONE
            using DTERR = Field<4, 1>;    // DTERR
            using DTIERR = Field<8, 1>;    // DTIERR
            using DTPASS = Field<13, 3>;    // DTPASS
        };

        // DDRPHYC byte lane 3 GS register 1
        struct DDRPHYC_DX3GSR1 : public RegisterReadOnly<0x5a004288> {
            using DFTERR = Field<0, 1>;    // DFTERR
            using DQSDFT = Field<4, 2>;    // DQSDFT
            using RVERR = Field<12, 1>;    // RVERR
            using RVIERR = Field<16, 1>;    // RVIERR
            using RVPASS = Field<20, 3>;    // RVPASS
        };

        // DDRPHYC byte lane 3 DLLC register
        struct DDRPHYC_DX3DLLCR : public Register<0x5a00428c> {
            using SFBDLY = Field<0, 3>;    // SFBDLY
            using SFWDLY = Field<3, 3>;    // SFWDLY
            using MFBDLY = Field<6, 3>;    // MFBDLY
            using MFWDLY = Field<9, 3>;    // MFWDLY
            using SSTART = Field<12, 2>;    // SSTART
            using SDPHASE = Field<14, 4>;    // SDPHASE
            using ATESTEN = Field<18, 1>;    // ATESTEN
            using SDLBMODE = Field<19, 1>;    // SDLBMODE
            using DLLSRST = Field<30, 1>;    // DLLSRST
            using DLLDIS = Field<31, 1>;    // DLLDIS
        };

        // DDRPHYC byte lane 3 DQT register
        struct DDRPHYC_DX3DQTR : public Register<0x5a004290> {
            using DQDLY0 = Field<0, 4>;    // DQDLY0
            using DQDLY1 = Field<4, 4>;    // DQDLY1
            using DQDLY2 = Field<8, 4>;    // DQDLY2
            using DQDLY3 = Field<12, 4>;    // DQDLY3
            using DQDLY4 = Field<16, 4>;    // DQDLY4
            using DQDLY5 = Field<20, 4>;    // DQDLY5
            using DQDLY6 = Field<24, 4>;    // DQDLY6
            using DQDLY7 = Field<28, 4>;    // DQDLY7
        };

        // DDRPHYC byte lane 3 DQST register
        struct DDRPHYC_DX3DQSTR : public Register<0x5a004294> {
            using R0DGSL = Field<0, 3>;    // R0DGSL
            using R0DGPS = Field<12, 2>;    // R0DGPS
            using DQSDLY = Field<20, 3>;    // DQSDLY
            using DQSNDLY = Field<23, 3>;    // DQSNDLY
            using DMDLY = Field<26, 4>;    // DMDLY
        };

    };

    // DLYBSD1
    struct DLYBSD1 {
        // DLYB control register
        struct DLYB_CR : public Register<0x58006000> {
            using DEN = Field<0, 1>;    // DEN
            using SEN = Field<1, 1>;    // SEN
        };

        // DLYB configuration register
        struct DLYB_CFGR : public Register<0x58006004> {
            using SEL = Field<0, 4>;    // SEL
            using UNIT = Field<8, 7>;    // UNIT
            using LNG = Field<16, 12>;    // LNG
            using LNGF = Field<31, 1>;    // LNGF
        };

        // DLYB IP version register
        struct DLYB_VERR : public RegisterReadOnly<0x580063f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // DLYB IP identification register
        struct DLYB_IPIDR : public RegisterReadOnly<0x580063f8> {
            using ID = Field<0, 32>;    // ID
        };

        // DLYB size ID register
        struct DLYB_SIDR : public RegisterReadOnly<0x580063fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // DLYBSD1
    struct DLYBSD2 {
        // DLYB control register
        struct DLYB_CR : public Register<0x58008000> {
            using DEN = Field<0, 1>;    // DEN
            using SEN = Field<1, 1>;    // SEN
        };

        // DLYB configuration register
        struct DLYB_CFGR : public Register<0x58008004> {
            using SEL = Field<0, 4>;    // SEL
            using UNIT = Field<8, 7>;    // UNIT
            using LNG = Field<16, 12>;    // LNG
            using LNGF = Field<31, 1>;    // LNGF
        };

        // DLYB IP version register
        struct DLYB_VERR : public RegisterReadOnly<0x580083f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // DLYB IP identification register
        struct DLYB_IPIDR : public RegisterReadOnly<0x580083f8> {
            using ID = Field<0, 32>;    // ID
        };

        // DLYB size ID register
        struct DLYB_SIDR : public RegisterReadOnly<0x580083fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // DLYBSD1
    struct DLYBSD3 {
        // DLYB control register
        struct DLYB_CR : public Register<0x48005000> {
            using DEN = Field<0, 1>;    // DEN
            using SEN = Field<1, 1>;    // SEN
        };

        // DLYB configuration register
        struct DLYB_CFGR : public Register<0x48005004> {
            using SEL = Field<0, 4>;    // SEL
            using UNIT = Field<8, 7>;    // UNIT
            using LNG = Field<16, 12>;    // LNG
            using LNGF = Field<31, 1>;    // LNGF
        };

        // DLYB IP version register
        struct DLYB_VERR : public RegisterReadOnly<0x480053f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // DLYB IP identification register
        struct DLYB_IPIDR : public RegisterReadOnly<0x480053f8> {
            using ID = Field<0, 32>;    // ID
        };

        // DLYB size ID register
        struct DLYB_SIDR : public RegisterReadOnly<0x480053fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // DFSDM1
    struct DFSDM1 {
        // This register specifies the parameters used by channel y.
        struct DFSDM_CH0CFGR1 : public Register<0x4400d000> {
            using SITP = Field<0, 2>;    // SITP
            using SPICKSEL = Field<2, 2>;    // SPICKSEL
            using SCDEN = Field<5, 1>;    // SCDEN
            using CKABEN = Field<6, 1>;    // CKABEN
            using CHEN = Field<7, 1>;    // CHEN
            using CHINSEL = Field<8, 1>;    // CHINSEL
            using DATMPX = Field<12, 2>;    // DATMPX
            using DATPACK = Field<14, 2>;    // DATPACK
            using CKOUTDIV = Field<16, 8>;    // CKOUTDIV
            using CKOUTSRC = Field<30, 1>;    // CKOUTSRC
            using DFSDMEN = Field<31, 1>;    // DFSDMEN
        };

        // This register specifies the parameters used by channel y.
        struct DFSDM_CH0CFGR2 : public Register<0x4400d004> {
            using DTRBS = Field<3, 5>;    // DTRBS
            using OFFSET = Field<8, 24>;    // OFFSET
        };

        // Short-circuit detector and analog watchdog settings for channel y.
        struct DFSDM_CH0AWSCDR : public Register<0x4400d008> {
            using SCDT = Field<0, 8>;    // SCDT
            using BKSCD = Field<12, 4>;    // BKSCD
            using AWFOSR = Field<16, 5>;    // AWFOSR
            using AWFORD = Field<22, 2>;    // AWFORD
        };

        // This register contains the data resulting from the analog watchdog filter associated to the input channel y.
        struct DFSDM_CH0WDATR : public RegisterReadOnly<0x4400d00c> {
            using WDATA = Field<0, 16>;    // WDATA
        };

        // This register contains 16-bit input data to be processed by DFSDM filter module.
        struct DFSDM_CH0DATINR : public Register<0x4400d010> {
            using INDAT0 = Field<0, 16>;    // INDAT0
            using INDAT1 = Field<16, 16>;    // INDAT1
        };

        // DFSDM channel 0 delay register
        struct DFSDM_CH0DLYR : public Register<0x4400d014> {
            using PLSSKP = Field<0, 6>;    // PLSSKP
        };

        // This register specifies the parameters used by channel y.
        struct DFSDM_CH1CFGR1 : public Register<0x4400d020> {
            using SITP = Field<0, 2>;    // SITP
            using SPICKSEL = Field<2, 2>;    // SPICKSEL
            using SCDEN = Field<5, 1>;    // SCDEN
            using CKABEN = Field<6, 1>;    // CKABEN
            using CHEN = Field<7, 1>;    // CHEN
            using CHINSEL = Field<8, 1>;    // CHINSEL
            using DATMPX = Field<12, 2>;    // DATMPX
            using DATPACK = Field<14, 2>;    // DATPACK
            using CKOUTDIV = Field<16, 8>;    // CKOUTDIV
            using CKOUTSRC = Field<30, 1>;    // CKOUTSRC
            using DFSDMEN = Field<31, 1>;    // DFSDMEN
        };

        // This register specifies the parameters used by channel y.
        struct DFSDM_CH1CFGR2 : public Register<0x4400d024> {
            using DTRBS = Field<3, 5>;    // DTRBS
            using OFFSET = Field<8, 24>;    // OFFSET
        };

        // Short-circuit detector and analog watchdog settings for channel y.
        struct DFSDM_CH1AWSCDR : public Register<0x4400d028> {
            using SCDT = Field<0, 8>;    // SCDT
            using BKSCD = Field<12, 4>;    // BKSCD
            using AWFOSR = Field<16, 5>;    // AWFOSR
            using AWFORD = Field<22, 2>;    // AWFORD
        };

        // This register contains the data resulting from the analog watchdog filter associated to the input channel y.
        struct DFSDM_CH1WDATR : public RegisterReadOnly<0x4400d02c> {
            using WDATA = Field<0, 16>;    // WDATA
        };

        // This register contains 16-bit input data to be processed by DFSDM filter module.
        struct DFSDM_CH1DATINR : public Register<0x4400d030> {
            using INDAT0 = Field<0, 16>;    // INDAT0
            using INDAT1 = Field<16, 16>;    // INDAT1
        };

        // DFSDM channel 1 delay register
        struct DFSDM_CH1DLYR : public Register<0x4400d034> {
            using PLSSKP = Field<0, 6>;    // PLSSKP
        };

        // This register specifies the parameters used by channel y.
        struct DFSDM_CH2CFGR1 : public Register<0x4400d040> {
            using SITP = Field<0, 2>;    // SITP
            using SPICKSEL = Field<2, 2>;    // SPICKSEL
            using SCDEN = Field<5, 1>;    // SCDEN
            using CKABEN = Field<6, 1>;    // CKABEN
            using CHEN = Field<7, 1>;    // CHEN
            using CHINSEL = Field<8, 1>;    // CHINSEL
            using DATMPX = Field<12, 2>;    // DATMPX
            using DATPACK = Field<14, 2>;    // DATPACK
            using CKOUTDIV = Field<16, 8>;    // CKOUTDIV
            using CKOUTSRC = Field<30, 1>;    // CKOUTSRC
            using DFSDMEN = Field<31, 1>;    // DFSDMEN
        };

        // This register specifies the parameters used by channel y.
        struct DFSDM_CH2CFGR2 : public Register<0x4400d044> {
            using DTRBS = Field<3, 5>;    // DTRBS
            using OFFSET = Field<8, 24>;    // OFFSET
        };

        // Short-circuit detector and analog watchdog settings for channel y.
        struct DFSDM_CH2AWSCDR : public Register<0x4400d048> {
            using SCDT = Field<0, 8>;    // SCDT
            using BKSCD = Field<12, 4>;    // BKSCD
            using AWFOSR = Field<16, 5>;    // AWFOSR
            using AWFORD = Field<22, 2>;    // AWFORD
        };

        // This register contains the data resulting from the analog watchdog filter associated to the input channel y.
        struct DFSDM_CH2WDATR : public RegisterReadOnly<0x4400d04c> {
            using WDATA = Field<0, 16>;    // WDATA
        };

        // This register contains 16-bit input data to be processed by DFSDM filter module.
        struct DFSDM_CH2DATINR : public Register<0x4400d050> {
            using INDAT0 = Field<0, 16>;    // INDAT0
            using INDAT1 = Field<16, 16>;    // INDAT1
        };

        // DFSDM channel 2 delay register
        struct DFSDM_CH2DLYR : public Register<0x4400d054> {
            using PLSSKP = Field<0, 6>;    // PLSSKP
        };

        // This register specifies the parameters used by channel y.
        struct DFSDM_CH3CFGR1 : public Register<0x4400d060> {
            using SITP = Field<0, 2>;    // SITP
            using SPICKSEL = Field<2, 2>;    // SPICKSEL
            using SCDEN = Field<5, 1>;    // SCDEN
            using CKABEN = Field<6, 1>;    // CKABEN
            using CHEN = Field<7, 1>;    // CHEN
            using CHINSEL = Field<8, 1>;    // CHINSEL
            using DATMPX = Field<12, 2>;    // DATMPX
            using DATPACK = Field<14, 2>;    // DATPACK
            using CKOUTDIV = Field<16, 8>;    // CKOUTDIV
            using CKOUTSRC = Field<30, 1>;    // CKOUTSRC
            using DFSDMEN = Field<31, 1>;    // DFSDMEN
        };

        // This register specifies the parameters used by channel y.
        struct DFSDM_CH3CFGR2 : public Register<0x4400d064> {
            using DTRBS = Field<3, 5>;    // DTRBS
            using OFFSET = Field<8, 24>;    // OFFSET
        };

        // Short-circuit detector and analog watchdog settings for channel y.
        struct DFSDM_CH3AWSCDR : public Register<0x4400d068> {
            using SCDT = Field<0, 8>;    // SCDT
            using BKSCD = Field<12, 4>;    // BKSCD
            using AWFOSR = Field<16, 5>;    // AWFOSR
            using AWFORD = Field<22, 2>;    // AWFORD
        };

        // This register contains the data resulting from the analog watchdog filter associated to the input channel y.
        struct DFSDM_CH3WDATR : public RegisterReadOnly<0x4400d06c> {
            using WDATA = Field<0, 16>;    // WDATA
        };

        // This register contains 16-bit input data to be processed by DFSDM filter module.
        struct DFSDM_CH3DATINR : public Register<0x4400d070> {
            using INDAT0 = Field<0, 16>;    // INDAT0
            using INDAT1 = Field<16, 16>;    // INDAT1
        };

        // DFSDM channel 3 delay register
        struct DFSDM_CH3DLYR : public Register<0x4400d074> {
            using PLSSKP = Field<0, 6>;    // PLSSKP
        };

        // This register specifies the parameters used by channel y.
        struct DFSDM_CH4CFGR1 : public Register<0x4400d080> {
            using SITP = Field<0, 2>;    // SITP
            using SPICKSEL = Field<2, 2>;    // SPICKSEL
            using SCDEN = Field<5, 1>;    // SCDEN
            using CKABEN = Field<6, 1>;    // CKABEN
            using CHEN = Field<7, 1>;    // CHEN
            using CHINSEL = Field<8, 1>;    // CHINSEL
            using DATMPX = Field<12, 2>;    // DATMPX
            using DATPACK = Field<14, 2>;    // DATPACK
            using CKOUTDIV = Field<16, 8>;    // CKOUTDIV
            using CKOUTSRC = Field<30, 1>;    // CKOUTSRC
            using DFSDMEN = Field<31, 1>;    // DFSDMEN
        };

        // This register specifies the parameters used by channel y.
        struct DFSDM_CH4CFGR2 : public Register<0x4400d084> {
            using DTRBS = Field<3, 5>;    // DTRBS
            using OFFSET = Field<8, 24>;    // OFFSET
        };

        // Short-circuit detector and analog watchdog settings for channel y.
        struct DFSDM_CH4AWSCDR : public Register<0x4400d088> {
            using SCDT = Field<0, 8>;    // SCDT
            using BKSCD = Field<12, 4>;    // BKSCD
            using AWFOSR = Field<16, 5>;    // AWFOSR
            using AWFORD = Field<22, 2>;    // AWFORD
        };

        // This register contains the data resulting from the analog watchdog filter associated to the input channel y.
        struct DFSDM_CH4WDATR : public RegisterReadOnly<0x4400d08c> {
            using WDATA = Field<0, 16>;    // WDATA
        };

        // This register contains 16-bit input data to be processed by DFSDM filter module.
        struct DFSDM_CH4DATINR : public Register<0x4400d090> {
            using INDAT0 = Field<0, 16>;    // INDAT0
            using INDAT1 = Field<16, 16>;    // INDAT1
        };

        // DFSDM channel 4 delay register
        struct DFSDM_CH4DLYR : public Register<0x4400d094> {
            using PLSSKP = Field<0, 6>;    // PLSSKP
        };

        // This register specifies the parameters used by channel y.
        struct DFSDM_CH5CFGR1 : public Register<0x4400d0a0> {
            using SITP = Field<0, 2>;    // SITP
            using SPICKSEL = Field<2, 2>;    // SPICKSEL
            using SCDEN = Field<5, 1>;    // SCDEN
            using CKABEN = Field<6, 1>;    // CKABEN
            using CHEN = Field<7, 1>;    // CHEN
            using CHINSEL = Field<8, 1>;    // CHINSEL
            using DATMPX = Field<12, 2>;    // DATMPX
            using DATPACK = Field<14, 2>;    // DATPACK
            using CKOUTDIV = Field<16, 8>;    // CKOUTDIV
            using CKOUTSRC = Field<30, 1>;    // CKOUTSRC
            using DFSDMEN = Field<31, 1>;    // DFSDMEN
        };

        // This register specifies the parameters used by channel y.
        struct DFSDM_CH5CFGR2 : public Register<0x4400d0a4> {
            using DTRBS = Field<3, 5>;    // DTRBS
            using OFFSET = Field<8, 24>;    // OFFSET
        };

        // Short-circuit detector and analog watchdog settings for channel y.
        struct DFSDM_CH5AWSCDR : public Register<0x4400d0a8> {
            using SCDT = Field<0, 8>;    // SCDT
            using BKSCD = Field<12, 4>;    // BKSCD
            using AWFOSR = Field<16, 5>;    // AWFOSR
            using AWFORD = Field<22, 2>;    // AWFORD
        };

        // This register contains the data resulting from the analog watchdog filter associated to the input channel y.
        struct DFSDM_CH5WDATR : public RegisterReadOnly<0x4400d0ac> {
            using WDATA = Field<0, 16>;    // WDATA
        };

        // This register contains 16-bit input data to be processed by DFSDM filter module.
        struct DFSDM_CH5DATINR : public Register<0x4400d0b0> {
            using INDAT0 = Field<0, 16>;    // INDAT0
            using INDAT1 = Field<16, 16>;    // INDAT1
        };

        // DFSDM channel 5 delay register
        struct DFSDM_CH5DLYR : public Register<0x4400d0b4> {
            using PLSSKP = Field<0, 6>;    // PLSSKP
        };

        // This register specifies the parameters used by channel y.
        struct DFSDM_CH6CFGR1 : public Register<0x4400d0c0> {
            using SITP = Field<0, 2>;    // SITP
            using SPICKSEL = Field<2, 2>;    // SPICKSEL
            using SCDEN = Field<5, 1>;    // SCDEN
            using CKABEN = Field<6, 1>;    // CKABEN
            using CHEN = Field<7, 1>;    // CHEN
            using CHINSEL = Field<8, 1>;    // CHINSEL
            using DATMPX = Field<12, 2>;    // DATMPX
            using DATPACK = Field<14, 2>;    // DATPACK
            using CKOUTDIV = Field<16, 8>;    // CKOUTDIV
            using CKOUTSRC = Field<30, 1>;    // CKOUTSRC
            using DFSDMEN = Field<31, 1>;    // DFSDMEN
        };

        // This register specifies the parameters used by channel y.
        struct DFSDM_CH6CFGR2 : public Register<0x4400d0c4> {
            using DTRBS = Field<3, 5>;    // DTRBS
            using OFFSET = Field<8, 24>;    // OFFSET
        };

        // Short-circuit detector and analog watchdog settings for channel y.
        struct DFSDM_CH6AWSCDR : public Register<0x4400d0c8> {
            using SCDT = Field<0, 8>;    // SCDT
            using BKSCD = Field<12, 4>;    // BKSCD
            using AWFOSR = Field<16, 5>;    // AWFOSR
            using AWFORD = Field<22, 2>;    // AWFORD
        };

        // This register contains the data resulting from the analog watchdog filter associated to the input channel y.
        struct DFSDM_CH6WDATR : public RegisterReadOnly<0x4400d0cc> {
            using WDATA = Field<0, 16>;    // WDATA
        };

        // This register contains 16-bit input data to be processed by DFSDM filter module.
        struct DFSDM_CH6DATINR : public Register<0x4400d0d0> {
            using INDAT0 = Field<0, 16>;    // INDAT0
            using INDAT1 = Field<16, 16>;    // INDAT1
        };

        // DFSDM channel 6 delay register
        struct DFSDM_CH6DLYR : public Register<0x4400d0d4> {
            using PLSSKP = Field<0, 6>;    // PLSSKP
        };

        // This register specifies the parameters used by channel y.
        struct DFSDM_CH7CFGR1 : public Register<0x4400d0e0> {
            using SITP = Field<0, 2>;    // SITP
            using SPICKSEL = Field<2, 2>;    // SPICKSEL
            using SCDEN = Field<5, 1>;    // SCDEN
            using CKABEN = Field<6, 1>;    // CKABEN
            using CHEN = Field<7, 1>;    // CHEN
            using CHINSEL = Field<8, 1>;    // CHINSEL
            using DATMPX = Field<12, 2>;    // DATMPX
            using DATPACK = Field<14, 2>;    // DATPACK
            using CKOUTDIV = Field<16, 8>;    // CKOUTDIV
            using CKOUTSRC = Field<30, 1>;    // CKOUTSRC
            using DFSDMEN = Field<31, 1>;    // DFSDMEN
        };

        // This register specifies the parameters used by channel y.
        struct DFSDM_CH7CFGR2 : public Register<0x4400d0e4> {
            using DTRBS = Field<3, 5>;    // DTRBS
            using OFFSET = Field<8, 24>;    // OFFSET
        };

        // Short-circuit detector and analog watchdog settings for channel y.
        struct DFSDM_CH7AWSCDR : public Register<0x4400d0e8> {
            using SCDT = Field<0, 8>;    // SCDT
            using BKSCD = Field<12, 4>;    // BKSCD
            using AWFOSR = Field<16, 5>;    // AWFOSR
            using AWFORD = Field<22, 2>;    // AWFORD
        };

        // This register contains the data resulting from the analog watchdog filter associated to the input channel y.
        struct DFSDM_CH7WDATR : public RegisterReadOnly<0x4400d0ec> {
            using WDATA = Field<0, 16>;    // WDATA
        };

        // This register contains 16-bit input data to be processed by DFSDM filter module.
        struct DFSDM_CH7DATINR : public Register<0x4400d0f0> {
            using INDAT0 = Field<0, 16>;    // INDAT0
            using INDAT1 = Field<16, 16>;    // INDAT1
        };

        // DFSDM channel 7 delay register
        struct DFSDM_CH7DLYR : public Register<0x4400d0f4> {
            using PLSSKP = Field<0, 6>;    // PLSSKP
        };

        // DFSDM filter 0 control register 1
        struct DFSDM_FLT0CR1 : public Register<0x4400d100> {
            using DFEN = Field<0, 1>;    // DFEN
            using JSWSTART = Field<1, 1>;    // JSWSTART
            using JSYNC = Field<3, 1>;    // JSYNC
            using JSCAN = Field<4, 1>;    // JSCAN
            using JDMAEN = Field<5, 1>;    // JDMAEN
            using JEXTSEL = Field<8, 5>;    // JEXTSEL
            using JEXTEN = Field<13, 2>;    // JEXTEN
            using RSWSTART = Field<17, 1>;    // RSWSTART
            using RCONT = Field<18, 1>;    // RCONT
            using RSYNC = Field<19, 1>;    // RSYNC
            using RDMAEN = Field<21, 1>;    // RDMAEN
            using RCH = Field<24, 3>;    // RCH
            using FAST = Field<29, 1>;    // FAST
            using AWFSEL = Field<30, 1>;    // AWFSEL
        };

        // DFSDM filter 0 control register 2
        struct DFSDM_FLT0CR2 : public Register<0x4400d104> {
            using JEOCIE = Field<0, 1>;    // JEOCIE
            using REOCIE = Field<1, 1>;    // REOCIE
            using JOVRIE = Field<2, 1>;    // JOVRIE
            using ROVRIE = Field<3, 1>;    // ROVRIE
            using AWDIE = Field<4, 1>;    // AWDIE
            using SCDIE = Field<5, 1>;    // SCDIE
            using CKABIE = Field<6, 1>;    // CKABIE
            using EXCH = Field<8, 8>;    // EXCH
            using AWDCH = Field<16, 8>;    // AWDCH
        };

        // DFSDM filter 0 interrupt and status register
        struct DFSDM_FLT0ISR : public RegisterReadOnly<0x4400d108> {
            using JEOCF = Field<0, 1>;    // JEOCF
            using REOCF = Field<1, 1>;    // REOCF
            using JOVRF = Field<2, 1>;    // JOVRF
            using ROVRF = Field<3, 1>;    // ROVRF
            using AWDF = Field<4, 1>;    // AWDF
            using JCIP = Field<13, 1>;    // JCIP
            using RCIP = Field<14, 1>;    // RCIP
            using CKABF = Field<16, 8>;    // CKABF
            using SCDF = Field<24, 8>;    // SCDF
        };

        // DFSDM filter 0 interrupt flag clear register
        struct DFSDM_FLT0ICR : public Register<0x4400d10c> {
            using CLRJOVRF = Field<2, 1>;    // CLRJOVRF
            using CLRROVRF = Field<3, 1>;    // CLRROVRF
            using CLRCKABF = Field<16, 8>;    // CLRCKABF
            using CLRSCDF = Field<24, 8>;    // CLRSCDF
        };

        // DFSDM filter 0 injected channel group selection register
        struct DFSDM_FLT0JCHGR : public Register<0x4400d110> {
            using JCHG = Field<0, 8>;    // JCHG
        };

        // DFSDM filter 0 control register
        struct DFSDM_FLT0FCR : public Register<0x4400d114> {
            using IOSR = Field<0, 8>;    // IOSR
            using FOSR = Field<16, 10>;    // FOSR
            using FORD = Field<29, 3>;    // FORD
        };

        // DFSDM filter 0 data register for injected group
        struct DFSDM_FLT0JDATAR : public RegisterReadOnly<0x4400d118> {
            using JDATACH = Field<0, 3>;    // JDATACH
            using JDATA = Field<8, 24>;    // JDATA
        };

        // DFSDM filter 0 data register for the regular channel
        struct DFSDM_FLT0RDATAR : public RegisterReadOnly<0x4400d11c> {
            using RDATACH = Field<0, 3>;    // RDATACH
            using RPEND = Field<4, 1>;    // RPEND
            using RDATA = Field<8, 24>;    // RDATA
        };

        // DFSDM filter 0 analog watchdog high threshold register
        struct DFSDM_FLT0AWHTR : public Register<0x4400d120> {
            using BKAWH = Field<0, 4>;    // BKAWH
            using AWHT = Field<8, 24>;    // AWHT
        };

        // DFSDM filter 0 analog watchdog low threshold register
        struct DFSDM_FLT0AWLTR : public Register<0x4400d124> {
            using BKAWL = Field<0, 4>;    // BKAWL
            using AWLT = Field<8, 24>;    // AWLT
        };

        // DFSDM filter 0 analog watchdog status register
        struct DFSDM_FLT0AWSR : public RegisterReadOnly<0x4400d128> {
            using AWLTF = Field<0, 8>;    // AWLTF
            using AWHTF = Field<8, 8>;    // AWHTF
        };

        // DFSDM filter 0 analog watchdog clear flag register
        struct DFSDM_FLT0AWCFR : public Register<0x4400d12c> {
            using CLRAWLTF = Field<0, 8>;    // CLRAWLTF
            using CLRAWHTF = Field<8, 8>;    // CLRAWHTF
        };

        // DFSDM filter 0 extremes detector maximum register
        struct DFSDM_FLT0EXMAX : public RegisterReadOnly<0x4400d130> {
            using EXMAXCH = Field<0, 3>;    // EXMAXCH
            using EXMAX = Field<8, 24>;    // EXMAX
        };

        // DFSDM filter 0 extremes detector minimum register
        struct DFSDM_FLT0EXMIN : public Register<0x4400d134> {
            using EXMINCH = Field<0, 3>;    // EXMINCH
            using EXMIN = Field<8, 24>;    // EXMIN
        };

        // DFSDM filter 0 conversion timer register
        struct DFSDM_FLT0CNVTIMR : public RegisterReadOnly<0x4400d138> {
            using CNVCNT = Field<4, 28>;    // CNVCNT
        };

        // DFSDM filter 1 control register 1
        struct DFSDM_FLT1CR1 : public Register<0x4400d180> {
            using DFEN = Field<0, 1>;    // DFEN
            using JSWSTART = Field<1, 1>;    // JSWSTART
            using JSYNC = Field<3, 1>;    // JSYNC
            using JSCAN = Field<4, 1>;    // JSCAN
            using JDMAEN = Field<5, 1>;    // JDMAEN
            using JEXTSEL = Field<8, 5>;    // JEXTSEL
            using JEXTEN = Field<13, 2>;    // JEXTEN
            using RSWSTART = Field<17, 1>;    // RSWSTART
            using RCONT = Field<18, 1>;    // RCONT
            using RSYNC = Field<19, 1>;    // RSYNC
            using RDMAEN = Field<21, 1>;    // RDMAEN
            using RCH = Field<24, 3>;    // RCH
            using FAST = Field<29, 1>;    // FAST
            using AWFSEL = Field<30, 1>;    // AWFSEL
        };

        // DFSDM filter 1 control register 2
        struct DFSDM_FLT1CR2 : public Register<0x4400d184> {
            using JEOCIE = Field<0, 1>;    // JEOCIE
            using REOCIE = Field<1, 1>;    // REOCIE
            using JOVRIE = Field<2, 1>;    // JOVRIE
            using ROVRIE = Field<3, 1>;    // ROVRIE
            using AWDIE = Field<4, 1>;    // AWDIE
            using SCDIE = Field<5, 1>;    // SCDIE
            using CKABIE = Field<6, 1>;    // CKABIE
            using EXCH = Field<8, 8>;    // EXCH
            using AWDCH = Field<16, 8>;    // AWDCH
        };

        // DFSDM filter 1 interrupt and status register
        struct DFSDM_FLT1ISR : public RegisterReadOnly<0x4400d188> {
            using JEOCF = Field<0, 1>;    // JEOCF
            using REOCF = Field<1, 1>;    // REOCF
            using JOVRF = Field<2, 1>;    // JOVRF
            using ROVRF = Field<3, 1>;    // ROVRF
            using AWDF = Field<4, 1>;    // AWDF
            using JCIP = Field<13, 1>;    // JCIP
            using RCIP = Field<14, 1>;    // RCIP
            using CKABF = Field<16, 8>;    // CKABF
            using SCDF = Field<24, 8>;    // SCDF
        };

        // DFSDM filter 1 interrupt flag clear register
        struct DFSDM_FLT1ICR : public Register<0x4400d18c> {
            using CLRJOVRF = Field<2, 1>;    // CLRJOVRF
            using CLRROVRF = Field<3, 1>;    // CLRROVRF
            using CLRCKABF = Field<16, 8>;    // CLRCKABF
            using CLRSCDF = Field<24, 8>;    // CLRSCDF
        };

        // DFSDM filter 1 injected channel group selection register
        struct DFSDM_FLT1JCHGR : public Register<0x4400d190> {
            using JCHG = Field<0, 8>;    // JCHG
        };

        // DFSDM filter 1 control register
        struct DFSDM_FLT1FCR : public Register<0x4400d194> {
            using IOSR = Field<0, 8>;    // IOSR
            using FOSR = Field<16, 10>;    // FOSR
            using FORD = Field<29, 3>;    // FORD
        };

        // DFSDM filter 1 data register for injected group
        struct DFSDM_FLT1JDATAR : public RegisterReadOnly<0x4400d198> {
            using JDATACH = Field<0, 3>;    // JDATACH
            using JDATA = Field<8, 24>;    // JDATA
        };

        // DFSDM filter 1 data register for the regular channel
        struct DFSDM_FLT1RDATAR : public RegisterReadOnly<0x4400d19c> {
            using RDATACH = Field<0, 3>;    // RDATACH
            using RPEND = Field<4, 1>;    // RPEND
            using RDATA = Field<8, 24>;    // RDATA
        };

        // DFSDM filter 1 analog watchdog high threshold register
        struct DFSDM_FLT1AWHTR : public Register<0x4400d1a0> {
            using BKAWH = Field<0, 4>;    // BKAWH
            using AWHT = Field<8, 24>;    // AWHT
        };

        // DFSDM filter 1 analog watchdog low threshold register
        struct DFSDM_FLT1AWLTR : public Register<0x4400d1a4> {
            using BKAWL = Field<0, 4>;    // BKAWL
            using AWLT = Field<8, 24>;    // AWLT
        };

        // DFSDM filter 1 analog watchdog status register
        struct DFSDM_FLT1AWSR : public RegisterReadOnly<0x4400d1a8> {
            using AWLTF = Field<0, 8>;    // AWLTF
            using AWHTF = Field<8, 8>;    // AWHTF
        };

        // DFSDM filter 1 analog watchdog clear flag register
        struct DFSDM_FLT1AWCFR : public Register<0x4400d1ac> {
            using CLRAWLTF = Field<0, 8>;    // CLRAWLTF
            using CLRAWHTF = Field<8, 8>;    // CLRAWHTF
        };

        // DFSDM filter 1 extremes detector maximum register
        struct DFSDM_FLT1EXMAX : public RegisterReadOnly<0x4400d1b0> {
            using EXMAXCH = Field<0, 3>;    // EXMAXCH
            using EXMAX = Field<8, 24>;    // EXMAX
        };

        // DFSDM filter 1 extremes detector minimum register
        struct DFSDM_FLT1EXMIN : public Register<0x4400d1b4> {
            using EXMINCH = Field<0, 3>;    // EXMINCH
            using EXMIN = Field<8, 24>;    // EXMIN
        };

        // DFSDM filter 1 conversion timer register
        struct DFSDM_FLT1CNVTIMR : public RegisterReadOnly<0x4400d1b8> {
            using CNVCNT = Field<4, 28>;    // CNVCNT
        };

        // DFSDM filter 2 control register 1
        struct DFSDM_FLT2CR1 : public Register<0x4400d200> {
            using DFEN = Field<0, 1>;    // DFEN
            using JSWSTART = Field<1, 1>;    // JSWSTART
            using JSYNC = Field<3, 1>;    // JSYNC
            using JSCAN = Field<4, 1>;    // JSCAN
            using JDMAEN = Field<5, 1>;    // JDMAEN
            using JEXTSEL = Field<8, 5>;    // JEXTSEL
            using JEXTEN = Field<13, 2>;    // JEXTEN
            using RSWSTART = Field<17, 1>;    // RSWSTART
            using RCONT = Field<18, 1>;    // RCONT
            using RSYNC = Field<19, 1>;    // RSYNC
            using RDMAEN = Field<21, 1>;    // RDMAEN
            using RCH = Field<24, 3>;    // RCH
            using FAST = Field<29, 1>;    // FAST
            using AWFSEL = Field<30, 1>;    // AWFSEL
        };

        // DFSDM filter 2 control register 2
        struct DFSDM_FLT2CR2 : public Register<0x4400d204> {
            using JEOCIE = Field<0, 1>;    // JEOCIE
            using REOCIE = Field<1, 1>;    // REOCIE
            using JOVRIE = Field<2, 1>;    // JOVRIE
            using ROVRIE = Field<3, 1>;    // ROVRIE
            using AWDIE = Field<4, 1>;    // AWDIE
            using SCDIE = Field<5, 1>;    // SCDIE
            using CKABIE = Field<6, 1>;    // CKABIE
            using EXCH = Field<8, 8>;    // EXCH
            using AWDCH = Field<16, 8>;    // AWDCH
        };

        // DFSDM filter 2 interrupt and status register
        struct DFSDM_FLT2ISR : public RegisterReadOnly<0x4400d208> {
            using JEOCF = Field<0, 1>;    // JEOCF
            using REOCF = Field<1, 1>;    // REOCF
            using JOVRF = Field<2, 1>;    // JOVRF
            using ROVRF = Field<3, 1>;    // ROVRF
            using AWDF = Field<4, 1>;    // AWDF
            using JCIP = Field<13, 1>;    // JCIP
            using RCIP = Field<14, 1>;    // RCIP
            using CKABF = Field<16, 8>;    // CKABF
            using SCDF = Field<24, 8>;    // SCDF
        };

        // DFSDM filter 2 interrupt flag clear register
        struct DFSDM_FLT2ICR : public Register<0x4400d20c> {
            using CLRJOVRF = Field<2, 1>;    // CLRJOVRF
            using CLRROVRF = Field<3, 1>;    // CLRROVRF
            using CLRCKABF = Field<16, 8>;    // CLRCKABF
            using CLRSCDF = Field<24, 8>;    // CLRSCDF
        };

        // DFSDM filter 2 injected channel group selection register
        struct DFSDM_FLT2JCHGR : public Register<0x4400d210> {
            using JCHG = Field<0, 8>;    // JCHG
        };

        // DFSDM filter 2 control register
        struct DFSDM_FLT2FCR : public Register<0x4400d214> {
            using IOSR = Field<0, 8>;    // IOSR
            using FOSR = Field<16, 10>;    // FOSR
            using FORD = Field<29, 3>;    // FORD
        };

        // DFSDM filter 2 data register for injected group
        struct DFSDM_FLT2JDATAR : public RegisterReadOnly<0x4400d218> {
            using JDATACH = Field<0, 3>;    // JDATACH
            using JDATA = Field<8, 24>;    // JDATA
        };

        // DFSDM filter 2 data register for the regular channel
        struct DFSDM_FLT2RDATAR : public RegisterReadOnly<0x4400d21c> {
            using RDATACH = Field<0, 3>;    // RDATACH
            using RPEND = Field<4, 1>;    // RPEND
            using RDATA = Field<8, 24>;    // RDATA
        };

        // DFSDM filter 2 analog watchdog high threshold register
        struct DFSDM_FLT2AWHTR : public Register<0x4400d220> {
            using BKAWH = Field<0, 4>;    // BKAWH
            using AWHT = Field<8, 24>;    // AWHT
        };

        // DFSDM filter 2 analog watchdog low threshold register
        struct DFSDM_FLT2AWLTR : public Register<0x4400d224> {
            using BKAWL = Field<0, 4>;    // BKAWL
            using AWLT = Field<8, 24>;    // AWLT
        };

        // DFSDM filter 2 analog watchdog status register
        struct DFSDM_FLT2AWSR : public RegisterReadOnly<0x4400d228> {
            using AWLTF = Field<0, 8>;    // AWLTF
            using AWHTF = Field<8, 8>;    // AWHTF
        };

        // DFSDM filter 2 analog watchdog clear flag register
        struct DFSDM_FLT2AWCFR : public Register<0x4400d22c> {
            using CLRAWLTF = Field<0, 8>;    // CLRAWLTF
            using CLRAWHTF = Field<8, 8>;    // CLRAWHTF
        };

        // DFSDM filter 2 extremes detector maximum register
        struct DFSDM_FLT2EXMAX : public RegisterReadOnly<0x4400d230> {
            using EXMAXCH = Field<0, 3>;    // EXMAXCH
            using EXMAX = Field<8, 24>;    // EXMAX
        };

        // DFSDM filter 2 extremes detector minimum register
        struct DFSDM_FLT2EXMIN : public Register<0x4400d234> {
            using EXMINCH = Field<0, 3>;    // EXMINCH
            using EXMIN = Field<8, 24>;    // EXMIN
        };

        // DFSDM filter 2 conversion timer register
        struct DFSDM_FLT2CNVTIMR : public RegisterReadOnly<0x4400d238> {
            using CNVCNT = Field<4, 28>;    // CNVCNT
        };

        // DFSDM filter 3 control register 1
        struct DFSDM_FLT3CR1 : public Register<0x4400d280> {
            using DFEN = Field<0, 1>;    // DFEN
            using JSWSTART = Field<1, 1>;    // JSWSTART
            using JSYNC = Field<3, 1>;    // JSYNC
            using JSCAN = Field<4, 1>;    // JSCAN
            using JDMAEN = Field<5, 1>;    // JDMAEN
            using JEXTSEL = Field<8, 5>;    // JEXTSEL
            using JEXTEN = Field<13, 2>;    // JEXTEN
            using RSWSTART = Field<17, 1>;    // RSWSTART
            using RCONT = Field<18, 1>;    // RCONT
            using RSYNC = Field<19, 1>;    // RSYNC
            using RDMAEN = Field<21, 1>;    // RDMAEN
            using RCH = Field<24, 3>;    // RCH
            using FAST = Field<29, 1>;    // FAST
            using AWFSEL = Field<30, 1>;    // AWFSEL
        };

        // DFSDM filter 3 control register 2
        struct DFSDM_FLT3CR2 : public Register<0x4400d284> {
            using JEOCIE = Field<0, 1>;    // JEOCIE
            using REOCIE = Field<1, 1>;    // REOCIE
            using JOVRIE = Field<2, 1>;    // JOVRIE
            using ROVRIE = Field<3, 1>;    // ROVRIE
            using AWDIE = Field<4, 1>;    // AWDIE
            using SCDIE = Field<5, 1>;    // SCDIE
            using CKABIE = Field<6, 1>;    // CKABIE
            using EXCH = Field<8, 8>;    // EXCH
            using AWDCH = Field<16, 8>;    // AWDCH
        };

        // DFSDM filter 3 interrupt and status register
        struct DFSDM_FLT3ISR : public RegisterReadOnly<0x4400d288> {
            using JEOCF = Field<0, 1>;    // JEOCF
            using REOCF = Field<1, 1>;    // REOCF
            using JOVRF = Field<2, 1>;    // JOVRF
            using ROVRF = Field<3, 1>;    // ROVRF
            using AWDF = Field<4, 1>;    // AWDF
            using JCIP = Field<13, 1>;    // JCIP
            using RCIP = Field<14, 1>;    // RCIP
            using CKABF = Field<16, 8>;    // CKABF
            using SCDF = Field<24, 8>;    // SCDF
        };

        // DFSDM filter 3 interrupt flag clear register
        struct DFSDM_FLT3ICR : public Register<0x4400d28c> {
            using CLRJOVRF = Field<2, 1>;    // CLRJOVRF
            using CLRROVRF = Field<3, 1>;    // CLRROVRF
            using CLRCKABF = Field<16, 8>;    // CLRCKABF
            using CLRSCDF = Field<24, 8>;    // CLRSCDF
        };

        // DFSDM filter 3 injected channel group selection register
        struct DFSDM_FLT3JCHGR : public Register<0x4400d290> {
            using JCHG = Field<0, 8>;    // JCHG
        };

        // DFSDM filter 3 control register
        struct DFSDM_FLT3FCR : public Register<0x4400d294> {
            using IOSR = Field<0, 8>;    // IOSR
            using FOSR = Field<16, 10>;    // FOSR
            using FORD = Field<29, 3>;    // FORD
        };

        // DFSDM filter 3 data register for injected group
        struct DFSDM_FLT3JDATAR : public RegisterReadOnly<0x4400d298> {
            using JDATACH = Field<0, 3>;    // JDATACH
            using JDATA = Field<8, 24>;    // JDATA
        };

        // DFSDM filter 3 data register for the regular channel
        struct DFSDM_FLT3RDATAR : public RegisterReadOnly<0x4400d29c> {
            using RDATACH = Field<0, 3>;    // RDATACH
            using RPEND = Field<4, 1>;    // RPEND
            using RDATA = Field<8, 24>;    // RDATA
        };

        // DFSDM filter 3 analog watchdog high threshold register
        struct DFSDM_FLT3AWHTR : public Register<0x4400d2a0> {
            using BKAWH = Field<0, 4>;    // BKAWH
            using AWHT = Field<8, 24>;    // AWHT
        };

        // DFSDM filter 3 analog watchdog low threshold register
        struct DFSDM_FLT3AWLTR : public Register<0x4400d2a4> {
            using BKAWL = Field<0, 4>;    // BKAWL
            using AWLT = Field<8, 24>;    // AWLT
        };

        // DFSDM filter 3 analog watchdog status register
        struct DFSDM_FLT3AWSR : public RegisterReadOnly<0x4400d2a8> {
            using AWLTF = Field<0, 8>;    // AWLTF
            using AWHTF = Field<8, 8>;    // AWHTF
        };

        // DFSDM filter 3 analog watchdog clear flag register
        struct DFSDM_FLT3AWCFR : public Register<0x4400d2ac> {
            using CLRAWLTF = Field<0, 8>;    // CLRAWLTF
            using CLRAWHTF = Field<8, 8>;    // CLRAWHTF
        };

        // DFSDM filter 3 extremes detector maximum register
        struct DFSDM_FLT3EXMAX : public RegisterReadOnly<0x4400d2b0> {
            using EXMAXCH = Field<0, 3>;    // EXMAXCH
            using EXMAX = Field<8, 24>;    // EXMAX
        };

        // DFSDM filter 3 extremes detector minimum register
        struct DFSDM_FLT3EXMIN : public Register<0x4400d2b4> {
            using EXMINCH = Field<0, 3>;    // EXMINCH
            using EXMIN = Field<8, 24>;    // EXMIN
        };

        // DFSDM filter 3 conversion timer register
        struct DFSDM_FLT3CNVTIMR : public RegisterReadOnly<0x4400d2b8> {
            using CNVCNT = Field<4, 28>;    // CNVCNT
        };

        // DFSDM filter 4 control register 1
        struct DFSDM_FLT4CR1 : public Register<0x4400d300> {
            using DFEN = Field<0, 1>;    // DFEN
            using JSWSTART = Field<1, 1>;    // JSWSTART
            using JSYNC = Field<3, 1>;    // JSYNC
            using JSCAN = Field<4, 1>;    // JSCAN
            using JDMAEN = Field<5, 1>;    // JDMAEN
            using JEXTSEL = Field<8, 5>;    // JEXTSEL
            using JEXTEN = Field<13, 2>;    // JEXTEN
            using RSWSTART = Field<17, 1>;    // RSWSTART
            using RCONT = Field<18, 1>;    // RCONT
            using RSYNC = Field<19, 1>;    // RSYNC
            using RDMAEN = Field<21, 1>;    // RDMAEN
            using RCH = Field<24, 3>;    // RCH
            using FAST = Field<29, 1>;    // FAST
            using AWFSEL = Field<30, 1>;    // AWFSEL
        };

        // DFSDM filter 4 control register 2
        struct DFSDM_FLT4CR2 : public Register<0x4400d304> {
            using JEOCIE = Field<0, 1>;    // JEOCIE
            using REOCIE = Field<1, 1>;    // REOCIE
            using JOVRIE = Field<2, 1>;    // JOVRIE
            using ROVRIE = Field<3, 1>;    // ROVRIE
            using AWDIE = Field<4, 1>;    // AWDIE
            using SCDIE = Field<5, 1>;    // SCDIE
            using CKABIE = Field<6, 1>;    // CKABIE
            using EXCH = Field<8, 8>;    // EXCH
            using AWDCH = Field<16, 8>;    // AWDCH
        };

        // DFSDM filter 4 interrupt and status register
        struct DFSDM_FLT4ISR : public RegisterReadOnly<0x4400d308> {
            using JEOCF = Field<0, 1>;    // JEOCF
            using REOCF = Field<1, 1>;    // REOCF
            using JOVRF = Field<2, 1>;    // JOVRF
            using ROVRF = Field<3, 1>;    // ROVRF
            using AWDF = Field<4, 1>;    // AWDF
            using JCIP = Field<13, 1>;    // JCIP
            using RCIP = Field<14, 1>;    // RCIP
            using CKABF = Field<16, 8>;    // CKABF
            using SCDF = Field<24, 8>;    // SCDF
        };

        // DFSDM filter 4 interrupt flag clear register
        struct DFSDM_FLT4ICR : public Register<0x4400d30c> {
            using CLRJOVRF = Field<2, 1>;    // CLRJOVRF
            using CLRROVRF = Field<3, 1>;    // CLRROVRF
            using CLRCKABF = Field<16, 8>;    // CLRCKABF
            using CLRSCDF = Field<24, 8>;    // CLRSCDF
        };

        // DFSDM filter 4 injected channel group selection register
        struct DFSDM_FLT4JCHGR : public Register<0x4400d310> {
            using JCHG = Field<0, 8>;    // JCHG
        };

        // DFSDM filter 4 control register
        struct DFSDM_FLT4FCR : public Register<0x4400d314> {
            using IOSR = Field<0, 8>;    // IOSR
            using FOSR = Field<16, 10>;    // FOSR
            using FORD = Field<29, 3>;    // FORD
        };

        // DFSDM filter 4 data register for injected group
        struct DFSDM_FLT4JDATAR : public RegisterReadOnly<0x4400d318> {
            using JDATACH = Field<0, 3>;    // JDATACH
            using JDATA = Field<8, 24>;    // JDATA
        };

        // DFSDM filter 4 data register for the regular channel
        struct DFSDM_FLT4RDATAR : public RegisterReadOnly<0x4400d31c> {
            using RDATACH = Field<0, 3>;    // RDATACH
            using RPEND = Field<4, 1>;    // RPEND
            using RDATA = Field<8, 24>;    // RDATA
        };

        // DFSDM filter 4 analog watchdog high threshold register
        struct DFSDM_FLT4AWHTR : public Register<0x4400d320> {
            using BKAWH = Field<0, 4>;    // BKAWH
            using AWHT = Field<8, 24>;    // AWHT
        };

        // DFSDM filter 4 analog watchdog low threshold register
        struct DFSDM_FLT4AWLTR : public Register<0x4400d324> {
            using BKAWL = Field<0, 4>;    // BKAWL
            using AWLT = Field<8, 24>;    // AWLT
        };

        // DFSDM filter 4 analog watchdog status register
        struct DFSDM_FLT4AWSR : public RegisterReadOnly<0x4400d328> {
            using AWLTF = Field<0, 8>;    // AWLTF
            using AWHTF = Field<8, 8>;    // AWHTF
        };

        // DFSDM filter 4 analog watchdog clear flag register
        struct DFSDM_FLT4AWCFR : public Register<0x4400d32c> {
            using CLRAWLTF = Field<0, 8>;    // CLRAWLTF
            using CLRAWHTF = Field<8, 8>;    // CLRAWHTF
        };

        // DFSDM filter 4 extremes detector maximum register
        struct DFSDM_FLT4EXMAX : public RegisterReadOnly<0x4400d330> {
            using EXMAXCH = Field<0, 3>;    // EXMAXCH
            using EXMAX = Field<8, 24>;    // EXMAX
        };

        // DFSDM filter 4 extremes detector minimum register
        struct DFSDM_FLT4EXMIN : public Register<0x4400d334> {
            using EXMINCH = Field<0, 3>;    // EXMINCH
            using EXMIN = Field<8, 24>;    // EXMIN
        };

        // DFSDM filter 4 conversion timer register
        struct DFSDM_FLT4CNVTIMR : public RegisterReadOnly<0x4400d338> {
            using CNVCNT = Field<4, 28>;    // CNVCNT
        };

        // DFSDM filter 5 control register 1
        struct DFSDM_FLT5CR1 : public Register<0x4400d380> {
            using DFEN = Field<0, 1>;    // DFEN
            using JSWSTART = Field<1, 1>;    // JSWSTART
            using JSYNC = Field<3, 1>;    // JSYNC
            using JSCAN = Field<4, 1>;    // JSCAN
            using JDMAEN = Field<5, 1>;    // JDMAEN
            using JEXTSEL = Field<8, 5>;    // JEXTSEL
            using JEXTEN = Field<13, 2>;    // JEXTEN
            using RSWSTART = Field<17, 1>;    // RSWSTART
            using RCONT = Field<18, 1>;    // RCONT
            using RSYNC = Field<19, 1>;    // RSYNC
            using RDMAEN = Field<21, 1>;    // RDMAEN
            using RCH = Field<24, 3>;    // RCH
            using FAST = Field<29, 1>;    // FAST
            using AWFSEL = Field<30, 1>;    // AWFSEL
        };

        // DFSDM filter 5 control register 2
        struct DFSDM_FLT5CR2 : public Register<0x4400d384> {
            using JEOCIE = Field<0, 1>;    // JEOCIE
            using REOCIE = Field<1, 1>;    // REOCIE
            using JOVRIE = Field<2, 1>;    // JOVRIE
            using ROVRIE = Field<3, 1>;    // ROVRIE
            using AWDIE = Field<4, 1>;    // AWDIE
            using SCDIE = Field<5, 1>;    // SCDIE
            using CKABIE = Field<6, 1>;    // CKABIE
            using EXCH = Field<8, 8>;    // EXCH
            using AWDCH = Field<16, 8>;    // AWDCH
        };

        // DFSDM filter 5 interrupt and status register
        struct DFSDM_FLT5ISR : public RegisterReadOnly<0x4400d388> {
            using JEOCF = Field<0, 1>;    // JEOCF
            using REOCF = Field<1, 1>;    // REOCF
            using JOVRF = Field<2, 1>;    // JOVRF
            using ROVRF = Field<3, 1>;    // ROVRF
            using AWDF = Field<4, 1>;    // AWDF
            using JCIP = Field<13, 1>;    // JCIP
            using RCIP = Field<14, 1>;    // RCIP
            using CKABF = Field<16, 8>;    // CKABF
            using SCDF = Field<24, 8>;    // SCDF
        };

        // DFSDM filter 5 interrupt flag clear register
        struct DFSDM_FLT5ICR : public Register<0x4400d38c> {
            using CLRJOVRF = Field<2, 1>;    // CLRJOVRF
            using CLRROVRF = Field<3, 1>;    // CLRROVRF
            using CLRCKABF = Field<16, 8>;    // CLRCKABF
            using CLRSCDF = Field<24, 8>;    // CLRSCDF
        };

        // DFSDM filter 5 injected channel group selection register
        struct DFSDM_FLT5JCHGR : public Register<0x4400d390> {
            using JCHG = Field<0, 8>;    // JCHG
        };

        // DFSDM filter 5 control register
        struct DFSDM_FLT5FCR : public Register<0x4400d394> {
            using IOSR = Field<0, 8>;    // IOSR
            using FOSR = Field<16, 10>;    // FOSR
            using FORD = Field<29, 3>;    // FORD
        };

        // DFSDM filter 5 data register for injected group
        struct DFSDM_FLT5JDATAR : public RegisterReadOnly<0x4400d398> {
            using JDATACH = Field<0, 3>;    // JDATACH
            using JDATA = Field<8, 24>;    // JDATA
        };

        // DFSDM filter 5 data register for the regular channel
        struct DFSDM_FLT5RDATAR : public RegisterReadOnly<0x4400d39c> {
            using RDATACH = Field<0, 3>;    // RDATACH
            using RPEND = Field<4, 1>;    // RPEND
            using RDATA = Field<8, 24>;    // RDATA
        };

        // DFSDM filter 5 analog watchdog high threshold register
        struct DFSDM_FLT5AWHTR : public Register<0x4400d3a0> {
            using BKAWH = Field<0, 4>;    // BKAWH
            using AWHT = Field<8, 24>;    // AWHT
        };

        // DFSDM filter 5 analog watchdog low threshold register
        struct DFSDM_FLT5AWLTR : public Register<0x4400d3a4> {
            using BKAWL = Field<0, 4>;    // BKAWL
            using AWLT = Field<8, 24>;    // AWLT
        };

        // DFSDM filter 5 analog watchdog status register
        struct DFSDM_FLT5AWSR : public RegisterReadOnly<0x4400d3a8> {
            using AWLTF = Field<0, 8>;    // AWLTF
            using AWHTF = Field<8, 8>;    // AWHTF
        };

        // DFSDM filter 5 analog watchdog clear flag register
        struct DFSDM_FLT5AWCFR : public Register<0x4400d3ac> {
            using CLRAWLTF = Field<0, 8>;    // CLRAWLTF
            using CLRAWHTF = Field<8, 8>;    // CLRAWHTF
        };

        // DFSDM filter 5 extremes detector maximum register
        struct DFSDM_FLT5EXMAX : public RegisterReadOnly<0x4400d3b0> {
            using EXMAXCH = Field<0, 3>;    // EXMAXCH
            using EXMAX = Field<8, 24>;    // EXMAX
        };

        // DFSDM filter 5 extremes detector minimum register
        struct DFSDM_FLT5EXMIN : public Register<0x4400d3b4> {
            using EXMINCH = Field<0, 3>;    // EXMINCH
            using EXMIN = Field<8, 24>;    // EXMIN
        };

        // DFSDM filter 5 conversion timer register
        struct DFSDM_FLT5CNVTIMR : public RegisterReadOnly<0x4400d3b8> {
            using CNVCNT = Field<4, 28>;    // CNVCNT
        };

        // This register specifies the hardware configuration of DFSDM peripheral.
        struct DFSDM_HWCFGR : public RegisterReadOnly<0x4400d7f0> {
            using NBT = Field<0, 8>;    // NBT
            using NBF = Field<8, 8>;    // NBF
        };

        // This register specifies the version of DFSDM peripheral.
        struct DFSDM_VERR : public RegisterReadOnly<0x4400d7f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // This register specifies the identification of DFSDM peripheral.
        struct DFSDM_IPIDR : public RegisterReadOnly<0x4400d7f8> {
            using ID = Field<0, 32>;    // ID
        };

        // This register specifies the size allocated to DFSDM registers.
        struct DFSDM_SIDR : public RegisterReadOnly<0x4400d7fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // DMA1
    struct DMA1 {
        // DMA low interrupt status register
        struct DMA_LISR : public RegisterReadOnly<0x48000000> {
            using FEIF0 = Field<0, 1>;    // FEIF0
            using DMEIF0 = Field<2, 1>;    // DMEIF0
            using TEIF0 = Field<3, 1>;    // TEIF0
            using HTIF0 = Field<4, 1>;    // HTIF0
            using TCIF0 = Field<5, 1>;    // TCIF0
            using FEIF1 = Field<6, 1>;    // FEIF1
            using DMEIF1 = Field<8, 1>;    // DMEIF1
            using TEIF1 = Field<9, 1>;    // TEIF1
            using HTIF1 = Field<10, 1>;    // HTIF1
            using TCIF1 = Field<11, 1>;    // TCIF1
            using FEIF2 = Field<16, 1>;    // FEIF2
            using DMEIF2 = Field<18, 1>;    // DMEIF2
            using TEIF2 = Field<19, 1>;    // TEIF2
            using HTIF2 = Field<20, 1>;    // HTIF2
            using TCIF2 = Field<21, 1>;    // TCIF2
            using FEIF3 = Field<22, 1>;    // FEIF3
            using DMEIF3 = Field<24, 1>;    // DMEIF3
            using TEIF3 = Field<25, 1>;    // TEIF3
            using HTIF3 = Field<26, 1>;    // HTIF3
            using TCIF3 = Field<27, 1>;    // TCIF3
        };

        // DMA high interrupt status register
        struct DMA_HISR : public RegisterReadOnly<0x48000004> {
            using FEIF4 = Field<0, 1>;    // FEIF4
            using DMEIF4 = Field<2, 1>;    // DMEIF4
            using TEIF4 = Field<3, 1>;    // TEIF4
            using HTIF4 = Field<4, 1>;    // HTIF4
            using TCIF4 = Field<5, 1>;    // TCIF4
            using FEIF5 = Field<6, 1>;    // FEIF5
            using DMEIF5 = Field<8, 1>;    // DMEIF5
            using TEIF5 = Field<9, 1>;    // TEIF5
            using HTIF5 = Field<10, 1>;    // HTIF5
            using TCIF5 = Field<11, 1>;    // TCIF5
            using FEIF6 = Field<16, 1>;    // FEIF6
            using DMEIF6 = Field<18, 1>;    // DMEIF6
            using TEIF6 = Field<19, 1>;    // TEIF6
            using HTIF6 = Field<20, 1>;    // HTIF6
            using TCIF6 = Field<21, 1>;    // TCIF6
            using FEIF7 = Field<22, 1>;    // FEIF7
            using DMEIF7 = Field<24, 1>;    // DMEIF7
            using TEIF7 = Field<25, 1>;    // TEIF7
            using HTIF7 = Field<26, 1>;    // HTIF7
            using TCIF7 = Field<27, 1>;    // TCIF7
        };

        // DMA low interrupt flag clear register
        struct DMA_LIFCR : public RegisterWriteOnly<0x48000008> {
            using CFEIF0 = Field<0, 1>;    // CFEIF0
            using CDMEIF0 = Field<2, 1>;    // CDMEIF0
            using CTEIF0 = Field<3, 1>;    // CTEIF0
            using CHTIF0 = Field<4, 1>;    // CHTIF0
            using CTCIF0 = Field<5, 1>;    // CTCIF0
            using CFEIF1 = Field<6, 1>;    // CFEIF1
            using CDMEIF1 = Field<8, 1>;    // CDMEIF1
            using CTEIF1 = Field<9, 1>;    // CTEIF1
            using CHTIF1 = Field<10, 1>;    // CHTIF1
            using CTCIF1 = Field<11, 1>;    // CTCIF1
            using CFEIF2 = Field<16, 1>;    // CFEIF2
            using CDMEIF2 = Field<18, 1>;    // CDMEIF2
            using CTEIF2 = Field<19, 1>;    // CTEIF2
            using CHTIF2 = Field<20, 1>;    // CHTIF2
            using CTCIF2 = Field<21, 1>;    // CTCIF2
            using CFEIF3 = Field<22, 1>;    // CFEIF3
            using CDMEIF3 = Field<24, 1>;    // CDMEIF3
            using CTEIF3 = Field<25, 1>;    // CTEIF3
            using CHTIF3 = Field<26, 1>;    // CHTIF3
            using CTCIF3 = Field<27, 1>;    // CTCIF3
        };

        // DMA high interrupt flag clear register
        struct DMA_HIFCR : public RegisterWriteOnly<0x4800000c> {
            using CFEIF4 = Field<0, 1>;    // CFEIF4
            using CDMEIF4 = Field<2, 1>;    // CDMEIF4
            using CTEIF4 = Field<3, 1>;    // CTEIF4
            using CHTIF4 = Field<4, 1>;    // CHTIF4
            using CTCIF4 = Field<5, 1>;    // CTCIF4
            using CFEIF5 = Field<6, 1>;    // CFEIF5
            using CDMEIF5 = Field<8, 1>;    // CDMEIF5
            using CTEIF5 = Field<9, 1>;    // CTEIF5
            using CHTIF5 = Field<10, 1>;    // CHTIF5
            using CTCIF5 = Field<11, 1>;    // CTCIF5
            using CFEIF6 = Field<16, 1>;    // CFEIF6
            using CDMEIF6 = Field<18, 1>;    // CDMEIF6
            using CTEIF6 = Field<19, 1>;    // CTEIF6
            using CHTIF6 = Field<20, 1>;    // CHTIF6
            using CTCIF6 = Field<21, 1>;    // CTCIF6
            using CFEIF7 = Field<22, 1>;    // CFEIF7
            using CDMEIF7 = Field<24, 1>;    // CDMEIF7
            using CTEIF7 = Field<25, 1>;    // CTEIF7
            using CHTIF7 = Field<26, 1>;    // CHTIF7
            using CTCIF7 = Field<27, 1>;    // CTCIF7
        };

        // This register is used to configure the concerned stream.
        struct DMA_S0CR : public Register<0x48000010> {
            using EN = Field<0, 1>;    // EN
            using DMEIE = Field<1, 1>;    // DMEIE
            using TEIE = Field<2, 1>;    // TEIE
            using HTIE = Field<3, 1>;    // HTIE
            using TCIE = Field<4, 1>;    // TCIE
            using PFCTRL = Field<5, 1>;    // PFCTRL
            using DIR = Field<6, 2>;    // DIR
            using CIRC = Field<8, 1>;    // CIRC
            using PINC = Field<9, 1>;    // PINC
            using MINC = Field<10, 1>;    // MINC
            using PSIZE = Field<11, 2>;    // PSIZE
            using MSIZE = Field<13, 2>;    // MSIZE
            using PINCOS = Field<15, 1>;    // PINCOS
            using PL = Field<16, 2>;    // PL
            using DBM = Field<18, 1>;    // DBM
            using CT = Field<19, 1>;    // CT
            using PBURST = Field<21, 2>;    // PBURST
            using MBURST = Field<23, 2>;    // MBURST
        };

        // DMA stream 0 number of data register
        struct DMA_S0NDTR : public Register<0x48000014> {
            using NDT = Field<0, 16>;    // NDT
        };

        // DMA stream 0 peripheral address register
        struct DMA_S0PAR : public Register<0x48000018> {
            using PAR = Field<0, 32>;    // PAR
        };

        // DMA stream 0 memory 0 address register
        struct DMA_S0M0AR : public Register<0x4800001c> {
            using M0A = Field<0, 32>;    // M0A
        };

        // DMA stream 0 memory 1 address register
        struct DMA_S0M1AR : public Register<0x48000020> {
            using M1A = Field<0, 32>;    // M1A
        };

        // DMA stream 0 FIFO control register
        struct DMA_S0FCR : public Register<0x48000024> {
            using FTH = Field<0, 2>;    // FTH
            using DMDIS = Field<2, 1>;    // DMDIS
            using FS = Field<3, 3>;    // FS
            using FEIE = Field<7, 1>;    // FEIE
        };

        // This register is used to configure the concerned stream.
        struct DMA_S1CR : public Register<0x48000028> {
            using EN = Field<0, 1>;    // EN
            using DMEIE = Field<1, 1>;    // DMEIE
            using TEIE = Field<2, 1>;    // TEIE
            using HTIE = Field<3, 1>;    // HTIE
            using TCIE = Field<4, 1>;    // TCIE
            using PFCTRL = Field<5, 1>;    // PFCTRL
            using DIR = Field<6, 2>;    // DIR
            using CIRC = Field<8, 1>;    // CIRC
            using PINC = Field<9, 1>;    // PINC
            using MINC = Field<10, 1>;    // MINC
            using PSIZE = Field<11, 2>;    // PSIZE
            using MSIZE = Field<13, 2>;    // MSIZE
            using PINCOS = Field<15, 1>;    // PINCOS
            using PL = Field<16, 2>;    // PL
            using DBM = Field<18, 1>;    // DBM
            using CT = Field<19, 1>;    // CT
            using PBURST = Field<21, 2>;    // PBURST
            using MBURST = Field<23, 2>;    // MBURST
        };

        // DMA stream 1 number of data register
        struct DMA_S1NDTR : public Register<0x4800002c> {
            using NDT = Field<0, 16>;    // NDT
        };

        // DMA stream 1 peripheral address register
        struct DMA_S1PAR : public Register<0x48000030> {
            using PAR = Field<0, 32>;    // PAR
        };

        // DMA stream 1 memory 0 address register
        struct DMA_S1M0AR : public Register<0x48000034> {
            using M0A = Field<0, 32>;    // M0A
        };

        // DMA stream 1 memory 1 address register
        struct DMA_S1M1AR : public Register<0x48000038> {
            using M1A = Field<0, 32>;    // M1A
        };

        // DMA stream 1 FIFO control register
        struct DMA_S1FCR : public Register<0x4800003c> {
            using FTH = Field<0, 2>;    // FTH
            using DMDIS = Field<2, 1>;    // DMDIS
            using FS = Field<3, 3>;    // FS
            using FEIE = Field<7, 1>;    // FEIE
        };

        // This register is used to configure the concerned stream.
        struct DMA_S2CR : public Register<0x48000040> {
            using EN = Field<0, 1>;    // EN
            using DMEIE = Field<1, 1>;    // DMEIE
            using TEIE = Field<2, 1>;    // TEIE
            using HTIE = Field<3, 1>;    // HTIE
            using TCIE = Field<4, 1>;    // TCIE
            using PFCTRL = Field<5, 1>;    // PFCTRL
            using DIR = Field<6, 2>;    // DIR
            using CIRC = Field<8, 1>;    // CIRC
            using PINC = Field<9, 1>;    // PINC
            using MINC = Field<10, 1>;    // MINC
            using PSIZE = Field<11, 2>;    // PSIZE
            using MSIZE = Field<13, 2>;    // MSIZE
            using PINCOS = Field<15, 1>;    // PINCOS
            using PL = Field<16, 2>;    // PL
            using DBM = Field<18, 1>;    // DBM
            using CT = Field<19, 1>;    // CT
            using PBURST = Field<21, 2>;    // PBURST
            using MBURST = Field<23, 2>;    // MBURST
        };

        // DMA stream 2 number of data register
        struct DMA_S2NDTR : public Register<0x48000044> {
            using NDT = Field<0, 16>;    // NDT
        };

        // DMA stream 2 peripheral address register
        struct DMA_S2PAR : public Register<0x48000048> {
            using PAR = Field<0, 32>;    // PAR
        };

        // DMA stream 2 memory 0 address register
        struct DMA_S2M0AR : public Register<0x4800004c> {
            using M0A = Field<0, 32>;    // M0A
        };

        // DMA stream 2 memory 1 address register
        struct DMA_S2M1AR : public Register<0x48000050> {
            using M1A = Field<0, 32>;    // M1A
        };

        // DMA stream 2 FIFO control register
        struct DMA_S2FCR : public Register<0x48000054> {
            using FTH = Field<0, 2>;    // FTH
            using DMDIS = Field<2, 1>;    // DMDIS
            using FS = Field<3, 3>;    // FS
            using FEIE = Field<7, 1>;    // FEIE
        };

        // This register is used to configure the concerned stream.
        struct DMA_S3CR : public Register<0x48000058> {
            using EN = Field<0, 1>;    // EN
            using DMEIE = Field<1, 1>;    // DMEIE
            using TEIE = Field<2, 1>;    // TEIE
            using HTIE = Field<3, 1>;    // HTIE
            using TCIE = Field<4, 1>;    // TCIE
            using PFCTRL = Field<5, 1>;    // PFCTRL
            using DIR = Field<6, 2>;    // DIR
            using CIRC = Field<8, 1>;    // CIRC
            using PINC = Field<9, 1>;    // PINC
            using MINC = Field<10, 1>;    // MINC
            using PSIZE = Field<11, 2>;    // PSIZE
            using MSIZE = Field<13, 2>;    // MSIZE
            using PINCOS = Field<15, 1>;    // PINCOS
            using PL = Field<16, 2>;    // PL
            using DBM = Field<18, 1>;    // DBM
            using CT = Field<19, 1>;    // CT
            using PBURST = Field<21, 2>;    // PBURST
            using MBURST = Field<23, 2>;    // MBURST
        };

        // DMA stream 3 number of data register
        struct DMA_S3NDTR : public Register<0x4800005c> {
            using NDT = Field<0, 16>;    // NDT
        };

        // DMA stream 3 peripheral address register
        struct DMA_S3PAR : public Register<0x48000060> {
            using PAR = Field<0, 32>;    // PAR
        };

        // DMA stream 3 memory 0 address register
        struct DMA_S3M0AR : public Register<0x48000064> {
            using M0A = Field<0, 32>;    // M0A
        };

        // DMA stream 3 memory 1 address register
        struct DMA_S3M1AR : public Register<0x48000068> {
            using M1A = Field<0, 32>;    // M1A
        };

        // DMA stream 3 FIFO control register
        struct DMA_S3FCR : public Register<0x4800006c> {
            using FTH = Field<0, 2>;    // FTH
            using DMDIS = Field<2, 1>;    // DMDIS
            using FS = Field<3, 3>;    // FS
            using FEIE = Field<7, 1>;    // FEIE
        };

        // This register is used to configure the concerned stream.
        struct DMA_S4CR : public Register<0x48000070> {
            using EN = Field<0, 1>;    // EN
            using DMEIE = Field<1, 1>;    // DMEIE
            using TEIE = Field<2, 1>;    // TEIE
            using HTIE = Field<3, 1>;    // HTIE
            using TCIE = Field<4, 1>;    // TCIE
            using PFCTRL = Field<5, 1>;    // PFCTRL
            using DIR = Field<6, 2>;    // DIR
            using CIRC = Field<8, 1>;    // CIRC
            using PINC = Field<9, 1>;    // PINC
            using MINC = Field<10, 1>;    // MINC
            using PSIZE = Field<11, 2>;    // PSIZE
            using MSIZE = Field<13, 2>;    // MSIZE
            using PINCOS = Field<15, 1>;    // PINCOS
            using PL = Field<16, 2>;    // PL
            using DBM = Field<18, 1>;    // DBM
            using CT = Field<19, 1>;    // CT
            using PBURST = Field<21, 2>;    // PBURST
            using MBURST = Field<23, 2>;    // MBURST
        };

        // DMA stream 4 number of data register
        struct DMA_S4NDTR : public Register<0x48000074> {
            using NDT = Field<0, 16>;    // NDT
        };

        // DMA stream 4 peripheral address register
        struct DMA_S4PAR : public Register<0x48000078> {
            using PAR = Field<0, 32>;    // PAR
        };

        // DMA stream 4 memory 0 address register
        struct DMA_S4M0AR : public Register<0x4800007c> {
            using M0A = Field<0, 32>;    // M0A
        };

        // DMA stream 4 memory 1 address register
        struct DMA_S4M1AR : public Register<0x48000080> {
            using M1A = Field<0, 32>;    // M1A
        };

        // DMA stream 4 FIFO control register
        struct DMA_S4FCR : public Register<0x48000084> {
            using FTH = Field<0, 2>;    // FTH
            using DMDIS = Field<2, 1>;    // DMDIS
            using FS = Field<3, 3>;    // FS
            using FEIE = Field<7, 1>;    // FEIE
        };

        // This register is used to configure the concerned stream.
        struct DMA_S5CR : public Register<0x48000088> {
            using EN = Field<0, 1>;    // EN
            using DMEIE = Field<1, 1>;    // DMEIE
            using TEIE = Field<2, 1>;    // TEIE
            using HTIE = Field<3, 1>;    // HTIE
            using TCIE = Field<4, 1>;    // TCIE
            using PFCTRL = Field<5, 1>;    // PFCTRL
            using DIR = Field<6, 2>;    // DIR
            using CIRC = Field<8, 1>;    // CIRC
            using PINC = Field<9, 1>;    // PINC
            using MINC = Field<10, 1>;    // MINC
            using PSIZE = Field<11, 2>;    // PSIZE
            using MSIZE = Field<13, 2>;    // MSIZE
            using PINCOS = Field<15, 1>;    // PINCOS
            using PL = Field<16, 2>;    // PL
            using DBM = Field<18, 1>;    // DBM
            using CT = Field<19, 1>;    // CT
            using PBURST = Field<21, 2>;    // PBURST
            using MBURST = Field<23, 2>;    // MBURST
        };

        // DMA stream 5 number of data register
        struct DMA_S5NDTR : public Register<0x4800008c> {
            using NDT = Field<0, 16>;    // NDT
        };

        // DMA stream 5 peripheral address register
        struct DMA_S5PAR : public Register<0x48000090> {
            using PAR = Field<0, 32>;    // PAR
        };

        // DMA stream 5 memory 0 address register
        struct DMA_S5M0AR : public Register<0x48000094> {
            using M0A = Field<0, 32>;    // M0A
        };

        // DMA stream 5 memory 1 address register
        struct DMA_S5M1AR : public Register<0x48000098> {
            using M1A = Field<0, 32>;    // M1A
        };

        // DMA stream 5 FIFO control register
        struct DMA_S5FCR : public Register<0x4800009c> {
            using FTH = Field<0, 2>;    // FTH
            using DMDIS = Field<2, 1>;    // DMDIS
            using FS = Field<3, 3>;    // FS
            using FEIE = Field<7, 1>;    // FEIE
        };

        // This register is used to configure the concerned stream.
        struct DMA_S6CR : public Register<0x480000a0> {
            using EN = Field<0, 1>;    // EN
            using DMEIE = Field<1, 1>;    // DMEIE
            using TEIE = Field<2, 1>;    // TEIE
            using HTIE = Field<3, 1>;    // HTIE
            using TCIE = Field<4, 1>;    // TCIE
            using PFCTRL = Field<5, 1>;    // PFCTRL
            using DIR = Field<6, 2>;    // DIR
            using CIRC = Field<8, 1>;    // CIRC
            using PINC = Field<9, 1>;    // PINC
            using MINC = Field<10, 1>;    // MINC
            using PSIZE = Field<11, 2>;    // PSIZE
            using MSIZE = Field<13, 2>;    // MSIZE
            using PINCOS = Field<15, 1>;    // PINCOS
            using PL = Field<16, 2>;    // PL
            using DBM = Field<18, 1>;    // DBM
            using CT = Field<19, 1>;    // CT
            using PBURST = Field<21, 2>;    // PBURST
            using MBURST = Field<23, 2>;    // MBURST
        };

        // DMA stream 6 number of data register
        struct DMA_S6NDTR : public Register<0x480000a4> {
            using NDT = Field<0, 16>;    // NDT
        };

        // DMA stream 6 peripheral address register
        struct DMA_S6PAR : public Register<0x480000a8> {
            using PAR = Field<0, 32>;    // PAR
        };

        // DMA stream 6 memory 0 address register
        struct DMA_S6M0AR : public Register<0x480000ac> {
            using M0A = Field<0, 32>;    // M0A
        };

        // DMA stream 6 memory 1 address register
        struct DMA_S6M1AR : public Register<0x480000b0> {
            using M1A = Field<0, 32>;    // M1A
        };

        // DMA stream 6 FIFO control register
        struct DMA_S6FCR : public Register<0x480000b4> {
            using FTH = Field<0, 2>;    // FTH
            using DMDIS = Field<2, 1>;    // DMDIS
            using FS = Field<3, 3>;    // FS
            using FEIE = Field<7, 1>;    // FEIE
        };

        // This register is used to configure the concerned stream.
        struct DMA_S7CR : public Register<0x480000b8> {
            using EN = Field<0, 1>;    // EN
            using DMEIE = Field<1, 1>;    // DMEIE
            using TEIE = Field<2, 1>;    // TEIE
            using HTIE = Field<3, 1>;    // HTIE
            using TCIE = Field<4, 1>;    // TCIE
            using PFCTRL = Field<5, 1>;    // PFCTRL
            using DIR = Field<6, 2>;    // DIR
            using CIRC = Field<8, 1>;    // CIRC
            using PINC = Field<9, 1>;    // PINC
            using MINC = Field<10, 1>;    // MINC
            using PSIZE = Field<11, 2>;    // PSIZE
            using MSIZE = Field<13, 2>;    // MSIZE
            using PINCOS = Field<15, 1>;    // PINCOS
            using PL = Field<16, 2>;    // PL
            using DBM = Field<18, 1>;    // DBM
            using CT = Field<19, 1>;    // CT
            using PBURST = Field<21, 2>;    // PBURST
            using MBURST = Field<23, 2>;    // MBURST
        };

        // DMA stream 7 number of data register
        struct DMA_S7NDTR : public Register<0x480000bc> {
            using NDT = Field<0, 16>;    // NDT
        };

        // DMA stream 7 peripheral address register
        struct DMA_S7PAR : public Register<0x480000c0> {
            using PAR = Field<0, 32>;    // PAR
        };

        // DMA stream 7 memory 0 address register
        struct DMA_S7M0AR : public Register<0x480000c4> {
            using M0A = Field<0, 32>;    // M0A
        };

        // DMA stream 7 memory 1 address register
        struct DMA_S7M1AR : public Register<0x480000c8> {
            using M1A = Field<0, 32>;    // M1A
        };

        // DMA stream 7 FIFO control register
        struct DMA_S7FCR : public Register<0x480000cc> {
            using FTH = Field<0, 2>;    // FTH
            using DMDIS = Field<2, 1>;    // DMDIS
            using FS = Field<3, 3>;    // FS
            using FEIE = Field<7, 1>;    // FEIE
        };

        // DMA hardware configuration 2register
        struct DMA_HWCFGR2 : public RegisterReadOnly<0x480003ec> {
            using FIFO_SIZE = Field<0, 2>;    // FIFO_SIZE
            using WRITE_BUFFERABLE = Field<4, 1>;    // WRITE_BUFFERABLE
            using CHSEL_WIDTH = Field<8, 3>;    // CHSEL_WIDTH
        };

        // DMA hardware configuration 1 register
        struct DMA_HWCFGR1 : public RegisterReadOnly<0x480003f0> {
            using DMA_DEF0 = Field<0, 2>;    // DMA_DEF0
            using DMA_DEF1 = Field<4, 2>;    // DMA_DEF1
            using DMA_DEF2 = Field<8, 2>;    // DMA_DEF2
            using DMA_DEF3 = Field<12, 2>;    // DMA_DEF3
            using DMA_DEF4 = Field<16, 2>;    // DMA_DEF4
            using DMA_DEF5 = Field<20, 2>;    // DMA_DEF5
            using DMA_DEF6 = Field<24, 2>;    // DMA_DEF6
            using DMA_DEF7 = Field<28, 2>;    // DMA_DEF7
        };

        // This register identifies the version of the IP.
        struct DMA_VERR : public RegisterReadOnly<0x480003f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // DMA IP identification register
        struct DMA_IPDR : public RegisterReadOnly<0x480003f8> {
            using ID = Field<0, 32>;    // ID
        };

        // DMA size identification register
        struct DMA_SIDR : public RegisterReadOnly<0x480003fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // DMA1
    struct DMA2 {
        // DMA low interrupt status register
        struct DMA_LISR : public RegisterReadOnly<0x48001000> {
            using FEIF0 = Field<0, 1>;    // FEIF0
            using DMEIF0 = Field<2, 1>;    // DMEIF0
            using TEIF0 = Field<3, 1>;    // TEIF0
            using HTIF0 = Field<4, 1>;    // HTIF0
            using TCIF0 = Field<5, 1>;    // TCIF0
            using FEIF1 = Field<6, 1>;    // FEIF1
            using DMEIF1 = Field<8, 1>;    // DMEIF1
            using TEIF1 = Field<9, 1>;    // TEIF1
            using HTIF1 = Field<10, 1>;    // HTIF1
            using TCIF1 = Field<11, 1>;    // TCIF1
            using FEIF2 = Field<16, 1>;    // FEIF2
            using DMEIF2 = Field<18, 1>;    // DMEIF2
            using TEIF2 = Field<19, 1>;    // TEIF2
            using HTIF2 = Field<20, 1>;    // HTIF2
            using TCIF2 = Field<21, 1>;    // TCIF2
            using FEIF3 = Field<22, 1>;    // FEIF3
            using DMEIF3 = Field<24, 1>;    // DMEIF3
            using TEIF3 = Field<25, 1>;    // TEIF3
            using HTIF3 = Field<26, 1>;    // HTIF3
            using TCIF3 = Field<27, 1>;    // TCIF3
        };

        // DMA high interrupt status register
        struct DMA_HISR : public RegisterReadOnly<0x48001004> {
            using FEIF4 = Field<0, 1>;    // FEIF4
            using DMEIF4 = Field<2, 1>;    // DMEIF4
            using TEIF4 = Field<3, 1>;    // TEIF4
            using HTIF4 = Field<4, 1>;    // HTIF4
            using TCIF4 = Field<5, 1>;    // TCIF4
            using FEIF5 = Field<6, 1>;    // FEIF5
            using DMEIF5 = Field<8, 1>;    // DMEIF5
            using TEIF5 = Field<9, 1>;    // TEIF5
            using HTIF5 = Field<10, 1>;    // HTIF5
            using TCIF5 = Field<11, 1>;    // TCIF5
            using FEIF6 = Field<16, 1>;    // FEIF6
            using DMEIF6 = Field<18, 1>;    // DMEIF6
            using TEIF6 = Field<19, 1>;    // TEIF6
            using HTIF6 = Field<20, 1>;    // HTIF6
            using TCIF6 = Field<21, 1>;    // TCIF6
            using FEIF7 = Field<22, 1>;    // FEIF7
            using DMEIF7 = Field<24, 1>;    // DMEIF7
            using TEIF7 = Field<25, 1>;    // TEIF7
            using HTIF7 = Field<26, 1>;    // HTIF7
            using TCIF7 = Field<27, 1>;    // TCIF7
        };

        // DMA low interrupt flag clear register
        struct DMA_LIFCR : public RegisterWriteOnly<0x48001008> {
            using CFEIF0 = Field<0, 1>;    // CFEIF0
            using CDMEIF0 = Field<2, 1>;    // CDMEIF0
            using CTEIF0 = Field<3, 1>;    // CTEIF0
            using CHTIF0 = Field<4, 1>;    // CHTIF0
            using CTCIF0 = Field<5, 1>;    // CTCIF0
            using CFEIF1 = Field<6, 1>;    // CFEIF1
            using CDMEIF1 = Field<8, 1>;    // CDMEIF1
            using CTEIF1 = Field<9, 1>;    // CTEIF1
            using CHTIF1 = Field<10, 1>;    // CHTIF1
            using CTCIF1 = Field<11, 1>;    // CTCIF1
            using CFEIF2 = Field<16, 1>;    // CFEIF2
            using CDMEIF2 = Field<18, 1>;    // CDMEIF2
            using CTEIF2 = Field<19, 1>;    // CTEIF2
            using CHTIF2 = Field<20, 1>;    // CHTIF2
            using CTCIF2 = Field<21, 1>;    // CTCIF2
            using CFEIF3 = Field<22, 1>;    // CFEIF3
            using CDMEIF3 = Field<24, 1>;    // CDMEIF3
            using CTEIF3 = Field<25, 1>;    // CTEIF3
            using CHTIF3 = Field<26, 1>;    // CHTIF3
            using CTCIF3 = Field<27, 1>;    // CTCIF3
        };

        // DMA high interrupt flag clear register
        struct DMA_HIFCR : public RegisterWriteOnly<0x4800100c> {
            using CFEIF4 = Field<0, 1>;    // CFEIF4
            using CDMEIF4 = Field<2, 1>;    // CDMEIF4
            using CTEIF4 = Field<3, 1>;    // CTEIF4
            using CHTIF4 = Field<4, 1>;    // CHTIF4
            using CTCIF4 = Field<5, 1>;    // CTCIF4
            using CFEIF5 = Field<6, 1>;    // CFEIF5
            using CDMEIF5 = Field<8, 1>;    // CDMEIF5
            using CTEIF5 = Field<9, 1>;    // CTEIF5
            using CHTIF5 = Field<10, 1>;    // CHTIF5
            using CTCIF5 = Field<11, 1>;    // CTCIF5
            using CFEIF6 = Field<16, 1>;    // CFEIF6
            using CDMEIF6 = Field<18, 1>;    // CDMEIF6
            using CTEIF6 = Field<19, 1>;    // CTEIF6
            using CHTIF6 = Field<20, 1>;    // CHTIF6
            using CTCIF6 = Field<21, 1>;    // CTCIF6
            using CFEIF7 = Field<22, 1>;    // CFEIF7
            using CDMEIF7 = Field<24, 1>;    // CDMEIF7
            using CTEIF7 = Field<25, 1>;    // CTEIF7
            using CHTIF7 = Field<26, 1>;    // CHTIF7
            using CTCIF7 = Field<27, 1>;    // CTCIF7
        };

        // This register is used to configure the concerned stream.
        struct DMA_S0CR : public Register<0x48001010> {
            using EN = Field<0, 1>;    // EN
            using DMEIE = Field<1, 1>;    // DMEIE
            using TEIE = Field<2, 1>;    // TEIE
            using HTIE = Field<3, 1>;    // HTIE
            using TCIE = Field<4, 1>;    // TCIE
            using PFCTRL = Field<5, 1>;    // PFCTRL
            using DIR = Field<6, 2>;    // DIR
            using CIRC = Field<8, 1>;    // CIRC
            using PINC = Field<9, 1>;    // PINC
            using MINC = Field<10, 1>;    // MINC
            using PSIZE = Field<11, 2>;    // PSIZE
            using MSIZE = Field<13, 2>;    // MSIZE
            using PINCOS = Field<15, 1>;    // PINCOS
            using PL = Field<16, 2>;    // PL
            using DBM = Field<18, 1>;    // DBM
            using CT = Field<19, 1>;    // CT
            using PBURST = Field<21, 2>;    // PBURST
            using MBURST = Field<23, 2>;    // MBURST
        };

        // DMA stream 0 number of data register
        struct DMA_S0NDTR : public Register<0x48001014> {
            using NDT = Field<0, 16>;    // NDT
        };

        // DMA stream 0 peripheral address register
        struct DMA_S0PAR : public Register<0x48001018> {
            using PAR = Field<0, 32>;    // PAR
        };

        // DMA stream 0 memory 0 address register
        struct DMA_S0M0AR : public Register<0x4800101c> {
            using M0A = Field<0, 32>;    // M0A
        };

        // DMA stream 0 memory 1 address register
        struct DMA_S0M1AR : public Register<0x48001020> {
            using M1A = Field<0, 32>;    // M1A
        };

        // DMA stream 0 FIFO control register
        struct DMA_S0FCR : public Register<0x48001024> {
            using FTH = Field<0, 2>;    // FTH
            using DMDIS = Field<2, 1>;    // DMDIS
            using FS = Field<3, 3>;    // FS
            using FEIE = Field<7, 1>;    // FEIE
        };

        // This register is used to configure the concerned stream.
        struct DMA_S1CR : public Register<0x48001028> {
            using EN = Field<0, 1>;    // EN
            using DMEIE = Field<1, 1>;    // DMEIE
            using TEIE = Field<2, 1>;    // TEIE
            using HTIE = Field<3, 1>;    // HTIE
            using TCIE = Field<4, 1>;    // TCIE
            using PFCTRL = Field<5, 1>;    // PFCTRL
            using DIR = Field<6, 2>;    // DIR
            using CIRC = Field<8, 1>;    // CIRC
            using PINC = Field<9, 1>;    // PINC
            using MINC = Field<10, 1>;    // MINC
            using PSIZE = Field<11, 2>;    // PSIZE
            using MSIZE = Field<13, 2>;    // MSIZE
            using PINCOS = Field<15, 1>;    // PINCOS
            using PL = Field<16, 2>;    // PL
            using DBM = Field<18, 1>;    // DBM
            using CT = Field<19, 1>;    // CT
            using PBURST = Field<21, 2>;    // PBURST
            using MBURST = Field<23, 2>;    // MBURST
        };

        // DMA stream 1 number of data register
        struct DMA_S1NDTR : public Register<0x4800102c> {
            using NDT = Field<0, 16>;    // NDT
        };

        // DMA stream 1 peripheral address register
        struct DMA_S1PAR : public Register<0x48001030> {
            using PAR = Field<0, 32>;    // PAR
        };

        // DMA stream 1 memory 0 address register
        struct DMA_S1M0AR : public Register<0x48001034> {
            using M0A = Field<0, 32>;    // M0A
        };

        // DMA stream 1 memory 1 address register
        struct DMA_S1M1AR : public Register<0x48001038> {
            using M1A = Field<0, 32>;    // M1A
        };

        // DMA stream 1 FIFO control register
        struct DMA_S1FCR : public Register<0x4800103c> {
            using FTH = Field<0, 2>;    // FTH
            using DMDIS = Field<2, 1>;    // DMDIS
            using FS = Field<3, 3>;    // FS
            using FEIE = Field<7, 1>;    // FEIE
        };

        // This register is used to configure the concerned stream.
        struct DMA_S2CR : public Register<0x48001040> {
            using EN = Field<0, 1>;    // EN
            using DMEIE = Field<1, 1>;    // DMEIE
            using TEIE = Field<2, 1>;    // TEIE
            using HTIE = Field<3, 1>;    // HTIE
            using TCIE = Field<4, 1>;    // TCIE
            using PFCTRL = Field<5, 1>;    // PFCTRL
            using DIR = Field<6, 2>;    // DIR
            using CIRC = Field<8, 1>;    // CIRC
            using PINC = Field<9, 1>;    // PINC
            using MINC = Field<10, 1>;    // MINC
            using PSIZE = Field<11, 2>;    // PSIZE
            using MSIZE = Field<13, 2>;    // MSIZE
            using PINCOS = Field<15, 1>;    // PINCOS
            using PL = Field<16, 2>;    // PL
            using DBM = Field<18, 1>;    // DBM
            using CT = Field<19, 1>;    // CT
            using PBURST = Field<21, 2>;    // PBURST
            using MBURST = Field<23, 2>;    // MBURST
        };

        // DMA stream 2 number of data register
        struct DMA_S2NDTR : public Register<0x48001044> {
            using NDT = Field<0, 16>;    // NDT
        };

        // DMA stream 2 peripheral address register
        struct DMA_S2PAR : public Register<0x48001048> {
            using PAR = Field<0, 32>;    // PAR
        };

        // DMA stream 2 memory 0 address register
        struct DMA_S2M0AR : public Register<0x4800104c> {
            using M0A = Field<0, 32>;    // M0A
        };

        // DMA stream 2 memory 1 address register
        struct DMA_S2M1AR : public Register<0x48001050> {
            using M1A = Field<0, 32>;    // M1A
        };

        // DMA stream 2 FIFO control register
        struct DMA_S2FCR : public Register<0x48001054> {
            using FTH = Field<0, 2>;    // FTH
            using DMDIS = Field<2, 1>;    // DMDIS
            using FS = Field<3, 3>;    // FS
            using FEIE = Field<7, 1>;    // FEIE
        };

        // This register is used to configure the concerned stream.
        struct DMA_S3CR : public Register<0x48001058> {
            using EN = Field<0, 1>;    // EN
            using DMEIE = Field<1, 1>;    // DMEIE
            using TEIE = Field<2, 1>;    // TEIE
            using HTIE = Field<3, 1>;    // HTIE
            using TCIE = Field<4, 1>;    // TCIE
            using PFCTRL = Field<5, 1>;    // PFCTRL
            using DIR = Field<6, 2>;    // DIR
            using CIRC = Field<8, 1>;    // CIRC
            using PINC = Field<9, 1>;    // PINC
            using MINC = Field<10, 1>;    // MINC
            using PSIZE = Field<11, 2>;    // PSIZE
            using MSIZE = Field<13, 2>;    // MSIZE
            using PINCOS = Field<15, 1>;    // PINCOS
            using PL = Field<16, 2>;    // PL
            using DBM = Field<18, 1>;    // DBM
            using CT = Field<19, 1>;    // CT
            using PBURST = Field<21, 2>;    // PBURST
            using MBURST = Field<23, 2>;    // MBURST
        };

        // DMA stream 3 number of data register
        struct DMA_S3NDTR : public Register<0x4800105c> {
            using NDT = Field<0, 16>;    // NDT
        };

        // DMA stream 3 peripheral address register
        struct DMA_S3PAR : public Register<0x48001060> {
            using PAR = Field<0, 32>;    // PAR
        };

        // DMA stream 3 memory 0 address register
        struct DMA_S3M0AR : public Register<0x48001064> {
            using M0A = Field<0, 32>;    // M0A
        };

        // DMA stream 3 memory 1 address register
        struct DMA_S3M1AR : public Register<0x48001068> {
            using M1A = Field<0, 32>;    // M1A
        };

        // DMA stream 3 FIFO control register
        struct DMA_S3FCR : public Register<0x4800106c> {
            using FTH = Field<0, 2>;    // FTH
            using DMDIS = Field<2, 1>;    // DMDIS
            using FS = Field<3, 3>;    // FS
            using FEIE = Field<7, 1>;    // FEIE
        };

        // This register is used to configure the concerned stream.
        struct DMA_S4CR : public Register<0x48001070> {
            using EN = Field<0, 1>;    // EN
            using DMEIE = Field<1, 1>;    // DMEIE
            using TEIE = Field<2, 1>;    // TEIE
            using HTIE = Field<3, 1>;    // HTIE
            using TCIE = Field<4, 1>;    // TCIE
            using PFCTRL = Field<5, 1>;    // PFCTRL
            using DIR = Field<6, 2>;    // DIR
            using CIRC = Field<8, 1>;    // CIRC
            using PINC = Field<9, 1>;    // PINC
            using MINC = Field<10, 1>;    // MINC
            using PSIZE = Field<11, 2>;    // PSIZE
            using MSIZE = Field<13, 2>;    // MSIZE
            using PINCOS = Field<15, 1>;    // PINCOS
            using PL = Field<16, 2>;    // PL
            using DBM = Field<18, 1>;    // DBM
            using CT = Field<19, 1>;    // CT
            using PBURST = Field<21, 2>;    // PBURST
            using MBURST = Field<23, 2>;    // MBURST
        };

        // DMA stream 4 number of data register
        struct DMA_S4NDTR : public Register<0x48001074> {
            using NDT = Field<0, 16>;    // NDT
        };

        // DMA stream 4 peripheral address register
        struct DMA_S4PAR : public Register<0x48001078> {
            using PAR = Field<0, 32>;    // PAR
        };

        // DMA stream 4 memory 0 address register
        struct DMA_S4M0AR : public Register<0x4800107c> {
            using M0A = Field<0, 32>;    // M0A
        };

        // DMA stream 4 memory 1 address register
        struct DMA_S4M1AR : public Register<0x48001080> {
            using M1A = Field<0, 32>;    // M1A
        };

        // DMA stream 4 FIFO control register
        struct DMA_S4FCR : public Register<0x48001084> {
            using FTH = Field<0, 2>;    // FTH
            using DMDIS = Field<2, 1>;    // DMDIS
            using FS = Field<3, 3>;    // FS
            using FEIE = Field<7, 1>;    // FEIE
        };

        // This register is used to configure the concerned stream.
        struct DMA_S5CR : public Register<0x48001088> {
            using EN = Field<0, 1>;    // EN
            using DMEIE = Field<1, 1>;    // DMEIE
            using TEIE = Field<2, 1>;    // TEIE
            using HTIE = Field<3, 1>;    // HTIE
            using TCIE = Field<4, 1>;    // TCIE
            using PFCTRL = Field<5, 1>;    // PFCTRL
            using DIR = Field<6, 2>;    // DIR
            using CIRC = Field<8, 1>;    // CIRC
            using PINC = Field<9, 1>;    // PINC
            using MINC = Field<10, 1>;    // MINC
            using PSIZE = Field<11, 2>;    // PSIZE
            using MSIZE = Field<13, 2>;    // MSIZE
            using PINCOS = Field<15, 1>;    // PINCOS
            using PL = Field<16, 2>;    // PL
            using DBM = Field<18, 1>;    // DBM
            using CT = Field<19, 1>;    // CT
            using PBURST = Field<21, 2>;    // PBURST
            using MBURST = Field<23, 2>;    // MBURST
        };

        // DMA stream 5 number of data register
        struct DMA_S5NDTR : public Register<0x4800108c> {
            using NDT = Field<0, 16>;    // NDT
        };

        // DMA stream 5 peripheral address register
        struct DMA_S5PAR : public Register<0x48001090> {
            using PAR = Field<0, 32>;    // PAR
        };

        // DMA stream 5 memory 0 address register
        struct DMA_S5M0AR : public Register<0x48001094> {
            using M0A = Field<0, 32>;    // M0A
        };

        // DMA stream 5 memory 1 address register
        struct DMA_S5M1AR : public Register<0x48001098> {
            using M1A = Field<0, 32>;    // M1A
        };

        // DMA stream 5 FIFO control register
        struct DMA_S5FCR : public Register<0x4800109c> {
            using FTH = Field<0, 2>;    // FTH
            using DMDIS = Field<2, 1>;    // DMDIS
            using FS = Field<3, 3>;    // FS
            using FEIE = Field<7, 1>;    // FEIE
        };

        // This register is used to configure the concerned stream.
        struct DMA_S6CR : public Register<0x480010a0> {
            using EN = Field<0, 1>;    // EN
            using DMEIE = Field<1, 1>;    // DMEIE
            using TEIE = Field<2, 1>;    // TEIE
            using HTIE = Field<3, 1>;    // HTIE
            using TCIE = Field<4, 1>;    // TCIE
            using PFCTRL = Field<5, 1>;    // PFCTRL
            using DIR = Field<6, 2>;    // DIR
            using CIRC = Field<8, 1>;    // CIRC
            using PINC = Field<9, 1>;    // PINC
            using MINC = Field<10, 1>;    // MINC
            using PSIZE = Field<11, 2>;    // PSIZE
            using MSIZE = Field<13, 2>;    // MSIZE
            using PINCOS = Field<15, 1>;    // PINCOS
            using PL = Field<16, 2>;    // PL
            using DBM = Field<18, 1>;    // DBM
            using CT = Field<19, 1>;    // CT
            using PBURST = Field<21, 2>;    // PBURST
            using MBURST = Field<23, 2>;    // MBURST
        };

        // DMA stream 6 number of data register
        struct DMA_S6NDTR : public Register<0x480010a4> {
            using NDT = Field<0, 16>;    // NDT
        };

        // DMA stream 6 peripheral address register
        struct DMA_S6PAR : public Register<0x480010a8> {
            using PAR = Field<0, 32>;    // PAR
        };

        // DMA stream 6 memory 0 address register
        struct DMA_S6M0AR : public Register<0x480010ac> {
            using M0A = Field<0, 32>;    // M0A
        };

        // DMA stream 6 memory 1 address register
        struct DMA_S6M1AR : public Register<0x480010b0> {
            using M1A = Field<0, 32>;    // M1A
        };

        // DMA stream 6 FIFO control register
        struct DMA_S6FCR : public Register<0x480010b4> {
            using FTH = Field<0, 2>;    // FTH
            using DMDIS = Field<2, 1>;    // DMDIS
            using FS = Field<3, 3>;    // FS
            using FEIE = Field<7, 1>;    // FEIE
        };

        // This register is used to configure the concerned stream.
        struct DMA_S7CR : public Register<0x480010b8> {
            using EN = Field<0, 1>;    // EN
            using DMEIE = Field<1, 1>;    // DMEIE
            using TEIE = Field<2, 1>;    // TEIE
            using HTIE = Field<3, 1>;    // HTIE
            using TCIE = Field<4, 1>;    // TCIE
            using PFCTRL = Field<5, 1>;    // PFCTRL
            using DIR = Field<6, 2>;    // DIR
            using CIRC = Field<8, 1>;    // CIRC
            using PINC = Field<9, 1>;    // PINC
            using MINC = Field<10, 1>;    // MINC
            using PSIZE = Field<11, 2>;    // PSIZE
            using MSIZE = Field<13, 2>;    // MSIZE
            using PINCOS = Field<15, 1>;    // PINCOS
            using PL = Field<16, 2>;    // PL
            using DBM = Field<18, 1>;    // DBM
            using CT = Field<19, 1>;    // CT
            using PBURST = Field<21, 2>;    // PBURST
            using MBURST = Field<23, 2>;    // MBURST
        };

        // DMA stream 7 number of data register
        struct DMA_S7NDTR : public Register<0x480010bc> {
            using NDT = Field<0, 16>;    // NDT
        };

        // DMA stream 7 peripheral address register
        struct DMA_S7PAR : public Register<0x480010c0> {
            using PAR = Field<0, 32>;    // PAR
        };

        // DMA stream 7 memory 0 address register
        struct DMA_S7M0AR : public Register<0x480010c4> {
            using M0A = Field<0, 32>;    // M0A
        };

        // DMA stream 7 memory 1 address register
        struct DMA_S7M1AR : public Register<0x480010c8> {
            using M1A = Field<0, 32>;    // M1A
        };

        // DMA stream 7 FIFO control register
        struct DMA_S7FCR : public Register<0x480010cc> {
            using FTH = Field<0, 2>;    // FTH
            using DMDIS = Field<2, 1>;    // DMDIS
            using FS = Field<3, 3>;    // FS
            using FEIE = Field<7, 1>;    // FEIE
        };

        // DMA hardware configuration 2register
        struct DMA_HWCFGR2 : public RegisterReadOnly<0x480013ec> {
            using FIFO_SIZE = Field<0, 2>;    // FIFO_SIZE
            using WRITE_BUFFERABLE = Field<4, 1>;    // WRITE_BUFFERABLE
            using CHSEL_WIDTH = Field<8, 3>;    // CHSEL_WIDTH
        };

        // DMA hardware configuration 1 register
        struct DMA_HWCFGR1 : public RegisterReadOnly<0x480013f0> {
            using DMA_DEF0 = Field<0, 2>;    // DMA_DEF0
            using DMA_DEF1 = Field<4, 2>;    // DMA_DEF1
            using DMA_DEF2 = Field<8, 2>;    // DMA_DEF2
            using DMA_DEF3 = Field<12, 2>;    // DMA_DEF3
            using DMA_DEF4 = Field<16, 2>;    // DMA_DEF4
            using DMA_DEF5 = Field<20, 2>;    // DMA_DEF5
            using DMA_DEF6 = Field<24, 2>;    // DMA_DEF6
            using DMA_DEF7 = Field<28, 2>;    // DMA_DEF7
        };

        // This register identifies the version of the IP.
        struct DMA_VERR : public RegisterReadOnly<0x480013f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // DMA IP identification register
        struct DMA_IPDR : public RegisterReadOnly<0x480013f8> {
            using ID = Field<0, 32>;    // ID
        };

        // DMA size identification register
        struct DMA_SIDR : public RegisterReadOnly<0x480013fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // DMAMUX1
    struct DMAMUX1 {
        // DMAMUX request line multiplexer channel 0 configuration register
        struct DMAMUX_C0CR : public Register<0x48002000> {
            using DMAREQ_ID = Field<0, 7>;    // DMAREQ_ID
            using SOIE = Field<8, 1>;    // SOIE
            using EGE = Field<9, 1>;    // EGE
            using SE = Field<16, 1>;    // SE
            using SPOL = Field<17, 2>;    // SPOL
            using NBREQ = Field<19, 5>;    // NBREQ
            using SYNC_ID = Field<24, 3>;    // SYNC_ID
        };

        // DMAMUX request line multiplexer channel 1 configuration register
        struct DMAMUX_C1CR : public Register<0x48002004> {
            using DMAREQ_ID = Field<0, 7>;    // DMAREQ_ID
            using SOIE = Field<8, 1>;    // SOIE
            using EGE = Field<9, 1>;    // EGE
            using SE = Field<16, 1>;    // SE
            using SPOL = Field<17, 2>;    // SPOL
            using NBREQ = Field<19, 5>;    // NBREQ
            using SYNC_ID = Field<24, 3>;    // SYNC_ID
        };

        // DMAMUX request line multiplexer channel 2 configuration register
        struct DMAMUX_C2CR : public Register<0x48002008> {
            using DMAREQ_ID = Field<0, 7>;    // DMAREQ_ID
            using SOIE = Field<8, 1>;    // SOIE
            using EGE = Field<9, 1>;    // EGE
            using SE = Field<16, 1>;    // SE
            using SPOL = Field<17, 2>;    // SPOL
            using NBREQ = Field<19, 5>;    // NBREQ
            using SYNC_ID = Field<24, 3>;    // SYNC_ID
        };

        // DMAMUX request line multiplexer channel 3 configuration register
        struct DMAMUX_C3CR : public Register<0x4800200c> {
            using DMAREQ_ID = Field<0, 7>;    // DMAREQ_ID
            using SOIE = Field<8, 1>;    // SOIE
            using EGE = Field<9, 1>;    // EGE
            using SE = Field<16, 1>;    // SE
            using SPOL = Field<17, 2>;    // SPOL
            using NBREQ = Field<19, 5>;    // NBREQ
            using SYNC_ID = Field<24, 3>;    // SYNC_ID
        };

        // DMAMUX request line multiplexer channel 4 configuration register
        struct DMAMUX_C4CR : public Register<0x48002010> {
            using DMAREQ_ID = Field<0, 7>;    // DMAREQ_ID
            using SOIE = Field<8, 1>;    // SOIE
            using EGE = Field<9, 1>;    // EGE
            using SE = Field<16, 1>;    // SE
            using SPOL = Field<17, 2>;    // SPOL
            using NBREQ = Field<19, 5>;    // NBREQ
            using SYNC_ID = Field<24, 3>;    // SYNC_ID
        };

        // DMAMUX request line multiplexer channel 5 configuration register
        struct DMAMUX_C5CR : public Register<0x48002014> {
            using DMAREQ_ID = Field<0, 7>;    // DMAREQ_ID
            using SOIE = Field<8, 1>;    // SOIE
            using EGE = Field<9, 1>;    // EGE
            using SE = Field<16, 1>;    // SE
            using SPOL = Field<17, 2>;    // SPOL
            using NBREQ = Field<19, 5>;    // NBREQ
            using SYNC_ID = Field<24, 3>;    // SYNC_ID
        };

        // DMAMUX request line multiplexer channel 6 configuration register
        struct DMAMUX_C6CR : public Register<0x48002018> {
            using DMAREQ_ID = Field<0, 7>;    // DMAREQ_ID
            using SOIE = Field<8, 1>;    // SOIE
            using EGE = Field<9, 1>;    // EGE
            using SE = Field<16, 1>;    // SE
            using SPOL = Field<17, 2>;    // SPOL
            using NBREQ = Field<19, 5>;    // NBREQ
            using SYNC_ID = Field<24, 3>;    // SYNC_ID
        };

        // DMAMUX request line multiplexer channel 7 configuration register
        struct DMAMUX_C7CR : public Register<0x4800201c> {
            using DMAREQ_ID = Field<0, 7>;    // DMAREQ_ID
            using SOIE = Field<8, 1>;    // SOIE
            using EGE = Field<9, 1>;    // EGE
            using SE = Field<16, 1>;    // SE
            using SPOL = Field<17, 2>;    // SPOL
            using NBREQ = Field<19, 5>;    // NBREQ
            using SYNC_ID = Field<24, 3>;    // SYNC_ID
        };

        // DMAMUX request line multiplexer channel 8 configuration register
        struct DMAMUX_C8CR : public Register<0x48002020> {
            using DMAREQ_ID = Field<0, 7>;    // DMAREQ_ID
            using SOIE = Field<8, 1>;    // SOIE
            using EGE = Field<9, 1>;    // EGE
            using SE = Field<16, 1>;    // SE
            using SPOL = Field<17, 2>;    // SPOL
            using NBREQ = Field<19, 5>;    // NBREQ
            using SYNC_ID = Field<24, 3>;    // SYNC_ID
        };

        // DMAMUX request line multiplexer channel 9 configuration register
        struct DMAMUX_C9CR : public Register<0x48002024> {
            using DMAREQ_ID = Field<0, 7>;    // DMAREQ_ID
            using SOIE = Field<8, 1>;    // SOIE
            using EGE = Field<9, 1>;    // EGE
            using SE = Field<16, 1>;    // SE
            using SPOL = Field<17, 2>;    // SPOL
            using NBREQ = Field<19, 5>;    // NBREQ
            using SYNC_ID = Field<24, 3>;    // SYNC_ID
        };

        // DMAMUX request line multiplexer channel 10 configuration register
        struct DMAMUX_C10CR : public Register<0x48002028> {
            using DMAREQ_ID = Field<0, 7>;    // DMAREQ_ID
            using SOIE = Field<8, 1>;    // SOIE
            using EGE = Field<9, 1>;    // EGE
            using SE = Field<16, 1>;    // SE
            using SPOL = Field<17, 2>;    // SPOL
            using NBREQ = Field<19, 5>;    // NBREQ
            using SYNC_ID = Field<24, 3>;    // SYNC_ID
        };

        // DMAMUX request line multiplexer channel 11 configuration register
        struct DMAMUX_C11CR : public Register<0x4800202c> {
            using DMAREQ_ID = Field<0, 7>;    // DMAREQ_ID
            using SOIE = Field<8, 1>;    // SOIE
            using EGE = Field<9, 1>;    // EGE
            using SE = Field<16, 1>;    // SE
            using SPOL = Field<17, 2>;    // SPOL
            using NBREQ = Field<19, 5>;    // NBREQ
            using SYNC_ID = Field<24, 3>;    // SYNC_ID
        };

        // DMAMUX request line multiplexer channel 12 configuration register
        struct DMAMUX_C12CR : public Register<0x48002030> {
            using DMAREQ_ID = Field<0, 7>;    // DMAREQ_ID
            using SOIE = Field<8, 1>;    // SOIE
            using EGE = Field<9, 1>;    // EGE
            using SE = Field<16, 1>;    // SE
            using SPOL = Field<17, 2>;    // SPOL
            using NBREQ = Field<19, 5>;    // NBREQ
            using SYNC_ID = Field<24, 3>;    // SYNC_ID
        };

        // DMAMUX request line multiplexer channel 13 configuration register
        struct DMAMUX_C13CR : public Register<0x48002034> {
            using DMAREQ_ID = Field<0, 7>;    // DMAREQ_ID
            using SOIE = Field<8, 1>;    // SOIE
            using EGE = Field<9, 1>;    // EGE
            using SE = Field<16, 1>;    // SE
            using SPOL = Field<17, 2>;    // SPOL
            using NBREQ = Field<19, 5>;    // NBREQ
            using SYNC_ID = Field<24, 3>;    // SYNC_ID
        };

        // DMAMUX request line multiplexer channel 14 configuration register
        struct DMAMUX_C14CR : public Register<0x48002038> {
            using DMAREQ_ID = Field<0, 7>;    // DMAREQ_ID
            using SOIE = Field<8, 1>;    // SOIE
            using EGE = Field<9, 1>;    // EGE
            using SE = Field<16, 1>;    // SE
            using SPOL = Field<17, 2>;    // SPOL
            using NBREQ = Field<19, 5>;    // NBREQ
            using SYNC_ID = Field<24, 3>;    // SYNC_ID
        };

        // DMAMUX request line multiplexer channel 15 configuration register
        struct DMAMUX_C15CR : public Register<0x4800203c> {
            using DMAREQ_ID = Field<0, 7>;    // DMAREQ_ID
            using SOIE = Field<8, 1>;    // SOIE
            using EGE = Field<9, 1>;    // EGE
            using SE = Field<16, 1>;    // SE
            using SPOL = Field<17, 2>;    // SPOL
            using NBREQ = Field<19, 5>;    // NBREQ
            using SYNC_ID = Field<24, 3>;    // SYNC_ID
        };

        // DMAMUX request line multiplexer interrupt channel status register
        struct DMAMUX_CSR : public RegisterReadOnly<0x48002080> {
            using SOF0 = Field<0, 1>;    // SOF0
            using SOF1 = Field<1, 1>;    // SOF1
            using SOF2 = Field<2, 1>;    // SOF2
            using SOF3 = Field<3, 1>;    // SOF3
            using SOF4 = Field<4, 1>;    // SOF4
            using SOF5 = Field<5, 1>;    // SOF5
            using SOF6 = Field<6, 1>;    // SOF6
            using SOF7 = Field<7, 1>;    // SOF7
            using SOF8 = Field<8, 1>;    // SOF8
            using SOF9 = Field<9, 1>;    // SOF9
            using SOF10 = Field<10, 1>;    // SOF10
            using SOF11 = Field<11, 1>;    // SOF11
            using SOF12 = Field<12, 1>;    // SOF12
            using SOF13 = Field<13, 1>;    // SOF13
            using SOF14 = Field<14, 1>;    // SOF14
            using SOF15 = Field<15, 1>;    // SOF15
        };

        // DMAMUX request line multiplexer interrupt clear flag register
        struct DMAMUX_CFR : public RegisterWriteOnly<0x48002084> {
            using CSOF0 = Field<0, 1>;    // CSOF0
            using CSOF1 = Field<1, 1>;    // CSOF1
            using CSOF2 = Field<2, 1>;    // CSOF2
            using CSOF3 = Field<3, 1>;    // CSOF3
            using CSOF4 = Field<4, 1>;    // CSOF4
            using CSOF5 = Field<5, 1>;    // CSOF5
            using CSOF6 = Field<6, 1>;    // CSOF6
            using CSOF7 = Field<7, 1>;    // CSOF7
            using CSOF8 = Field<8, 1>;    // CSOF8
            using CSOF9 = Field<9, 1>;    // CSOF9
            using CSOF10 = Field<10, 1>;    // CSOF10
            using CSOF11 = Field<11, 1>;    // CSOF11
            using CSOF12 = Field<12, 1>;    // CSOF12
            using CSOF13 = Field<13, 1>;    // CSOF13
            using CSOF14 = Field<14, 1>;    // CSOF14
            using CSOF15 = Field<15, 1>;    // CSOF15
        };

        // DMAMUX request generator channel 0 configuration register
        struct DMAMUX_RG0CR : public Register<0x48002100> {
            using SIG_ID = Field<0, 3>;    // SIG_ID
            using OIE = Field<8, 1>;    // OIE
            using GE = Field<16, 1>;    // GE
            using GPOL = Field<17, 2>;    // GPOL
            using GNBREQ = Field<19, 5>;    // GNBREQ
        };

        // DMAMUX request generator channel 1 configuration register
        struct DMAMUX_RG1CR : public Register<0x48002104> {
            using SIG_ID = Field<0, 3>;    // SIG_ID
            using OIE = Field<8, 1>;    // OIE
            using GE = Field<16, 1>;    // GE
            using GPOL = Field<17, 2>;    // GPOL
            using GNBREQ = Field<19, 5>;    // GNBREQ
        };

        // DMAMUX request generator channel 2 configuration register
        struct DMAMUX_RG2CR : public Register<0x48002108> {
            using SIG_ID = Field<0, 3>;    // SIG_ID
            using OIE = Field<8, 1>;    // OIE
            using GE = Field<16, 1>;    // GE
            using GPOL = Field<17, 2>;    // GPOL
            using GNBREQ = Field<19, 5>;    // GNBREQ
        };

        // DMAMUX request generator channel 3 configuration register
        struct DMAMUX_RG3CR : public Register<0x4800210c> {
            using SIG_ID = Field<0, 3>;    // SIG_ID
            using OIE = Field<8, 1>;    // OIE
            using GE = Field<16, 1>;    // GE
            using GPOL = Field<17, 2>;    // GPOL
            using GNBREQ = Field<19, 5>;    // GNBREQ
        };

        // DMAMUX request generator channel 4 configuration register
        struct DMAMUX_RG4CR : public Register<0x48002110> {
            using SIG_ID = Field<0, 3>;    // SIG_ID
            using OIE = Field<8, 1>;    // OIE
            using GE = Field<16, 1>;    // GE
            using GPOL = Field<17, 2>;    // GPOL
            using GNBREQ = Field<19, 5>;    // GNBREQ
        };

        // DMAMUX request generator channel 5 configuration register
        struct DMAMUX_RG5CR : public Register<0x48002114> {
            using SIG_ID = Field<0, 3>;    // SIG_ID
            using OIE = Field<8, 1>;    // OIE
            using GE = Field<16, 1>;    // GE
            using GPOL = Field<17, 2>;    // GPOL
            using GNBREQ = Field<19, 5>;    // GNBREQ
        };

        // DMAMUX request generator channel 6 configuration register
        struct DMAMUX_RG6CR : public Register<0x48002118> {
            using SIG_ID = Field<0, 3>;    // SIG_ID
            using OIE = Field<8, 1>;    // OIE
            using GE = Field<16, 1>;    // GE
            using GPOL = Field<17, 2>;    // GPOL
            using GNBREQ = Field<19, 5>;    // GNBREQ
        };

        // DMAMUX request generator channel 7 configuration register
        struct DMAMUX_RG7CR : public Register<0x4800211c> {
            using SIG_ID = Field<0, 3>;    // SIG_ID
            using OIE = Field<8, 1>;    // OIE
            using GE = Field<16, 1>;    // GE
            using GPOL = Field<17, 2>;    // GPOL
            using GNBREQ = Field<19, 5>;    // GNBREQ
        };

        // DMAMUX request generator interrupt status register
        struct DMAMUX_RGSR : public RegisterReadOnly<0x48002140> {
            using OF0 = Field<0, 1>;    // OF0
            using OF1 = Field<1, 1>;    // OF1
            using OF2 = Field<2, 1>;    // OF2
            using OF3 = Field<3, 1>;    // OF3
            using OF4 = Field<4, 1>;    // OF4
            using OF5 = Field<5, 1>;    // OF5
            using OF6 = Field<6, 1>;    // OF6
            using OF7 = Field<7, 1>;    // OF7
        };

        // DMAMUX request generator interrupt clear flag register
        struct DMAMUX_RGCFR : public RegisterWriteOnly<0x48002144> {
            using COF0 = Field<0, 1>;    // COF0
            using COF1 = Field<1, 1>;    // COF1
            using COF2 = Field<2, 1>;    // COF2
            using COF3 = Field<3, 1>;    // COF3
            using COF4 = Field<4, 1>;    // COF4
            using COF5 = Field<5, 1>;    // COF5
            using COF6 = Field<6, 1>;    // COF6
            using COF7 = Field<7, 1>;    // COF7
        };

        // DMAMUX hardware configuration 2 register
        struct DMAMUX_HWCFGR2 : public RegisterReadOnly<0x480023ec> {
            using NUM_DMA_EXT_REQ = Field<0, 8>;    // NUM_DMA_EXT_REQ
        };

        // DMAMUX hardware configuration 1 register
        struct DMAMUX_HWCFGR1 : public RegisterReadOnly<0x480023f0> {
            using NUM_DMA_STREAMS = Field<0, 8>;    // NUM_DMA_STREAMS
            using NUM_DMA_PERIPH_REQ = Field<8, 8>;    // NUM_DMA_PERIPH_REQ
            using NUM_DMA_TRIG = Field<16, 8>;    // NUM_DMA_TRIG
            using NUM_DMA_REQGEN = Field<24, 8>;    // NUM_DMA_REQGEN
        };

        // This register identifies the IP version.
        struct DMAMUX_VERR : public RegisterReadOnly<0x480023f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // This register identifies the IP.
        struct DMAMUX_IPIDR : public RegisterReadOnly<0x480023f8> {
            using ID = Field<0, 32>;    // ID
        };

        // DMAMUX size identification register
        struct DMAMUX_SIDR : public RegisterReadOnly<0x480023fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // DSIHOST1
    struct DSIHOST1 {
        // DSI Host version register
        struct DSI_VR : public RegisterReadOnly<0x5a000000> {
            using VERSION = Field<0, 32>;    // VERSION
        };

        // DSI Host control register
        struct DSI_CR : public Register<0x5a000004> {
            using EN = Field<0, 1>;    // EN
        };

        // DSI Host clock control register
        struct DSI_CCR : public Register<0x5a000008> {
            using TXECKDIV = Field<0, 8>;    // TXECKDIV
            using TOCKDIV = Field<8, 8>;    // TOCKDIV
        };

        // DSI Host LTDC VCID register
        struct DSI_LVCIDR : public Register<0x5a00000c> {
            using VCID = Field<0, 2>;    // VCID
        };

        // DSI Host LTDC color coding register
        struct DSI_LCOLCR : public Register<0x5a000010> {
            using COLC = Field<0, 4>;    // COLC
            using LPE = Field<8, 1>;    // LPE
        };

        // DSI Host LTDC polarity configuration register
        struct DSI_LPCR : public Register<0x5a000014> {
            using DEP = Field<0, 1>;    // DEP
            using VSP = Field<1, 1>;    // VSP
            using HSP = Field<2, 1>;    // HSP
        };

        // DSI Host low-power mode configuration register
        struct DSI_LPMCR : public Register<0x5a000018> {
            using VLPSIZE = Field<0, 8>;    // VLPSIZE
            using LPSIZE = Field<16, 8>;    // LPSIZE
        };

        // DSI Host protocol configuration register
        struct DSI_PCR : public Register<0x5a00002c> {
            using ETTXE = Field<0, 1>;    // ETTXE
            using ETRXE = Field<1, 1>;    // ETRXE
            using BTAE = Field<2, 1>;    // BTAE
            using ECCRXE = Field<3, 1>;    // ECCRXE
            using CRCRXE = Field<4, 1>;    // CRCRXE
        };

        // DSI Host generic VCID register
        struct DSI_GVCIDR : public RegisterReadOnly<0x5a000030> {
            using VCID = Field<0, 2>;    // VCID
        };

        // DSI Host mode configuration register
        struct DSI_MCR : public Register<0x5a000034> {
            using CMDM = Field<0, 1>;    // CMDM
        };

        // DSI Host video mode configuration register
        struct DSI_VMCR : public Register<0x5a000038> {
            using VMT = Field<0, 2>;    // VMT
            using LPVSAE = Field<8, 1>;    // LPVSAE
            using LPVBPE = Field<9, 1>;    // LPVBPE
            using LPVFPE = Field<10, 1>;    // LPVFPE
            using LPVAE = Field<11, 1>;    // LPVAE
            using LPHBPE = Field<12, 1>;    // LPHBPE
            using LPHFPE = Field<13, 1>;    // LPHFPE
            using FBTAAE = Field<14, 1>;    // FBTAAE
            using LPCE = Field<15, 1>;    // LPCE
            using PGE = Field<16, 1>;    // PGE
            using PGM = Field<20, 1>;    // PGM
            using PGO = Field<24, 1>;    // PGO
        };

        // DSI Host video packet configuration register
        struct DSI_VPCR : public Register<0x5a00003c> {
            using VPSIZE = Field<0, 14>;    // VPSIZE
        };

        // DSI Host video chunks configuration register
        struct DSI_VCCR : public Register<0x5a000040> {
            using NUMC = Field<0, 13>;    // NUMC
        };

        // DSI Host video null packet configuration register
        struct DSI_VNPCR : public Register<0x5a000044> {
            using NPSIZE = Field<0, 13>;    // NPSIZE
        };

        // DSI Host video HSA configuration register
        struct DSI_VHSACR : public Register<0x5a000048> {
            using HSA = Field<0, 12>;    // HSA
        };

        // DSI Host video HBP configuration register
        struct DSI_VHBPCR : public Register<0x5a00004c> {
            using HBP = Field<0, 12>;    // HBP
        };

        // DSI Host video line configuration register
        struct DSI_VLCR : public Register<0x5a000050> {
            using HLINE = Field<0, 15>;    // HLINE
        };

        // DSI Host video VSA configuration register
        struct DSI_VVSACR : public Register<0x5a000054> {
            using VSA = Field<0, 10>;    // VSA
        };

        // DSI Host video VBP configuration register
        struct DSI_VVBPCR : public Register<0x5a000058> {
            using VBP = Field<0, 10>;    // VBP
        };

        // DSI Host video VFP configuration register
        struct DSI_VVFPCR : public Register<0x5a00005c> {
            using VFP = Field<0, 10>;    // VFP
        };

        // DSI Host video VA configuration register
        struct DSI_VVACR : public Register<0x5a000060> {
            using VA = Field<0, 14>;    // VA
        };

        // DSI Host LTDC command configuration register
        struct DSI_LCCR : public Register<0x5a000064> {
            using CMDSIZE = Field<0, 16>;    // CMDSIZE
        };

        // DSI Host command mode configuration register
        struct DSI_CMCR : public Register<0x5a000068> {
            using TEARE = Field<0, 1>;    // TEARE
            using ARE = Field<1, 1>;    // ARE
            using GSW0TX = Field<8, 1>;    // GSW0TX
            using GSW1TX = Field<9, 1>;    // GSW1TX
            using GSW2TX = Field<10, 1>;    // GSW2TX
            using GSR0TX = Field<11, 1>;    // GSR0TX
            using GSR1TX = Field<12, 1>;    // GSR1TX
            using GSR2TX = Field<13, 1>;    // GSR2TX
            using GLWTX = Field<14, 1>;    // GLWTX
            using DSW0TX = Field<16, 1>;    // DSW0TX
            using DSW1TX = Field<17, 1>;    // DSW1TX
            using DSR0TX = Field<18, 1>;    // DSR0TX
            using DLWTX = Field<19, 1>;    // DLWTX
            using MRDPS = Field<24, 1>;    // MRDPS
        };

        // DSI Host generic header configuration register
        struct DSI_GHCR : public Register<0x5a00006c> {
            using DT = Field<0, 6>;    // DT
            using VCID = Field<6, 2>;    // VCID
            using WCLSB = Field<8, 8>;    // WCLSB
            using WCMSB = Field<16, 8>;    // WCMSB
        };

        // DSI Host generic payload data register
        struct DSI_GPDR : public Register<0x5a000070> {
            using DATA1 = Field<0, 8>;    // DATA1
            using DATA2 = Field<8, 8>;    // DATA2
            using DATA3 = Field<16, 8>;    // DATA3
            using DATA4 = Field<24, 8>;    // DATA4
        };

        // DSI Host generic packet status register
        struct DSI_GPSR : public RegisterReadOnly<0x5a000074> {
            using CMDFE = Field<0, 1>;    // CMDFE
            using CMDFF = Field<1, 1>;    // CMDFF
            using PWRFE = Field<2, 1>;    // PWRFE
            using PWRFF = Field<3, 1>;    // PWRFF
            using PRDFE = Field<4, 1>;    // PRDFE
            using PRDFF = Field<5, 1>;    // PRDFF
            using RCB = Field<6, 1>;    // RCB
        };

        // DSI Host timeout counter configuration register 0
        struct DSI_TCCR0 : public Register<0x5a000078> {
            using LPRX_TOCNT = Field<0, 16>;    // LPRX_TOCNT
            using HSTX_TOCNT = Field<16, 16>;    // HSTX_TOCNT
        };

        // DSI Host timeout counter configuration register 1
        struct DSI_TCCR1 : public Register<0x5a00007c> {
            using HSRD_TOCNT = Field<0, 16>;    // HSRD_TOCNT
        };

        // DSI Host timeout counter configuration register 2
        struct DSI_TCCR2 : public Register<0x5a000080> {
            using LPRD_TOCNT = Field<0, 16>;    // LPRD_TOCNT
        };

        // DSI Host timeout counter configuration register 3
        struct DSI_TCCR3 : public Register<0x5a000084> {
            using HSWR_TOCNT = Field<0, 16>;    // HSWR_TOCNT
            using PM = Field<24, 1>;    // PM
        };

        // DSI Host timeout counter configuration register 4
        struct DSI_TCCR4 : public Register<0x5a000088> {
            using LPWR_TOCNT = Field<0, 16>;    // LPWR_TOCNT
        };

        // DSI Host timeout counter configuration register 5
        struct DSI_TCCR5 : public Register<0x5a00008c> {
            using BTA_TOCNT = Field<0, 16>;    // BTA_TOCNT
        };

        // DSI Host clock lane configuration register
        struct DSI_CLCR : public Register<0x5a000094> {
            using DPCC = Field<0, 1>;    // DPCC
            using ACR = Field<1, 1>;    // ACR
        };

        // DSI Host clock lane timer configuration register
        struct DSI_CLTCR : public Register<0x5a000098> {
            using LP2HS_TIME = Field<0, 10>;    // LP2HS_TIME
            using HS2LP_TIME = Field<16, 10>;    // HS2LP_TIME
        };

        // DSI Host data lane timer configuration register
        struct DSI_DLTCR : public Register<0x5a00009c> {
            using LP2HS_TIME = Field<0, 10>;    // LP2HS_TIME
            using HS2LP_TIME = Field<16, 10>;    // HS2LP_TIME
        };

        // DSI Host PHY control register
        struct DSI_PCTLR : public Register<0x5a0000a0> {
            using DEN = Field<1, 1>;    // DEN
            using CKE = Field<2, 1>;    // CKE
        };

        // DSI Host PHY configuration register
        struct DSI_PCONFR : public Register<0x5a0000a4> {
            using NL = Field<0, 2>;    // NL
            using SW_TIME = Field<8, 8>;    // SW_TIME
        };

        // DSI Host PHY ULPS control register
        struct DSI_PUCR : public Register<0x5a0000a8> {
            using URCL = Field<0, 1>;    // URCL
            using UECL = Field<1, 1>;    // UECL
            using URDL = Field<2, 1>;    // URDL
            using UEDL = Field<3, 1>;    // UEDL
        };

        // DSI Host PHY TX triggers configuration register
        struct DSI_PTTCR : public Register<0x5a0000ac> {
            using TX_TRIG = Field<0, 4>;    // TX_TRIG
        };

        // DSI Host PHY status register
        struct DSI_PSR : public RegisterReadOnly<0x5a0000b0> {
            using PD = Field<1, 1>;    // PD
            using PSSC = Field<2, 1>;    // PSSC
            using UANC = Field<3, 1>;    // UANC
            using PSS0 = Field<4, 1>;    // PSS0
            using UAN0 = Field<5, 1>;    // UAN0
            using RUE0 = Field<6, 1>;    // RUE0
            using PSS1 = Field<7, 1>;    // PSS1
            using UAN1 = Field<8, 1>;    // UAN1
        };

        // DSI Host interrupt and status register 0
        struct DSI_ISR0 : public RegisterReadOnly<0x5a0000bc> {
            using AE0 = Field<0, 1>;    // AE0
            using AE1 = Field<1, 1>;    // AE1
            using AE2 = Field<2, 1>;    // AE2
            using AE3 = Field<3, 1>;    // AE3
            using AE4 = Field<4, 1>;    // AE4
            using AE5 = Field<5, 1>;    // AE5
            using AE6 = Field<6, 1>;    // AE6
            using AE7 = Field<7, 1>;    // AE7
            using AE8 = Field<8, 1>;    // AE8
            using AE9 = Field<9, 1>;    // AE9
            using AE10 = Field<10, 1>;    // AE10
            using AE11 = Field<11, 1>;    // AE11
            using AE12 = Field<12, 1>;    // AE12
            using AE13 = Field<13, 1>;    // AE13
            using AE14 = Field<14, 1>;    // AE14
            using AE15 = Field<15, 1>;    // AE15
            using PE0 = Field<16, 1>;    // PE0
            using PE1 = Field<17, 1>;    // PE1
            using PE2 = Field<18, 1>;    // PE2
            using PE3 = Field<19, 1>;    // PE3
            using PE4 = Field<20, 1>;    // PE4
        };

        // DSI Host interrupt and status register 1
        struct DSI_ISR1 : public RegisterReadOnly<0x5a0000c0> {
            using TOHSTX = Field<0, 1>;    // TOHSTX
            using TOLPRX = Field<1, 1>;    // TOLPRX
            using ECCSE = Field<2, 1>;    // ECCSE
            using ECCME = Field<3, 1>;    // ECCME
            using CRCE = Field<4, 1>;    // CRCE
            using PSE = Field<5, 1>;    // PSE
            using EOTPE = Field<6, 1>;    // EOTPE
            using LPWRE = Field<7, 1>;    // LPWRE
            using GCWRE = Field<8, 1>;    // GCWRE
            using GPWRE = Field<9, 1>;    // GPWRE
            using GPTXE = Field<10, 1>;    // GPTXE
            using GPRDE = Field<11, 1>;    // GPRDE
            using GPRXE = Field<12, 1>;    // GPRXE
        };

        // DSI Host interrupt enable register 0
        struct DSI_IER0 : public Register<0x5a0000c4> {
            using AE0IE = Field<0, 1>;    // AE0IE
            using AE1IE = Field<1, 1>;    // AE1IE
            using AE2IE = Field<2, 1>;    // AE2IE
            using AE3IE = Field<3, 1>;    // AE3IE
            using AE4IE = Field<4, 1>;    // AE4IE
            using AE5IE = Field<5, 1>;    // AE5IE
            using AE6IE = Field<6, 1>;    // AE6IE
            using AE7IE = Field<7, 1>;    // AE7IE
            using AE8IE = Field<8, 1>;    // AE8IE
            using AE9IE = Field<9, 1>;    // AE9IE
            using AE10IE = Field<10, 1>;    // AE10IE
            using AE11IE = Field<11, 1>;    // AE11IE
            using AE12IE = Field<12, 1>;    // AE12IE
            using AE13IE = Field<13, 1>;    // AE13IE
            using AE14IE = Field<14, 1>;    // AE14IE
            using AE15IE = Field<15, 1>;    // AE15IE
            using PE0IE = Field<16, 1>;    // PE0IE
            using PE1IE = Field<17, 1>;    // PE1IE
            using PE2IE = Field<18, 1>;    // PE2IE
            using PE3IE = Field<19, 1>;    // PE3IE
            using PE4IE = Field<20, 1>;    // PE4IE
        };

        // DSI Host interrupt enable register 1
        struct DSI_IER1 : public Register<0x5a0000c8> {
            using TOHSTXIE = Field<0, 1>;    // TOHSTXIE
            using TOLPRXIE = Field<1, 1>;    // TOLPRXIE
            using ECCSEIE = Field<2, 1>;    // ECCSEIE
            using ECCMEIE = Field<3, 1>;    // ECCMEIE
            using CRCEIE = Field<4, 1>;    // CRCEIE
            using PSEIE = Field<5, 1>;    // PSEIE
            using EOTPEIE = Field<6, 1>;    // EOTPEIE
            using LPWREIE = Field<7, 1>;    // LPWREIE
            using GCWREIE = Field<8, 1>;    // GCWREIE
            using GPWREIE = Field<9, 1>;    // GPWREIE
            using GPTXEIE = Field<10, 1>;    // GPTXEIE
            using GPRDEIE = Field<11, 1>;    // GPRDEIE
            using GPRXEIE = Field<12, 1>;    // GPRXEIE
        };

        // DSI Host force interrupt register 0
        struct DSI_FIR0 : public RegisterWriteOnly<0x5a0000d8> {
            using FAE0 = Field<0, 1>;    // FAE0
            using FAE1 = Field<1, 1>;    // FAE1
            using FAE2 = Field<2, 1>;    // FAE2
            using FAE3 = Field<3, 1>;    // FAE3
            using FAE4 = Field<4, 1>;    // FAE4
            using FAE5 = Field<5, 1>;    // FAE5
            using FAE6 = Field<6, 1>;    // FAE6
            using FAE7 = Field<7, 1>;    // FAE7
            using FAE8 = Field<8, 1>;    // FAE8
            using FAE9 = Field<9, 1>;    // FAE9
            using FAE10 = Field<10, 1>;    // FAE10
            using FAE11 = Field<11, 1>;    // FAE11
            using FAE12 = Field<12, 1>;    // FAE12
            using FAE13 = Field<13, 1>;    // FAE13
            using FAE14 = Field<14, 1>;    // FAE14
            using FAE15 = Field<15, 1>;    // FAE15
            using FPE0 = Field<16, 1>;    // FPE0
            using FPE1 = Field<17, 1>;    // FPE1
            using FPE2 = Field<18, 1>;    // FPE2
            using FPE3 = Field<19, 1>;    // FPE3
            using FPE4 = Field<20, 1>;    // FPE4
        };

        // DSI Host force interrupt register 1
        struct DSI_FIR1 : public RegisterWriteOnly<0x5a0000dc> {
            using FTOHSTX = Field<0, 1>;    // FTOHSTX
            using FTOLPRX = Field<1, 1>;    // FTOLPRX
            using FECCSE = Field<2, 1>;    // FECCSE
            using FECCME = Field<3, 1>;    // FECCME
            using FCRCE = Field<4, 1>;    // FCRCE
            using FPSE = Field<5, 1>;    // FPSE
            using FEOTPE = Field<6, 1>;    // FEOTPE
            using FLPWRE = Field<7, 1>;    // FLPWRE
            using FGCWRE = Field<8, 1>;    // FGCWRE
            using FGPWRE = Field<9, 1>;    // FGPWRE
            using FGPTXE = Field<10, 1>;    // FGPTXE
            using FGPRDE = Field<11, 1>;    // FGPRDE
            using FGPRXE = Field<12, 1>;    // FGPRXE
        };

        // DSI Host data lane timer read configuration register
        struct DSI_DLTRCR : public Register<0x5a0000f4> {
            using MRD_TIME = Field<0, 15>;    // MRD_TIME
        };

        // DSI Host video shadow control register
        struct DSI_VSCR : public Register<0x5a000100> {
            using EN = Field<0, 1>;    // EN
            using UR = Field<8, 1>;    // UR
        };

        // DSI Host LTDC current VCID register
        struct DSI_LCVCIDR : public Register<0x5a00010c> {
            using VCID = Field<0, 2>;    // VCID
        };

        // DSI Host LTDC current color coding register
        struct DSI_LCCCR : public RegisterReadOnly<0x5a000110> {
            using COLC = Field<0, 4>;    // COLC
            using LPE = Field<8, 1>;    // LPE
        };

        // DSI Host low-power mode current configuration register
        struct DSI_LPMCCR : public RegisterReadOnly<0x5a000118> {
            using VLPSIZE = Field<0, 8>;    // VLPSIZE
            using LPSIZE = Field<16, 8>;    // LPSIZE
        };

        // DSI Host video mode current configuration register
        struct DSI_VMCCR : public RegisterReadOnly<0x5a000138> {
            using VMT = Field<0, 2>;    // VMT
            using LPVSAE = Field<2, 1>;    // LPVSAE
            using LPVBPE = Field<3, 1>;    // LPVBPE
            using LPVFPE = Field<4, 1>;    // LPVFPE
            using LPVAE = Field<5, 1>;    // LPVAE
            using LPHBPE = Field<6, 1>;    // LPHBPE
            using LPHFE = Field<7, 1>;    // LPHFE
            using FBTAAE = Field<8, 1>;    // FBTAAE
            using LPCE = Field<9, 1>;    // LPCE
        };

        // DSI Host video packet current configuration register
        struct DSI_VPCCR : public RegisterReadOnly<0x5a00013c> {
            using VPSIZE = Field<0, 14>;    // VPSIZE
        };

        // DSI Host video chunks current configuration register
        struct DSI_VCCCR : public RegisterReadOnly<0x5a000140> {
            using NUMC = Field<0, 13>;    // NUMC
        };

        // DSI Host video null packet current configuration register
        struct DSI_VNPCCR : public RegisterReadOnly<0x5a000144> {
            using NPSIZE = Field<0, 13>;    // NPSIZE
        };

        // DSI Host video HSA current configuration register
        struct DSI_VHSACCR : public RegisterReadOnly<0x5a000148> {
            using HSA = Field<0, 12>;    // HSA
        };

        // DSI Host video HBP current configuration register
        struct DSI_VHBPCCR : public RegisterReadOnly<0x5a00014c> {
            using HBP = Field<0, 12>;    // HBP
        };

        // DSI Host video line current configuration register
        struct DSI_VLCCR : public RegisterReadOnly<0x5a000150> {
            using HLINE = Field<0, 15>;    // HLINE
        };

        // DSI Host video VSA current configuration register
        struct DSI_VVSACCR : public RegisterReadOnly<0x5a000154> {
            using VSA = Field<0, 10>;    // VSA
        };

        // DSI Host video VBP current configuration register
        struct DSI_VVBPCCR : public RegisterReadOnly<0x5a000158> {
            using VBP = Field<0, 10>;    // VBP
        };

        // DSI Host video VFP current configuration register
        struct DSI_VVFPCCR : public RegisterReadOnly<0x5a00015c> {
            using VFP = Field<0, 10>;    // VFP
        };

        // DSI Host video VA current configuration register
        struct DSI_VVACCR : public RegisterReadOnly<0x5a000160> {
            using VA = Field<0, 14>;    // VA
        };

        // DSI wrapper configuration register
        struct DSI_WCFGR : public Register<0x5a000400> {
            using DSIM = Field<0, 1>;    // DSIM
            using COLMUX = Field<1, 3>;    // COLMUX
            using TESRC = Field<4, 1>;    // TESRC
            using TEPOL = Field<5, 1>;    // TEPOL
            using AR = Field<6, 1>;    // AR
            using VSPOL = Field<7, 1>;    // VSPOL
        };

        // DSI wrapper control register
        struct DSI_WCR : public Register<0x5a000404> {
            using COLM = Field<0, 1>;    // COLM
            using SHTDN = Field<1, 1>;    // SHTDN
            using LTDCEN = Field<2, 1>;    // LTDCEN
            using DSIEN = Field<3, 1>;    // DSIEN
        };

        // DSI wrapper interrupt enable register
        struct DSI_WIER : public Register<0x5a000408> {
            using TEIE = Field<0, 1>;    // TEIE
            using ERIE = Field<1, 1>;    // ERIE
            using PLLLIE = Field<9, 1>;    // PLLLIE
            using PLLUIE = Field<10, 1>;    // PLLUIE
            using RRIE = Field<13, 1>;    // RRIE
        };

        // DSI wrapper interrupt and status register
        struct DSI_WISR : public RegisterReadOnly<0x5a00040c> {
            using TEIF = Field<0, 1>;    // TEIF
            using ERIF = Field<1, 1>;    // ERIF
            using BUSY = Field<2, 1>;    // BUSY
            using PLLLS = Field<8, 1>;    // PLLLS
            using PLLLIF = Field<9, 1>;    // PLLLIF
            using PLLUIF = Field<10, 1>;    // PLLUIF
            using RRS = Field<12, 1>;    // RRS
            using RRIF = Field<13, 1>;    // RRIF
        };

        // DSI wrapper interrupt flag clear register
        struct DSI_WIFCR : public RegisterWriteOnly<0x5a000410> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CERIF = Field<1, 1>;    // CERIF
            using CPLLLIF = Field<9, 1>;    // CPLLLIF
            using CPLLUIF = Field<10, 1>;    // CPLLUIF
            using CRRIF = Field<13, 1>;    // CRRIF
        };

        // DSI wrapper PHY configuration register 0
        struct DSI_WPCR0 : public Register<0x5a000418> {
            using UIX4 = Field<0, 6>;    // UIX4
            using SWCL = Field<6, 1>;    // SWCL
            using SWDL0 = Field<7, 1>;    // SWDL0
            using SWDL1 = Field<8, 1>;    // SWDL1
            using HSICL = Field<9, 1>;    // HSICL
            using HSIDL0 = Field<10, 1>;    // HSIDL0
            using HSIDL1 = Field<11, 1>;    // HSIDL1
            using FTXSMCL = Field<12, 1>;    // FTXSMCL
            using FTXSMDL = Field<13, 1>;    // FTXSMDL
            using CDOFFDL = Field<14, 1>;    // CDOFFDL
            using TDDL = Field<16, 1>;    // TDDL
        };

        // This register shall be programmed only when DSI is stopped (CR. DSIEN=0 and CR.EN = 0).
        struct DSI_WPCR1 : public Register<0x5a00041c> {
            using SKEWCL = Field<0, 2>;    // SKEWCL
            using SKEWDL = Field<2, 2>;    // SKEWDL
            using LPTXSRCL = Field<6, 2>;    // LPTXSRCL
            using LPTXSRDL = Field<8, 2>;    // LPTXSRDL
            using SDDCCL = Field<12, 1>;    // SDDCCL
            using SDDCDL = Field<13, 1>;    // SDDCDL
            using HSTXSRUCL = Field<16, 1>;    // HSTXSRUCL
            using HSTXSRDCL = Field<17, 1>;    // HSTXSRDCL
            using HSTXSRUDL = Field<18, 1>;    // HSTXSRUDL
            using HSTXSRDDL = Field<19, 1>;    // HSTXSRDDL
        };

        // DSI wrapper regulator and PLL control register
        struct DSI_WRPCR : public Register<0x5a000430> {
            using PLLEN = Field<0, 1>;    // PLLEN
            using NDIV = Field<2, 7>;    // NDIV
            using IDF = Field<11, 4>;    // IDF
            using ODF = Field<16, 2>;    // ODF
            using REGEN = Field<24, 1>;    // REGEN
            using BGREN = Field<28, 1>;    // BGREN
        };

        // DSI Host hardware configuration register
        struct DSI_HWCFGR : public RegisterReadOnly<0x5a0007f0> {
            using TECHNO = Field<0, 4>;    // TECHNO
            using FIFOSIZE = Field<4, 12>;    // FIFOSIZE
        };

        // DSI Host version register
        struct DSI_VERR : public RegisterReadOnly<0x5a0007f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // DSI Host identification register
        struct DSI_IPIDR : public RegisterReadOnly<0x5a0007f8> {
            using ID = Field<0, 32>;    // ID
        };

        // DSI Host size identification register
        struct DSI_SIDR : public RegisterReadOnly<0x5a0007fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // DTS register block
    struct DTS {
        // DTS_CFGR1 is the configuration register for temperature sensor 1.
        struct DTS_CFGR1 : public Register<0x50028000> {
            using TS1_EN = Field<0, 1>;    // TS1_EN
            using TS1_START = Field<4, 1>;    // TS1_START
            using TS1_INTRIG_SEL = Field<8, 4>;    // TS1_INTRIG_SEL
            using TS1_SMP_TIME = Field<16, 4>;    // TS1_SMP_TIME
            using REFCLK_SEL = Field<20, 1>;    // REFCLK_SEL
            using Q_MEAS_opt = Field<21, 1>;    // Q_MEAS_opt
            using HSREF_CLK_DIV = Field<24, 7>;    // HSREF_CLK_DIV
        };

        // DTS_T0VALR1 contains the value of the factory calibration temperature (T0) for temperature sensor 1. The system reset value is factory trimmed.
        struct DTS_T0VALR1 : public RegisterReadOnly<0x50028008> {
            using TS1_FMT0 = Field<0, 16>;    // TS1_FMT0
            using TS1_T0 = Field<16, 2>;    // TS1_T0
        };

        // The DTS_RAMPVALR is the ramp coefficient for the temperature sensor. The system reset value is factory trimmed.
        struct DTS_RAMPVALR : public RegisterReadOnly<0x50028010> {
            using TS1_RAMP_COEFF = Field<0, 16>;    // TS1_RAMP_COEFF
        };

        // DTS_ITR1 contains the threshold values for sensor 1.
        struct DTS_ITR1 : public Register<0x50028014> {
            using TS1_LITTHD = Field<0, 16>;    // TS1_LITTHD
            using TS1_HITTHD = Field<16, 16>;    // TS1_HITTHD
        };

        // The DTS_DR contains the number of REF_CLK cycles used to compute the FM(T) frequency.
        struct DTS_DR : public Register<0x5002801c> {
            using TS1_MFREQ = Field<0, 16>;    // TS1_MFREQ
        };

        // Temperature sensor status register
        struct DTS_SR : public RegisterReadOnly<0x50028020> {
            using TS1_ITEF = Field<0, 1>;    // TS1_ITEF
            using TS1_ITLF = Field<1, 1>;    // TS1_ITLF
            using TS1_ITHF = Field<2, 1>;    // TS1_ITHF
            using TS1_AITEF = Field<4, 1>;    // TS1_AITEF
            using TS1_AITLF = Field<5, 1>;    // TS1_AITLF
            using TS1_AITHF = Field<6, 1>;    // TS1_AITHF
            using TS1_RDY = Field<15, 1>;    // TS1_RDY
        };

        // Temperature sensor interrupt enable register
        struct DTS_ITENR : public Register<0x50028024> {
            using TS1_ITEEN = Field<0, 1>;    // TS1_ITEEN
            using TS1_ITLEN = Field<1, 1>;    // TS1_ITLEN
            using TS1_ITHEN = Field<2, 1>;    // TS1_ITHEN
            using TS1_AITEEN = Field<4, 1>;    // TS1_AITEEN
            using TS1_AITLEN = Field<5, 1>;    // TS1_AITLEN
            using TS1_AITHEN = Field<6, 1>;    // TS1_AITHEN
        };

        // DTS_ICIFR is the control register for the interrupt flags.
        struct DTS_ICIFR : public Register<0x50028028> {
            using TS1_CITEF = Field<0, 1>;    // TS1_CITEF
            using TS1_CITLF = Field<1, 1>;    // TS1_CITLF
            using TS1_CITHF = Field<2, 1>;    // TS1_CITHF
            using TS1_CAITEF = Field<4, 1>;    // TS1_CAITEF
            using TS1_CAITLF = Field<5, 1>;    // TS1_CAITLF
            using TS1_CAITHF = Field<6, 1>;    // TS1_CAITHF
        };

        // The DTS_OR contains general-purpose option bits.
        struct DTS_OR : public Register<0x5002802c> {
            using TS_Op0 = Field<0, 1>;    // TS_Op0
            using TS_Op1 = Field<1, 1>;    // TS_Op1
            using TS_Op2 = Field<2, 1>;    // TS_Op2
            using TS_Op3 = Field<3, 1>;    // TS_Op3
            using TS_Op4 = Field<4, 1>;    // TS_Op4
            using TS_Op5 = Field<5, 1>;    // TS_Op5
            using TS_Op6 = Field<6, 1>;    // TS_Op6
            using TS_Op7 = Field<7, 1>;    // TS_Op7
            using TS_Op8 = Field<8, 1>;    // TS_Op8
            using TS_Op9 = Field<9, 1>;    // TS_Op9
            using TS_Op10 = Field<10, 1>;    // TS_Op10
            using TS_Op11 = Field<11, 1>;    // TS_Op11
            using TS_Op12 = Field<12, 1>;    // TS_Op12
            using TS_Op13 = Field<13, 1>;    // TS_Op13
            using TS_Op14 = Field<14, 1>;    // TS_Op14
            using TS_Op15 = Field<15, 1>;    // TS_Op15
            using TS_Op16 = Field<16, 1>;    // TS_Op16
            using TS_Op17 = Field<17, 1>;    // TS_Op17
            using TS_Op18 = Field<18, 1>;    // TS_Op18
            using TS_Op19 = Field<19, 1>;    // TS_Op19
            using TS_Op20 = Field<20, 1>;    // TS_Op20
            using TS_Op21 = Field<21, 1>;    // TS_Op21
            using TS_Op22 = Field<22, 1>;    // TS_Op22
            using TS_Op23 = Field<23, 1>;    // TS_Op23
            using TS_Op24 = Field<24, 1>;    // TS_Op24
            using TS_Op25 = Field<25, 1>;    // TS_Op25
            using TS_Op26 = Field<26, 1>;    // TS_Op26
            using TS_Op27 = Field<27, 1>;    // TS_Op27
            using TS_Op28 = Field<28, 1>;    // TS_Op28
            using TS_Op29 = Field<29, 1>;    // TS_Op29
            using TS_Op30 = Field<30, 1>;    // TS_Op30
            using TS_Op31 = Field<31, 1>;    // TS_Op31
        };

    };

    // ETH_MAC_MMC
    struct ETH_MAC_MMC {
        // The MAC Configuration Register establishes the operating mode of the MAC.
        struct ETH_MACCR : public Register<0x5800a000> {
            using RE = Field<0, 1>;    // RE
            using TE = Field<1, 1>;    // TE
            using PRELEN = Field<2, 2>;    // PRELEN
            using DC = Field<4, 1>;    // DC
            using BL = Field<5, 2>;    // BL
            using DR = Field<8, 1>;    // DR
            using DCRS = Field<9, 1>;    // DCRS
            using DO = Field<10, 1>;    // DO
            using ECRSFD = Field<11, 1>;    // ECRSFD
            using LM = Field<12, 1>;    // LM
            using DM = Field<13, 1>;    // DM
            using FES = Field<14, 1>;    // FES
            using PS = Field<15, 1>;    // PS
            using JE = Field<16, 1>;    // JE
            using JD = Field<17, 1>;    // JD
            using BE = Field<18, 1>;    // BE
            using WD = Field<19, 1>;    // WD
            using ACS = Field<20, 1>;    // ACS
            using CST = Field<21, 1>;    // CST
            using S2KP = Field<22, 1>;    // S2KP
            using GPSLCE = Field<23, 1>;    // GPSLCE
            using IPG = Field<24, 3>;    // IPG
            using IPC = Field<27, 1>;    // IPC
            using SARC = Field<28, 3>;    // SARC
            using ARPEN = Field<31, 1>;    // ARPEN
        };

        // The MAC Extended Configuration Register establishes the operating mode of the MAC.
        struct ETH_MACECR : public Register<0x5800a004> {
            using GPSL = Field<0, 14>;    // GPSL
            using DCRCC = Field<16, 1>;    // DCRCC
            using SPEN = Field<17, 1>;    // SPEN
            using USP = Field<18, 1>;    // USP
            using EIPGEN = Field<24, 1>;    // EIPGEN
            using EIPG = Field<25, 5>;    // EIPG
        };

        // The MAC Packet Filter register contains the filter controls for receiving packets. Some of the controls from this register go to the address check block of the MAC which performs the first level of address filtering. The second level of filtering is performed on the incoming packet based on other controls such as Pass Bad Packets and Pass Control Packets.
        struct ETH_MACPFR : public Register<0x5800a008> {
            using PR = Field<0, 1>;    // PR
            using HUC = Field<1, 1>;    // HUC
            using HMC = Field<2, 1>;    // HMC
            using DAIF = Field<3, 1>;    // DAIF
            using PM = Field<4, 1>;    // PM
            using DBF = Field<5, 1>;    // DBF
            using PCF = Field<6, 2>;    // PCF
            using SAIF = Field<8, 1>;    // SAIF
            using SAF = Field<9, 1>;    // SAF
            using HPF = Field<10, 1>;    // HPF
            using VTFE = Field<16, 1>;    // VTFE
            using IPFE = Field<20, 1>;    // IPFE
            using DNTU = Field<21, 1>;    // DNTU
            using RA = Field<31, 1>;    // RA
        };

        // The Watchdog Timeout register controls the watchdog timeout for received packets.
        struct ETH_MACWTR : public Register<0x5800a00c> {
            using WTO = Field<0, 4>;    // WTO
            using PWE = Field<8, 1>;    // PWE
        };

        // The Hash Table Register 0 contains the first 32 bits of the Hash table (64 bits). For Hash filtering, the content of the destination address in the incoming packet is passed through the CRC logic and the upper six bits of the CRC register are used to index the content of the Hash table. The most significant bits determines the register to be used (Hash Table Register 0 or 1). The Hash value of the destination address is calculated in the following way: Calculate the 32-bit CRC for the DA (See IEEE 802.3, Section 3.2.8 for the steps to calculate CRC32). Perform bitwise reversal for the value obtained in Step 1. Take the upper 7 or 8 bits from the value obtained in Step 2. If the corresponding bit value of the register is 1, the packet is accepted. Otherwise, it is rejected. If the PM bit is set in ETH_MACPFR, all multicast packets are accepted regardless of the multicast Hash values. If the Hash Table register is configured to be double-synchronized to the GMII clock domain, the synchronization is triggered only when Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the Hash Table Register X registers are written.
        struct ETH_MACHT0R : public Register<0x5800a010> {
            using HT31T0 = Field<0, 32>;    // HT31T0
        };

        // The Hash Table Register 1contains the last 32 bits of the Hash table (64 bits). For Hash filtering, the content of the destination address in the incoming packet is passed through the CRC logic and the upper six bits of the CRC register are used to index the content of the Hash table. The most significant bits determines the register to be used (Hash Table Register 0 or 1). The Hash value of the destination address is calculated in the following way: Calculate the 32-bit CRC for the DA (See IEEE 802.3, Section 3.2.8 for the steps to calculate CRC32). Perform bitwise reversal for the value obtained in Step 1. Take the upper 7 or 8 bits from the value obtained in Step 2. If the corresponding bit value of the register is 1, the packet is accepted. Otherwise, it is rejected. If the PM bit is set in ETH_MACPFR, all multicast packets are accepted regardless of the multicast Hash values. If the Hash Table register is configured to be double-synchronized to the GMII clock domain, the synchronization is triggered only when Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the Hash Table Register X registers are written.
        struct ETH_MACHT1R : public Register<0x5800a014> {
            using HT63T32 = Field<0, 32>;    // HT63T32
        };

        // The VLAN Tag register identifies the IEEE 802.1Q VLAN type packets.
        struct ETH_MACVTR : public Register<0x5800a050> {
            using VL = Field<0, 16>;    // VL
            using ETV = Field<16, 1>;    // ETV
            using VTIM = Field<17, 1>;    // VTIM
            using ESVL = Field<18, 1>;    // ESVL
            using ERSVLM = Field<19, 1>;    // ERSVLM
            using DOVLTC = Field<20, 1>;    // DOVLTC
            using EVLS = Field<21, 2>;    // EVLS
            using EVLRXS = Field<24, 1>;    // EVLRXS
            using VTHM = Field<25, 1>;    // VTHM
            using EDVLP = Field<26, 1>;    // EDVLP
            using ERIVLT = Field<27, 1>;    // ERIVLT
            using EIVLS = Field<28, 2>;    // EIVLS
            using EIVLRXS = Field<31, 1>;    // EIVLRXS
        };

        // When the ERSVLM bit of ETH_MACHT1R register is set, the 16-bit VLAN Hash Table register is used for group address filtering based on the VLAN tag. For Hash filtering, the content of the 16-bit VLAN tag or 12-bit VLAN ID (based on the ETV bit of ETH_MACVTR register) in the incoming packet is passed through the CRC logic. The upper four bits of the calculated CRC are used to index the contents of the VLAN Hash table. For example, a Hash value of 1000 selects Bit 8 of the VLAN Hash table. The Hash value of the destination address is calculated in the following way: Calculate the 32-bit CRC for the VLAN tag or ID (For steps to calculate CRC32, see Section 3.2.8 of IEEE 802.3). Perform bitwise reversal for the value obtained in step 1. Take the upper four bits from the value obtained in step 2. If the VLAN Hash Table register is configured to be double-synchronized to the GMII clock domain, the synchronization is triggered only when Bits[15:8] (in little-endian mode) or Bits[7:0] (in big-endian mode) of this register are written.
        struct ETH_MACVHTR : public Register<0x5800a058> {
            using VLHT = Field<0, 16>;    // VLHT
        };

        // The VLAN Tag Inclusion or Replacement register contains the VLAN tag for insertion or replacement in the Transmit packets. It also contains the VLAN tag insertion controls.
        struct ETH_MACVIR : public Register<0x5800a060> {
            using VLT = Field<0, 16>;    // VLT
            using VLC = Field<16, 2>;    // VLC
            using VLP = Field<18, 1>;    // VLP
            using CSVL = Field<19, 1>;    // CSVL
            using VLTI = Field<20, 1>;    // VLTI
        };

        // The Inner VLAN Tag Inclusion or Replacement register contains the inner VLAN tag to be inserted or replaced in the Transmit packet. It also contains the inner VLAN tag insertion controls.
        struct ETH_MACIVIR : public Register<0x5800a064> {
            using VLT = Field<0, 16>;    // VLT
            using VLC = Field<16, 2>;    // VLC
            using VLP = Field<18, 1>;    // VLP
            using CSVL = Field<19, 1>;    // CSVL
            using VLTI = Field<20, 1>;    // VLTI
        };

        // The Flow Control register controls the generation and reception of the Control (Pause Command) packets by the Flow control module of the MAC. A Write to a register with the Busy bit set to 1 triggers the Flow Control block to generate a Pause packet. The fields of the control packet are selected as specified in the 802.3x specification, and the Pause Time value from this register is used in the Pause Time field of the control packet. The Busy bit remains set until the control packet is transferred onto the cable. The application must make sure that the Busy bit is cleared before writing to the register.
        struct ETH_MACQ0TxFCR : public Register<0x5800a070> {
            using FCB_BPA = Field<0, 1>;    // FCB_BPA
            using TFE = Field<1, 1>;    // TFE
            using PLT = Field<4, 3>;    // PLT
            using DZPQ = Field<7, 1>;    // DZPQ
            using PT = Field<16, 16>;    // PT
        };

        // The Receive Flow Control register controls the pausing of MAC Transmit based on the received Pause packet.
        struct ETH_MACRxFCR : public Register<0x5800a090> {
            using RFE = Field<0, 1>;    // RFE
            using UP = Field<1, 1>;    // UP
        };

        // The transmit queue priority mapping 0 register contains the priority values assigned to Tx queue 0 and tx queue 1.
        struct ETH_MACTxQPMR : public RegisterReadOnly<0x5800a098> {
            using PSTQ0 = Field<0, 8>;    // PSTQ0
            using PSTQ1 = Field<8, 8>;    // PSTQ1
        };

        // The Receive Queue Control 0 register controls the queue management in the MAC Receiver.
        struct ETH_MACRxQC0R : public Register<0x5800a0a0> {
            using RXQ0EN = Field<0, 2>;    // RXQ0EN
            using RXQ1EN = Field<2, 2>;    // RXQ1EN
        };

        // The Receive Queue Control 1 register controls queue 1 management in the MAC receiver.
        struct ETH_MACRxQC1R : public Register<0x5800a0a4> {
            using AVCPQ = Field<0, 3>;    // AVCPQ
            using AVPTPQ = Field<4, 3>;    // AVPTPQ
            using UPQ = Field<12, 3>;    // UPQ
            using MCBCQ = Field<16, 3>;    // MCBCQ
            using MCBCQEN = Field<20, 1>;    // MCBCQEN
            using TACPQE = Field<21, 1>;    // TACPQE
        };

        // This register controls the routing of tagged packets based on the USP (user priority) field of the received packets to the Rx queue 0 and 1.
        struct ETH_MACRxQC2R : public Register<0x5800a0a8> {
            using PSRQ0 = Field<0, 8>;    // PSRQ0
            using PSRQ1 = Field<8, 8>;    // PSRQ1
        };

        // The Interrupt Status register contains the status of interrupts.
        struct ETH_MACISR : public RegisterReadOnly<0x5800a0b0> {
            using RGSMIIIS = Field<0, 1>;    // RGSMIIIS
            using PHYIS = Field<3, 1>;    // PHYIS
            using PMTIS = Field<4, 1>;    // PMTIS
            using LPIIS = Field<5, 1>;    // LPIIS
            using MMCIS = Field<8, 1>;    // MMCIS
            using MMCRXIS = Field<9, 1>;    // MMCRXIS
            using MMCTXIS = Field<10, 1>;    // MMCTXIS
            using TSIS = Field<12, 1>;    // TSIS
            using TXSTSIS = Field<13, 1>;    // TXSTSIS
            using RXSTSIS = Field<14, 1>;    // RXSTSIS
        };

        // The Interrupt Enable register contains the masks for generating the interrupts.
        struct ETH_MACIER : public Register<0x5800a0b4> {
            using RGSMIIIE = Field<0, 1>;    // RGSMIIIE
            using PHYIE = Field<3, 1>;    // PHYIE
            using PMTIE = Field<4, 1>;    // PMTIE
            using LPIIE = Field<5, 1>;    // LPIIE
            using TSIE = Field<12, 1>;    // TSIE
            using TXSTSIE = Field<13, 1>;    // TXSTSIE
            using RXSTSIE = Field<14, 1>;    // RXSTSIE
        };

        // The Receive Transmit Status register contains the Receive and Transmit Error status.
        struct ETH_MACRxTxSR : public RegisterReadOnly<0x5800a0b8> {
            using TJT = Field<0, 1>;    // TJT
            using NCARR = Field<1, 1>;    // NCARR
            using LCARR = Field<2, 1>;    // LCARR
            using EXDEF = Field<3, 1>;    // EXDEF
            using LCOL = Field<4, 1>;    // LCOL
            using EXCOL = Field<5, 1>;    // EXCOL
            using RWT = Field<8, 1>;    // RWT
        };

        // The PMT Control and Status Register is present only when you select the PMT module in coreConsultant.
        struct ETH_MACPCSR : public Register<0x5800a0c0> {
            using PWRDWN = Field<0, 1>;    // PWRDWN
            using MGKPKTEN = Field<1, 1>;    // MGKPKTEN
            using RWKPKTEN = Field<2, 1>;    // RWKPKTEN
            using MGKPRCVD = Field<5, 1>;    // MGKPRCVD
            using RWKPRCVD = Field<6, 1>;    // RWKPRCVD
            using GLBLUCAST = Field<9, 1>;    // GLBLUCAST
            using RWKPFE = Field<10, 1>;    // RWKPFE
            using RWKPTR = Field<24, 5>;    // RWKPTR
            using RWKFILTRST = Field<31, 1>;    // RWKFILTRST
        };

        // The LPI Control and Status Register controls the LPI functions and provides the LPI interrupt status. The status bits are cleared when this register is read.
        struct ETH_MACRWKPFR : public Register<0x5800a0c4> {
            using TLPIEN = Field<0, 1>;    // TLPIEN
            using TLPIEX = Field<1, 1>;    // TLPIEX
            using RLPIEN = Field<2, 1>;    // RLPIEN
            using RLPIEX = Field<3, 1>;    // RLPIEX
            using TLPIST = Field<8, 1>;    // TLPIST
            using RLPIST = Field<9, 1>;    // RLPIST
            using LPIEN = Field<16, 1>;    // LPIEN
            using PLS = Field<17, 1>;    // PLS
            using PLSEN = Field<18, 1>;    // PLSEN
            using LPITXA = Field<19, 1>;    // LPITXA
            using LPITE = Field<20, 1>;    // LPITE
        };

        // The LPI Control and Status Register controls the LPI functions and provides the LPI interrupt status. The status bits are cleared when this register is read.
        struct ETH_MACLCSR : public Register<0x5800a0d0> {
            using TLPIEN = Field<0, 1>;    // TLPIEN
            using TLPIEX = Field<1, 1>;    // TLPIEX
            using RLPIEN = Field<2, 1>;    // RLPIEN
            using RLPIEX = Field<3, 1>;    // RLPIEX
            using TLPIST = Field<8, 1>;    // TLPIST
            using RLPIST = Field<9, 1>;    // RLPIST
            using LPIEN = Field<16, 1>;    // LPIEN
            using PLS = Field<17, 1>;    // PLS
            using PLSEN = Field<18, 1>;    // PLSEN
            using LPITXA = Field<19, 1>;    // LPITXA
            using LPITE = Field<20, 1>;    // LPITE
        };

        // The LPI Timers Control register controls the timeout values in the LPI states. It specifies the time for which the MAC transmits the LPI pattern and also the time for which the MAC waits before resuming the normal transmission.
        struct ETH_MACLTCR : public Register<0x5800a0d4> {
            using TWT = Field<0, 16>;    // TWT
            using LST = Field<16, 10>;    // LST
        };

        // The LPI Entry Timer Register is used to store the LPI Idle Timer Value in Micro-Seconds.
        struct ETH_MACLETR : public Register<0x5800a0d8> {
            using LPIET = Field<3, 17>;    // LPIET
        };

        // This register controls the generation of the Reference time (1-microsecond tick) for all the LPI timers. This timer has to be programmed by the software initially.
        struct ETH_MAC1USTCR : public Register<0x5800a0dc> {
            using TIC_1US_CNTR = Field<0, 12>;    // TIC_1US_CNTR
        };

        // The PHY Interface Control and Status register indicates the status signals received by the, RGMII interface from the PHY.
        struct ETH_MACPHYCSR : public Register<0x5800a0f8> {
            using TC = Field<0, 1>;    // TC
            using LUD = Field<1, 1>;    // LUD
            using LNKMOD = Field<16, 1>;    // LNKMOD
            using LNKSPEED = Field<17, 2>;    // LNKSPEED
            using LNKSTS = Field<19, 1>;    // LNKSTS
            using JABTO = Field<20, 1>;    // JABTO
            using FALSCARDET = Field<21, 1>;    // FALSCARDET
        };

        // The version register identifies the version of the Ethernet peripheral.
        struct ETH_MACVR : public RegisterReadOnly<0x5800a110> {
            using SNPSVER = Field<0, 8>;    // SNPSVER
            using USERVER = Field<8, 8>;    // USERVER
        };

        // The Debug register provides the debug status of various MAC blocks.
        struct ETH_MACDR : public RegisterReadOnly<0x5800a114> {
            using RPESTS = Field<0, 1>;    // RPESTS
            using RFCFCSTS = Field<1, 2>;    // RFCFCSTS
            using TPESTS = Field<16, 1>;    // TPESTS
            using TFCSTS = Field<17, 2>;    // TFCSTS
        };

        // This register indicates the presence of second set of the optional features or functions of the Ethernet peripheral. The software driver can use this register to dynamically enable or disable the programs related to the optional blocks.
        struct ETH_MACHWF1R : public RegisterReadOnly<0x5800a120> {
            using RXFIFOSIZE = Field<0, 5>;    // RXFIFOSIZE
            using TXFIFOSIZE = Field<6, 5>;    // TXFIFOSIZE
            using OSTEN = Field<11, 1>;    // OSTEN
            using PTOEN = Field<12, 1>;    // PTOEN
            using ADVTHWORD = Field<13, 1>;    // ADVTHWORD
            using ADDR64 = Field<14, 2>;    // ADDR64
            using DCBEN = Field<16, 1>;    // DCBEN
            using SPHEN = Field<17, 1>;    // SPHEN
            using TSOEN = Field<18, 1>;    // TSOEN
            using DBGMEMA = Field<19, 1>;    // DBGMEMA
            using AVSEL = Field<20, 1>;    // AVSEL
            using HASHTBLSZ = Field<24, 2>;    // HASHTBLSZ
            using L3L4FNUM = Field<27, 4>;    // L3L4FNUM
        };

        // This register indicates the presence of third set of the optional features or functions of the Ethernet peripheral. The software driver can use this register to dynamically enable or disable the programs related to the optional blocks.
        struct ETH_MACHWF2R : public RegisterReadOnly<0x5800a124> {
            using RXQCNT = Field<0, 4>;    // RXQCNT
            using TXQCNT = Field<6, 4>;    // TXQCNT
            using RXCHCNT = Field<12, 4>;    // RXCHCNT
            using TXCHCNT = Field<18, 4>;    // TXCHCNT
            using PPSOUTNUM = Field<24, 3>;    // PPSOUTNUM
            using AUXSNAPNUM = Field<28, 3>;    // AUXSNAPNUM
        };

        // The MDIO Address register controls the management cycles to external PHY through a management interface.
        struct ETH_MACMDIOAR : public Register<0x5800a200> {
            using GB = Field<0, 1>;    // GB
            using C45E = Field<1, 1>;    // C45E
            using GOC = Field<2, 2>;    // GOC
            using SKAP = Field<4, 1>;    // SKAP
            using CR = Field<8, 4>;    // CR
            using NTC = Field<12, 3>;    // NTC
            using RDA = Field<16, 5>;    // RDA
            using PA = Field<21, 5>;    // PA
            using BTB = Field<26, 1>;    // BTB
            using PSE = Field<27, 1>;    // PSE
        };

        // The MDIO Data register stores the Write data to be written to the PHY register located at the address specified in ETH_MACMDIOAR. This register also stores the Read data from the PHY register located at the address specified by MDIO Address register.
        struct ETH_MACMDIODR : public Register<0x5800a204> {
            using GD = Field<0, 16>;    // GD
            using RA = Field<16, 16>;    // RA
        };

        // The MAC Address0 High register holds the upper 16 bits of the first 6-byte MAC address of the station. The first DA byte that is received on the GMII interface corresponds to the LS byte (Bits [7:0]) of the MAC Address Low register. For example, if 0x112233445566 is received (0x11 in lane 0 of the first column) on the GMII as the destination address, then the MacAddress0 Register [47:0] is compared with 0x665544332211. If the MAC address registers are configured to be double-synchronized to the GMII clock domains, then the synchronization is triggered only when Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the MAC Address0 Low Register are written. For proper synchronization updates, the consecutive writes to this Address Low Register should be performed after at least four clock cycles in the destination clock domain.
        struct ETH_MACA0HR : public Register<0x5800a300> {
            using ADDRHI = Field<0, 16>;    // ADDRHI
            using AE = Field<31, 1>;    // AE
        };

        // The MAC Address x Low register holds the lower 32 bits of the 6-byte first MAC address of the station.
        struct ETH_MACA0LR : public Register<0x5800a304> {
            using ADDRLO = Field<0, 32>;    // ADDRLO
        };

        // The MAC Address x High register holds the upper 16 bits of the second 6-byte MAC address of the station.
        struct ETH_MACA1HR : public Register<0x5800a308> {
            using ADDRHI = Field<0, 16>;    // ADDRHI
            using MBC = Field<24, 6>;    // MBC
            using SA = Field<30, 1>;    // SA
            using AE = Field<31, 1>;    // AE
        };

        // The MAC Address x Low register holds the lower 32 bits of the 6-byte first MAC address of the station.
        struct ETH_MACA1LR : public Register<0x5800a30c> {
            using ADDRLO = Field<0, 32>;    // ADDRLO
        };

        // The MAC Address x High register holds the upper 16 bits of the second 6-byte MAC address of the station.
        struct ETH_MACA2HR : public Register<0x5800a310> {
            using ADDRHI = Field<0, 16>;    // ADDRHI
            using MBC = Field<24, 6>;    // MBC
            using SA = Field<30, 1>;    // SA
            using AE = Field<31, 1>;    // AE
        };

        // The MAC Address x Low register holds the lower 32 bits of the 6-byte first MAC address of the station.
        struct ETH_MACA2LR : public Register<0x5800a314> {
            using ADDRLO = Field<0, 32>;    // ADDRLO
        };

        // The MAC Address x High register holds the upper 16 bits of the second 6-byte MAC address of the station.
        struct ETH_MACA3HR : public Register<0x5800a318> {
            using ADDRHI = Field<0, 16>;    // ADDRHI
            using MBC = Field<24, 6>;    // MBC
            using SA = Field<30, 1>;    // SA
            using AE = Field<31, 1>;    // AE
        };

        // The MAC Address x Low register holds the lower 32 bits of the 6-byte first MAC address of the station.
        struct ETH_MACA3LR : public Register<0x5800a31c> {
            using ADDRLO = Field<0, 32>;    // ADDRLO
        };

        // This register configures the MMC operating mode.
        struct MMC_CONTROL : public Register<0x5800a700> {
            using CNTRST = Field<0, 1>;    // CNTRST
            using CNTSTOPRO = Field<1, 1>;    // CNTSTOPRO
            using RSTONRD = Field<2, 1>;    // RSTONRD
            using CNTFREEZ = Field<3, 1>;    // CNTFREEZ
            using CNTPRST = Field<4, 1>;    // CNTPRST
            using CNTPRSTLVL = Field<5, 1>;    // CNTPRSTLVL
            using UCDBC = Field<8, 1>;    // UCDBC
        };

        // This register maintains the interrupts generated from all Receive statistics counters. The MMC Receive Interrupt register maintains the interrupts that are generated when the following occur: Receive statistic counters reach half of their maximum values (0x8000_0000 for 32 bit counter and 0x8000 for 16 bit counter). Receive statistic counters cross their maximum values (0xFFFF_FFFF for 32 bit counter and 0xFFFF for 16 bit counter). When the Counter Stop Rollover is set, interrupts are set but the counter remains at all-ones. The MMC Receive Interrupt register is a 32 bit register. An interrupt bit is cleared when the respective MMC counter that caused the interrupt is read. The least significant byte lane (Bits[7:0]) of the respective counter must be read to clear the interrupt bit.
        struct MMC_RX_INTERRUPT : public RegisterReadOnly<0x5800a704> {
            using RXCRCERPIS = Field<5, 1>;    // RXCRCERPIS
            using RXALGNERPIS = Field<6, 1>;    // RXALGNERPIS
            using RXUCGPIS = Field<17, 1>;    // RXUCGPIS
            using RXLPIUSCIS = Field<26, 1>;    // RXLPIUSCIS
            using RXLPITRCIS = Field<27, 1>;    // RXLPITRCIS
        };

        // This register maintains the interrupts generated from all Transmit statistics counters. The MMC Transmit Interrupt register maintains the interrupts generated when transmit statistic counters reach half their maximum values (0x8000_0000 for 32 bit counter and 0x8000 for 16 bit counter), and when they cross their maximum values (0xFFFF_FFFF for 32-bit counter and 0xFFFF for 16-bit counter). When Counter Stop Rollover is set, the interrupts are set but the counter remains at all-ones. The MMC Transmit Interrupt register is a 32 bit register. An interrupt bit is cleared when the respective MMC counter that caused the interrupt is read. The least significant byte lane (Bits[7:0]) of the respective counter must be read to clear the interrupt bit.
        struct MMC_TX_INTERRUPT : public RegisterReadOnly<0x5800a708> {
            using TXSCOLGPIS = Field<14, 1>;    // TXSCOLGPIS
            using TXMCOLGPIS = Field<15, 1>;    // TXMCOLGPIS
            using TXGPKTIS = Field<21, 1>;    // TXGPKTIS
            using TXLPIUSCIS = Field<26, 1>;    // TXLPIUSCIS
            using TXLPITRCIS = Field<27, 1>;    // TXLPITRCIS
        };

        // The MMC Receive Interrupt Mask register maintains the masks for the interrupts generated when receive statistic counters reach half of their maximum value or the maximum values.
        struct MMC_RX_INTERRUPT_MASK : public Register<0x5800a70c> {
            using RXCRCERPIM = Field<5, 1>;    // RXCRCERPIM
            using RXALGNERPIM = Field<6, 1>;    // RXALGNERPIM
            using RXUCGPIM = Field<17, 1>;    // RXUCGPIM
            using RXLPIUSCIM = Field<26, 1>;    // RXLPIUSCIM
            using RXLPITRCIM = Field<27, 1>;    // RXLPITRCIM
        };

        // This register maintains the masks for interrupts generated from all Transmit statistics counters. The MMC Transmit Interrupt Mask register maintains the masks for the interrupts generated when the transmit statistic counters reach half of their maximum value or the maximum values. This register is 32 bit wide. This register is present only when any one of the MMC Transmit Counters is selected during core configuration.
        struct MMC_TX_INTERRUPT_MASK : public Register<0x5800a710> {
            using TXSCOLGPIM = Field<14, 1>;    // TXSCOLGPIM
            using TXMCOLGPIM = Field<15, 1>;    // TXMCOLGPIM
            using TXGPKTIM = Field<21, 1>;    // TXGPKTIM
            using TXLPIUSCIM = Field<26, 1>;    // TXLPIUSCIM
            using TXLPITRCIM = Field<27, 1>;    // TXLPITRCIM
        };

        // This register provides the number of successfully transmitted packets by Ethernet peripheral after a single collision in the half-duplex mode.
        struct TX_SINGLE_COLLISION_GOOD_PACKETS : public RegisterReadOnly<0x5800a74c> {
            using TXSNGLCOLG = Field<0, 32>;    // TXSNGLCOLG
        };

        // This register provides the number of successfully transmitted packets by Ethernet peripheral after multiple collisions in the half-duplex mode.
        struct TX_MULTIPLE_COLLISION_GOOD_PACKETS : public RegisterReadOnly<0x5800a750> {
            using TXMULTCOLG = Field<0, 32>;    // TXMULTCOLG
        };

        // This register provides the number of good packets transmitted by Ethernet peripheral.
        struct TX_PACKET_COUNT_GOOD : public RegisterReadOnly<0x5800a768> {
            using TXPKTG = Field<0, 32>;    // TXPKTG
        };

        // This register provides the number of packets received by Ethernet peripheral with CRC error.
        struct RX_CRC_ERROR_PACKETS : public RegisterReadOnly<0x5800a794> {
            using RXCRCERR = Field<0, 32>;    // RXCRCERR
        };

        // This register provides the number of packets received by Ethernet peripheral with alignment (dribble) error. It is valid only in 10/100 mode.
        struct RX_ALIGNMENT_ERROR_PACKETS : public RegisterReadOnly<0x5800a798> {
            using RXALGNERR = Field<0, 32>;    // RXALGNERR
        };

        // This register provides the number of good unicast packets received by Ethernet peripheral.
        struct RX_UNICAST_PACKETS_GOOD : public RegisterReadOnly<0x5800a7c4> {
            using RXUCASTG = Field<0, 32>;    // RXUCASTG
        };

        // This register provides the number of microseconds Tx LPI is asserted by Ethernet peripheral.
        struct TX_LPI_USEC_CNTR : public RegisterReadOnly<0x5800a7ec> {
            using TXLPIUSC = Field<0, 32>;    // TXLPIUSC
        };

        // This register provides the number of times Ethernet peripheral has entered Tx LPI.
        struct TX_LPI_TRAN_CNTR : public RegisterReadOnly<0x5800a7f0> {
            using TXLPITRC = Field<0, 32>;    // TXLPITRC
        };

        // This register provides the number of microseconds Rx LPI is sampled by Ethernet peripheral.
        struct RX_LPI_USEC_CNTR : public RegisterReadOnly<0x5800a7f4> {
            using RXLPIUSC = Field<0, 32>;    // RXLPIUSC
        };

        // This register provides the number of times Ethernet peripheral has entered Rx LPI.
        struct RX_LPI_TRAN_CNTR : public RegisterReadOnly<0x5800a7f8> {
            using RXLPITRC = Field<0, 32>;    // RXLPITRC
        };

        // The Layer 3 and Layer 4 Control register controls the operations of filter 0 of Layer 3 and Layer 4. This register is reserved if the Layer 3 and Layer 4 Filtering feature is not selected during core configuration.
        struct ETH_MACL3L4C0R : public Register<0x5800a900> {
            using L3PEN0 = Field<0, 1>;    // L3PEN0
            using L3SAM0 = Field<2, 1>;    // L3SAM0
            using L3SAIM0 = Field<3, 1>;    // L3SAIM0
            using L3DAM0 = Field<4, 1>;    // L3DAM0
            using L3DAIM0 = Field<5, 1>;    // L3DAIM0
            using L3HSBM0 = Field<6, 5>;    // L3HSBM0
            using L3HDBM0 = Field<11, 5>;    // L3HDBM0
            using L4PEN0 = Field<16, 1>;    // L4PEN0
            using L4SPM0 = Field<18, 1>;    // L4SPM0
            using L4SPIM0 = Field<19, 1>;    // L4SPIM0
            using L4DPM0 = Field<20, 1>;    // L4DPM0
            using L4DPIM0 = Field<21, 1>;    // L4DPIM0
        };

        // Layer4 address filter 0 register
        struct ETH_MACL4A0R : public Register<0x5800a904> {
            using L4SP0 = Field<0, 16>;    // L4SP0
            using L4DP0 = Field<16, 16>;    // L4DP0
        };

        // For IPv4 packets, the Layer 3 Address 0 Register 0 register contains the 32-bit IP Source Address field. For IPv6 packets, it contains Bits[31:0] of the 128-bit IP Source Address or Destination Address field.
        struct ETH_MACL3A00R : public Register<0x5800a910> {
            using L3A00 = Field<0, 32>;    // L3A00
        };

        // For IPv4 packets, the Layer 3 Address 1 Register 0 register contains the 32-bit IP Destination Address field. For IPv6 packets, it contains Bits[63:32] of the 128-bit IP Source Address or Destination Address field.
        struct ETH_MACL3A10R : public Register<0x5800a914> {
            using L3A10 = Field<0, 32>;    // L3A10
        };

        // The Layer 3 Address 2 Register 0 register is reserved for IPv4 packets. For IPv6 packets, it contains Bits[95:64] of 128-bit IP Source Address or Destination Address field.
        struct ETH_MACL3A20 : public Register<0x5800a918> {
            using L3A20 = Field<0, 32>;    // L3A20
        };

        // The Layer 3 Address 3 Register 0 register is reserved for IPv4 packets. For IPv6 packets, it contains Bits[127:96] of 128-bit IP Source Address or Destination Address field.
        struct ETH_MACL3A30 : public Register<0x5800a91c> {
            using L3A30 = Field<0, 32>;    // L3A30
        };

        // The Layer 3 and Layer 4 Control register controls the operations of filter 0 of Layer 3 and Layer 4.
        struct ETH_MACL3L4C1R : public Register<0x5800a930> {
            using L3PEN1 = Field<0, 1>;    // L3PEN1
            using L3SAM1 = Field<2, 1>;    // L3SAM1
            using L3SAIM1 = Field<3, 1>;    // L3SAIM1
            using L3DAM1 = Field<4, 1>;    // L3DAM1
            using L3DAIM1 = Field<5, 1>;    // L3DAIM1
            using L3HSBM1 = Field<6, 5>;    // L3HSBM1
            using L3HDBM1 = Field<11, 5>;    // L3HDBM1
            using L4PEN1 = Field<16, 1>;    // L4PEN1
            using L4SPM1 = Field<18, 1>;    // L4SPM1
            using L4SPIM1 = Field<19, 1>;    // L4SPIM1
            using L4DPM1 = Field<20, 1>;    // L4DPM1
            using L4DPIM1 = Field<21, 1>;    // L4DPIM1
        };

        // The Layer 4 Address 0 register and registers 580 through 667 are reserved (RO with default value) if Enable Layer 3 and Layer 4 Packet Filter option is not selected while configuring the core. You can configure the Layer 3 and Layer 4 Address Registers to be double-synchronized by selecting the Synchronize Layer 3 and Layer 4 Address Registers to Rx Clock Domain option while configuring the core. When you select this option, the synchronization is triggered only when Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the Layer 3 and Layer 4 Address Registers are written. For proper synchronization updates, you should perform consecutive writes to same Layer 3 and Layer 4 Address Registers after at least four clock cycles delay of the destination clock.
        struct ETH_MACL4A1R : public Register<0x5800a934> {
            using L4SP1 = Field<0, 16>;    // L4SP1
            using L4DP1 = Field<16, 16>;    // L4DP1
        };

        // For IPv4 packets, the Layer 3 Address 0 Register 0 register contains the 32-bit IP Source Address field. For IPv6 packets, it contains Bits[31:0] of the 128-bit IP Source Address or Destination Address field.
        struct ETH_MACL3A01R : public Register<0x5800a940> {
            using L3A01 = Field<0, 32>;    // L3A01
        };

        // For IPv4 packets, the Layer 3 Address 1 Register 0 register contains the 32-bit IP Destination Address field. For IPv6 packets, it contains Bits[63:32] of the 128-bit IP Source Address or Destination Address field.
        struct ETH_MACL3A11R : public Register<0x5800a944> {
            using L3A11 = Field<0, 32>;    // L3A11
        };

        // The Layer 3 Address 2 Register 0 register is reserved for IPv4 packets. For IPv6 packets, it contains Bits[95:64] of 128-bit IP Source Address or Destination Address field.
        struct ETH_MACL3A21R : public Register<0x5800a948> {
            using L3A21 = Field<0, 32>;    // L3A21
        };

        // The Layer 3 Address 3 Register 0 register is reserved for IPv4 packets. For IPv6 packets, it contains Bits[127:96] of 128-bit IP Source Address or Destination Address field.
        struct ETH_MACL3A31R : public Register<0x5800a94c> {
            using L3A31 = Field<0, 32>;    // L3A31
        };

        // The ARP Address register contains the IPv4 Destination Address of the MAC.
        struct ETH_MACARPAR : public Register<0x5800aae0> {
            using ARPPA = Field<0, 32>;    // ARPPA
        };

        // This register controls the operation of the System Time generator and processing of PTP packets for timestamping in the Receiver.
        struct ETH_MACTSCR : public Register<0x5800ab00> {
            using TSENA = Field<0, 1>;    // TSENA
            using TSCFUPDT = Field<1, 1>;    // TSCFUPDT
            using TSINIT = Field<2, 1>;    // TSINIT
            using TSUPDT = Field<3, 1>;    // TSUPDT
            using TSADDREG = Field<5, 1>;    // TSADDREG
            using TSENALL = Field<8, 1>;    // TSENALL
            using TSCTRLSSR = Field<9, 1>;    // TSCTRLSSR
            using TSVER2ENA = Field<10, 1>;    // TSVER2ENA
            using TSIPENA = Field<11, 1>;    // TSIPENA
            using TSIPV6ENA = Field<12, 1>;    // TSIPV6ENA
            using TSIPV4ENA = Field<13, 1>;    // TSIPV4ENA
            using TSEVNTENA = Field<14, 1>;    // TSEVNTENA
            using TSMSTRENA = Field<15, 1>;    // TSMSTRENA
            using SNAPTYPSEL = Field<16, 2>;    // SNAPTYPSEL
            using TSENMACADDR = Field<18, 1>;    // TSENMACADDR
            using CSC = Field<19, 1>;    // CSC
            using TXTSSTSM = Field<24, 1>;    // TXTSSTSM
            using AV8021ASMEN = Field<28, 1>;    // AV8021ASMEN
        };

        // The Sub-second Increment register is present only when the IEEE 1588 timestamp feature is selected without an external timestamp input. In Coarse Update mode [Bit 1 in ETH_MACTSCR register, the value in this register is added to the system time every clock cycle of HCLK. In Fine Update mode, the value in this register is added to the system time whenever the Accumulator gets an overflow.
        struct ETH_MACSSIR : public Register<0x5800ab04> {
            using SNSINC = Field<8, 8>;    // SNSINC
            using SSINC = Field<16, 8>;    // SSINC
        };

        // The System Time Seconds register, along with System Time Nanoseconds register, indicates the current value of the system time maintained by the MAC. Though it is updated on a continuous basis, there is some delay from the actual time because of clock domain transfer latencies (from HCLK to CSR clock). This register is present only when the IEEE 1588 Timestamp feature is selected without external timestamp input.
        struct ETH_MACSTSR : public RegisterReadOnly<0x5800ab08> {
            using TSS = Field<0, 32>;    // TSS
        };

        // The System Time Nanoseconds register, along with System Time Seconds register, indicates the current value of the system time maintained by the MAC. This register is present only when the IEEE 1588 Timestamp feature is selected without external timestamp input.
        struct ETH_MACSTNR : public RegisterReadOnly<0x5800ab0c> {
            using TSSS = Field<0, 31>;    // TSSS
        };

        // The System Time Seconds Update register, along with the System Time Nanoseconds Update register, initializes or updates the system time maintained by the MAC. You must write both registers before setting the TSINIT or TSUPDT bits in ETH_MACTSCR register. This register is present only when the IEEE 1588 Timestamp feature is selected without external timestamp input.
        struct ETH_MACSTSUR : public Register<0x5800ab10> {
            using TSS = Field<0, 32>;    // TSS
        };

        // This register is present only when the IEEE 1588 timestamp feature is selected without external timestamp input.
        struct ETH_MACSTNUR : public Register<0x5800ab14> {
            using TSSS = Field<0, 31>;    // TSSS
            using ADDSUB = Field<31, 1>;    // ADDSUB
        };

        // The Timestamp Addend register is present only when the IEEE 1588 Timestamp feature is selected without external timestamp input. This register value is used only when the system time is configured for Fine Update mode (TSCFUPDT bit in the ETH_MACTSCR register). The content of this register is added to a 32-bit accumulator in every clock cycle (of HCLK) and the system time is updated whenever the accumulator overflows.
        struct ETH_MACTSAR : public Register<0x5800ab18> {
            using TSAR = Field<0, 32>;    // TSAR
        };

        // The Timestamp Status register is present only when the IEEE 1588 Timestamp feature is selected. All bits except Bits[27:25] gets cleared when the application reads this register.
        struct ETH_MACTSSR : public RegisterReadOnly<0x5800ab20> {
            using TSSOVF = Field<0, 1>;    // TSSOVF
            using TSTARGT0 = Field<1, 1>;    // TSTARGT0
            using AUXTSTRIG = Field<2, 1>;    // AUXTSTRIG
            using TSTRGTERR0 = Field<3, 1>;    // TSTRGTERR0
            using TXTSSIS = Field<15, 1>;    // TXTSSIS
            using ATSSTN = Field<16, 4>;    // ATSSTN
            using ATSSTM = Field<24, 1>;    // ATSSTM
            using ATSNS = Field<25, 5>;    // ATSNS
        };

        // This register contains the nanosecond part of timestamp captured for Transmit packets when Tx status is disabled.
        struct ETH_MACTxTSSNR : public RegisterReadOnly<0x5800ab30> {
            using TXTSSLO = Field<0, 31>;    // TXTSSLO
            using TXTSSMIS = Field<31, 1>;    // TXTSSMIS
        };

        // The register contains the higher 32 bits of the timestamp (in seconds) captured when a PTP packet is transmitted.
        struct ETH_MACTxTSSSR : public RegisterReadOnly<0x5800ab34> {
            using TXTSSHI = Field<0, 32>;    // TXTSSHI
        };

        // The Auxiliary Timestamp Control register controls the Auxiliary Timestamp snapshot.
        struct ETH_MACACR : public Register<0x5800ab40> {
            using ATSFC = Field<0, 1>;    // ATSFC
            using ATSEN0 = Field<4, 1>;    // ATSEN0
            using ATSEN1 = Field<5, 1>;    // ATSEN1
            using ATSEN2 = Field<6, 1>;    // ATSEN2
            using ATSEN3 = Field<7, 1>;    // ATSEN3
        };

        // The Auxiliary Timestamp Nanoseconds register, along with ETH_MACATSSR, gives the 64-bit timestamp stored as auxiliary snapshot. These two registers form the read port of a 64-bit wide FIFO with a depth of 4 words. You can store multiple snapshots in this FIFO. Bits[29:25] in ETH_MACTSSR indicate the fill-level of the FIFO. The top of the FIFO is removed only when the last byte of MAC Register 91 (Auxiliary Timestamp - Seconds Register) is read. In the little-endian mode, this means when Bits[31:24] are read and in big-endian mode, Bits[7:0] are read.
        struct ETH_MACATSNR : public RegisterReadOnly<0x5800ab48> {
            using AUXTSLO = Field<0, 31>;    // AUXTSLO
        };

        // The Auxiliary Timestamp - Seconds register contains the lower 32 bits of the Seconds field of the auxiliary timestamp register.
        struct ETH_MACATSSR : public RegisterReadOnly<0x5800ab4c> {
            using AUXTSHI = Field<0, 32>;    // AUXTSHI
        };

        // The MAC Timestamp Ingress Asymmetry Correction register contains the Ingress Asymmetry Correction value to be used while updating correction field in PDelay_Resp PTP messages.
        struct ETH_MACTSIACR : public Register<0x5800ab50> {
            using OSTIAC = Field<0, 32>;    // OSTIAC
        };

        // The MAC Timestamp Egress Asymmetry Correction register contains the Egress Asymmetry Correction value to be used while updating the correction field in PDelay_Req PTP messages.
        struct ETH_MACTSEACR : public Register<0x5800ab54> {
            using OSTEAC = Field<0, 32>;    // OSTEAC
        };

        // This register contains the correction value in nanoseconds to be used with the captured timestamp value in the ingress path.
        struct ETH_MACTSICNR : public Register<0x5800ab58> {
            using TSIC = Field<0, 32>;    // TSIC
        };

        // This register contains the correction value in nanoseconds to be used with the captured timestamp value in the egress path.
        struct ETH_MACTSECNR : public Register<0x5800ab5c> {
            using TSEC = Field<0, 32>;    // TSEC
        };

        // The PPS Control register is present only when the Timestamp feature is selected and External Timestamp is not enabled. Bits[30:24] of this register are valid only when four Flexible PPS outputs are selected. Bits[22:16] are valid only when three or more Flexible PPS outputs are selected. Bits[14:8] are valid only when two or more Flexible PPS outputs are selected. Bits[6:4] are valid only when Flexible PPS feature is selected.
        struct ETH_MACPPSCR : public Register<0x5800ab70> {
            using PPSCTRL = Field<0, 4>;    // PPSCTRL
            using PPSEN0 = Field<4, 1>;    // PPSEN0
            using TRGTMODSEL0 = Field<5, 2>;    // TRGTMODSEL0
        };

        // The PPS Target Time Seconds register, along with PPS Target Time Nanoseconds register, is used to schedule an interrupt event [Bit 1 of ETH_MACTSSR] when the system time exceeds the value programmed in these registers.
        struct ETH_MACPPSTTSR : public Register<0x5800ab80> {
            using TSTRH0 = Field<0, 32>;    // TSTRH0
        };

        // The PPS Target Time Nanoseconds register is present only when more than one Flexible PPS output is selected.
        struct ETH_MACPPSTTNR : public Register<0x5800ab84> {
            using TTSL0 = Field<0, 31>;    // TTSL0
            using TRGTBUSY0 = Field<31, 1>;    // TRGTBUSY0
        };

        // The PPS Interval register contains the number of units of sub-second increment value between the rising edges of PPS signal output (ptp_pps_o[0]).
        struct ETH_MACPPSIR : public Register<0x5800ab88> {
            using PPSINT0 = Field<0, 32>;    // PPSINT0
        };

        // The PPS Width register contains the number of units of sub-second increment value between the rising and corresponding falling edges of PPS signal output (ptp_pps_o).
        struct ETH_MACPPSWR : public Register<0x5800ab8c> {
            using PPSWIDTH0 = Field<0, 32>;    // PPSWIDTH0
        };

        // This register controls the PTP Offload Engine operation. This register is available only when the Enable PTP Timestamp Offload feature is selected.
        struct ETH_MACPOCR : public Register<0x5800abc0> {
            using PTOEN = Field<0, 1>;    // PTOEN
            using ASYNCEN = Field<1, 1>;    // ASYNCEN
            using APDREQEN = Field<2, 1>;    // APDREQEN
            using ASYNCTRIG = Field<4, 1>;    // ASYNCTRIG
            using APDREQTRIG = Field<5, 1>;    // APDREQTRIG
            using DRRDIS = Field<6, 1>;    // DRRDIS
            using DN = Field<8, 8>;    // DN
        };

        // This register contains Bits[31:0] of the 80-bit Source Port Identity of the PTP node. This register is available only when the Enable PTP Timestamp Offload feature is selected.
        struct ETH_MACSPI0R : public Register<0x5800abc4> {
            using SPI0 = Field<0, 32>;    // SPI0
        };

        // This register contains Bits[63:32] of the 80-bit Source Port Identity of the PTP node. This register is available only when the Enable PTP Timestamp Offload feature is selected.
        struct ETH_MACSPI1R : public Register<0x5800abc8> {
            using SPI1 = Field<0, 32>;    // SPI1
        };

        // This register contains Bits[79:64] of the 80-bit Source Port Identity of the PTP node.
        struct ETH_MACSPI2R : public Register<0x5800abcc> {
            using SPI2 = Field<0, 16>;    // SPI2
        };

        // This register contains the periodic intervals for automatic PTP packet generation.
        struct ETH_MACLMIR : public Register<0x5800abd0> {
            using LSI = Field<0, 8>;    // LSI
            using DRSYNCR = Field<8, 3>;    // DRSYNCR
            using LMPDRI = Field<24, 8>;    // LMPDRI
        };

    };

    // ETH_MTL
    struct ETH_MTL {
        // The Operating Mode register establishes the Transmit and Receive operating modes and commands.
        struct ETH_MTLOMR : public Register<0x5800ac00> {
            using DTXSTS = Field<1, 1>;    // DTXSTS
            using RAA = Field<2, 1>;    // RAA
            using SCHALG = Field<5, 2>;    // SCHALG
            using CNTPRST = Field<8, 1>;    // CNTPRST
            using CNTCLR = Field<9, 1>;    // CNTCLR
        };

        // The software driver (application) reads this register during interrupt service routine or polling to determine the interrupt status of MTL queues and the MAC.
        struct ETH_MTLISR : public RegisterReadOnly<0x5800ac20> {
            using Q0IS = Field<0, 1>;    // Q0IS
            using Q1IS = Field<1, 1>;    // Q1IS
        };

        // Tx queue 0 operating mode Register
        struct ETH_MTLTxQ0OMR : public Register<0x5800ad00> {
            using FTQ = Field<0, 1>;    // FTQ
            using TSF = Field<1, 1>;    // TSF
            using TXQEN = Field<2, 2>;    // TXQEN
            using TTC = Field<4, 2>;    // TTC
            using TQS = Field<16, 9>;    // TQS
        };

        // Tx queue 1 operating mode Register
        struct ETH_MTLTxQ1OMR : public Register<0x5800ad40> {
            using FTQ = Field<0, 1>;    // FTQ
            using TSF = Field<1, 1>;    // TSF
            using TXQEN = Field<2, 2>;    // TXQEN
            using TTC = Field<4, 2>;    // TTC
            using TQS = Field<16, 9>;    // TQS
        };

        // Tx queue 0 underflow register
        struct ETH_MTLTxQ0UR : public RegisterReadOnly<0x5800ad04> {
            using UFFRMCNT = Field<0, 11>;    // UFFRMCNT
            using UFCNTOVF = Field<11, 1>;    // UFCNTOVF
        };

        // Tx queue 1 underflow register
        struct ETH_MTLTxQ1UR : public RegisterReadOnly<0x5800ad44> {
            using UFFRMCNT = Field<0, 11>;    // UFFRMCNT
            using UFCNTOVF = Field<11, 1>;    // UFCNTOVF
        };

        // Tx queue 0 underflow register
        struct ETH_MTLTxQ0DR : public RegisterReadOnly<0x5800ad08> {
            using TXQPAUSED = Field<0, 1>;    // TXQPAUSED
            using TRCSTS = Field<1, 2>;    // TRCSTS
            using TWCSTS = Field<3, 1>;    // TWCSTS
            using TXQSTS = Field<4, 1>;    // TXQSTS
            using TXSTSFSTS = Field<5, 1>;    // TXSTSFSTS
            using PTXQ = Field<16, 3>;    // PTXQ
            using STXSTSF = Field<20, 3>;    // STXSTSF
        };

        // Tx queue 1 underflow register
        struct ETH_MTLTxQ1DR : public RegisterReadOnly<0x5800ad48> {
            using TXQPAUSED = Field<0, 1>;    // TXQPAUSED
            using TRCSTS = Field<1, 2>;    // TRCSTS
            using TWCSTS = Field<3, 1>;    // TWCSTS
            using TXQSTS = Field<4, 1>;    // TXQSTS
            using TXSTSFSTS = Field<5, 1>;    // TXSTSFSTS
            using PTXQ = Field<16, 3>;    // PTXQ
            using STXSTSF = Field<20, 3>;    // STXSTSF
        };

        // Tx queue x ETS status Register
        struct ETH_MTLTxQ0ESR : public RegisterReadOnly<0x5800ad14> {
            using ABS = Field<0, 24>;    // ABS
        };

        // Tx queue x ETS status Register
        struct ETH_MTLTxQ1ESR : public RegisterReadOnly<0x5800ad54> {
            using ABS = Field<0, 24>;    // ABS
        };

        // Queue 0 interrupt control status Register
        struct ETH_MTLQ0ICSR : public Register<0x5800ad2c> {
            using TXUNFIS = Field<0, 1>;    // TXUNFIS
            using ABPSIS = Field<1, 1>;    // ABPSIS
            using TXUIE = Field<8, 1>;    // TXUIE
            using ABPSIE = Field<9, 1>;    // ABPSIE
            using RXOVFIS = Field<16, 1>;    // RXOVFIS
            using RXOIE = Field<24, 1>;    // RXOIE
        };

        // Queue 1 interrupt control status Register
        struct ETH_MTLQ1ICSR : public Register<0x5800ad6c> {
            using TXUNFIS = Field<0, 1>;    // TXUNFIS
            using ABPSIS = Field<1, 1>;    // ABPSIS
            using TXUIE = Field<8, 1>;    // TXUIE
            using ABPSIE = Field<9, 1>;    // ABPSIE
            using RXOVFIS = Field<16, 1>;    // RXOVFIS
            using RXOIE = Field<24, 1>;    // RXOIE
        };

        // Rx queue 0 operating mode register
        struct ETH_MTLRxQ0OMR : public Register<0x5800ad30> {
            using RTC = Field<0, 2>;    // RTC
            using FUP = Field<3, 1>;    // FUP
            using FEP = Field<4, 1>;    // FEP
            using RSF = Field<5, 1>;    // RSF
            using DIS_TCP_EF = Field<6, 1>;    // DIS_TCP_EF
            using EHFC = Field<7, 1>;    // EHFC
            using RFA = Field<8, 3>;    // RFA
            using RFD = Field<14, 3>;    // RFD
            using RQS = Field<20, 4>;    // RQS
        };

        // Rx queue 1 operating mode register
        struct ETH_MTLRxQ1OMR : public Register<0x5800ad70> {
            using RTC = Field<0, 2>;    // RTC
            using FUP = Field<3, 1>;    // FUP
            using FEP = Field<4, 1>;    // FEP
            using RSF = Field<5, 1>;    // RSF
            using DIS_TCP_EF = Field<6, 1>;    // DIS_TCP_EF
            using EHFC = Field<7, 1>;    // EHFC
            using RFA = Field<8, 3>;    // RFA
            using RFD = Field<14, 3>;    // RFD
            using RQS = Field<20, 4>;    // RQS
        };

        // Rx queue 0 missed packet and overflow counter register
        struct ETH_MTLRxQ0MPOCR : public RegisterReadOnly<0x5800ad34> {
            using OVFPKTCNT = Field<0, 11>;    // OVFPKTCNT
            using OVFCNTOVF = Field<11, 1>;    // OVFCNTOVF
            using MISPKTCNT = Field<16, 11>;    // MISPKTCNT
            using MISCNTOVF = Field<27, 1>;    // MISCNTOVF
        };

        // Rx queue 1 missed packet and overflow counter register
        struct ETH_MTLRxQ1MPOCR : public RegisterReadOnly<0x5800ad74> {
            using OVFPKTCNT = Field<0, 11>;    // OVFPKTCNT
            using OVFCNTOVF = Field<11, 1>;    // OVFCNTOVF
            using MISPKTCNT = Field<16, 11>;    // MISPKTCNT
            using MISCNTOVF = Field<27, 1>;    // MISCNTOVF
        };

        // Rx queue i debug register
        struct ETH_MTLRxQ0DR : public RegisterReadOnly<0x5800ad38> {
            using RWCSTS = Field<0, 1>;    // RWCSTS
            using RRCSTS = Field<1, 2>;    // RRCSTS
            using RXQSTS = Field<4, 2>;    // RXQSTS
            using PRXQ = Field<16, 14>;    // PRXQ
        };

        // Rx queue i debug register
        struct ETH_MTLRxQ1DR : public RegisterReadOnly<0x5800ad78> {
            using RWCSTS = Field<0, 1>;    // RWCSTS
            using RRCSTS = Field<1, 2>;    // RRCSTS
            using RXQSTS = Field<4, 2>;    // RXQSTS
            using PRXQ = Field<16, 14>;    // PRXQ
        };

        // Rx queue 0 control register
        struct ETH_MTLRxQ0CR : public Register<0x5800ad3c> {
            using RXQ_WEGT = Field<0, 3>;    // RXQ_WEGT
            using RXQ_FRM_ARBIT = Field<3, 1>;    // RXQ_FRM_ARBIT
        };

        // Rx queue 1 control register
        struct ETH_MTLRxQ1CR : public Register<0x5800ad7c> {
            using RXQ_WEGT = Field<0, 3>;    // RXQ_WEGT
            using RXQ_FRM_ARBIT = Field<3, 1>;    // RXQ_FRM_ARBIT
        };

        // The Queue ETS Control register controls the enhanced transmission selection operation.
        struct ETH_MTLTxQ1ECR : public Register<0x5800ad50> {
            using AVALG = Field<2, 1>;    // AVALG
            using CC = Field<3, 1>;    // CC
            using SLC = Field<4, 3>;    // SLC
        };

        // This register provides the average traffic transmitted on queue 1.
        struct ETH_MTLTxQ1QWR : public Register<0x5800ad58> {
            using ISCQW = Field<0, 21>;    // ISCQW
        };

        // The sendSlopeCredit register contains the sendSlope credit value required for the credit-based shaper algorithm for the Queue.
        struct ETH_MTLTxQ1SSCR : public Register<0x5800ad5c> {
            using SSC = Field<0, 14>;    // SSC
        };

        // The hiCredit register contains the hiCredit value required for the credit-based shaper algorithm for the Queue.
        struct ETH_MTLTxQ1HCR : public Register<0x5800ad60> {
            using HC = Field<0, 29>;    // HC
        };

        // The loCredit register contains the loCredit value required for the credit-based shaper algorithm for the Queue.
        struct ETH_MTLTxQ1LCR : public Register<0x5800ad64> {
            using LC = Field<0, 29>;    // LC
        };

    };

    // ETH_DMA
    struct ETH_DMA {
        // DMA mode register
        struct ETH_DMAMR : public Register<0x5800b000> {
            using SWR = Field<0, 1>;    // Software Reset
            using TAA = Field<2, 3>;    // TAA
            using TXPR = Field<11, 1>;    // Transmit priority
            using PR = Field<12, 3>;    // Priority ratio
            using INTM = Field<16, 2>;    // Interrupt Mode
        };

        // System bus mode register
        struct ETH_DMASBMR : public Register<0x5800b004> {
            using FB = Field<0, 1>;    // Fixed Burst Length
            using BLEN4 = Field<1, 1>;    // BLEN4
            using BLEN8 = Field<2, 1>;    // BLEN8
            using BLEN16 = Field<3, 1>;    // BLEN16
            using BLEN32 = Field<4, 1>;    // BLEN32
            using BLEN64 = Field<5, 1>;    // BLEN64
            using BLEN128 = Field<6, 1>;    // BLEN128
            using BLEN256 = Field<7, 1>;    // BLEN256
            using AAL = Field<12, 1>;    // Address-Aligned Beats
            using ONEKBBE = Field<13, 1>;    // ONEKBBE
            using RD_OSR_LMT = Field<16, 2>;    // RD_OSR_LMT
            using WR_OSR_LMT = Field<24, 2>;    // WR_OSR_LMT
            using LPI_XIT_PKT = Field<30, 1>;    // LPI_XIT_PKT
            using EN_LPI = Field<31, 1>;    // EN_LPI
        };

        // Interrupt status register
        struct ETH_DMAISR : public RegisterReadOnly<0x5800b008> {
            using DC0IS = Field<0, 1>;    // DMA Channel Interrupt Status
            using DC1IS = Field<1, 1>;    // DC1IS
            using MTLIS = Field<16, 1>;    // MTL Interrupt Status
            using MACIS = Field<17, 1>;    // MAC Interrupt Status
        };

        // Debug status register
        struct ETH_DMADSR : public RegisterReadOnly<0x5800b00c> {
            using AXWHSTS = Field<0, 1>;    // AHB Master Write Channel
            using AXRHSTS = Field<1, 1>;    // AXRHSTS
            using RPS0 = Field<8, 4>;    // RPS0
            using TPS0 = Field<12, 4>;    // TPS0
            using RPS1 = Field<16, 4>;    // RPS1
            using TPS1 = Field<20, 4>;    // TPS1
        };

        // AXI4 transmit channel ACE control register
        struct ETH_DMAA4TxACR : public Register<0x5800b020> {
            using TDRC = Field<0, 4>;    // TDRC
            using TEC = Field<8, 4>;    // TEC
            using THC = Field<16, 4>;    // THC
        };

        // AXI4 receive channel ACE control register
        struct ETH_DMAA4RxACR : public Register<0x5800b024> {
            using RDWC = Field<0, 4>;    // RDWC
            using RPC = Field<8, 4>;    // RPC
            using RHC = Field<16, 4>;    // RHC
            using RDC = Field<24, 2>;    // RDC
        };

        // AXI4 descriptor ACE control register
        struct ETH_DMAA4DACR : public Register<0x5800b028> {
            using TDWC = Field<0, 4>;    // TDWC
            using TDWD = Field<4, 2>;    // TDWD
            using RDRC = Field<8, 4>;    // RDRC
            using RDP = Field<16, 3>;    // RDP
            using WRP = Field<20, 3>;    // WRP
        };

        // Channel 0 control register
        struct ETH_DMAC0CR : public Register<0x5800b100> {
            using MSS = Field<0, 14>;    // MSS
            using PBLX8 = Field<16, 1>;    // PBLX8
            using DSL = Field<18, 3>;    // DSL
        };

        // Channel 1 control register
        struct ETH_DMAC1CR : public Register<0x5800b180> {
            using MSS = Field<0, 14>;    // MSS
            using PBLX8 = Field<16, 1>;    // PBLX8
            using DSL = Field<18, 3>;    // DSL
        };

        // Channel 0 transmit control register
        struct ETH_DMAC0TxCR : public Register<0x5800b104> {
            using ST = Field<0, 1>;    // ST
            using TCW = Field<1, 3>;    // TCW
            using OSF = Field<4, 1>;    // OSF
            using TSE = Field<12, 1>;    // TSE
            using TXPBL = Field<16, 6>;    // TXPBL
            using TQOS = Field<24, 4>;    // TQOS
        };

        // Channel 1 transmit control register
        struct ETH_DMAC1TxCR : public Register<0x5800b184> {
            using ST = Field<0, 1>;    // ST
            using TCW = Field<1, 3>;    // TCW
            using OSF = Field<4, 1>;    // OSF
            using TSE = Field<12, 1>;    // TSE
            using TXPBL = Field<16, 6>;    // TXPBL
            using TQOS = Field<24, 4>;    // TQOS
        };

        // Channel receive control register
        struct ETH_DMAC0RxCR : public Register<0x5800b108> {
            using SR = Field<0, 1>;    // Start or Stop Receive Command
            using RBSZ = Field<1, 14>;    // Receive Buffer size
            using RXPBL = Field<16, 6>;    // RXPBL
            using RQOS = Field<24, 4>;    // RQOS
            using RPF = Field<31, 1>;    // DMA Rx Channel Packet Flush
        };

        // Channel i Tx descriptor list address register
        struct ETH_DMAC0TxDLAR : public Register<0x5800b114> {
            using TDESLA = Field<3, 29>;    // Start of Transmit List
        };

        // Channel i Tx descriptor list address register
        struct ETH_DMAC1TxDLAR : public Register<0x5800b194> {
            using TDESLA = Field<3, 29>;    // Start of Transmit List
        };

        // Channel Rx descriptor list address register
        struct ETH_DMAC0RxDLAR : public Register<0x5800b11c> {
            using RDESLA = Field<3, 29>;    // Start of Receive List
        };

        // Channel Tx descriptor tail pointer register
        struct ETH_DMAC0TxDTPR : public Register<0x5800b120> {
            using TDT = Field<3, 29>;    // Transmit Descriptor Tail Pointer
        };

        // Channel Tx descriptor tail pointer register
        struct ETH_DMAC1TxDTPR : public Register<0x5800b1a0> {
            using TDT = Field<3, 29>;    // Transmit Descriptor Tail Pointer
        };

        // Channel Rx descriptor tail pointer register
        struct ETH_DMAC0RxDTPR : public Register<0x5800b128> {
            using RDT = Field<3, 29>;    // Receive Descriptor Tail Pointer
        };

        // Channel Tx descriptor ring length register
        struct ETH_DMAC0TxRLR : public Register<0x5800b12c> {
            using TDRL = Field<0, 10>;    // Transmit Descriptor Ring Length
        };

        // Channel Tx descriptor ring length register
        struct ETH_DMAC1TxRLR : public Register<0x5800b1ac> {
            using TDRL = Field<0, 10>;    // Transmit Descriptor Ring Length
        };

        // Channel Rx descriptor ring length register
        struct ETH_DMAC0RxRLR : public Register<0x5800b130> {
            using RDRL = Field<0, 10>;    // Receive Descriptor Ring Length
        };

        // Channel interrupt enable register
        struct ETH_DMAC0IER : public Register<0x5800b134> {
            using TIE = Field<0, 1>;    // Transmit Interrupt Enable
            using TXSE = Field<1, 1>;    // Transmit Stopped Enable
            using TBUE = Field<2, 1>;    // Transmit Buffer Unavailable Enable
            using RIE = Field<6, 1>;    // Receive Interrupt Enable
            using RBUE = Field<7, 1>;    // Receive Buffer Unavailable Enable
            using RSE = Field<8, 1>;    // Receive Stopped Enable
            using RWTE = Field<9, 1>;    // Receive Watchdog Timeout Enable
            using ETIE = Field<10, 1>;    // Early Transmit Interrupt Enable
            using ERIE = Field<11, 1>;    // Early Receive Interrupt Enable
            using FBEE = Field<12, 1>;    // Fatal Bus Error Enable
            using CDEE = Field<13, 1>;    // Context Descriptor Error Enable
            using AIE = Field<14, 1>;    // Abnormal Interrupt Summary Enable
            using NIE = Field<15, 1>;    // Normal Interrupt Summary Enable
        };

        // Channel interrupt enable register
        struct ETH_DMAC1IER : public Register<0x5800b1b4> {
            using TIE = Field<0, 1>;    // Transmit Interrupt Enable
            using TXSE = Field<1, 1>;    // Transmit Stopped Enable
            using TBUE = Field<2, 1>;    // Transmit Buffer Unavailable Enable
            using RIE = Field<6, 1>;    // Receive Interrupt Enable
            using RBUE = Field<7, 1>;    // Receive Buffer Unavailable Enable
            using RSE = Field<8, 1>;    // Receive Stopped Enable
            using RWTE = Field<9, 1>;    // Receive Watchdog Timeout Enable
            using ETIE = Field<10, 1>;    // Early Transmit Interrupt Enable
            using ERIE = Field<11, 1>;    // Early Receive Interrupt Enable
            using FBEE = Field<12, 1>;    // Fatal Bus Error Enable
            using CDEE = Field<13, 1>;    // Context Descriptor Error Enable
            using AIE = Field<14, 1>;    // Abnormal Interrupt Summary Enable
            using NIE = Field<15, 1>;    // Normal Interrupt Summary Enable
        };

        // Channel Rx interrupt watchdog timer register
        struct ETH_DMAC0RxIWTR : public Register<0x5800b138> {
            using RWT = Field<0, 8>;    // Receive Interrupt Watchdog Timer Count
        };

        // Channel i slot function control status register
        struct ETH_DMAC0SFCSR : public Register<0x5800b13c> {
            using ESC = Field<0, 1>;    // ESC
            using ASC = Field<1, 1>;    // ASC
            using RSN = Field<16, 4>;    // RSN
        };

        // Channel i slot function control status register
        struct ETH_DMAC1SFCSR : public Register<0x5800b1bc> {
            using ESC = Field<0, 1>;    // ESC
            using ASC = Field<1, 1>;    // ASC
            using RSN = Field<16, 4>;    // RSN
        };

        // Channel current application transmit descriptor register
        struct ETH_DMAC0CATxDR : public RegisterReadOnly<0x5800b144> {
            using CURTDESAPTR = Field<0, 32>;    // Application Transmit Descriptor Address Pointer
        };

        // Channel current application transmit descriptor register
        struct ETH_DMAC1CATxDR : public RegisterReadOnly<0x5800b1c4> {
            using CURTDESAPTR = Field<0, 32>;    // Application Transmit Descriptor Address Pointer
        };

        // Channel 0 current application receive descriptor register
        struct ETH_DMAC0CARxDR : public RegisterReadOnly<0x5800b14c> {
            using CURRDESAPTR = Field<0, 32>;    // Application Transmit Descriptor Address Pointer
        };

        // Channel 0 current application transmit buffer register
        struct ETH_DMAC0CATxBR : public RegisterReadOnly<0x5800b154> {
            using CURTBUFAPTR = Field<0, 32>;    // Application Transmit Buffer Address Pointer
        };

        // Channel 0 current application transmit buffer register
        struct ETH_DMAC1CATxBR : public RegisterReadOnly<0x5800b1d4> {
            using CURTBUFAPTR = Field<0, 32>;    // Application Transmit Buffer Address Pointer
        };

        // Channel current application receive buffer register
        struct ETH_DMAC0CARxBR : public RegisterReadOnly<0x5800b15c> {
            using CURRBUFAPTR = Field<0, 32>;    // Application Receive Buffer Address Pointer
        };

        // Channel status register
        struct ETH_DMAC0SR : public Register<0x5800b160> {
            using TI = Field<0, 1>;    // Transmit Interrupt
            using TPS = Field<1, 1>;    // Transmit Process Stopped
            using TBU = Field<2, 1>;    // Transmit Buffer Unavailable
            using RI = Field<6, 1>;    // Receive Interrupt
            using RBU = Field<7, 1>;    // Receive Buffer Unavailable
            using RPS = Field<8, 1>;    // Receive Process Stopped
            using RWT = Field<9, 1>;    // Receive Watchdog Timeout
            using ETI = Field<10, 1>;    // Early Transmit Interrupt
            using ERI = Field<11, 1>;    // Early Receive Interrupt
            using FBE = Field<12, 1>;    // Fatal Bus Error
            using CDE = Field<13, 1>;    // Context Descriptor Error
            using AIS = Field<14, 1>;    // Abnormal Interrupt Summary
            using NIS = Field<15, 1>;    // Normal Interrupt Summary
            using TEB = Field<16, 3>;    // Tx DMA Error Bits
            using REB = Field<19, 3>;    // Rx DMA Error Bits
        };

        // Channel status register
        struct ETH_DMAC1SR : public Register<0x5800b1e0> {
            using TI = Field<0, 1>;    // Transmit Interrupt
            using TPS = Field<1, 1>;    // Transmit Process Stopped
            using TBU = Field<2, 1>;    // Transmit Buffer Unavailable
            using RI = Field<6, 1>;    // Receive Interrupt
            using RBU = Field<7, 1>;    // Receive Buffer Unavailable
            using RPS = Field<8, 1>;    // Receive Process Stopped
            using RWT = Field<9, 1>;    // Receive Watchdog Timeout
            using ETI = Field<10, 1>;    // Early Transmit Interrupt
            using ERI = Field<11, 1>;    // Early Receive Interrupt
            using FBE = Field<12, 1>;    // Fatal Bus Error
            using CDE = Field<13, 1>;    // Context Descriptor Error
            using AIS = Field<14, 1>;    // Abnormal Interrupt Summary
            using NIS = Field<15, 1>;    // Normal Interrupt Summary
            using TEB = Field<16, 3>;    // Tx DMA Error Bits
            using REB = Field<19, 3>;    // Rx DMA Error Bits
        };

        // Channel missed frame count register
        struct ETH_DMAC0MFCR : public RegisterReadOnly<0x5800b16c> {
            using MFC = Field<0, 11>;    // Dropped Packet Counters
            using MFCO = Field<15, 1>;    // Overflow status of the MFC Counter
        };

        // Channel missed frame count register
        struct ETH_DMAC1MFCR : public RegisterReadOnly<0x5800b1ec> {
            using MFC = Field<0, 11>;    // Dropped Packet Counters
            using MFCO = Field<15, 1>;    // Overflow status of the MFC Counter
        };

    };

    // EXTI
    struct EXTI {
        // Contains only register bits for configurable events.
        struct EXTI_RTSR1 : public Register<0x5000d000> {
            using RT0 = Field<0, 1>;    // RT0
            using RT1 = Field<1, 1>;    // RT1
            using RT2 = Field<2, 1>;    // RT2
            using RT3 = Field<3, 1>;    // RT3
            using RT4 = Field<4, 1>;    // RT4
            using RT5 = Field<5, 1>;    // RT5
            using RT6 = Field<6, 1>;    // RT6
            using RT7 = Field<7, 1>;    // RT7
            using RT8 = Field<8, 1>;    // RT8
            using RT9 = Field<9, 1>;    // RT9
            using RT10 = Field<10, 1>;    // RT10
            using RT11 = Field<11, 1>;    // RT11
            using RT12 = Field<12, 1>;    // RT12
            using RT13 = Field<13, 1>;    // RT13
            using RT14 = Field<14, 1>;    // RT14
            using RT15 = Field<15, 1>;    // RT15
            using RT16 = Field<16, 1>;    // RT16
        };

        // Contains only register bits for configurable events.
        struct EXTI_FTSR1 : public Register<0x5000d004> {
            using FT0 = Field<0, 1>;    // FT0
            using FT1 = Field<1, 1>;    // FT1
            using FT2 = Field<2, 1>;    // FT2
            using FT3 = Field<3, 1>;    // FT3
            using FT4 = Field<4, 1>;    // FT4
            using FT5 = Field<5, 1>;    // FT5
            using FT6 = Field<6, 1>;    // FT6
            using FT7 = Field<7, 1>;    // FT7
            using FT8 = Field<8, 1>;    // FT8
            using FT9 = Field<9, 1>;    // FT9
            using FT10 = Field<10, 1>;    // FT10
            using FT11 = Field<11, 1>;    // FT11
            using FT12 = Field<12, 1>;    // FT12
            using FT13 = Field<13, 1>;    // FT13
            using FT14 = Field<14, 1>;    // FT14
            using FT15 = Field<15, 1>;    // FT15
            using FT16 = Field<16, 1>;    // FT16
        };

        // Contains only register bits for configurable events.
        struct EXTI_SWIER1 : public Register<0x5000d008> {
            using SWI0 = Field<0, 1>;    // SWI0
            using SWI1 = Field<1, 1>;    // SWI1
            using SWI2 = Field<2, 1>;    // SWI2
            using SWI3 = Field<3, 1>;    // SWI3
            using SWI4 = Field<4, 1>;    // SWI4
            using SWI5 = Field<5, 1>;    // SWI5
            using SWI6 = Field<6, 1>;    // SWI6
            using SWI7 = Field<7, 1>;    // SWI7
            using SWI8 = Field<8, 1>;    // SWI8
            using SWI9 = Field<9, 1>;    // SWI9
            using SWI10 = Field<10, 1>;    // SWI10
            using SWI11 = Field<11, 1>;    // SWI11
            using SWI12 = Field<12, 1>;    // SWI12
            using SWI13 = Field<13, 1>;    // SWI13
            using SWI14 = Field<14, 1>;    // SWI14
            using SWI15 = Field<15, 1>;    // SWI15
            using SWI16 = Field<16, 1>;    // SWI16
        };

        // Contains only register bits for configurable events.
        struct EXTI_RPR1 : public Register<0x5000d00c> {
            using RPIF0 = Field<0, 1>;    // RPIF0
            using RPIF1 = Field<1, 1>;    // RPIF1
            using RPIF2 = Field<2, 1>;    // RPIF2
            using RPIF3 = Field<3, 1>;    // RPIF3
            using RPIF4 = Field<4, 1>;    // RPIF4
            using RPIF5 = Field<5, 1>;    // RPIF5
            using RPIF6 = Field<6, 1>;    // RPIF6
            using RPIF7 = Field<7, 1>;    // RPIF7
            using RPIF8 = Field<8, 1>;    // RPIF8
            using RPIF9 = Field<9, 1>;    // RPIF9
            using RPIF10 = Field<10, 1>;    // RPIF10
            using RPIF11 = Field<11, 1>;    // RPIF11
            using RPIF12 = Field<12, 1>;    // RPIF12
            using RPIF13 = Field<13, 1>;    // RPIF13
            using RPIF14 = Field<14, 1>;    // RPIF14
            using RPIF15 = Field<15, 1>;    // RPIF15
            using RPIF16 = Field<16, 1>;    // RPIF16
        };

        // Contains only register bits for configurable events.
        struct EXTI_FPR1 : public Register<0x5000d010> {
            using FPIF0 = Field<0, 1>;    // FPIF0
            using FPIF1 = Field<1, 1>;    // FPIF1
            using FPIF2 = Field<2, 1>;    // FPIF2
            using FPIF3 = Field<3, 1>;    // FPIF3
            using FPIF4 = Field<4, 1>;    // FPIF4
            using FPIF5 = Field<5, 1>;    // FPIF5
            using FPIF6 = Field<6, 1>;    // FPIF6
            using FPIF7 = Field<7, 1>;    // FPIF7
            using FPIF8 = Field<8, 1>;    // FPIF8
            using FPIF9 = Field<9, 1>;    // FPIF9
            using FPIF10 = Field<10, 1>;    // FPIF10
            using FPIF11 = Field<11, 1>;    // FPIF11
            using FPIF12 = Field<12, 1>;    // FPIF12
            using FPIF13 = Field<13, 1>;    // FPIF13
            using FPIF14 = Field<14, 1>;    // FPIF14
            using FPIF15 = Field<15, 1>;    // FPIF15
            using FPIF16 = Field<16, 1>;    // FPIF16
        };

        // This register provides TrustZone Write access security, a non-secure write access will generate a bus error. A non-secure read will return the register data. Contains only register bits for TrustZone capable Input events.
        struct EXTI_TZENR1 : public Register<0x5000d014> {
            using TZEN0 = Field<0, 1>;    // TZEN0
            using TZEN1 = Field<1, 1>;    // TZEN1
            using TZEN2 = Field<2, 1>;    // TZEN2
            using TZEN3 = Field<3, 1>;    // TZEN3
            using TZEN4 = Field<4, 1>;    // TZEN4
            using TZEN5 = Field<5, 1>;    // TZEN5
            using TZEN6 = Field<6, 1>;    // TZEN6
            using TZEN7 = Field<7, 1>;    // TZEN7
            using TZEN8 = Field<8, 1>;    // TZEN8
            using TZEN9 = Field<9, 1>;    // TZEN9
            using TZEN10 = Field<10, 1>;    // TZEN10
            using TZEN11 = Field<11, 1>;    // TZEN11
            using TZEN12 = Field<12, 1>;    // TZEN12
            using TZEN13 = Field<13, 1>;    // TZEN13
            using TZEN14 = Field<14, 1>;    // TZEN14
            using TZEN15 = Field<15, 1>;    // TZEN15
            using TZEN17 = Field<17, 1>;    // TZEN17
            using TZEN18 = Field<18, 1>;    // TZEN18
            using TZEN19 = Field<19, 1>;    // TZEN19
            using TZEN24 = Field<24, 1>;    // TZEN24
            using TZEN26 = Field<26, 1>;    // TZEN26
        };

        // Contains only register bits for configurable events.
        struct EXTI_RTSR2 : public Register<0x5000d020> {
        };

        // Contains only register bits for configurable events.
        struct EXTI_FTSR2 : public Register<0x5000d024> {
        };

        // Contains only register bits for configurable events.
        struct EXTI_SWIER2 : public Register<0x5000d028> {
        };

        // Contains only register bits for configurable events.
        struct EXTI_RPR2 : public Register<0x5000d02c> {
        };

        // Contains only register bits for configurable events.
        struct EXTI_FPR2 : public Register<0x5000d030> {
        };

        // This register provides TrustZone Write access security, a non-secure write access will generate a bus error. A non-secure read will return the register data. Contains only register bits for TrustZone capable Input events.
        struct EXTI_TZENR2 : public Register<0x5000d034> {
            using TZEN41 = Field<9, 1>;    // TZEN41
            using TZEN54 = Field<22, 1>;    // TZEN54
            using TZEN55 = Field<23, 1>;    // TZEN55
            using TZEN56 = Field<24, 1>;    // TZEN56
            using TZEN57 = Field<25, 1>;    // TZEN57
            using TZEN58 = Field<26, 1>;    // TZEN58
            using TZEN59 = Field<27, 1>;    // TZEN59
            using TZEN60 = Field<28, 1>;    // TZEN60
        };

        // Contains only register bits for configurable events.
        struct EXTI_RTSR3 : public Register<0x5000d040> {
            using RT65 = Field<1, 1>;    // RT65
            using RT66 = Field<2, 1>;    // RT66
            using RT68 = Field<4, 1>;    // RT68
            using RT73 = Field<9, 1>;    // RT73
            using RT74 = Field<10, 1>;    // RT74
        };

        // Contains only register bits for configurable events.
        struct EXTI_FTSR3 : public Register<0x5000d044> {
            using FT65 = Field<1, 1>;    // FT65
            using FT66 = Field<2, 1>;    // FT66
            using FT68 = Field<4, 1>;    // FT68
            using FT73 = Field<9, 1>;    // FT73
            using FT74 = Field<10, 1>;    // FT74
        };

        // Contains only register bits for configurable events.
        struct EXTI_SWIER3 : public Register<0x5000d048> {
            using SWI65 = Field<1, 1>;    // SWI65
            using SWI66 = Field<2, 1>;    // SWI66
            using SWI68 = Field<4, 1>;    // SWI68
            using SWI73 = Field<9, 1>;    // SWI73
            using SWI74 = Field<10, 1>;    // SWI74
        };

        // Contains only register bits for configurable events.
        struct EXTI_RPR3 : public Register<0x5000d04c> {
            using RPIF65 = Field<1, 1>;    // RPIF65
            using RPIF66 = Field<2, 1>;    // RPIF66
            using RPIF68 = Field<4, 1>;    // RPIF68
            using RPIF73 = Field<9, 1>;    // RPIF73
            using RPIF74 = Field<10, 1>;    // RPIF74
        };

        // Contains only register bits for configurable events.
        struct EXTI_FPR3 : public Register<0x5000d050> {
            using FPIF65 = Field<1, 1>;    // FPIF65
            using FPIF66 = Field<2, 1>;    // FPIF66
            using FPIF68 = Field<4, 1>;    // FPIF68
            using FPIF73 = Field<9, 1>;    // FPIF73
            using FPIF74 = Field<10, 1>;    // FPIF74
        };

        // This register provides TrustZone Write access security, a non-secure write access will generate a bus error. A non-secure read will return the register data. Contains only register bits for TrustZone capable Input events.
        struct EXTI_TZENR3 : public Register<0x5000d054> {
        };

        // EXTIm fields contain only the number of bits in line with the nb_ioport configuration.
        struct EXTI_EXTICR1 : public Register<0x5000d060> {
            using EXTI0 = Field<0, 8>;    // EXTI0
            using EXTI1 = Field<8, 8>;    // EXTI1
            using EXTI2 = Field<16, 8>;    // EXTI2
            using EXTI3 = Field<24, 8>;    // EXTI3
        };

        // EXTIm fields contain only the number of bits in line with the nb_ioport configuration.
        struct EXTI_EXTICR2 : public Register<0x5000d064> {
            using EXTI4 = Field<0, 8>;    // EXTI4
            using EXTI5 = Field<8, 8>;    // EXTI5
            using EXTI6 = Field<16, 8>;    // EXTI6
            using EXTI7 = Field<24, 8>;    // EXTI7
        };

        // EXTIm fields contain only the number of bits in line with the nb_ioport configuration.
        struct EXTI_EXTICR3 : public Register<0x5000d068> {
            using EXTI8 = Field<0, 8>;    // EXTI8
            using EXTI9 = Field<8, 8>;    // EXTI9
            using EXTI10 = Field<16, 8>;    // EXTI10
            using EXTI11 = Field<24, 8>;    // EXTI11
        };

        // EXTIm fields contain only the number of bits in line with the nb_ioport configuration.
        struct EXTI_EXTICR4 : public Register<0x5000d06c> {
            using EXTI12 = Field<0, 8>;    // EXTI12
            using EXTI13 = Field<8, 8>;    // EXTI13
            using EXTI14 = Field<16, 8>;    // EXTI14
            using EXTI15 = Field<24, 8>;    // EXTI15
        };

        // Contains register bits for configurable events and Direct events.
        struct EXTI_IMR1 : public Register<0x5000d080> {
            using IM0 = Field<0, 1>;    // IM0
            using IM1 = Field<1, 1>;    // IM1
            using IM2 = Field<2, 1>;    // IM2
            using IM3 = Field<3, 1>;    // IM3
            using IM4 = Field<4, 1>;    // IM4
            using IM5 = Field<5, 1>;    // IM5
            using IM6 = Field<6, 1>;    // IM6
            using IM7 = Field<7, 1>;    // IM7
            using IM8 = Field<8, 1>;    // IM8
            using IM9 = Field<9, 1>;    // IM9
            using IM10 = Field<10, 1>;    // IM10
            using IM11 = Field<11, 1>;    // IM11
            using IM12 = Field<12, 1>;    // IM12
            using IM13 = Field<13, 1>;    // IM13
            using IM14 = Field<14, 1>;    // IM14
            using IM15 = Field<15, 1>;    // IM15
            using IM16 = Field<16, 1>;    // IM16
            using IM17 = Field<17, 1>;    // IM17
            using IM18 = Field<18, 1>;    // IM18
            using IM19 = Field<19, 1>;    // IM19
            using IM20 = Field<20, 1>;    // IM20
            using IM21 = Field<21, 1>;    // IM21
            using IM22 = Field<22, 1>;    // IM22
            using IM23 = Field<23, 1>;    // IM23
            using IM24 = Field<24, 1>;    // IM24
            using IM25 = Field<25, 1>;    // IM25
            using IM26 = Field<26, 1>;    // IM26
            using IM27 = Field<27, 1>;    // IM27
            using IM28 = Field<28, 1>;    // IM28
            using IM29 = Field<29, 1>;    // IM29
            using IM30 = Field<30, 1>;    // IM30
            using IM31 = Field<31, 1>;    // IM31
        };

        // EXTI CPU wakeup with event mask register
        struct EXTI_EMR1 : public Register<0x5000d084> {
            using EM0 = Field<0, 1>;    // EM0
            using EM1 = Field<1, 1>;    // EM1
            using EM2 = Field<2, 1>;    // EM2
            using EM3 = Field<3, 1>;    // EM3
            using EM4 = Field<4, 1>;    // EM4
            using EM5 = Field<5, 1>;    // EM5
            using EM6 = Field<6, 1>;    // EM6
            using EM7 = Field<7, 1>;    // EM7
            using EM8 = Field<8, 1>;    // EM8
            using EM9 = Field<9, 1>;    // EM9
            using EM10 = Field<10, 1>;    // EM10
            using EM11 = Field<11, 1>;    // EM11
            using EM12 = Field<12, 1>;    // EM12
            using EM13 = Field<13, 1>;    // EM13
            using EM14 = Field<14, 1>;    // EM14
            using EM15 = Field<15, 1>;    // EM15
            using EM17 = Field<17, 1>;    // EM17
            using EM18 = Field<18, 1>;    // EM18
            using EM19 = Field<19, 1>;    // EM19
        };

        // Contains register bits for configurable events and direct events.
        struct EXTI_IMR2 : public Register<0x5000d090> {
            using IM32 = Field<0, 1>;    // IM32
            using IM33 = Field<1, 1>;    // IM33
            using IM34 = Field<2, 1>;    // IM34
            using IM35 = Field<3, 1>;    // IM35
            using IM36 = Field<4, 1>;    // IM36
            using IM37 = Field<5, 1>;    // IM37
            using IM38 = Field<6, 1>;    // IM38
            using IM39 = Field<7, 1>;    // IM39
            using IM40 = Field<8, 1>;    // IM40
            using IM41 = Field<9, 1>;    // IM41
            using IM42 = Field<10, 1>;    // IM42
            using IM43 = Field<11, 1>;    // IM43
            using IM44 = Field<12, 1>;    // IM44
            using IM45 = Field<13, 1>;    // IM45
            using IM46 = Field<14, 1>;    // IM46
            using IM47 = Field<15, 1>;    // IM47
            using IM48 = Field<16, 1>;    // IM48
            using IM49 = Field<17, 1>;    // IM49
            using IM50 = Field<18, 1>;    // IM50
            using IM51 = Field<19, 1>;    // IM51
            using IM52 = Field<20, 1>;    // IM52
            using IM53 = Field<21, 1>;    // IM53
            using IM54 = Field<22, 1>;    // IM54
            using IM55 = Field<23, 1>;    // IM55
            using IM56 = Field<24, 1>;    // IM56
            using IM57 = Field<25, 1>;    // IM57
            using IM58 = Field<26, 1>;    // IM58
            using IM59 = Field<27, 1>;    // IM59
            using IM60 = Field<28, 1>;    // IM60
            using IM61 = Field<29, 1>;    // IM61
            using IM62 = Field<30, 1>;    // IM62
            using IM63 = Field<31, 1>;    // IM63
        };

        // EXTI CPU wakeup with event mask register
        struct EXTI_EMR2 : public Register<0x5000d094> {
        };

        // Contains register bits for configurable events and direct events.
        struct EXTI_IMR3 : public Register<0x5000d0a0> {
            using IM64 = Field<0, 1>;    // IM64
            using IM65 = Field<1, 1>;    // IM65
            using IM66 = Field<2, 1>;    // IM66
            using IM67 = Field<3, 1>;    // IM67
            using IM68 = Field<4, 1>;    // IM68
            using IM69 = Field<5, 1>;    // IM69
            using IM70 = Field<6, 1>;    // IM70
            using IM71 = Field<7, 1>;    // IM71
            using IM72 = Field<8, 1>;    // IM72
            using IM73 = Field<9, 1>;    // IM73
            using IM74 = Field<10, 1>;    // IM74
            using IM75 = Field<11, 1>;    // IM75
        };

        // EXTI CPU wakeup with event mask register
        struct EXTI_EMR3 : public Register<0x5000d0a4> {
            using EM66 = Field<2, 1>;    // EM66
        };

        // Contains register bits for configurable events and Direct events.
        struct EXTI_C2IMR1 : public Register<0x5000d0c0> {
            using IM0 = Field<0, 1>;    // IM0
            using IM1 = Field<1, 1>;    // IM1
            using IM2 = Field<2, 1>;    // IM2
            using IM3 = Field<3, 1>;    // IM3
            using IM4 = Field<4, 1>;    // IM4
            using IM5 = Field<5, 1>;    // IM5
            using IM6 = Field<6, 1>;    // IM6
            using IM7 = Field<7, 1>;    // IM7
            using IM8 = Field<8, 1>;    // IM8
            using IM9 = Field<9, 1>;    // IM9
            using IM10 = Field<10, 1>;    // IM10
            using IM11 = Field<11, 1>;    // IM11
            using IM12 = Field<12, 1>;    // IM12
            using IM13 = Field<13, 1>;    // IM13
            using IM14 = Field<14, 1>;    // IM14
            using IM15 = Field<15, 1>;    // IM15
            using IM16 = Field<16, 1>;    // IM16
            using IM17 = Field<17, 1>;    // IM17
            using IM18 = Field<18, 1>;    // IM18
            using IM19 = Field<19, 1>;    // IM19
            using IM20 = Field<20, 1>;    // IM20
            using IM21 = Field<21, 1>;    // IM21
            using IM22 = Field<22, 1>;    // IM22
            using IM23 = Field<23, 1>;    // IM23
            using IM24 = Field<24, 1>;    // IM24
            using IM25 = Field<25, 1>;    // IM25
            using IM26 = Field<26, 1>;    // IM26
            using IM27 = Field<27, 1>;    // IM27
            using IM28 = Field<28, 1>;    // IM28
            using IM29 = Field<29, 1>;    // IM29
            using IM30 = Field<30, 1>;    // IM30
            using IM31 = Field<31, 1>;    // IM31
        };

        // EXTI CPU2 wakeup with event mask register
        struct EXTI_C2EMR1 : public Register<0x5000d0c4> {
            using EM0 = Field<0, 1>;    // EM0
            using EM1 = Field<1, 1>;    // EM1
            using EM2 = Field<2, 1>;    // EM2
            using EM3 = Field<3, 1>;    // EM3
            using EM4 = Field<4, 1>;    // EM4
            using EM5 = Field<5, 1>;    // EM5
            using EM6 = Field<6, 1>;    // EM6
            using EM7 = Field<7, 1>;    // EM7
            using EM8 = Field<8, 1>;    // EM8
            using EM9 = Field<9, 1>;    // EM9
            using EM10 = Field<10, 1>;    // EM10
            using EM11 = Field<11, 1>;    // EM11
            using EM12 = Field<12, 1>;    // EM12
            using EM13 = Field<13, 1>;    // EM13
            using EM14 = Field<14, 1>;    // EM14
            using EM15 = Field<15, 1>;    // EM15
            using EM17 = Field<17, 1>;    // EM17
            using EM18 = Field<18, 1>;    // EM18
            using EM19 = Field<19, 1>;    // EM19
        };

        // Contains register bits for configurable events and direct events.
        struct EXTI_C2IMR2 : public Register<0x5000d0d0> {
            using IM32 = Field<0, 1>;    // IM32
            using IM33 = Field<1, 1>;    // IM33
            using IM34 = Field<2, 1>;    // IM34
            using IM35 = Field<3, 1>;    // IM35
            using IM36 = Field<4, 1>;    // IM36
            using IM37 = Field<5, 1>;    // IM37
            using IM38 = Field<6, 1>;    // IM38
            using IM39 = Field<7, 1>;    // IM39
            using IM40 = Field<8, 1>;    // IM40
            using IM41 = Field<9, 1>;    // IM41
            using IM42 = Field<10, 1>;    // IM42
            using IM43 = Field<11, 1>;    // IM43
            using IM44 = Field<12, 1>;    // IM44
            using IM45 = Field<13, 1>;    // IM45
            using IM46 = Field<14, 1>;    // IM46
            using IM47 = Field<15, 1>;    // IM47
            using IM48 = Field<16, 1>;    // IM48
            using IM49 = Field<17, 1>;    // IM49
            using IM50 = Field<18, 1>;    // IM50
            using IM51 = Field<19, 1>;    // IM51
            using IM52 = Field<20, 1>;    // IM52
            using IM53 = Field<21, 1>;    // IM53
            using IM54 = Field<22, 1>;    // IM54
            using IM55 = Field<23, 1>;    // IM55
            using IM56 = Field<24, 1>;    // IM56
            using IM57 = Field<25, 1>;    // IM57
            using IM58 = Field<26, 1>;    // IM58
            using IM59 = Field<27, 1>;    // IM59
            using IM60 = Field<28, 1>;    // IM60
            using IM61 = Field<29, 1>;    // IM61
            using IM62 = Field<30, 1>;    // IM62
            using IM63 = Field<31, 1>;    // IM63
        };

        // EXTI CPU2 wakeup with event mask register
        struct EXTI_C2EMR2 : public Register<0x5000d0d4> {
        };

        // Contains register bits for configurable events and direct events.
        struct EXTI_C2IMR3 : public Register<0x5000d0e0> {
            using IM64 = Field<0, 1>;    // IM64
            using IM65 = Field<1, 1>;    // IM65
            using IM66 = Field<2, 1>;    // IM66
            using IM67 = Field<3, 1>;    // IM67
            using IM68 = Field<4, 1>;    // IM68
            using IM69 = Field<5, 1>;    // IM69
            using IM70 = Field<6, 1>;    // IM70
            using IM71 = Field<7, 1>;    // IM71
            using IM72 = Field<8, 1>;    // IM72
            using IM73 = Field<9, 1>;    // IM73
            using IM74 = Field<10, 1>;    // IM74
            using IM75 = Field<11, 1>;    // IM75
        };

        // EXTI CPU2 wakeup with event mask register
        struct EXTI_C2EMR3 : public Register<0x5000d0e4> {
            using EM66 = Field<2, 1>;    // EM66
        };

        // EXTI hardware configuration register 13
        struct EXTI_HWCFGR13 : public RegisterReadOnly<0x5000d3c0> {
            using TZ = Field<0, 32>;    // TZ
        };

        // EXTI hardware configuration register 12
        struct EXTI_HWCFGR12 : public RegisterReadOnly<0x5000d3c4> {
            using TZ = Field<0, 32>;    // TZ
        };

        // EXTI hardware configuration register 11
        struct EXTI_HWCFGR11 : public RegisterReadOnly<0x5000d3c8> {
            using TZ = Field<0, 32>;    // TZ
        };

        // EXTI hardware configuration register 10
        struct EXTI_HWCFGR10 : public RegisterReadOnly<0x5000d3cc> {
        };

        // EXTI hardware configuration register 9
        struct EXTI_HWCFGR9 : public RegisterReadOnly<0x5000d3d0> {
        };

        // EXTI hardware configuration register 8
        struct EXTI_HWCFGR8 : public RegisterReadOnly<0x5000d3d4> {
        };

        // EXTI hardware configuration register 7
        struct EXTI_HWCFGR7 : public RegisterReadOnly<0x5000d3d8> {
            using CPUEVENT = Field<0, 32>;    // CPUEVENT
        };

        // EXTI hardware configuration register 6
        struct EXTI_HWCFGR6 : public RegisterReadOnly<0x5000d3dc> {
            using CPUEVENT = Field<0, 32>;    // CPUEVENT
        };

        // EXTI hardware configuration register 5
        struct EXTI_HWCFGR5 : public RegisterReadOnly<0x5000d3e0> {
            using CPUEVENT = Field<0, 32>;    // CPUEVENT
        };

        // EXTI hardware configuration register 4
        struct EXTI_HWCFGR4 : public RegisterReadOnly<0x5000d3e4> {
            using EVENT_TRG = Field<0, 32>;    // EVENT_TRG
        };

        // EXTI hardware configuration register 3
        struct EXTI_HWCFGR3 : public RegisterReadOnly<0x5000d3e8> {
            using EVENT_TRG = Field<0, 32>;    // EVENT_TRG
        };

        // EXTI hardware configuration register 2
        struct EXTI_HWCFGR2 : public RegisterReadOnly<0x5000d3ec> {
            using EVENT_TRG = Field<0, 32>;    // EVENT_TRG
        };

        // EXTI hardware configuration register 1
        struct EXTI_HWCFGR1 : public RegisterReadOnly<0x5000d3f0> {
            using NBEVENTS = Field<0, 8>;    // NBEVENTS
            using NBCPUS = Field<8, 4>;    // NBCPUS
            using CPUEVTEN = Field<12, 4>;    // CPUEVTEN
            using NBIOPORT = Field<16, 8>;    // NBIOPORT
        };

        // EXTI IP version register
        struct EXTI_VERR : public RegisterReadOnly<0x5000d3f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // EXTI identification register
        struct EXTI_IPIDR : public RegisterReadOnly<0x5000d3f8> {
            using IPID = Field<0, 32>;    // IPID
        };

        // EXTI size ID register
        struct EXTI_SIDR : public RegisterReadOnly<0x5000d3fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // FDCAN1
    struct FDCAN1 {
        // FDCAN core release register
        struct FDCAN_CREL : public RegisterReadOnly<0x4400e000> {
            using DAY = Field<0, 8>;    // DAY
            using MON = Field<8, 8>;    // MON
            using YEAR = Field<16, 4>;    // YEAR
            using SUBSTEP = Field<20, 4>;    // SUBSTEP
            using STEP = Field<24, 4>;    // STEP
            using REL = Field<28, 4>;    // REL
        };

        // FDCAN Endian register
        struct FDCAN_ENDN : public RegisterReadOnly<0x4400e004> {
            using ETV = Field<0, 32>;    // ETV
        };

        // This register is dedicated to data bit timing phase and only writable if bits FDCAN_CCCR.CCE and FDCAN_CCCR.INIT are set. The CAN time quantum may be programmed in the range from 1 to 32 FDCAN clock periods. tq = (DBRP + 1) FDCAN clock periods. DTSEG1 is the sum of Prop_Seg and Phase_Seg1. DTSEG2 is Phase_Seg2. Therefore the length of the bit time is (DTSEG1 + DTSEG2 + 3) tq for programmed values, or (Sync_Seg+Prop_Seg+Phase_Seg1+Phase_Seg2) tq for functional values. The information processing time (IPT) is zero, meaning the data for the next bit is available at the first clock edge after the sample point.
        struct FDCAN_DBTP : public Register<0x4400e00c> {
            using DSJW = Field<0, 4>;    // DSJW
            using DTSEG2 = Field<4, 4>;    // DTSEG2
            using DTSEG1 = Field<8, 5>;    // DTSEG1
            using DBRP = Field<16, 5>;    // DBRP
            using TDC = Field<23, 1>;    // TDC
        };

        // Write access to this register has to be enabled by setting bit FDCAN_CCCR.TEST to 1. All register functions are set to their reset values when bit FDCAN_CCCR.TEST is reset. Loop back mode and software control of Tx pin FDCANx_TX are hardware test modes. Programming TX differently from 00 may disturb the message transfer on the CAN bus.
        struct FDCAN_TEST : public Register<0x4400e010> {
            using LBCK = Field<4, 1>;    // LBCK
            using TX = Field<5, 2>;    // TX
            using RX = Field<7, 1>;    // RX
        };

        // The RAM watchdog monitors the READY output of the message RAM. A message RAM access starts the message RAM watchdog counter with the value configured by the FDCAN_RWD.WDC bits. The counter is reloaded with FDCAN_RWD.WDC bits when the message RAM signals successful completion by activating its READY output. In case there is no response from the message RAM until the counter has counted down to 0, the counter stops and interrupt flag FDCAN_IR.WDI bit is set. The RAM watchdog counter is clocked by the fdcan_pclk clock.
        struct FDCAN_RWD : public Register<0x4400e014> {
            using WDC = Field<0, 8>;    // WDC
            using WDV = Field<8, 8>;    // WDV
        };

        // For details about setting and resetting of single bits see Software initialization.
        struct FDCAN_CCCR : public Register<0x4400e018> {
            using INIT = Field<0, 1>;    // INIT
            using CCE = Field<1, 1>;    // CCE
            using ASM = Field<2, 1>;    // ASM
            using CSA = Field<3, 1>;    // CSA
            using CSR = Field<4, 1>;    // CSR
            using MON = Field<5, 1>;    // MON
            using DAR = Field<6, 1>;    // DAR
            using TEST = Field<7, 1>;    // TEST
            using FDOE = Field<8, 1>;    // FDOE
            using BRSE = Field<9, 1>;    // BRSE
            using PXHD = Field<12, 1>;    // PXHD
            using EFBI = Field<13, 1>;    // EFBI
            using TXP = Field<14, 1>;    // TXP
            using NISO = Field<15, 1>;    // NISO
        };

        // This register is dedicated to the nominal bit timing used during the arbitration phase.
        struct FDCAN_NBTP : public Register<0x4400e01c> {
            using NTSEG2 = Field<0, 7>;    // NTSEG2
            using NTSEG1 = Field<8, 8>;    // NTSEG1
            using NBRP = Field<16, 9>;    // NBRP
            using NSJW = Field<25, 7>;    // NSJW
        };

        // FDCAN timestamp counter configuration register
        struct FDCAN_TSCC : public Register<0x4400e020> {
            using TSS = Field<0, 2>;    // TSS
            using TCP = Field<16, 4>;    // TCP
        };

        // FDCAN timestamp counter value register
        struct FDCAN_TSCV : public Register<0x4400e024> {
            using TSC = Field<0, 16>;    // TSC
        };

        // FDCAN timeout counter configuration register
        struct FDCAN_TOCC : public Register<0x4400e028> {
            using ETOC = Field<0, 1>;    // ETOC
            using TOS = Field<1, 2>;    // TOS
            using TOP = Field<16, 16>;    // TOP
        };

        // FDCAN timeout counter value register
        struct FDCAN_TOCV : public Register<0x4400e02c> {
            using TOC = Field<0, 16>;    // TOC
        };

        // FDCAN error counter register
        struct FDCAN_ECR : public Register<0x4400e040> {
            using TEC = Field<0, 8>;    // TEC
            using TREC = Field<8, 7>;    // TREC
            using RP = Field<15, 1>;    // RP
            using CEL = Field<16, 8>;    // CEL
        };

        // FDCAN protocol status register
        struct FDCAN_PSR : public Register<0x4400e044> {
            using LEC = Field<0, 3>;    // LEC
            using ACT = Field<3, 2>;    // ACT
            using EP = Field<5, 1>;    // EP
            using EW = Field<6, 1>;    // EW
            using BO = Field<7, 1>;    // BO
            using DLEC = Field<8, 3>;    // DLEC
            using RESI = Field<11, 1>;    // RESI
            using RBRS = Field<12, 1>;    // RBRS
            using REDL = Field<13, 1>;    // REDL
            using PXE = Field<14, 1>;    // PXE
            using TDCV = Field<16, 7>;    // TDCV
        };

        // FDCAN transmitter delay compensation register
        struct FDCAN_TDCR : public Register<0x4400e048> {
            using TDCF = Field<0, 7>;    // TDCF
            using TDCO = Field<8, 7>;    // TDCO
        };

        // The flags are set when one of the listed conditions is detected (edge-sensitive). The flags remain set until the Host clears them. A flag is cleared by writing a 1 to the corresponding bit position. Writing a 0 has no effect. A hard reset will clear the register. The configuration of IE controls whether an interrupt is generated. The configuration of ILS controls on which interrupt line an interrupt is signaled.
        struct FDCAN_IR : public Register<0x4400e050> {
            using RF0N = Field<0, 1>;    // RF0N
            using RF0W = Field<1, 1>;    // RF0W
            using RF0F = Field<2, 1>;    // RF0F
            using RF0L = Field<3, 1>;    // RF0L
            using RF1N = Field<4, 1>;    // RF1N
            using RF1W = Field<5, 1>;    // RF1W
            using RF1F = Field<6, 1>;    // RF1F
            using RF1L = Field<7, 1>;    // RF1L
            using HPM = Field<8, 1>;    // HPM
            using TC = Field<9, 1>;    // TC
            using TCF = Field<10, 1>;    // TCF
            using TFE = Field<11, 1>;    // TFE
            using TEFN = Field<12, 1>;    // TEFN
            using TEFW = Field<13, 1>;    // TEFW
            using TEFF = Field<14, 1>;    // TEFF
            using TEFL = Field<15, 1>;    // TEFL
            using TSW = Field<16, 1>;    // TSW
            using MRAF = Field<17, 1>;    // MRAF
            using TOO = Field<18, 1>;    // TOO
            using DRX = Field<19, 1>;    // DRX
            using ELO = Field<22, 1>;    // ELO
            using EP = Field<23, 1>;    // EP
            using EW = Field<24, 1>;    // EW
            using BO = Field<25, 1>;    // BO
            using WDI = Field<26, 1>;    // WDI
            using PEA = Field<27, 1>;    // PEA
            using PED = Field<28, 1>;    // PED
            using ARA = Field<29, 1>;    // ARA
        };

        // The settings in the interrupt enable register determine which status changes in the interrupt register will be signaled on an interrupt line.
        struct FDCAN_IE : public Register<0x4400e054> {
            using RF0NE = Field<0, 1>;    // RF0NE
            using RF0WE = Field<1, 1>;    // RF0WE
            using RF0FE = Field<2, 1>;    // RF0FE
            using RF0LE = Field<3, 1>;    // RF0LE
            using RF1NE = Field<4, 1>;    // RF1NE
            using RF1WE = Field<5, 1>;    // RF1WE
            using RF1FE = Field<6, 1>;    // RF1FE
            using RF1LE = Field<7, 1>;    // RF1LE
            using HPME = Field<8, 1>;    // HPME
            using TCE = Field<9, 1>;    // TCE
            using TCFE = Field<10, 1>;    // TCFE
            using TFEE = Field<11, 1>;    // TFEE
            using TEFNE = Field<12, 1>;    // TEFNE
            using TEFWE = Field<13, 1>;    // TEFWE
            using TEFFE = Field<14, 1>;    // TEFFE
            using TEFLE = Field<15, 1>;    // TEFLE
            using TSWE = Field<16, 1>;    // TSWE
            using MRAFE = Field<17, 1>;    // MRAFE
            using TOOE = Field<18, 1>;    // TOOE
            using DRXE = Field<19, 1>;    // DRXE
            using BECE = Field<20, 1>;    // BECE
            using BEUE = Field<21, 1>;    // BEUE
            using ELOE = Field<22, 1>;    // ELOE
            using EPE = Field<23, 1>;    // EPE
            using EWE = Field<24, 1>;    // EWE
            using BOE = Field<25, 1>;    // BOE
            using WDIE = Field<26, 1>;    // WDIE
            using PEAE = Field<27, 1>;    // PEAE
            using PEDE = Field<28, 1>;    // PEDE
            using ARAE = Field<29, 1>;    // ARAE
        };

        // This register assigns an interrupt generated by a specific interrupt flag from the interrupt register to one of the two module interrupt lines. For interrupt generation the respective interrupt line has to be enabled via FDCAN_ILE.EINT0 and FDCAN_ILE.EINT1.
        struct FDCAN_ILS : public Register<0x4400e058> {
            using RF0NL = Field<0, 1>;    // RF0NL
            using RF0WL = Field<1, 1>;    // RF0WL
            using RF0FL = Field<2, 1>;    // RF0FL
            using RF0LL = Field<3, 1>;    // RF0LL
            using RF1NL = Field<4, 1>;    // RF1NL
            using RF1WL = Field<5, 1>;    // RF1WL
            using RF1FL = Field<6, 1>;    // RF1FL
            using RF1LL = Field<7, 1>;    // RF1LL
            using HPML = Field<8, 1>;    // HPML
            using TCL = Field<9, 1>;    // TCL
            using TCFL = Field<10, 1>;    // TCFL
            using TFEL = Field<11, 1>;    // TFEL
            using TEFNL = Field<12, 1>;    // TEFNL
            using TEFWL = Field<13, 1>;    // TEFWL
            using TEFFL = Field<14, 1>;    // TEFFL
            using TEFLL = Field<15, 1>;    // TEFLL
            using TSWL = Field<16, 1>;    // TSWL
            using MRAFL = Field<17, 1>;    // MRAFL
            using TOOL = Field<18, 1>;    // TOOL
            using DRXL = Field<19, 1>;    // DRXL
            using BECL = Field<20, 1>;    // BECL
            using BEUL = Field<21, 1>;    // BEUL
            using ELOL = Field<22, 1>;    // ELOL
            using EPL = Field<23, 1>;    // EPL
            using EWL = Field<24, 1>;    // EWL
            using BOL = Field<25, 1>;    // BOL
            using WDIL = Field<26, 1>;    // WDIL
            using PEAL = Field<27, 1>;    // PEAL
            using PEDL = Field<28, 1>;    // PEDL
            using ARAL = Field<29, 1>;    // ARAL
        };

        // Each of the two interrupt lines to the CPU can be enabled/disabled separately by programming bits EINT0 and EINT1.
        struct FDCAN_ILE : public Register<0x4400e05c> {
            using EINT0 = Field<0, 1>;    // EINT0
            using EINT1 = Field<1, 1>;    // EINT1
        };

        // Global settings for message ID filtering. The global filter configuration register controls the filter path for standard and extended messages as described in Figure708: Standard message ID filter path and Figure709: Extended message ID filter path.
        struct FDCAN_GFC : public Register<0x4400e080> {
            using RRFE = Field<0, 1>;    // RRFE
            using RRFS = Field<1, 1>;    // RRFS
            using ANFE = Field<2, 2>;    // ANFE
            using ANFS = Field<4, 2>;    // ANFS
        };

        // Settings for 11-bit standard message ID filtering.The standard ID filter configuration register controls the filter path for standard messages as described in Figure708.
        struct FDCAN_SIDFC : public Register<0x4400e084> {
            using FLSSA = Field<2, 14>;    // FLSSA
            using LSS = Field<16, 8>;    // LSS
        };

        // Settings for 29-bit extended message ID filtering. The FDCAN extended ID filter configuration register controls the filter path for standard messages as described in Figure709: Extended message ID filter path.
        struct FDCAN_XIDFC : public Register<0x4400e088> {
            using FLESA = Field<2, 14>;    // FLESA
            using LSE = Field<16, 8>;    // LSE
        };

        // FDCAN extended ID and mask register
        struct FDCAN_XIDAM : public Register<0x4400e090> {
            using EIDM = Field<0, 29>;    // EIDM
        };

        // This register is updated every time a message ID filter element configured to generate a priority event match. This can be used to monitor the status of incoming high priority messages and to enable fast access to these messages.
        struct FDCAN_HPMS : public RegisterReadOnly<0x4400e094> {
            using BIDX = Field<0, 6>;    // BIDX
            using MSI = Field<6, 2>;    // MSI
            using FIDX = Field<8, 7>;    // FIDX
            using FLST = Field<15, 1>;    // FLST
        };

        // FDCAN new data 1 register
        struct FDCAN_NDAT1 : public Register<0x4400e098> {
            using ND0 = Field<0, 1>;    // ND0
            using ND1 = Field<1, 1>;    // ND1
            using ND2 = Field<2, 1>;    // ND2
            using ND3 = Field<3, 1>;    // ND3
            using ND4 = Field<4, 1>;    // ND4
            using ND5 = Field<5, 1>;    // ND5
            using ND6 = Field<6, 1>;    // ND6
            using ND7 = Field<7, 1>;    // ND7
            using ND8 = Field<8, 1>;    // ND8
            using ND9 = Field<9, 1>;    // ND9
            using ND10 = Field<10, 1>;    // ND10
            using ND11 = Field<11, 1>;    // ND11
            using ND12 = Field<12, 1>;    // ND12
            using ND13 = Field<13, 1>;    // ND13
            using ND14 = Field<14, 1>;    // ND14
            using ND15 = Field<15, 1>;    // ND15
            using ND16 = Field<16, 1>;    // ND16
            using ND17 = Field<17, 1>;    // ND17
            using ND18 = Field<18, 1>;    // ND18
            using ND19 = Field<19, 1>;    // ND19
            using ND20 = Field<20, 1>;    // ND20
            using ND21 = Field<21, 1>;    // ND21
            using ND22 = Field<22, 1>;    // ND22
            using ND23 = Field<23, 1>;    // ND23
            using ND24 = Field<24, 1>;    // ND24
            using ND25 = Field<25, 1>;    // ND25
            using ND26 = Field<26, 1>;    // ND26
            using ND27 = Field<27, 1>;    // ND27
            using ND28 = Field<28, 1>;    // ND28
            using ND29 = Field<29, 1>;    // ND29
            using ND30 = Field<30, 1>;    // ND30
            using ND31 = Field<31, 1>;    // ND31
        };

        // FDCAN new data 2 register
        struct FDCAN_NDAT2 : public Register<0x4400e09c> {
            using ND32 = Field<0, 1>;    // ND32
            using ND33 = Field<1, 1>;    // ND33
            using ND34 = Field<2, 1>;    // ND34
            using ND35 = Field<3, 1>;    // ND35
            using ND36 = Field<4, 1>;    // ND36
            using ND37 = Field<5, 1>;    // ND37
            using ND38 = Field<6, 1>;    // ND38
            using ND39 = Field<7, 1>;    // ND39
            using ND40 = Field<8, 1>;    // ND40
            using ND41 = Field<9, 1>;    // ND41
            using ND42 = Field<10, 1>;    // ND42
            using ND43 = Field<11, 1>;    // ND43
            using ND44 = Field<12, 1>;    // ND44
            using ND45 = Field<13, 1>;    // ND45
            using ND46 = Field<14, 1>;    // ND46
            using ND47 = Field<15, 1>;    // ND47
            using ND48 = Field<16, 1>;    // ND48
            using ND49 = Field<17, 1>;    // ND49
            using ND50 = Field<18, 1>;    // ND50
            using ND51 = Field<19, 1>;    // ND51
            using ND52 = Field<20, 1>;    // ND52
            using ND53 = Field<21, 1>;    // ND53
            using ND54 = Field<22, 1>;    // ND54
            using ND55 = Field<23, 1>;    // ND55
            using ND56 = Field<24, 1>;    // ND56
            using ND57 = Field<25, 1>;    // ND57
            using ND58 = Field<26, 1>;    // ND58
            using ND59 = Field<27, 1>;    // ND59
            using ND60 = Field<28, 1>;    // ND60
            using ND61 = Field<29, 1>;    // ND61
            using ND62 = Field<30, 1>;    // ND62
            using ND63 = Field<31, 1>;    // ND63
        };

        // FDCAN Rx FIFO 0 configuration register
        struct FDCAN_RXF0C : public Register<0x4400e0a0> {
            using F0SA = Field<2, 14>;    // F0SA
            using F0S = Field<16, 7>;    // F0S
            using F0WM = Field<24, 7>;    // F0WM
            using F0OM = Field<31, 1>;    // F0OM
        };

        // FDCAN Rx FIFO 0 status register
        struct FDCAN_RXF0S : public Register<0x4400e0a4> {
            using F0FL = Field<0, 7>;    // F0FL
            using F0GI = Field<8, 6>;    // F0GI
            using F0PI = Field<16, 6>;    // F0PI
            using F0F = Field<24, 1>;    // F0F
            using RF0L = Field<25, 1>;    // RF0L
        };

        // FDCAN Rx FIFO 0 acknowledge register
        struct FDCAN_RXF0A : public Register<0x4400e0a8> {
            using F0AI = Field<0, 6>;    // F0AI
        };

        // FDCAN Rx buffer configuration register
        struct FDCAN_RXBC : public Register<0x4400e0ac> {
            using RBSA = Field<2, 14>;    // RBSA
        };

        // FDCAN Rx FIFO 1 configuration register
        struct FDCAN_RXF1C : public Register<0x4400e0b0> {
            using F1SA = Field<2, 14>;    // F1SA
            using F1S = Field<16, 7>;    // F1S
            using F1WM = Field<24, 7>;    // F1WM
            using F1OM = Field<31, 1>;    // F1OM
        };

        // FDCAN Rx FIFO 1 status register
        struct FDCAN_RXF1S : public RegisterReadOnly<0x4400e0b4> {
            using F1FL = Field<0, 7>;    // F1FL
            using F1GI = Field<8, 6>;    // F1GI
            using F1PI = Field<16, 6>;    // F1PI
            using F1F = Field<24, 1>;    // F1F
            using RF1L = Field<25, 1>;    // RF1L
            using DMS = Field<30, 2>;    // DMS
        };

        // FDCAN Rx FIFO 1 acknowledge register
        struct FDCAN_RXF1A : public Register<0x4400e0b8> {
            using F1AI = Field<0, 6>;    // F1AI
        };

        // Configures the number of data bytes belonging to an Rx buffer / Rx FIFO element. Data field sizes higher than 8 bytes are intended for CAN FD operation only.
        struct FDCAN_RXESC : public RegisterReadOnly<0x4400e0bc> {
            using F0DS = Field<0, 3>;    // F0DS
            using F1DS = Field<4, 3>;    // F1DS
            using RBDS = Field<8, 3>;    // RBDS
        };

        // FDCAN Tx buffer configuration register
        struct FDCAN_TXBC : public Register<0x4400e0c0> {
            using TBSA = Field<2, 14>;    // TBSA
            using NDTB = Field<16, 6>;    // NDTB
            using TFQS = Field<24, 6>;    // TFQS
            using TFQM = Field<30, 1>;    // TFQM
        };

        // The Tx FIFO/queue status is related to the pending Tx requests listed in register FDCAN_TXBRP. Therefore the effect of add/cancellation requests may be delayed due to a running Tx scan (FDCAN_TXBRP not yet updated).
        struct FDCAN_TXFQS : public RegisterReadOnly<0x4400e0c4> {
            using TFFL = Field<0, 6>;    // TFFL
            using TFGI = Field<8, 5>;    // TFGI
            using TFQPI = Field<16, 5>;    // TFQPI
            using TFQF = Field<21, 1>;    // TFQF
        };

        // Configures the number of data bytes belonging to a Tx buffer element. Data field sizes &gt;8 bytes are intended for CAN FD operation only.
        struct FDCAN_TXESC : public RegisterReadOnly<0x4400e0c8> {
            using TBDS = Field<0, 3>;    // TBDS
        };

        // FDCAN Tx buffer add request register
        struct FDCAN_TXBAR : public Register<0x4400e0d0> {
            using AR = Field<0, 32>;    // AR
        };

        // FDCAN Tx buffer cancellation request register
        struct FDCAN_TXBCR : public Register<0x4400e0d4> {
            using CR = Field<0, 32>;    // CR
        };

        // FDCAN Tx buffer transmission occurred register
        struct FDCAN_TXBTO : public RegisterReadOnly<0x4400e0d8> {
            using TO = Field<0, 32>;    // TO
        };

        // FDCAN Tx buffer cancellation finished register
        struct FDCAN_TXBCF : public RegisterReadOnly<0x4400e0dc> {
            using CF = Field<0, 32>;    // CF
        };

        // FDCAN Tx buffer transmission interrupt enable register
        struct FDCAN_TXBTIE : public Register<0x4400e0e0> {
            using TIE = Field<0, 32>;    // TIE
        };

        // FDCAN Tx buffer cancellation finished interrupt enable register
        struct FDCAN_TXBCIE : public Register<0x4400e0e4> {
            using CFIE = Field<0, 32>;    // CFIE
        };

        // FDCAN Tx event FIFO configuration register
        struct FDCAN_TXEFC : public Register<0x4400e0f0> {
            using EFSA = Field<2, 14>;    // EFSA
            using EFS = Field<16, 6>;    // EFS
            using EFWM = Field<24, 6>;    // EFWM
        };

        // FDCAN Tx event FIFO status register
        struct FDCAN_TXEFS : public RegisterReadOnly<0x4400e0f4> {
            using EFFL = Field<0, 6>;    // EFFL
            using EFGI = Field<8, 5>;    // EFGI
            using EFPI = Field<16, 5>;    // EFPI
            using EFF = Field<24, 1>;    // EFF
            using TEFL = Field<25, 1>;    // TEFL
        };

        // FDCAN Tx event FIFO acknowledge register
        struct FDCAN_TXEFA : public Register<0x4400e0f8> {
            using EFAI = Field<0, 5>;    // EFAI
        };

        // FDCAN TT trigger memory configuration register
        struct FDCAN_TTTMC : public Register<0x4400e100> {
            using TMSA = Field<2, 14>;    // TMSA
            using TME = Field<16, 7>;    // TME
        };

        // FDCAN TT reference message configuration register
        struct FDCAN_TTRMC : public Register<0x4400e104> {
            using RID = Field<0, 29>;    // RID
            using XTD = Field<30, 1>;    // XTD
            using RMPS = Field<31, 1>;    // RMPS
        };

        // FDCAN TT operation configuration register
        struct FDCAN_TTOCF : public Register<0x4400e108> {
            using OM = Field<0, 2>;    // OM
            using GEN = Field<3, 1>;    // GEN
            using TM = Field<4, 1>;    // TM
            using LDSDL = Field<5, 3>;    // LDSDL
            using IRTO = Field<8, 7>;    // IRTO
            using EECS = Field<15, 1>;    // EECS
            using AWL = Field<16, 8>;    // AWL
            using EGTF = Field<24, 1>;    // EGTF
            using ECC = Field<25, 1>;    // ECC
            using EVTP = Field<26, 1>;    // EVTP
        };

        // FDCAN TT matrix limits register
        struct FDCAN_TTMLM : public Register<0x4400e10c> {
            using CCM = Field<0, 6>;    // CCM
            using CSS = Field<6, 2>;    // CSS
            using TXEW = Field<8, 4>;    // TXEW
            using ENTT = Field<16, 12>;    // ENTT
        };

        // The length of the NTU is given by: NTU = CAN clock period x NC/DC. NC is an 18-bit value. Its high part, NCH[17:16] is hard wired to 0b01. Therefore the range of NC extends from 0x10000 to 0x1FFFF. The value configured by NCL is the initial value for FDCAN_TURNA.NAV[15:0]. DC is set to 0x1000 by hardware reset and it may not be written to 0x0000. Level 1: NC 4 * DC and NTU = CAN bit time Levels 0 and 2: NC 8 * DC The actual value of FDCAN_TUR may be changed by the clock drift compensation function of TTCAN level 0 and level 2 in order to adjust the node local view of the NTU to the time master view of the NTU. DC will not be changed by the automatic drift compensation, FDCAN_TURNA.NAV may be adjusted around NC in the range of the synchronization deviation limit given by FDCAN_TTOCF.LDSDL. NC and DC should be programmed to the largest suitable values in achieve the best computational accuracy for the drift compensation process.
        struct FDCAN_TURCF : public Register<0x4400e110> {
            using NCL = Field<0, 16>;    // NCL
            using DC = Field<16, 14>;    // DC
            using ELT = Field<31, 1>;    // ELT
        };

        // FDCAN TT operation control register
        struct FDCAN_TTOCN : public Register<0x4400e114> {
            using SGT = Field<0, 1>;    // SGT
            using ECS = Field<1, 1>;    // ECS
            using SWP = Field<2, 1>;    // SWP
            using SWS = Field<3, 2>;    // SWS
            using RTIE = Field<5, 1>;    // RTIE
            using TMC = Field<6, 2>;    // TMC
            using TTIE = Field<8, 1>;    // TTIE
            using GCS = Field<9, 1>;    // GCS
            using FGP = Field<10, 1>;    // FGP
            using TMG = Field<11, 1>;    // TMG
            using NIG = Field<12, 1>;    // NIG
            using ESCN = Field<13, 1>;    // ESCN
            using LCKC = Field<15, 1>;    // LCKC
        };

        // If TTOST.WGDT is set, the next reference message will be transmitted with the Master_Ref_Mark modified by the preset value and with Disc_Bit = 1, presetting the global time in all nodes simultaneously. TP is reset to 0x0000 each time a reference message with Disc_Bit = 1 becomes valid or if the node is not the current time master. TP is locked while FDCAN_TTOST.WGTD = 1 after setting FDCAN_TTOCN.SGT until the reference message with Disc_Bit = 1 becomes valid or until the node is no longer the current time master.
        struct FDCAN_TTGTP : public Register<0x4400e118> {
            using TP = Field<0, 16>;    // TP
            using CTP = Field<16, 16>;    // CTP
        };

        // A time mark interrupt (FDCAN_TTIR.TMI = 1) is generated when the time base indicated by FDCAN_TTOCN.TMC (cycle time, local time, or global time) has the same value as TM.
        struct FDCAN_TTTMK : public Register<0x4400e11c> {
            using TM = Field<0, 16>;    // TM
            using TICC = Field<16, 7>;    // TICC
            using LCKM = Field<31, 1>;    // LCKM
        };

        // The flags are set when one of the listed conditions is detected (edge-sensitive). The flags remain set until the Host clears them. A flag is cleared by writing a 1 to the corresponding bit position. Writing a 0 has no effect. A hard reset will clear the register.
        struct FDCAN_TTIR : public Register<0x4400e120> {
            using SBC = Field<0, 1>;    // SBC
            using SMC = Field<1, 1>;    // SMC
            using CSM = Field<2, 1>;    // CSM
            using SOG = Field<3, 1>;    // SOG
            using RTMI = Field<4, 1>;    // RTMI
            using TTMI = Field<5, 1>;    // TTMI
            using SWE = Field<6, 1>;    // SWE
            using GTW = Field<7, 1>;    // GTW
            using GTD = Field<8, 1>;    // GTD
            using GTE = Field<9, 1>;    // GTE
            using TXU = Field<10, 1>;    // TXU
            using TXO = Field<11, 1>;    // TXO
            using SE1 = Field<12, 1>;    // SE1
            using SE2 = Field<13, 1>;    // SE2
            using ELC = Field<14, 1>;    // ELC
            using IWTG = Field<15, 1>;    // IWTG
            using WT = Field<16, 1>;    // WT
            using AW = Field<17, 1>;    // AW
            using CER = Field<18, 1>;    // CER
        };

        // The settings in the TT interrupt enable register determine which status changes in the TT interrupt register will result in an interrupt.
        struct FDCAN_TTIE : public Register<0x4400e124> {
            using SBCE = Field<0, 1>;    // SBCE
            using SMCE = Field<1, 1>;    // SMCE
            using CSME = Field<2, 1>;    // CSME
            using SOGE = Field<3, 1>;    // SOGE
            using RTMIE = Field<4, 1>;    // RTMIE
            using TTMIE = Field<5, 1>;    // TTMIE
            using SWEE = Field<6, 1>;    // SWEE
            using GTWE = Field<7, 1>;    // GTWE
            using GTDE = Field<8, 1>;    // GTDE
            using GTEE = Field<9, 1>;    // GTEE
            using TXUE = Field<10, 1>;    // TXUE
            using TXOE = Field<11, 1>;    // TXOE
            using SE1E = Field<12, 1>;    // SE1E
            using SE2E = Field<13, 1>;    // SE2E
            using ELCE = Field<14, 1>;    // ELCE
            using IWTE = Field<15, 1>;    // IWTE
            using WTE = Field<16, 1>;    // WTE
            using AWE = Field<17, 1>;    // AWE
            using CERE = Field<18, 1>;    // CERE
        };

        // The TT interrupt Line select register assigns an interrupt generated by a specific interrupt flag from the TT interrupt register to one of the two module interrupt lines. For interrupt generation the respective interrupt line has to be enabled via FDCAN_ILE.EINT0 and FDCAN_ILE.EINT1.
        struct FDCAN_TTILS : public Register<0x4400e128> {
            using SBCL = Field<0, 1>;    // SBCL
            using SMCL = Field<1, 1>;    // SMCL
            using CSML = Field<2, 1>;    // CSML
            using SOGL = Field<3, 1>;    // SOGL
            using RTMIL = Field<4, 1>;    // RTMIL
            using TTMIL = Field<5, 1>;    // TTMIL
            using SWEL = Field<6, 1>;    // SWEL
            using GTWL = Field<7, 1>;    // GTWL
            using GTDL = Field<8, 1>;    // GTDL
            using GTEL = Field<9, 1>;    // GTEL
            using TXUL = Field<10, 1>;    // TXUL
            using TXOL = Field<11, 1>;    // TXOL
            using SE1L = Field<12, 1>;    // SE1L
            using SE2L = Field<13, 1>;    // SE2L
            using ELCL = Field<14, 1>;    // ELCL
            using IWTL = Field<15, 1>;    // IWTL
            using WTL = Field<16, 1>;    // WTL
            using AWL = Field<17, 1>;    // AWL
            using CERL = Field<18, 1>;    // CERL
        };

        // FDCAN TT operation status register
        struct FDCAN_TTOST : public RegisterReadOnly<0x4400e12c> {
            using EL = Field<0, 2>;    // EL
            using MS = Field<2, 2>;    // MS
            using SYS = Field<4, 2>;    // SYS
            using QGTP = Field<6, 1>;    // QGTP
            using QCS = Field<7, 1>;    // QCS
            using RTO = Field<8, 8>;    // RTO
            using WGTD = Field<22, 1>;    // WGTD
            using GFI = Field<23, 1>;    // GFI
            using TMP = Field<24, 3>;    // TMP
            using GSI = Field<27, 1>;    // GSI
            using WFE = Field<28, 1>;    // WFE
            using AWE = Field<29, 1>;    // AWE
            using WECS = Field<30, 1>;    // WECS
            using SPL = Field<31, 1>;    // SPL
        };

        // There is no drift compensation in TTCAN level 1.
        struct FDCAN_TURNA : public RegisterReadOnly<0x4400e130> {
            using NAV = Field<0, 18>;    // NAV
        };

        // FDCAN TT local and global time register
        struct FDCAN_TTLGT : public RegisterReadOnly<0x4400e134> {
            using LT = Field<0, 16>;    // LT
            using GT = Field<16, 16>;    // GT
        };

        // FDCAN TT cycle time and count register
        struct FDCAN_TTCTC : public RegisterReadOnly<0x4400e138> {
            using CT = Field<0, 16>;    // CT
            using CC = Field<16, 6>;    // CC
        };

        // FDCAN TT capture time register
        struct FDCAN_TTCPT : public RegisterReadOnly<0x4400e13c> {
            using CCV = Field<0, 6>;    // CCV
            using SWV = Field<16, 16>;    // SWV
        };

        // FDCAN TT cycle sync mark register
        struct FDCAN_TTCSM : public RegisterReadOnly<0x4400e140> {
            using CSM = Field<0, 16>;    // CSM
        };

        // The settings in the FDCAN_TTTS register select the input to be used as event trigger and stop watch trigger.
        struct FDCAN_TTTS : public Register<0x4400e300> {
            using SWTDEL = Field<0, 2>;    // SWTDEL
            using EVTSEL = Field<4, 2>;    // EVTSEL
        };

    };

    // FDCAN1
    struct FDCAN2 {
        // FDCAN core release register
        struct FDCAN_CREL : public RegisterReadOnly<0x4400f000> {
            using DAY = Field<0, 8>;    // DAY
            using MON = Field<8, 8>;    // MON
            using YEAR = Field<16, 4>;    // YEAR
            using SUBSTEP = Field<20, 4>;    // SUBSTEP
            using STEP = Field<24, 4>;    // STEP
            using REL = Field<28, 4>;    // REL
        };

        // FDCAN Endian register
        struct FDCAN_ENDN : public RegisterReadOnly<0x4400f004> {
            using ETV = Field<0, 32>;    // ETV
        };

        // This register is dedicated to data bit timing phase and only writable if bits FDCAN_CCCR.CCE and FDCAN_CCCR.INIT are set. The CAN time quantum may be programmed in the range from 1 to 32 FDCAN clock periods. tq = (DBRP + 1) FDCAN clock periods. DTSEG1 is the sum of Prop_Seg and Phase_Seg1. DTSEG2 is Phase_Seg2. Therefore the length of the bit time is (DTSEG1 + DTSEG2 + 3) tq for programmed values, or (Sync_Seg+Prop_Seg+Phase_Seg1+Phase_Seg2) tq for functional values. The information processing time (IPT) is zero, meaning the data for the next bit is available at the first clock edge after the sample point.
        struct FDCAN_DBTP : public Register<0x4400f00c> {
            using DSJW = Field<0, 4>;    // DSJW
            using DTSEG2 = Field<4, 4>;    // DTSEG2
            using DTSEG1 = Field<8, 5>;    // DTSEG1
            using DBRP = Field<16, 5>;    // DBRP
            using TDC = Field<23, 1>;    // TDC
        };

        // Write access to this register has to be enabled by setting bit FDCAN_CCCR.TEST to 1. All register functions are set to their reset values when bit FDCAN_CCCR.TEST is reset. Loop back mode and software control of Tx pin FDCANx_TX are hardware test modes. Programming TX differently from 00 may disturb the message transfer on the CAN bus.
        struct FDCAN_TEST : public Register<0x4400f010> {
            using LBCK = Field<4, 1>;    // LBCK
            using TX = Field<5, 2>;    // TX
            using RX = Field<7, 1>;    // RX
        };

        // The RAM watchdog monitors the READY output of the message RAM. A message RAM access starts the message RAM watchdog counter with the value configured by the FDCAN_RWD.WDC bits. The counter is reloaded with FDCAN_RWD.WDC bits when the message RAM signals successful completion by activating its READY output. In case there is no response from the message RAM until the counter has counted down to 0, the counter stops and interrupt flag FDCAN_IR.WDI bit is set. The RAM watchdog counter is clocked by the fdcan_pclk clock.
        struct FDCAN_RWD : public Register<0x4400f014> {
            using WDC = Field<0, 8>;    // WDC
            using WDV = Field<8, 8>;    // WDV
        };

        // For details about setting and resetting of single bits see Software initialization.
        struct FDCAN_CCCR : public Register<0x4400f018> {
            using INIT = Field<0, 1>;    // INIT
            using CCE = Field<1, 1>;    // CCE
            using ASM = Field<2, 1>;    // ASM
            using CSA = Field<3, 1>;    // CSA
            using CSR = Field<4, 1>;    // CSR
            using MON = Field<5, 1>;    // MON
            using DAR = Field<6, 1>;    // DAR
            using TEST = Field<7, 1>;    // TEST
            using FDOE = Field<8, 1>;    // FDOE
            using BRSE = Field<9, 1>;    // BRSE
            using PXHD = Field<12, 1>;    // PXHD
            using EFBI = Field<13, 1>;    // EFBI
            using TXP = Field<14, 1>;    // TXP
            using NISO = Field<15, 1>;    // NISO
        };

        // This register is dedicated to the nominal bit timing used during the arbitration phase.
        struct FDCAN_NBTP : public Register<0x4400f01c> {
            using NTSEG2 = Field<0, 7>;    // NTSEG2
            using NTSEG1 = Field<8, 8>;    // NTSEG1
            using NBRP = Field<16, 9>;    // NBRP
            using NSJW = Field<25, 7>;    // NSJW
        };

        // FDCAN timestamp counter configuration register
        struct FDCAN_TSCC : public Register<0x4400f020> {
            using TSS = Field<0, 2>;    // TSS
            using TCP = Field<16, 4>;    // TCP
        };

        // FDCAN timestamp counter value register
        struct FDCAN_TSCV : public Register<0x4400f024> {
            using TSC = Field<0, 16>;    // TSC
        };

        // FDCAN timeout counter configuration register
        struct FDCAN_TOCC : public Register<0x4400f028> {
            using ETOC = Field<0, 1>;    // ETOC
            using TOS = Field<1, 2>;    // TOS
            using TOP = Field<16, 16>;    // TOP
        };

        // FDCAN timeout counter value register
        struct FDCAN_TOCV : public Register<0x4400f02c> {
            using TOC = Field<0, 16>;    // TOC
        };

        // FDCAN error counter register
        struct FDCAN_ECR : public Register<0x4400f040> {
            using TEC = Field<0, 8>;    // TEC
            using TREC = Field<8, 7>;    // TREC
            using RP = Field<15, 1>;    // RP
            using CEL = Field<16, 8>;    // CEL
        };

        // FDCAN protocol status register
        struct FDCAN_PSR : public Register<0x4400f044> {
            using LEC = Field<0, 3>;    // LEC
            using ACT = Field<3, 2>;    // ACT
            using EP = Field<5, 1>;    // EP
            using EW = Field<6, 1>;    // EW
            using BO = Field<7, 1>;    // BO
            using DLEC = Field<8, 3>;    // DLEC
            using RESI = Field<11, 1>;    // RESI
            using RBRS = Field<12, 1>;    // RBRS
            using REDL = Field<13, 1>;    // REDL
            using PXE = Field<14, 1>;    // PXE
            using TDCV = Field<16, 7>;    // TDCV
        };

        // FDCAN transmitter delay compensation register
        struct FDCAN_TDCR : public Register<0x4400f048> {
            using TDCF = Field<0, 7>;    // TDCF
            using TDCO = Field<8, 7>;    // TDCO
        };

        // The flags are set when one of the listed conditions is detected (edge-sensitive). The flags remain set until the Host clears them. A flag is cleared by writing a 1 to the corresponding bit position. Writing a 0 has no effect. A hard reset will clear the register. The configuration of IE controls whether an interrupt is generated. The configuration of ILS controls on which interrupt line an interrupt is signaled.
        struct FDCAN_IR : public Register<0x4400f050> {
            using RF0N = Field<0, 1>;    // RF0N
            using RF0W = Field<1, 1>;    // RF0W
            using RF0F = Field<2, 1>;    // RF0F
            using RF0L = Field<3, 1>;    // RF0L
            using RF1N = Field<4, 1>;    // RF1N
            using RF1W = Field<5, 1>;    // RF1W
            using RF1F = Field<6, 1>;    // RF1F
            using RF1L = Field<7, 1>;    // RF1L
            using HPM = Field<8, 1>;    // HPM
            using TC = Field<9, 1>;    // TC
            using TCF = Field<10, 1>;    // TCF
            using TFE = Field<11, 1>;    // TFE
            using TEFN = Field<12, 1>;    // TEFN
            using TEFW = Field<13, 1>;    // TEFW
            using TEFF = Field<14, 1>;    // TEFF
            using TEFL = Field<15, 1>;    // TEFL
            using TSW = Field<16, 1>;    // TSW
            using MRAF = Field<17, 1>;    // MRAF
            using TOO = Field<18, 1>;    // TOO
            using DRX = Field<19, 1>;    // DRX
            using ELO = Field<22, 1>;    // ELO
            using EP = Field<23, 1>;    // EP
            using EW = Field<24, 1>;    // EW
            using BO = Field<25, 1>;    // BO
            using WDI = Field<26, 1>;    // WDI
            using PEA = Field<27, 1>;    // PEA
            using PED = Field<28, 1>;    // PED
            using ARA = Field<29, 1>;    // ARA
        };

        // The settings in the interrupt enable register determine which status changes in the interrupt register will be signaled on an interrupt line.
        struct FDCAN_IE : public Register<0x4400f054> {
            using RF0NE = Field<0, 1>;    // RF0NE
            using RF0WE = Field<1, 1>;    // RF0WE
            using RF0FE = Field<2, 1>;    // RF0FE
            using RF0LE = Field<3, 1>;    // RF0LE
            using RF1NE = Field<4, 1>;    // RF1NE
            using RF1WE = Field<5, 1>;    // RF1WE
            using RF1FE = Field<6, 1>;    // RF1FE
            using RF1LE = Field<7, 1>;    // RF1LE
            using HPME = Field<8, 1>;    // HPME
            using TCE = Field<9, 1>;    // TCE
            using TCFE = Field<10, 1>;    // TCFE
            using TFEE = Field<11, 1>;    // TFEE
            using TEFNE = Field<12, 1>;    // TEFNE
            using TEFWE = Field<13, 1>;    // TEFWE
            using TEFFE = Field<14, 1>;    // TEFFE
            using TEFLE = Field<15, 1>;    // TEFLE
            using TSWE = Field<16, 1>;    // TSWE
            using MRAFE = Field<17, 1>;    // MRAFE
            using TOOE = Field<18, 1>;    // TOOE
            using DRXE = Field<19, 1>;    // DRXE
            using BECE = Field<20, 1>;    // BECE
            using BEUE = Field<21, 1>;    // BEUE
            using ELOE = Field<22, 1>;    // ELOE
            using EPE = Field<23, 1>;    // EPE
            using EWE = Field<24, 1>;    // EWE
            using BOE = Field<25, 1>;    // BOE
            using WDIE = Field<26, 1>;    // WDIE
            using PEAE = Field<27, 1>;    // PEAE
            using PEDE = Field<28, 1>;    // PEDE
            using ARAE = Field<29, 1>;    // ARAE
        };

        // This register assigns an interrupt generated by a specific interrupt flag from the interrupt register to one of the two module interrupt lines. For interrupt generation the respective interrupt line has to be enabled via FDCAN_ILE.EINT0 and FDCAN_ILE.EINT1.
        struct FDCAN_ILS : public Register<0x4400f058> {
            using RF0NL = Field<0, 1>;    // RF0NL
            using RF0WL = Field<1, 1>;    // RF0WL
            using RF0FL = Field<2, 1>;    // RF0FL
            using RF0LL = Field<3, 1>;    // RF0LL
            using RF1NL = Field<4, 1>;    // RF1NL
            using RF1WL = Field<5, 1>;    // RF1WL
            using RF1FL = Field<6, 1>;    // RF1FL
            using RF1LL = Field<7, 1>;    // RF1LL
            using HPML = Field<8, 1>;    // HPML
            using TCL = Field<9, 1>;    // TCL
            using TCFL = Field<10, 1>;    // TCFL
            using TFEL = Field<11, 1>;    // TFEL
            using TEFNL = Field<12, 1>;    // TEFNL
            using TEFWL = Field<13, 1>;    // TEFWL
            using TEFFL = Field<14, 1>;    // TEFFL
            using TEFLL = Field<15, 1>;    // TEFLL
            using TSWL = Field<16, 1>;    // TSWL
            using MRAFL = Field<17, 1>;    // MRAFL
            using TOOL = Field<18, 1>;    // TOOL
            using DRXL = Field<19, 1>;    // DRXL
            using BECL = Field<20, 1>;    // BECL
            using BEUL = Field<21, 1>;    // BEUL
            using ELOL = Field<22, 1>;    // ELOL
            using EPL = Field<23, 1>;    // EPL
            using EWL = Field<24, 1>;    // EWL
            using BOL = Field<25, 1>;    // BOL
            using WDIL = Field<26, 1>;    // WDIL
            using PEAL = Field<27, 1>;    // PEAL
            using PEDL = Field<28, 1>;    // PEDL
            using ARAL = Field<29, 1>;    // ARAL
        };

        // Each of the two interrupt lines to the CPU can be enabled/disabled separately by programming bits EINT0 and EINT1.
        struct FDCAN_ILE : public Register<0x4400f05c> {
            using EINT0 = Field<0, 1>;    // EINT0
            using EINT1 = Field<1, 1>;    // EINT1
        };

        // Global settings for message ID filtering. The global filter configuration register controls the filter path for standard and extended messages as described in Figure708: Standard message ID filter path and Figure709: Extended message ID filter path.
        struct FDCAN_GFC : public Register<0x4400f080> {
            using RRFE = Field<0, 1>;    // RRFE
            using RRFS = Field<1, 1>;    // RRFS
            using ANFE = Field<2, 2>;    // ANFE
            using ANFS = Field<4, 2>;    // ANFS
        };

        // Settings for 11-bit standard message ID filtering.The standard ID filter configuration register controls the filter path for standard messages as described in Figure708.
        struct FDCAN_SIDFC : public Register<0x4400f084> {
            using FLSSA = Field<2, 14>;    // FLSSA
            using LSS = Field<16, 8>;    // LSS
        };

        // Settings for 29-bit extended message ID filtering. The FDCAN extended ID filter configuration register controls the filter path for standard messages as described in Figure709: Extended message ID filter path.
        struct FDCAN_XIDFC : public Register<0x4400f088> {
            using FLESA = Field<2, 14>;    // FLESA
            using LSE = Field<16, 8>;    // LSE
        };

        // FDCAN extended ID and mask register
        struct FDCAN_XIDAM : public Register<0x4400f090> {
            using EIDM = Field<0, 29>;    // EIDM
        };

        // This register is updated every time a message ID filter element configured to generate a priority event match. This can be used to monitor the status of incoming high priority messages and to enable fast access to these messages.
        struct FDCAN_HPMS : public RegisterReadOnly<0x4400f094> {
            using BIDX = Field<0, 6>;    // BIDX
            using MSI = Field<6, 2>;    // MSI
            using FIDX = Field<8, 7>;    // FIDX
            using FLST = Field<15, 1>;    // FLST
        };

        // FDCAN new data 1 register
        struct FDCAN_NDAT1 : public Register<0x4400f098> {
            using ND0 = Field<0, 1>;    // ND0
            using ND1 = Field<1, 1>;    // ND1
            using ND2 = Field<2, 1>;    // ND2
            using ND3 = Field<3, 1>;    // ND3
            using ND4 = Field<4, 1>;    // ND4
            using ND5 = Field<5, 1>;    // ND5
            using ND6 = Field<6, 1>;    // ND6
            using ND7 = Field<7, 1>;    // ND7
            using ND8 = Field<8, 1>;    // ND8
            using ND9 = Field<9, 1>;    // ND9
            using ND10 = Field<10, 1>;    // ND10
            using ND11 = Field<11, 1>;    // ND11
            using ND12 = Field<12, 1>;    // ND12
            using ND13 = Field<13, 1>;    // ND13
            using ND14 = Field<14, 1>;    // ND14
            using ND15 = Field<15, 1>;    // ND15
            using ND16 = Field<16, 1>;    // ND16
            using ND17 = Field<17, 1>;    // ND17
            using ND18 = Field<18, 1>;    // ND18
            using ND19 = Field<19, 1>;    // ND19
            using ND20 = Field<20, 1>;    // ND20
            using ND21 = Field<21, 1>;    // ND21
            using ND22 = Field<22, 1>;    // ND22
            using ND23 = Field<23, 1>;    // ND23
            using ND24 = Field<24, 1>;    // ND24
            using ND25 = Field<25, 1>;    // ND25
            using ND26 = Field<26, 1>;    // ND26
            using ND27 = Field<27, 1>;    // ND27
            using ND28 = Field<28, 1>;    // ND28
            using ND29 = Field<29, 1>;    // ND29
            using ND30 = Field<30, 1>;    // ND30
            using ND31 = Field<31, 1>;    // ND31
        };

        // FDCAN new data 2 register
        struct FDCAN_NDAT2 : public Register<0x4400f09c> {
            using ND32 = Field<0, 1>;    // ND32
            using ND33 = Field<1, 1>;    // ND33
            using ND34 = Field<2, 1>;    // ND34
            using ND35 = Field<3, 1>;    // ND35
            using ND36 = Field<4, 1>;    // ND36
            using ND37 = Field<5, 1>;    // ND37
            using ND38 = Field<6, 1>;    // ND38
            using ND39 = Field<7, 1>;    // ND39
            using ND40 = Field<8, 1>;    // ND40
            using ND41 = Field<9, 1>;    // ND41
            using ND42 = Field<10, 1>;    // ND42
            using ND43 = Field<11, 1>;    // ND43
            using ND44 = Field<12, 1>;    // ND44
            using ND45 = Field<13, 1>;    // ND45
            using ND46 = Field<14, 1>;    // ND46
            using ND47 = Field<15, 1>;    // ND47
            using ND48 = Field<16, 1>;    // ND48
            using ND49 = Field<17, 1>;    // ND49
            using ND50 = Field<18, 1>;    // ND50
            using ND51 = Field<19, 1>;    // ND51
            using ND52 = Field<20, 1>;    // ND52
            using ND53 = Field<21, 1>;    // ND53
            using ND54 = Field<22, 1>;    // ND54
            using ND55 = Field<23, 1>;    // ND55
            using ND56 = Field<24, 1>;    // ND56
            using ND57 = Field<25, 1>;    // ND57
            using ND58 = Field<26, 1>;    // ND58
            using ND59 = Field<27, 1>;    // ND59
            using ND60 = Field<28, 1>;    // ND60
            using ND61 = Field<29, 1>;    // ND61
            using ND62 = Field<30, 1>;    // ND62
            using ND63 = Field<31, 1>;    // ND63
        };

        // FDCAN Rx FIFO 0 configuration register
        struct FDCAN_RXF0C : public Register<0x4400f0a0> {
            using F0SA = Field<2, 14>;    // F0SA
            using F0S = Field<16, 7>;    // F0S
            using F0WM = Field<24, 7>;    // F0WM
            using F0OM = Field<31, 1>;    // F0OM
        };

        // FDCAN Rx FIFO 0 status register
        struct FDCAN_RXF0S : public Register<0x4400f0a4> {
            using F0FL = Field<0, 7>;    // F0FL
            using F0GI = Field<8, 6>;    // F0GI
            using F0PI = Field<16, 6>;    // F0PI
            using F0F = Field<24, 1>;    // F0F
            using RF0L = Field<25, 1>;    // RF0L
        };

        // FDCAN Rx FIFO 0 acknowledge register
        struct FDCAN_RXF0A : public Register<0x4400f0a8> {
            using F0AI = Field<0, 6>;    // F0AI
        };

        // FDCAN Rx buffer configuration register
        struct FDCAN_RXBC : public Register<0x4400f0ac> {
            using RBSA = Field<2, 14>;    // RBSA
        };

        // FDCAN Rx FIFO 1 configuration register
        struct FDCAN_RXF1C : public Register<0x4400f0b0> {
            using F1SA = Field<2, 14>;    // F1SA
            using F1S = Field<16, 7>;    // F1S
            using F1WM = Field<24, 7>;    // F1WM
            using F1OM = Field<31, 1>;    // F1OM
        };

        // FDCAN Rx FIFO 1 status register
        struct FDCAN_RXF1S : public RegisterReadOnly<0x4400f0b4> {
            using F1FL = Field<0, 7>;    // F1FL
            using F1GI = Field<8, 6>;    // F1GI
            using F1PI = Field<16, 6>;    // F1PI
            using F1F = Field<24, 1>;    // F1F
            using RF1L = Field<25, 1>;    // RF1L
            using DMS = Field<30, 2>;    // DMS
        };

        // FDCAN Rx FIFO 1 acknowledge register
        struct FDCAN_RXF1A : public Register<0x4400f0b8> {
            using F1AI = Field<0, 6>;    // F1AI
        };

        // Configures the number of data bytes belonging to an Rx buffer / Rx FIFO element. Data field sizes higher than 8 bytes are intended for CAN FD operation only.
        struct FDCAN_RXESC : public RegisterReadOnly<0x4400f0bc> {
            using F0DS = Field<0, 3>;    // F0DS
            using F1DS = Field<4, 3>;    // F1DS
            using RBDS = Field<8, 3>;    // RBDS
        };

        // FDCAN Tx buffer configuration register
        struct FDCAN_TXBC : public Register<0x4400f0c0> {
            using TBSA = Field<2, 14>;    // TBSA
            using NDTB = Field<16, 6>;    // NDTB
            using TFQS = Field<24, 6>;    // TFQS
            using TFQM = Field<30, 1>;    // TFQM
        };

        // The Tx FIFO/queue status is related to the pending Tx requests listed in register FDCAN_TXBRP. Therefore the effect of add/cancellation requests may be delayed due to a running Tx scan (FDCAN_TXBRP not yet updated).
        struct FDCAN_TXFQS : public RegisterReadOnly<0x4400f0c4> {
            using TFFL = Field<0, 6>;    // TFFL
            using TFGI = Field<8, 5>;    // TFGI
            using TFQPI = Field<16, 5>;    // TFQPI
            using TFQF = Field<21, 1>;    // TFQF
        };

        // Configures the number of data bytes belonging to a Tx buffer element. Data field sizes &gt;8 bytes are intended for CAN FD operation only.
        struct FDCAN_TXESC : public RegisterReadOnly<0x4400f0c8> {
            using TBDS = Field<0, 3>;    // TBDS
        };

        // FDCAN Tx buffer add request register
        struct FDCAN_TXBAR : public Register<0x4400f0d0> {
            using AR = Field<0, 32>;    // AR
        };

        // FDCAN Tx buffer cancellation request register
        struct FDCAN_TXBCR : public Register<0x4400f0d4> {
            using CR = Field<0, 32>;    // CR
        };

        // FDCAN Tx buffer transmission occurred register
        struct FDCAN_TXBTO : public RegisterReadOnly<0x4400f0d8> {
            using TO = Field<0, 32>;    // TO
        };

        // FDCAN Tx buffer cancellation finished register
        struct FDCAN_TXBCF : public RegisterReadOnly<0x4400f0dc> {
            using CF = Field<0, 32>;    // CF
        };

        // FDCAN Tx buffer transmission interrupt enable register
        struct FDCAN_TXBTIE : public Register<0x4400f0e0> {
            using TIE = Field<0, 32>;    // TIE
        };

        // FDCAN Tx buffer cancellation finished interrupt enable register
        struct FDCAN_TXBCIE : public Register<0x4400f0e4> {
            using CFIE = Field<0, 32>;    // CFIE
        };

        // FDCAN Tx event FIFO configuration register
        struct FDCAN_TXEFC : public Register<0x4400f0f0> {
            using EFSA = Field<2, 14>;    // EFSA
            using EFS = Field<16, 6>;    // EFS
            using EFWM = Field<24, 6>;    // EFWM
        };

        // FDCAN Tx event FIFO status register
        struct FDCAN_TXEFS : public RegisterReadOnly<0x4400f0f4> {
            using EFFL = Field<0, 6>;    // EFFL
            using EFGI = Field<8, 5>;    // EFGI
            using EFPI = Field<16, 5>;    // EFPI
            using EFF = Field<24, 1>;    // EFF
            using TEFL = Field<25, 1>;    // TEFL
        };

        // FDCAN Tx event FIFO acknowledge register
        struct FDCAN_TXEFA : public Register<0x4400f0f8> {
            using EFAI = Field<0, 5>;    // EFAI
        };

        // FDCAN TT trigger memory configuration register
        struct FDCAN_TTTMC : public Register<0x4400f100> {
            using TMSA = Field<2, 14>;    // TMSA
            using TME = Field<16, 7>;    // TME
        };

        // FDCAN TT reference message configuration register
        struct FDCAN_TTRMC : public Register<0x4400f104> {
            using RID = Field<0, 29>;    // RID
            using XTD = Field<30, 1>;    // XTD
            using RMPS = Field<31, 1>;    // RMPS
        };

        // FDCAN TT operation configuration register
        struct FDCAN_TTOCF : public Register<0x4400f108> {
            using OM = Field<0, 2>;    // OM
            using GEN = Field<3, 1>;    // GEN
            using TM = Field<4, 1>;    // TM
            using LDSDL = Field<5, 3>;    // LDSDL
            using IRTO = Field<8, 7>;    // IRTO
            using EECS = Field<15, 1>;    // EECS
            using AWL = Field<16, 8>;    // AWL
            using EGTF = Field<24, 1>;    // EGTF
            using ECC = Field<25, 1>;    // ECC
            using EVTP = Field<26, 1>;    // EVTP
        };

        // FDCAN TT matrix limits register
        struct FDCAN_TTMLM : public Register<0x4400f10c> {
            using CCM = Field<0, 6>;    // CCM
            using CSS = Field<6, 2>;    // CSS
            using TXEW = Field<8, 4>;    // TXEW
            using ENTT = Field<16, 12>;    // ENTT
        };

        // The length of the NTU is given by: NTU = CAN clock period x NC/DC. NC is an 18-bit value. Its high part, NCH[17:16] is hard wired to 0b01. Therefore the range of NC extends from 0x10000 to 0x1FFFF. The value configured by NCL is the initial value for FDCAN_TURNA.NAV[15:0]. DC is set to 0x1000 by hardware reset and it may not be written to 0x0000. Level 1: NC 4 * DC and NTU = CAN bit time Levels 0 and 2: NC 8 * DC The actual value of FDCAN_TUR may be changed by the clock drift compensation function of TTCAN level 0 and level 2 in order to adjust the node local view of the NTU to the time master view of the NTU. DC will not be changed by the automatic drift compensation, FDCAN_TURNA.NAV may be adjusted around NC in the range of the synchronization deviation limit given by FDCAN_TTOCF.LDSDL. NC and DC should be programmed to the largest suitable values in achieve the best computational accuracy for the drift compensation process.
        struct FDCAN_TURCF : public Register<0x4400f110> {
            using NCL = Field<0, 16>;    // NCL
            using DC = Field<16, 14>;    // DC
            using ELT = Field<31, 1>;    // ELT
        };

        // FDCAN TT operation control register
        struct FDCAN_TTOCN : public Register<0x4400f114> {
            using SGT = Field<0, 1>;    // SGT
            using ECS = Field<1, 1>;    // ECS
            using SWP = Field<2, 1>;    // SWP
            using SWS = Field<3, 2>;    // SWS
            using RTIE = Field<5, 1>;    // RTIE
            using TMC = Field<6, 2>;    // TMC
            using TTIE = Field<8, 1>;    // TTIE
            using GCS = Field<9, 1>;    // GCS
            using FGP = Field<10, 1>;    // FGP
            using TMG = Field<11, 1>;    // TMG
            using NIG = Field<12, 1>;    // NIG
            using ESCN = Field<13, 1>;    // ESCN
            using LCKC = Field<15, 1>;    // LCKC
        };

        // If TTOST.WGDT is set, the next reference message will be transmitted with the Master_Ref_Mark modified by the preset value and with Disc_Bit = 1, presetting the global time in all nodes simultaneously. TP is reset to 0x0000 each time a reference message with Disc_Bit = 1 becomes valid or if the node is not the current time master. TP is locked while FDCAN_TTOST.WGTD = 1 after setting FDCAN_TTOCN.SGT until the reference message with Disc_Bit = 1 becomes valid or until the node is no longer the current time master.
        struct FDCAN_TTGTP : public Register<0x4400f118> {
            using TP = Field<0, 16>;    // TP
            using CTP = Field<16, 16>;    // CTP
        };

        // A time mark interrupt (FDCAN_TTIR.TMI = 1) is generated when the time base indicated by FDCAN_TTOCN.TMC (cycle time, local time, or global time) has the same value as TM.
        struct FDCAN_TTTMK : public Register<0x4400f11c> {
            using TM = Field<0, 16>;    // TM
            using TICC = Field<16, 7>;    // TICC
            using LCKM = Field<31, 1>;    // LCKM
        };

        // The flags are set when one of the listed conditions is detected (edge-sensitive). The flags remain set until the Host clears them. A flag is cleared by writing a 1 to the corresponding bit position. Writing a 0 has no effect. A hard reset will clear the register.
        struct FDCAN_TTIR : public Register<0x4400f120> {
            using SBC = Field<0, 1>;    // SBC
            using SMC = Field<1, 1>;    // SMC
            using CSM = Field<2, 1>;    // CSM
            using SOG = Field<3, 1>;    // SOG
            using RTMI = Field<4, 1>;    // RTMI
            using TTMI = Field<5, 1>;    // TTMI
            using SWE = Field<6, 1>;    // SWE
            using GTW = Field<7, 1>;    // GTW
            using GTD = Field<8, 1>;    // GTD
            using GTE = Field<9, 1>;    // GTE
            using TXU = Field<10, 1>;    // TXU
            using TXO = Field<11, 1>;    // TXO
            using SE1 = Field<12, 1>;    // SE1
            using SE2 = Field<13, 1>;    // SE2
            using ELC = Field<14, 1>;    // ELC
            using IWTG = Field<15, 1>;    // IWTG
            using WT = Field<16, 1>;    // WT
            using AW = Field<17, 1>;    // AW
            using CER = Field<18, 1>;    // CER
        };

        // The settings in the TT interrupt enable register determine which status changes in the TT interrupt register will result in an interrupt.
        struct FDCAN_TTIE : public Register<0x4400f124> {
            using SBCE = Field<0, 1>;    // SBCE
            using SMCE = Field<1, 1>;    // SMCE
            using CSME = Field<2, 1>;    // CSME
            using SOGE = Field<3, 1>;    // SOGE
            using RTMIE = Field<4, 1>;    // RTMIE
            using TTMIE = Field<5, 1>;    // TTMIE
            using SWEE = Field<6, 1>;    // SWEE
            using GTWE = Field<7, 1>;    // GTWE
            using GTDE = Field<8, 1>;    // GTDE
            using GTEE = Field<9, 1>;    // GTEE
            using TXUE = Field<10, 1>;    // TXUE
            using TXOE = Field<11, 1>;    // TXOE
            using SE1E = Field<12, 1>;    // SE1E
            using SE2E = Field<13, 1>;    // SE2E
            using ELCE = Field<14, 1>;    // ELCE
            using IWTE = Field<15, 1>;    // IWTE
            using WTE = Field<16, 1>;    // WTE
            using AWE = Field<17, 1>;    // AWE
            using CERE = Field<18, 1>;    // CERE
        };

        // The TT interrupt Line select register assigns an interrupt generated by a specific interrupt flag from the TT interrupt register to one of the two module interrupt lines. For interrupt generation the respective interrupt line has to be enabled via FDCAN_ILE.EINT0 and FDCAN_ILE.EINT1.
        struct FDCAN_TTILS : public Register<0x4400f128> {
            using SBCL = Field<0, 1>;    // SBCL
            using SMCL = Field<1, 1>;    // SMCL
            using CSML = Field<2, 1>;    // CSML
            using SOGL = Field<3, 1>;    // SOGL
            using RTMIL = Field<4, 1>;    // RTMIL
            using TTMIL = Field<5, 1>;    // TTMIL
            using SWEL = Field<6, 1>;    // SWEL
            using GTWL = Field<7, 1>;    // GTWL
            using GTDL = Field<8, 1>;    // GTDL
            using GTEL = Field<9, 1>;    // GTEL
            using TXUL = Field<10, 1>;    // TXUL
            using TXOL = Field<11, 1>;    // TXOL
            using SE1L = Field<12, 1>;    // SE1L
            using SE2L = Field<13, 1>;    // SE2L
            using ELCL = Field<14, 1>;    // ELCL
            using IWTL = Field<15, 1>;    // IWTL
            using WTL = Field<16, 1>;    // WTL
            using AWL = Field<17, 1>;    // AWL
            using CERL = Field<18, 1>;    // CERL
        };

        // FDCAN TT operation status register
        struct FDCAN_TTOST : public RegisterReadOnly<0x4400f12c> {
            using EL = Field<0, 2>;    // EL
            using MS = Field<2, 2>;    // MS
            using SYS = Field<4, 2>;    // SYS
            using QGTP = Field<6, 1>;    // QGTP
            using QCS = Field<7, 1>;    // QCS
            using RTO = Field<8, 8>;    // RTO
            using WGTD = Field<22, 1>;    // WGTD
            using GFI = Field<23, 1>;    // GFI
            using TMP = Field<24, 3>;    // TMP
            using GSI = Field<27, 1>;    // GSI
            using WFE = Field<28, 1>;    // WFE
            using AWE = Field<29, 1>;    // AWE
            using WECS = Field<30, 1>;    // WECS
            using SPL = Field<31, 1>;    // SPL
        };

        // There is no drift compensation in TTCAN level 1.
        struct FDCAN_TURNA : public RegisterReadOnly<0x4400f130> {
            using NAV = Field<0, 18>;    // NAV
        };

        // FDCAN TT local and global time register
        struct FDCAN_TTLGT : public RegisterReadOnly<0x4400f134> {
            using LT = Field<0, 16>;    // LT
            using GT = Field<16, 16>;    // GT
        };

        // FDCAN TT cycle time and count register
        struct FDCAN_TTCTC : public RegisterReadOnly<0x4400f138> {
            using CT = Field<0, 16>;    // CT
            using CC = Field<16, 6>;    // CC
        };

        // FDCAN TT capture time register
        struct FDCAN_TTCPT : public RegisterReadOnly<0x4400f13c> {
            using CCV = Field<0, 6>;    // CCV
            using SWV = Field<16, 16>;    // SWV
        };

        // FDCAN TT cycle sync mark register
        struct FDCAN_TTCSM : public RegisterReadOnly<0x4400f140> {
            using CSM = Field<0, 16>;    // CSM
        };

        // The settings in the FDCAN_TTTS register select the input to be used as event trigger and stop watch trigger.
        struct FDCAN_TTTS : public Register<0x4400f300> {
            using SWTDEL = Field<0, 2>;    // SWTDEL
            using EVTSEL = Field<4, 2>;    // EVTSEL
        };

    };

    // CCU
    struct CCU {
        // Clock calibration unit core release register
        struct FCCAN_CCU_CREL : public RegisterReadOnly<0x44010000> {
            using DAY = Field<0, 8>;    // DAY
            using MON = Field<8, 8>;    // MON
            using YEAR = Field<16, 4>;    // YEAR
            using SUBSTEP = Field<20, 4>;    // SUBSTEP
            using STEP = Field<24, 4>;    // STEP
            using REL = Field<28, 4>;    // REL
        };

        // Calibration configuration register
        struct FCCAN_CCU_CCFG : public Register<0x44010004> {
            using TQBT = Field<0, 5>;    // TQBT
            using BCC = Field<6, 1>;    // BCC
            using CFL = Field<7, 1>;    // CFL
            using OCPM = Field<8, 8>;    // OCPM
            using CDIV = Field<16, 4>;    // CDIV
            using SWR = Field<31, 1>;    // SWR
        };

        // Calibration status register
        struct FCCAN_CCU_CSTAT : public RegisterReadOnly<0x44010008> {
            using OCPC = Field<0, 18>;    // OCPC
            using TQC = Field<18, 11>;    // TQC
            using CALS = Field<30, 2>;    // CALS
        };

        // The calibration watchdog is started after the first falling edge when the calibration FSM is in state Not_Calibrated (CCU_CSTAT.CALS = 00). In this state the calibration watchdog monitors the message received. In case no message was received until the calibration watchdog has counted down to 0, the calibration FSM stays in state Not_Calibrated (CCU_CSTAT.CALS = 00), the counter is reloaded with FDCAN_RWD.WDC and basic calibration is restarted after the next falling edge. When in state Basic_Calibrated (CCU_CSTAT.CALS = 01), the calibration watchdog is restarted with each received message . In case no message was received until the calibration watchdog has counted down to 0, the calibration FSM returns to state Not_Calibrated (CCU_CSTAT.CALS = 00), the counter is reloaded with FDCAN_RWD.WDC and basic calibration is restarted after the next falling edge. When a quartz message is received, state Precision_Calibrated (CCU_CSTAT.CALS = 10) is entered and the calibration watchdog is restarted. In this state the calibration watchdog monitors the quartz message received input. In case no message from a quartz controlled node is received by the attached TTCAN until the calibration watchdog has counted down to 0, the calibration FSM transits back to state Basic_Calibrated (CCU_CSTAT.CALS = 01). The signal is active when the CAN protocol engine on the attached TTCAN is started i.e. when the INIT bit is reset. A calibration watchdog event also sets interrupt flag CCU_IR.CWE. If enabled by CCU_IE.CWEE, interrupt line is activated (set to high). Interrupt line remains active until interrupt flag CCU_IR.CWE is reset.
        struct FCCAN_CCU_CWD : public Register<0x4401000c> {
            using WDC = Field<0, 16>;    // WDC
            using WDV = Field<16, 16>;    // WDV
        };

        // The flags are set when one of the listed conditions is detected (edge-sensitive). The flags remain set until the Host clears them. A flag is cleared by writing a 1 to the corresponding bit position. Writing a 0 has no effect. A hard reset will clear the register. The configuration of CCU_IE controls whether an interrupt is generated or not.
        struct FCCAN_CCU_IR : public Register<0x44010010> {
            using CWE = Field<0, 1>;    // CWE
            using CSC = Field<1, 1>;    // CSC
        };

        // The settings in the CU interrupt enable register determine whether a status change in the CU interrupt register will be signaled on an interrupt line.
        struct FCCAN_CCU_IE : public Register<0x44010014> {
            using CWEE = Field<0, 1>;    // CWEE
            using CSCE = Field<1, 1>;    // CSCE
        };

    };

    // FMC register block
    struct FMC {
        // This register contains the control information of each memory bank, used for SRAMs, PSRAM, FRAM and NOR Flash memories.
        struct FMC_BCR1 : public Register<0x58002000> {
            using MBKEN = Field<0, 1>;    // MBKEN
            using MUXEN = Field<1, 1>;    // MUXEN
            using MTYP = Field<2, 2>;    // MTYP
            using MWID = Field<4, 2>;    // MWID
            using FACCEN = Field<6, 1>;    // FACCEN
            using BURSTEN = Field<8, 1>;    // BURSTEN
            using WAITPOL = Field<9, 1>;    // WAITPOL
            using WAITCFG = Field<11, 1>;    // WAITCFG
            using WREN = Field<12, 1>;    // WREN
            using WAITEN = Field<13, 1>;    // WAITEN
            using EXTMOD = Field<14, 1>;    // EXTMOD
            using ASYNCWAIT = Field<15, 1>;    // ASYNCWAIT
            using CPSIZE = Field<16, 3>;    // CPSIZE
            using CBURSTRW = Field<19, 1>;    // CBURSTRW
            using CCLKEN = Field<20, 1>;    // CCLKEN
            using NBLSET = Field<22, 2>;    // NBLSET
            using FMCEN = Field<31, 1>;    // FMCEN
        };

        // This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, two registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
        struct FMC_BTR1 : public Register<0x58002004> {
            using ADDSET = Field<0, 4>;    // ADDSET
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using DATAST = Field<8, 8>;    // DATAST
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using DATLAT = Field<24, 4>;    // DATLAT
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATAHLD = Field<30, 2>;    // DATAHLD
        };

        // This register contains the control information of each memory bank, used for SRAMs, PSRAM, FRAM and NOR Flash memories.
        struct FMC_BCR2 : public Register<0x58002008> {
            using MBKEN = Field<0, 1>;    // MBKEN
            using MUXEN = Field<1, 1>;    // MUXEN
            using MTYP = Field<2, 2>;    // MTYP
            using MWID = Field<4, 2>;    // MWID
            using FACCEN = Field<6, 1>;    // FACCEN
            using BURSTEN = Field<8, 1>;    // BURSTEN
            using WAITPOL = Field<9, 1>;    // WAITPOL
            using WAITCFG = Field<11, 1>;    // WAITCFG
            using WREN = Field<12, 1>;    // WREN
            using WAITEN = Field<13, 1>;    // WAITEN
            using EXTMOD = Field<14, 1>;    // EXTMOD
            using ASYNCWAIT = Field<15, 1>;    // ASYNCWAIT
            using CPSIZE = Field<16, 3>;    // CPSIZE
            using CBURSTRW = Field<19, 1>;    // CBURSTRW
            using CCLKEN = Field<20, 1>;    // CCLKEN
            using NBLSET = Field<22, 2>;    // NBLSET
            using FMCEN = Field<31, 1>;    // FMCEN
        };

        // This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, two registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
        struct FMC_BTR2 : public Register<0x5800200c> {
            using ADDSET = Field<0, 4>;    // ADDSET
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using DATAST = Field<8, 8>;    // DATAST
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using DATLAT = Field<24, 4>;    // DATLAT
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATAHLD = Field<30, 2>;    // DATAHLD
        };

        // This register contains the control information of each memory bank, used for SRAMs, PSRAM, FRAM and NOR Flash memories.
        struct FMC_BCR3 : public Register<0x58002010> {
            using MBKEN = Field<0, 1>;    // MBKEN
            using MUXEN = Field<1, 1>;    // MUXEN
            using MTYP = Field<2, 2>;    // MTYP
            using MWID = Field<4, 2>;    // MWID
            using FACCEN = Field<6, 1>;    // FACCEN
            using BURSTEN = Field<8, 1>;    // BURSTEN
            using WAITPOL = Field<9, 1>;    // WAITPOL
            using WAITCFG = Field<11, 1>;    // WAITCFG
            using WREN = Field<12, 1>;    // WREN
            using WAITEN = Field<13, 1>;    // WAITEN
            using EXTMOD = Field<14, 1>;    // EXTMOD
            using ASYNCWAIT = Field<15, 1>;    // ASYNCWAIT
            using CPSIZE = Field<16, 3>;    // CPSIZE
            using CBURSTRW = Field<19, 1>;    // CBURSTRW
            using CCLKEN = Field<20, 1>;    // CCLKEN
            using NBLSET = Field<22, 2>;    // NBLSET
            using FMCEN = Field<31, 1>;    // FMCEN
        };

        // This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, two registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
        struct FMC_BTR3 : public Register<0x58002014> {
            using ADDSET = Field<0, 4>;    // ADDSET
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using DATAST = Field<8, 8>;    // DATAST
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using DATLAT = Field<24, 4>;    // DATLAT
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATAHLD = Field<30, 2>;    // DATAHLD
        };

        // This register contains the control information of each memory bank, used for SRAMs, PSRAM, FRAM and NOR Flash memories.
        struct FMC_BCR4 : public Register<0x58002018> {
            using MBKEN = Field<0, 1>;    // MBKEN
            using MUXEN = Field<1, 1>;    // MUXEN
            using MTYP = Field<2, 2>;    // MTYP
            using MWID = Field<4, 2>;    // MWID
            using FACCEN = Field<6, 1>;    // FACCEN
            using BURSTEN = Field<8, 1>;    // BURSTEN
            using WAITPOL = Field<9, 1>;    // WAITPOL
            using WAITCFG = Field<11, 1>;    // WAITCFG
            using WREN = Field<12, 1>;    // WREN
            using WAITEN = Field<13, 1>;    // WAITEN
            using EXTMOD = Field<14, 1>;    // EXTMOD
            using ASYNCWAIT = Field<15, 1>;    // ASYNCWAIT
            using CPSIZE = Field<16, 3>;    // CPSIZE
            using CBURSTRW = Field<19, 1>;    // CBURSTRW
            using CCLKEN = Field<20, 1>;    // CCLKEN
            using NBLSET = Field<22, 2>;    // NBLSET
            using FMCEN = Field<31, 1>;    // FMCEN
        };

        // This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, two registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
        struct FMC_BTR4 : public Register<0x5800201c> {
            using ADDSET = Field<0, 4>;    // ADDSET
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using DATAST = Field<8, 8>;    // DATAST
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using DATLAT = Field<24, 4>;    // DATLAT
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATAHLD = Field<30, 2>;    // DATAHLD
        };

        // This register contains the PSRAM chip select counter value for synchronous mode. The chip select counter is common to all banks and can be enabled separately on each bank. During PSRAM read or write accesses, this value is loaded into a timer which is decremented using the fmc_ker_ck while the NE signal is held low. When the timer reaches 0, the PSRAM controller splits the current access, toggles NE to allow PSRAM device refresh and restarts a new access. The programmed counter value guarantees a maximum NE pulse width (tCEM) as specified for PSRAM devices. The counter is reloaded and starts decrementing each time a new access is started by a transition of NE from high to low. h
        struct FMC_PCSCNTR : public Register<0x58002020> {
            using CSCOUNT = Field<0, 16>;    // CSCOUNT
            using CNTB1EN = Field<16, 1>;    // CNTB1EN
            using CNTB2EN = Field<17, 1>;    // CNTB2EN
            using CNTB3EN = Field<18, 1>;    // CNTB3EN
            using CNTB4EN = Field<19, 1>;    // CNTB4EN
        };

        // NAND Flash Programmable control register
        struct FMC_PCR : public Register<0x58002080> {
            using PWAITEN = Field<1, 1>;    // PWAITEN
            using PBKEN = Field<2, 1>;    // PBKEN
            using PWID = Field<4, 2>;    // PWID
            using ECCEN = Field<6, 1>;    // ECCEN
            using ECCALG = Field<8, 1>;    // ECCALG
            using TCLR = Field<9, 4>;    // TCLR
            using TAR = Field<13, 4>;    // TAR
            using ECCSS = Field<17, 3>;    // ECCSS
            using TCEH = Field<20, 4>;    // TCEH
            using BCHECC = Field<24, 1>;    // BCHECC
            using WEN = Field<25, 1>;    // WEN
        };

        // This register contains information about the AXI interface isolation status and the NAND write requests status. The FMC has to be disabled before modifying some registers. As requests might be pending, it is necessary to wait till the AXI interface is stable and the core of the block is totally isolated from its AXI interface before reconfiguring the registers. The PEF and PNWEF bits indicate the status of the pipe. If Hamming algorithm is used, the ECC is calculated while data are written to the memory. To read the correct ECC, the software must consequently wait untill no write request to the NAND controller are pending, by polling PEF and NWRF bits.
        struct FMC_SR : public RegisterReadOnly<0x58002084> {
            using ISOST = Field<0, 2>;    // ISOST
            using PEF = Field<4, 1>;    // PEF
            using NWRF = Field<6, 1>;    // NWRF
        };

        // The FMC_PMEM read/write register contains NAND Flash memory bank timing information. This information is used to access the NAND Flash common memory space for command, address write accesses or data read/write accesses.
        struct FMC_PMEM : public Register<0x58002088> {
            using MEMSET = Field<0, 8>;    // MEMSET
            using MEMWAIT = Field<8, 8>;    // MEMWAIT
            using MEMHOLD = Field<16, 8>;    // MEMHOLD
            using MEMHIZ = Field<24, 8>;    // MEMHIZ
        };

        // The FMC_PATT read/write register contains NAND Flash memory bank timing information. It is used for 8-bit accesses to the NAND Flash attribute memory space during the last address write access when the timing differs from previous accesses (for Ready/Busy management, refer to Section25.8.5: NAND Flash prewait function).
        struct FMC_PATT : public Register<0x5800208c> {
            using ATTSET = Field<0, 8>;    // ATTSET
            using ATTWAIT = Field<8, 8>;    // ATTWAIT
            using ATTHOLD = Field<16, 8>;    // ATTHOLD
            using ATTHIZ = Field<24, 8>;    // ATTHIZ
        };

        // This register is used during read accesses in conjunction with the FMC sequencer. It contains the current error correction code value computed by the FMC NAND controller Hamming module. When the FMC sequencer reads data from a NAND Flash memory page at the correct address, the data read are automatically processed by the Hamming computation module. When X bytes have been read (according to the sector size ECCSS field in the FMC_PCR register), the CPU must read the computed ECC value from the FMC_HECCR register. It then verifies if these computed parity data are the same as the parity value recorded in the spare area and stored in the and the FMC_HPR, to determine whether a page is valid, and to correct it otherwise. The FMC_HPR register should be cleared after being read by setting the ECCEN bit to 0. To compute a new data block, the ECCEN bit must be set to 1.
        struct FMC_HPR : public RegisterReadOnly<0x58002090> {
            using HPR = Field<0, 32>;    // HPR
        };

        // This register contain the current error correction code value computed by the FMC NAND controller Hamming module.When the CPU reads/writes data from/to a NAND Flash memory page at the correct address (refer to Section25.8.6: NAND ECC controller), the data read/written from/to the NAND Flash memory are automatically processed by the Hamming computation module. When X bytes have been read (according to the sector size ECCSS field in the FMC_PCR register), the CPU must read the computed ECC value from the FMC_HECCR register. It then verifies if these computed parity data are the same as the parity value recorded in the spare area, to determine whether a page is valid, and to correct it otherwise. The FMC_HECCR register should be cleared after being read by setting the ECCEN bit to 0. To compute a new data block, the ECCEN bit must be set to 1.
        struct FMC_HECCR : public RegisterReadOnly<0x58002094> {
            using HECC = Field<0, 32>;    // HECC
        };

        // This register contains the control information of each memory bank. It is used for SRAMs, FRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
        struct FMC_BWTR1 : public Register<0x58002104> {
            using ADDSET = Field<0, 4>;    // ADDSET
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using DATAST = Field<8, 8>;    // DATAST
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATAHLD = Field<30, 2>;    // DATAHLD
        };

        // This register contains the control information of each memory bank. It is used for SRAMs, FRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
        struct FMC_BWTR2 : public Register<0x5800210c> {
            using ADDSET = Field<0, 4>;    // ADDSET
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using DATAST = Field<8, 8>;    // DATAST
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATAHLD = Field<30, 2>;    // DATAHLD
        };

        // This register contains the control information of each memory bank. It is used for SRAMs, FRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
        struct FMC_BWTR3 : public Register<0x58002114> {
            using ADDSET = Field<0, 4>;    // ADDSET
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using DATAST = Field<8, 8>;    // DATAST
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATAHLD = Field<30, 2>;    // DATAHLD
        };

        // This register contains the control information of each memory bank. It is used for SRAMs, FRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
        struct FMC_BWTR4 : public Register<0x5800211c> {
            using ADDSET = Field<0, 4>;    // ADDSET
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using DATAST = Field<8, 8>;    // DATAST
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATAHLD = Field<30, 2>;    // DATAHLD
        };

        // FMC NAND Command Sequencer Control Register
        struct FMC_CSQCR : public RegisterWriteOnly<0x58002200> {
            using CSQSTART = Field<0, 1>;    // CSQSTART
        };

        // FMC NAND Command Sequencer Configuration Register 1
        struct FMC_CSQCFGR1 : public Register<0x58002204> {
            using CMD2EN = Field<1, 1>;    // CMD2EN
            using DMADEN = Field<2, 1>;    // DMADEN
            using ACYNBR = Field<4, 3>;    // ACYNBR
            using CMD1 = Field<8, 8>;    // CMD1
            using CMD2 = Field<16, 8>;    // CMD2
            using CMD1T = Field<24, 1>;    // CMD1T
            using CMD2T = Field<25, 1>;    // CMD2T
        };

        // This register is used to configure the command sequencer to issue random read/ write commands to read/ write data by sector and automatically read/write data from NAND Flash memory at a programmable address offset. This is useful when performing a sector read/write operation followed by an ECC read/write operation in the NAND Flash spare area.The command sequencer generates the random commands untill all the sectors are read/written. .
        struct FMC_CSQCFGR2 : public Register<0x58002208> {
            using SQSDTEN = Field<0, 1>;    // SQSDTEN
            using RCMD2EN = Field<1, 1>;    // RCMD2EN
            using DMASEN = Field<2, 1>;    // DMASEN
            using RCMD1 = Field<8, 8>;    // RCMD1
            using RCMD2 = Field<16, 8>;    // RCMD2
            using RCMD1T = Field<24, 1>;    // RCMD1T
            using RCMD2T = Field<25, 1>;    // RCMD2T
        };

        // FMC NAND sequencer configuration register 3
        struct FMC_CSQCFGR3 : public Register<0x5800220c> {
            using SNBR = Field<8, 6>;    // SNBR
            using AC1T = Field<16, 1>;    // AC1T
            using AC2T = Field<17, 1>;    // AC2T
            using AC3T = Field<18, 1>;    // AC3T
            using AC4T = Field<19, 1>;    // AC4T
            using AC5T = Field<20, 1>;    // AC5T
            using SDT = Field<21, 1>;    // SDT
            using RAC1T = Field<22, 1>;    // RAC1T
            using RAC2T = Field<23, 1>;    // RAC2T
        };

        // This register is used to define the value of address cycles 1 to 4 to be issued by the command sequencer.
        struct FMC_CSQAR1 : public Register<0x58002210> {
            using ADDC1 = Field<0, 8>;    // ADDC1
            using ADDC2 = Field<8, 8>;    // ADDC2
            using ADDC3 = Field<16, 8>;    // ADDC3
            using ADDC4 = Field<24, 8>;    // ADDC4
        };

        // This register is used to program the fifth address cycle and the address offset in spare area. It also selects the chip enable.
        struct FMC_CSQAR2 : public Register<0x58002214> {
            using ADDC5 = Field<0, 8>;    // ADDC5
            using NANDCEN0 = Field<10, 1>;    // NANDCEN0
            using NANDCEN1 = Field<11, 1>;    // NANDCEN1
            using SAO = Field<16, 16>;    // SAO
        };

        // FMC NAND Command Sequencer Interrupt Enable Register
        struct FMC_CSQIER : public Register<0x58002220> {
            using TCIE = Field<0, 1>;    // TCIE
            using SCIE = Field<1, 1>;    // SCIE
            using SEIE = Field<2, 1>;    // SEIE
            using SUEIE = Field<3, 1>;    // SUEIE
            using CMDTCIE = Field<4, 1>;    // CMDTCIE
        };

        // FMC NAND Command Sequencer Interrupt Status Register
        struct FMC_CSQISR : public Register<0x58002224> {
            using TCF = Field<0, 1>;    // TCF
            using SCF = Field<1, 1>;    // SCF
            using SEF = Field<2, 1>;    // SEF
            using SUEF = Field<3, 1>;    // SUEF
            using CMDTCF = Field<4, 1>;    // CMDTCF
        };

        // FMC NAND Command Sequencer Interrupt Clear Register
        struct FMC_CSQICR : public RegisterWriteOnly<0x58002228> {
            using CTCF = Field<0, 1>;    // CTCF
            using CSCF = Field<1, 1>;    // CSCF
            using CSEF = Field<2, 1>;    // CSEF
            using CSUEF = Field<3, 1>;    // CSUEF
            using CCMDTCF = Field<4, 1>;    // CCMDTCF
        };

        // This register holds a sector error mapping status when the whole transfer is complete.
        struct FMC_CSQEMSR : public RegisterReadOnly<0x58002230> {
            using SEM = Field<0, 16>;    // SEM
        };

        // FMC BCH Interrupt enable register
        struct FMC_BCHIER : public Register<0x58002250> {
            using DUEIE = Field<0, 1>;    // DUEIE
            using DERIE = Field<1, 1>;    // DERIE
            using DEFIE = Field<2, 1>;    // DEFIE
            using DSRIE = Field<3, 1>;    // DSRIE
            using EPBRIE = Field<4, 1>;    // EPBRIE
        };

        // This register holds the status of BCH encoder/decoder after processing each sector. When the sequencer is used, this register is automatically cleared.
        struct FMC_BCHISR : public RegisterReadOnly<0x58002254> {
            using DUEF = Field<0, 1>;    // DUEF
            using DERF = Field<1, 1>;    // DERF
            using DEFF = Field<2, 1>;    // DEFF
            using DSRF = Field<3, 1>;    // DSRF
            using EPBRF = Field<4, 1>;    // EPBRF
        };

        // FMC BCH Interrupt Clear Register
        struct FMC_BCHICR : public RegisterWriteOnly<0x58002258> {
            using CDUEF = Field<0, 1>;    // CDUEF
            using CDERF = Field<1, 1>;    // CDERF
            using CDEFF = Field<2, 1>;    // CDEFF
            using CDSRF = Field<3, 1>;    // CDSRF
            using CEPBRF = Field<4, 1>;    // CEPBRF
        };

        // These registers contain the BCH parity bits (BCHPB). For the BCH 4-bit, only BCHPB[51:0] are significant and for the BCH 8-bit BCHPB[103:0] are significant.
        struct FMC_BCHPBR1 : public RegisterReadOnly<0x58002260> {
            using BCHPB = Field<0, 32>;    // BCHPB
        };

        // FMC BCH Parity Bits Register 2
        struct FMC_BCHPBR2 : public RegisterReadOnly<0x58002264> {
            using BCHPB = Field<0, 32>;    // BCHPB
        };

        // FMC BCH Parity Bits Register 3
        struct FMC_BCHPBR3 : public RegisterReadOnly<0x58002268> {
            using BCHPB = Field<0, 32>;    // BCHPB
        };

        // FMC BCH Parity Bits Register 4
        struct FMC_BCHPBR4 : public RegisterReadOnly<0x5800226c> {
            using BCHPB = Field<0, 8>;    // BCHPB
        };

        // This register contains some fields already available in other registers but that require to be saved when error correction is performed on several sectors at a time (for example a whole NAND Flash page). This allows a DMA channel to transfer the content of FMC_BCHDSR0..4 to a decoding status buffer. .
        struct FMC_BCHDSR0 : public RegisterReadOnly<0x5800227c> {
            using DUE = Field<0, 1>;    // DUE
            using DEF = Field<1, 1>;    // DEF
            using DEN = Field<4, 4>;    // DEN
        };

        // The maximum error correction capability of the BCH block embedded in the FMC is 8 errors
        struct FMC_BCHDSR1 : public RegisterReadOnly<0x58002280> {
            using EBP1 = Field<0, 13>;    // EBP1
            using EBP2 = Field<16, 13>;    // EBP2
        };

        // The maximum error correction capability of the BCH block embedded in the FMC is 8 errors. This register contains the positions of the 3rd and 4th error bits in EBP3 and EPB4 fields, respectively.
        struct FMC_BCHDSR2 : public RegisterReadOnly<0x58002284> {
            using EBP3 = Field<0, 13>;    // EBP3
            using EBP4 = Field<16, 13>;    // EBP4
        };

        // The maximum error correction capability of the BCH block embedded in the FMC is 8 errors.
        struct FMC_BCHDSR3 : public RegisterReadOnly<0x58002288> {
            using EBP5 = Field<0, 13>;    // EBP5
            using EBP6 = Field<16, 13>;    // EBP6
        };

        // The maximum error correction capability of the BCH block embedded in the FMC is 8 errors. This register contains the positions of the 7th and 8th error bits in EBP7 and EPB8 fields, respectively. .
        struct FMC_BCHDSR4 : public RegisterReadOnly<0x5800228c> {
            using EBP7 = Field<0, 13>;    // EBP7
            using EBP8 = Field<16, 13>;    // EBP8
        };

        // FMC Hardware configuration register 2
        struct FMC_HWCFGR2 : public RegisterReadOnly<0x580023ec> {
            using RD_LN2DPTH = Field<0, 4>;    // RD_LN2DPTH
            using NOR_BASE = Field<4, 4>;    // NOR_BASE
            using SDRAM_RBASE = Field<8, 4>;    // SDRAM_RBASE
            using NAND_BASE = Field<12, 4>;    // NAND_BASE
            using SDRAM1_BASE = Field<16, 4>;    // SDRAM1_BASE
            using SDRAM2_BASE = Field<20, 4>;    // SDRAM2_BASE
        };

        // FMC Hardware configuration register 1
        struct FMC_HWCFGR1 : public RegisterReadOnly<0x580023f0> {
            using NAND_SEL = Field<0, 1>;    // NAND_SEL
            using NAND_ECC = Field<4, 1>;    // NAND_ECC
            using SDRAM_SEL = Field<8, 1>;    // SDRAM_SEL
            using ID_SIZE = Field<12, 4>;    // ID_SIZE
            using WA_LN2DPTH = Field<16, 4>;    // WA_LN2DPTH
            using WD_LN2DPTH = Field<20, 4>;    // WD_LN2DPTH
            using WR_LN2DPTH = Field<24, 4>;    // WR_LN2DPTH
            using RA_LN2DPTH = Field<28, 4>;    // RA_LN2DPTH
        };

        // FMC Version register
        struct FMC_VERR : public RegisterReadOnly<0x580023f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // FMC Identification register
        struct FMC_IPIDR : public RegisterReadOnly<0x580023f8> {
            using ID = Field<0, 32>;    // ID
        };

        // FMC Size Identification register
        struct FMC_SIDR : public RegisterReadOnly<0x580023fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // GICD
    struct GICD {
        // GICD control register
        struct GICD_CTLR : public Register<0xa0021000> {
            using ENABLEGRP0 = Field<0, 1>;    // ENABLEGRP0
            using ENABLEGRP1 = Field<1, 1>;    // ENABLEGRP1
        };

        // GICD interrupt controller type register
        struct GICD_TYPER : public RegisterReadOnly<0xa0021004> {
            using ITLINESNUMBER = Field<0, 5>;    // ITLINESNUMBER
            using CPUNUMBER = Field<5, 3>;    // CPUNUMBER
            using SECURITYEXTN = Field<10, 1>;    // SECURITYEXTN
            using LSPI = Field<11, 5>;    // LSPI
        };

        // GICD implementer identification register
        struct GICD_IIDR : public RegisterReadOnly<0xa0021008> {
            using IMPLEMENTER = Field<0, 12>;    // IMPLEMENTER
            using VARIANT = Field<12, 4>;    // VARIANT
            using REVISION = Field<16, 4>;    // REVISION
            using PRODUCTID = Field<24, 8>;    // PRODUCTID
        };

        // For interrupts ID
        struct GICD_IGROUPR0 : public Register<0xa0021080> {
            using IGROUPR0 = Field<0, 32>;    // IGROUPR0
        };

        // For interrupts ID
        struct GICD_IGROUPR1 : public Register<0xa0021084> {
            using IGROUPR1 = Field<0, 32>;    // IGROUPR1
        };

        // For interrupts ID
        struct GICD_IGROUPR2 : public Register<0xa0021088> {
            using IGROUPR2 = Field<0, 32>;    // IGROUPR2
        };

        // For interrupts ID = x*32 to ID = x*32+31
        struct GICD_IGROUPR3 : public Register<0xa002108c> {
            using IGROUPR3 = Field<0, 32>;    // IGROUPR3
        };

        // For interrupts ID = x*32 to ID = x*32+31
        struct GICD_IGROUPR4 : public Register<0xa0021090> {
            using IGROUPR4 = Field<0, 32>;    // IGROUPR4
        };

        // For interrupts ID
        struct GICD_IGROUPR5 : public Register<0xa0021094> {
            using IGROUPR5 = Field<0, 32>;    // IGROUPR5
        };

        // For interrupts ID
        struct GICD_IGROUPR6 : public Register<0xa0021098> {
            using IGROUPR6 = Field<0, 32>;    // IGROUPR6
        };

        // For interrupts ID
        struct GICD_IGROUPR7 : public Register<0xa002109c> {
            using IGROUPR7 = Field<0, 32>;    // IGROUPR7
        };

        // For interrupts ID
        struct GICD_IGROUPR8 : public Register<0xa00210a0> {
            using IGROUPR8 = Field<0, 32>;    // IGROUPR8
        };

        // For interrupts ID = 0 to ID = 31
        struct GICD_ISENABLER0 : public Register<0xa0021100> {
            using ISENABLER0 = Field<0, 32>;    // ISENABLER0
        };

        // For interrupts ID
        struct GICD_ISENABLER1 : public Register<0xa0021104> {
            using ISENABLER1 = Field<0, 32>;    // ISENABLER1
        };

        // For interrupts ID
        struct GICD_ISENABLER2 : public Register<0xa0021108> {
            using ISENABLER2 = Field<0, 32>;    // ISENABLER2
        };

        // For interrupts ID
        struct GICD_ISENABLER3 : public Register<0xa002110c> {
            using ISENABLER3 = Field<0, 32>;    // ISENABLER3
        };

        // For interrupts ID
        struct GICD_ISENABLER4 : public Register<0xa0021110> {
            using ISENABLER4 = Field<0, 32>;    // ISENABLER4
        };

        // For interrupts ID
        struct GICD_ISENABLER5 : public Register<0xa0021114> {
            using ISENABLER5 = Field<0, 32>;    // ISENABLER5
        };

        // For interrupts ID
        struct GICD_ISENABLER6 : public Register<0xa0021118> {
            using ISENABLER6 = Field<0, 32>;    // ISENABLER6
        };

        // For interrupts ID
        struct GICD_ISENABLER7 : public Register<0xa002111c> {
            using ISENABLER7 = Field<0, 32>;    // ISENABLER7
        };

        // For interrupts ID
        struct GICD_ISENABLER8 : public Register<0xa0021120> {
            using ISENABLER8 = Field<0, 32>;    // ISENABLER8
        };

        // For interrupts ID = 0 to ID = 31
        struct GICD_ICENABLER0 : public Register<0xa0021180> {
            using ICENABLER0 = Field<0, 32>;    // ICENABLER0
        };

        // For interrupts ID
        struct GICD_ICENABLER1 : public Register<0xa0021184> {
            using ICENABLER1 = Field<0, 32>;    // ICENABLER1
        };

        // For interrupts ID
        struct GICD_ICENABLER2 : public Register<0xa0021188> {
            using ICENABLER2 = Field<0, 32>;    // ICENABLER2
        };

        // For interrupts ID
        struct GICD_ICENABLER3 : public Register<0xa002118c> {
            using ICENABLER3 = Field<0, 32>;    // ICENABLER3
        };

        // For interrupts ID
        struct GICD_ICENABLER4 : public Register<0xa0021190> {
            using ICENABLER4 = Field<0, 32>;    // ICENABLER4
        };

        // For interrupts ID
        struct GICD_ICENABLER5 : public Register<0xa0021194> {
            using ICENABLER5 = Field<0, 32>;    // ICENABLER5
        };

        // For interrupts ID
        struct GICD_ICENABLER6 : public Register<0xa0021198> {
            using ICENABLER6 = Field<0, 32>;    // ICENABLER6
        };

        // For interrupts ID
        struct GICD_ICENABLER7 : public Register<0xa002119c> {
            using ICENABLER7 = Field<0, 32>;    // ICENABLER7
        };

        // For interrupts ID
        struct GICD_ICENABLER8 : public Register<0xa00211a0> {
            using ICENABLER8 = Field<0, 32>;    // ICENABLER8
        };

        // For interrupts ID
        struct GICD_ISPENDR0 : public Register<0xa0021200> {
            using ISPENDR0 = Field<0, 32>;    // ISPENDR0
        };

        // For interrupts ID
        struct GICD_ISPENDR1 : public Register<0xa0021204> {
            using ISPENDR1 = Field<0, 32>;    // ISPENDR1
        };

        // For interrupts ID
        struct GICD_ISPENDR2 : public Register<0xa0021208> {
            using ISPENDR2 = Field<0, 32>;    // ISPENDR2
        };

        // For interrupts ID
        struct GICD_ISPENDR3 : public Register<0xa002120c> {
            using ISPENDR3 = Field<0, 32>;    // ISPENDR3
        };

        // For interrupts ID
        struct GICD_ISPENDR4 : public Register<0xa0021210> {
            using ISPENDR4 = Field<0, 32>;    // ISPENDR4
        };

        // For interrupts ID
        struct GICD_ISPENDR5 : public Register<0xa0021214> {
            using ISPENDR5 = Field<0, 32>;    // ISPENDR5
        };

        // For interrupts ID
        struct GICD_ISPENDR6 : public Register<0xa0021218> {
            using ISPENDR6 = Field<0, 32>;    // ISPENDR6
        };

        // For interrupts ID
        struct GICD_ISPENDR7 : public Register<0xa002121c> {
            using ISPENDR7 = Field<0, 32>;    // ISPENDR7
        };

        // For interrupts ID
        struct GICD_ISPENDR8 : public Register<0xa0021220> {
            using ISPENDR8 = Field<0, 32>;    // ISPENDR8
        };

        // For interrupts ID
        struct GICD_ICPENDR0 : public Register<0xa0021280> {
            using ICPENDR0 = Field<0, 32>;    // ICPENDR0
        };

        // For interrupts ID
        struct GICD_ICPENDR1 : public Register<0xa0021284> {
            using ICPENDR1 = Field<0, 32>;    // ICPENDR1
        };

        // For interrupts ID
        struct GICD_ICPENDR2 : public Register<0xa0021288> {
            using ICPENDR2 = Field<0, 32>;    // ICPENDR2
        };

        // For interrupts ID
        struct GICD_ICPENDR3 : public Register<0xa002128c> {
            using ICPENDR3 = Field<0, 32>;    // ICPENDR3
        };

        // For interrupts ID
        struct GICD_ICPENDR4 : public Register<0xa0021290> {
            using ICPENDR4 = Field<0, 32>;    // ICPENDR4
        };

        // For interrupts ID
        struct GICD_ICPENDR5 : public Register<0xa0021294> {
            using ICPENDR5 = Field<0, 32>;    // ICPENDR5
        };

        // For interrupts ID
        struct GICD_ICPENDR6 : public Register<0xa0021298> {
            using ICPENDR6 = Field<0, 32>;    // ICPENDR6
        };

        // For interrupts ID
        struct GICD_ICPENDR7 : public Register<0xa002129c> {
            using ICPENDR7 = Field<0, 32>;    // ICPENDR7
        };

        // For interrupts ID
        struct GICD_ICPENDR8 : public Register<0xa00212a0> {
            using ICPENDR8 = Field<0, 32>;    // ICPENDR8
        };

        // For interrupts ID
        struct GICD_ISACTIVER0 : public Register<0xa0021300> {
            using ISACTIVER0 = Field<0, 32>;    // ISACTIVER0
        };

        // For interrupts ID
        struct GICD_ISACTIVER1 : public Register<0xa0021304> {
            using ISACTIVER1 = Field<0, 32>;    // ISACTIVER1
        };

        // For interrupts ID
        struct GICD_ISACTIVER2 : public Register<0xa0021308> {
            using ISACTIVER2 = Field<0, 32>;    // ISACTIVER2
        };

        // For interrupts ID
        struct GICD_ISACTIVER3 : public Register<0xa002130c> {
            using ISACTIVER3 = Field<0, 32>;    // ISACTIVER3
        };

        // For interrupts ID
        struct GICD_ISACTIVER4 : public Register<0xa0021310> {
            using ISACTIVER4 = Field<0, 32>;    // ISACTIVER4
        };

        // For interrupts ID
        struct GICD_ISACTIVER5 : public Register<0xa0021314> {
            using ISACTIVER5 = Field<0, 32>;    // ISACTIVER5
        };

        // For interrupts ID
        struct GICD_ISACTIVER6 : public Register<0xa0021318> {
            using ISACTIVER6 = Field<0, 32>;    // ISACTIVER6
        };

        // For interrupts ID
        struct GICD_ISACTIVER7 : public Register<0xa002131c> {
            using ISACTIVER7 = Field<0, 32>;    // ISACTIVER7
        };

        // For interrupts ID
        struct GICD_ISACTIVER8 : public Register<0xa0021320> {
            using ISACTIVER8 = Field<0, 32>;    // ISACTIVER8
        };

        // For interrupts ID
        struct GICD_ICACTIVER0 : public Register<0xa0021380> {
            using ICACTIVER0 = Field<0, 32>;    // ICACTIVER0
        };

        // For interrupts ID
        struct GICD_ICACTIVER1 : public Register<0xa0021384> {
            using ICACTIVER1 = Field<0, 32>;    // ICACTIVER1
        };

        // For interrupts ID
        struct GICD_ICACTIVER2 : public Register<0xa0021388> {
            using ICACTIVER2 = Field<0, 32>;    // ICACTIVER2
        };

        // For interrupts ID
        struct GICD_ICACTIVER3 : public Register<0xa002138c> {
            using ICACTIVER3 = Field<0, 32>;    // ICACTIVER3
        };

        // For interrupts ID
        struct GICD_ICACTIVER4 : public Register<0xa0021390> {
            using ICACTIVER4 = Field<0, 32>;    // ICACTIVER4
        };

        // For interrupts ID
        struct GICD_ICACTIVER5 : public Register<0xa0021394> {
            using ICACTIVER5 = Field<0, 32>;    // ICACTIVER5
        };

        // For interrupts ID
        struct GICD_ICACTIVER6 : public Register<0xa0021398> {
            using ICACTIVER6 = Field<0, 32>;    // ICACTIVER6
        };

        // For interrupts ID
        struct GICD_ICACTIVER7 : public Register<0xa002139c> {
            using ICACTIVER7 = Field<0, 32>;    // ICACTIVER7
        };

        // For interrupts ID
        struct GICD_ICACTIVER8 : public Register<0xa00213a0> {
            using ICACTIVER8 = Field<0, 32>;    // ICACTIVER8
        };

        // GICD interrupt priority register 0
        struct GICD_IPRIORITYR0 : public Register<0xa0021400> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 1
        struct GICD_IPRIORITYR1 : public Register<0xa0021404> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 2
        struct GICD_IPRIORITYR2 : public Register<0xa0021408> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 3
        struct GICD_IPRIORITYR3 : public Register<0xa002140c> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 4
        struct GICD_IPRIORITYR4 : public Register<0xa0021410> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 5
        struct GICD_IPRIORITYR5 : public Register<0xa0021414> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 6
        struct GICD_IPRIORITYR6 : public Register<0xa0021418> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 7
        struct GICD_IPRIORITYR7 : public Register<0xa002141c> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 8
        struct GICD_IPRIORITYR8 : public Register<0xa0021420> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 9
        struct GICD_IPRIORITYR9 : public Register<0xa0021424> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 10
        struct GICD_IPRIORITYR10 : public Register<0xa0021428> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 11
        struct GICD_IPRIORITYR11 : public Register<0xa002142c> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 12
        struct GICD_IPRIORITYR12 : public Register<0xa0021430> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 13
        struct GICD_IPRIORITYR13 : public Register<0xa0021434> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 14
        struct GICD_IPRIORITYR14 : public Register<0xa0021438> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 15
        struct GICD_IPRIORITYR15 : public Register<0xa002143c> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 16
        struct GICD_IPRIORITYR16 : public Register<0xa0021440> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 17
        struct GICD_IPRIORITYR17 : public Register<0xa0021444> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 18
        struct GICD_IPRIORITYR18 : public Register<0xa0021448> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 19
        struct GICD_IPRIORITYR19 : public Register<0xa002144c> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 20
        struct GICD_IPRIORITYR20 : public Register<0xa0021450> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 21
        struct GICD_IPRIORITYR21 : public Register<0xa0021454> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 22
        struct GICD_IPRIORITYR22 : public Register<0xa0021458> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 23
        struct GICD_IPRIORITYR23 : public Register<0xa002145c> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 24
        struct GICD_IPRIORITYR24 : public Register<0xa0021460> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 25
        struct GICD_IPRIORITYR25 : public Register<0xa0021464> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 26
        struct GICD_IPRIORITYR26 : public Register<0xa0021468> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 27
        struct GICD_IPRIORITYR27 : public Register<0xa002146c> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 28
        struct GICD_IPRIORITYR28 : public Register<0xa0021470> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 29
        struct GICD_IPRIORITYR29 : public Register<0xa0021474> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 30
        struct GICD_IPRIORITYR30 : public Register<0xa0021478> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 31
        struct GICD_IPRIORITYR31 : public Register<0xa002147c> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 32
        struct GICD_IPRIORITYR32 : public Register<0xa0021480> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 33
        struct GICD_IPRIORITYR33 : public Register<0xa0021484> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 34
        struct GICD_IPRIORITYR34 : public Register<0xa0021488> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 35
        struct GICD_IPRIORITYR35 : public Register<0xa002148c> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 36
        struct GICD_IPRIORITYR36 : public Register<0xa0021490> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 37
        struct GICD_IPRIORITYR37 : public Register<0xa0021494> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 38
        struct GICD_IPRIORITYR38 : public Register<0xa0021498> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 39
        struct GICD_IPRIORITYR39 : public Register<0xa002149c> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 40
        struct GICD_IPRIORITYR40 : public Register<0xa00214a0> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 41
        struct GICD_IPRIORITYR41 : public Register<0xa00214a4> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 42
        struct GICD_IPRIORITYR42 : public Register<0xa00214a8> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 43
        struct GICD_IPRIORITYR43 : public Register<0xa00214ac> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 44
        struct GICD_IPRIORITYR44 : public Register<0xa00214b0> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 45
        struct GICD_IPRIORITYR45 : public Register<0xa00214b4> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 46
        struct GICD_IPRIORITYR46 : public Register<0xa00214b8> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 47
        struct GICD_IPRIORITYR47 : public Register<0xa00214bc> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 48
        struct GICD_IPRIORITYR48 : public Register<0xa00214c0> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 49
        struct GICD_IPRIORITYR49 : public Register<0xa00214c4> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 50
        struct GICD_IPRIORITYR50 : public Register<0xa00214c8> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 51
        struct GICD_IPRIORITYR51 : public Register<0xa00214cc> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 52
        struct GICD_IPRIORITYR52 : public Register<0xa00214d0> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 53
        struct GICD_IPRIORITYR53 : public Register<0xa00214d4> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 54
        struct GICD_IPRIORITYR54 : public Register<0xa00214d8> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 55
        struct GICD_IPRIORITYR55 : public Register<0xa00214dc> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 56
        struct GICD_IPRIORITYR56 : public Register<0xa00214e0> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 57
        struct GICD_IPRIORITYR57 : public Register<0xa00214e4> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 58
        struct GICD_IPRIORITYR58 : public Register<0xa00214e8> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 59
        struct GICD_IPRIORITYR59 : public Register<0xa00214ec> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 60
        struct GICD_IPRIORITYR60 : public Register<0xa00214f0> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 61
        struct GICD_IPRIORITYR61 : public Register<0xa00214f4> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 62
        struct GICD_IPRIORITYR62 : public Register<0xa00214f8> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 63
        struct GICD_IPRIORITYR63 : public Register<0xa00214fc> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 64
        struct GICD_IPRIORITYR64 : public Register<0xa0021500> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 65
        struct GICD_IPRIORITYR65 : public Register<0xa0021504> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 66
        struct GICD_IPRIORITYR66 : public Register<0xa0021508> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 67
        struct GICD_IPRIORITYR67 : public Register<0xa002150c> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 68
        struct GICD_IPRIORITYR68 : public Register<0xa0021510> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 69
        struct GICD_IPRIORITYR69 : public Register<0xa0021514> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 70
        struct GICD_IPRIORITYR70 : public Register<0xa0021518> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // GICD interrupt priority register 71
        struct GICD_IPRIORITYR71 : public Register<0xa002151c> {
            using PRIORITY0 = Field<3, 5>;    // PRIORITY0
            using PRIORITY1 = Field<11, 5>;    // PRIORITY1
            using PRIORITY2 = Field<19, 5>;    // PRIORITY2
            using PRIORITY3 = Field<27, 5>;    // PRIORITY3
        };

        // For existing SGIs and PPIs, read of CPU targets field returns the number of the processor performing the read.
        struct GICD_ITARGETSR0 : public RegisterReadOnly<0xa0021800> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // For existing SGIs and PPIs, read of CPU targets field returns the number of the processor performing the read.
        struct GICD_ITARGETSR1 : public RegisterReadOnly<0xa0021804> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // For existing SGIs and PPIs, read of CPU targets field returns the number of the processor performing the read.
        struct GICD_ITARGETSR2 : public RegisterReadOnly<0xa0021808> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // For existing SGIs and PPIs, read of CPU targets field returns the number of the processor performing the read.
        struct GICD_ITARGETSR3 : public RegisterReadOnly<0xa002180c> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // For existing SGIs and PPIs, read of CPU targets field returns the number of the processor performing the read.
        struct GICD_ITARGETSR4 : public RegisterReadOnly<0xa0021810> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // For existing SGIs and PPIs, read of CPU targets field returns the number of the processor performing the read.
        struct GICD_ITARGETSR5 : public RegisterReadOnly<0xa0021814> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // For existing SGIs and PPIs, read of CPU targets field returns the number of the processor performing the read.
        struct GICD_ITARGETSR6 : public RegisterReadOnly<0xa0021818> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // For existing SGIs and PPIs, read of CPU targets field returns the number of the processor performing the read.
        struct GICD_ITARGETSR7 : public RegisterReadOnly<0xa002181c> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 8
        struct GICD_ITARGETSR8 : public Register<0xa0021820> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 9
        struct GICD_ITARGETSR9 : public Register<0xa0021824> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 10
        struct GICD_ITARGETSR10 : public Register<0xa0021828> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 11
        struct GICD_ITARGETSR11 : public Register<0xa002182c> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 12
        struct GICD_ITARGETSR12 : public Register<0xa0021830> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 13
        struct GICD_ITARGETSR13 : public Register<0xa0021834> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 14
        struct GICD_ITARGETSR14 : public Register<0xa0021838> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 15
        struct GICD_ITARGETSR15 : public Register<0xa002183c> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 16
        struct GICD_ITARGETSR16 : public Register<0xa0021840> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 17
        struct GICD_ITARGETSR17 : public Register<0xa0021844> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 18
        struct GICD_ITARGETSR18 : public Register<0xa0021848> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 19
        struct GICD_ITARGETSR19 : public Register<0xa002184c> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 20
        struct GICD_ITARGETSR20 : public Register<0xa0021850> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 21
        struct GICD_ITARGETSR21 : public Register<0xa0021854> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 22
        struct GICD_ITARGETSR22 : public Register<0xa0021858> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 23
        struct GICD_ITARGETSR23 : public Register<0xa002185c> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 24
        struct GICD_ITARGETSR24 : public Register<0xa0021860> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 25
        struct GICD_ITARGETSR25 : public Register<0xa0021864> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 26
        struct GICD_ITARGETSR26 : public Register<0xa0021868> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 27
        struct GICD_ITARGETSR27 : public Register<0xa002186c> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 28
        struct GICD_ITARGETSR28 : public Register<0xa0021870> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 29
        struct GICD_ITARGETSR29 : public Register<0xa0021874> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 30
        struct GICD_ITARGETSR30 : public Register<0xa0021878> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 31
        struct GICD_ITARGETSR31 : public Register<0xa002187c> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 32
        struct GICD_ITARGETSR32 : public Register<0xa0021880> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 33
        struct GICD_ITARGETSR33 : public Register<0xa0021884> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 34
        struct GICD_ITARGETSR34 : public Register<0xa0021888> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 35
        struct GICD_ITARGETSR35 : public Register<0xa002188c> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 36
        struct GICD_ITARGETSR36 : public Register<0xa0021890> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 37
        struct GICD_ITARGETSR37 : public Register<0xa0021894> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 38
        struct GICD_ITARGETSR38 : public Register<0xa0021898> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 39
        struct GICD_ITARGETSR39 : public Register<0xa002189c> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 40
        struct GICD_ITARGETSR40 : public Register<0xa00218a0> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 41
        struct GICD_ITARGETSR41 : public Register<0xa00218a4> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 42
        struct GICD_ITARGETSR42 : public Register<0xa00218a8> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 43
        struct GICD_ITARGETSR43 : public Register<0xa00218ac> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 44
        struct GICD_ITARGETSR44 : public Register<0xa00218b0> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 45
        struct GICD_ITARGETSR45 : public Register<0xa00218b4> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 46
        struct GICD_ITARGETSR46 : public Register<0xa00218b8> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 47
        struct GICD_ITARGETSR47 : public Register<0xa00218bc> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 48
        struct GICD_ITARGETSR48 : public Register<0xa00218c0> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 49
        struct GICD_ITARGETSR49 : public Register<0xa00218c4> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 50
        struct GICD_ITARGETSR50 : public Register<0xa00218c8> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 51
        struct GICD_ITARGETSR51 : public Register<0xa00218cc> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 52
        struct GICD_ITARGETSR52 : public Register<0xa00218d0> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 53
        struct GICD_ITARGETSR53 : public Register<0xa00218d4> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 54
        struct GICD_ITARGETSR54 : public Register<0xa00218d8> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 55
        struct GICD_ITARGETSR55 : public Register<0xa00218dc> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 56
        struct GICD_ITARGETSR56 : public Register<0xa00218e0> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 57
        struct GICD_ITARGETSR57 : public Register<0xa00218e4> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 58
        struct GICD_ITARGETSR58 : public Register<0xa00218e8> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 59
        struct GICD_ITARGETSR59 : public Register<0xa00218ec> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 60
        struct GICD_ITARGETSR60 : public Register<0xa00218f0> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 61
        struct GICD_ITARGETSR61 : public Register<0xa00218f4> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 62
        struct GICD_ITARGETSR62 : public Register<0xa00218f8> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 63
        struct GICD_ITARGETSR63 : public Register<0xa00218fc> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 64
        struct GICD_ITARGETSR64 : public Register<0xa0021900> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 65
        struct GICD_ITARGETSR65 : public Register<0xa0021904> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 66
        struct GICD_ITARGETSR66 : public Register<0xa0021908> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 67
        struct GICD_ITARGETSR67 : public Register<0xa002190c> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 68
        struct GICD_ITARGETSR68 : public Register<0xa0021910> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 69
        struct GICD_ITARGETSR69 : public Register<0xa0021914> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 70
        struct GICD_ITARGETSR70 : public Register<0xa0021918> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt processor target register 71
        struct GICD_ITARGETSR71 : public Register<0xa002191c> {
            using CPU_TARGETS0 = Field<0, 2>;    // CPU_TARGETS0
            using CPU_TARGETS1 = Field<8, 2>;    // CPU_TARGETS1
            using CPU_TARGETS2 = Field<16, 2>;    // CPU_TARGETS2
            using CPU_TARGETS3 = Field<24, 2>;    // CPU_TARGETS3
        };

        // GICD interrupt configuration register
        struct GICD_ICFGR0 : public Register<0xa0021c00> {
            using INT_CONFIG0 = Field<0, 2>;    // INT_CONFIG0
            using INT_CONFIG1 = Field<2, 2>;    // INT_CONFIG1
            using INT_CONFIG2 = Field<4, 2>;    // INT_CONFIG2
            using INT_CONFIG3 = Field<6, 2>;    // INT_CONFIG3
            using INT_CONFIG4 = Field<8, 2>;    // INT_CONFIG4
            using INT_CONFIG5 = Field<10, 2>;    // INT_CONFIG5
            using INT_CONFIG6 = Field<12, 2>;    // INT_CONFIG6
            using INT_CONFIG7 = Field<14, 2>;    // INT_CONFIG7
            using INT_CONFIG8 = Field<16, 2>;    // INT_CONFIG8
            using INT_CONFIG9 = Field<18, 2>;    // INT_CONFIG9
            using INT_CONFIG10 = Field<20, 2>;    // INT_CONFIG10
            using INT_CONFIG11 = Field<22, 2>;    // INT_CONFIG11
            using INT_CONFIG12 = Field<24, 2>;    // INT_CONFIG12
            using INT_CONFIG13 = Field<26, 2>;    // INT_CONFIG13
            using INT_CONFIG14 = Field<28, 2>;    // INT_CONFIG14
            using INT_CONFIG15 = Field<30, 2>;    // INT_CONFIG15
        };

        // GICD interrupt configuration register
        struct GICD_ICFGR1 : public Register<0xa0021c04> {
            using INT_CONFIG0 = Field<0, 2>;    // INT_CONFIG0
            using INT_CONFIG1 = Field<2, 2>;    // INT_CONFIG1
            using INT_CONFIG2 = Field<4, 2>;    // INT_CONFIG2
            using INT_CONFIG3 = Field<6, 2>;    // INT_CONFIG3
            using INT_CONFIG4 = Field<8, 2>;    // INT_CONFIG4
            using INT_CONFIG5 = Field<10, 2>;    // INT_CONFIG5
            using INT_CONFIG6 = Field<12, 2>;    // INT_CONFIG6
            using INT_CONFIG7 = Field<14, 2>;    // INT_CONFIG7
            using INT_CONFIG8 = Field<16, 2>;    // INT_CONFIG8
            using INT_CONFIG9 = Field<18, 2>;    // INT_CONFIG9
            using INT_CONFIG10 = Field<20, 2>;    // INT_CONFIG10
            using INT_CONFIG11 = Field<22, 2>;    // INT_CONFIG11
            using INT_CONFIG12 = Field<24, 2>;    // INT_CONFIG12
            using INT_CONFIG13 = Field<26, 2>;    // INT_CONFIG13
            using INT_CONFIG14 = Field<28, 2>;    // INT_CONFIG14
            using INT_CONFIG15 = Field<30, 2>;    // INT_CONFIG15
        };

        // GICD interrupt configuration register 2
        struct GICD_ICFGR2 : public Register<0xa0021c08> {
            using INT_CONFIG0 = Field<0, 2>;    // INT_CONFIG0
            using INT_CONFIG1 = Field<2, 2>;    // INT_CONFIG1
            using INT_CONFIG2 = Field<4, 2>;    // INT_CONFIG2
            using INT_CONFIG3 = Field<6, 2>;    // INT_CONFIG3
            using INT_CONFIG4 = Field<8, 2>;    // INT_CONFIG4
            using INT_CONFIG5 = Field<10, 2>;    // INT_CONFIG5
            using INT_CONFIG6 = Field<12, 2>;    // INT_CONFIG6
            using INT_CONFIG7 = Field<14, 2>;    // INT_CONFIG7
            using INT_CONFIG8 = Field<16, 2>;    // INT_CONFIG8
            using INT_CONFIG9 = Field<18, 2>;    // INT_CONFIG9
            using INT_CONFIG10 = Field<20, 2>;    // INT_CONFIG10
            using INT_CONFIG11 = Field<22, 2>;    // INT_CONFIG11
            using INT_CONFIG12 = Field<24, 2>;    // INT_CONFIG12
            using INT_CONFIG13 = Field<26, 2>;    // INT_CONFIG13
            using INT_CONFIG14 = Field<28, 2>;    // INT_CONFIG14
            using INT_CONFIG15 = Field<30, 2>;    // INT_CONFIG15
        };

        // GICD interrupt configuration register 3
        struct GICD_ICFGR3 : public Register<0xa0021c0c> {
            using INT_CONFIG0 = Field<0, 2>;    // INT_CONFIG0
            using INT_CONFIG1 = Field<2, 2>;    // INT_CONFIG1
            using INT_CONFIG2 = Field<4, 2>;    // INT_CONFIG2
            using INT_CONFIG3 = Field<6, 2>;    // INT_CONFIG3
            using INT_CONFIG4 = Field<8, 2>;    // INT_CONFIG4
            using INT_CONFIG5 = Field<10, 2>;    // INT_CONFIG5
            using INT_CONFIG6 = Field<12, 2>;    // INT_CONFIG6
            using INT_CONFIG7 = Field<14, 2>;    // INT_CONFIG7
            using INT_CONFIG8 = Field<16, 2>;    // INT_CONFIG8
            using INT_CONFIG9 = Field<18, 2>;    // INT_CONFIG9
            using INT_CONFIG10 = Field<20, 2>;    // INT_CONFIG10
            using INT_CONFIG11 = Field<22, 2>;    // INT_CONFIG11
            using INT_CONFIG12 = Field<24, 2>;    // INT_CONFIG12
            using INT_CONFIG13 = Field<26, 2>;    // INT_CONFIG13
            using INT_CONFIG14 = Field<28, 2>;    // INT_CONFIG14
            using INT_CONFIG15 = Field<30, 2>;    // INT_CONFIG15
        };

        // GICD interrupt configuration register 4
        struct GICD_ICFGR4 : public Register<0xa0021c10> {
            using INT_CONFIG0 = Field<0, 2>;    // INT_CONFIG0
            using INT_CONFIG1 = Field<2, 2>;    // INT_CONFIG1
            using INT_CONFIG2 = Field<4, 2>;    // INT_CONFIG2
            using INT_CONFIG3 = Field<6, 2>;    // INT_CONFIG3
            using INT_CONFIG4 = Field<8, 2>;    // INT_CONFIG4
            using INT_CONFIG5 = Field<10, 2>;    // INT_CONFIG5
            using INT_CONFIG6 = Field<12, 2>;    // INT_CONFIG6
            using INT_CONFIG7 = Field<14, 2>;    // INT_CONFIG7
            using INT_CONFIG8 = Field<16, 2>;    // INT_CONFIG8
            using INT_CONFIG9 = Field<18, 2>;    // INT_CONFIG9
            using INT_CONFIG10 = Field<20, 2>;    // INT_CONFIG10
            using INT_CONFIG11 = Field<22, 2>;    // INT_CONFIG11
            using INT_CONFIG12 = Field<24, 2>;    // INT_CONFIG12
            using INT_CONFIG13 = Field<26, 2>;    // INT_CONFIG13
            using INT_CONFIG14 = Field<28, 2>;    // INT_CONFIG14
            using INT_CONFIG15 = Field<30, 2>;    // INT_CONFIG15
        };

        // GICD interrupt configuration register 5
        struct GICD_ICFGR5 : public Register<0xa0021c14> {
            using INT_CONFIG0 = Field<0, 2>;    // INT_CONFIG0
            using INT_CONFIG1 = Field<2, 2>;    // INT_CONFIG1
            using INT_CONFIG2 = Field<4, 2>;    // INT_CONFIG2
            using INT_CONFIG3 = Field<6, 2>;    // INT_CONFIG3
            using INT_CONFIG4 = Field<8, 2>;    // INT_CONFIG4
            using INT_CONFIG5 = Field<10, 2>;    // INT_CONFIG5
            using INT_CONFIG6 = Field<12, 2>;    // INT_CONFIG6
            using INT_CONFIG7 = Field<14, 2>;    // INT_CONFIG7
            using INT_CONFIG8 = Field<16, 2>;    // INT_CONFIG8
            using INT_CONFIG9 = Field<18, 2>;    // INT_CONFIG9
            using INT_CONFIG10 = Field<20, 2>;    // INT_CONFIG10
            using INT_CONFIG11 = Field<22, 2>;    // INT_CONFIG11
            using INT_CONFIG12 = Field<24, 2>;    // INT_CONFIG12
            using INT_CONFIG13 = Field<26, 2>;    // INT_CONFIG13
            using INT_CONFIG14 = Field<28, 2>;    // INT_CONFIG14
            using INT_CONFIG15 = Field<30, 2>;    // INT_CONFIG15
        };

        // GICD interrupt configuration register 6
        struct GICD_ICFGR6 : public Register<0xa0021c18> {
            using INT_CONFIG0 = Field<0, 2>;    // INT_CONFIG0
            using INT_CONFIG1 = Field<2, 2>;    // INT_CONFIG1
            using INT_CONFIG2 = Field<4, 2>;    // INT_CONFIG2
            using INT_CONFIG3 = Field<6, 2>;    // INT_CONFIG3
            using INT_CONFIG4 = Field<8, 2>;    // INT_CONFIG4
            using INT_CONFIG5 = Field<10, 2>;    // INT_CONFIG5
            using INT_CONFIG6 = Field<12, 2>;    // INT_CONFIG6
            using INT_CONFIG7 = Field<14, 2>;    // INT_CONFIG7
            using INT_CONFIG8 = Field<16, 2>;    // INT_CONFIG8
            using INT_CONFIG9 = Field<18, 2>;    // INT_CONFIG9
            using INT_CONFIG10 = Field<20, 2>;    // INT_CONFIG10
            using INT_CONFIG11 = Field<22, 2>;    // INT_CONFIG11
            using INT_CONFIG12 = Field<24, 2>;    // INT_CONFIG12
            using INT_CONFIG13 = Field<26, 2>;    // INT_CONFIG13
            using INT_CONFIG14 = Field<28, 2>;    // INT_CONFIG14
            using INT_CONFIG15 = Field<30, 2>;    // INT_CONFIG15
        };

        // GICD interrupt configuration register 7
        struct GICD_ICFGR7 : public Register<0xa0021c1c> {
            using INT_CONFIG0 = Field<0, 2>;    // INT_CONFIG0
            using INT_CONFIG1 = Field<2, 2>;    // INT_CONFIG1
            using INT_CONFIG2 = Field<4, 2>;    // INT_CONFIG2
            using INT_CONFIG3 = Field<6, 2>;    // INT_CONFIG3
            using INT_CONFIG4 = Field<8, 2>;    // INT_CONFIG4
            using INT_CONFIG5 = Field<10, 2>;    // INT_CONFIG5
            using INT_CONFIG6 = Field<12, 2>;    // INT_CONFIG6
            using INT_CONFIG7 = Field<14, 2>;    // INT_CONFIG7
            using INT_CONFIG8 = Field<16, 2>;    // INT_CONFIG8
            using INT_CONFIG9 = Field<18, 2>;    // INT_CONFIG9
            using INT_CONFIG10 = Field<20, 2>;    // INT_CONFIG10
            using INT_CONFIG11 = Field<22, 2>;    // INT_CONFIG11
            using INT_CONFIG12 = Field<24, 2>;    // INT_CONFIG12
            using INT_CONFIG13 = Field<26, 2>;    // INT_CONFIG13
            using INT_CONFIG14 = Field<28, 2>;    // INT_CONFIG14
            using INT_CONFIG15 = Field<30, 2>;    // INT_CONFIG15
        };

        // GICD interrupt configuration register 8
        struct GICD_ICFGR8 : public Register<0xa0021c20> {
            using INT_CONFIG0 = Field<0, 2>;    // INT_CONFIG0
            using INT_CONFIG1 = Field<2, 2>;    // INT_CONFIG1
            using INT_CONFIG2 = Field<4, 2>;    // INT_CONFIG2
            using INT_CONFIG3 = Field<6, 2>;    // INT_CONFIG3
            using INT_CONFIG4 = Field<8, 2>;    // INT_CONFIG4
            using INT_CONFIG5 = Field<10, 2>;    // INT_CONFIG5
            using INT_CONFIG6 = Field<12, 2>;    // INT_CONFIG6
            using INT_CONFIG7 = Field<14, 2>;    // INT_CONFIG7
            using INT_CONFIG8 = Field<16, 2>;    // INT_CONFIG8
            using INT_CONFIG9 = Field<18, 2>;    // INT_CONFIG9
            using INT_CONFIG10 = Field<20, 2>;    // INT_CONFIG10
            using INT_CONFIG11 = Field<22, 2>;    // INT_CONFIG11
            using INT_CONFIG12 = Field<24, 2>;    // INT_CONFIG12
            using INT_CONFIG13 = Field<26, 2>;    // INT_CONFIG13
            using INT_CONFIG14 = Field<28, 2>;    // INT_CONFIG14
            using INT_CONFIG15 = Field<30, 2>;    // INT_CONFIG15
        };

        // GICD interrupt configuration register 9
        struct GICD_ICFGR9 : public Register<0xa0021c24> {
            using INT_CONFIG0 = Field<0, 2>;    // INT_CONFIG0
            using INT_CONFIG1 = Field<2, 2>;    // INT_CONFIG1
            using INT_CONFIG2 = Field<4, 2>;    // INT_CONFIG2
            using INT_CONFIG3 = Field<6, 2>;    // INT_CONFIG3
            using INT_CONFIG4 = Field<8, 2>;    // INT_CONFIG4
            using INT_CONFIG5 = Field<10, 2>;    // INT_CONFIG5
            using INT_CONFIG6 = Field<12, 2>;    // INT_CONFIG6
            using INT_CONFIG7 = Field<14, 2>;    // INT_CONFIG7
            using INT_CONFIG8 = Field<16, 2>;    // INT_CONFIG8
            using INT_CONFIG9 = Field<18, 2>;    // INT_CONFIG9
            using INT_CONFIG10 = Field<20, 2>;    // INT_CONFIG10
            using INT_CONFIG11 = Field<22, 2>;    // INT_CONFIG11
            using INT_CONFIG12 = Field<24, 2>;    // INT_CONFIG12
            using INT_CONFIG13 = Field<26, 2>;    // INT_CONFIG13
            using INT_CONFIG14 = Field<28, 2>;    // INT_CONFIG14
            using INT_CONFIG15 = Field<30, 2>;    // INT_CONFIG15
        };

        // GICD interrupt configuration register 10
        struct GICD_ICFGR10 : public Register<0xa0021c28> {
            using INT_CONFIG0 = Field<0, 2>;    // INT_CONFIG0
            using INT_CONFIG1 = Field<2, 2>;    // INT_CONFIG1
            using INT_CONFIG2 = Field<4, 2>;    // INT_CONFIG2
            using INT_CONFIG3 = Field<6, 2>;    // INT_CONFIG3
            using INT_CONFIG4 = Field<8, 2>;    // INT_CONFIG4
            using INT_CONFIG5 = Field<10, 2>;    // INT_CONFIG5
            using INT_CONFIG6 = Field<12, 2>;    // INT_CONFIG6
            using INT_CONFIG7 = Field<14, 2>;    // INT_CONFIG7
            using INT_CONFIG8 = Field<16, 2>;    // INT_CONFIG8
            using INT_CONFIG9 = Field<18, 2>;    // INT_CONFIG9
            using INT_CONFIG10 = Field<20, 2>;    // INT_CONFIG10
            using INT_CONFIG11 = Field<22, 2>;    // INT_CONFIG11
            using INT_CONFIG12 = Field<24, 2>;    // INT_CONFIG12
            using INT_CONFIG13 = Field<26, 2>;    // INT_CONFIG13
            using INT_CONFIG14 = Field<28, 2>;    // INT_CONFIG14
            using INT_CONFIG15 = Field<30, 2>;    // INT_CONFIG15
        };

        // GICD interrupt configuration register 11
        struct GICD_ICFGR11 : public Register<0xa0021c2c> {
            using INT_CONFIG0 = Field<0, 2>;    // INT_CONFIG0
            using INT_CONFIG1 = Field<2, 2>;    // INT_CONFIG1
            using INT_CONFIG2 = Field<4, 2>;    // INT_CONFIG2
            using INT_CONFIG3 = Field<6, 2>;    // INT_CONFIG3
            using INT_CONFIG4 = Field<8, 2>;    // INT_CONFIG4
            using INT_CONFIG5 = Field<10, 2>;    // INT_CONFIG5
            using INT_CONFIG6 = Field<12, 2>;    // INT_CONFIG6
            using INT_CONFIG7 = Field<14, 2>;    // INT_CONFIG7
            using INT_CONFIG8 = Field<16, 2>;    // INT_CONFIG8
            using INT_CONFIG9 = Field<18, 2>;    // INT_CONFIG9
            using INT_CONFIG10 = Field<20, 2>;    // INT_CONFIG10
            using INT_CONFIG11 = Field<22, 2>;    // INT_CONFIG11
            using INT_CONFIG12 = Field<24, 2>;    // INT_CONFIG12
            using INT_CONFIG13 = Field<26, 2>;    // INT_CONFIG13
            using INT_CONFIG14 = Field<28, 2>;    // INT_CONFIG14
            using INT_CONFIG15 = Field<30, 2>;    // INT_CONFIG15
        };

        // GICD interrupt configuration register 12
        struct GICD_ICFGR12 : public Register<0xa0021c30> {
            using INT_CONFIG0 = Field<0, 2>;    // INT_CONFIG0
            using INT_CONFIG1 = Field<2, 2>;    // INT_CONFIG1
            using INT_CONFIG2 = Field<4, 2>;    // INT_CONFIG2
            using INT_CONFIG3 = Field<6, 2>;    // INT_CONFIG3
            using INT_CONFIG4 = Field<8, 2>;    // INT_CONFIG4
            using INT_CONFIG5 = Field<10, 2>;    // INT_CONFIG5
            using INT_CONFIG6 = Field<12, 2>;    // INT_CONFIG6
            using INT_CONFIG7 = Field<14, 2>;    // INT_CONFIG7
            using INT_CONFIG8 = Field<16, 2>;    // INT_CONFIG8
            using INT_CONFIG9 = Field<18, 2>;    // INT_CONFIG9
            using INT_CONFIG10 = Field<20, 2>;    // INT_CONFIG10
            using INT_CONFIG11 = Field<22, 2>;    // INT_CONFIG11
            using INT_CONFIG12 = Field<24, 2>;    // INT_CONFIG12
            using INT_CONFIG13 = Field<26, 2>;    // INT_CONFIG13
            using INT_CONFIG14 = Field<28, 2>;    // INT_CONFIG14
            using INT_CONFIG15 = Field<30, 2>;    // INT_CONFIG15
        };

        // GICD interrupt configuration register 13
        struct GICD_ICFGR13 : public Register<0xa0021c34> {
            using INT_CONFIG0 = Field<0, 2>;    // INT_CONFIG0
            using INT_CONFIG1 = Field<2, 2>;    // INT_CONFIG1
            using INT_CONFIG2 = Field<4, 2>;    // INT_CONFIG2
            using INT_CONFIG3 = Field<6, 2>;    // INT_CONFIG3
            using INT_CONFIG4 = Field<8, 2>;    // INT_CONFIG4
            using INT_CONFIG5 = Field<10, 2>;    // INT_CONFIG5
            using INT_CONFIG6 = Field<12, 2>;    // INT_CONFIG6
            using INT_CONFIG7 = Field<14, 2>;    // INT_CONFIG7
            using INT_CONFIG8 = Field<16, 2>;    // INT_CONFIG8
            using INT_CONFIG9 = Field<18, 2>;    // INT_CONFIG9
            using INT_CONFIG10 = Field<20, 2>;    // INT_CONFIG10
            using INT_CONFIG11 = Field<22, 2>;    // INT_CONFIG11
            using INT_CONFIG12 = Field<24, 2>;    // INT_CONFIG12
            using INT_CONFIG13 = Field<26, 2>;    // INT_CONFIG13
            using INT_CONFIG14 = Field<28, 2>;    // INT_CONFIG14
            using INT_CONFIG15 = Field<30, 2>;    // INT_CONFIG15
        };

        // GICD interrupt configuration register 14
        struct GICD_ICFGR14 : public Register<0xa0021c38> {
            using INT_CONFIG0 = Field<0, 2>;    // INT_CONFIG0
            using INT_CONFIG1 = Field<2, 2>;    // INT_CONFIG1
            using INT_CONFIG2 = Field<4, 2>;    // INT_CONFIG2
            using INT_CONFIG3 = Field<6, 2>;    // INT_CONFIG3
            using INT_CONFIG4 = Field<8, 2>;    // INT_CONFIG4
            using INT_CONFIG5 = Field<10, 2>;    // INT_CONFIG5
            using INT_CONFIG6 = Field<12, 2>;    // INT_CONFIG6
            using INT_CONFIG7 = Field<14, 2>;    // INT_CONFIG7
            using INT_CONFIG8 = Field<16, 2>;    // INT_CONFIG8
            using INT_CONFIG9 = Field<18, 2>;    // INT_CONFIG9
            using INT_CONFIG10 = Field<20, 2>;    // INT_CONFIG10
            using INT_CONFIG11 = Field<22, 2>;    // INT_CONFIG11
            using INT_CONFIG12 = Field<24, 2>;    // INT_CONFIG12
            using INT_CONFIG13 = Field<26, 2>;    // INT_CONFIG13
            using INT_CONFIG14 = Field<28, 2>;    // INT_CONFIG14
            using INT_CONFIG15 = Field<30, 2>;    // INT_CONFIG15
        };

        // GICD interrupt configuration register 15
        struct GICD_ICFGR15 : public Register<0xa0021c3c> {
            using INT_CONFIG0 = Field<0, 2>;    // INT_CONFIG0
            using INT_CONFIG1 = Field<2, 2>;    // INT_CONFIG1
            using INT_CONFIG2 = Field<4, 2>;    // INT_CONFIG2
            using INT_CONFIG3 = Field<6, 2>;    // INT_CONFIG3
            using INT_CONFIG4 = Field<8, 2>;    // INT_CONFIG4
            using INT_CONFIG5 = Field<10, 2>;    // INT_CONFIG5
            using INT_CONFIG6 = Field<12, 2>;    // INT_CONFIG6
            using INT_CONFIG7 = Field<14, 2>;    // INT_CONFIG7
            using INT_CONFIG8 = Field<16, 2>;    // INT_CONFIG8
            using INT_CONFIG9 = Field<18, 2>;    // INT_CONFIG9
            using INT_CONFIG10 = Field<20, 2>;    // INT_CONFIG10
            using INT_CONFIG11 = Field<22, 2>;    // INT_CONFIG11
            using INT_CONFIG12 = Field<24, 2>;    // INT_CONFIG12
            using INT_CONFIG13 = Field<26, 2>;    // INT_CONFIG13
            using INT_CONFIG14 = Field<28, 2>;    // INT_CONFIG14
            using INT_CONFIG15 = Field<30, 2>;    // INT_CONFIG15
        };

        // GICD interrupt configuration register 16
        struct GICD_ICFGR16 : public Register<0xa0021c40> {
            using INT_CONFIG0 = Field<0, 2>;    // INT_CONFIG0
            using INT_CONFIG1 = Field<2, 2>;    // INT_CONFIG1
            using INT_CONFIG2 = Field<4, 2>;    // INT_CONFIG2
            using INT_CONFIG3 = Field<6, 2>;    // INT_CONFIG3
            using INT_CONFIG4 = Field<8, 2>;    // INT_CONFIG4
            using INT_CONFIG5 = Field<10, 2>;    // INT_CONFIG5
            using INT_CONFIG6 = Field<12, 2>;    // INT_CONFIG6
            using INT_CONFIG7 = Field<14, 2>;    // INT_CONFIG7
            using INT_CONFIG8 = Field<16, 2>;    // INT_CONFIG8
            using INT_CONFIG9 = Field<18, 2>;    // INT_CONFIG9
            using INT_CONFIG10 = Field<20, 2>;    // INT_CONFIG10
            using INT_CONFIG11 = Field<22, 2>;    // INT_CONFIG11
            using INT_CONFIG12 = Field<24, 2>;    // INT_CONFIG12
            using INT_CONFIG13 = Field<26, 2>;    // INT_CONFIG13
            using INT_CONFIG14 = Field<28, 2>;    // INT_CONFIG14
            using INT_CONFIG15 = Field<30, 2>;    // INT_CONFIG15
        };

        // GICD interrupt configuration register 17
        struct GICD_ICFGR17 : public Register<0xa0021c44> {
            using INT_CONFIG0 = Field<0, 2>;    // INT_CONFIG0
            using INT_CONFIG1 = Field<2, 2>;    // INT_CONFIG1
            using INT_CONFIG2 = Field<4, 2>;    // INT_CONFIG2
            using INT_CONFIG3 = Field<6, 2>;    // INT_CONFIG3
            using INT_CONFIG4 = Field<8, 2>;    // INT_CONFIG4
            using INT_CONFIG5 = Field<10, 2>;    // INT_CONFIG5
            using INT_CONFIG6 = Field<12, 2>;    // INT_CONFIG6
            using INT_CONFIG7 = Field<14, 2>;    // INT_CONFIG7
            using INT_CONFIG8 = Field<16, 2>;    // INT_CONFIG8
            using INT_CONFIG9 = Field<18, 2>;    // INT_CONFIG9
            using INT_CONFIG10 = Field<20, 2>;    // INT_CONFIG10
            using INT_CONFIG11 = Field<22, 2>;    // INT_CONFIG11
            using INT_CONFIG12 = Field<24, 2>;    // INT_CONFIG12
            using INT_CONFIG13 = Field<26, 2>;    // INT_CONFIG13
            using INT_CONFIG14 = Field<28, 2>;    // INT_CONFIG14
            using INT_CONFIG15 = Field<30, 2>;    // INT_CONFIG15
        };

        // GICD private peripheral interrupt status register
        struct GICD_PPISR : public RegisterReadOnly<0xa0021d00> {
            using PPI6 = Field<9, 1>;    // PPI6
            using PPI5 = Field<10, 1>;    // PPI5
            using PPI4 = Field<11, 1>;    // PPI4
            using PPI0 = Field<12, 1>;    // PPI0
            using PPI1 = Field<13, 1>;    // PPI1
            using PPI2 = Field<14, 1>;    // PPI2
            using PPI3 = Field<15, 1>;    // PPI3
        };

        // For interrupts ID = SPI number+32, from SPI [x*32+31] to SPI [x*32]
        struct GICD_SPISR1 : public RegisterReadOnly<0xa0021d08> {
            using SPISR1 = Field<0, 32>;    // SPISR1
        };

        // For interrupts ID
        struct GICD_SPISR2 : public RegisterReadOnly<0xa0021d0c> {
            using SPISR2 = Field<0, 32>;    // SPISR2
        };

        // For interrupts ID
        struct GICD_SPISR3 : public RegisterReadOnly<0xa0021d10> {
            using SPISR3 = Field<0, 32>;    // SPISR3
        };

        // For interrupts ID
        struct GICD_SPISR4 : public RegisterReadOnly<0xa0021d14> {
            using SPISR4 = Field<0, 32>;    // SPISR4
        };

        // For interrupts ID
        struct GICD_SPISR5 : public RegisterReadOnly<0xa0021d18> {
            using SPISR5 = Field<0, 32>;    // SPISR5
        };

        // For interrupts ID
        struct GICD_SPISR6 : public RegisterReadOnly<0xa0021d1c> {
            using SPISR6 = Field<0, 32>;    // SPISR6
        };

        // For interrupts ID
        struct GICD_SPISR7 : public RegisterReadOnly<0xa0021d20> {
            using SPISR7 = Field<0, 32>;    // SPISR7
        };

        // GICD software generated interrupt register
        struct GICD_SGIR : public RegisterWriteOnly<0xa0021f00> {
            using SGIINTID = Field<0, 4>;    // SGIINTID
            using NSATT = Field<15, 1>;    // NSATT
            using CPUTARGETLIST = Field<16, 2>;    // CPUTARGETLIST
            using TARGETLISTFILTER = Field<24, 2>;    // TARGETLISTFILTER
        };

        // For SGI x*4 to SGI x*4+3
        struct GICD_CPENDSGIR0 : public Register<0xa0021f10> {
            using SGI_CLEAR_PENDING0 = Field<0, 2>;    // SGI_CLEAR_PENDING0
            using SGI_CLEAR_PENDING1 = Field<8, 2>;    // SGI_CLEAR_PENDING1
            using SGI_CLEAR_PENDING2 = Field<16, 2>;    // SGI_CLEAR_PENDING2
            using SGI_CLEAR_PENDING3 = Field<24, 2>;    // SGI_CLEAR_PENDING3
        };

        // For SGI x*4 to SGI x*4+3
        struct GICD_CPENDSGIR1 : public Register<0xa0021f14> {
            using SGI_CLEAR_PENDING0 = Field<0, 2>;    // SGI_CLEAR_PENDING0
            using SGI_CLEAR_PENDING1 = Field<8, 2>;    // SGI_CLEAR_PENDING1
            using SGI_CLEAR_PENDING2 = Field<16, 2>;    // SGI_CLEAR_PENDING2
            using SGI_CLEAR_PENDING3 = Field<24, 2>;    // SGI_CLEAR_PENDING3
        };

        // For SGI x*4 to SGI x*4+3
        struct GICD_CPENDSGIR2 : public Register<0xa0021f18> {
            using SGI_CLEAR_PENDING0 = Field<0, 2>;    // SGI_CLEAR_PENDING0
            using SGI_CLEAR_PENDING1 = Field<8, 2>;    // SGI_CLEAR_PENDING1
            using SGI_CLEAR_PENDING2 = Field<16, 2>;    // SGI_CLEAR_PENDING2
            using SGI_CLEAR_PENDING3 = Field<24, 2>;    // SGI_CLEAR_PENDING3
        };

        // For SGI x*4 to SGI x*4+3
        struct GICD_CPENDSGIR3 : public Register<0xa0021f1c> {
            using SGI_CLEAR_PENDING0 = Field<0, 2>;    // SGI_CLEAR_PENDING0
            using SGI_CLEAR_PENDING1 = Field<8, 2>;    // SGI_CLEAR_PENDING1
            using SGI_CLEAR_PENDING2 = Field<16, 2>;    // SGI_CLEAR_PENDING2
            using SGI_CLEAR_PENDING3 = Field<24, 2>;    // SGI_CLEAR_PENDING3
        };

        // For SGI x*4 to SGI x*4+3
        struct GICD_SPENDSGIR0 : public Register<0xa0021f20> {
            using SGI_SET_PENDING0 = Field<0, 2>;    // SGI_SET_PENDING0
            using SGI_SET_PENDING1 = Field<8, 2>;    // SGI_SET_PENDING1
            using SGI_SET_PENDING2 = Field<16, 2>;    // SGI_SET_PENDING2
            using SGI_SET_PENDING3 = Field<24, 2>;    // SGI_SET_PENDING3
        };

        // For SGI x*4 to SGI x*4+3
        struct GICD_SPENDSGIR1 : public Register<0xa0021f24> {
            using SGI_SET_PENDING0 = Field<0, 2>;    // SGI_SET_PENDING0
            using SGI_SET_PENDING1 = Field<8, 2>;    // SGI_SET_PENDING1
            using SGI_SET_PENDING2 = Field<16, 2>;    // SGI_SET_PENDING2
            using SGI_SET_PENDING3 = Field<24, 2>;    // SGI_SET_PENDING3
        };

        // For SGI x*4 to SGI x*4+3
        struct GICD_SPENDSGIR2 : public Register<0xa0021f28> {
            using SGI_SET_PENDING0 = Field<0, 2>;    // SGI_SET_PENDING0
            using SGI_SET_PENDING1 = Field<8, 2>;    // SGI_SET_PENDING1
            using SGI_SET_PENDING2 = Field<16, 2>;    // SGI_SET_PENDING2
            using SGI_SET_PENDING3 = Field<24, 2>;    // SGI_SET_PENDING3
        };

        // For SGI x*4 to SGI x*4+3
        struct GICD_SPENDSGIR3 : public Register<0xa0021f2c> {
            using SGI_SET_PENDING0 = Field<0, 2>;    // SGI_SET_PENDING0
            using SGI_SET_PENDING1 = Field<8, 2>;    // SGI_SET_PENDING1
            using SGI_SET_PENDING2 = Field<16, 2>;    // SGI_SET_PENDING2
            using SGI_SET_PENDING3 = Field<24, 2>;    // SGI_SET_PENDING3
        };

        // GICD peripheral ID4 register
        struct GICD_PIDR4 : public RegisterReadOnly<0xa0021fd0> {
            using PIDR4 = Field<0, 32>;    // PIDR4
        };

        // GICD peripheral ID5 to ID7 register 5
        struct GICD_PIDR5 : public RegisterReadOnly<0xa0021fd4> {
            using PIDR5 = Field<0, 32>;    // PIDR5
        };

        // GICD peripheral ID5 to ID7 register 6
        struct GICD_PIDR6 : public RegisterReadOnly<0xa0021fd8> {
            using PIDR6 = Field<0, 32>;    // PIDR6
        };

        // GICD peripheral ID5 to ID7 register 7
        struct GICD_PIDR7 : public RegisterReadOnly<0xa0021fdc> {
            using PIDR7 = Field<0, 32>;    // PIDR7
        };

        // GICD peripheral ID0 register
        struct GICD_PIDR0 : public RegisterReadOnly<0xa0021fe0> {
            using PIDR0 = Field<0, 32>;    // PIDR0
        };

        // GICD peripheral ID1 register
        struct GICD_PIDR1 : public RegisterReadOnly<0xa0021fe4> {
            using PIDR1 = Field<0, 32>;    // PIDR1
        };

        // GICD peripheral ID2 register
        struct GICD_PIDR2 : public RegisterReadOnly<0xa0021fe8> {
            using PIDR2 = Field<0, 32>;    // PIDR2
        };

        // GICD peripheral ID3 register
        struct GICD_PIDR3 : public RegisterReadOnly<0xa0021fec> {
            using PIDR3 = Field<0, 32>;    // PIDR3
        };

        // GICD component ID0 register
        struct GICD_CIDR0 : public RegisterReadOnly<0xa0021ff0> {
            using CIDR0 = Field<0, 32>;    // CIDR0
        };

        // GICD component ID1 register
        struct GICD_CIDR1 : public RegisterReadOnly<0xa0021ff4> {
            using CIDR1 = Field<0, 32>;    // CIDR1
        };

        // GICD component ID2 register
        struct GICD_CIDR2 : public RegisterReadOnly<0xa0021ff8> {
            using CIDR2 = Field<0, 32>;    // CIDR2
        };

        // GICD component ID3 register
        struct GICD_CIDR3 : public RegisterReadOnly<0xa0021ffc> {
            using CIDR3 = Field<0, 32>;    // CIDR3
        };

    };

    // GICC
    struct GICC {
        // GICC control register
        struct GICC_CTLR : public Register<0xa0022000> {
            using ENABLEGRP0 = Field<0, 1>;    // ENABLEGRP0
            using ENABLEGRP1 = Field<1, 1>;    // ENABLEGRP1
            using ACKCTL = Field<2, 1>;    // ACKCTL
            using FIQEN = Field<3, 1>;    // FIQEN
            using CBPR = Field<4, 1>;    // CBPR
            using FIQBYPDISGRP0 = Field<5, 1>;    // FIQBYPDISGRP0
            using IRQBYPDISGRP0 = Field<6, 1>;    // IRQBYPDISGRP0
            using FIQBYPDISGRP1 = Field<7, 1>;    // FIQBYPDISGRP1
            using IRQBYPDISGRP1 = Field<8, 1>;    // IRQBYPDISGRP1
            using EOIMODES = Field<9, 1>;    // EOIMODES
            using EOIMODENS = Field<10, 1>;    // EOIMODENS
        };

        // GICC input priority mask register
        struct GICC_PMR : public Register<0xa0022004> {
            using PRIORITY = Field<3, 5>;    // PRIORITY
        };

        // GICC binary point register
        struct GICC_BPR : public Register<0xa0022008> {
            using BINARY_POINT = Field<0, 3>;    // BINARY_POINT
        };

        // GICC interrupt acknowledge register
        struct GICC_IAR : public RegisterReadOnly<0xa002200c> {
            using INTERRUPT_ID = Field<0, 10>;    // INTERRUPT_ID
            using CPUID = Field<10, 1>;    // CPUID
        };

        // GICC end of interrupt register
        struct GICC_EOIR : public RegisterWriteOnly<0xa0022010> {
            using EOIINTID = Field<0, 10>;    // EOIINTID
            using CPUID = Field<10, 1>;    // CPUID
        };

        // GICC running priority register
        struct GICC_RPR : public RegisterReadOnly<0xa0022014> {
            using PRIORITY = Field<3, 5>;    // PRIORITY
        };

        // GICC highest priority pending interrupt register
        struct GICC_HPPIR : public RegisterReadOnly<0xa0022018> {
            using PENDINTID = Field<0, 10>;    // PENDINTID
            using CPUID = Field<10, 1>;    // CPUID
        };

        // GICC_ABPR is an alias of the non-secure GICC_BPR. When GICC_CTLR.CBPR is set to 0, a secure access to this register is equivalent to a non-secure access to GICC_BPR.
        struct GICC_ABPR : public Register<0xa002201c> {
            using BINARY_POINT = Field<0, 3>;    // BINARY_POINT
        };

        // GICC_AIAR is an alias of the non-secure view of GICC_IAR. A secure access to this register is identical to a non-secure access to GICC_IAR.
        struct GICC_AIAR : public RegisterReadOnly<0xa0022020> {
            using INTERRUPT_ID = Field<0, 10>;    // INTERRUPT_ID
            using CPUID = Field<10, 1>;    // CPUID
        };

        // GICC_AEOIR is an alias of the Non-secure GICC_EOIR. A secure access to this register is similar to a non-secure access to GICC_EOIR, except that the GICC_CTLR.EOImodeS bit is used.
        struct GICC_AEOIR : public RegisterWriteOnly<0xa0022024> {
            using EOIINTID = Field<0, 10>;    // EOIINTID
            using CPUID = Field<10, 1>;    // CPUID
        };

        // ICC_AHPPIR is an alias of the non-secure GICC_HPPIR. A secure access to this register is equivalent to a non-secure access to GICC_HPPIR.
        struct GICC_AHPPIR : public RegisterReadOnly<0xa0022028> {
            using PENDINTID = Field<0, 10>;    // PENDINTID
            using CPUID = Field<10, 1>;    // CPUID
        };

        // GICC active priority register
        struct GICC_APR0 : public Register<0xa00220d0> {
            using APR0 = Field<0, 32>;    // APR0
        };

        // GICC non-secure active priority register
        struct GICC_NSAPR0 : public Register<0xa00220e0> {
            using NSAPR0 = Field<0, 32>;    // NSAPR0
        };

        // GICC interface identification register
        struct GICC_IIDR : public RegisterReadOnly<0xa00220fc> {
            using IMPLEMENTER = Field<0, 12>;    // IMPLEMENTER
            using REVISION = Field<12, 4>;    // REVISION
            using ARCH = Field<16, 4>;    // ARCH
            using PRODUCTID = Field<20, 12>;    // PRODUCTID
        };

        // GICC deactivate interrupt register
        struct GICC_DIR : public RegisterWriteOnly<0xa0023000> {
            using INTERRUPT_ID = Field<0, 10>;    // INTERRUPT_ID
            using CPUID = Field<10, 1>;    // CPUID
        };

    };

    // GICH
    struct GICH {
        // GICH hypervisor control register
        struct GICH_HCR : public Register<0xa0024000> {
            using EN = Field<0, 1>;    // EN
            using UIE = Field<1, 1>;    // UIE
            using LRENPIE = Field<2, 1>;    // LRENPIE
            using NPIE = Field<3, 1>;    // NPIE
            using VGRP0EIE = Field<4, 1>;    // VGRP0EIE
            using VGRP0DIE = Field<5, 1>;    // VGRP0DIE
            using VGRP1EIE = Field<6, 1>;    // VGRP1EIE
            using VGRP1DIE = Field<7, 1>;    // VGRP1DIE
            using EOICOUNT = Field<27, 5>;    // EOICOUNT
        };

        // GICH VGIC type register
        struct GICH_VTR : public RegisterReadOnly<0xa0024004> {
            using LISTREGS = Field<0, 5>;    // LISTREGS
            using PREBITS = Field<26, 3>;    // PREBITS
            using PRIBITS = Field<29, 3>;    // PRIBITS
        };

        // GICH virtual machine control register
        struct GICH_VMCR : public Register<0xa0024008> {
            using VMGRP0EN = Field<0, 1>;    // VMGRP0EN
            using VMGRP1EN = Field<1, 1>;    // VMGRP1EN
            using VMACKCTL = Field<2, 1>;    // VMACKCTL
            using VMFIQEN = Field<3, 1>;    // VMFIQEN
            using VMCBPR = Field<4, 1>;    // VMCBPR
            using VEM = Field<9, 1>;    // VEM
            using VMABP = Field<18, 3>;    // VMABP
            using VMBP = Field<21, 3>;    // VMBP
            using VMPRIMASK = Field<27, 5>;    // VMPRIMASK
        };

        // GICH maintenance interrupt status register
        struct GICH_MISR : public RegisterReadOnly<0xa0024010> {
            using EOI = Field<0, 1>;    // EOI
            using U = Field<1, 1>;    // U
            using LRENP = Field<2, 1>;    // LRENP
            using NP = Field<3, 1>;    // NP
            using VGRP0E = Field<4, 1>;    // VGRP0E
            using VGRP0D = Field<5, 1>;    // VGRP0D
            using VGRP1E = Field<6, 1>;    // VGRP1E
            using VGRP1D = Field<7, 1>;    // VGRP1D
        };

        // GICH end of interrupt status register
        struct GICH_EISR0 : public RegisterReadOnly<0xa0024020> {
            using EISR0 = Field<0, 32>;    // EISR0
        };

        // GICH empty list status register
        struct GICH_ELSR0 : public RegisterReadOnly<0xa0024030> {
            using ELSR0 = Field<0, 32>;    // ELSR0
        };

        // GICH active priority register
        struct GICH_APR0 : public Register<0xa00240f0> {
            using APR0 = Field<0, 32>;    // APR0
        };

        // GICH list register 0
        struct GICH_LR0 : public Register<0xa0024100> {
            using VIRTUALID = Field<0, 10>;    // VIRTUALID
            using PHYSICALID = Field<10, 10>;    // PHYSICALID
            using PRIORITY = Field<23, 5>;    // PRIORITY
            using STATE = Field<28, 2>;    // STATE
            using GRP1 = Field<30, 1>;    // GRP1
            using HW = Field<31, 1>;    // HW
        };

        // GICH list register 1
        struct GICH_LR1 : public Register<0xa0024104> {
            using VIRTUALID = Field<0, 10>;    // VIRTUALID
            using PHYSICALID = Field<10, 10>;    // PHYSICALID
            using PRIORITY = Field<23, 5>;    // PRIORITY
            using STATE = Field<28, 2>;    // STATE
            using GRP1 = Field<30, 1>;    // GRP1
            using HW = Field<31, 1>;    // HW
        };

        // GICH list register 2
        struct GICH_LR2 : public Register<0xa0024108> {
            using VIRTUALID = Field<0, 10>;    // VIRTUALID
            using PHYSICALID = Field<10, 10>;    // PHYSICALID
            using PRIORITY = Field<23, 5>;    // PRIORITY
            using STATE = Field<28, 2>;    // STATE
            using GRP1 = Field<30, 1>;    // GRP1
            using HW = Field<31, 1>;    // HW
        };

        // GICH list register 3
        struct GICH_LR3 : public Register<0xa002410c> {
            using VIRTUALID = Field<0, 10>;    // VIRTUALID
            using PHYSICALID = Field<10, 10>;    // PHYSICALID
            using PRIORITY = Field<23, 5>;    // PRIORITY
            using STATE = Field<28, 2>;    // STATE
            using GRP1 = Field<30, 1>;    // GRP1
            using HW = Field<31, 1>;    // HW
        };

    };

    // GICV
    struct GICV {
        // GICV virtual machine control register
        struct GICV_CTLR : public Register<0xa0026000> {
            using ENABLEGRP0 = Field<0, 1>;    // ENABLEGRP0
            using ENABLEGRP1 = Field<1, 1>;    // ENABLEGRP1
            using ACKCTL = Field<2, 1>;    // ACKCTL
            using FIQEN = Field<3, 1>;    // FIQEN
            using CBPR = Field<4, 1>;    // CBPR
            using EOIMODE = Field<9, 1>;    // EOIMODE
        };

        // GICV VM priority mask register
        struct GICV_PMR : public Register<0xa0026004> {
            using PRIORITY = Field<3, 5>;    // PRIORITY
        };

        // GICV VM binary point register
        struct GICV_BPR : public Register<0xa0026008> {
            using BINARY_POINT = Field<0, 3>;    // BINARY_POINT
        };

        // GICV VM interrupt acknowledge register
        struct GICV_IAR : public RegisterReadOnly<0xa002600c> {
            using INTERRUPT_ID = Field<0, 10>;    // INTERRUPT_ID
            using CPUID = Field<10, 1>;    // CPUID
        };

        // GICV VM end of interrupt register
        struct GICV_EOIR : public RegisterWriteOnly<0xa0026010> {
            using EOIINTID = Field<0, 10>;    // EOIINTID
            using CPUID = Field<10, 1>;    // CPUID
        };

        // GICV VM running priority register
        struct GICV_RPR : public RegisterReadOnly<0xa0026014> {
            using PRIORITY = Field<3, 5>;    // PRIORITY
        };

        // GICV VM highest priority pending interrupt register
        struct GICV_HPPIR : public RegisterReadOnly<0xa0026018> {
            using PENDINTID = Field<0, 10>;    // PENDINTID
            using CPUID = Field<10, 1>;    // CPUID
        };

        // GICV VM aliased binary point register
        struct GICV_ABPR : public Register<0xa002601c> {
            using BINARY_POINT = Field<0, 3>;    // BINARY_POINT
        };

        // GICV VM aliased interrupt register
        struct GICV_AIAR : public RegisterReadOnly<0xa0026020> {
            using INTERRUPT_ID = Field<0, 10>;    // INTERRUPT_ID
            using CPUID = Field<10, 1>;    // CPUID
        };

        // GICV VM aliased end of interrupt register
        struct GICV_AEOIR : public RegisterWriteOnly<0xa0026024> {
            using EOIINTID = Field<0, 10>;    // EOIINTID
            using CPUID = Field<10, 1>;    // CPUID
        };

        // GICV VM aliased highest priority pending interrupt register
        struct GICV_AHPPIR : public RegisterReadOnly<0xa0026028> {
            using PENDINTID = Field<0, 10>;    // PENDINTID
            using CPUID = Field<10, 1>;    // CPUID
        };

        // The GICV_APR0 is an alias of GICH_APR.
        struct GICV_APR0 : public Register<0xa00260d0> {
            using APR0 = Field<0, 32>;    // APR0
        };

        // The GICV_IIDR is an alias of GICC_IIDR.
        struct GICV_IIDR : public RegisterReadOnly<0xa00260fc> {
            using IIDR = Field<0, 32>;    // IIDR
        };

        // GICV VM deactivate interrupt register
        struct GICV_DIR : public RegisterWriteOnly<0xa0027000> {
            using INTERRUPT_ID = Field<0, 10>;    // INTERRUPT_ID
            using CPUID = Field<10, 1>;    // CPUID
        };

    };

    // TIM1
    struct TIM1 {
        // TIM1 control register 1
        struct TIM1_CR1 : public Register<0x44000000> {
            using CEN = Field<0, 1>;    // CEN
            using UDIS = Field<1, 1>;    // UDIS
            using URS = Field<2, 1>;    // URS
            using OPM = Field<3, 1>;    // OPM
            using DIR = Field<4, 1>;    // DIR
            using CMS = Field<5, 2>;    // CMS
            using ARPE = Field<7, 1>;    // ARPE
            using CKD = Field<8, 2>;    // CKD
            using UIFREMAP = Field<11, 1>;    // UIFREMAP
        };

        // TIM1 control register 2
        struct TIM1_CR2 : public Register<0x44000004> {
            using CCPC = Field<0, 1>;    // CCPC
            using CCUS = Field<2, 1>;    // CCUS
            using CCDS = Field<3, 1>;    // CCDS
            using MMS = Field<4, 3>;    // MMS
            using TI1S = Field<7, 1>;    // TI1S
            using OIS1 = Field<8, 1>;    // OIS1
            using OIS1N = Field<9, 1>;    // OIS1N
            using OIS2 = Field<10, 1>;    // OIS2
            using OIS2N = Field<11, 1>;    // OIS2N
            using OIS3 = Field<12, 1>;    // OIS3
            using OIS3N = Field<13, 1>;    // OIS3N
            using OIS4 = Field<14, 1>;    // OIS4
            using OIS5 = Field<16, 1>;    // OIS5
            using OIS6 = Field<18, 1>;    // OIS6
            using MMS2 = Field<20, 4>;    // MMS2
        };

        // TIM1 slave mode control register
        struct TIM1_SMCR : public Register<0x44000008> {
            using SMS = Field<0, 3>;    // SMS
            using TS = Field<4, 3>;    // TS
            using MSM = Field<7, 1>;    // MSM
            using ETF = Field<8, 4>;    // ETF
            using ETPS = Field<12, 2>;    // ETPS
            using ECE = Field<14, 1>;    // ECE
            using ETP = Field<15, 1>;    // ETP
            using SMS3 = Field<16, 1>;    // SMS3
            using TS3 = Field<20, 1>;    // TS3
            using TS4 = Field<21, 1>;    // TS4
        };

        // TIM1 DMA/interrupt enable register
        struct TIM1_DIER : public Register<0x4400000c> {
            using UIE = Field<0, 1>;    // UIE
            using CC1IE = Field<1, 1>;    // CC1IE
            using CC2IE = Field<2, 1>;    // CC2IE
            using CC3IE = Field<3, 1>;    // CC3IE
            using CC4IE = Field<4, 1>;    // CC4IE
            using COMIE = Field<5, 1>;    // COMIE
            using TIE = Field<6, 1>;    // TIE
            using BIE = Field<7, 1>;    // BIE
            using UDE = Field<8, 1>;    // UDE
            using CC1DE = Field<9, 1>;    // CC1DE
            using CC2DE = Field<10, 1>;    // CC2DE
            using CC3DE = Field<11, 1>;    // CC3DE
            using CC4DE = Field<12, 1>;    // CC4DE
            using COMDE = Field<13, 1>;    // COMDE
            using TDE = Field<14, 1>;    // TDE
        };

        // TIM1 status register
        struct TIM1_SR : public Register<0x44000010> {
            using UIF = Field<0, 1>;    // UIF
            using CC1IF = Field<1, 1>;    // CC1IF
            using CC2IF = Field<2, 1>;    // CC2IF
            using CC3IF = Field<3, 1>;    // CC3IF
            using CC4IF = Field<4, 1>;    // CC4IF
            using COMIF = Field<5, 1>;    // COMIF
            using TIF = Field<6, 1>;    // TIF
            using BIF = Field<7, 1>;    // BIF
            using B2IF = Field<8, 1>;    // B2IF
            using CC1OF = Field<9, 1>;    // CC1OF
            using CC2OF = Field<10, 1>;    // CC2OF
            using CC3OF = Field<11, 1>;    // CC3OF
            using CC4OF = Field<12, 1>;    // CC4OF
            using SBIF = Field<13, 1>;    // SBIF
            using CC5IF = Field<16, 1>;    // CC5IF
            using CC6IF = Field<17, 1>;    // CC6IF
        };

        // TIM1 event generation register
        struct TIM1_EGR : public RegisterWriteOnly<0x44000014> {
            using UG = Field<0, 1>;    // UG
            using CC1G = Field<1, 1>;    // CC1G
            using CC2G = Field<2, 1>;    // CC2G
            using CC3G = Field<3, 1>;    // CC3G
            using CC4G = Field<4, 1>;    // CC4G
            using COMG = Field<5, 1>;    // COMG
            using TG = Field<6, 1>;    // TG
            using BG = Field<7, 1>;    // BG
            using B2G = Field<8, 1>;    // B2G
        };

        // The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
        struct TIM1_CCMR1ALTERNATE1 : public Register<0x44000018> {
            using CC1S = Field<0, 2>;    // CC1S
            using IC1PSC = Field<2, 2>;    // IC1PSC
            using IC1F = Field<4, 4>;    // IC1F
            using CC2S = Field<8, 2>;    // CC2S
            using IC2PSC = Field<10, 2>;    // IC2PSC
            using IC2F = Field<12, 4>;    // IC2F
        };

        // The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
        struct TIM1_CCMR2ALTERNATE17 : public Register<0x4400001c> {
            using CC3S = Field<0, 2>;    // CC3S
            using IC3PSC = Field<2, 2>;    // IC3PSC
            using IC3F = Field<4, 4>;    // IC3F
            using CC4S = Field<8, 2>;    // CC4S
            using IC4PSC = Field<10, 2>;    // IC4PSC
            using IC4F = Field<12, 4>;    // IC4F
        };

        // TIM1 capture/compare enable register
        struct TIM1_CCER : public Register<0x44000020> {
            using CC1E = Field<0, 1>;    // CC1E
            using CC1P = Field<1, 1>;    // CC1P
            using CC1NE = Field<2, 1>;    // CC1NE
            using CC1NP = Field<3, 1>;    // CC1NP
            using CC2E = Field<4, 1>;    // CC2E
            using CC2P = Field<5, 1>;    // CC2P
            using CC2NE = Field<6, 1>;    // CC2NE
            using CC2NP = Field<7, 1>;    // CC2NP
            using CC3E = Field<8, 1>;    // CC3E
            using CC3P = Field<9, 1>;    // CC3P
            using CC3NE = Field<10, 1>;    // CC3NE
            using CC3NP = Field<11, 1>;    // CC3NP
            using CC4E = Field<12, 1>;    // CC4E
            using CC4P = Field<13, 1>;    // CC4P
            using CC4NP = Field<15, 1>;    // CC4NP
            using CC5E = Field<16, 1>;    // CC5E
            using CC5P = Field<17, 1>;    // CC5P
            using CC6E = Field<20, 1>;    // CC6E
            using CC6P = Field<21, 1>;    // CC6P
        };

        // TIM1 counter
        struct TIM1_CNT : public Register<0x44000024> {
            using CNT = Field<0, 16>;    // CNT
            using UIFCPY = Field<31, 1>;    // UIFCPY
        };

        // TIM1 prescaler
        struct TIM1_PSC : public Register<0x44000028> {
            using PSC = Field<0, 16>;    // PSC
        };

        // TIM1 auto-reload register
        struct TIM1_ARR : public Register<0x4400002c> {
            using ARR = Field<0, 16>;    // ARR
        };

        // TIM1 repetition counter register
        struct TIM1_RCR : public Register<0x44000030> {
            using REP = Field<0, 16>;    // REP
        };

        // TIM1 capture/compare register 1
        struct TIM1_CCR1 : public Register<0x44000034> {
            using CCR1 = Field<0, 16>;    // CCR1
        };

        // TIM1 capture/compare register 2
        struct TIM1_CCR2 : public Register<0x44000038> {
            using CCR2 = Field<0, 16>;    // CCR2
        };

        // TIM1 capture/compare register 3
        struct TIM1_CCR3 : public Register<0x4400003c> {
            using CCR3 = Field<0, 16>;    // CCR3
        };

        // TIM1 capture/compare register 4
        struct TIM1_CCR4 : public Register<0x44000040> {
            using CCR4 = Field<0, 16>;    // CCR4
        };

        // As the bits BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] can be write-locked depending on the LOCK configuration, it can be necessary to configure all of them during the first write access to the TIMx_BDTR register.
        struct TIM1_BDTR : public Register<0x44000044> {
            using DTG = Field<0, 8>;    // DTG
            using LOCK = Field<8, 2>;    // LOCK
            using OSSI = Field<10, 1>;    // OSSI
            using OSSR = Field<11, 1>;    // OSSR
            using BKE = Field<12, 1>;    // BKE
            using BKP = Field<13, 1>;    // BKP
            using AOE = Field<14, 1>;    // AOE
            using MOE = Field<15, 1>;    // MOE
            using BKF = Field<16, 4>;    // BKF
            using BK2F = Field<20, 4>;    // BK2F
            using BK2E = Field<24, 1>;    // BK2E
            using BK2P = Field<25, 1>;    // BK2P
            using BKDSRM = Field<26, 1>;    // BKDSRM
            using BK2DSRM = Field<27, 1>;    // BK2DSRM
            using BKBID = Field<28, 1>;    // BKBID
            using BK2BID = Field<29, 1>;    // BK2BID
        };

        // TIM1 DMA control register
        struct TIM1_DCR : public Register<0x44000048> {
            using DBA = Field<0, 5>;    // DBA
            using DBL = Field<8, 5>;    // DBL
        };

        // TIM1 DMA address for full transfer
        struct TIM1_DMAR : public Register<0x4400004c> {
            using DMAB = Field<0, 32>;    // DMAB
        };

        // The channels 5 and 6 can only be configured in output. Output compare mode:
        struct TIM1_CCMR3 : public Register<0x44000054> {
            using OC5FE = Field<2, 1>;    // OC5FE
            using OC5PE = Field<3, 1>;    // OC5PE
            using OC5M = Field<4, 3>;    // OC5M
            using OC5CE = Field<7, 1>;    // OC5CE
            using OC6FE = Field<10, 1>;    // OC6FE
            using OC6PE = Field<11, 1>;    // OC6PE
            using OC6M = Field<12, 3>;    // OC6M
            using OC6CE = Field<15, 1>;    // OC6CE
            using OC5M3 = Field<16, 1>;    // OC5M3
            using OC6M3 = Field<24, 1>;    // OC6M3
        };

        // TIM1 capture/compare register 5
        struct TIM1_CCR5 : public Register<0x44000058> {
            using CCR5 = Field<0, 16>;    // CCR5
            using GC5C1 = Field<29, 1>;    // GC5C1
            using GC5C2 = Field<30, 1>;    // GC5C2
            using GC5C3 = Field<31, 1>;    // GC5C3
        };

        // TIM1 capture/compare register 6
        struct TIM1_CCR6 : public Register<0x4400005c> {
            using CCR6 = Field<0, 16>;    // CCR6
        };

        // TIM1 alternate function option register 1
        struct TIM1_AF1 : public Register<0x44000060> {
            using BKINE = Field<0, 1>;    // BKINE
            using BKDF1BK0E = Field<8, 1>;    // BKDF1BK0E
            using BKINP = Field<9, 1>;    // BKINP
            using ETRSEL = Field<14, 4>;    // ETRSEL
        };

        // TIM1 Alternate function register 2
        struct TIM1_AF2 : public Register<0x44000064> {
            using BK2INE = Field<0, 1>;    // BK2INE
            using BK2DF1BK1E = Field<8, 1>;    // BK2DF1BK1E
            using BK2INP = Field<9, 1>;    // BK2INP
        };

        // TIM1 timer input selection register
        struct TIM1_TISEL : public Register<0x44000068> {
            using TI1SEL = Field<0, 4>;    // TI1SEL
            using TI2SEL = Field<8, 4>;    // TI2SEL
            using TI3SEL = Field<16, 4>;    // TI3SEL
            using TI4SEL = Field<24, 4>;    // TI4SEL
        };

    };

    // TIM2
    struct TIM2 {
        // TIM2 control register 1
        struct TIM2_CR1 : public Register<0x40000000> {
            using CEN = Field<0, 1>;    // CEN
            using UDIS = Field<1, 1>;    // UDIS
            using URS = Field<2, 1>;    // URS
            using OPM = Field<3, 1>;    // OPM
            using DIR = Field<4, 1>;    // DIR
            using CMS = Field<5, 2>;    // CMS
            using ARPE = Field<7, 1>;    // ARPE
            using CKD = Field<8, 2>;    // CKD
            using UIFREMAP = Field<11, 1>;    // UIFREMAP
        };

        // TIM2 control register 2
        struct TIM2_CR2 : public Register<0x40000004> {
            using CCPC = Field<0, 1>;    // CCPC
            using CCUS = Field<2, 1>;    // CCUS
            using CCDS = Field<3, 1>;    // CCDS
            using MMS = Field<4, 3>;    // MMS
            using TI1S = Field<7, 1>;    // TI1S
            using OIS1 = Field<8, 1>;    // OIS1
            using OIS1N = Field<9, 1>;    // OIS1N
            using OIS2 = Field<10, 1>;    // OIS2
            using OIS2N = Field<11, 1>;    // OIS2N
            using OIS3 = Field<12, 1>;    // OIS3
            using OIS3N = Field<13, 1>;    // OIS3N
            using OIS4 = Field<14, 1>;    // OIS4
            using OIS5 = Field<16, 1>;    // OIS5
            using OIS6 = Field<18, 1>;    // OIS6
            using MMS2 = Field<20, 4>;    // MMS2
        };

        // TIM2 slave mode control register
        struct TIM2_SMCR : public Register<0x40000008> {
            using SMS = Field<0, 3>;    // SMS
            using TS = Field<4, 3>;    // TS
            using MSM = Field<7, 1>;    // MSM
            using ETF = Field<8, 4>;    // ETF
            using ETPS = Field<12, 2>;    // ETPS
            using ECE = Field<14, 1>;    // ECE
            using ETP = Field<15, 1>;    // ETP
            using SMS3 = Field<16, 1>;    // SMS3
            using TS3 = Field<20, 1>;    // TS3
            using TS4 = Field<21, 1>;    // TS4
        };

        // TIM2 DMA/interrupt enable register
        struct TIM2_DIER : public Register<0x4000000c> {
            using UIE = Field<0, 1>;    // UIE
            using CC1IE = Field<1, 1>;    // CC1IE
            using CC2IE = Field<2, 1>;    // CC2IE
            using CC3IE = Field<3, 1>;    // CC3IE
            using CC4IE = Field<4, 1>;    // CC4IE
            using COMIE = Field<5, 1>;    // COMIE
            using TIE = Field<6, 1>;    // TIE
            using BIE = Field<7, 1>;    // BIE
            using UDE = Field<8, 1>;    // UDE
            using CC1DE = Field<9, 1>;    // CC1DE
            using CC2DE = Field<10, 1>;    // CC2DE
            using CC3DE = Field<11, 1>;    // CC3DE
            using CC4DE = Field<12, 1>;    // CC4DE
            using COMDE = Field<13, 1>;    // COMDE
            using TDE = Field<14, 1>;    // TDE
        };

        // TIM2 status register
        struct TIM2_SR : public Register<0x40000010> {
            using UIF = Field<0, 1>;    // UIF
            using CC1IF = Field<1, 1>;    // CC1IF
            using CC2IF = Field<2, 1>;    // CC2IF
            using CC3IF = Field<3, 1>;    // CC3IF
            using CC4IF = Field<4, 1>;    // CC4IF
            using COMIF = Field<5, 1>;    // COMIF
            using TIF = Field<6, 1>;    // TIF
            using BIF = Field<7, 1>;    // BIF
            using B2IF = Field<8, 1>;    // B2IF
            using CC1OF = Field<9, 1>;    // CC1OF
            using CC2OF = Field<10, 1>;    // CC2OF
            using CC3OF = Field<11, 1>;    // CC3OF
            using CC4OF = Field<12, 1>;    // CC4OF
            using SBIF = Field<13, 1>;    // SBIF
            using CC5IF = Field<16, 1>;    // CC5IF
            using CC6IF = Field<17, 1>;    // CC6IF
        };

        // TIM2 event generation register
        struct TIM2_EGR : public RegisterWriteOnly<0x40000014> {
            using UG = Field<0, 1>;    // UG
            using CC1G = Field<1, 1>;    // CC1G
            using CC2G = Field<2, 1>;    // CC2G
            using CC3G = Field<3, 1>;    // CC3G
            using CC4G = Field<4, 1>;    // CC4G
            using COMG = Field<5, 1>;    // COMG
            using TG = Field<6, 1>;    // TG
            using BG = Field<7, 1>;    // BG
            using B2G = Field<8, 1>;    // B2G
        };

        // The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
        struct TIM2_CCMR1ALTERNATE2 : public Register<0x40000018> {
            using CC1S = Field<0, 2>;    // CC1S
            using IC1PSC = Field<2, 2>;    // IC1PSC
            using IC1F = Field<4, 4>;    // IC1F
            using CC2S = Field<8, 2>;    // CC2S
            using IC2PSC = Field<10, 2>;    // IC2PSC
            using IC2F = Field<12, 4>;    // IC2F
        };

        // The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
        struct TIM2_CCMR2ALTERNATE18 : public Register<0x4000001c> {
            using CC3S = Field<0, 2>;    // CC3S
            using IC3PSC = Field<2, 2>;    // IC3PSC
            using IC3F = Field<4, 4>;    // IC3F
            using CC4S = Field<8, 2>;    // CC4S
            using IC4PSC = Field<10, 2>;    // IC4PSC
            using IC4F = Field<12, 4>;    // IC4F
        };

        // TIM2 capture/compare enable register
        struct TIM2_CCER : public Register<0x40000020> {
            using CC1E = Field<0, 1>;    // CC1E
            using CC1P = Field<1, 1>;    // CC1P
            using CC1NE = Field<2, 1>;    // CC1NE
            using CC1NP = Field<3, 1>;    // CC1NP
            using CC2E = Field<4, 1>;    // CC2E
            using CC2P = Field<5, 1>;    // CC2P
            using CC2NE = Field<6, 1>;    // CC2NE
            using CC2NP = Field<7, 1>;    // CC2NP
            using CC3E = Field<8, 1>;    // CC3E
            using CC3P = Field<9, 1>;    // CC3P
            using CC3NE = Field<10, 1>;    // CC3NE
            using CC3NP = Field<11, 1>;    // CC3NP
            using CC4E = Field<12, 1>;    // CC4E
            using CC4P = Field<13, 1>;    // CC4P
            using CC4NP = Field<15, 1>;    // CC4NP
            using CC5E = Field<16, 1>;    // CC5E
            using CC5P = Field<17, 1>;    // CC5P
            using CC6E = Field<20, 1>;    // CC6E
            using CC6P = Field<21, 1>;    // CC6P
        };

        // TIM2 counter
        struct TIM2_CNT : public Register<0x40000024> {
            using CNT = Field<0, 16>;    // CNT
            using UIFCPY = Field<31, 1>;    // UIFCPY
        };

        // TIM2 prescaler
        struct TIM2_PSC : public Register<0x40000028> {
            using PSC = Field<0, 16>;    // PSC
        };

        // TIM2 auto-reload register
        struct TIM2_ARR : public Register<0x4000002c> {
            using ARR = Field<0, 16>;    // ARR
        };

        // TIM2 repetition counter register
        struct TIM2_RCR : public Register<0x40000030> {
            using REP = Field<0, 16>;    // REP
        };

        // TIM2 capture/compare register 1
        struct TIM2_CCR1 : public Register<0x40000034> {
            using CCR1 = Field<0, 16>;    // CCR1
        };

        // TIM2 capture/compare register 2
        struct TIM2_CCR2 : public Register<0x40000038> {
            using CCR2 = Field<0, 16>;    // CCR2
        };

        // TIM2 capture/compare register 3
        struct TIM2_CCR3 : public Register<0x4000003c> {
            using CCR3 = Field<0, 16>;    // CCR3
        };

        // TIM2 capture/compare register 4
        struct TIM2_CCR4 : public Register<0x40000040> {
            using CCR4 = Field<0, 16>;    // CCR4
        };

        // As the bits BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] can be write-locked depending on the LOCK configuration, it can be necessary to configure all of them during the first write access to the TIMx_BDTR register.
        struct TIM2_BDTR : public Register<0x40000044> {
            using DTG = Field<0, 8>;    // DTG
            using LOCK = Field<8, 2>;    // LOCK
            using OSSI = Field<10, 1>;    // OSSI
            using OSSR = Field<11, 1>;    // OSSR
            using BKE = Field<12, 1>;    // BKE
            using BKP = Field<13, 1>;    // BKP
            using AOE = Field<14, 1>;    // AOE
            using MOE = Field<15, 1>;    // MOE
            using BKF = Field<16, 4>;    // BKF
            using BK2F = Field<20, 4>;    // BK2F
            using BK2E = Field<24, 1>;    // BK2E
            using BK2P = Field<25, 1>;    // BK2P
            using BKDSRM = Field<26, 1>;    // BKDSRM
            using BK2DSRM = Field<27, 1>;    // BK2DSRM
            using BKBID = Field<28, 1>;    // BKBID
            using BK2BID = Field<29, 1>;    // BK2BID
        };

        // TIM2 DMA control register
        struct TIM2_DCR : public Register<0x40000048> {
            using DBA = Field<0, 5>;    // DBA
            using DBL = Field<8, 5>;    // DBL
        };

        // TIM2 DMA address for full transfer
        struct TIM2_DMAR : public Register<0x4000004c> {
            using DMAB = Field<0, 32>;    // DMAB
        };

        // The channels 5 and 6 can only be configured in output. Output compare mode:
        struct TIM2_CCMR3 : public Register<0x40000054> {
            using OC5FE = Field<2, 1>;    // OC5FE
            using OC5PE = Field<3, 1>;    // OC5PE
            using OC5M = Field<4, 3>;    // OC5M
            using OC5CE = Field<7, 1>;    // OC5CE
            using OC6FE = Field<10, 1>;    // OC6FE
            using OC6PE = Field<11, 1>;    // OC6PE
            using OC6M = Field<12, 3>;    // OC6M
            using OC6CE = Field<15, 1>;    // OC6CE
            using OC5M3 = Field<16, 1>;    // OC5M3
            using OC6M3 = Field<24, 1>;    // OC6M3
        };

        // TIM2 capture/compare register 5
        struct TIM2_CCR5 : public Register<0x40000058> {
            using CCR5 = Field<0, 16>;    // CCR5
            using GC5C1 = Field<29, 1>;    // GC5C1
            using GC5C2 = Field<30, 1>;    // GC5C2
            using GC5C3 = Field<31, 1>;    // GC5C3
        };

        // TIM2 capture/compare register 6
        struct TIM2_CCR6 : public Register<0x4000005c> {
            using CCR6 = Field<0, 16>;    // CCR6
        };

    };

    // TIM3
    struct TIM3 {
        // TIM3 control register 1
        struct TIM3_CR1 : public Register<0x40001000> {
            using CEN = Field<0, 1>;    // CEN
            using UDIS = Field<1, 1>;    // UDIS
            using URS = Field<2, 1>;    // URS
            using OPM = Field<3, 1>;    // OPM
            using DIR = Field<4, 1>;    // DIR
            using CMS = Field<5, 2>;    // CMS
            using ARPE = Field<7, 1>;    // ARPE
            using CKD = Field<8, 2>;    // CKD
            using UIFREMAP = Field<11, 1>;    // UIFREMAP
        };

        // TIM3 control register 2
        struct TIM3_CR2 : public Register<0x40001004> {
            using CCPC = Field<0, 1>;    // CCPC
            using CCUS = Field<2, 1>;    // CCUS
            using CCDS = Field<3, 1>;    // CCDS
            using MMS = Field<4, 3>;    // MMS
            using TI1S = Field<7, 1>;    // TI1S
            using OIS1 = Field<8, 1>;    // OIS1
            using OIS1N = Field<9, 1>;    // OIS1N
            using OIS2 = Field<10, 1>;    // OIS2
            using OIS2N = Field<11, 1>;    // OIS2N
            using OIS3 = Field<12, 1>;    // OIS3
            using OIS3N = Field<13, 1>;    // OIS3N
            using OIS4 = Field<14, 1>;    // OIS4
            using OIS5 = Field<16, 1>;    // OIS5
            using OIS6 = Field<18, 1>;    // OIS6
            using MMS2 = Field<20, 4>;    // MMS2
        };

        // TIM3 slave mode control register
        struct TIM3_SMCR : public Register<0x40001008> {
            using SMS = Field<0, 3>;    // SMS
            using TS = Field<4, 3>;    // TS
            using MSM = Field<7, 1>;    // MSM
            using ETF = Field<8, 4>;    // ETF
            using ETPS = Field<12, 2>;    // ETPS
            using ECE = Field<14, 1>;    // ECE
            using ETP = Field<15, 1>;    // ETP
            using SMS3 = Field<16, 1>;    // SMS3
            using TS3 = Field<20, 1>;    // TS3
            using TS4 = Field<21, 1>;    // TS4
        };

        // TIM3 DMA/interrupt enable register
        struct TIM3_DIER : public Register<0x4000100c> {
            using UIE = Field<0, 1>;    // UIE
            using CC1IE = Field<1, 1>;    // CC1IE
            using CC2IE = Field<2, 1>;    // CC2IE
            using CC3IE = Field<3, 1>;    // CC3IE
            using CC4IE = Field<4, 1>;    // CC4IE
            using COMIE = Field<5, 1>;    // COMIE
            using TIE = Field<6, 1>;    // TIE
            using BIE = Field<7, 1>;    // BIE
            using UDE = Field<8, 1>;    // UDE
            using CC1DE = Field<9, 1>;    // CC1DE
            using CC2DE = Field<10, 1>;    // CC2DE
            using CC3DE = Field<11, 1>;    // CC3DE
            using CC4DE = Field<12, 1>;    // CC4DE
            using COMDE = Field<13, 1>;    // COMDE
            using TDE = Field<14, 1>;    // TDE
        };

        // TIM3 status register
        struct TIM3_SR : public Register<0x40001010> {
            using UIF = Field<0, 1>;    // UIF
            using CC1IF = Field<1, 1>;    // CC1IF
            using CC2IF = Field<2, 1>;    // CC2IF
            using CC3IF = Field<3, 1>;    // CC3IF
            using CC4IF = Field<4, 1>;    // CC4IF
            using COMIF = Field<5, 1>;    // COMIF
            using TIF = Field<6, 1>;    // TIF
            using BIF = Field<7, 1>;    // BIF
            using B2IF = Field<8, 1>;    // B2IF
            using CC1OF = Field<9, 1>;    // CC1OF
            using CC2OF = Field<10, 1>;    // CC2OF
            using CC3OF = Field<11, 1>;    // CC3OF
            using CC4OF = Field<12, 1>;    // CC4OF
            using SBIF = Field<13, 1>;    // SBIF
            using CC5IF = Field<16, 1>;    // CC5IF
            using CC6IF = Field<17, 1>;    // CC6IF
        };

        // TIM3 event generation register
        struct TIM3_EGR : public RegisterWriteOnly<0x40001014> {
            using UG = Field<0, 1>;    // UG
            using CC1G = Field<1, 1>;    // CC1G
            using CC2G = Field<2, 1>;    // CC2G
            using CC3G = Field<3, 1>;    // CC3G
            using CC4G = Field<4, 1>;    // CC4G
            using COMG = Field<5, 1>;    // COMG
            using TG = Field<6, 1>;    // TG
            using BG = Field<7, 1>;    // BG
            using B2G = Field<8, 1>;    // B2G
        };

        // The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
        struct TIM3_CCMR1ALTERNATE3 : public Register<0x40001018> {
            using CC1S = Field<0, 2>;    // CC1S
            using IC1PSC = Field<2, 2>;    // IC1PSC
            using IC1F = Field<4, 4>;    // IC1F
            using CC2S = Field<8, 2>;    // CC2S
            using IC2PSC = Field<10, 2>;    // IC2PSC
            using IC2F = Field<12, 4>;    // IC2F
        };

        // The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
        struct TIM3_CCMR2ALTERNATE19 : public Register<0x4000101c> {
            using CC3S = Field<0, 2>;    // CC3S
            using IC3PSC = Field<2, 2>;    // IC3PSC
            using IC3F = Field<4, 4>;    // IC3F
            using CC4S = Field<8, 2>;    // CC4S
            using IC4PSC = Field<10, 2>;    // IC4PSC
            using IC4F = Field<12, 4>;    // IC4F
        };

        // TIM3 capture/compare enable register
        struct TIM3_CCER : public Register<0x40001020> {
            using CC1E = Field<0, 1>;    // CC1E
            using CC1P = Field<1, 1>;    // CC1P
            using CC1NE = Field<2, 1>;    // CC1NE
            using CC1NP = Field<3, 1>;    // CC1NP
            using CC2E = Field<4, 1>;    // CC2E
            using CC2P = Field<5, 1>;    // CC2P
            using CC2NE = Field<6, 1>;    // CC2NE
            using CC2NP = Field<7, 1>;    // CC2NP
            using CC3E = Field<8, 1>;    // CC3E
            using CC3P = Field<9, 1>;    // CC3P
            using CC3NE = Field<10, 1>;    // CC3NE
            using CC3NP = Field<11, 1>;    // CC3NP
            using CC4E = Field<12, 1>;    // CC4E
            using CC4P = Field<13, 1>;    // CC4P
            using CC4NP = Field<15, 1>;    // CC4NP
            using CC5E = Field<16, 1>;    // CC5E
            using CC5P = Field<17, 1>;    // CC5P
            using CC6E = Field<20, 1>;    // CC6E
            using CC6P = Field<21, 1>;    // CC6P
        };

        // TIM3 counter
        struct TIM3_CNT : public Register<0x40001024> {
            using CNT = Field<0, 16>;    // CNT
            using UIFCPY = Field<31, 1>;    // UIFCPY
        };

        // TIM3 prescaler
        struct TIM3_PSC : public Register<0x40001028> {
            using PSC = Field<0, 16>;    // PSC
        };

        // TIM3 auto-reload register
        struct TIM3_ARR : public Register<0x4000102c> {
            using ARR = Field<0, 16>;    // ARR
        };

        // TIM3 repetition counter register
        struct TIM3_RCR : public Register<0x40001030> {
            using REP = Field<0, 16>;    // REP
        };

        // TIM3 capture/compare register 1
        struct TIM3_CCR1 : public Register<0x40001034> {
            using CCR1 = Field<0, 16>;    // CCR1
        };

        // TIM3 capture/compare register 2
        struct TIM3_CCR2 : public Register<0x40001038> {
            using CCR2 = Field<0, 16>;    // CCR2
        };

        // TIM3 capture/compare register 3
        struct TIM3_CCR3 : public Register<0x4000103c> {
            using CCR3 = Field<0, 16>;    // CCR3
        };

        // TIM3 capture/compare register 4
        struct TIM3_CCR4 : public Register<0x40001040> {
            using CCR4 = Field<0, 16>;    // CCR4
        };

        // As the bits BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] can be write-locked depending on the LOCK configuration, it can be necessary to configure all of them during the first write access to the TIMx_BDTR register.
        struct TIM3_BDTR : public Register<0x40001044> {
            using DTG = Field<0, 8>;    // DTG
            using LOCK = Field<8, 2>;    // LOCK
            using OSSI = Field<10, 1>;    // OSSI
            using OSSR = Field<11, 1>;    // OSSR
            using BKE = Field<12, 1>;    // BKE
            using BKP = Field<13, 1>;    // BKP
            using AOE = Field<14, 1>;    // AOE
            using MOE = Field<15, 1>;    // MOE
            using BKF = Field<16, 4>;    // BKF
            using BK2F = Field<20, 4>;    // BK2F
            using BK2E = Field<24, 1>;    // BK2E
            using BK2P = Field<25, 1>;    // BK2P
            using BKDSRM = Field<26, 1>;    // BKDSRM
            using BK2DSRM = Field<27, 1>;    // BK2DSRM
            using BKBID = Field<28, 1>;    // BKBID
            using BK2BID = Field<29, 1>;    // BK2BID
        };

        // TIM3 DMA control register
        struct TIM3_DCR : public Register<0x40001048> {
            using DBA = Field<0, 5>;    // DBA
            using DBL = Field<8, 5>;    // DBL
        };

        // TIM3 DMA address for full transfer
        struct TIM3_DMAR : public Register<0x4000104c> {
            using DMAB = Field<0, 32>;    // DMAB
        };

        // The channels 5 and 6 can only be configured in output. Output compare mode:
        struct TIM3_CCMR3 : public Register<0x40001054> {
            using OC5FE = Field<2, 1>;    // OC5FE
            using OC5PE = Field<3, 1>;    // OC5PE
            using OC5M = Field<4, 3>;    // OC5M
            using OC5CE = Field<7, 1>;    // OC5CE
            using OC6FE = Field<10, 1>;    // OC6FE
            using OC6PE = Field<11, 1>;    // OC6PE
            using OC6M = Field<12, 3>;    // OC6M
            using OC6CE = Field<15, 1>;    // OC6CE
            using OC5M3 = Field<16, 1>;    // OC5M3
            using OC6M3 = Field<24, 1>;    // OC6M3
        };

        // TIM3 capture/compare register 5
        struct TIM3_CCR5 : public Register<0x40001058> {
            using CCR5 = Field<0, 16>;    // CCR5
            using GC5C1 = Field<29, 1>;    // GC5C1
            using GC5C2 = Field<30, 1>;    // GC5C2
            using GC5C3 = Field<31, 1>;    // GC5C3
        };

        // TIM3 capture/compare register 6
        struct TIM3_CCR6 : public Register<0x4000105c> {
            using CCR6 = Field<0, 16>;    // CCR6
        };

    };

    // TIM4
    struct TIM4 {
        // TIM4 control register 1
        struct TIM4_CR1 : public Register<0x40002000> {
            using CEN = Field<0, 1>;    // CEN
            using UDIS = Field<1, 1>;    // UDIS
            using URS = Field<2, 1>;    // URS
            using OPM = Field<3, 1>;    // OPM
            using DIR = Field<4, 1>;    // DIR
            using CMS = Field<5, 2>;    // CMS
            using ARPE = Field<7, 1>;    // ARPE
            using CKD = Field<8, 2>;    // CKD
            using UIFREMAP = Field<11, 1>;    // UIFREMAP
        };

        // TIM4 control register 2
        struct TIM4_CR2 : public Register<0x40002004> {
            using CCPC = Field<0, 1>;    // CCPC
            using CCUS = Field<2, 1>;    // CCUS
            using CCDS = Field<3, 1>;    // CCDS
            using MMS = Field<4, 3>;    // MMS
            using TI1S = Field<7, 1>;    // TI1S
            using OIS1 = Field<8, 1>;    // OIS1
            using OIS1N = Field<9, 1>;    // OIS1N
            using OIS2 = Field<10, 1>;    // OIS2
            using OIS2N = Field<11, 1>;    // OIS2N
            using OIS3 = Field<12, 1>;    // OIS3
            using OIS3N = Field<13, 1>;    // OIS3N
            using OIS4 = Field<14, 1>;    // OIS4
            using OIS5 = Field<16, 1>;    // OIS5
            using OIS6 = Field<18, 1>;    // OIS6
            using MMS2 = Field<20, 4>;    // MMS2
        };

        // TIM4 slave mode control register
        struct TIM4_SMCR : public Register<0x40002008> {
            using SMS = Field<0, 3>;    // SMS
            using TS = Field<4, 3>;    // TS
            using MSM = Field<7, 1>;    // MSM
            using ETF = Field<8, 4>;    // ETF
            using ETPS = Field<12, 2>;    // ETPS
            using ECE = Field<14, 1>;    // ECE
            using ETP = Field<15, 1>;    // ETP
            using SMS3 = Field<16, 1>;    // SMS3
            using TS3 = Field<20, 1>;    // TS3
            using TS4 = Field<21, 1>;    // TS4
        };

        // TIM4 DMA/interrupt enable register
        struct TIM4_DIER : public Register<0x4000200c> {
            using UIE = Field<0, 1>;    // UIE
            using CC1IE = Field<1, 1>;    // CC1IE
            using CC2IE = Field<2, 1>;    // CC2IE
            using CC3IE = Field<3, 1>;    // CC3IE
            using CC4IE = Field<4, 1>;    // CC4IE
            using COMIE = Field<5, 1>;    // COMIE
            using TIE = Field<6, 1>;    // TIE
            using BIE = Field<7, 1>;    // BIE
            using UDE = Field<8, 1>;    // UDE
            using CC1DE = Field<9, 1>;    // CC1DE
            using CC2DE = Field<10, 1>;    // CC2DE
            using CC3DE = Field<11, 1>;    // CC3DE
            using CC4DE = Field<12, 1>;    // CC4DE
            using COMDE = Field<13, 1>;    // COMDE
            using TDE = Field<14, 1>;    // TDE
        };

        // TIM4 status register
        struct TIM4_SR : public Register<0x40002010> {
            using UIF = Field<0, 1>;    // UIF
            using CC1IF = Field<1, 1>;    // CC1IF
            using CC2IF = Field<2, 1>;    // CC2IF
            using CC3IF = Field<3, 1>;    // CC3IF
            using CC4IF = Field<4, 1>;    // CC4IF
            using COMIF = Field<5, 1>;    // COMIF
            using TIF = Field<6, 1>;    // TIF
            using BIF = Field<7, 1>;    // BIF
            using B2IF = Field<8, 1>;    // B2IF
            using CC1OF = Field<9, 1>;    // CC1OF
            using CC2OF = Field<10, 1>;    // CC2OF
            using CC3OF = Field<11, 1>;    // CC3OF
            using CC4OF = Field<12, 1>;    // CC4OF
            using SBIF = Field<13, 1>;    // SBIF
            using CC5IF = Field<16, 1>;    // CC5IF
            using CC6IF = Field<17, 1>;    // CC6IF
        };

        // TIM4 event generation register
        struct TIM4_EGR : public RegisterWriteOnly<0x40002014> {
            using UG = Field<0, 1>;    // UG
            using CC1G = Field<1, 1>;    // CC1G
            using CC2G = Field<2, 1>;    // CC2G
            using CC3G = Field<3, 1>;    // CC3G
            using CC4G = Field<4, 1>;    // CC4G
            using COMG = Field<5, 1>;    // COMG
            using TG = Field<6, 1>;    // TG
            using BG = Field<7, 1>;    // BG
            using B2G = Field<8, 1>;    // B2G
        };

        // The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
        struct TIM4_CCMR1ALTERNATE4 : public Register<0x40002018> {
            using CC1S = Field<0, 2>;    // CC1S
            using IC1PSC = Field<2, 2>;    // IC1PSC
            using IC1F = Field<4, 4>;    // IC1F
            using CC2S = Field<8, 2>;    // CC2S
            using IC2PSC = Field<10, 2>;    // IC2PSC
            using IC2F = Field<12, 4>;    // IC2F
        };

        // The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
        struct TIM4_CCMR2ALTERNATE20 : public Register<0x4000201c> {
            using CC3S = Field<0, 2>;    // CC3S
            using IC3PSC = Field<2, 2>;    // IC3PSC
            using IC3F = Field<4, 4>;    // IC3F
            using CC4S = Field<8, 2>;    // CC4S
            using IC4PSC = Field<10, 2>;    // IC4PSC
            using IC4F = Field<12, 4>;    // IC4F
        };

        // TIM4 capture/compare enable register
        struct TIM4_CCER : public Register<0x40002020> {
            using CC1E = Field<0, 1>;    // CC1E
            using CC1P = Field<1, 1>;    // CC1P
            using CC1NE = Field<2, 1>;    // CC1NE
            using CC1NP = Field<3, 1>;    // CC1NP
            using CC2E = Field<4, 1>;    // CC2E
            using CC2P = Field<5, 1>;    // CC2P
            using CC2NE = Field<6, 1>;    // CC2NE
            using CC2NP = Field<7, 1>;    // CC2NP
            using CC3E = Field<8, 1>;    // CC3E
            using CC3P = Field<9, 1>;    // CC3P
            using CC3NE = Field<10, 1>;    // CC3NE
            using CC3NP = Field<11, 1>;    // CC3NP
            using CC4E = Field<12, 1>;    // CC4E
            using CC4P = Field<13, 1>;    // CC4P
            using CC4NP = Field<15, 1>;    // CC4NP
            using CC5E = Field<16, 1>;    // CC5E
            using CC5P = Field<17, 1>;    // CC5P
            using CC6E = Field<20, 1>;    // CC6E
            using CC6P = Field<21, 1>;    // CC6P
        };

        // TIM4 counter
        struct TIM4_CNT : public Register<0x40002024> {
            using CNT = Field<0, 16>;    // CNT
            using UIFCPY = Field<31, 1>;    // UIFCPY
        };

        // TIM4 prescaler
        struct TIM4_PSC : public Register<0x40002028> {
            using PSC = Field<0, 16>;    // PSC
        };

        // TIM4 auto-reload register
        struct TIM4_ARR : public Register<0x4000202c> {
            using ARR = Field<0, 16>;    // ARR
        };

        // TIM4 repetition counter register
        struct TIM4_RCR : public Register<0x40002030> {
            using REP = Field<0, 16>;    // REP
        };

        // TIM4 capture/compare register 1
        struct TIM4_CCR1 : public Register<0x40002034> {
            using CCR1 = Field<0, 16>;    // CCR1
        };

        // TIM4 capture/compare register 2
        struct TIM4_CCR2 : public Register<0x40002038> {
            using CCR2 = Field<0, 16>;    // CCR2
        };

        // TIM4 capture/compare register 3
        struct TIM4_CCR3 : public Register<0x4000203c> {
            using CCR3 = Field<0, 16>;    // CCR3
        };

        // TIM4 capture/compare register 4
        struct TIM4_CCR4 : public Register<0x40002040> {
            using CCR4 = Field<0, 16>;    // CCR4
        };

        // As the bits BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] can be write-locked depending on the LOCK configuration, it can be necessary to configure all of them during the first write access to the TIMx_BDTR register.
        struct TIM4_BDTR : public Register<0x40002044> {
            using DTG = Field<0, 8>;    // DTG
            using LOCK = Field<8, 2>;    // LOCK
            using OSSI = Field<10, 1>;    // OSSI
            using OSSR = Field<11, 1>;    // OSSR
            using BKE = Field<12, 1>;    // BKE
            using BKP = Field<13, 1>;    // BKP
            using AOE = Field<14, 1>;    // AOE
            using MOE = Field<15, 1>;    // MOE
            using BKF = Field<16, 4>;    // BKF
            using BK2F = Field<20, 4>;    // BK2F
            using BK2E = Field<24, 1>;    // BK2E
            using BK2P = Field<25, 1>;    // BK2P
            using BKDSRM = Field<26, 1>;    // BKDSRM
            using BK2DSRM = Field<27, 1>;    // BK2DSRM
            using BKBID = Field<28, 1>;    // BKBID
            using BK2BID = Field<29, 1>;    // BK2BID
        };

        // TIM4 DMA control register
        struct TIM4_DCR : public Register<0x40002048> {
            using DBA = Field<0, 5>;    // DBA
            using DBL = Field<8, 5>;    // DBL
        };

        // TIM4 DMA address for full transfer
        struct TIM4_DMAR : public Register<0x4000204c> {
            using DMAB = Field<0, 32>;    // DMAB
        };

        // The channels 5 and 6 can only be configured in output. Output compare mode:
        struct TIM4_CCMR3 : public Register<0x40002054> {
            using OC5FE = Field<2, 1>;    // OC5FE
            using OC5PE = Field<3, 1>;    // OC5PE
            using OC5M = Field<4, 3>;    // OC5M
            using OC5CE = Field<7, 1>;    // OC5CE
            using OC6FE = Field<10, 1>;    // OC6FE
            using OC6PE = Field<11, 1>;    // OC6PE
            using OC6M = Field<12, 3>;    // OC6M
            using OC6CE = Field<15, 1>;    // OC6CE
            using OC5M3 = Field<16, 1>;    // OC5M3
            using OC6M3 = Field<24, 1>;    // OC6M3
        };

        // TIM4 capture/compare register 5
        struct TIM4_CCR5 : public Register<0x40002058> {
            using CCR5 = Field<0, 16>;    // CCR5
            using GC5C1 = Field<29, 1>;    // GC5C1
            using GC5C2 = Field<30, 1>;    // GC5C2
            using GC5C3 = Field<31, 1>;    // GC5C3
        };

        // TIM4 capture/compare register 6
        struct TIM4_CCR6 : public Register<0x4000205c> {
            using CCR6 = Field<0, 16>;    // CCR6
        };

    };

    // TIM5
    struct TIM5 {
        // TIM5 control register 1
        struct TIM5_CR1 : public Register<0x40003000> {
            using CEN = Field<0, 1>;    // CEN
            using UDIS = Field<1, 1>;    // UDIS
            using URS = Field<2, 1>;    // URS
            using OPM = Field<3, 1>;    // OPM
            using DIR = Field<4, 1>;    // DIR
            using CMS = Field<5, 2>;    // CMS
            using ARPE = Field<7, 1>;    // ARPE
            using CKD = Field<8, 2>;    // CKD
            using UIFREMAP = Field<11, 1>;    // UIFREMAP
        };

        // TIM5 control register 2
        struct TIM5_CR2 : public Register<0x40003004> {
            using CCPC = Field<0, 1>;    // CCPC
            using CCUS = Field<2, 1>;    // CCUS
            using CCDS = Field<3, 1>;    // CCDS
            using MMS = Field<4, 3>;    // MMS
            using TI1S = Field<7, 1>;    // TI1S
            using OIS1 = Field<8, 1>;    // OIS1
            using OIS1N = Field<9, 1>;    // OIS1N
            using OIS2 = Field<10, 1>;    // OIS2
            using OIS2N = Field<11, 1>;    // OIS2N
            using OIS3 = Field<12, 1>;    // OIS3
            using OIS3N = Field<13, 1>;    // OIS3N
            using OIS4 = Field<14, 1>;    // OIS4
            using OIS5 = Field<16, 1>;    // OIS5
            using OIS6 = Field<18, 1>;    // OIS6
            using MMS2 = Field<20, 4>;    // MMS2
        };

        // TIM5 slave mode control register
        struct TIM5_SMCR : public Register<0x40003008> {
            using SMS = Field<0, 3>;    // SMS
            using TS = Field<4, 3>;    // TS
            using MSM = Field<7, 1>;    // MSM
            using ETF = Field<8, 4>;    // ETF
            using ETPS = Field<12, 2>;    // ETPS
            using ECE = Field<14, 1>;    // ECE
            using ETP = Field<15, 1>;    // ETP
            using SMS3 = Field<16, 1>;    // SMS3
            using TS3 = Field<20, 1>;    // TS3
            using TS4 = Field<21, 1>;    // TS4
        };

        // TIM5 DMA/interrupt enable register
        struct TIM5_DIER : public Register<0x4000300c> {
            using UIE = Field<0, 1>;    // UIE
            using CC1IE = Field<1, 1>;    // CC1IE
            using CC2IE = Field<2, 1>;    // CC2IE
            using CC3IE = Field<3, 1>;    // CC3IE
            using CC4IE = Field<4, 1>;    // CC4IE
            using COMIE = Field<5, 1>;    // COMIE
            using TIE = Field<6, 1>;    // TIE
            using BIE = Field<7, 1>;    // BIE
            using UDE = Field<8, 1>;    // UDE
            using CC1DE = Field<9, 1>;    // CC1DE
            using CC2DE = Field<10, 1>;    // CC2DE
            using CC3DE = Field<11, 1>;    // CC3DE
            using CC4DE = Field<12, 1>;    // CC4DE
            using COMDE = Field<13, 1>;    // COMDE
            using TDE = Field<14, 1>;    // TDE
        };

        // TIM5 status register
        struct TIM5_SR : public Register<0x40003010> {
            using UIF = Field<0, 1>;    // UIF
            using CC1IF = Field<1, 1>;    // CC1IF
            using CC2IF = Field<2, 1>;    // CC2IF
            using CC3IF = Field<3, 1>;    // CC3IF
            using CC4IF = Field<4, 1>;    // CC4IF
            using COMIF = Field<5, 1>;    // COMIF
            using TIF = Field<6, 1>;    // TIF
            using BIF = Field<7, 1>;    // BIF
            using B2IF = Field<8, 1>;    // B2IF
            using CC1OF = Field<9, 1>;    // CC1OF
            using CC2OF = Field<10, 1>;    // CC2OF
            using CC3OF = Field<11, 1>;    // CC3OF
            using CC4OF = Field<12, 1>;    // CC4OF
            using SBIF = Field<13, 1>;    // SBIF
            using CC5IF = Field<16, 1>;    // CC5IF
            using CC6IF = Field<17, 1>;    // CC6IF
        };

        // TIM5 event generation register
        struct TIM5_EGR : public RegisterWriteOnly<0x40003014> {
            using UG = Field<0, 1>;    // UG
            using CC1G = Field<1, 1>;    // CC1G
            using CC2G = Field<2, 1>;    // CC2G
            using CC3G = Field<3, 1>;    // CC3G
            using CC4G = Field<4, 1>;    // CC4G
            using COMG = Field<5, 1>;    // COMG
            using TG = Field<6, 1>;    // TG
            using BG = Field<7, 1>;    // BG
            using B2G = Field<8, 1>;    // B2G
        };

        // The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
        struct TIM5_CCMR1ALTERNATE5 : public Register<0x40003018> {
            using CC1S = Field<0, 2>;    // CC1S
            using IC1PSC = Field<2, 2>;    // IC1PSC
            using IC1F = Field<4, 4>;    // IC1F
            using CC2S = Field<8, 2>;    // CC2S
            using IC2PSC = Field<10, 2>;    // IC2PSC
            using IC2F = Field<12, 4>;    // IC2F
        };

        // The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
        struct TIM5_CCMR2ALTERNATE21 : public Register<0x4000301c> {
            using CC3S = Field<0, 2>;    // CC3S
            using IC3PSC = Field<2, 2>;    // IC3PSC
            using IC3F = Field<4, 4>;    // IC3F
            using CC4S = Field<8, 2>;    // CC4S
            using IC4PSC = Field<10, 2>;    // IC4PSC
            using IC4F = Field<12, 4>;    // IC4F
        };

        // TIM5 capture/compare enable register
        struct TIM5_CCER : public Register<0x40003020> {
            using CC1E = Field<0, 1>;    // CC1E
            using CC1P = Field<1, 1>;    // CC1P
            using CC1NE = Field<2, 1>;    // CC1NE
            using CC1NP = Field<3, 1>;    // CC1NP
            using CC2E = Field<4, 1>;    // CC2E
            using CC2P = Field<5, 1>;    // CC2P
            using CC2NE = Field<6, 1>;    // CC2NE
            using CC2NP = Field<7, 1>;    // CC2NP
            using CC3E = Field<8, 1>;    // CC3E
            using CC3P = Field<9, 1>;    // CC3P
            using CC3NE = Field<10, 1>;    // CC3NE
            using CC3NP = Field<11, 1>;    // CC3NP
            using CC4E = Field<12, 1>;    // CC4E
            using CC4P = Field<13, 1>;    // CC4P
            using CC4NP = Field<15, 1>;    // CC4NP
            using CC5E = Field<16, 1>;    // CC5E
            using CC5P = Field<17, 1>;    // CC5P
            using CC6E = Field<20, 1>;    // CC6E
            using CC6P = Field<21, 1>;    // CC6P
        };

        // TIM5 counter
        struct TIM5_CNT : public Register<0x40003024> {
            using CNT = Field<0, 16>;    // CNT
            using UIFCPY = Field<31, 1>;    // UIFCPY
        };

        // TIM5 prescaler
        struct TIM5_PSC : public Register<0x40003028> {
            using PSC = Field<0, 16>;    // PSC
        };

        // TIM5 auto-reload register
        struct TIM5_ARR : public Register<0x4000302c> {
            using ARR = Field<0, 16>;    // ARR
        };

        // TIM5 repetition counter register
        struct TIM5_RCR : public Register<0x40003030> {
            using REP = Field<0, 16>;    // REP
        };

        // TIM5 capture/compare register 1
        struct TIM5_CCR1 : public Register<0x40003034> {
            using CCR1 = Field<0, 16>;    // CCR1
        };

        // TIM5 capture/compare register 2
        struct TIM5_CCR2 : public Register<0x40003038> {
            using CCR2 = Field<0, 16>;    // CCR2
        };

        // TIM5 capture/compare register 3
        struct TIM5_CCR3 : public Register<0x4000303c> {
            using CCR3 = Field<0, 16>;    // CCR3
        };

        // TIM5 capture/compare register 4
        struct TIM5_CCR4 : public Register<0x40003040> {
            using CCR4 = Field<0, 16>;    // CCR4
        };

        // As the bits BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] can be write-locked depending on the LOCK configuration, it can be necessary to configure all of them during the first write access to the TIMx_BDTR register.
        struct TIM5_BDTR : public Register<0x40003044> {
            using DTG = Field<0, 8>;    // DTG
            using LOCK = Field<8, 2>;    // LOCK
            using OSSI = Field<10, 1>;    // OSSI
            using OSSR = Field<11, 1>;    // OSSR
            using BKE = Field<12, 1>;    // BKE
            using BKP = Field<13, 1>;    // BKP
            using AOE = Field<14, 1>;    // AOE
            using MOE = Field<15, 1>;    // MOE
            using BKF = Field<16, 4>;    // BKF
            using BK2F = Field<20, 4>;    // BK2F
            using BK2E = Field<24, 1>;    // BK2E
            using BK2P = Field<25, 1>;    // BK2P
            using BKDSRM = Field<26, 1>;    // BKDSRM
            using BK2DSRM = Field<27, 1>;    // BK2DSRM
            using BKBID = Field<28, 1>;    // BKBID
            using BK2BID = Field<29, 1>;    // BK2BID
        };

        // TIM5 DMA control register
        struct TIM5_DCR : public Register<0x40003048> {
            using DBA = Field<0, 5>;    // DBA
            using DBL = Field<8, 5>;    // DBL
        };

        // TIM5 DMA address for full transfer
        struct TIM5_DMAR : public Register<0x4000304c> {
            using DMAB = Field<0, 32>;    // DMAB
        };

        // The channels 5 and 6 can only be configured in output. Output compare mode:
        struct TIM5_CCMR3 : public Register<0x40003054> {
            using OC5FE = Field<2, 1>;    // OC5FE
            using OC5PE = Field<3, 1>;    // OC5PE
            using OC5M = Field<4, 3>;    // OC5M
            using OC5CE = Field<7, 1>;    // OC5CE
            using OC6FE = Field<10, 1>;    // OC6FE
            using OC6PE = Field<11, 1>;    // OC6PE
            using OC6M = Field<12, 3>;    // OC6M
            using OC6CE = Field<15, 1>;    // OC6CE
            using OC5M3 = Field<16, 1>;    // OC5M3
            using OC6M3 = Field<24, 1>;    // OC6M3
        };

        // TIM5 capture/compare register 5
        struct TIM5_CCR5 : public Register<0x40003058> {
            using CCR5 = Field<0, 16>;    // CCR5
            using GC5C1 = Field<29, 1>;    // GC5C1
            using GC5C2 = Field<30, 1>;    // GC5C2
            using GC5C3 = Field<31, 1>;    // GC5C3
        };

        // TIM5 capture/compare register 6
        struct TIM5_CCR6 : public Register<0x4000305c> {
            using CCR6 = Field<0, 16>;    // CCR6
        };

    };

    // TIM6
    struct TIM6 {
        // TIM6 control register 1
        struct TIM6_CR1 : public Register<0x40004000> {
            using CEN = Field<0, 1>;    // CEN
            using UDIS = Field<1, 1>;    // UDIS
            using URS = Field<2, 1>;    // URS
            using OPM = Field<3, 1>;    // OPM
            using DIR = Field<4, 1>;    // DIR
            using CMS = Field<5, 2>;    // CMS
            using ARPE = Field<7, 1>;    // ARPE
            using CKD = Field<8, 2>;    // CKD
            using UIFREMAP = Field<11, 1>;    // UIFREMAP
        };

        // TIM6 control register 2
        struct TIM6_CR2 : public Register<0x40004004> {
            using CCPC = Field<0, 1>;    // CCPC
            using CCUS = Field<2, 1>;    // CCUS
            using CCDS = Field<3, 1>;    // CCDS
            using MMS = Field<4, 3>;    // MMS
            using TI1S = Field<7, 1>;    // TI1S
            using OIS1 = Field<8, 1>;    // OIS1
            using OIS1N = Field<9, 1>;    // OIS1N
            using OIS2 = Field<10, 1>;    // OIS2
            using OIS2N = Field<11, 1>;    // OIS2N
            using OIS3 = Field<12, 1>;    // OIS3
            using OIS3N = Field<13, 1>;    // OIS3N
            using OIS4 = Field<14, 1>;    // OIS4
            using OIS5 = Field<16, 1>;    // OIS5
            using OIS6 = Field<18, 1>;    // OIS6
            using MMS2 = Field<20, 4>;    // MMS2
        };

        // TIM6 slave mode control register
        struct TIM6_SMCR : public Register<0x40004008> {
            using SMS = Field<0, 3>;    // SMS
            using TS = Field<4, 3>;    // TS
            using MSM = Field<7, 1>;    // MSM
            using ETF = Field<8, 4>;    // ETF
            using ETPS = Field<12, 2>;    // ETPS
            using ECE = Field<14, 1>;    // ECE
            using ETP = Field<15, 1>;    // ETP
            using SMS3 = Field<16, 1>;    // SMS3
            using TS3 = Field<20, 1>;    // TS3
            using TS4 = Field<21, 1>;    // TS4
        };

        // TIM6 DMA/interrupt enable register
        struct TIM6_DIER : public Register<0x4000400c> {
            using UIE = Field<0, 1>;    // UIE
            using CC1IE = Field<1, 1>;    // CC1IE
            using CC2IE = Field<2, 1>;    // CC2IE
            using CC3IE = Field<3, 1>;    // CC3IE
            using CC4IE = Field<4, 1>;    // CC4IE
            using COMIE = Field<5, 1>;    // COMIE
            using TIE = Field<6, 1>;    // TIE
            using BIE = Field<7, 1>;    // BIE
            using UDE = Field<8, 1>;    // UDE
            using CC1DE = Field<9, 1>;    // CC1DE
            using CC2DE = Field<10, 1>;    // CC2DE
            using CC3DE = Field<11, 1>;    // CC3DE
            using CC4DE = Field<12, 1>;    // CC4DE
            using COMDE = Field<13, 1>;    // COMDE
            using TDE = Field<14, 1>;    // TDE
        };

        // TIM6 status register
        struct TIM6_SR : public Register<0x40004010> {
            using UIF = Field<0, 1>;    // UIF
            using CC1IF = Field<1, 1>;    // CC1IF
            using CC2IF = Field<2, 1>;    // CC2IF
            using CC3IF = Field<3, 1>;    // CC3IF
            using CC4IF = Field<4, 1>;    // CC4IF
            using COMIF = Field<5, 1>;    // COMIF
            using TIF = Field<6, 1>;    // TIF
            using BIF = Field<7, 1>;    // BIF
            using B2IF = Field<8, 1>;    // B2IF
            using CC1OF = Field<9, 1>;    // CC1OF
            using CC2OF = Field<10, 1>;    // CC2OF
            using CC3OF = Field<11, 1>;    // CC3OF
            using CC4OF = Field<12, 1>;    // CC4OF
            using SBIF = Field<13, 1>;    // SBIF
            using CC5IF = Field<16, 1>;    // CC5IF
            using CC6IF = Field<17, 1>;    // CC6IF
        };

        // TIM6 event generation register
        struct TIM6_EGR : public RegisterWriteOnly<0x40004014> {
            using UG = Field<0, 1>;    // UG
            using CC1G = Field<1, 1>;    // CC1G
            using CC2G = Field<2, 1>;    // CC2G
            using CC3G = Field<3, 1>;    // CC3G
            using CC4G = Field<4, 1>;    // CC4G
            using COMG = Field<5, 1>;    // COMG
            using TG = Field<6, 1>;    // TG
            using BG = Field<7, 1>;    // BG
            using B2G = Field<8, 1>;    // B2G
        };

        // The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
        struct TIM6_CCMR1ALTERNATE6 : public Register<0x40004018> {
            using CC1S = Field<0, 2>;    // CC1S
            using IC1PSC = Field<2, 2>;    // IC1PSC
            using IC1F = Field<4, 4>;    // IC1F
            using CC2S = Field<8, 2>;    // CC2S
            using IC2PSC = Field<10, 2>;    // IC2PSC
            using IC2F = Field<12, 4>;    // IC2F
        };

        // The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
        struct TIM6_CCMR2ALTERNATE22 : public Register<0x4000401c> {
            using CC3S = Field<0, 2>;    // CC3S
            using IC3PSC = Field<2, 2>;    // IC3PSC
            using IC3F = Field<4, 4>;    // IC3F
            using CC4S = Field<8, 2>;    // CC4S
            using IC4PSC = Field<10, 2>;    // IC4PSC
            using IC4F = Field<12, 4>;    // IC4F
        };

        // TIM6 capture/compare enable register
        struct TIM6_CCER : public Register<0x40004020> {
            using CC1E = Field<0, 1>;    // CC1E
            using CC1P = Field<1, 1>;    // CC1P
            using CC1NE = Field<2, 1>;    // CC1NE
            using CC1NP = Field<3, 1>;    // CC1NP
            using CC2E = Field<4, 1>;    // CC2E
            using CC2P = Field<5, 1>;    // CC2P
            using CC2NE = Field<6, 1>;    // CC2NE
            using CC2NP = Field<7, 1>;    // CC2NP
            using CC3E = Field<8, 1>;    // CC3E
            using CC3P = Field<9, 1>;    // CC3P
            using CC3NE = Field<10, 1>;    // CC3NE
            using CC3NP = Field<11, 1>;    // CC3NP
            using CC4E = Field<12, 1>;    // CC4E
            using CC4P = Field<13, 1>;    // CC4P
            using CC4NP = Field<15, 1>;    // CC4NP
            using CC5E = Field<16, 1>;    // CC5E
            using CC5P = Field<17, 1>;    // CC5P
            using CC6E = Field<20, 1>;    // CC6E
            using CC6P = Field<21, 1>;    // CC6P
        };

        // TIM6 counter
        struct TIM6_CNT : public Register<0x40004024> {
            using CNT = Field<0, 16>;    // CNT
            using UIFCPY = Field<31, 1>;    // UIFCPY
        };

        // TIM6 prescaler
        struct TIM6_PSC : public Register<0x40004028> {
            using PSC = Field<0, 16>;    // PSC
        };

        // TIM6 auto-reload register
        struct TIM6_ARR : public Register<0x4000402c> {
            using ARR = Field<0, 16>;    // ARR
        };

        // TIM6 repetition counter register
        struct TIM6_RCR : public Register<0x40004030> {
            using REP = Field<0, 16>;    // REP
        };

        // TIM6 capture/compare register 1
        struct TIM6_CCR1 : public Register<0x40004034> {
            using CCR1 = Field<0, 16>;    // CCR1
        };

        // TIM6 capture/compare register 2
        struct TIM6_CCR2 : public Register<0x40004038> {
            using CCR2 = Field<0, 16>;    // CCR2
        };

        // TIM6 capture/compare register 3
        struct TIM6_CCR3 : public Register<0x4000403c> {
            using CCR3 = Field<0, 16>;    // CCR3
        };

        // TIM6 capture/compare register 4
        struct TIM6_CCR4 : public Register<0x40004040> {
            using CCR4 = Field<0, 16>;    // CCR4
        };

        // As the bits BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] can be write-locked depending on the LOCK configuration, it can be necessary to configure all of them during the first write access to the TIMx_BDTR register.
        struct TIM6_BDTR : public Register<0x40004044> {
            using DTG = Field<0, 8>;    // DTG
            using LOCK = Field<8, 2>;    // LOCK
            using OSSI = Field<10, 1>;    // OSSI
            using OSSR = Field<11, 1>;    // OSSR
            using BKE = Field<12, 1>;    // BKE
            using BKP = Field<13, 1>;    // BKP
            using AOE = Field<14, 1>;    // AOE
            using MOE = Field<15, 1>;    // MOE
            using BKF = Field<16, 4>;    // BKF
            using BK2F = Field<20, 4>;    // BK2F
            using BK2E = Field<24, 1>;    // BK2E
            using BK2P = Field<25, 1>;    // BK2P
            using BKDSRM = Field<26, 1>;    // BKDSRM
            using BK2DSRM = Field<27, 1>;    // BK2DSRM
            using BKBID = Field<28, 1>;    // BKBID
            using BK2BID = Field<29, 1>;    // BK2BID
        };

        // TIM6 DMA control register
        struct TIM6_DCR : public Register<0x40004048> {
            using DBA = Field<0, 5>;    // DBA
            using DBL = Field<8, 5>;    // DBL
        };

        // TIM6 DMA address for full transfer
        struct TIM6_DMAR : public Register<0x4000404c> {
            using DMAB = Field<0, 32>;    // DMAB
        };

        // The channels 5 and 6 can only be configured in output. Output compare mode:
        struct TIM6_CCMR3 : public Register<0x40004054> {
            using OC5FE = Field<2, 1>;    // OC5FE
            using OC5PE = Field<3, 1>;    // OC5PE
            using OC5M = Field<4, 3>;    // OC5M
            using OC5CE = Field<7, 1>;    // OC5CE
            using OC6FE = Field<10, 1>;    // OC6FE
            using OC6PE = Field<11, 1>;    // OC6PE
            using OC6M = Field<12, 3>;    // OC6M
            using OC6CE = Field<15, 1>;    // OC6CE
            using OC5M3 = Field<16, 1>;    // OC5M3
            using OC6M3 = Field<24, 1>;    // OC6M3
        };

        // TIM6 capture/compare register 5
        struct TIM6_CCR5 : public Register<0x40004058> {
            using CCR5 = Field<0, 16>;    // CCR5
            using GC5C1 = Field<29, 1>;    // GC5C1
            using GC5C2 = Field<30, 1>;    // GC5C2
            using GC5C3 = Field<31, 1>;    // GC5C3
        };

        // TIM6 capture/compare register 6
        struct TIM6_CCR6 : public Register<0x4000405c> {
            using CCR6 = Field<0, 16>;    // CCR6
        };

    };

    // TIM7
    struct TIM7 {
        // TIM7 control register 1
        struct TIM7_CR1 : public Register<0x40005000> {
            using CEN = Field<0, 1>;    // CEN
            using UDIS = Field<1, 1>;    // UDIS
            using URS = Field<2, 1>;    // URS
            using OPM = Field<3, 1>;    // OPM
            using DIR = Field<4, 1>;    // DIR
            using CMS = Field<5, 2>;    // CMS
            using ARPE = Field<7, 1>;    // ARPE
            using CKD = Field<8, 2>;    // CKD
            using UIFREMAP = Field<11, 1>;    // UIFREMAP
        };

        // TIM7 control register 2
        struct TIM7_CR2 : public Register<0x40005004> {
            using CCPC = Field<0, 1>;    // CCPC
            using CCUS = Field<2, 1>;    // CCUS
            using CCDS = Field<3, 1>;    // CCDS
            using MMS = Field<4, 3>;    // MMS
            using TI1S = Field<7, 1>;    // TI1S
            using OIS1 = Field<8, 1>;    // OIS1
            using OIS1N = Field<9, 1>;    // OIS1N
            using OIS2 = Field<10, 1>;    // OIS2
            using OIS2N = Field<11, 1>;    // OIS2N
            using OIS3 = Field<12, 1>;    // OIS3
            using OIS3N = Field<13, 1>;    // OIS3N
            using OIS4 = Field<14, 1>;    // OIS4
            using OIS5 = Field<16, 1>;    // OIS5
            using OIS6 = Field<18, 1>;    // OIS6
            using MMS2 = Field<20, 4>;    // MMS2
        };

        // TIM7 slave mode control register
        struct TIM7_SMCR : public Register<0x40005008> {
            using SMS = Field<0, 3>;    // SMS
            using TS = Field<4, 3>;    // TS
            using MSM = Field<7, 1>;    // MSM
            using ETF = Field<8, 4>;    // ETF
            using ETPS = Field<12, 2>;    // ETPS
            using ECE = Field<14, 1>;    // ECE
            using ETP = Field<15, 1>;    // ETP
            using SMS3 = Field<16, 1>;    // SMS3
            using TS3 = Field<20, 1>;    // TS3
            using TS4 = Field<21, 1>;    // TS4
        };

        // TIM7 DMA/interrupt enable register
        struct TIM7_DIER : public Register<0x4000500c> {
            using UIE = Field<0, 1>;    // UIE
            using CC1IE = Field<1, 1>;    // CC1IE
            using CC2IE = Field<2, 1>;    // CC2IE
            using CC3IE = Field<3, 1>;    // CC3IE
            using CC4IE = Field<4, 1>;    // CC4IE
            using COMIE = Field<5, 1>;    // COMIE
            using TIE = Field<6, 1>;    // TIE
            using BIE = Field<7, 1>;    // BIE
            using UDE = Field<8, 1>;    // UDE
            using CC1DE = Field<9, 1>;    // CC1DE
            using CC2DE = Field<10, 1>;    // CC2DE
            using CC3DE = Field<11, 1>;    // CC3DE
            using CC4DE = Field<12, 1>;    // CC4DE
            using COMDE = Field<13, 1>;    // COMDE
            using TDE = Field<14, 1>;    // TDE
        };

        // TIM7 status register
        struct TIM7_SR : public Register<0x40005010> {
            using UIF = Field<0, 1>;    // UIF
            using CC1IF = Field<1, 1>;    // CC1IF
            using CC2IF = Field<2, 1>;    // CC2IF
            using CC3IF = Field<3, 1>;    // CC3IF
            using CC4IF = Field<4, 1>;    // CC4IF
            using COMIF = Field<5, 1>;    // COMIF
            using TIF = Field<6, 1>;    // TIF
            using BIF = Field<7, 1>;    // BIF
            using B2IF = Field<8, 1>;    // B2IF
            using CC1OF = Field<9, 1>;    // CC1OF
            using CC2OF = Field<10, 1>;    // CC2OF
            using CC3OF = Field<11, 1>;    // CC3OF
            using CC4OF = Field<12, 1>;    // CC4OF
            using SBIF = Field<13, 1>;    // SBIF
            using CC5IF = Field<16, 1>;    // CC5IF
            using CC6IF = Field<17, 1>;    // CC6IF
        };

        // TIM7 event generation register
        struct TIM7_EGR : public RegisterWriteOnly<0x40005014> {
            using UG = Field<0, 1>;    // UG
            using CC1G = Field<1, 1>;    // CC1G
            using CC2G = Field<2, 1>;    // CC2G
            using CC3G = Field<3, 1>;    // CC3G
            using CC4G = Field<4, 1>;    // CC4G
            using COMG = Field<5, 1>;    // COMG
            using TG = Field<6, 1>;    // TG
            using BG = Field<7, 1>;    // BG
            using B2G = Field<8, 1>;    // B2G
        };

        // The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
        struct TIM7_CCMR1ALTERNATE7 : public Register<0x40005018> {
            using CC1S = Field<0, 2>;    // CC1S
            using IC1PSC = Field<2, 2>;    // IC1PSC
            using IC1F = Field<4, 4>;    // IC1F
            using CC2S = Field<8, 2>;    // CC2S
            using IC2PSC = Field<10, 2>;    // IC2PSC
            using IC2F = Field<12, 4>;    // IC2F
        };

        // The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
        struct TIM7_CCMR2ALTERNATE23 : public Register<0x4000501c> {
            using CC3S = Field<0, 2>;    // CC3S
            using IC3PSC = Field<2, 2>;    // IC3PSC
            using IC3F = Field<4, 4>;    // IC3F
            using CC4S = Field<8, 2>;    // CC4S
            using IC4PSC = Field<10, 2>;    // IC4PSC
            using IC4F = Field<12, 4>;    // IC4F
        };

        // TIM7 capture/compare enable register
        struct TIM7_CCER : public Register<0x40005020> {
            using CC1E = Field<0, 1>;    // CC1E
            using CC1P = Field<1, 1>;    // CC1P
            using CC1NE = Field<2, 1>;    // CC1NE
            using CC1NP = Field<3, 1>;    // CC1NP
            using CC2E = Field<4, 1>;    // CC2E
            using CC2P = Field<5, 1>;    // CC2P
            using CC2NE = Field<6, 1>;    // CC2NE
            using CC2NP = Field<7, 1>;    // CC2NP
            using CC3E = Field<8, 1>;    // CC3E
            using CC3P = Field<9, 1>;    // CC3P
            using CC3NE = Field<10, 1>;    // CC3NE
            using CC3NP = Field<11, 1>;    // CC3NP
            using CC4E = Field<12, 1>;    // CC4E
            using CC4P = Field<13, 1>;    // CC4P
            using CC4NP = Field<15, 1>;    // CC4NP
            using CC5E = Field<16, 1>;    // CC5E
            using CC5P = Field<17, 1>;    // CC5P
            using CC6E = Field<20, 1>;    // CC6E
            using CC6P = Field<21, 1>;    // CC6P
        };

        // TIM7 counter
        struct TIM7_CNT : public Register<0x40005024> {
            using CNT = Field<0, 16>;    // CNT
            using UIFCPY = Field<31, 1>;    // UIFCPY
        };

        // TIM7 prescaler
        struct TIM7_PSC : public Register<0x40005028> {
            using PSC = Field<0, 16>;    // PSC
        };

        // TIM7 auto-reload register
        struct TIM7_ARR : public Register<0x4000502c> {
            using ARR = Field<0, 16>;    // ARR
        };

        // TIM7 repetition counter register
        struct TIM7_RCR : public Register<0x40005030> {
            using REP = Field<0, 16>;    // REP
        };

        // TIM7 capture/compare register 1
        struct TIM7_CCR1 : public Register<0x40005034> {
            using CCR1 = Field<0, 16>;    // CCR1
        };

        // TIM7 capture/compare register 2
        struct TIM7_CCR2 : public Register<0x40005038> {
            using CCR2 = Field<0, 16>;    // CCR2
        };

        // TIM7 capture/compare register 3
        struct TIM7_CCR3 : public Register<0x4000503c> {
            using CCR3 = Field<0, 16>;    // CCR3
        };

        // TIM7 capture/compare register 4
        struct TIM7_CCR4 : public Register<0x40005040> {
            using CCR4 = Field<0, 16>;    // CCR4
        };

        // As the bits BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] can be write-locked depending on the LOCK configuration, it can be necessary to configure all of them during the first write access to the TIMx_BDTR register.
        struct TIM7_BDTR : public Register<0x40005044> {
            using DTG = Field<0, 8>;    // DTG
            using LOCK = Field<8, 2>;    // LOCK
            using OSSI = Field<10, 1>;    // OSSI
            using OSSR = Field<11, 1>;    // OSSR
            using BKE = Field<12, 1>;    // BKE
            using BKP = Field<13, 1>;    // BKP
            using AOE = Field<14, 1>;    // AOE
            using MOE = Field<15, 1>;    // MOE
            using BKF = Field<16, 4>;    // BKF
            using BK2F = Field<20, 4>;    // BK2F
            using BK2E = Field<24, 1>;    // BK2E
            using BK2P = Field<25, 1>;    // BK2P
            using BKDSRM = Field<26, 1>;    // BKDSRM
            using BK2DSRM = Field<27, 1>;    // BK2DSRM
            using BKBID = Field<28, 1>;    // BKBID
            using BK2BID = Field<29, 1>;    // BK2BID
        };

        // TIM7 DMA control register
        struct TIM7_DCR : public Register<0x40005048> {
            using DBA = Field<0, 5>;    // DBA
            using DBL = Field<8, 5>;    // DBL
        };

        // TIM7 DMA address for full transfer
        struct TIM7_DMAR : public Register<0x4000504c> {
            using DMAB = Field<0, 32>;    // DMAB
        };

        // The channels 5 and 6 can only be configured in output. Output compare mode:
        struct TIM7_CCMR3 : public Register<0x40005054> {
            using OC5FE = Field<2, 1>;    // OC5FE
            using OC5PE = Field<3, 1>;    // OC5PE
            using OC5M = Field<4, 3>;    // OC5M
            using OC5CE = Field<7, 1>;    // OC5CE
            using OC6FE = Field<10, 1>;    // OC6FE
            using OC6PE = Field<11, 1>;    // OC6PE
            using OC6M = Field<12, 3>;    // OC6M
            using OC6CE = Field<15, 1>;    // OC6CE
            using OC5M3 = Field<16, 1>;    // OC5M3
            using OC6M3 = Field<24, 1>;    // OC6M3
        };

        // TIM7 capture/compare register 5
        struct TIM7_CCR5 : public Register<0x40005058> {
            using CCR5 = Field<0, 16>;    // CCR5
            using GC5C1 = Field<29, 1>;    // GC5C1
            using GC5C2 = Field<30, 1>;    // GC5C2
            using GC5C3 = Field<31, 1>;    // GC5C3
        };

        // TIM7 capture/compare register 6
        struct TIM7_CCR6 : public Register<0x4000505c> {
            using CCR6 = Field<0, 16>;    // CCR6
        };

    };

    // TIM8
    struct TIM8 {
        // TIM8 control register 1
        struct TIM8_CR1 : public Register<0x44001000> {
            using CEN = Field<0, 1>;    // CEN
            using UDIS = Field<1, 1>;    // UDIS
            using URS = Field<2, 1>;    // URS
            using OPM = Field<3, 1>;    // OPM
            using DIR = Field<4, 1>;    // DIR
            using CMS = Field<5, 2>;    // CMS
            using ARPE = Field<7, 1>;    // ARPE
            using CKD = Field<8, 2>;    // CKD
            using UIFREMAP = Field<11, 1>;    // UIFREMAP
        };

        // TIM8 control register 2
        struct TIM8_CR2 : public Register<0x44001004> {
            using CCPC = Field<0, 1>;    // CCPC
            using CCUS = Field<2, 1>;    // CCUS
            using CCDS = Field<3, 1>;    // CCDS
            using MMS = Field<4, 3>;    // MMS
            using TI1S = Field<7, 1>;    // TI1S
            using OIS1 = Field<8, 1>;    // OIS1
            using OIS1N = Field<9, 1>;    // OIS1N
            using OIS2 = Field<10, 1>;    // OIS2
            using OIS2N = Field<11, 1>;    // OIS2N
            using OIS3 = Field<12, 1>;    // OIS3
            using OIS3N = Field<13, 1>;    // OIS3N
            using OIS4 = Field<14, 1>;    // OIS4
            using OIS5 = Field<16, 1>;    // OIS5
            using OIS6 = Field<18, 1>;    // OIS6
            using MMS2 = Field<20, 4>;    // MMS2
        };

        // TIM8 slave mode control register
        struct TIM8_SMCR : public Register<0x44001008> {
            using SMS = Field<0, 3>;    // SMS
            using TS = Field<4, 3>;    // TS
            using MSM = Field<7, 1>;    // MSM
            using ETF = Field<8, 4>;    // ETF
            using ETPS = Field<12, 2>;    // ETPS
            using ECE = Field<14, 1>;    // ECE
            using ETP = Field<15, 1>;    // ETP
            using SMS3 = Field<16, 1>;    // SMS3
            using TS3 = Field<20, 1>;    // TS3
            using TS4 = Field<21, 1>;    // TS4
        };

        // TIM8 DMA/interrupt enable register
        struct TIM8_DIER : public Register<0x4400100c> {
            using UIE = Field<0, 1>;    // UIE
            using CC1IE = Field<1, 1>;    // CC1IE
            using CC2IE = Field<2, 1>;    // CC2IE
            using CC3IE = Field<3, 1>;    // CC3IE
            using CC4IE = Field<4, 1>;    // CC4IE
            using COMIE = Field<5, 1>;    // COMIE
            using TIE = Field<6, 1>;    // TIE
            using BIE = Field<7, 1>;    // BIE
            using UDE = Field<8, 1>;    // UDE
            using CC1DE = Field<9, 1>;    // CC1DE
            using CC2DE = Field<10, 1>;    // CC2DE
            using CC3DE = Field<11, 1>;    // CC3DE
            using CC4DE = Field<12, 1>;    // CC4DE
            using COMDE = Field<13, 1>;    // COMDE
            using TDE = Field<14, 1>;    // TDE
        };

        // TIM8 status register
        struct TIM8_SR : public Register<0x44001010> {
            using UIF = Field<0, 1>;    // UIF
            using CC1IF = Field<1, 1>;    // CC1IF
            using CC2IF = Field<2, 1>;    // CC2IF
            using CC3IF = Field<3, 1>;    // CC3IF
            using CC4IF = Field<4, 1>;    // CC4IF
            using COMIF = Field<5, 1>;    // COMIF
            using TIF = Field<6, 1>;    // TIF
            using BIF = Field<7, 1>;    // BIF
            using B2IF = Field<8, 1>;    // B2IF
            using CC1OF = Field<9, 1>;    // CC1OF
            using CC2OF = Field<10, 1>;    // CC2OF
            using CC3OF = Field<11, 1>;    // CC3OF
            using CC4OF = Field<12, 1>;    // CC4OF
            using SBIF = Field<13, 1>;    // SBIF
            using CC5IF = Field<16, 1>;    // CC5IF
            using CC6IF = Field<17, 1>;    // CC6IF
        };

        // TIM8 event generation register
        struct TIM8_EGR : public RegisterWriteOnly<0x44001014> {
            using UG = Field<0, 1>;    // UG
            using CC1G = Field<1, 1>;    // CC1G
            using CC2G = Field<2, 1>;    // CC2G
            using CC3G = Field<3, 1>;    // CC3G
            using CC4G = Field<4, 1>;    // CC4G
            using COMG = Field<5, 1>;    // COMG
            using TG = Field<6, 1>;    // TG
            using BG = Field<7, 1>;    // BG
            using B2G = Field<8, 1>;    // B2G
        };

        // The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
        struct TIM8_CCMR1ALTERNATE8 : public Register<0x44001018> {
            using CC1S = Field<0, 2>;    // CC1S
            using IC1PSC = Field<2, 2>;    // IC1PSC
            using IC1F = Field<4, 4>;    // IC1F
            using CC2S = Field<8, 2>;    // CC2S
            using IC2PSC = Field<10, 2>;    // IC2PSC
            using IC2F = Field<12, 4>;    // IC2F
        };

        // The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
        struct TIM8_CCMR2ALTERNATE24 : public Register<0x4400101c> {
            using CC3S = Field<0, 2>;    // CC3S
            using IC3PSC = Field<2, 2>;    // IC3PSC
            using IC3F = Field<4, 4>;    // IC3F
            using CC4S = Field<8, 2>;    // CC4S
            using IC4PSC = Field<10, 2>;    // IC4PSC
            using IC4F = Field<12, 4>;    // IC4F
        };

        // TIM8 capture/compare enable register
        struct TIM8_CCER : public Register<0x44001020> {
            using CC1E = Field<0, 1>;    // CC1E
            using CC1P = Field<1, 1>;    // CC1P
            using CC1NE = Field<2, 1>;    // CC1NE
            using CC1NP = Field<3, 1>;    // CC1NP
            using CC2E = Field<4, 1>;    // CC2E
            using CC2P = Field<5, 1>;    // CC2P
            using CC2NE = Field<6, 1>;    // CC2NE
            using CC2NP = Field<7, 1>;    // CC2NP
            using CC3E = Field<8, 1>;    // CC3E
            using CC3P = Field<9, 1>;    // CC3P
            using CC3NE = Field<10, 1>;    // CC3NE
            using CC3NP = Field<11, 1>;    // CC3NP
            using CC4E = Field<12, 1>;    // CC4E
            using CC4P = Field<13, 1>;    // CC4P
            using CC4NP = Field<15, 1>;    // CC4NP
            using CC5E = Field<16, 1>;    // CC5E
            using CC5P = Field<17, 1>;    // CC5P
            using CC6E = Field<20, 1>;    // CC6E
            using CC6P = Field<21, 1>;    // CC6P
        };

        // TIM8 counter
        struct TIM8_CNT : public Register<0x44001024> {
            using CNT = Field<0, 16>;    // CNT
            using UIFCPY = Field<31, 1>;    // UIFCPY
        };

        // TIM8 prescaler
        struct TIM8_PSC : public Register<0x44001028> {
            using PSC = Field<0, 16>;    // PSC
        };

        // TIM8 auto-reload register
        struct TIM8_ARR : public Register<0x4400102c> {
            using ARR = Field<0, 16>;    // ARR
        };

        // TIM8 repetition counter register
        struct TIM8_RCR : public Register<0x44001030> {
            using REP = Field<0, 16>;    // REP
        };

        // TIM8 capture/compare register 1
        struct TIM8_CCR1 : public Register<0x44001034> {
            using CCR1 = Field<0, 16>;    // CCR1
        };

        // TIM8 capture/compare register 2
        struct TIM8_CCR2 : public Register<0x44001038> {
            using CCR2 = Field<0, 16>;    // CCR2
        };

        // TIM8 capture/compare register 3
        struct TIM8_CCR3 : public Register<0x4400103c> {
            using CCR3 = Field<0, 16>;    // CCR3
        };

        // TIM8 capture/compare register 4
        struct TIM8_CCR4 : public Register<0x44001040> {
            using CCR4 = Field<0, 16>;    // CCR4
        };

        // As the bits BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] can be write-locked depending on the LOCK configuration, it can be necessary to configure all of them during the first write access to the TIMx_BDTR register.
        struct TIM8_BDTR : public Register<0x44001044> {
            using DTG = Field<0, 8>;    // DTG
            using LOCK = Field<8, 2>;    // LOCK
            using OSSI = Field<10, 1>;    // OSSI
            using OSSR = Field<11, 1>;    // OSSR
            using BKE = Field<12, 1>;    // BKE
            using BKP = Field<13, 1>;    // BKP
            using AOE = Field<14, 1>;    // AOE
            using MOE = Field<15, 1>;    // MOE
            using BKF = Field<16, 4>;    // BKF
            using BK2F = Field<20, 4>;    // BK2F
            using BK2E = Field<24, 1>;    // BK2E
            using BK2P = Field<25, 1>;    // BK2P
            using BKDSRM = Field<26, 1>;    // BKDSRM
            using BK2DSRM = Field<27, 1>;    // BK2DSRM
            using BKBID = Field<28, 1>;    // BKBID
            using BK2BID = Field<29, 1>;    // BK2BID
        };

        // TIM8 DMA control register
        struct TIM8_DCR : public Register<0x44001048> {
            using DBA = Field<0, 5>;    // DBA
            using DBL = Field<8, 5>;    // DBL
        };

        // TIM8 DMA address for full transfer
        struct TIM8_DMAR : public Register<0x4400104c> {
            using DMAB = Field<0, 32>;    // DMAB
        };

        // The channels 5 and 6 can only be configured in output. Output compare mode:
        struct TIM8_CCMR3 : public Register<0x44001054> {
            using OC5FE = Field<2, 1>;    // OC5FE
            using OC5PE = Field<3, 1>;    // OC5PE
            using OC5M = Field<4, 3>;    // OC5M
            using OC5CE = Field<7, 1>;    // OC5CE
            using OC6FE = Field<10, 1>;    // OC6FE
            using OC6PE = Field<11, 1>;    // OC6PE
            using OC6M = Field<12, 3>;    // OC6M
            using OC6CE = Field<15, 1>;    // OC6CE
            using OC5M3 = Field<16, 1>;    // OC5M3
            using OC6M3 = Field<24, 1>;    // OC6M3
        };

        // TIM8 capture/compare register 5
        struct TIM8_CCR5 : public Register<0x44001058> {
            using CCR5 = Field<0, 16>;    // CCR5
            using GC5C1 = Field<29, 1>;    // GC5C1
            using GC5C2 = Field<30, 1>;    // GC5C2
            using GC5C3 = Field<31, 1>;    // GC5C3
        };

        // TIM8 capture/compare register 6
        struct TIM8_CCR6 : public Register<0x4400105c> {
            using CCR6 = Field<0, 16>;    // CCR6
        };

        // TIM8 Alternate function option register 1
        struct TIM8_AF1 : public Register<0x44001060> {
            using BKINE = Field<0, 1>;    // BKINE
            using BKDF1BK2E = Field<8, 1>;    // BKDF1BK2E
            using BKINP = Field<9, 1>;    // BKINP
            using ETRSEL = Field<14, 4>;    // ETRSEL
        };

        // TIM8 Alternate function option register 2
        struct TIM8_AF2 : public Register<0x44001064> {
            using BK2INE = Field<0, 1>;    // BK2INE
            using BK2DF1BK3E = Field<8, 1>;    // BK2DF1BK3E
            using BK2INP = Field<9, 1>;    // BK2INP
        };

        // TIM8 timer input selection register
        struct TIM8_TISEL : public Register<0x44001068> {
            using TI1SEL = Field<0, 4>;    // TI1SEL
            using TI2SEL = Field<8, 4>;    // TI2SEL
            using TI3SEL = Field<16, 4>;    // TI3SEL
            using TI4SEL = Field<24, 4>;    // TI4SEL
        };

    };

    // TIM13
    struct TIM13 {
        // TIM13 control register 1
        struct TIM13_CR1 : public Register<0x40007000> {
            using CEN = Field<0, 1>;    // CEN
            using UDIS = Field<1, 1>;    // UDIS
            using URS = Field<2, 1>;    // URS
            using OPM = Field<3, 1>;    // OPM
            using ARPE = Field<7, 1>;    // ARPE
            using CKD = Field<8, 2>;    // CKD
            using UIFREMAP = Field<11, 1>;    // UIFREMAP
        };

        // TIM13 Interrupt enable register
        struct TIM13_DIER : public Register<0x4000700c> {
            using UIE = Field<0, 1>;    // UIE
            using CC1IE = Field<1, 1>;    // CC1IE
        };

        // TIM13 status register
        struct TIM13_SR : public Register<0x40007010> {
            using UIF = Field<0, 1>;    // UIF
            using CC1IF = Field<1, 1>;    // CC1IF
            using CC1OF = Field<9, 1>;    // CC1OF
        };

        // TIM13 event generation register
        struct TIM13_EGR : public RegisterWriteOnly<0x40007014> {
            using UG = Field<0, 1>;    // UG
            using CC1G = Field<1, 1>;    // CC1G
        };

        // The channels can be used in input (capture mode) or in output (compare mode). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function in input and in output mode. For a given bit, OCxx describes its function when the channel is configured in output, ICxx describes its function when the channel is configured in input. So one must take care that the same bit can have a different meaning for the input stage and for the output stage. Output compare mode
        struct TIM13_CCMR1 : public Register<0x40007018> {
            using CC1S = Field<0, 2>;    // CC1S
            using OC1FE = Field<2, 1>;    // OC1FE
            using OC1PE = Field<3, 1>;    // OC1PE
            using OC1M = Field<4, 3>;    // OC1M
            using OC1M3 = Field<16, 1>;    // OC1M3
        };

        // TIM13 capture/compare enable register
        struct TIM13_CCER : public Register<0x40007020> {
            using CC1E = Field<0, 1>;    // CC1E
            using CC1P = Field<1, 1>;    // CC1P
            using CC1NP = Field<3, 1>;    // CC1NP
        };

        // TIM13 counter
        struct TIM13_CNT : public Register<0x40007024> {
            using CNT = Field<0, 16>;    // CNT
            using UIFCPY = Field<31, 1>;    // UIFCPY
        };

        // TIM13 prescaler
        struct TIM13_PSC : public Register<0x40007028> {
            using PSC = Field<0, 16>;    // PSC
        };

        // TIM13 auto-reload register
        struct TIM13_ARR : public Register<0x4000702c> {
            using ARR = Field<0, 16>;    // ARR
        };

        // TIM13 capture/compare register 1
        struct TIM13_CCR1 : public Register<0x40007034> {
            using CCR1 = Field<0, 16>;    // CCR1
        };

        // TIM13 timer input selection register
        struct TIM13_TISEL : public Register<0x40007068> {
            using TI1SEL = Field<0, 4>;    // TI1SEL
        };

    };

    // TIM14
    struct TIM14 {
        // TIM14 control register 1
        struct TIM14_CR1 : public Register<0x40008000> {
            using CEN = Field<0, 1>;    // CEN
            using UDIS = Field<1, 1>;    // UDIS
            using URS = Field<2, 1>;    // URS
            using OPM = Field<3, 1>;    // OPM
            using ARPE = Field<7, 1>;    // ARPE
            using CKD = Field<8, 2>;    // CKD
            using UIFREMAP = Field<11, 1>;    // UIFREMAP
        };

        // TIM14 Interrupt enable register
        struct TIM14_DIER : public Register<0x4000800c> {
            using UIE = Field<0, 1>;    // UIE
            using CC1IE = Field<1, 1>;    // CC1IE
        };

        // TIM14 status register
        struct TIM14_SR : public Register<0x40008010> {
            using UIF = Field<0, 1>;    // UIF
            using CC1IF = Field<1, 1>;    // CC1IF
            using CC1OF = Field<9, 1>;    // CC1OF
        };

        // TIM14 event generation register
        struct TIM14_EGR : public RegisterWriteOnly<0x40008014> {
            using UG = Field<0, 1>;    // UG
            using CC1G = Field<1, 1>;    // CC1G
        };

        // The channels can be used in input (capture mode) or in output (compare mode). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function in input and in output mode. For a given bit, OCxx describes its function when the channel is configured in output, ICxx describes its function when the channel is configured in input. So one must take care that the same bit can have a different meaning for the input stage and for the output stage. Output compare mode
        struct TIM14_CCMR1 : public Register<0x40008018> {
            using CC1S = Field<0, 2>;    // CC1S
            using OC1FE = Field<2, 1>;    // OC1FE
            using OC1PE = Field<3, 1>;    // OC1PE
            using OC1M = Field<4, 3>;    // OC1M
            using OC1M3 = Field<16, 1>;    // OC1M3
        };

        // TIM14 capture/compare enable register
        struct TIM14_CCER : public Register<0x40008020> {
            using CC1E = Field<0, 1>;    // CC1E
            using CC1P = Field<1, 1>;    // CC1P
            using CC1NP = Field<3, 1>;    // CC1NP
        };

        // TIM14 counter
        struct TIM14_CNT : public Register<0x40008024> {
            using CNT = Field<0, 16>;    // CNT
            using UIFCPY = Field<31, 1>;    // UIFCPY
        };

        // TIM14 prescaler
        struct TIM14_PSC : public Register<0x40008028> {
            using PSC = Field<0, 16>;    // PSC
        };

        // TIM14 auto-reload register
        struct TIM14_ARR : public Register<0x4000802c> {
            using ARR = Field<0, 16>;    // ARR
        };

        // TIM14 capture/compare register 1
        struct TIM14_CCR1 : public Register<0x40008034> {
            using CCR1 = Field<0, 16>;    // CCR1
        };

        // TIM14 timer input selection register
        struct TIM14_TISEL : public Register<0x40008068> {
            using TI1SEL = Field<0, 4>;    // TI1SEL
        };

    };

    // I2C2
    struct I2C2 {
        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2xi2c_pclk+6xi2c_ker_ck.
        struct I2C_CR1 : public Register<0x40013000> {
            using PE = Field<0, 1>;    // PE
            using TXIE = Field<1, 1>;    // TXIE
            using RXIE = Field<2, 1>;    // RXIE
            using ADDRIE = Field<3, 1>;    // ADDRIE
            using NACKIE = Field<4, 1>;    // NACKIE
            using STOPIE = Field<5, 1>;    // STOPIE
            using TCIE = Field<6, 1>;    // TCIE
            using ERRIE = Field<7, 1>;    // ERRIE
            using DNF = Field<8, 4>;    // DNF
            using ANFOFF = Field<12, 1>;    // ANFOFF
            using TXDMAEN = Field<14, 1>;    // TXDMAEN
            using RXDMAEN = Field<15, 1>;    // RXDMAEN
            using SBC = Field<16, 1>;    // SBC
            using NOSTRETCH = Field<17, 1>;    // NOSTRETCH
            using WUPEN = Field<18, 1>;    // WUPEN
            using GCEN = Field<19, 1>;    // GCEN
            using SMBHEN = Field<20, 1>;    // SMBHEN
            using SMBDEN = Field<21, 1>;    // SMBDEN
            using ALERTEN = Field<22, 1>;    // ALERTEN
            using PECEN = Field<23, 1>;    // PECEN
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_CR2 : public Register<0x40013004> {
            using SADD = Field<0, 10>;    // SADD
            using RD_WRN = Field<10, 1>;    // RD_WRN
            using ADD10 = Field<11, 1>;    // ADD10
            using HEAD10R = Field<12, 1>;    // HEAD10R
            using START = Field<13, 1>;    // START
            using STOP = Field<14, 1>;    // STOP
            using NACK = Field<15, 1>;    // NACK
            using NBYTES = Field<16, 8>;    // NBYTES
            using RELOAD = Field<24, 1>;    // RELOAD
            using AUTOEND = Field<25, 1>;    // AUTOEND
            using PECBYTE = Field<26, 1>;    // PECBYTE
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_OAR1 : public Register<0x40013008> {
            using OA1 = Field<0, 10>;    // OA1
            using OA1MODE = Field<10, 1>;    // OA1MODE
            using OA1EN = Field<15, 1>;    // OA1EN
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_OAR2 : public Register<0x4001300c> {
            using OA2 = Field<1, 7>;    // OA2
            using OA2MSK = Field<8, 3>;    // OA2MSK
            using OA2EN = Field<15, 1>;    // OA2EN
        };

        // Access: No wait states
        struct I2C_TIMINGR : public Register<0x40013010> {
            using SCLL = Field<0, 8>;    // SCLL
            using SCLH = Field<8, 8>;    // SCLH
            using SDADEL = Field<16, 4>;    // SDADEL
            using SCLDEL = Field<20, 4>;    // SCLDEL
            using PRESC = Field<28, 4>;    // PRESC
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_TIMEOUTR : public Register<0x40013014> {
            using TIMEOUTA = Field<0, 12>;    // TIMEOUTA
            using TIDLE = Field<12, 1>;    // TIDLE
            using TIMOUTEN = Field<15, 1>;    // TIMOUTEN
            using TIMEOUTB = Field<16, 12>;    // TIMEOUTB
            using TEXTEN = Field<31, 1>;    // TEXTEN
        };

        // Access: No wait states
        struct I2C_ISR : public Register<0x40013018> {
            using TXE = Field<0, 1>;    // TXE
            using TXIS = Field<1, 1>;    // TXIS
            using RXNE = Field<2, 1>;    // RXNE
            using ADDR = Field<3, 1>;    // ADDR
            using NACKF = Field<4, 1>;    // NACKF
            using STOPF = Field<5, 1>;    // STOPF
            using TC = Field<6, 1>;    // TC
            using TCR = Field<7, 1>;    // TCR
            using BERR = Field<8, 1>;    // BERR
            using ARLO = Field<9, 1>;    // ARLO
            using OVR = Field<10, 1>;    // OVR
            using PECERR = Field<11, 1>;    // PECERR
            using TIMEOUT = Field<12, 1>;    // TIMEOUT
            using ALERT = Field<13, 1>;    // ALERT
            using BUSY = Field<15, 1>;    // BUSY
            using DIR = Field<16, 1>;    // DIR
            using ADDCODE = Field<17, 7>;    // ADDCODE
        };

        // Access: No wait states
        struct I2C_ICR : public RegisterWriteOnly<0x4001301c> {
            using ADDRCF = Field<3, 1>;    // ADDRCF
            using NACKCF = Field<4, 1>;    // NACKCF
            using STOPCF = Field<5, 1>;    // STOPCF
            using BERRCF = Field<8, 1>;    // BERRCF
            using ARLOCF = Field<9, 1>;    // ARLOCF
            using OVRCF = Field<10, 1>;    // OVRCF
            using PECCF = Field<11, 1>;    // PECCF
            using TIMOUTCF = Field<12, 1>;    // TIMOUTCF
            using ALERTCF = Field<13, 1>;    // ALERTCF
        };

        // Access: No wait states
        struct I2C_PECR : public RegisterReadOnly<0x40013020> {
            using PEC = Field<0, 8>;    // PEC
        };

        // Access: No wait states
        struct I2C_RXDR : public RegisterReadOnly<0x40013024> {
            using RXDATA = Field<0, 8>;    // RXDATA
        };

        // Access: No wait states
        struct I2C_TXDR : public Register<0x40013028> {
            using TXDATA = Field<0, 8>;    // TXDATA
        };

        // I2C hardware configuration register
        struct I2C_HWCFGR : public RegisterReadOnly<0x400133f0> {
            using SMBUS = Field<0, 4>;    // SMBUS
            using ASYN = Field<4, 4>;    // ASYN
            using WKP = Field<8, 4>;    // WKP
        };

        // I2C version register
        struct I2C_VERR : public RegisterReadOnly<0x400133f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // I2C identification register
        struct I2C_IPIDR : public RegisterReadOnly<0x400133f8> {
            using ID = Field<0, 32>;    // ID
        };

        // I2C size identification register
        struct I2C_SIDR : public RegisterReadOnly<0x400133fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // I2C2
    struct I2C1 {
        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2xi2c_pclk+6xi2c_ker_ck.
        struct I2C_CR1 : public Register<0x40012000> {
            using PE = Field<0, 1>;    // PE
            using TXIE = Field<1, 1>;    // TXIE
            using RXIE = Field<2, 1>;    // RXIE
            using ADDRIE = Field<3, 1>;    // ADDRIE
            using NACKIE = Field<4, 1>;    // NACKIE
            using STOPIE = Field<5, 1>;    // STOPIE
            using TCIE = Field<6, 1>;    // TCIE
            using ERRIE = Field<7, 1>;    // ERRIE
            using DNF = Field<8, 4>;    // DNF
            using ANFOFF = Field<12, 1>;    // ANFOFF
            using TXDMAEN = Field<14, 1>;    // TXDMAEN
            using RXDMAEN = Field<15, 1>;    // RXDMAEN
            using SBC = Field<16, 1>;    // SBC
            using NOSTRETCH = Field<17, 1>;    // NOSTRETCH
            using WUPEN = Field<18, 1>;    // WUPEN
            using GCEN = Field<19, 1>;    // GCEN
            using SMBHEN = Field<20, 1>;    // SMBHEN
            using SMBDEN = Field<21, 1>;    // SMBDEN
            using ALERTEN = Field<22, 1>;    // ALERTEN
            using PECEN = Field<23, 1>;    // PECEN
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_CR2 : public Register<0x40012004> {
            using SADD = Field<0, 10>;    // SADD
            using RD_WRN = Field<10, 1>;    // RD_WRN
            using ADD10 = Field<11, 1>;    // ADD10
            using HEAD10R = Field<12, 1>;    // HEAD10R
            using START = Field<13, 1>;    // START
            using STOP = Field<14, 1>;    // STOP
            using NACK = Field<15, 1>;    // NACK
            using NBYTES = Field<16, 8>;    // NBYTES
            using RELOAD = Field<24, 1>;    // RELOAD
            using AUTOEND = Field<25, 1>;    // AUTOEND
            using PECBYTE = Field<26, 1>;    // PECBYTE
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_OAR1 : public Register<0x40012008> {
            using OA1 = Field<0, 10>;    // OA1
            using OA1MODE = Field<10, 1>;    // OA1MODE
            using OA1EN = Field<15, 1>;    // OA1EN
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_OAR2 : public Register<0x4001200c> {
            using OA2 = Field<1, 7>;    // OA2
            using OA2MSK = Field<8, 3>;    // OA2MSK
            using OA2EN = Field<15, 1>;    // OA2EN
        };

        // Access: No wait states
        struct I2C_TIMINGR : public Register<0x40012010> {
            using SCLL = Field<0, 8>;    // SCLL
            using SCLH = Field<8, 8>;    // SCLH
            using SDADEL = Field<16, 4>;    // SDADEL
            using SCLDEL = Field<20, 4>;    // SCLDEL
            using PRESC = Field<28, 4>;    // PRESC
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_TIMEOUTR : public Register<0x40012014> {
            using TIMEOUTA = Field<0, 12>;    // TIMEOUTA
            using TIDLE = Field<12, 1>;    // TIDLE
            using TIMOUTEN = Field<15, 1>;    // TIMOUTEN
            using TIMEOUTB = Field<16, 12>;    // TIMEOUTB
            using TEXTEN = Field<31, 1>;    // TEXTEN
        };

        // Access: No wait states
        struct I2C_ISR : public Register<0x40012018> {
            using TXE = Field<0, 1>;    // TXE
            using TXIS = Field<1, 1>;    // TXIS
            using RXNE = Field<2, 1>;    // RXNE
            using ADDR = Field<3, 1>;    // ADDR
            using NACKF = Field<4, 1>;    // NACKF
            using STOPF = Field<5, 1>;    // STOPF
            using TC = Field<6, 1>;    // TC
            using TCR = Field<7, 1>;    // TCR
            using BERR = Field<8, 1>;    // BERR
            using ARLO = Field<9, 1>;    // ARLO
            using OVR = Field<10, 1>;    // OVR
            using PECERR = Field<11, 1>;    // PECERR
            using TIMEOUT = Field<12, 1>;    // TIMEOUT
            using ALERT = Field<13, 1>;    // ALERT
            using BUSY = Field<15, 1>;    // BUSY
            using DIR = Field<16, 1>;    // DIR
            using ADDCODE = Field<17, 7>;    // ADDCODE
        };

        // Access: No wait states
        struct I2C_ICR : public RegisterWriteOnly<0x4001201c> {
            using ADDRCF = Field<3, 1>;    // ADDRCF
            using NACKCF = Field<4, 1>;    // NACKCF
            using STOPCF = Field<5, 1>;    // STOPCF
            using BERRCF = Field<8, 1>;    // BERRCF
            using ARLOCF = Field<9, 1>;    // ARLOCF
            using OVRCF = Field<10, 1>;    // OVRCF
            using PECCF = Field<11, 1>;    // PECCF
            using TIMOUTCF = Field<12, 1>;    // TIMOUTCF
            using ALERTCF = Field<13, 1>;    // ALERTCF
        };

        // Access: No wait states
        struct I2C_PECR : public RegisterReadOnly<0x40012020> {
            using PEC = Field<0, 8>;    // PEC
        };

        // Access: No wait states
        struct I2C_RXDR : public RegisterReadOnly<0x40012024> {
            using RXDATA = Field<0, 8>;    // RXDATA
        };

        // Access: No wait states
        struct I2C_TXDR : public Register<0x40012028> {
            using TXDATA = Field<0, 8>;    // TXDATA
        };

        // I2C hardware configuration register
        struct I2C_HWCFGR : public RegisterReadOnly<0x400123f0> {
            using SMBUS = Field<0, 4>;    // SMBUS
            using ASYN = Field<4, 4>;    // ASYN
            using WKP = Field<8, 4>;    // WKP
        };

        // I2C version register
        struct I2C_VERR : public RegisterReadOnly<0x400123f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // I2C identification register
        struct I2C_IPIDR : public RegisterReadOnly<0x400123f8> {
            using ID = Field<0, 32>;    // ID
        };

        // I2C size identification register
        struct I2C_SIDR : public RegisterReadOnly<0x400123fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // I2C2
    struct I2C3 {
        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2xi2c_pclk+6xi2c_ker_ck.
        struct I2C_CR1 : public Register<0x40014000> {
            using PE = Field<0, 1>;    // PE
            using TXIE = Field<1, 1>;    // TXIE
            using RXIE = Field<2, 1>;    // RXIE
            using ADDRIE = Field<3, 1>;    // ADDRIE
            using NACKIE = Field<4, 1>;    // NACKIE
            using STOPIE = Field<5, 1>;    // STOPIE
            using TCIE = Field<6, 1>;    // TCIE
            using ERRIE = Field<7, 1>;    // ERRIE
            using DNF = Field<8, 4>;    // DNF
            using ANFOFF = Field<12, 1>;    // ANFOFF
            using TXDMAEN = Field<14, 1>;    // TXDMAEN
            using RXDMAEN = Field<15, 1>;    // RXDMAEN
            using SBC = Field<16, 1>;    // SBC
            using NOSTRETCH = Field<17, 1>;    // NOSTRETCH
            using WUPEN = Field<18, 1>;    // WUPEN
            using GCEN = Field<19, 1>;    // GCEN
            using SMBHEN = Field<20, 1>;    // SMBHEN
            using SMBDEN = Field<21, 1>;    // SMBDEN
            using ALERTEN = Field<22, 1>;    // ALERTEN
            using PECEN = Field<23, 1>;    // PECEN
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_CR2 : public Register<0x40014004> {
            using SADD = Field<0, 10>;    // SADD
            using RD_WRN = Field<10, 1>;    // RD_WRN
            using ADD10 = Field<11, 1>;    // ADD10
            using HEAD10R = Field<12, 1>;    // HEAD10R
            using START = Field<13, 1>;    // START
            using STOP = Field<14, 1>;    // STOP
            using NACK = Field<15, 1>;    // NACK
            using NBYTES = Field<16, 8>;    // NBYTES
            using RELOAD = Field<24, 1>;    // RELOAD
            using AUTOEND = Field<25, 1>;    // AUTOEND
            using PECBYTE = Field<26, 1>;    // PECBYTE
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_OAR1 : public Register<0x40014008> {
            using OA1 = Field<0, 10>;    // OA1
            using OA1MODE = Field<10, 1>;    // OA1MODE
            using OA1EN = Field<15, 1>;    // OA1EN
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_OAR2 : public Register<0x4001400c> {
            using OA2 = Field<1, 7>;    // OA2
            using OA2MSK = Field<8, 3>;    // OA2MSK
            using OA2EN = Field<15, 1>;    // OA2EN
        };

        // Access: No wait states
        struct I2C_TIMINGR : public Register<0x40014010> {
            using SCLL = Field<0, 8>;    // SCLL
            using SCLH = Field<8, 8>;    // SCLH
            using SDADEL = Field<16, 4>;    // SDADEL
            using SCLDEL = Field<20, 4>;    // SCLDEL
            using PRESC = Field<28, 4>;    // PRESC
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_TIMEOUTR : public Register<0x40014014> {
            using TIMEOUTA = Field<0, 12>;    // TIMEOUTA
            using TIDLE = Field<12, 1>;    // TIDLE
            using TIMOUTEN = Field<15, 1>;    // TIMOUTEN
            using TIMEOUTB = Field<16, 12>;    // TIMEOUTB
            using TEXTEN = Field<31, 1>;    // TEXTEN
        };

        // Access: No wait states
        struct I2C_ISR : public Register<0x40014018> {
            using TXE = Field<0, 1>;    // TXE
            using TXIS = Field<1, 1>;    // TXIS
            using RXNE = Field<2, 1>;    // RXNE
            using ADDR = Field<3, 1>;    // ADDR
            using NACKF = Field<4, 1>;    // NACKF
            using STOPF = Field<5, 1>;    // STOPF
            using TC = Field<6, 1>;    // TC
            using TCR = Field<7, 1>;    // TCR
            using BERR = Field<8, 1>;    // BERR
            using ARLO = Field<9, 1>;    // ARLO
            using OVR = Field<10, 1>;    // OVR
            using PECERR = Field<11, 1>;    // PECERR
            using TIMEOUT = Field<12, 1>;    // TIMEOUT
            using ALERT = Field<13, 1>;    // ALERT
            using BUSY = Field<15, 1>;    // BUSY
            using DIR = Field<16, 1>;    // DIR
            using ADDCODE = Field<17, 7>;    // ADDCODE
        };

        // Access: No wait states
        struct I2C_ICR : public RegisterWriteOnly<0x4001401c> {
            using ADDRCF = Field<3, 1>;    // ADDRCF
            using NACKCF = Field<4, 1>;    // NACKCF
            using STOPCF = Field<5, 1>;    // STOPCF
            using BERRCF = Field<8, 1>;    // BERRCF
            using ARLOCF = Field<9, 1>;    // ARLOCF
            using OVRCF = Field<10, 1>;    // OVRCF
            using PECCF = Field<11, 1>;    // PECCF
            using TIMOUTCF = Field<12, 1>;    // TIMOUTCF
            using ALERTCF = Field<13, 1>;    // ALERTCF
        };

        // Access: No wait states
        struct I2C_PECR : public RegisterReadOnly<0x40014020> {
            using PEC = Field<0, 8>;    // PEC
        };

        // Access: No wait states
        struct I2C_RXDR : public RegisterReadOnly<0x40014024> {
            using RXDATA = Field<0, 8>;    // RXDATA
        };

        // Access: No wait states
        struct I2C_TXDR : public Register<0x40014028> {
            using TXDATA = Field<0, 8>;    // TXDATA
        };

        // I2C hardware configuration register
        struct I2C_HWCFGR : public RegisterReadOnly<0x400143f0> {
            using SMBUS = Field<0, 4>;    // SMBUS
            using ASYN = Field<4, 4>;    // ASYN
            using WKP = Field<8, 4>;    // WKP
        };

        // I2C version register
        struct I2C_VERR : public RegisterReadOnly<0x400143f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // I2C identification register
        struct I2C_IPIDR : public RegisterReadOnly<0x400143f8> {
            using ID = Field<0, 32>;    // ID
        };

        // I2C size identification register
        struct I2C_SIDR : public RegisterReadOnly<0x400143fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // I2C2
    struct I2C4 {
        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2xi2c_pclk+6xi2c_ker_ck.
        struct I2C_CR1 : public Register<0x5c002000> {
            using PE = Field<0, 1>;    // PE
            using TXIE = Field<1, 1>;    // TXIE
            using RXIE = Field<2, 1>;    // RXIE
            using ADDRIE = Field<3, 1>;    // ADDRIE
            using NACKIE = Field<4, 1>;    // NACKIE
            using STOPIE = Field<5, 1>;    // STOPIE
            using TCIE = Field<6, 1>;    // TCIE
            using ERRIE = Field<7, 1>;    // ERRIE
            using DNF = Field<8, 4>;    // DNF
            using ANFOFF = Field<12, 1>;    // ANFOFF
            using TXDMAEN = Field<14, 1>;    // TXDMAEN
            using RXDMAEN = Field<15, 1>;    // RXDMAEN
            using SBC = Field<16, 1>;    // SBC
            using NOSTRETCH = Field<17, 1>;    // NOSTRETCH
            using WUPEN = Field<18, 1>;    // WUPEN
            using GCEN = Field<19, 1>;    // GCEN
            using SMBHEN = Field<20, 1>;    // SMBHEN
            using SMBDEN = Field<21, 1>;    // SMBDEN
            using ALERTEN = Field<22, 1>;    // ALERTEN
            using PECEN = Field<23, 1>;    // PECEN
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_CR2 : public Register<0x5c002004> {
            using SADD = Field<0, 10>;    // SADD
            using RD_WRN = Field<10, 1>;    // RD_WRN
            using ADD10 = Field<11, 1>;    // ADD10
            using HEAD10R = Field<12, 1>;    // HEAD10R
            using START = Field<13, 1>;    // START
            using STOP = Field<14, 1>;    // STOP
            using NACK = Field<15, 1>;    // NACK
            using NBYTES = Field<16, 8>;    // NBYTES
            using RELOAD = Field<24, 1>;    // RELOAD
            using AUTOEND = Field<25, 1>;    // AUTOEND
            using PECBYTE = Field<26, 1>;    // PECBYTE
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_OAR1 : public Register<0x5c002008> {
            using OA1 = Field<0, 10>;    // OA1
            using OA1MODE = Field<10, 1>;    // OA1MODE
            using OA1EN = Field<15, 1>;    // OA1EN
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_OAR2 : public Register<0x5c00200c> {
            using OA2 = Field<1, 7>;    // OA2
            using OA2MSK = Field<8, 3>;    // OA2MSK
            using OA2EN = Field<15, 1>;    // OA2EN
        };

        // Access: No wait states
        struct I2C_TIMINGR : public Register<0x5c002010> {
            using SCLL = Field<0, 8>;    // SCLL
            using SCLH = Field<8, 8>;    // SCLH
            using SDADEL = Field<16, 4>;    // SDADEL
            using SCLDEL = Field<20, 4>;    // SCLDEL
            using PRESC = Field<28, 4>;    // PRESC
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_TIMEOUTR : public Register<0x5c002014> {
            using TIMEOUTA = Field<0, 12>;    // TIMEOUTA
            using TIDLE = Field<12, 1>;    // TIDLE
            using TIMOUTEN = Field<15, 1>;    // TIMOUTEN
            using TIMEOUTB = Field<16, 12>;    // TIMEOUTB
            using TEXTEN = Field<31, 1>;    // TEXTEN
        };

        // Access: No wait states
        struct I2C_ISR : public Register<0x5c002018> {
            using TXE = Field<0, 1>;    // TXE
            using TXIS = Field<1, 1>;    // TXIS
            using RXNE = Field<2, 1>;    // RXNE
            using ADDR = Field<3, 1>;    // ADDR
            using NACKF = Field<4, 1>;    // NACKF
            using STOPF = Field<5, 1>;    // STOPF
            using TC = Field<6, 1>;    // TC
            using TCR = Field<7, 1>;    // TCR
            using BERR = Field<8, 1>;    // BERR
            using ARLO = Field<9, 1>;    // ARLO
            using OVR = Field<10, 1>;    // OVR
            using PECERR = Field<11, 1>;    // PECERR
            using TIMEOUT = Field<12, 1>;    // TIMEOUT
            using ALERT = Field<13, 1>;    // ALERT
            using BUSY = Field<15, 1>;    // BUSY
            using DIR = Field<16, 1>;    // DIR
            using ADDCODE = Field<17, 7>;    // ADDCODE
        };

        // Access: No wait states
        struct I2C_ICR : public RegisterWriteOnly<0x5c00201c> {
            using ADDRCF = Field<3, 1>;    // ADDRCF
            using NACKCF = Field<4, 1>;    // NACKCF
            using STOPCF = Field<5, 1>;    // STOPCF
            using BERRCF = Field<8, 1>;    // BERRCF
            using ARLOCF = Field<9, 1>;    // ARLOCF
            using OVRCF = Field<10, 1>;    // OVRCF
            using PECCF = Field<11, 1>;    // PECCF
            using TIMOUTCF = Field<12, 1>;    // TIMOUTCF
            using ALERTCF = Field<13, 1>;    // ALERTCF
        };

        // Access: No wait states
        struct I2C_PECR : public RegisterReadOnly<0x5c002020> {
            using PEC = Field<0, 8>;    // PEC
        };

        // Access: No wait states
        struct I2C_RXDR : public RegisterReadOnly<0x5c002024> {
            using RXDATA = Field<0, 8>;    // RXDATA
        };

        // Access: No wait states
        struct I2C_TXDR : public Register<0x5c002028> {
            using TXDATA = Field<0, 8>;    // TXDATA
        };

        // I2C hardware configuration register
        struct I2C_HWCFGR : public RegisterReadOnly<0x5c0023f0> {
            using SMBUS = Field<0, 4>;    // SMBUS
            using ASYN = Field<4, 4>;    // ASYN
            using WKP = Field<8, 4>;    // WKP
        };

        // I2C version register
        struct I2C_VERR : public RegisterReadOnly<0x5c0023f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // I2C identification register
        struct I2C_IPIDR : public RegisterReadOnly<0x5c0023f8> {
            using ID = Field<0, 32>;    // ID
        };

        // I2C size identification register
        struct I2C_SIDR : public RegisterReadOnly<0x5c0023fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // I2C2
    struct I2C5 {
        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2xi2c_pclk+6xi2c_ker_ck.
        struct I2C_CR1 : public Register<0x40015000> {
            using PE = Field<0, 1>;    // PE
            using TXIE = Field<1, 1>;    // TXIE
            using RXIE = Field<2, 1>;    // RXIE
            using ADDRIE = Field<3, 1>;    // ADDRIE
            using NACKIE = Field<4, 1>;    // NACKIE
            using STOPIE = Field<5, 1>;    // STOPIE
            using TCIE = Field<6, 1>;    // TCIE
            using ERRIE = Field<7, 1>;    // ERRIE
            using DNF = Field<8, 4>;    // DNF
            using ANFOFF = Field<12, 1>;    // ANFOFF
            using TXDMAEN = Field<14, 1>;    // TXDMAEN
            using RXDMAEN = Field<15, 1>;    // RXDMAEN
            using SBC = Field<16, 1>;    // SBC
            using NOSTRETCH = Field<17, 1>;    // NOSTRETCH
            using WUPEN = Field<18, 1>;    // WUPEN
            using GCEN = Field<19, 1>;    // GCEN
            using SMBHEN = Field<20, 1>;    // SMBHEN
            using SMBDEN = Field<21, 1>;    // SMBDEN
            using ALERTEN = Field<22, 1>;    // ALERTEN
            using PECEN = Field<23, 1>;    // PECEN
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_CR2 : public Register<0x40015004> {
            using SADD = Field<0, 10>;    // SADD
            using RD_WRN = Field<10, 1>;    // RD_WRN
            using ADD10 = Field<11, 1>;    // ADD10
            using HEAD10R = Field<12, 1>;    // HEAD10R
            using START = Field<13, 1>;    // START
            using STOP = Field<14, 1>;    // STOP
            using NACK = Field<15, 1>;    // NACK
            using NBYTES = Field<16, 8>;    // NBYTES
            using RELOAD = Field<24, 1>;    // RELOAD
            using AUTOEND = Field<25, 1>;    // AUTOEND
            using PECBYTE = Field<26, 1>;    // PECBYTE
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_OAR1 : public Register<0x40015008> {
            using OA1 = Field<0, 10>;    // OA1
            using OA1MODE = Field<10, 1>;    // OA1MODE
            using OA1EN = Field<15, 1>;    // OA1EN
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_OAR2 : public Register<0x4001500c> {
            using OA2 = Field<1, 7>;    // OA2
            using OA2MSK = Field<8, 3>;    // OA2MSK
            using OA2EN = Field<15, 1>;    // OA2EN
        };

        // Access: No wait states
        struct I2C_TIMINGR : public Register<0x40015010> {
            using SCLL = Field<0, 8>;    // SCLL
            using SCLH = Field<8, 8>;    // SCLH
            using SDADEL = Field<16, 4>;    // SDADEL
            using SCLDEL = Field<20, 4>;    // SCLDEL
            using PRESC = Field<28, 4>;    // PRESC
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_TIMEOUTR : public Register<0x40015014> {
            using TIMEOUTA = Field<0, 12>;    // TIMEOUTA
            using TIDLE = Field<12, 1>;    // TIDLE
            using TIMOUTEN = Field<15, 1>;    // TIMOUTEN
            using TIMEOUTB = Field<16, 12>;    // TIMEOUTB
            using TEXTEN = Field<31, 1>;    // TEXTEN
        };

        // Access: No wait states
        struct I2C_ISR : public Register<0x40015018> {
            using TXE = Field<0, 1>;    // TXE
            using TXIS = Field<1, 1>;    // TXIS
            using RXNE = Field<2, 1>;    // RXNE
            using ADDR = Field<3, 1>;    // ADDR
            using NACKF = Field<4, 1>;    // NACKF
            using STOPF = Field<5, 1>;    // STOPF
            using TC = Field<6, 1>;    // TC
            using TCR = Field<7, 1>;    // TCR
            using BERR = Field<8, 1>;    // BERR
            using ARLO = Field<9, 1>;    // ARLO
            using OVR = Field<10, 1>;    // OVR
            using PECERR = Field<11, 1>;    // PECERR
            using TIMEOUT = Field<12, 1>;    // TIMEOUT
            using ALERT = Field<13, 1>;    // ALERT
            using BUSY = Field<15, 1>;    // BUSY
            using DIR = Field<16, 1>;    // DIR
            using ADDCODE = Field<17, 7>;    // ADDCODE
        };

        // Access: No wait states
        struct I2C_ICR : public RegisterWriteOnly<0x4001501c> {
            using ADDRCF = Field<3, 1>;    // ADDRCF
            using NACKCF = Field<4, 1>;    // NACKCF
            using STOPCF = Field<5, 1>;    // STOPCF
            using BERRCF = Field<8, 1>;    // BERRCF
            using ARLOCF = Field<9, 1>;    // ARLOCF
            using OVRCF = Field<10, 1>;    // OVRCF
            using PECCF = Field<11, 1>;    // PECCF
            using TIMOUTCF = Field<12, 1>;    // TIMOUTCF
            using ALERTCF = Field<13, 1>;    // ALERTCF
        };

        // Access: No wait states
        struct I2C_PECR : public RegisterReadOnly<0x40015020> {
            using PEC = Field<0, 8>;    // PEC
        };

        // Access: No wait states
        struct I2C_RXDR : public RegisterReadOnly<0x40015024> {
            using RXDATA = Field<0, 8>;    // RXDATA
        };

        // Access: No wait states
        struct I2C_TXDR : public Register<0x40015028> {
            using TXDATA = Field<0, 8>;    // TXDATA
        };

        // I2C hardware configuration register
        struct I2C_HWCFGR : public RegisterReadOnly<0x400153f0> {
            using SMBUS = Field<0, 4>;    // SMBUS
            using ASYN = Field<4, 4>;    // ASYN
            using WKP = Field<8, 4>;    // WKP
        };

        // I2C version register
        struct I2C_VERR : public RegisterReadOnly<0x400153f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // I2C identification register
        struct I2C_IPIDR : public RegisterReadOnly<0x400153f8> {
            using ID = Field<0, 32>;    // ID
        };

        // I2C size identification register
        struct I2C_SIDR : public RegisterReadOnly<0x400153fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // I2C2
    struct I2C6 {
        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2xi2c_pclk+6xi2c_ker_ck.
        struct I2C_CR1 : public Register<0x5c009000> {
            using PE = Field<0, 1>;    // PE
            using TXIE = Field<1, 1>;    // TXIE
            using RXIE = Field<2, 1>;    // RXIE
            using ADDRIE = Field<3, 1>;    // ADDRIE
            using NACKIE = Field<4, 1>;    // NACKIE
            using STOPIE = Field<5, 1>;    // STOPIE
            using TCIE = Field<6, 1>;    // TCIE
            using ERRIE = Field<7, 1>;    // ERRIE
            using DNF = Field<8, 4>;    // DNF
            using ANFOFF = Field<12, 1>;    // ANFOFF
            using TXDMAEN = Field<14, 1>;    // TXDMAEN
            using RXDMAEN = Field<15, 1>;    // RXDMAEN
            using SBC = Field<16, 1>;    // SBC
            using NOSTRETCH = Field<17, 1>;    // NOSTRETCH
            using WUPEN = Field<18, 1>;    // WUPEN
            using GCEN = Field<19, 1>;    // GCEN
            using SMBHEN = Field<20, 1>;    // SMBHEN
            using SMBDEN = Field<21, 1>;    // SMBDEN
            using ALERTEN = Field<22, 1>;    // ALERTEN
            using PECEN = Field<23, 1>;    // PECEN
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_CR2 : public Register<0x5c009004> {
            using SADD = Field<0, 10>;    // SADD
            using RD_WRN = Field<10, 1>;    // RD_WRN
            using ADD10 = Field<11, 1>;    // ADD10
            using HEAD10R = Field<12, 1>;    // HEAD10R
            using START = Field<13, 1>;    // START
            using STOP = Field<14, 1>;    // STOP
            using NACK = Field<15, 1>;    // NACK
            using NBYTES = Field<16, 8>;    // NBYTES
            using RELOAD = Field<24, 1>;    // RELOAD
            using AUTOEND = Field<25, 1>;    // AUTOEND
            using PECBYTE = Field<26, 1>;    // PECBYTE
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_OAR1 : public Register<0x5c009008> {
            using OA1 = Field<0, 10>;    // OA1
            using OA1MODE = Field<10, 1>;    // OA1MODE
            using OA1EN = Field<15, 1>;    // OA1EN
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_OAR2 : public Register<0x5c00900c> {
            using OA2 = Field<1, 7>;    // OA2
            using OA2MSK = Field<8, 3>;    // OA2MSK
            using OA2EN = Field<15, 1>;    // OA2EN
        };

        // Access: No wait states
        struct I2C_TIMINGR : public Register<0x5c009010> {
            using SCLL = Field<0, 8>;    // SCLL
            using SCLH = Field<8, 8>;    // SCLH
            using SDADEL = Field<16, 4>;    // SDADEL
            using SCLDEL = Field<20, 4>;    // SCLDEL
            using PRESC = Field<28, 4>;    // PRESC
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
        struct I2C_TIMEOUTR : public Register<0x5c009014> {
            using TIMEOUTA = Field<0, 12>;    // TIMEOUTA
            using TIDLE = Field<12, 1>;    // TIDLE
            using TIMOUTEN = Field<15, 1>;    // TIMOUTEN
            using TIMEOUTB = Field<16, 12>;    // TIMEOUTB
            using TEXTEN = Field<31, 1>;    // TEXTEN
        };

        // Access: No wait states
        struct I2C_ISR : public Register<0x5c009018> {
            using TXE = Field<0, 1>;    // TXE
            using TXIS = Field<1, 1>;    // TXIS
            using RXNE = Field<2, 1>;    // RXNE
            using ADDR = Field<3, 1>;    // ADDR
            using NACKF = Field<4, 1>;    // NACKF
            using STOPF = Field<5, 1>;    // STOPF
            using TC = Field<6, 1>;    // TC
            using TCR = Field<7, 1>;    // TCR
            using BERR = Field<8, 1>;    // BERR
            using ARLO = Field<9, 1>;    // ARLO
            using OVR = Field<10, 1>;    // OVR
            using PECERR = Field<11, 1>;    // PECERR
            using TIMEOUT = Field<12, 1>;    // TIMEOUT
            using ALERT = Field<13, 1>;    // ALERT
            using BUSY = Field<15, 1>;    // BUSY
            using DIR = Field<16, 1>;    // DIR
            using ADDCODE = Field<17, 7>;    // ADDCODE
        };

        // Access: No wait states
        struct I2C_ICR : public RegisterWriteOnly<0x5c00901c> {
            using ADDRCF = Field<3, 1>;    // ADDRCF
            using NACKCF = Field<4, 1>;    // NACKCF
            using STOPCF = Field<5, 1>;    // STOPCF
            using BERRCF = Field<8, 1>;    // BERRCF
            using ARLOCF = Field<9, 1>;    // ARLOCF
            using OVRCF = Field<10, 1>;    // OVRCF
            using PECCF = Field<11, 1>;    // PECCF
            using TIMOUTCF = Field<12, 1>;    // TIMOUTCF
            using ALERTCF = Field<13, 1>;    // ALERTCF
        };

        // Access: No wait states
        struct I2C_PECR : public RegisterReadOnly<0x5c009020> {
            using PEC = Field<0, 8>;    // PEC
        };

        // Access: No wait states
        struct I2C_RXDR : public RegisterReadOnly<0x5c009024> {
            using RXDATA = Field<0, 8>;    // RXDATA
        };

        // Access: No wait states
        struct I2C_TXDR : public Register<0x5c009028> {
            using TXDATA = Field<0, 8>;    // TXDATA
        };

        // I2C hardware configuration register
        struct I2C_HWCFGR : public RegisterReadOnly<0x5c0093f0> {
            using SMBUS = Field<0, 4>;    // SMBUS
            using ASYN = Field<4, 4>;    // ASYN
            using WKP = Field<8, 4>;    // WKP
        };

        // I2C version register
        struct I2C_VERR : public RegisterReadOnly<0x5c0093f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // I2C identification register
        struct I2C_IPIDR : public RegisterReadOnly<0x5c0093f8> {
            using ID = Field<0, 32>;    // ID
        };

        // I2C size identification register
        struct I2C_SIDR : public RegisterReadOnly<0x5c0093fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // RTC
    struct RTC {
        // The RTC_TR is the calendar time shadow register. This register must be written in initialization mode only. Refer to Calendar initialization and configuration on page1830 and Reading the calendar on page1831. This register is write protected. The write access procedure is described in RTC register write protection on page1830. This register can be write-protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
        struct RTC_TR : public Register<0x5c004000> {
            using SU = Field<0, 4>;    // SU
            using ST = Field<4, 3>;    // ST
            using MNU = Field<8, 4>;    // MNU
            using MNT = Field<12, 3>;    // MNT
            using HU = Field<16, 4>;    // HU
            using HT = Field<20, 2>;    // HT
            using PM = Field<22, 1>;    // PM
        };

        // The RTC_DR is the calendar date shadow register. This register must be written in initialization mode only. Refer to Calendar initialization and configuration on page1830 and Reading the calendar on page1831. This register is write protected. The write access procedure is described in RTC register write protection on page1830. This register can be write-protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
        struct RTC_DR : public Register<0x5c004004> {
            using DU = Field<0, 4>;    // DU
            using DT = Field<4, 2>;    // DT
            using MU = Field<8, 4>;    // MU
            using MT = Field<12, 1>;    // MT
            using WDU = Field<13, 3>;    // WDU
            using YU = Field<16, 4>;    // YU
            using YT = Field<20, 4>;    // YT
        };

        // RTC sub second register
        struct RTC_SSR : public RegisterReadOnly<0x5c004008> {
            using SS = Field<0, 16>;    // SS
        };

        // This register is write protected. The write access procedure is described in RTC register write protection on page1830. This register can be globally protected, or each bit of this register can be individually protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
        struct RTC_ICSR : public Register<0x5c00400c> {
            using ALRAWF = Field<0, 1>;    // ALRAWF
            using ALRBWF = Field<1, 1>;    // ALRBWF
            using WUTWF = Field<2, 1>;    // WUTWF
            using SHPF = Field<3, 1>;    // SHPF
            using INITS = Field<4, 1>;    // INITS
            using RSF = Field<5, 1>;    // RSF
            using INITF = Field<6, 1>;    // INITF
            using INIT = Field<7, 1>;    // INIT
            using RECALPF = Field<16, 1>;    // RECALPF
        };

        // This register must be written in initialization mode only. The initialization must be performed in two separate write accesses. Refer to Calendar initialization and configuration on page1830. This register is write protected. The write access procedure is described in RTC register write protection on page1830. This register can be write-protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
        struct RTC_PRER : public Register<0x5c004010> {
            using PREDIV_S = Field<0, 15>;    // PREDIV_S
            using PREDIV_A = Field<16, 7>;    // PREDIV_A
        };

        // This register can be written only when WUTWF is set to 1 in RTC_ICSR. This register is write protected. The write access procedure is described in RTC register write protection on page1830. This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
        struct RTC_WUTR : public Register<0x5c004014> {
            using WUT = Field<0, 16>;    // WUT
        };

        // This register is write protected. The write access procedure is described in RTC register write protection on page1830. This register can be globally protected, or each bit of this register can be individually protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
        struct RTC_CR : public Register<0x5c004018> {
            using WUCKSEL = Field<0, 3>;    // WUCKSEL
            using TSEDGE = Field<3, 1>;    // TSEDGE
            using REFCKON = Field<4, 1>;    // REFCKON
            using BYPSHAD = Field<5, 1>;    // BYPSHAD
            using FMT = Field<6, 1>;    // FMT
            using ALRAE = Field<8, 1>;    // ALRAE
            using ALRBE = Field<9, 1>;    // ALRBE
            using WUTE = Field<10, 1>;    // WUTE
            using TSE = Field<11, 1>;    // TSE
            using ALRAIE = Field<12, 1>;    // ALRAIE
            using ALRBIE = Field<13, 1>;    // ALRBIE
            using WUTIE = Field<14, 1>;    // WUTIE
            using TSIE = Field<15, 1>;    // TSIE
            using ADD1H = Field<16, 1>;    // ADD1H
            using SUB1H = Field<17, 1>;    // SUB1H
            using BKP = Field<18, 1>;    // BKP
            using COSEL = Field<19, 1>;    // COSEL
            using POL = Field<20, 1>;    // POL
            using OSEL = Field<21, 2>;    // OSEL
            using COE = Field<23, 1>;    // COE
            using ITSE = Field<24, 1>;    // ITSE
            using TAMPTS = Field<25, 1>;    // TAMPTS
            using TAMPOE = Field<26, 1>;    // TAMPOE
            using TAMPALRM_PU = Field<29, 1>;    // TAMPALRM_PU
            using TAMPALRM_TYPE = Field<30, 1>;    // TAMPALRM_TYPE
            using OUT2EN = Field<31, 1>;    // OUT2EN
        };

        // This register can be written only when the APB access is secure.
        struct RTC_SMCR : public Register<0x5c004020> {
            using ALRADPROT = Field<0, 1>;    // ALRADPROT
            using ALRBDPROT = Field<1, 1>;    // ALRBDPROT
            using WUTDPROT = Field<2, 1>;    // WUTDPROT
            using TSDPROT = Field<3, 1>;    // TSDPROT
            using CALDPROT = Field<13, 1>;    // CALDPROT
            using INITDPROT = Field<14, 1>;    // INITDPROT
            using DECPROT = Field<15, 1>;    // DECPROT
        };

        // RTC write protection register
        struct RTC_WPR : public RegisterWriteOnly<0x5c004024> {
            using KEY = Field<0, 8>;    // KEY
        };

        // This register is write protected. The write access procedure is described in RTC register write protection on page1830. This register can be write-protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
        struct RTC_CALR : public Register<0x5c004028> {
            using CALM = Field<0, 9>;    // CALM
            using CALW16 = Field<13, 1>;    // CALW16
            using CALW8 = Field<14, 1>;    // CALW8
            using CALP = Field<15, 1>;    // CALP
        };

        // This register is write protected. The write access procedure is described in RTC register write protection on page1830. This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
        struct RTC_SHIFTR : public RegisterWriteOnly<0x5c00402c> {
            using SUBFS = Field<0, 15>;    // SUBFS
            using ADD1S = Field<31, 1>;    // ADD1S
        };

        // The content of this register is valid only when TSF is set to 1 in RTC_SR. It is cleared when TSF bit is reset. This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
        struct RTC_TSTR : public RegisterReadOnly<0x5c004030> {
            using SU = Field<0, 4>;    // SU
            using ST = Field<4, 3>;    // ST
            using MNU = Field<8, 4>;    // MNU
            using MNT = Field<12, 3>;    // MNT
            using HU = Field<16, 4>;    // HU
            using HT = Field<20, 2>;    // HT
            using PM = Field<22, 1>;    // PM
        };

        // The content of this register is valid only when TSF is set to 1 in RTC_SR. It is cleared when TSF bit is reset. This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
        struct RTC_TSDR : public RegisterReadOnly<0x5c004034> {
            using DU = Field<0, 4>;    // DU
            using DT = Field<4, 2>;    // DT
            using MU = Field<8, 4>;    // MU
            using MT = Field<12, 1>;    // MT
            using WDU = Field<13, 3>;    // WDU
        };

        // The content of this register is valid only when TSF is set to 1 in RTC_SR. It is cleared when the TSF bit is reset. This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
        struct RTC_TSSSR : public RegisterReadOnly<0x5c004038> {
            using SS = Field<0, 16>;    // SS
        };

        // This register can be written only when ALRAWF is set to 1 in RTC_ICSR, or in initialization mode. This register is write protected. The write access procedure is described in RTC register write protection on page1830. This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
        struct RTC_ALRMAR : public Register<0x5c004040> {
            using SU = Field<0, 4>;    // SU
            using ST = Field<4, 3>;    // ST
            using MSK1 = Field<7, 1>;    // MSK1
            using MNU = Field<8, 4>;    // MNU
            using MNT = Field<12, 3>;    // MNT
            using MSK2 = Field<15, 1>;    // MSK2
            using HU = Field<16, 4>;    // HU
            using HT = Field<20, 2>;    // HT
            using PM = Field<22, 1>;    // PM
            using MSK3 = Field<23, 1>;    // MSK3
            using DU = Field<24, 4>;    // DU
            using DT = Field<28, 2>;    // DT
            using WDSEL = Field<30, 1>;    // WDSEL
            using MSK4 = Field<31, 1>;    // MSK4
        };

        // This register can be written only when ALRAWF is set to 1 in RTC_ICSR, or in initialization mode. This register is write protected. The write access procedure is described in RTC register write protection on page1830. This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
        struct RTC_ALRMASSR : public Register<0x5c004044> {
            using SS = Field<0, 15>;    // SS
            using MASKSS = Field<24, 4>;    // MASKSS
        };

        // This register can be written only when ALRBWF is set to 1 in RTC_ICSR, or in initialization mode. This register is write protected. The write access procedure is described in RTC register write protection on page1830. This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
        struct RTC_ALRMBR : public Register<0x5c004048> {
            using SU = Field<0, 4>;    // SU
            using ST = Field<4, 3>;    // ST
            using MSK1 = Field<7, 1>;    // MSK1
            using MNU = Field<8, 4>;    // MNU
            using MNT = Field<12, 3>;    // MNT
            using MSK2 = Field<15, 1>;    // MSK2
            using HU = Field<16, 4>;    // HU
            using HT = Field<20, 2>;    // HT
            using PM = Field<22, 1>;    // PM
            using MSK3 = Field<23, 1>;    // MSK3
            using DU = Field<24, 4>;    // DU
            using DT = Field<28, 2>;    // DT
            using WDSEL = Field<30, 1>;    // WDSEL
            using MSK4 = Field<31, 1>;    // MSK4
        };

        // This register can be written only when ALRBE is reset in RTC_CR register, or in initialization mode. This register is write protected.The write access procedure is described in Section: RTC register write protection. This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
        struct RTC_ALRMBSSR : public Register<0x5c00404c> {
            using SS = Field<0, 15>;    // SS
            using MASKSS = Field<24, 4>;    // MASKSS
        };

        // This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
        struct RTC_SR : public RegisterReadOnly<0x5c004050> {
            using ALRAF = Field<0, 1>;    // ALRAF
            using ALRBF = Field<1, 1>;    // ALRBF
            using WUTF = Field<2, 1>;    // WUTF
            using TSF = Field<3, 1>;    // TSF
            using TSOVF = Field<4, 1>;    // TSOVF
            using ITSF = Field<5, 1>;    // ITSF
        };

        // RTC non-secure masked interrupt status register
        struct RTC_MISR : public RegisterReadOnly<0x5c004054> {
            using ALRAMF = Field<0, 1>;    // ALRAMF
            using ALRBMF = Field<1, 1>;    // ALRBMF
            using WUTMF = Field<2, 1>;    // WUTMF
            using TSMF = Field<3, 1>;    // TSMF
            using TSOVMF = Field<4, 1>;    // TSOVMF
            using ITSMF = Field<5, 1>;    // ITSMF
        };

        // This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
        struct RTC_SMISR : public RegisterReadOnly<0x5c004058> {
            using ALRAMF = Field<0, 1>;    // ALRAMF
            using ALRBMF = Field<1, 1>;    // ALRBMF
            using WUTMF = Field<2, 1>;    // WUTMF
            using TSMF = Field<3, 1>;    // TSMF
            using TSOVMF = Field<4, 1>;    // TSOVMF
            using ITSMF = Field<5, 1>;    // ITSMF
        };

        // This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
        struct RTC_SCR : public RegisterWriteOnly<0x5c00405c> {
            using CALRAF = Field<0, 1>;    // CALRAF
            using CALRBF = Field<1, 1>;    // CALRBF
            using CWUTF = Field<2, 1>;    // CWUTF
            using CTSF = Field<3, 1>;    // CTSF
            using CTSOVF = Field<4, 1>;    // CTSOVF
            using CITSF = Field<5, 1>;    // CITSF
        };

        // RTC configuration register
        struct RTC_CFGR : public Register<0x5c004060> {
            using OUT2_RMP = Field<0, 1>;    // OUT2_RMP
            using LSCOEN = Field<1, 2>;    // LSCOEN
        };

        // RTC hardware configuration register
        struct RTC_HWCFGR : public RegisterReadOnly<0x5c0043f0> {
            using ALARMB = Field<0, 4>;    // ALARMB
            using WAKEUP = Field<4, 4>;    // WAKEUP
            using SMOOTH_CALIB = Field<8, 4>;    // SMOOTH_CALIB
            using TIMESTAMP = Field<12, 4>;    // TIMESTAMP
            using OPTIONREG_OUT = Field<16, 8>;    // OPTIONREG_OUT
            using TRUST_ZONE = Field<24, 4>;    // TRUST_ZONE
        };

        // RTC version register
        struct RTC_VERR : public RegisterReadOnly<0x5c0043f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // RTC identification register
        struct RTC_IPIDR : public RegisterReadOnly<0x5c0043f8> {
            using ID = Field<0, 32>;    // ID
        };

        // RTC size identification register
        struct RTC_SIDR : public RegisterReadOnly<0x5c0043fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // TAMP
    struct TAMP {
        // This register can be protected against non-secure access. Refer to Section51.3.3: TAMP secure protection modes.
        struct TAMP_CR1 : public Register<0x5c00a000> {
            using TAMP1E = Field<0, 1>;    // TAMP1E
            using TAMP2E = Field<1, 1>;    // TAMP2E
            using TAMP3E = Field<2, 1>;    // TAMP3E
            using ITAMP1E = Field<16, 1>;    // ITAMP1E
            using ITAMP2E = Field<17, 1>;    // ITAMP2E
            using ITAMP3E = Field<18, 1>;    // ITAMP3E
            using ITAMP4E = Field<19, 1>;    // ITAMP4E
            using ITAMP5E = Field<20, 1>;    // ITAMP5E
            using ITAMP8E = Field<23, 1>;    // ITAMP8E
        };

        // This register can be protected against non-secure access. Refer to Section51.3.3: TAMP secure protection modes.
        struct TAMP_CR2 : public Register<0x5c00a004> {
            using TAMP1NOER = Field<0, 1>;    // TAMP1NOER
            using TAMP2NOER = Field<1, 1>;    // TAMP2NOER
            using TAMP3NOER = Field<2, 1>;    // TAMP3NOER
            using TAMP1MSK = Field<16, 1>;    // TAMP1MSK
            using TAMP2MSK = Field<17, 1>;    // TAMP2MSK
            using TAMP3MSK = Field<18, 1>;    // TAMP3MSK
            using TAMP1TRG = Field<24, 1>;    // TAMP1TRG
            using TAMP2TRG = Field<25, 1>;    // TAMP2TRG
            using TAMP3TRG = Field<26, 1>;    // TAMP3TRG
        };

        // This register can be protected against non-secure access. Refer to Section51.3.3: TAMP secure protection modes.
        struct TAMP_FLTCR : public Register<0x5c00a00c> {
            using TAMPFREQ = Field<0, 3>;    // TAMPFREQ
            using TAMPFLT = Field<3, 2>;    // TAMPFLT
            using TAMPPRCH = Field<5, 2>;    // TAMPPRCH
            using TAMPPUDIS = Field<7, 1>;    // TAMPPUDIS
        };

        // This register can be protected against non-secure access. Refer to Section51.3.3: TAMP secure protection modes.
        struct TAMP_ATCR1 : public Register<0x5c00a010> {
            using TAMP1AM = Field<0, 1>;    // TAMP1AM
            using TAMP2AM = Field<1, 1>;    // TAMP2AM
            using TAMP3AM = Field<2, 1>;    // TAMP3AM
            using ATOSEL1 = Field<8, 2>;    // ATOSEL1
            using ATOSEL2 = Field<10, 2>;    // ATOSEL2
            using ATOSEL3 = Field<12, 2>;    // ATOSEL3
            using ATCKSEL = Field<16, 3>;    // ATCKSEL
            using ATPER = Field<24, 3>;    // ATPER
            using ATOSHARE = Field<30, 1>;    // ATOSHARE
            using FLTEN = Field<31, 1>;    // FLTEN
        };

        // This register can be protected against non-secure access. Refer to Section51.3.3: TAMP secure protection modes.
        struct TAMP_ATSEEDR : public RegisterWriteOnly<0x5c00a014> {
            using SEED = Field<0, 32>;    // SEED
        };

        // This register can be protected against non-secure access. Refer to Section51.3.3: TAMP secure protection modes.
        struct TAMP_ATOR : public RegisterReadOnly<0x5c00a018> {
            using PRNG = Field<0, 8>;    // PRNG
            using SEEDF = Field<14, 1>;    // SEEDF
            using INITS = Field<15, 1>;    // INITS
        };

        // This register can be written only when the APB access is secure.
        struct TAMP_SMCR : public Register<0x5c00a020> {
            using BKPRWDPROT = Field<0, 8>;    // BKPRWDPROT
            using BKPWDPROT = Field<16, 8>;    // BKPWDPROT
            using TAMPDPROT = Field<31, 1>;    // TAMPDPROT
        };

        // This register can be protected against non-secure access. Refer to Section51.3.3: TAMP secure protection modes.
        struct TAMP_IER : public Register<0x5c00a02c> {
            using TAMP1IE = Field<0, 1>;    // TAMP1IE
            using TAMP2IE = Field<1, 1>;    // TAMP2IE
            using TAMP3IE = Field<2, 1>;    // TAMP3IE
            using ITAMP1IE = Field<16, 1>;    // ITAMP1IE
            using ITAMP2IE = Field<17, 1>;    // ITAMP2IE
            using ITAMP3IE = Field<18, 1>;    // ITAMP3IE
            using ITAMP4IE = Field<19, 1>;    // ITAMP4IE
            using ITAMP5IE = Field<20, 1>;    // ITAMP5IE
            using ITAMP8IE = Field<23, 1>;    // ITAMP8IE
        };

        // This register can be protected against non-secure access. Refer to Section51.3.3: TAMP secure protection modes.
        struct TAMP_SR : public RegisterReadOnly<0x5c00a030> {
            using TAMP1F = Field<0, 1>;    // TAMP1F
            using TAMP2F = Field<1, 1>;    // TAMP2F
            using TAMP3F = Field<2, 1>;    // TAMP3F
            using ITAMP1F = Field<16, 1>;    // ITAMP1F
            using ITAMP2F = Field<17, 1>;    // ITAMP2F
            using ITAMP3F = Field<18, 1>;    // ITAMP3F
            using ITAMP4F = Field<19, 1>;    // ITAMP4F
            using ITAMP5F = Field<20, 1>;    // ITAMP5F
            using ITAMP8F = Field<23, 1>;    // ITAMP8F
        };

        // TAMP non-secure masked interrupt status register
        struct TAMP_MISR : public RegisterReadOnly<0x5c00a034> {
            using TAMP1MF = Field<0, 1>;    // TAMP1MF
            using TAMP2MF = Field<1, 1>;    // TAMP2MF
            using TAMP3MF = Field<2, 1>;    // TAMP3MF
            using ITAMP1MF = Field<16, 1>;    // ITAMP1MF
            using ITAMP2MF = Field<17, 1>;    // ITAMP2MF
            using ITAMP3MF = Field<18, 1>;    // ITAMP3MF
            using ITAMP4MF = Field<19, 1>;    // ITAMP4MF
            using ITAMP5MF = Field<20, 1>;    // ITAMP5MF
            using ITAMP8MF = Field<23, 1>;    // ITAMP8MF
        };

        // TAMP secure masked interrupt status register
        struct TAMP_SMISR : public RegisterReadOnly<0x5c00a038> {
            using TAMP1MF = Field<0, 1>;    // TAMP1MF
            using TAMP2MF = Field<1, 1>;    // TAMP2MF
            using TAMP3MF = Field<2, 1>;    // TAMP3MF
            using ITAMP1MF = Field<16, 1>;    // ITAMP1MF
            using ITAMP2MF = Field<17, 1>;    // ITAMP2MF
            using ITAMP3MF = Field<18, 1>;    // ITAMP3MF
            using ITAMP4MF = Field<19, 1>;    // ITAMP4MF
            using ITAMP5MF = Field<20, 1>;    // ITAMP5MF
            using ITAMP8MF = Field<23, 1>;    // ITAMP8MF
        };

        // TAMP status clear register
        struct TAMP_SCR : public RegisterWriteOnly<0x5c00a03c> {
            using CTAMP1F = Field<0, 1>;    // CTAMP1F
            using CTAMP2F = Field<1, 1>;    // CTAMP2F
            using CTAMP3F = Field<2, 1>;    // CTAMP3F
            using CITAMP1F = Field<16, 1>;    // CITAMP1F
            using CITAMP2F = Field<17, 1>;    // CITAMP2F
            using CITAMP3F = Field<18, 1>;    // CITAMP3F
            using CITAMP4F = Field<19, 1>;    // CITAMP4F
            using CITAMP5F = Field<20, 1>;    // CITAMP5F
            using CITAMP8F = Field<23, 1>;    // CITAMP8F
        };

        // TAMP monotonic counter register
        struct TAMP_COUNTR : public RegisterReadOnly<0x5c00a040> {
            using COUNT = Field<0, 32>;    // COUNT
        };

        // TAMP configuration register
        struct TAMP_CFGR : public Register<0x5c00a050> {
            using OUT3_RMP = Field<0, 1>;    // OUT3_RMP
        };

        // TAMP backup 0 register
        struct TAMP_BKP0R : public Register<0x5c00a100> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 1 register
        struct TAMP_BKP1R : public Register<0x5c00a104> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 2 register
        struct TAMP_BKP2R : public Register<0x5c00a108> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 3 register
        struct TAMP_BKP3R : public Register<0x5c00a10c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 4 register
        struct TAMP_BKP4R : public Register<0x5c00a110> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 5 register
        struct TAMP_BKP5R : public Register<0x5c00a114> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 6 register
        struct TAMP_BKP6R : public Register<0x5c00a118> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 7 register
        struct TAMP_BKP7R : public Register<0x5c00a11c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 8 register
        struct TAMP_BKP8R : public Register<0x5c00a120> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 9 register
        struct TAMP_BKP9R : public Register<0x5c00a124> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 10 register
        struct TAMP_BKP10R : public Register<0x5c00a128> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 11 register
        struct TAMP_BKP11R : public Register<0x5c00a12c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 12 register
        struct TAMP_BKP12R : public Register<0x5c00a130> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 13 register
        struct TAMP_BKP13R : public Register<0x5c00a134> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 14 register
        struct TAMP_BKP14R : public Register<0x5c00a138> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 15 register
        struct TAMP_BKP15R : public Register<0x5c00a13c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 16 register
        struct TAMP_BKP16R : public Register<0x5c00a140> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 17 register
        struct TAMP_BKP17R : public Register<0x5c00a144> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 18 register
        struct TAMP_BKP18R : public Register<0x5c00a148> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 19 register
        struct TAMP_BKP19R : public Register<0x5c00a14c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 20 register
        struct TAMP_BKP20R : public Register<0x5c00a150> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 21 register
        struct TAMP_BKP21R : public Register<0x5c00a154> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 22 register
        struct TAMP_BKP22R : public Register<0x5c00a158> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 23 register
        struct TAMP_BKP23R : public Register<0x5c00a15c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 24 register
        struct TAMP_BKP24R : public Register<0x5c00a160> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 25 register
        struct TAMP_BKP25R : public Register<0x5c00a164> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 26 register
        struct TAMP_BKP26R : public Register<0x5c00a168> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 27 register
        struct TAMP_BKP27R : public Register<0x5c00a16c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 28 register
        struct TAMP_BKP28R : public Register<0x5c00a170> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 29 register
        struct TAMP_BKP29R : public Register<0x5c00a174> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 30 register
        struct TAMP_BKP30R : public Register<0x5c00a178> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup 31 register
        struct TAMP_BKP31R : public Register<0x5c00a17c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP hardware configuration register 2
        struct TAMP_HWCFGR2 : public RegisterReadOnly<0x5c00a3ec> {
            using OPTIONREG_OUT = Field<0, 8>;    // OPTIONREG_OUT
            using TRUST_ZONE = Field<8, 4>;    // TRUST_ZONE
        };

        // TAMP hardware configuration register 1
        struct TAMP_HWCFGR1 : public RegisterReadOnly<0x5c00a3f0> {
            using BACKUP_REGS = Field<0, 8>;    // BACKUP_REGS
            using TAMPER = Field<8, 4>;    // TAMPER
            using ACTIVE_TAMPER = Field<12, 4>;    // ACTIVE_TAMPER
            using INT_TAMPER = Field<16, 16>;    // INT_TAMPER
        };

        // TAMP version register
        struct TAMP_VERR : public RegisterReadOnly<0x5c00a3f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // TAMP identification register
        struct TAMP_IPIDR : public RegisterReadOnly<0x5c00a3f8> {
            using ID = Field<0, 32>;    // ID
        };

        // TAMP size identification register
        struct TAMP_SIDR : public RegisterReadOnly<0x5c00a3fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // STGENC
    struct STGENC {
        // STGENC control register
        struct STGENC_CNTCR : public Register<0x5c008000> {
            using EN = Field<0, 1>;    // EN
            using HLTDBG = Field<1, 1>;    // HLTDBG
        };

        // STGENC status register
        struct STGENC_CNTSR : public RegisterReadOnly<0x5c008004> {
            using EN = Field<0, 1>;    // EN
            using HLTDBG = Field<1, 1>;    // HLTDBG
        };

        // the control interface must clear the STGENC_CNTCR.EN bit before writing to this register.
        struct STGENC_CNTCVL : public Register<0x5c008008> {
            using CNTCVL_L_32 = Field<0, 32>;    // CNTCVL_L_32
        };

        // the control interface must clear the STGENC_CNTCR.EN bit before writing to this register.
        struct STGENC_CNTCVU : public Register<0x5c00800c> {
            using CNTCVU_U_32 = Field<0, 32>;    // CNTCVU_U_32
        };

        // the control interface must clear the STGEN_CNTCR.EN bit before writing to this register.
        struct STGENC_CNTFID0 : public Register<0x5c008020> {
            using FREQ = Field<0, 32>;    // FREQ
        };

        // STGENC peripheral ID4 register
        struct STGENC_PIDR4 : public RegisterReadOnly<0x5c008fd0> {
            using DES_2 = Field<0, 4>;    // DES_2
            using SIZE = Field<4, 4>;    // SIZE
        };

        // STGENC peripheral ID5 register
        struct STGENC_PIDR5 : public RegisterReadOnly<0x5c008fd4> {
            using PIDR5 = Field<0, 32>;    // PIDR5
        };

        // STGENC peripheral ID6 register
        struct STGENC_PIDR6 : public RegisterReadOnly<0x5c008fd8> {
            using PIDR6 = Field<0, 32>;    // PIDR6
        };

        // STGENC peripheral ID7 register
        struct STGENC_PIDR7 : public RegisterReadOnly<0x5c008fdc> {
            using PIDR7 = Field<0, 32>;    // PIDR7
        };

        // STGENC peripheral ID0 register
        struct STGENC_PIDR0 : public RegisterReadOnly<0x5c008fe0> {
            using PART_0 = Field<0, 8>;    // PART_0
        };

        // STGENC peripheral ID1 register
        struct STGENC_PIDR1 : public RegisterReadOnly<0x5c008fe4> {
            using PART_1 = Field<0, 4>;    // PART_1
            using DES_0 = Field<4, 4>;    // DES_0
        };

        // STGENC peripheral ID2 register
        struct STGENC_PIDR2 : public RegisterReadOnly<0x5c008fe8> {
            using DES_1 = Field<0, 3>;    // DES_1
            using JEDEC = Field<3, 1>;    // JEDEC
            using REVISION = Field<4, 4>;    // REVISION
        };

        // STGENC peripheral ID3 register
        struct STGENC_PIDR3 : public RegisterReadOnly<0x5c008fec> {
            using CMOD = Field<0, 4>;    // CMOD
            using REVAND = Field<4, 4>;    // REVAND
        };

        // STGENC component ID0 register
        struct STGENC_CIDR0 : public RegisterReadOnly<0x5c008ff0> {
            using PRMBL_0 = Field<0, 8>;    // PRMBL_0
        };

        // STGENC component ID1 register
        struct STGENC_CIDR1 : public RegisterReadOnly<0x5c008ff4> {
            using PRMBL_1 = Field<0, 4>;    // PRMBL_1
            using CLASS = Field<4, 4>;    // CLASS
        };

        // STGENC component ID2 register
        struct STGENC_CIDR2 : public RegisterReadOnly<0x5c008ff8> {
            using PRMBL_2 = Field<0, 8>;    // PRMBL_2
        };

        // STGENC component ID3 register
        struct STGENC_CIDR3 : public RegisterReadOnly<0x5c008ffc> {
            using PRMBL_3 = Field<0, 8>;    // PRMBL_3
        };

    };

    // STGENR
    struct STGENR {
        // the control interface must clear the STGEN_CNTCR.EN bit before writing to this register.
        struct STGENR_CNTCVL : public RegisterReadOnly<0x5a005000> {
            using CNTCVL_L_32 = Field<0, 32>;    // CNTCVL_L_32
        };

        // the control interface must clear the STGEN_CNTCR.EN bit before writing to this register.
        struct STGENR_CNTCVU : public RegisterReadOnly<0x5a005004> {
            using CNTCVU_U_32 = Field<0, 32>;    // CNTCVU_U_32
        };

        // STGENR peripheral ID4 register
        struct STGENR_PIDR4 : public RegisterReadOnly<0x5a005fd0> {
            using DES_2 = Field<0, 4>;    // DES_2
            using SIZE = Field<4, 4>;    // SIZE
        };

        // STGENR peripheral ID5 register
        struct STGENR_PIDR5 : public RegisterReadOnly<0x5a005fd4> {
            using PIDR5 = Field<0, 32>;    // PIDR5
        };

        // STGENR peripheral ID6 register
        struct STGENR_PIDR6 : public RegisterReadOnly<0x5a005fd8> {
            using PIDR6 = Field<0, 32>;    // PIDR6
        };

        // STGENR peripheral ID7 register
        struct STGENR_PIDR7 : public RegisterReadOnly<0x5a005fdc> {
            using PIDR7 = Field<0, 32>;    // PIDR7
        };

        // STGENR peripheral ID0 register
        struct STGENR_PIDR0 : public RegisterReadOnly<0x5a005fe0> {
            using PART_0 = Field<0, 8>;    // PART_0
        };

        // STGENR peripheral ID1 register
        struct STGENR_PIDR1 : public RegisterReadOnly<0x5a005fe4> {
            using PART_1 = Field<0, 4>;    // PART_1
            using DES_0 = Field<4, 4>;    // DES_0
        };

        // STGENR peripheral ID2 register
        struct STGENR_PIDR2 : public RegisterReadOnly<0x5a005fe8> {
            using DES_1 = Field<0, 3>;    // DES_1
            using JEDEC = Field<3, 1>;    // JEDEC
            using REVISION = Field<4, 4>;    // REVISION
        };

        // STGENR peripheral ID3 register
        struct STGENR_PIDR3 : public RegisterReadOnly<0x5a005fec> {
            using CMOD = Field<0, 4>;    // CMOD
            using REVAND = Field<4, 4>;    // REVAND
        };

        // STGENR component ID0 register
        struct STGENR_CIDR0 : public RegisterReadOnly<0x5a005ff0> {
            using PRMBL_0 = Field<0, 8>;    // PRMBL_0
        };

        // STGENR component ID1 register
        struct STGENR_CIDR1 : public RegisterReadOnly<0x5a005ff4> {
            using PRMBL_1 = Field<0, 4>;    // PRMBL_1
            using CLASS = Field<4, 4>;    // CLASS
        };

        // STGENR component ID2 register
        struct STGENR_CIDR2 : public RegisterReadOnly<0x5a005ff8> {
            using PRMBL_2 = Field<0, 8>;    // PRMBL_2
        };

        // STGENR component ID3 register
        struct STGENR_CIDR3 : public RegisterReadOnly<0x5a005ffc> {
            using PRMBL_3 = Field<0, 8>;    // PRMBL_3
        };

    };

    // ETZPC
    struct ETZPC {
        // ETZPC ROM secure size definition
        struct ETZPC_TZMA0_SIZE : public Register<0x5c007000> {
            using R0SIZE = Field<0, 10>;    // R0SIZE
            using LOCK = Field<31, 1>;    // LOCK
        };

        // ETZPC RAM secure size definition
        struct ETZPC_TZMA1_SIZE : public Register<0x5c007004> {
            using R0SIZE = Field<0, 10>;    // R0SIZE
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Register reset values
        struct ETZPC_DECPROT0 : public Register<0x5c007010> {
            using DECPROT0 = Field<0, 2>;    // DECPROT0
            using DECPROT1 = Field<2, 2>;    // DECPROT1
            using DECPROT2 = Field<4, 2>;    // DECPROT2
            using DECPROT3 = Field<6, 2>;    // DECPROT3
            using DECPROT4 = Field<8, 2>;    // DECPROT4
            using DECPROT5 = Field<10, 2>;    // DECPROT5
            using DECPROT6 = Field<12, 2>;    // DECPROT6
            using DECPROT7 = Field<14, 2>;    // DECPROT7
            using DECPROT8 = Field<16, 2>;    // DECPROT8
            using DECPROT9 = Field<18, 2>;    // DECPROT9
            using DECPROT10 = Field<20, 2>;    // DECPROT10
            using DECPROT11 = Field<22, 2>;    // DECPROT11
            using DECPROT12 = Field<24, 2>;    // DECPROT12
            using DECPROT13 = Field<26, 2>;    // DECPROT13
            using DECPROT14 = Field<28, 2>;    // DECPROT14
            using DECPROT15 = Field<30, 2>;    // DECPROT15
        };

        // Register reset values
        struct ETZPC_DECPROT1 : public Register<0x5c007014> {
            using DECPROT0 = Field<0, 2>;    // DECPROT0
            using DECPROT1 = Field<2, 2>;    // DECPROT1
            using DECPROT2 = Field<4, 2>;    // DECPROT2
            using DECPROT3 = Field<6, 2>;    // DECPROT3
            using DECPROT4 = Field<8, 2>;    // DECPROT4
            using DECPROT5 = Field<10, 2>;    // DECPROT5
            using DECPROT6 = Field<12, 2>;    // DECPROT6
            using DECPROT7 = Field<14, 2>;    // DECPROT7
            using DECPROT8 = Field<16, 2>;    // DECPROT8
            using DECPROT9 = Field<18, 2>;    // DECPROT9
            using DECPROT10 = Field<20, 2>;    // DECPROT10
            using DECPROT11 = Field<22, 2>;    // DECPROT11
            using DECPROT12 = Field<24, 2>;    // DECPROT12
            using DECPROT13 = Field<26, 2>;    // DECPROT13
            using DECPROT14 = Field<28, 2>;    // DECPROT14
            using DECPROT15 = Field<30, 2>;    // DECPROT15
        };

        // Register reset values
        struct ETZPC_DECPROT2 : public Register<0x5c007018> {
            using DECPROT0 = Field<0, 2>;    // DECPROT0
            using DECPROT1 = Field<2, 2>;    // DECPROT1
            using DECPROT2 = Field<4, 2>;    // DECPROT2
            using DECPROT3 = Field<6, 2>;    // DECPROT3
            using DECPROT4 = Field<8, 2>;    // DECPROT4
            using DECPROT5 = Field<10, 2>;    // DECPROT5
            using DECPROT6 = Field<12, 2>;    // DECPROT6
            using DECPROT7 = Field<14, 2>;    // DECPROT7
            using DECPROT8 = Field<16, 2>;    // DECPROT8
            using DECPROT9 = Field<18, 2>;    // DECPROT9
            using DECPROT10 = Field<20, 2>;    // DECPROT10
            using DECPROT11 = Field<22, 2>;    // DECPROT11
            using DECPROT12 = Field<24, 2>;    // DECPROT12
            using DECPROT13 = Field<26, 2>;    // DECPROT13
            using DECPROT14 = Field<28, 2>;    // DECPROT14
            using DECPROT15 = Field<30, 2>;    // DECPROT15
        };

        // Register reset values
        struct ETZPC_DECPROT3 : public Register<0x5c00701c> {
            using DECPROT0 = Field<0, 2>;    // DECPROT0
            using DECPROT1 = Field<2, 2>;    // DECPROT1
            using DECPROT2 = Field<4, 2>;    // DECPROT2
            using DECPROT3 = Field<6, 2>;    // DECPROT3
            using DECPROT4 = Field<8, 2>;    // DECPROT4
            using DECPROT5 = Field<10, 2>;    // DECPROT5
            using DECPROT6 = Field<12, 2>;    // DECPROT6
            using DECPROT7 = Field<14, 2>;    // DECPROT7
            using DECPROT8 = Field<16, 2>;    // DECPROT8
            using DECPROT9 = Field<18, 2>;    // DECPROT9
            using DECPROT10 = Field<20, 2>;    // DECPROT10
            using DECPROT11 = Field<22, 2>;    // DECPROT11
            using DECPROT12 = Field<24, 2>;    // DECPROT12
            using DECPROT13 = Field<26, 2>;    // DECPROT13
            using DECPROT14 = Field<28, 2>;    // DECPROT14
            using DECPROT15 = Field<30, 2>;    // DECPROT15
        };

        // Register reset values
        struct ETZPC_DECPROT4 : public Register<0x5c007020> {
            using DECPROT0 = Field<0, 2>;    // DECPROT0
            using DECPROT1 = Field<2, 2>;    // DECPROT1
            using DECPROT2 = Field<4, 2>;    // DECPROT2
            using DECPROT3 = Field<6, 2>;    // DECPROT3
            using DECPROT4 = Field<8, 2>;    // DECPROT4
            using DECPROT5 = Field<10, 2>;    // DECPROT5
            using DECPROT6 = Field<12, 2>;    // DECPROT6
            using DECPROT7 = Field<14, 2>;    // DECPROT7
            using DECPROT8 = Field<16, 2>;    // DECPROT8
            using DECPROT9 = Field<18, 2>;    // DECPROT9
            using DECPROT10 = Field<20, 2>;    // DECPROT10
            using DECPROT11 = Field<22, 2>;    // DECPROT11
            using DECPROT12 = Field<24, 2>;    // DECPROT12
            using DECPROT13 = Field<26, 2>;    // DECPROT13
            using DECPROT14 = Field<28, 2>;    // DECPROT14
            using DECPROT15 = Field<30, 2>;    // DECPROT15
        };

        // Register reset values
        struct ETZPC_DECPROT5 : public Register<0x5c007024> {
            using DECPROT0 = Field<0, 2>;    // DECPROT0
            using DECPROT1 = Field<2, 2>;    // DECPROT1
            using DECPROT2 = Field<4, 2>;    // DECPROT2
            using DECPROT3 = Field<6, 2>;    // DECPROT3
            using DECPROT4 = Field<8, 2>;    // DECPROT4
            using DECPROT5 = Field<10, 2>;    // DECPROT5
            using DECPROT6 = Field<12, 2>;    // DECPROT6
            using DECPROT7 = Field<14, 2>;    // DECPROT7
            using DECPROT8 = Field<16, 2>;    // DECPROT8
            using DECPROT9 = Field<18, 2>;    // DECPROT9
            using DECPROT10 = Field<20, 2>;    // DECPROT10
            using DECPROT11 = Field<22, 2>;    // DECPROT11
            using DECPROT12 = Field<24, 2>;    // DECPROT12
            using DECPROT13 = Field<26, 2>;    // DECPROT13
            using DECPROT14 = Field<28, 2>;    // DECPROT14
            using DECPROT15 = Field<30, 2>;    // DECPROT15
        };

        // ETZPC decprot lock 0 register
        struct ETZPC_DECPROT_LOCK0 : public Register<0x5c007030> {
            using LOCK0 = Field<0, 1>;    // LOCK0
            using LOCK1 = Field<1, 1>;    // LOCK1
            using LOCK2 = Field<2, 1>;    // LOCK2
            using LOCK3 = Field<3, 1>;    // LOCK3
            using LOCK4 = Field<4, 1>;    // LOCK4
            using LOCK5 = Field<5, 1>;    // LOCK5
            using LOCK6 = Field<6, 1>;    // LOCK6
            using LOCK7 = Field<7, 1>;    // LOCK7
            using LOCK8 = Field<8, 1>;    // LOCK8
            using LOCK9 = Field<9, 1>;    // LOCK9
            using LOCK10 = Field<10, 1>;    // LOCK10
            using LOCK11 = Field<11, 1>;    // LOCK11
            using LOCK12 = Field<12, 1>;    // LOCK12
            using LOCK13 = Field<13, 1>;    // LOCK13
            using LOCK14 = Field<14, 1>;    // LOCK14
            using LOCK15 = Field<15, 1>;    // LOCK15
            using LOCK16 = Field<16, 1>;    // LOCK16
            using LOCK17 = Field<17, 1>;    // LOCK17
            using LOCK18 = Field<18, 1>;    // LOCK18
            using LOCK19 = Field<19, 1>;    // LOCK19
            using LOCK20 = Field<20, 1>;    // LOCK20
            using LOCK21 = Field<21, 1>;    // LOCK21
            using LOCK22 = Field<22, 1>;    // LOCK22
            using LOCK23 = Field<23, 1>;    // LOCK23
            using LOCK24 = Field<24, 1>;    // LOCK24
            using LOCK25 = Field<25, 1>;    // LOCK25
            using LOCK26 = Field<26, 1>;    // LOCK26
            using LOCK27 = Field<27, 1>;    // LOCK27
            using LOCK28 = Field<28, 1>;    // LOCK28
            using LOCK29 = Field<29, 1>;    // LOCK29
            using LOCK30 = Field<30, 1>;    // LOCK30
            using LOCK31 = Field<31, 1>;    // LOCK31
        };

        // ETZPC decprot lock 1 register
        struct ETZPC_DECPROT_LOCK1 : public Register<0x5c007034> {
            using LOCK0 = Field<0, 1>;    // LOCK0
            using LOCK1 = Field<1, 1>;    // LOCK1
            using LOCK2 = Field<2, 1>;    // LOCK2
            using LOCK3 = Field<3, 1>;    // LOCK3
            using LOCK4 = Field<4, 1>;    // LOCK4
            using LOCK5 = Field<5, 1>;    // LOCK5
            using LOCK6 = Field<6, 1>;    // LOCK6
            using LOCK7 = Field<7, 1>;    // LOCK7
            using LOCK8 = Field<8, 1>;    // LOCK8
            using LOCK9 = Field<9, 1>;    // LOCK9
            using LOCK10 = Field<10, 1>;    // LOCK10
            using LOCK11 = Field<11, 1>;    // LOCK11
            using LOCK12 = Field<12, 1>;    // LOCK12
            using LOCK13 = Field<13, 1>;    // LOCK13
            using LOCK14 = Field<14, 1>;    // LOCK14
            using LOCK15 = Field<15, 1>;    // LOCK15
            using LOCK16 = Field<16, 1>;    // LOCK16
            using LOCK17 = Field<17, 1>;    // LOCK17
            using LOCK18 = Field<18, 1>;    // LOCK18
            using LOCK19 = Field<19, 1>;    // LOCK19
            using LOCK20 = Field<20, 1>;    // LOCK20
            using LOCK21 = Field<21, 1>;    // LOCK21
            using LOCK22 = Field<22, 1>;    // LOCK22
            using LOCK23 = Field<23, 1>;    // LOCK23
            using LOCK24 = Field<24, 1>;    // LOCK24
            using LOCK25 = Field<25, 1>;    // LOCK25
            using LOCK26 = Field<26, 1>;    // LOCK26
            using LOCK27 = Field<27, 1>;    // LOCK27
            using LOCK28 = Field<28, 1>;    // LOCK28
            using LOCK29 = Field<29, 1>;    // LOCK29
            using LOCK30 = Field<30, 1>;    // LOCK30
            using LOCK31 = Field<31, 1>;    // LOCK31
        };

        // ETZPC decprot lock 2 register
        struct ETZPC_DECPROT_LOCK2 : public Register<0x5c007038> {
            using LOCK0 = Field<0, 1>;    // LOCK0
            using LOCK1 = Field<1, 1>;    // LOCK1
            using LOCK2 = Field<2, 1>;    // LOCK2
            using LOCK3 = Field<3, 1>;    // LOCK3
            using LOCK4 = Field<4, 1>;    // LOCK4
            using LOCK5 = Field<5, 1>;    // LOCK5
            using LOCK6 = Field<6, 1>;    // LOCK6
            using LOCK7 = Field<7, 1>;    // LOCK7
            using LOCK8 = Field<8, 1>;    // LOCK8
            using LOCK9 = Field<9, 1>;    // LOCK9
            using LOCK10 = Field<10, 1>;    // LOCK10
            using LOCK11 = Field<11, 1>;    // LOCK11
            using LOCK12 = Field<12, 1>;    // LOCK12
            using LOCK13 = Field<13, 1>;    // LOCK13
            using LOCK14 = Field<14, 1>;    // LOCK14
            using LOCK15 = Field<15, 1>;    // LOCK15
            using LOCK16 = Field<16, 1>;    // LOCK16
            using LOCK17 = Field<17, 1>;    // LOCK17
            using LOCK18 = Field<18, 1>;    // LOCK18
            using LOCK19 = Field<19, 1>;    // LOCK19
            using LOCK20 = Field<20, 1>;    // LOCK20
            using LOCK21 = Field<21, 1>;    // LOCK21
            using LOCK22 = Field<22, 1>;    // LOCK22
            using LOCK23 = Field<23, 1>;    // LOCK23
            using LOCK24 = Field<24, 1>;    // LOCK24
            using LOCK25 = Field<25, 1>;    // LOCK25
            using LOCK26 = Field<26, 1>;    // LOCK26
            using LOCK27 = Field<27, 1>;    // LOCK27
            using LOCK28 = Field<28, 1>;    // LOCK28
            using LOCK29 = Field<29, 1>;    // LOCK29
            using LOCK30 = Field<30, 1>;    // LOCK30
            using LOCK31 = Field<31, 1>;    // LOCK31
        };

        // ETZPC IP HW configuration register
        struct ETZPC_HWCFGR : public RegisterReadOnly<0x5c0073f0> {
            using NUM_TZMA = Field<0, 8>;    // NUM_TZMA
            using NUM_PER_SEC = Field<8, 8>;    // NUM_PER_SEC
            using NUM_AHB_SEC = Field<16, 8>;    // NUM_AHB_SEC
            using CHUNKS1N4 = Field<24, 8>;    // CHUNKS1N4
        };

        // ETZPC IP version register
        struct ETZPC_VERR : public RegisterReadOnly<0x5c0073f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // ETZPC IP version register
        struct ETZPC_IDR : public RegisterReadOnly<0x5c0073f8> {
            using ID = Field<0, 32>;    // ID
        };

        // ETZPC IP version register
        struct ETZPC_SIDR : public RegisterReadOnly<0x5c0073fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // IWDG1
    struct IWDG1 {
        // Key register
        struct IWDG_KR : public RegisterWriteOnly<0x5c003000> {
            using KEY = Field<0, 16>;    // KEY
        };

        // Prescaler register
        struct IWDG_PR : public Register<0x5c003004> {
            using PR = Field<0, 3>;    // PR
        };

        // Reload register
        struct IWDG_RLR : public Register<0x5c003008> {
            using RL = Field<0, 12>;    // RL
        };

        // Status register
        struct IWDG_SR : public RegisterReadOnly<0x5c00300c> {
            using PVU = Field<0, 1>;    // PVU
            using RVU = Field<1, 1>;    // RVU
            using WVU = Field<2, 1>;    // WVU
        };

        // Window register
        struct IWDG_WINR : public Register<0x5c003010> {
            using WIN = Field<0, 12>;    // WIN
        };

        // IWDG hardware configuration register
        struct IWDG_HWCFGR : public RegisterReadOnly<0x5c0033f0> {
            using WINDOW = Field<0, 4>;    // WINDOW
            using PR_DEFAULT = Field<4, 4>;    // PR_DEFAULT
        };

        // IWDG version register
        struct IWDG_VERR : public RegisterReadOnly<0x5c0033f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // IWDG identification register
        struct IWDG_IDR : public RegisterReadOnly<0x5c0033f8> {
            using ID = Field<0, 32>;    // ID
        };

        // IWDG size identification register
        struct IWDG_SIDR : public RegisterReadOnly<0x5c0033fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // IWDG1
    struct IWDG2 {
        // Key register
        struct IWDG_KR : public RegisterWriteOnly<0x5a002000> {
            using KEY = Field<0, 16>;    // KEY
        };

        // Prescaler register
        struct IWDG_PR : public Register<0x5a002004> {
            using PR = Field<0, 3>;    // PR
        };

        // Reload register
        struct IWDG_RLR : public Register<0x5a002008> {
            using RL = Field<0, 12>;    // RL
        };

        // Status register
        struct IWDG_SR : public RegisterReadOnly<0x5a00200c> {
            using PVU = Field<0, 1>;    // PVU
            using RVU = Field<1, 1>;    // RVU
            using WVU = Field<2, 1>;    // WVU
        };

        // Window register
        struct IWDG_WINR : public Register<0x5a002010> {
            using WIN = Field<0, 12>;    // WIN
        };

        // IWDG hardware configuration register
        struct IWDG_HWCFGR : public RegisterReadOnly<0x5a0023f0> {
            using WINDOW = Field<0, 4>;    // WINDOW
            using PR_DEFAULT = Field<4, 4>;    // PR_DEFAULT
        };

        // IWDG version register
        struct IWDG_VERR : public RegisterReadOnly<0x5a0023f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // IWDG identification register
        struct IWDG_IDR : public RegisterReadOnly<0x5a0023f8> {
            using ID = Field<0, 32>;    // ID
        };

        // IWDG size identification register
        struct IWDG_SIDR : public RegisterReadOnly<0x5a0023fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // SPI1
    struct SPI1 {
        // SPI/I2S control register 1
        struct SPI2S_CR1 : public Register<0x44004000> {
            using SPE = Field<0, 1>;    // SPE
            using MASRX = Field<8, 1>;    // MASRX
            using CSTART = Field<9, 1>;    // CSTART
            using CSUSP = Field<10, 1>;    // CSUSP
            using HDDIR = Field<11, 1>;    // HDDIR
            using SSI = Field<12, 1>;    // SSI
            using CRC33_17 = Field<13, 1>;    // CRC33_17
            using RCRCINI = Field<14, 1>;    // RCRCINI
            using TCRCINI = Field<15, 1>;    // TCRCINI
            using IOLOCK = Field<16, 1>;    // IOLOCK
        };

        // SPI/I2S interrupt enable register
        struct SPI2S_IER : public Register<0x44004010> {
            using RXPIE = Field<0, 1>;    // RXPIE
            using TXPIE = Field<1, 1>;    // TXPIE
            using DXPIE = Field<2, 1>;    // DXPIE
            using EOTIE = Field<3, 1>;    // EOTIE
            using TXTFIE = Field<4, 1>;    // TXTFIE
            using UDRIE = Field<5, 1>;    // UDRIE
            using OVRIE = Field<6, 1>;    // OVRIE
            using CRCEIE = Field<7, 1>;    // CRCEIE
            using TIFREIE = Field<8, 1>;    // TIFREIE
            using MODFIE = Field<9, 1>;    // MODFIE
            using TSERFIE = Field<10, 1>;    // TSERFIE
        };

        // SPI/I2S status register
        struct SPI2S_SR : public RegisterReadOnly<0x44004014> {
            using RXP = Field<0, 1>;    // RXP
            using TXP = Field<1, 1>;    // TXP
            using DXP = Field<2, 1>;    // DXP
            using EOT = Field<3, 1>;    // EOT
            using TXTF = Field<4, 1>;    // TXTF
            using UDR = Field<5, 1>;    // UDR
            using OVR = Field<6, 1>;    // OVR
            using CRCE = Field<7, 1>;    // CRCE
            using TIFRE = Field<8, 1>;    // TIFRE
            using MODF = Field<9, 1>;    // MODF
            using TSERF = Field<10, 1>;    // TSERF
            using SUSP = Field<11, 1>;    // SUSP
            using TXC = Field<12, 1>;    // TXC
            using RXPLVL = Field<13, 2>;    // RXPLVL
            using RXWNE = Field<15, 1>;    // RXWNE
            using CTSIZE = Field<16, 16>;    // CTSIZE
        };

        // SPI/I2S interrupt/status flags clear register
        struct SPI2S_IFCR : public RegisterWriteOnly<0x44004018> {
            using EOTC = Field<3, 1>;    // EOTC
            using TXTFC = Field<4, 1>;    // TXTFC
            using UDRC = Field<5, 1>;    // UDRC
            using OVRC = Field<6, 1>;    // OVRC
            using CRCEC = Field<7, 1>;    // CRCEC
            using TIFREC = Field<8, 1>;    // TIFREC
            using MODFC = Field<9, 1>;    // MODFC
            using TSERFC = Field<10, 1>;    // TSERFC
            using SUSPC = Field<11, 1>;    // SUSPC
        };

        // SPI/I2S transmit data register
        struct SPI2S_TXDR : public RegisterWriteOnly<0x44004020> {
            using TXDR = Field<0, 32>;    // TXDR
        };

        // SPI/I2S receive data register
        struct SPI2S_RXDR : public RegisterReadOnly<0x44004030> {
            using RXDR = Field<0, 32>;    // RXDR
        };

        // SPI control register 2
        struct SPI_CR2 : public Register<0x44004004> {
            using TSIZE = Field<0, 16>;    // TSIZE
            using TSER = Field<16, 16>;    // TSER
        };

        // Content of this register is write protected when SPI is enabled
        struct SPI_CFG1 : public Register<0x44004008> {
            using DSIZE = Field<0, 5>;    // DSIZE
            using FTHLV = Field<5, 4>;    // FTHLV
            using UDRCFG = Field<9, 2>;    // UDRCFG
            using UDRDET = Field<11, 2>;    // UDRDET
            using RXDMAEN = Field<14, 1>;    // RXDMAEN
            using TXDMAEN = Field<15, 1>;    // TXDMAEN
            using CRCSIZE = Field<16, 5>;    // CRCSIZE
            using CRCEN = Field<22, 1>;    // CRCEN
            using MBR = Field<28, 3>;    // MBR
        };

        // The content of this register is write protected when SPI is enabled or IOLOCK bit is set at SPI2S_CR1 register.
        struct SPI_CFG2 : public Register<0x4400400c> {
            using MSSI = Field<0, 4>;    // MSSI
            using MIDI = Field<4, 4>;    // MIDI
            using IOSWP = Field<15, 1>;    // IOSWP
            using COMM = Field<17, 2>;    // COMM
            using SP = Field<19, 3>;    // SP
            using MASTER = Field<22, 1>;    // MASTER
            using LSBFRST = Field<23, 1>;    // LSBFRST
            using CPHA = Field<24, 1>;    // CPHA
            using CPOL = Field<25, 1>;    // CPOL
            using SSM = Field<26, 1>;    // SSM
            using SSIOP = Field<28, 1>;    // SSIOP
            using SSOE = Field<29, 1>;    // SSOE
            using SSOM = Field<30, 1>;    // SSOM
            using AFCNTR = Field<31, 1>;    // AFCNTR
        };

        // SPI polynomial register
        struct SPI_CRCPOLY : public Register<0x44004040> {
            using CRCPOLY = Field<0, 32>;    // CRCPOLY
        };

        // SPI transmitter CRC register
        struct SPI_TXCRC : public RegisterReadOnly<0x44004044> {
            using TXCRC = Field<0, 32>;    // TXCRC
        };

        // SPI receiver CRC register
        struct SPI_RXCRC : public RegisterReadOnly<0x44004048> {
            using RXCRC = Field<0, 32>;    // RXCRC
        };

        // SPI underrun data register
        struct SPI_UDRDR : public Register<0x4400404c> {
            using UDRDR = Field<0, 32>;    // UDRDR
        };

        // All documented bits in this register must be configured when the I2S is disabled (SPE = 0).These bits are not used in SPI mode except for I2SMOD which needs to be set to 0 in SPI mode.
        struct SPI_I2SCFGR : public Register<0x44004050> {
            using I2SMOD = Field<0, 1>;    // I2SMOD
            using I2SCFG = Field<1, 3>;    // I2SCFG
            using I2SSTD = Field<4, 2>;    // I2SSTD
            using PCMSYNC = Field<7, 1>;    // PCMSYNC
            using DATLEN = Field<8, 2>;    // DATLEN
            using CHLEN = Field<10, 1>;    // CHLEN
            using CKPOL = Field<11, 1>;    // CKPOL
            using FIXCH = Field<12, 1>;    // FIXCH
            using WSINV = Field<13, 1>;    // WSINV
            using DATFMT = Field<14, 1>;    // DATFMT
            using I2SDIV = Field<16, 8>;    // I2SDIV
            using ODD = Field<24, 1>;    // ODD
            using MCKOE = Field<25, 1>;    // MCKOE
        };

        // SPI/I2S hardware configuration register
        struct SPI_I2S_HWCFGR : public RegisterReadOnly<0x440043f0> {
            using TXFCFG = Field<0, 4>;    // TXFCFG
            using RXFCFG = Field<4, 4>;    // RXFCFG
            using CRCCFG = Field<8, 4>;    // CRCCFG
            using I2SCFG = Field<12, 4>;    // I2SCFG
            using DSCFG = Field<16, 4>;    // DSCFG
        };

        // SPI/I2S version register
        struct SPI_VERR : public RegisterReadOnly<0x440043f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // SPI/I2S identification register
        struct SPI_IPIDR : public RegisterReadOnly<0x440043f8> {
            using ID = Field<0, 32>;    // ID
        };

        // SPI/I2S size identification register
        struct SPI_SIDR : public RegisterReadOnly<0x440043fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // SPI2
    struct SPI2 {
        // SPI/I2S control register 1
        struct SPI2S_CR1 : public Register<0x4000b000> {
            using SPE = Field<0, 1>;    // SPE
            using MASRX = Field<8, 1>;    // MASRX
            using CSTART = Field<9, 1>;    // CSTART
            using CSUSP = Field<10, 1>;    // CSUSP
            using HDDIR = Field<11, 1>;    // HDDIR
            using SSI = Field<12, 1>;    // SSI
            using CRC33_17 = Field<13, 1>;    // CRC33_17
            using RCRCINI = Field<14, 1>;    // RCRCINI
            using TCRCINI = Field<15, 1>;    // TCRCINI
            using IOLOCK = Field<16, 1>;    // IOLOCK
        };

        // SPI/I2S interrupt enable register
        struct SPI2S_IER : public Register<0x4000b010> {
            using RXPIE = Field<0, 1>;    // RXPIE
            using TXPIE = Field<1, 1>;    // TXPIE
            using DXPIE = Field<2, 1>;    // DXPIE
            using EOTIE = Field<3, 1>;    // EOTIE
            using TXTFIE = Field<4, 1>;    // TXTFIE
            using UDRIE = Field<5, 1>;    // UDRIE
            using OVRIE = Field<6, 1>;    // OVRIE
            using CRCEIE = Field<7, 1>;    // CRCEIE
            using TIFREIE = Field<8, 1>;    // TIFREIE
            using MODFIE = Field<9, 1>;    // MODFIE
            using TSERFIE = Field<10, 1>;    // TSERFIE
        };

        // SPI/I2S status register
        struct SPI2S_SR : public RegisterReadOnly<0x4000b014> {
            using RXP = Field<0, 1>;    // RXP
            using TXP = Field<1, 1>;    // TXP
            using DXP = Field<2, 1>;    // DXP
            using EOT = Field<3, 1>;    // EOT
            using TXTF = Field<4, 1>;    // TXTF
            using UDR = Field<5, 1>;    // UDR
            using OVR = Field<6, 1>;    // OVR
            using CRCE = Field<7, 1>;    // CRCE
            using TIFRE = Field<8, 1>;    // TIFRE
            using MODF = Field<9, 1>;    // MODF
            using TSERF = Field<10, 1>;    // TSERF
            using SUSP = Field<11, 1>;    // SUSP
            using TXC = Field<12, 1>;    // TXC
            using RXPLVL = Field<13, 2>;    // RXPLVL
            using RXWNE = Field<15, 1>;    // RXWNE
            using CTSIZE = Field<16, 16>;    // CTSIZE
        };

        // SPI/I2S interrupt/status flags clear register
        struct SPI2S_IFCR : public RegisterWriteOnly<0x4000b018> {
            using EOTC = Field<3, 1>;    // EOTC
            using TXTFC = Field<4, 1>;    // TXTFC
            using UDRC = Field<5, 1>;    // UDRC
            using OVRC = Field<6, 1>;    // OVRC
            using CRCEC = Field<7, 1>;    // CRCEC
            using TIFREC = Field<8, 1>;    // TIFREC
            using MODFC = Field<9, 1>;    // MODFC
            using TSERFC = Field<10, 1>;    // TSERFC
            using SUSPC = Field<11, 1>;    // SUSPC
        };

        // SPI/I2S transmit data register
        struct SPI2S_TXDR : public RegisterWriteOnly<0x4000b020> {
            using TXDR = Field<0, 32>;    // TXDR
        };

        // SPI/I2S receive data register
        struct SPI2S_RXDR : public RegisterReadOnly<0x4000b030> {
            using RXDR = Field<0, 32>;    // RXDR
        };

        // SPI control register 2
        struct SPI_CR2 : public Register<0x4000b004> {
            using TSIZE = Field<0, 16>;    // TSIZE
            using TSER = Field<16, 16>;    // TSER
        };

        // Content of this register is write protected when SPI is enabled
        struct SPI_CFG1 : public Register<0x4000b008> {
            using DSIZE = Field<0, 5>;    // DSIZE
            using FTHLV = Field<5, 4>;    // FTHLV
            using UDRCFG = Field<9, 2>;    // UDRCFG
            using UDRDET = Field<11, 2>;    // UDRDET
            using RXDMAEN = Field<14, 1>;    // RXDMAEN
            using TXDMAEN = Field<15, 1>;    // TXDMAEN
            using CRCSIZE = Field<16, 5>;    // CRCSIZE
            using CRCEN = Field<22, 1>;    // CRCEN
            using MBR = Field<28, 3>;    // MBR
        };

        // The content of this register is write protected when SPI is enabled or IOLOCK bit is set at SPI2S_CR1 register.
        struct SPI_CFG2 : public Register<0x4000b00c> {
            using MSSI = Field<0, 4>;    // MSSI
            using MIDI = Field<4, 4>;    // MIDI
            using IOSWP = Field<15, 1>;    // IOSWP
            using COMM = Field<17, 2>;    // COMM
            using SP = Field<19, 3>;    // SP
            using MASTER = Field<22, 1>;    // MASTER
            using LSBFRST = Field<23, 1>;    // LSBFRST
            using CPHA = Field<24, 1>;    // CPHA
            using CPOL = Field<25, 1>;    // CPOL
            using SSM = Field<26, 1>;    // SSM
            using SSIOP = Field<28, 1>;    // SSIOP
            using SSOE = Field<29, 1>;    // SSOE
            using SSOM = Field<30, 1>;    // SSOM
            using AFCNTR = Field<31, 1>;    // AFCNTR
        };

        // SPI polynomial register
        struct SPI_CRCPOLY : public Register<0x4000b040> {
            using CRCPOLY = Field<0, 32>;    // CRCPOLY
        };

        // SPI transmitter CRC register
        struct SPI_TXCRC : public RegisterReadOnly<0x4000b044> {
            using TXCRC = Field<0, 32>;    // TXCRC
        };

        // SPI receiver CRC register
        struct SPI_RXCRC : public RegisterReadOnly<0x4000b048> {
            using RXCRC = Field<0, 32>;    // RXCRC
        };

        // SPI underrun data register
        struct SPI_UDRDR : public Register<0x4000b04c> {
            using UDRDR = Field<0, 32>;    // UDRDR
        };

        // All documented bits in this register must be configured when the I2S is disabled (SPE = 0).These bits are not used in SPI mode except for I2SMOD which needs to be set to 0 in SPI mode.
        struct SPI_I2SCFGR : public Register<0x4000b050> {
            using I2SMOD = Field<0, 1>;    // I2SMOD
            using I2SCFG = Field<1, 3>;    // I2SCFG
            using I2SSTD = Field<4, 2>;    // I2SSTD
            using PCMSYNC = Field<7, 1>;    // PCMSYNC
            using DATLEN = Field<8, 2>;    // DATLEN
            using CHLEN = Field<10, 1>;    // CHLEN
            using CKPOL = Field<11, 1>;    // CKPOL
            using FIXCH = Field<12, 1>;    // FIXCH
            using WSINV = Field<13, 1>;    // WSINV
            using DATFMT = Field<14, 1>;    // DATFMT
            using I2SDIV = Field<16, 8>;    // I2SDIV
            using ODD = Field<24, 1>;    // ODD
            using MCKOE = Field<25, 1>;    // MCKOE
        };

        // SPI/I2S hardware configuration register
        struct SPI_I2S_HWCFGR : public RegisterReadOnly<0x4000b3f0> {
            using TXFCFG = Field<0, 4>;    // TXFCFG
            using RXFCFG = Field<4, 4>;    // RXFCFG
            using CRCCFG = Field<8, 4>;    // CRCCFG
            using I2SCFG = Field<12, 4>;    // I2SCFG
            using DSCFG = Field<16, 4>;    // DSCFG
        };

        // SPI/I2S version register
        struct SPI_VERR : public RegisterReadOnly<0x4000b3f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // SPI/I2S identification register
        struct SPI_IPIDR : public RegisterReadOnly<0x4000b3f8> {
            using ID = Field<0, 32>;    // ID
        };

        // SPI/I2S size identification register
        struct SPI_SIDR : public RegisterReadOnly<0x4000b3fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // SPI2
    struct SPI3 {
        // SPI/I2S control register 1
        struct SPI2S_CR1 : public Register<0x4000c000> {
            using SPE = Field<0, 1>;    // SPE
            using MASRX = Field<8, 1>;    // MASRX
            using CSTART = Field<9, 1>;    // CSTART
            using CSUSP = Field<10, 1>;    // CSUSP
            using HDDIR = Field<11, 1>;    // HDDIR
            using SSI = Field<12, 1>;    // SSI
            using CRC33_17 = Field<13, 1>;    // CRC33_17
            using RCRCINI = Field<14, 1>;    // RCRCINI
            using TCRCINI = Field<15, 1>;    // TCRCINI
            using IOLOCK = Field<16, 1>;    // IOLOCK
        };

        // SPI/I2S interrupt enable register
        struct SPI2S_IER : public Register<0x4000c010> {
            using RXPIE = Field<0, 1>;    // RXPIE
            using TXPIE = Field<1, 1>;    // TXPIE
            using DXPIE = Field<2, 1>;    // DXPIE
            using EOTIE = Field<3, 1>;    // EOTIE
            using TXTFIE = Field<4, 1>;    // TXTFIE
            using UDRIE = Field<5, 1>;    // UDRIE
            using OVRIE = Field<6, 1>;    // OVRIE
            using CRCEIE = Field<7, 1>;    // CRCEIE
            using TIFREIE = Field<8, 1>;    // TIFREIE
            using MODFIE = Field<9, 1>;    // MODFIE
            using TSERFIE = Field<10, 1>;    // TSERFIE
        };

        // SPI/I2S status register
        struct SPI2S_SR : public RegisterReadOnly<0x4000c014> {
            using RXP = Field<0, 1>;    // RXP
            using TXP = Field<1, 1>;    // TXP
            using DXP = Field<2, 1>;    // DXP
            using EOT = Field<3, 1>;    // EOT
            using TXTF = Field<4, 1>;    // TXTF
            using UDR = Field<5, 1>;    // UDR
            using OVR = Field<6, 1>;    // OVR
            using CRCE = Field<7, 1>;    // CRCE
            using TIFRE = Field<8, 1>;    // TIFRE
            using MODF = Field<9, 1>;    // MODF
            using TSERF = Field<10, 1>;    // TSERF
            using SUSP = Field<11, 1>;    // SUSP
            using TXC = Field<12, 1>;    // TXC
            using RXPLVL = Field<13, 2>;    // RXPLVL
            using RXWNE = Field<15, 1>;    // RXWNE
            using CTSIZE = Field<16, 16>;    // CTSIZE
        };

        // SPI/I2S interrupt/status flags clear register
        struct SPI2S_IFCR : public RegisterWriteOnly<0x4000c018> {
            using EOTC = Field<3, 1>;    // EOTC
            using TXTFC = Field<4, 1>;    // TXTFC
            using UDRC = Field<5, 1>;    // UDRC
            using OVRC = Field<6, 1>;    // OVRC
            using CRCEC = Field<7, 1>;    // CRCEC
            using TIFREC = Field<8, 1>;    // TIFREC
            using MODFC = Field<9, 1>;    // MODFC
            using TSERFC = Field<10, 1>;    // TSERFC
            using SUSPC = Field<11, 1>;    // SUSPC
        };

        // SPI/I2S transmit data register
        struct SPI2S_TXDR : public RegisterWriteOnly<0x4000c020> {
            using TXDR = Field<0, 32>;    // TXDR
        };

        // SPI/I2S receive data register
        struct SPI2S_RXDR : public RegisterReadOnly<0x4000c030> {
            using RXDR = Field<0, 32>;    // RXDR
        };

        // SPI control register 2
        struct SPI_CR2 : public Register<0x4000c004> {
            using TSIZE = Field<0, 16>;    // TSIZE
            using TSER = Field<16, 16>;    // TSER
        };

        // Content of this register is write protected when SPI is enabled
        struct SPI_CFG1 : public Register<0x4000c008> {
            using DSIZE = Field<0, 5>;    // DSIZE
            using FTHLV = Field<5, 4>;    // FTHLV
            using UDRCFG = Field<9, 2>;    // UDRCFG
            using UDRDET = Field<11, 2>;    // UDRDET
            using RXDMAEN = Field<14, 1>;    // RXDMAEN
            using TXDMAEN = Field<15, 1>;    // TXDMAEN
            using CRCSIZE = Field<16, 5>;    // CRCSIZE
            using CRCEN = Field<22, 1>;    // CRCEN
            using MBR = Field<28, 3>;    // MBR
        };

        // The content of this register is write protected when SPI is enabled or IOLOCK bit is set at SPI2S_CR1 register.
        struct SPI_CFG2 : public Register<0x4000c00c> {
            using MSSI = Field<0, 4>;    // MSSI
            using MIDI = Field<4, 4>;    // MIDI
            using IOSWP = Field<15, 1>;    // IOSWP
            using COMM = Field<17, 2>;    // COMM
            using SP = Field<19, 3>;    // SP
            using MASTER = Field<22, 1>;    // MASTER
            using LSBFRST = Field<23, 1>;    // LSBFRST
            using CPHA = Field<24, 1>;    // CPHA
            using CPOL = Field<25, 1>;    // CPOL
            using SSM = Field<26, 1>;    // SSM
            using SSIOP = Field<28, 1>;    // SSIOP
            using SSOE = Field<29, 1>;    // SSOE
            using SSOM = Field<30, 1>;    // SSOM
            using AFCNTR = Field<31, 1>;    // AFCNTR
        };

        // SPI polynomial register
        struct SPI_CRCPOLY : public Register<0x4000c040> {
            using CRCPOLY = Field<0, 32>;    // CRCPOLY
        };

        // SPI transmitter CRC register
        struct SPI_TXCRC : public RegisterReadOnly<0x4000c044> {
            using TXCRC = Field<0, 32>;    // TXCRC
        };

        // SPI receiver CRC register
        struct SPI_RXCRC : public RegisterReadOnly<0x4000c048> {
            using RXCRC = Field<0, 32>;    // RXCRC
        };

        // SPI underrun data register
        struct SPI_UDRDR : public Register<0x4000c04c> {
            using UDRDR = Field<0, 32>;    // UDRDR
        };

        // All documented bits in this register must be configured when the I2S is disabled (SPE = 0).These bits are not used in SPI mode except for I2SMOD which needs to be set to 0 in SPI mode.
        struct SPI_I2SCFGR : public Register<0x4000c050> {
            using I2SMOD = Field<0, 1>;    // I2SMOD
            using I2SCFG = Field<1, 3>;    // I2SCFG
            using I2SSTD = Field<4, 2>;    // I2SSTD
            using PCMSYNC = Field<7, 1>;    // PCMSYNC
            using DATLEN = Field<8, 2>;    // DATLEN
            using CHLEN = Field<10, 1>;    // CHLEN
            using CKPOL = Field<11, 1>;    // CKPOL
            using FIXCH = Field<12, 1>;    // FIXCH
            using WSINV = Field<13, 1>;    // WSINV
            using DATFMT = Field<14, 1>;    // DATFMT
            using I2SDIV = Field<16, 8>;    // I2SDIV
            using ODD = Field<24, 1>;    // ODD
            using MCKOE = Field<25, 1>;    // MCKOE
        };

        // SPI/I2S hardware configuration register
        struct SPI_I2S_HWCFGR : public RegisterReadOnly<0x4000c3f0> {
            using TXFCFG = Field<0, 4>;    // TXFCFG
            using RXFCFG = Field<4, 4>;    // RXFCFG
            using CRCCFG = Field<8, 4>;    // CRCCFG
            using I2SCFG = Field<12, 4>;    // I2SCFG
            using DSCFG = Field<16, 4>;    // DSCFG
        };

        // SPI/I2S version register
        struct SPI_VERR : public RegisterReadOnly<0x4000c3f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // SPI/I2S identification register
        struct SPI_IPIDR : public RegisterReadOnly<0x4000c3f8> {
            using ID = Field<0, 32>;    // ID
        };

        // SPI/I2S size identification register
        struct SPI_SIDR : public RegisterReadOnly<0x4000c3fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // SPI2
    struct SPI4 {
        // SPI/I2S control register 1
        struct SPI2S_CR1 : public Register<0x44005000> {
            using SPE = Field<0, 1>;    // SPE
            using MASRX = Field<8, 1>;    // MASRX
            using CSTART = Field<9, 1>;    // CSTART
            using CSUSP = Field<10, 1>;    // CSUSP
            using HDDIR = Field<11, 1>;    // HDDIR
            using SSI = Field<12, 1>;    // SSI
            using CRC33_17 = Field<13, 1>;    // CRC33_17
            using RCRCINI = Field<14, 1>;    // RCRCINI
            using TCRCINI = Field<15, 1>;    // TCRCINI
            using IOLOCK = Field<16, 1>;    // IOLOCK
        };

        // SPI/I2S interrupt enable register
        struct SPI2S_IER : public Register<0x44005010> {
            using RXPIE = Field<0, 1>;    // RXPIE
            using TXPIE = Field<1, 1>;    // TXPIE
            using DXPIE = Field<2, 1>;    // DXPIE
            using EOTIE = Field<3, 1>;    // EOTIE
            using TXTFIE = Field<4, 1>;    // TXTFIE
            using UDRIE = Field<5, 1>;    // UDRIE
            using OVRIE = Field<6, 1>;    // OVRIE
            using CRCEIE = Field<7, 1>;    // CRCEIE
            using TIFREIE = Field<8, 1>;    // TIFREIE
            using MODFIE = Field<9, 1>;    // MODFIE
            using TSERFIE = Field<10, 1>;    // TSERFIE
        };

        // SPI/I2S status register
        struct SPI2S_SR : public RegisterReadOnly<0x44005014> {
            using RXP = Field<0, 1>;    // RXP
            using TXP = Field<1, 1>;    // TXP
            using DXP = Field<2, 1>;    // DXP
            using EOT = Field<3, 1>;    // EOT
            using TXTF = Field<4, 1>;    // TXTF
            using UDR = Field<5, 1>;    // UDR
            using OVR = Field<6, 1>;    // OVR
            using CRCE = Field<7, 1>;    // CRCE
            using TIFRE = Field<8, 1>;    // TIFRE
            using MODF = Field<9, 1>;    // MODF
            using TSERF = Field<10, 1>;    // TSERF
            using SUSP = Field<11, 1>;    // SUSP
            using TXC = Field<12, 1>;    // TXC
            using RXPLVL = Field<13, 2>;    // RXPLVL
            using RXWNE = Field<15, 1>;    // RXWNE
            using CTSIZE = Field<16, 16>;    // CTSIZE
        };

        // SPI/I2S interrupt/status flags clear register
        struct SPI2S_IFCR : public RegisterWriteOnly<0x44005018> {
            using EOTC = Field<3, 1>;    // EOTC
            using TXTFC = Field<4, 1>;    // TXTFC
            using UDRC = Field<5, 1>;    // UDRC
            using OVRC = Field<6, 1>;    // OVRC
            using CRCEC = Field<7, 1>;    // CRCEC
            using TIFREC = Field<8, 1>;    // TIFREC
            using MODFC = Field<9, 1>;    // MODFC
            using TSERFC = Field<10, 1>;    // TSERFC
            using SUSPC = Field<11, 1>;    // SUSPC
        };

        // SPI/I2S transmit data register
        struct SPI2S_TXDR : public RegisterWriteOnly<0x44005020> {
            using TXDR = Field<0, 32>;    // TXDR
        };

        // SPI/I2S receive data register
        struct SPI2S_RXDR : public RegisterReadOnly<0x44005030> {
            using RXDR = Field<0, 32>;    // RXDR
        };

        // SPI control register 2
        struct SPI_CR2 : public Register<0x44005004> {
            using TSIZE = Field<0, 16>;    // TSIZE
            using TSER = Field<16, 16>;    // TSER
        };

        // Content of this register is write protected when SPI is enabled
        struct SPI_CFG1 : public Register<0x44005008> {
            using DSIZE = Field<0, 5>;    // DSIZE
            using FTHLV = Field<5, 4>;    // FTHLV
            using UDRCFG = Field<9, 2>;    // UDRCFG
            using UDRDET = Field<11, 2>;    // UDRDET
            using RXDMAEN = Field<14, 1>;    // RXDMAEN
            using TXDMAEN = Field<15, 1>;    // TXDMAEN
            using CRCSIZE = Field<16, 5>;    // CRCSIZE
            using CRCEN = Field<22, 1>;    // CRCEN
            using MBR = Field<28, 3>;    // MBR
        };

        // The content of this register is write protected when SPI is enabled or IOLOCK bit is set at SPI2S_CR1 register.
        struct SPI_CFG2 : public Register<0x4400500c> {
            using MSSI = Field<0, 4>;    // MSSI
            using MIDI = Field<4, 4>;    // MIDI
            using IOSWP = Field<15, 1>;    // IOSWP
            using COMM = Field<17, 2>;    // COMM
            using SP = Field<19, 3>;    // SP
            using MASTER = Field<22, 1>;    // MASTER
            using LSBFRST = Field<23, 1>;    // LSBFRST
            using CPHA = Field<24, 1>;    // CPHA
            using CPOL = Field<25, 1>;    // CPOL
            using SSM = Field<26, 1>;    // SSM
            using SSIOP = Field<28, 1>;    // SSIOP
            using SSOE = Field<29, 1>;    // SSOE
            using SSOM = Field<30, 1>;    // SSOM
            using AFCNTR = Field<31, 1>;    // AFCNTR
        };

        // SPI polynomial register
        struct SPI_CRCPOLY : public Register<0x44005040> {
            using CRCPOLY = Field<0, 32>;    // CRCPOLY
        };

        // SPI transmitter CRC register
        struct SPI_TXCRC : public RegisterReadOnly<0x44005044> {
            using TXCRC = Field<0, 32>;    // TXCRC
        };

        // SPI receiver CRC register
        struct SPI_RXCRC : public RegisterReadOnly<0x44005048> {
            using RXCRC = Field<0, 32>;    // RXCRC
        };

        // SPI underrun data register
        struct SPI_UDRDR : public Register<0x4400504c> {
            using UDRDR = Field<0, 32>;    // UDRDR
        };

        // All documented bits in this register must be configured when the I2S is disabled (SPE = 0).These bits are not used in SPI mode except for I2SMOD which needs to be set to 0 in SPI mode.
        struct SPI_I2SCFGR : public Register<0x44005050> {
            using I2SMOD = Field<0, 1>;    // I2SMOD
            using I2SCFG = Field<1, 3>;    // I2SCFG
            using I2SSTD = Field<4, 2>;    // I2SSTD
            using PCMSYNC = Field<7, 1>;    // PCMSYNC
            using DATLEN = Field<8, 2>;    // DATLEN
            using CHLEN = Field<10, 1>;    // CHLEN
            using CKPOL = Field<11, 1>;    // CKPOL
            using FIXCH = Field<12, 1>;    // FIXCH
            using WSINV = Field<13, 1>;    // WSINV
            using DATFMT = Field<14, 1>;    // DATFMT
            using I2SDIV = Field<16, 8>;    // I2SDIV
            using ODD = Field<24, 1>;    // ODD
            using MCKOE = Field<25, 1>;    // MCKOE
        };

        // SPI/I2S hardware configuration register
        struct SPI_I2S_HWCFGR : public RegisterReadOnly<0x440053f0> {
            using TXFCFG = Field<0, 4>;    // TXFCFG
            using RXFCFG = Field<4, 4>;    // RXFCFG
            using CRCCFG = Field<8, 4>;    // CRCCFG
            using I2SCFG = Field<12, 4>;    // I2SCFG
            using DSCFG = Field<16, 4>;    // DSCFG
        };

        // SPI/I2S version register
        struct SPI_VERR : public RegisterReadOnly<0x440053f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // SPI/I2S identification register
        struct SPI_IPIDR : public RegisterReadOnly<0x440053f8> {
            using ID = Field<0, 32>;    // ID
        };

        // SPI/I2S size identification register
        struct SPI_SIDR : public RegisterReadOnly<0x440053fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // SPI2
    struct SPI5 {
        // SPI/I2S control register 1
        struct SPI2S_CR1 : public Register<0x44009000> {
            using SPE = Field<0, 1>;    // SPE
            using MASRX = Field<8, 1>;    // MASRX
            using CSTART = Field<9, 1>;    // CSTART
            using CSUSP = Field<10, 1>;    // CSUSP
            using HDDIR = Field<11, 1>;    // HDDIR
            using SSI = Field<12, 1>;    // SSI
            using CRC33_17 = Field<13, 1>;    // CRC33_17
            using RCRCINI = Field<14, 1>;    // RCRCINI
            using TCRCINI = Field<15, 1>;    // TCRCINI
            using IOLOCK = Field<16, 1>;    // IOLOCK
        };

        // SPI/I2S interrupt enable register
        struct SPI2S_IER : public Register<0x44009010> {
            using RXPIE = Field<0, 1>;    // RXPIE
            using TXPIE = Field<1, 1>;    // TXPIE
            using DXPIE = Field<2, 1>;    // DXPIE
            using EOTIE = Field<3, 1>;    // EOTIE
            using TXTFIE = Field<4, 1>;    // TXTFIE
            using UDRIE = Field<5, 1>;    // UDRIE
            using OVRIE = Field<6, 1>;    // OVRIE
            using CRCEIE = Field<7, 1>;    // CRCEIE
            using TIFREIE = Field<8, 1>;    // TIFREIE
            using MODFIE = Field<9, 1>;    // MODFIE
            using TSERFIE = Field<10, 1>;    // TSERFIE
        };

        // SPI/I2S status register
        struct SPI2S_SR : public RegisterReadOnly<0x44009014> {
            using RXP = Field<0, 1>;    // RXP
            using TXP = Field<1, 1>;    // TXP
            using DXP = Field<2, 1>;    // DXP
            using EOT = Field<3, 1>;    // EOT
            using TXTF = Field<4, 1>;    // TXTF
            using UDR = Field<5, 1>;    // UDR
            using OVR = Field<6, 1>;    // OVR
            using CRCE = Field<7, 1>;    // CRCE
            using TIFRE = Field<8, 1>;    // TIFRE
            using MODF = Field<9, 1>;    // MODF
            using TSERF = Field<10, 1>;    // TSERF
            using SUSP = Field<11, 1>;    // SUSP
            using TXC = Field<12, 1>;    // TXC
            using RXPLVL = Field<13, 2>;    // RXPLVL
            using RXWNE = Field<15, 1>;    // RXWNE
            using CTSIZE = Field<16, 16>;    // CTSIZE
        };

        // SPI/I2S interrupt/status flags clear register
        struct SPI2S_IFCR : public RegisterWriteOnly<0x44009018> {
            using EOTC = Field<3, 1>;    // EOTC
            using TXTFC = Field<4, 1>;    // TXTFC
            using UDRC = Field<5, 1>;    // UDRC
            using OVRC = Field<6, 1>;    // OVRC
            using CRCEC = Field<7, 1>;    // CRCEC
            using TIFREC = Field<8, 1>;    // TIFREC
            using MODFC = Field<9, 1>;    // MODFC
            using TSERFC = Field<10, 1>;    // TSERFC
            using SUSPC = Field<11, 1>;    // SUSPC
        };

        // SPI/I2S transmit data register
        struct SPI2S_TXDR : public RegisterWriteOnly<0x44009020> {
            using TXDR = Field<0, 32>;    // TXDR
        };

        // SPI/I2S receive data register
        struct SPI2S_RXDR : public RegisterReadOnly<0x44009030> {
            using RXDR = Field<0, 32>;    // RXDR
        };

        // SPI control register 2
        struct SPI_CR2 : public Register<0x44009004> {
            using TSIZE = Field<0, 16>;    // TSIZE
            using TSER = Field<16, 16>;    // TSER
        };

        // Content of this register is write protected when SPI is enabled
        struct SPI_CFG1 : public Register<0x44009008> {
            using DSIZE = Field<0, 5>;    // DSIZE
            using FTHLV = Field<5, 4>;    // FTHLV
            using UDRCFG = Field<9, 2>;    // UDRCFG
            using UDRDET = Field<11, 2>;    // UDRDET
            using RXDMAEN = Field<14, 1>;    // RXDMAEN
            using TXDMAEN = Field<15, 1>;    // TXDMAEN
            using CRCSIZE = Field<16, 5>;    // CRCSIZE
            using CRCEN = Field<22, 1>;    // CRCEN
            using MBR = Field<28, 3>;    // MBR
        };

        // The content of this register is write protected when SPI is enabled or IOLOCK bit is set at SPI2S_CR1 register.
        struct SPI_CFG2 : public Register<0x4400900c> {
            using MSSI = Field<0, 4>;    // MSSI
            using MIDI = Field<4, 4>;    // MIDI
            using IOSWP = Field<15, 1>;    // IOSWP
            using COMM = Field<17, 2>;    // COMM
            using SP = Field<19, 3>;    // SP
            using MASTER = Field<22, 1>;    // MASTER
            using LSBFRST = Field<23, 1>;    // LSBFRST
            using CPHA = Field<24, 1>;    // CPHA
            using CPOL = Field<25, 1>;    // CPOL
            using SSM = Field<26, 1>;    // SSM
            using SSIOP = Field<28, 1>;    // SSIOP
            using SSOE = Field<29, 1>;    // SSOE
            using SSOM = Field<30, 1>;    // SSOM
            using AFCNTR = Field<31, 1>;    // AFCNTR
        };

        // SPI polynomial register
        struct SPI_CRCPOLY : public Register<0x44009040> {
            using CRCPOLY = Field<0, 32>;    // CRCPOLY
        };

        // SPI transmitter CRC register
        struct SPI_TXCRC : public RegisterReadOnly<0x44009044> {
            using TXCRC = Field<0, 32>;    // TXCRC
        };

        // SPI receiver CRC register
        struct SPI_RXCRC : public RegisterReadOnly<0x44009048> {
            using RXCRC = Field<0, 32>;    // RXCRC
        };

        // SPI underrun data register
        struct SPI_UDRDR : public Register<0x4400904c> {
            using UDRDR = Field<0, 32>;    // UDRDR
        };

        // All documented bits in this register must be configured when the I2S is disabled (SPE = 0).These bits are not used in SPI mode except for I2SMOD which needs to be set to 0 in SPI mode.
        struct SPI_I2SCFGR : public Register<0x44009050> {
            using I2SMOD = Field<0, 1>;    // I2SMOD
            using I2SCFG = Field<1, 3>;    // I2SCFG
            using I2SSTD = Field<4, 2>;    // I2SSTD
            using PCMSYNC = Field<7, 1>;    // PCMSYNC
            using DATLEN = Field<8, 2>;    // DATLEN
            using CHLEN = Field<10, 1>;    // CHLEN
            using CKPOL = Field<11, 1>;    // CKPOL
            using FIXCH = Field<12, 1>;    // FIXCH
            using WSINV = Field<13, 1>;    // WSINV
            using DATFMT = Field<14, 1>;    // DATFMT
            using I2SDIV = Field<16, 8>;    // I2SDIV
            using ODD = Field<24, 1>;    // ODD
            using MCKOE = Field<25, 1>;    // MCKOE
        };

        // SPI/I2S hardware configuration register
        struct SPI_I2S_HWCFGR : public RegisterReadOnly<0x440093f0> {
            using TXFCFG = Field<0, 4>;    // TXFCFG
            using RXFCFG = Field<4, 4>;    // RXFCFG
            using CRCCFG = Field<8, 4>;    // CRCCFG
            using I2SCFG = Field<12, 4>;    // I2SCFG
            using DSCFG = Field<16, 4>;    // DSCFG
        };

        // SPI/I2S version register
        struct SPI_VERR : public RegisterReadOnly<0x440093f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // SPI/I2S identification register
        struct SPI_IPIDR : public RegisterReadOnly<0x440093f8> {
            using ID = Field<0, 32>;    // ID
        };

        // SPI/I2S size identification register
        struct SPI_SIDR : public RegisterReadOnly<0x440093fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // SPI2
    struct SPI6 {
        // SPI/I2S control register 1
        struct SPI2S_CR1 : public Register<0x5c001000> {
            using SPE = Field<0, 1>;    // SPE
            using MASRX = Field<8, 1>;    // MASRX
            using CSTART = Field<9, 1>;    // CSTART
            using CSUSP = Field<10, 1>;    // CSUSP
            using HDDIR = Field<11, 1>;    // HDDIR
            using SSI = Field<12, 1>;    // SSI
            using CRC33_17 = Field<13, 1>;    // CRC33_17
            using RCRCINI = Field<14, 1>;    // RCRCINI
            using TCRCINI = Field<15, 1>;    // TCRCINI
            using IOLOCK = Field<16, 1>;    // IOLOCK
        };

        // SPI/I2S interrupt enable register
        struct SPI2S_IER : public Register<0x5c001010> {
            using RXPIE = Field<0, 1>;    // RXPIE
            using TXPIE = Field<1, 1>;    // TXPIE
            using DXPIE = Field<2, 1>;    // DXPIE
            using EOTIE = Field<3, 1>;    // EOTIE
            using TXTFIE = Field<4, 1>;    // TXTFIE
            using UDRIE = Field<5, 1>;    // UDRIE
            using OVRIE = Field<6, 1>;    // OVRIE
            using CRCEIE = Field<7, 1>;    // CRCEIE
            using TIFREIE = Field<8, 1>;    // TIFREIE
            using MODFIE = Field<9, 1>;    // MODFIE
            using TSERFIE = Field<10, 1>;    // TSERFIE
        };

        // SPI/I2S status register
        struct SPI2S_SR : public RegisterReadOnly<0x5c001014> {
            using RXP = Field<0, 1>;    // RXP
            using TXP = Field<1, 1>;    // TXP
            using DXP = Field<2, 1>;    // DXP
            using EOT = Field<3, 1>;    // EOT
            using TXTF = Field<4, 1>;    // TXTF
            using UDR = Field<5, 1>;    // UDR
            using OVR = Field<6, 1>;    // OVR
            using CRCE = Field<7, 1>;    // CRCE
            using TIFRE = Field<8, 1>;    // TIFRE
            using MODF = Field<9, 1>;    // MODF
            using TSERF = Field<10, 1>;    // TSERF
            using SUSP = Field<11, 1>;    // SUSP
            using TXC = Field<12, 1>;    // TXC
            using RXPLVL = Field<13, 2>;    // RXPLVL
            using RXWNE = Field<15, 1>;    // RXWNE
            using CTSIZE = Field<16, 16>;    // CTSIZE
        };

        // SPI/I2S interrupt/status flags clear register
        struct SPI2S_IFCR : public RegisterWriteOnly<0x5c001018> {
            using EOTC = Field<3, 1>;    // EOTC
            using TXTFC = Field<4, 1>;    // TXTFC
            using UDRC = Field<5, 1>;    // UDRC
            using OVRC = Field<6, 1>;    // OVRC
            using CRCEC = Field<7, 1>;    // CRCEC
            using TIFREC = Field<8, 1>;    // TIFREC
            using MODFC = Field<9, 1>;    // MODFC
            using TSERFC = Field<10, 1>;    // TSERFC
            using SUSPC = Field<11, 1>;    // SUSPC
        };

        // SPI/I2S transmit data register
        struct SPI2S_TXDR : public RegisterWriteOnly<0x5c001020> {
            using TXDR = Field<0, 32>;    // TXDR
        };

        // SPI/I2S receive data register
        struct SPI2S_RXDR : public RegisterReadOnly<0x5c001030> {
            using RXDR = Field<0, 32>;    // RXDR
        };

        // SPI control register 2
        struct SPI_CR2 : public Register<0x5c001004> {
            using TSIZE = Field<0, 16>;    // TSIZE
            using TSER = Field<16, 16>;    // TSER
        };

        // Content of this register is write protected when SPI is enabled
        struct SPI_CFG1 : public Register<0x5c001008> {
            using DSIZE = Field<0, 5>;    // DSIZE
            using FTHLV = Field<5, 4>;    // FTHLV
            using UDRCFG = Field<9, 2>;    // UDRCFG
            using UDRDET = Field<11, 2>;    // UDRDET
            using RXDMAEN = Field<14, 1>;    // RXDMAEN
            using TXDMAEN = Field<15, 1>;    // TXDMAEN
            using CRCSIZE = Field<16, 5>;    // CRCSIZE
            using CRCEN = Field<22, 1>;    // CRCEN
            using MBR = Field<28, 3>;    // MBR
        };

        // The content of this register is write protected when SPI is enabled or IOLOCK bit is set at SPI2S_CR1 register.
        struct SPI_CFG2 : public Register<0x5c00100c> {
            using MSSI = Field<0, 4>;    // MSSI
            using MIDI = Field<4, 4>;    // MIDI
            using IOSWP = Field<15, 1>;    // IOSWP
            using COMM = Field<17, 2>;    // COMM
            using SP = Field<19, 3>;    // SP
            using MASTER = Field<22, 1>;    // MASTER
            using LSBFRST = Field<23, 1>;    // LSBFRST
            using CPHA = Field<24, 1>;    // CPHA
            using CPOL = Field<25, 1>;    // CPOL
            using SSM = Field<26, 1>;    // SSM
            using SSIOP = Field<28, 1>;    // SSIOP
            using SSOE = Field<29, 1>;    // SSOE
            using SSOM = Field<30, 1>;    // SSOM
            using AFCNTR = Field<31, 1>;    // AFCNTR
        };

        // SPI polynomial register
        struct SPI_CRCPOLY : public Register<0x5c001040> {
            using CRCPOLY = Field<0, 32>;    // CRCPOLY
        };

        // SPI transmitter CRC register
        struct SPI_TXCRC : public RegisterReadOnly<0x5c001044> {
            using TXCRC = Field<0, 32>;    // TXCRC
        };

        // SPI receiver CRC register
        struct SPI_RXCRC : public RegisterReadOnly<0x5c001048> {
            using RXCRC = Field<0, 32>;    // RXCRC
        };

        // SPI underrun data register
        struct SPI_UDRDR : public Register<0x5c00104c> {
            using UDRDR = Field<0, 32>;    // UDRDR
        };

        // All documented bits in this register must be configured when the I2S is disabled (SPE = 0).These bits are not used in SPI mode except for I2SMOD which needs to be set to 0 in SPI mode.
        struct SPI_I2SCFGR : public Register<0x5c001050> {
            using I2SMOD = Field<0, 1>;    // I2SMOD
            using I2SCFG = Field<1, 3>;    // I2SCFG
            using I2SSTD = Field<4, 2>;    // I2SSTD
            using PCMSYNC = Field<7, 1>;    // PCMSYNC
            using DATLEN = Field<8, 2>;    // DATLEN
            using CHLEN = Field<10, 1>;    // CHLEN
            using CKPOL = Field<11, 1>;    // CKPOL
            using FIXCH = Field<12, 1>;    // FIXCH
            using WSINV = Field<13, 1>;    // WSINV
            using DATFMT = Field<14, 1>;    // DATFMT
            using I2SDIV = Field<16, 8>;    // I2SDIV
            using ODD = Field<24, 1>;    // ODD
            using MCKOE = Field<25, 1>;    // MCKOE
        };

        // SPI/I2S hardware configuration register
        struct SPI_I2S_HWCFGR : public RegisterReadOnly<0x5c0013f0> {
            using TXFCFG = Field<0, 4>;    // TXFCFG
            using RXFCFG = Field<4, 4>;    // RXFCFG
            using CRCCFG = Field<8, 4>;    // CRCCFG
            using I2SCFG = Field<12, 4>;    // I2SCFG
            using DSCFG = Field<16, 4>;    // DSCFG
        };

        // SPI/I2S version register
        struct SPI_VERR : public RegisterReadOnly<0x5c0013f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // SPI/I2S identification register
        struct SPI_IPIDR : public RegisterReadOnly<0x5c0013f8> {
            using ID = Field<0, 32>;    // ID
        };

        // SPI/I2S size identification register
        struct SPI_SIDR : public RegisterReadOnly<0x5c0013fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART1 {
        // Control register 1
        struct CR1 : public Register<0x5c000000> {
            using RXFFIE = Field<31, 1>;    // RXFIFO Full interrupt enable
            using TXFEIE = Field<30, 1>;    // TXFIFO empty interrupt enable
            using FIFOEN = Field<29, 1>;    // FIFO mode enable
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT = Field<21, 5>;    // DEAT
            using DEDT = Field<16, 5>;    // DEDT
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x5c000004> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD = Field<21, 2>;    // Auto baud rate mode
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
            using DIS_NSS = Field<3, 1>;    // When the DSI_NSS bit is set, the NSS pin input will be ignored
            using SLVEN = Field<0, 1>;    // Synchronous Slave mode enable
        };

        // Control register 3
        struct CR3 : public Register<0x5c000008> {
            using TXFTCFG = Field<29, 3>;    // TXFIFO threshold configuration
            using RXFTIE = Field<28, 1>;    // RXFIFO threshold interrupt enable
            using RXFTCFG = Field<25, 3>;    // Receive FIFO threshold configuration
            using TCBGTIE = Field<24, 1>;    // Tr Complete before guard time, interrupt enable
            using TXFTIE = Field<23, 1>;    // threshold interrupt enable
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x5c00000c> {
            using BRR_4_15 = Field<4, 12>;    // BRR_4_15
            using BRR_0_3 = Field<0, 4>;    // BRR_0_3
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x5c000010> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x5c000014> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x5c000018> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x5c00001c> {
            using TXFT = Field<27, 1>;    // TXFIFO threshold flag
            using RXFT = Field<26, 1>;    // RXFIFO threshold flag
            using TCBGT = Field<25, 1>;    // Transmission complete before guard time flag
            using RXFF = Field<24, 1>;    // RXFIFO Full
            using TXFE = Field<23, 1>;    // TXFIFO Empty
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using UDR = Field<13, 1>;    // SPI slave underrun error flag
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x5c000020> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using UDRCF = Field<13, 1>;    // SPI slave underrun clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCBGTCF = Field<7, 1>;    // Transmission complete before Guard time clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using TXFECF = Field<5, 1>;    // TXFIFO empty clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x5c000024> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x5c000028> {
            using Field = Field<0, 9>;    // Transmit data value
        };

        // Prescaler register
        struct PRESC : public Register<0x5c00002c> {
            using PRESCALER = Field<0, 4>;    // Clock prescaler
        };

        // USART Hardware Configuration register 2
        struct HWCFGR2 : public RegisterReadOnly<0x5c0003ec> {
            using CFG1 = Field<0, 4>;    // CFG1
            using CFG2 = Field<4, 4>;    // CFG2
        };

        // USART Hardware Configuration register 1
        struct HWCFGR1 : public RegisterReadOnly<0x5c0003f0> {
            using CFG1 = Field<0, 4>;    // CFG1
            using CFG2 = Field<4, 4>;    // CFG2
            using CFG3 = Field<8, 4>;    // CFG3
            using CFG4 = Field<12, 4>;    // CFG4
            using CFG5 = Field<16, 4>;    // CFG5
            using CFG6 = Field<20, 4>;    // CFG6
            using CFG7 = Field<24, 4>;    // CFG7
            using CFG8 = Field<28, 4>;    // CFG8
        };

        // EXTI IP Version register
        struct VERR : public RegisterReadOnly<0x5c0003f4> {
            using MINREV = Field<0, 4>;    // Minor Revision number
            using MAJREV = Field<4, 4>;    // Major Revision number
        };

        // EXTI Identification register
        struct IPIDR : public RegisterReadOnly<0x5c0003f8> {
            using IPID = Field<0, 32>;    // IP Identification
        };

        // EXTI Size ID register
        struct SIDR : public RegisterReadOnly<0x5c0003fc> {
            using SID = Field<0, 32>;    // Size Identification
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART2 {
        // Control register 1
        struct CR1 : public Register<0x4000e000> {
            using RXFFIE = Field<31, 1>;    // RXFIFO Full interrupt enable
            using TXFEIE = Field<30, 1>;    // TXFIFO empty interrupt enable
            using FIFOEN = Field<29, 1>;    // FIFO mode enable
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT = Field<21, 5>;    // DEAT
            using DEDT = Field<16, 5>;    // DEDT
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x4000e004> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD = Field<21, 2>;    // Auto baud rate mode
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
            using DIS_NSS = Field<3, 1>;    // When the DSI_NSS bit is set, the NSS pin input will be ignored
            using SLVEN = Field<0, 1>;    // Synchronous Slave mode enable
        };

        // Control register 3
        struct CR3 : public Register<0x4000e008> {
            using TXFTCFG = Field<29, 3>;    // TXFIFO threshold configuration
            using RXFTIE = Field<28, 1>;    // RXFIFO threshold interrupt enable
            using RXFTCFG = Field<25, 3>;    // Receive FIFO threshold configuration
            using TCBGTIE = Field<24, 1>;    // Tr Complete before guard time, interrupt enable
            using TXFTIE = Field<23, 1>;    // threshold interrupt enable
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4000e00c> {
            using BRR_4_15 = Field<4, 12>;    // BRR_4_15
            using BRR_0_3 = Field<0, 4>;    // BRR_0_3
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x4000e010> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x4000e014> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x4000e018> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x4000e01c> {
            using TXFT = Field<27, 1>;    // TXFIFO threshold flag
            using RXFT = Field<26, 1>;    // RXFIFO threshold flag
            using TCBGT = Field<25, 1>;    // Transmission complete before guard time flag
            using RXFF = Field<24, 1>;    // RXFIFO Full
            using TXFE = Field<23, 1>;    // TXFIFO Empty
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using UDR = Field<13, 1>;    // SPI slave underrun error flag
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x4000e020> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using UDRCF = Field<13, 1>;    // SPI slave underrun clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCBGTCF = Field<7, 1>;    // Transmission complete before Guard time clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using TXFECF = Field<5, 1>;    // TXFIFO empty clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x4000e024> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x4000e028> {
            using Field = Field<0, 9>;    // Transmit data value
        };

        // Prescaler register
        struct PRESC : public Register<0x4000e02c> {
            using PRESCALER = Field<0, 4>;    // Clock prescaler
        };

        // USART Hardware Configuration register 2
        struct HWCFGR2 : public RegisterReadOnly<0x4000e3ec> {
            using CFG1 = Field<0, 4>;    // CFG1
            using CFG2 = Field<4, 4>;    // CFG2
        };

        // USART Hardware Configuration register 1
        struct HWCFGR1 : public RegisterReadOnly<0x4000e3f0> {
            using CFG1 = Field<0, 4>;    // CFG1
            using CFG2 = Field<4, 4>;    // CFG2
            using CFG3 = Field<8, 4>;    // CFG3
            using CFG4 = Field<12, 4>;    // CFG4
            using CFG5 = Field<16, 4>;    // CFG5
            using CFG6 = Field<20, 4>;    // CFG6
            using CFG7 = Field<24, 4>;    // CFG7
            using CFG8 = Field<28, 4>;    // CFG8
        };

        // EXTI IP Version register
        struct VERR : public RegisterReadOnly<0x4000e3f4> {
            using MINREV = Field<0, 4>;    // Minor Revision number
            using MAJREV = Field<4, 4>;    // Major Revision number
        };

        // EXTI Identification register
        struct IPIDR : public RegisterReadOnly<0x4000e3f8> {
            using IPID = Field<0, 32>;    // IP Identification
        };

        // EXTI Size ID register
        struct SIDR : public RegisterReadOnly<0x4000e3fc> {
            using SID = Field<0, 32>;    // Size Identification
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART3 {
        // Control register 1
        struct CR1 : public Register<0x4000f000> {
            using RXFFIE = Field<31, 1>;    // RXFIFO Full interrupt enable
            using TXFEIE = Field<30, 1>;    // TXFIFO empty interrupt enable
            using FIFOEN = Field<29, 1>;    // FIFO mode enable
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT = Field<21, 5>;    // DEAT
            using DEDT = Field<16, 5>;    // DEDT
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x4000f004> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD = Field<21, 2>;    // Auto baud rate mode
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
            using DIS_NSS = Field<3, 1>;    // When the DSI_NSS bit is set, the NSS pin input will be ignored
            using SLVEN = Field<0, 1>;    // Synchronous Slave mode enable
        };

        // Control register 3
        struct CR3 : public Register<0x4000f008> {
            using TXFTCFG = Field<29, 3>;    // TXFIFO threshold configuration
            using RXFTIE = Field<28, 1>;    // RXFIFO threshold interrupt enable
            using RXFTCFG = Field<25, 3>;    // Receive FIFO threshold configuration
            using TCBGTIE = Field<24, 1>;    // Tr Complete before guard time, interrupt enable
            using TXFTIE = Field<23, 1>;    // threshold interrupt enable
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4000f00c> {
            using BRR_4_15 = Field<4, 12>;    // BRR_4_15
            using BRR_0_3 = Field<0, 4>;    // BRR_0_3
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x4000f010> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x4000f014> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x4000f018> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x4000f01c> {
            using TXFT = Field<27, 1>;    // TXFIFO threshold flag
            using RXFT = Field<26, 1>;    // RXFIFO threshold flag
            using TCBGT = Field<25, 1>;    // Transmission complete before guard time flag
            using RXFF = Field<24, 1>;    // RXFIFO Full
            using TXFE = Field<23, 1>;    // TXFIFO Empty
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using UDR = Field<13, 1>;    // SPI slave underrun error flag
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x4000f020> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using UDRCF = Field<13, 1>;    // SPI slave underrun clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCBGTCF = Field<7, 1>;    // Transmission complete before Guard time clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using TXFECF = Field<5, 1>;    // TXFIFO empty clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x4000f024> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x4000f028> {
            using Field = Field<0, 9>;    // Transmit data value
        };

        // Prescaler register
        struct PRESC : public Register<0x4000f02c> {
            using PRESCALER = Field<0, 4>;    // Clock prescaler
        };

        // USART Hardware Configuration register 2
        struct HWCFGR2 : public RegisterReadOnly<0x4000f3ec> {
            using CFG1 = Field<0, 4>;    // CFG1
            using CFG2 = Field<4, 4>;    // CFG2
        };

        // USART Hardware Configuration register 1
        struct HWCFGR1 : public RegisterReadOnly<0x4000f3f0> {
            using CFG1 = Field<0, 4>;    // CFG1
            using CFG2 = Field<4, 4>;    // CFG2
            using CFG3 = Field<8, 4>;    // CFG3
            using CFG4 = Field<12, 4>;    // CFG4
            using CFG5 = Field<16, 4>;    // CFG5
            using CFG6 = Field<20, 4>;    // CFG6
            using CFG7 = Field<24, 4>;    // CFG7
            using CFG8 = Field<28, 4>;    // CFG8
        };

        // EXTI IP Version register
        struct VERR : public RegisterReadOnly<0x4000f3f4> {
            using MINREV = Field<0, 4>;    // Minor Revision number
            using MAJREV = Field<4, 4>;    // Major Revision number
        };

        // EXTI Identification register
        struct IPIDR : public RegisterReadOnly<0x4000f3f8> {
            using IPID = Field<0, 32>;    // IP Identification
        };

        // EXTI Size ID register
        struct SIDR : public RegisterReadOnly<0x4000f3fc> {
            using SID = Field<0, 32>;    // Size Identification
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct UART4 {
        // Control register 1
        struct CR1 : public Register<0x40010000> {
            using RXFFIE = Field<31, 1>;    // RXFIFO Full interrupt enable
            using TXFEIE = Field<30, 1>;    // TXFIFO empty interrupt enable
            using FIFOEN = Field<29, 1>;    // FIFO mode enable
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT = Field<21, 5>;    // DEAT
            using DEDT = Field<16, 5>;    // DEDT
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40010004> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD = Field<21, 2>;    // Auto baud rate mode
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
            using DIS_NSS = Field<3, 1>;    // When the DSI_NSS bit is set, the NSS pin input will be ignored
            using SLVEN = Field<0, 1>;    // Synchronous Slave mode enable
        };

        // Control register 3
        struct CR3 : public Register<0x40010008> {
            using TXFTCFG = Field<29, 3>;    // TXFIFO threshold configuration
            using RXFTIE = Field<28, 1>;    // RXFIFO threshold interrupt enable
            using RXFTCFG = Field<25, 3>;    // Receive FIFO threshold configuration
            using TCBGTIE = Field<24, 1>;    // Tr Complete before guard time, interrupt enable
            using TXFTIE = Field<23, 1>;    // threshold interrupt enable
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4001000c> {
            using BRR_4_15 = Field<4, 12>;    // BRR_4_15
            using BRR_0_3 = Field<0, 4>;    // BRR_0_3
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40010010> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40010014> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x40010018> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x4001001c> {
            using TXFT = Field<27, 1>;    // TXFIFO threshold flag
            using RXFT = Field<26, 1>;    // RXFIFO threshold flag
            using TCBGT = Field<25, 1>;    // Transmission complete before guard time flag
            using RXFF = Field<24, 1>;    // RXFIFO Full
            using TXFE = Field<23, 1>;    // TXFIFO Empty
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using UDR = Field<13, 1>;    // SPI slave underrun error flag
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x40010020> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using UDRCF = Field<13, 1>;    // SPI slave underrun clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCBGTCF = Field<7, 1>;    // Transmission complete before Guard time clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using TXFECF = Field<5, 1>;    // TXFIFO empty clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x40010024> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40010028> {
            using Field = Field<0, 9>;    // Transmit data value
        };

        // Prescaler register
        struct PRESC : public Register<0x4001002c> {
            using PRESCALER = Field<0, 4>;    // Clock prescaler
        };

        // USART Hardware Configuration register 2
        struct HWCFGR2 : public RegisterReadOnly<0x400103ec> {
            using CFG1 = Field<0, 4>;    // CFG1
            using CFG2 = Field<4, 4>;    // CFG2
        };

        // USART Hardware Configuration register 1
        struct HWCFGR1 : public RegisterReadOnly<0x400103f0> {
            using CFG1 = Field<0, 4>;    // CFG1
            using CFG2 = Field<4, 4>;    // CFG2
            using CFG3 = Field<8, 4>;    // CFG3
            using CFG4 = Field<12, 4>;    // CFG4
            using CFG5 = Field<16, 4>;    // CFG5
            using CFG6 = Field<20, 4>;    // CFG6
            using CFG7 = Field<24, 4>;    // CFG7
            using CFG8 = Field<28, 4>;    // CFG8
        };

        // EXTI IP Version register
        struct VERR : public RegisterReadOnly<0x400103f4> {
            using MINREV = Field<0, 4>;    // Minor Revision number
            using MAJREV = Field<4, 4>;    // Major Revision number
        };

        // EXTI Identification register
        struct IPIDR : public RegisterReadOnly<0x400103f8> {
            using IPID = Field<0, 32>;    // IP Identification
        };

        // EXTI Size ID register
        struct SIDR : public RegisterReadOnly<0x400103fc> {
            using SID = Field<0, 32>;    // Size Identification
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct UART5 {
        // Control register 1
        struct CR1 : public Register<0x40011000> {
            using RXFFIE = Field<31, 1>;    // RXFIFO Full interrupt enable
            using TXFEIE = Field<30, 1>;    // TXFIFO empty interrupt enable
            using FIFOEN = Field<29, 1>;    // FIFO mode enable
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT = Field<21, 5>;    // DEAT
            using DEDT = Field<16, 5>;    // DEDT
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40011004> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD = Field<21, 2>;    // Auto baud rate mode
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
            using DIS_NSS = Field<3, 1>;    // When the DSI_NSS bit is set, the NSS pin input will be ignored
            using SLVEN = Field<0, 1>;    // Synchronous Slave mode enable
        };

        // Control register 3
        struct CR3 : public Register<0x40011008> {
            using TXFTCFG = Field<29, 3>;    // TXFIFO threshold configuration
            using RXFTIE = Field<28, 1>;    // RXFIFO threshold interrupt enable
            using RXFTCFG = Field<25, 3>;    // Receive FIFO threshold configuration
            using TCBGTIE = Field<24, 1>;    // Tr Complete before guard time, interrupt enable
            using TXFTIE = Field<23, 1>;    // threshold interrupt enable
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4001100c> {
            using BRR_4_15 = Field<4, 12>;    // BRR_4_15
            using BRR_0_3 = Field<0, 4>;    // BRR_0_3
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40011010> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40011014> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x40011018> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x4001101c> {
            using TXFT = Field<27, 1>;    // TXFIFO threshold flag
            using RXFT = Field<26, 1>;    // RXFIFO threshold flag
            using TCBGT = Field<25, 1>;    // Transmission complete before guard time flag
            using RXFF = Field<24, 1>;    // RXFIFO Full
            using TXFE = Field<23, 1>;    // TXFIFO Empty
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using UDR = Field<13, 1>;    // SPI slave underrun error flag
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x40011020> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using UDRCF = Field<13, 1>;    // SPI slave underrun clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCBGTCF = Field<7, 1>;    // Transmission complete before Guard time clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using TXFECF = Field<5, 1>;    // TXFIFO empty clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x40011024> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40011028> {
            using Field = Field<0, 9>;    // Transmit data value
        };

        // Prescaler register
        struct PRESC : public Register<0x4001102c> {
            using PRESCALER = Field<0, 4>;    // Clock prescaler
        };

        // USART Hardware Configuration register 2
        struct HWCFGR2 : public RegisterReadOnly<0x400113ec> {
            using CFG1 = Field<0, 4>;    // CFG1
            using CFG2 = Field<4, 4>;    // CFG2
        };

        // USART Hardware Configuration register 1
        struct HWCFGR1 : public RegisterReadOnly<0x400113f0> {
            using CFG1 = Field<0, 4>;    // CFG1
            using CFG2 = Field<4, 4>;    // CFG2
            using CFG3 = Field<8, 4>;    // CFG3
            using CFG4 = Field<12, 4>;    // CFG4
            using CFG5 = Field<16, 4>;    // CFG5
            using CFG6 = Field<20, 4>;    // CFG6
            using CFG7 = Field<24, 4>;    // CFG7
            using CFG8 = Field<28, 4>;    // CFG8
        };

        // EXTI IP Version register
        struct VERR : public RegisterReadOnly<0x400113f4> {
            using MINREV = Field<0, 4>;    // Minor Revision number
            using MAJREV = Field<4, 4>;    // Major Revision number
        };

        // EXTI Identification register
        struct IPIDR : public RegisterReadOnly<0x400113f8> {
            using IPID = Field<0, 32>;    // IP Identification
        };

        // EXTI Size ID register
        struct SIDR : public RegisterReadOnly<0x400113fc> {
            using SID = Field<0, 32>;    // Size Identification
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART6 {
        // Control register 1
        struct CR1 : public Register<0x44003000> {
            using RXFFIE = Field<31, 1>;    // RXFIFO Full interrupt enable
            using TXFEIE = Field<30, 1>;    // TXFIFO empty interrupt enable
            using FIFOEN = Field<29, 1>;    // FIFO mode enable
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT = Field<21, 5>;    // DEAT
            using DEDT = Field<16, 5>;    // DEDT
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x44003004> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD = Field<21, 2>;    // Auto baud rate mode
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
            using DIS_NSS = Field<3, 1>;    // When the DSI_NSS bit is set, the NSS pin input will be ignored
            using SLVEN = Field<0, 1>;    // Synchronous Slave mode enable
        };

        // Control register 3
        struct CR3 : public Register<0x44003008> {
            using TXFTCFG = Field<29, 3>;    // TXFIFO threshold configuration
            using RXFTIE = Field<28, 1>;    // RXFIFO threshold interrupt enable
            using RXFTCFG = Field<25, 3>;    // Receive FIFO threshold configuration
            using TCBGTIE = Field<24, 1>;    // Tr Complete before guard time, interrupt enable
            using TXFTIE = Field<23, 1>;    // threshold interrupt enable
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4400300c> {
            using BRR_4_15 = Field<4, 12>;    // BRR_4_15
            using BRR_0_3 = Field<0, 4>;    // BRR_0_3
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x44003010> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x44003014> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x44003018> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x4400301c> {
            using TXFT = Field<27, 1>;    // TXFIFO threshold flag
            using RXFT = Field<26, 1>;    // RXFIFO threshold flag
            using TCBGT = Field<25, 1>;    // Transmission complete before guard time flag
            using RXFF = Field<24, 1>;    // RXFIFO Full
            using TXFE = Field<23, 1>;    // TXFIFO Empty
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using UDR = Field<13, 1>;    // SPI slave underrun error flag
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x44003020> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using UDRCF = Field<13, 1>;    // SPI slave underrun clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCBGTCF = Field<7, 1>;    // Transmission complete before Guard time clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using TXFECF = Field<5, 1>;    // TXFIFO empty clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x44003024> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x44003028> {
            using Field = Field<0, 9>;    // Transmit data value
        };

        // Prescaler register
        struct PRESC : public Register<0x4400302c> {
            using PRESCALER = Field<0, 4>;    // Clock prescaler
        };

        // USART Hardware Configuration register 2
        struct HWCFGR2 : public RegisterReadOnly<0x440033ec> {
            using CFG1 = Field<0, 4>;    // CFG1
            using CFG2 = Field<4, 4>;    // CFG2
        };

        // USART Hardware Configuration register 1
        struct HWCFGR1 : public RegisterReadOnly<0x440033f0> {
            using CFG1 = Field<0, 4>;    // CFG1
            using CFG2 = Field<4, 4>;    // CFG2
            using CFG3 = Field<8, 4>;    // CFG3
            using CFG4 = Field<12, 4>;    // CFG4
            using CFG5 = Field<16, 4>;    // CFG5
            using CFG6 = Field<20, 4>;    // CFG6
            using CFG7 = Field<24, 4>;    // CFG7
            using CFG8 = Field<28, 4>;    // CFG8
        };

        // EXTI IP Version register
        struct VERR : public RegisterReadOnly<0x440033f4> {
            using MINREV = Field<0, 4>;    // Minor Revision number
            using MAJREV = Field<4, 4>;    // Major Revision number
        };

        // EXTI Identification register
        struct IPIDR : public RegisterReadOnly<0x440033f8> {
            using IPID = Field<0, 32>;    // IP Identification
        };

        // EXTI Size ID register
        struct SIDR : public RegisterReadOnly<0x440033fc> {
            using SID = Field<0, 32>;    // Size Identification
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct UART7 {
        // Control register 1
        struct CR1 : public Register<0x40018000> {
            using RXFFIE = Field<31, 1>;    // RXFIFO Full interrupt enable
            using TXFEIE = Field<30, 1>;    // TXFIFO empty interrupt enable
            using FIFOEN = Field<29, 1>;    // FIFO mode enable
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT = Field<21, 5>;    // DEAT
            using DEDT = Field<16, 5>;    // DEDT
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40018004> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD = Field<21, 2>;    // Auto baud rate mode
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
            using DIS_NSS = Field<3, 1>;    // When the DSI_NSS bit is set, the NSS pin input will be ignored
            using SLVEN = Field<0, 1>;    // Synchronous Slave mode enable
        };

        // Control register 3
        struct CR3 : public Register<0x40018008> {
            using TXFTCFG = Field<29, 3>;    // TXFIFO threshold configuration
            using RXFTIE = Field<28, 1>;    // RXFIFO threshold interrupt enable
            using RXFTCFG = Field<25, 3>;    // Receive FIFO threshold configuration
            using TCBGTIE = Field<24, 1>;    // Tr Complete before guard time, interrupt enable
            using TXFTIE = Field<23, 1>;    // threshold interrupt enable
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4001800c> {
            using BRR_4_15 = Field<4, 12>;    // BRR_4_15
            using BRR_0_3 = Field<0, 4>;    // BRR_0_3
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40018010> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40018014> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x40018018> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x4001801c> {
            using TXFT = Field<27, 1>;    // TXFIFO threshold flag
            using RXFT = Field<26, 1>;    // RXFIFO threshold flag
            using TCBGT = Field<25, 1>;    // Transmission complete before guard time flag
            using RXFF = Field<24, 1>;    // RXFIFO Full
            using TXFE = Field<23, 1>;    // TXFIFO Empty
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using UDR = Field<13, 1>;    // SPI slave underrun error flag
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x40018020> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using UDRCF = Field<13, 1>;    // SPI slave underrun clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCBGTCF = Field<7, 1>;    // Transmission complete before Guard time clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using TXFECF = Field<5, 1>;    // TXFIFO empty clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x40018024> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40018028> {
            using Field = Field<0, 9>;    // Transmit data value
        };

        // Prescaler register
        struct PRESC : public Register<0x4001802c> {
            using PRESCALER = Field<0, 4>;    // Clock prescaler
        };

        // USART Hardware Configuration register 2
        struct HWCFGR2 : public RegisterReadOnly<0x400183ec> {
            using CFG1 = Field<0, 4>;    // CFG1
            using CFG2 = Field<4, 4>;    // CFG2
        };

        // USART Hardware Configuration register 1
        struct HWCFGR1 : public RegisterReadOnly<0x400183f0> {
            using CFG1 = Field<0, 4>;    // CFG1
            using CFG2 = Field<4, 4>;    // CFG2
            using CFG3 = Field<8, 4>;    // CFG3
            using CFG4 = Field<12, 4>;    // CFG4
            using CFG5 = Field<16, 4>;    // CFG5
            using CFG6 = Field<20, 4>;    // CFG6
            using CFG7 = Field<24, 4>;    // CFG7
            using CFG8 = Field<28, 4>;    // CFG8
        };

        // EXTI IP Version register
        struct VERR : public RegisterReadOnly<0x400183f4> {
            using MINREV = Field<0, 4>;    // Minor Revision number
            using MAJREV = Field<4, 4>;    // Major Revision number
        };

        // EXTI Identification register
        struct IPIDR : public RegisterReadOnly<0x400183f8> {
            using IPID = Field<0, 32>;    // IP Identification
        };

        // EXTI Size ID register
        struct SIDR : public RegisterReadOnly<0x400183fc> {
            using SID = Field<0, 32>;    // Size Identification
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct UART8 {
        // Control register 1
        struct CR1 : public Register<0x40019000> {
            using RXFFIE = Field<31, 1>;    // RXFIFO Full interrupt enable
            using TXFEIE = Field<30, 1>;    // TXFIFO empty interrupt enable
            using FIFOEN = Field<29, 1>;    // FIFO mode enable
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT = Field<21, 5>;    // DEAT
            using DEDT = Field<16, 5>;    // DEDT
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40019004> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD = Field<21, 2>;    // Auto baud rate mode
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
            using DIS_NSS = Field<3, 1>;    // When the DSI_NSS bit is set, the NSS pin input will be ignored
            using SLVEN = Field<0, 1>;    // Synchronous Slave mode enable
        };

        // Control register 3
        struct CR3 : public Register<0x40019008> {
            using TXFTCFG = Field<29, 3>;    // TXFIFO threshold configuration
            using RXFTIE = Field<28, 1>;    // RXFIFO threshold interrupt enable
            using RXFTCFG = Field<25, 3>;    // Receive FIFO threshold configuration
            using TCBGTIE = Field<24, 1>;    // Tr Complete before guard time, interrupt enable
            using TXFTIE = Field<23, 1>;    // threshold interrupt enable
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4001900c> {
            using BRR_4_15 = Field<4, 12>;    // BRR_4_15
            using BRR_0_3 = Field<0, 4>;    // BRR_0_3
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40019010> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40019014> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x40019018> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x4001901c> {
            using TXFT = Field<27, 1>;    // TXFIFO threshold flag
            using RXFT = Field<26, 1>;    // RXFIFO threshold flag
            using TCBGT = Field<25, 1>;    // Transmission complete before guard time flag
            using RXFF = Field<24, 1>;    // RXFIFO Full
            using TXFE = Field<23, 1>;    // TXFIFO Empty
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using UDR = Field<13, 1>;    // SPI slave underrun error flag
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x40019020> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using UDRCF = Field<13, 1>;    // SPI slave underrun clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCBGTCF = Field<7, 1>;    // Transmission complete before Guard time clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using TXFECF = Field<5, 1>;    // TXFIFO empty clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x40019024> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40019028> {
            using Field = Field<0, 9>;    // Transmit data value
        };

        // Prescaler register
        struct PRESC : public Register<0x4001902c> {
            using PRESCALER = Field<0, 4>;    // Clock prescaler
        };

        // USART Hardware Configuration register 2
        struct HWCFGR2 : public RegisterReadOnly<0x400193ec> {
            using CFG1 = Field<0, 4>;    // CFG1
            using CFG2 = Field<4, 4>;    // CFG2
        };

        // USART Hardware Configuration register 1
        struct HWCFGR1 : public RegisterReadOnly<0x400193f0> {
            using CFG1 = Field<0, 4>;    // CFG1
            using CFG2 = Field<4, 4>;    // CFG2
            using CFG3 = Field<8, 4>;    // CFG3
            using CFG4 = Field<12, 4>;    // CFG4
            using CFG5 = Field<16, 4>;    // CFG5
            using CFG6 = Field<20, 4>;    // CFG6
            using CFG7 = Field<24, 4>;    // CFG7
            using CFG8 = Field<28, 4>;    // CFG8
        };

        // EXTI IP Version register
        struct VERR : public RegisterReadOnly<0x400193f4> {
            using MINREV = Field<0, 4>;    // Minor Revision number
            using MAJREV = Field<4, 4>;    // Major Revision number
        };

        // EXTI Identification register
        struct IPIDR : public RegisterReadOnly<0x400193f8> {
            using IPID = Field<0, 32>;    // IP Identification
        };

        // EXTI Size ID register
        struct SIDR : public RegisterReadOnly<0x400193fc> {
            using SID = Field<0, 32>;    // Size Identification
        };

    };

    // LTDC
    struct LTDC {
        // LTDC identification register
        struct LTDC_IDR : public RegisterReadOnly<0x5a001000> {
            using REV = Field<0, 8>;    // REV
            using MINVER = Field<8, 8>;    // MINVER
            using MAJVER = Field<16, 8>;    // MAJVER
        };

        // LDTC layer count register
        struct LTDC_LCR : public RegisterReadOnly<0x5a001004> {
            using LNBR = Field<0, 8>;    // LNBR
        };

        // This register defines the number of horizontal synchronization pixels minus 1 and the number of vertical synchronization lines minus 1. Refer to Figure274 and Section36.4: LTDC programmable parameters for an example of configuration.
        struct LTDC_SSCR : public Register<0x5a001008> {
            using VSH = Field<0, 12>;    // VSH
            using HSW = Field<16, 12>;    // HSW
        };

        // This register defines the accumulated number of horizontal synchronization and back porch pixels minus 1 (HSYNCwidth+HBP-1) and the accumulated number of vertical synchronization and back porch lines minus 1 (VSYNCheight+VBP-1). Refer to Figure274 and Section36.4: LTDC programmable parameters for an example of configuration.
        struct LTDC_BPCR : public Register<0x5a00100c> {
            using AVBP = Field<0, 12>;    // AVBP
            using AHBP = Field<16, 12>;    // AHBP
        };

        // This register defines the accumulated number of horizontal synchronization, back porch and active pixels minus 1 (HSYNC width+HBP+activewidth-1) and the accumulated number of vertical synchronization, back porch lines and active lines minus 1 (VSYNCheight+BVBP+activeheight-1). Refer to Figure274 and Section36.4: LTDC programmable parameters for an example of configuration.
        struct LTDC_AWCR : public Register<0x5a001010> {
            using AAH = Field<0, 12>;    // AAH
            using AAW = Field<16, 12>;    // AAW
        };

        // This register defines the accumulated number of horizontal synchronization, back porch, active and front porch pixels minus 1 (HSYNCwidth+HBP+activewidth+HFP-1) and the accumulated number of vertical synchronization, back porch lines, active and front lines minus 1 (VSYNCheight+BVBP+activeheight+VFP-1). Refer to Figure274 and Section36.4: LTDC programmable parameters for an example of configuration.
        struct LTDC_TWCR : public Register<0x5a001014> {
            using TOTALH = Field<0, 12>;    // TOTALH
            using TOTALW = Field<16, 12>;    // TOTALW
        };

        // This register defines the global configuration of the LCD-TFT controller.
        struct LTDC_GCR : public Register<0x5a001018> {
            using LTDCEN = Field<0, 1>;    // LTDCEN
            using DBW = Field<4, 3>;    // DBW
            using DGW = Field<8, 3>;    // DGW
            using DRW = Field<12, 3>;    // DRW
            using DEN = Field<16, 1>;    // DEN
            using PCPOL = Field<28, 1>;    // PCPOL
            using DEPOL = Field<29, 1>;    // DEPOL
            using VSPOL = Field<30, 1>;    // VSPOL
            using HSPOL = Field<31, 1>;    // HSPOL
        };

        // LTDC global configuration 1 register
        struct LTDC_GC1R : public RegisterReadOnly<0x5a00101c> {
            using WBCH = Field<0, 4>;    // WBCH
            using WGCH = Field<4, 4>;    // WGCH
            using WRCH = Field<8, 4>;    // WRCH
            using PRBEN = Field<12, 1>;    // PRBEN
            using DT = Field<14, 2>;    // DT
            using GCT = Field<17, 3>;    // GCT
            using SHREN = Field<21, 1>;    // SHREN
            using BCP = Field<22, 1>;    // BCP
            using BBEN = Field<23, 1>;    // BBEN
            using LNIP = Field<24, 1>;    // LNIP
            using TP = Field<25, 1>;    // TP
            using IPP = Field<26, 1>;    // IPP
            using SPP = Field<27, 1>;    // SPP
            using DWP = Field<28, 1>;    // DWP
            using STREN = Field<29, 1>;    // STREN
            using BMEN = Field<31, 1>;    // BMEN
        };

        // LTDC global configuration 2 register
        struct LTDC_GC2R : public RegisterReadOnly<0x5a001020> {
            using EDCEN = Field<0, 1>;    // EDCEN
            using STSAEN = Field<1, 1>;    // STSAEN
            using DVAEN = Field<2, 1>;    // DVAEN
            using DPAEN = Field<3, 1>;    // DPAEN
            using BW = Field<4, 3>;    // BW
            using EDCA = Field<7, 1>;    // EDCA
        };

        // This register allows to reload either immediately or during the vertical blanking period, the shadow registers values to the active registers. The shadow registers are all Layer1 and Layer2 registers except the LTDC_L1CLUTWR and the LTDC_L2CLUTWR.
        struct LTDC_SRCR : public Register<0x5a001024> {
            using IMR = Field<0, 1>;    // IMR
            using VBR = Field<1, 1>;    // VBR
        };

        // This register defines the background color (RGB888).
        struct LTDC_BCCR : public Register<0x5a00102c> {
            using BCBLUE = Field<0, 8>;    // BCBLUE
            using BCGREEN = Field<8, 8>;    // BCGREEN
            using BCRED = Field<16, 8>;    // BCRED
        };

        // This register determines which status flags generate an interrupt request by setting the corresponding bit to 1.
        struct LTDC_IER : public Register<0x5a001034> {
            using LIE = Field<0, 1>;    // LIE
            using FUIE = Field<1, 1>;    // FUIE
            using TERRIE = Field<2, 1>;    // TERRIE
            using RRIE = Field<3, 1>;    // RRIE
        };

        // This register returns the interrupt status flag.
        struct LTDC_ISR : public RegisterReadOnly<0x5a001038> {
            using LIF = Field<0, 1>;    // LIF
            using FUIF = Field<1, 1>;    // FUIF
            using TERRIF = Field<2, 1>;    // TERRIF
            using RRIF = Field<3, 1>;    // RRIF
        };

        // LTDC Interrupt Clear Register
        struct LTDC_ICR : public RegisterWriteOnly<0x5a00103c> {
            using CLIF = Field<0, 1>;    // CLIF
            using CFUIF = Field<1, 1>;    // CFUIF
            using CTERRIF = Field<2, 1>;    // CTERRIF
            using CRRIF = Field<3, 1>;    // CRRIF
        };

        // This register defines the position of the line interrupt. The line value to be programmed depends on the timings parameters. Refer to Figure274.
        struct LTDC_LIPCR : public Register<0x5a001040> {
            using LIPOS = Field<0, 12>;    // LIPOS
        };

        // LTDC current position status register
        struct LTDC_CPSR : public RegisterReadOnly<0x5a001044> {
            using CYPOS = Field<0, 16>;    // CYPOS
            using CXPOS = Field<16, 16>;    // CXPOS
        };

        // This register returns the status of the current display phase which is controlled by the HSYNC, VSYNC, and horizontal/vertical DE signals. Example: if the current display phase is the vertical synchronization, the VSYNCS bit is set (active high). If the current display phase is the horizontal synchronization, the HSYNCS bit is active high.
        struct LTDC_CDSR : public RegisterReadOnly<0x5a001048> {
            using VDES = Field<0, 1>;    // VDES
            using HDES = Field<1, 1>;    // HDES
            using VSYNCS = Field<2, 1>;    // VSYNCS
            using HSYNCS = Field<3, 1>;    // HSYNCS
        };

        // LTDC layer 1 control register
        struct LTDC_L1CR : public Register<0x5a001084> {
            using LEN = Field<0, 1>;    // LEN
            using COLKEN = Field<1, 1>;    // COLKEN
            using CLUTEN = Field<4, 1>;    // CLUTEN
        };

        // This register defines the horizontal position (first and last pixel) of the layer 1 or 2 window. The first visible pixel of a line is the programmed value of AHBP[11:0] bits + 1 in the LTDC_BPCR register. The last visible pixel of a line is the programmed value of AAW[11:0] bits in the LTDC_AWCR register.
        struct LTDC_L1WHPCR : public Register<0x5a001088> {
            using WHSTPOS = Field<0, 12>;    // WHSTPOS
            using WHSPPOS = Field<16, 12>;    // WHSPPOS
        };

        // This register defines the vertical position (first and last line) of the layer1 or 2 window. The first visible line of a frame is the programmed value of AVBP[11:0] bits + 1 in the register LTDC_BPCR register. The last visible line of a frame is the programmed value of AAH[11:0] bits in the LTDC_AWCR register.
        struct LTDC_L1WVPCR : public Register<0x5a00108c> {
            using WVSTPOS = Field<0, 12>;    // WVSTPOS
            using WVSPPOS = Field<16, 12>;    // WVSPPOS
        };

        // This register defines the color key value (RGB), that is used by the color keying.
        struct LTDC_L1CKCR : public Register<0x5a001090> {
            using CKBLUE = Field<0, 8>;    // CKBLUE
            using CKGREEN = Field<8, 8>;    // CKGREEN
            using CKRED = Field<16, 8>;    // CKRED
        };

        // This register defines the pixel format that is used for the stored data in the frame buffer of a layer. The pixel data is read from the frame buffer and then transformed to the internal format 8888 (ARGB).
        struct LTDC_L1PFCR : public Register<0x5a001094> {
            using PF = Field<0, 3>;    // PF
        };

        // This register defines the constant alpha value (divided by 255 by hardware), that is used in the alpha blending. Refer to LTDC_LxBFCR register.
        struct LTDC_L1CACR : public Register<0x5a001098> {
            using CONSTA = Field<0, 8>;    // CONSTA
        };

        // This register defines the default color of a layer in the format ARGB. The default color is used outside the defined layer window or when a layer is disabled. The reset value of 0x00000000 defines a transparent black color.
        struct LTDC_L1DCCR : public Register<0x5a00109c> {
            using DCBLUE = Field<0, 8>;    // DCBLUE
            using DCGREEN = Field<8, 8>;    // DCGREEN
            using DCRED = Field<16, 8>;    // DCRED
            using DCALPHA = Field<24, 8>;    // DCALPHA
        };

        // This register defines the blending factors F1 and F2. The general blending formula is: BC = BF1 x C + BF2 x Cs BC = blended color BF1 = blend factor 1 C = current layer color BF2 = blend factor 2 Cs = subjacent layers blended color
        struct LTDC_L1BFCR : public Register<0x5a0010a0> {
            using BF2 = Field<0, 3>;    // BF2
            using BF1 = Field<8, 3>;    // BF1
        };

        // This register defines the color frame buffer start address which has to point to the address where the pixel data of the top left pixel of a layer is stored in the frame buffer.
        struct LTDC_L1CFBAR : public Register<0x5a0010ac> {
            using CFBADD = Field<0, 32>;    // CFBADD
        };

        // This register defines the color frame buffer line length and pitch.
        struct LTDC_L1CFBLR : public Register<0x5a0010b0> {
            using CFBLL = Field<0, 14>;    // CFBLL
            using CFBP = Field<16, 14>;    // CFBP
        };

        // This register defines the number of lines in the color frame buffer.
        struct LTDC_L1CFBLNR : public Register<0x5a0010b4> {
            using CFBLNBR = Field<0, 12>;    // CFBLNBR
        };

        // This register defines the CLUT address and the RGB value.
        struct LTDC_L1CLUTWR : public RegisterWriteOnly<0x5a0010c4> {
            using BLUE = Field<0, 8>;    // BLUE
            using GREEN = Field<8, 8>;    // GREEN
            using RED = Field<16, 8>;    // RED
            using CLUTADD = Field<24, 8>;    // CLUTADD
        };

        // LTDC layer 2 control register
        struct LTDC_L2CR : public Register<0x5a001104> {
            using LEN = Field<0, 1>;    // LEN
            using COLKEN = Field<1, 1>;    // COLKEN
            using CLUTEN = Field<4, 1>;    // CLUTEN
        };

        // This register defines the horizontal position (first and last pixel) of the layer 1 or 2 window. The first visible pixel of a line is the programmed value of AHBP[11:0] bits + 1 in the LTDC_BPCR register. The last visible pixel of a line is the programmed value of AAW[11:0] bits in the LTDC_AWCR register.
        struct LTDC_L2WHPCR : public Register<0x5a001108> {
            using WHSTPOS = Field<0, 12>;    // WHSTPOS
            using WHSPPOS = Field<16, 12>;    // WHSPPOS
        };

        // This register defines the vertical position (first and last line) of the layer1 or 2 window. The first visible line of a frame is the programmed value of AVBP[11:0] bits + 1 in the register LTDC_BPCR register. The last visible line of a frame is the programmed value of AAH[11:0] bits in the LTDC_AWCR register.
        struct LTDC_L2WVPCR : public Register<0x5a00110c> {
            using WVSTPOS = Field<0, 12>;    // WVSTPOS
            using WVSPPOS = Field<16, 12>;    // WVSPPOS
        };

        // This register defines the color key value (RGB), that is used by the color keying.
        struct LTDC_L2CKCR : public Register<0x5a001110> {
            using CKBLUE = Field<0, 8>;    // CKBLUE
            using CKGREEN = Field<8, 8>;    // CKGREEN
            using CKRED = Field<16, 8>;    // CKRED
        };

        // This register defines the pixel format that is used for the stored data in the frame buffer of a layer. The pixel data is read from the frame buffer and then transformed to the internal format 8888 (ARGB).
        struct LTDC_L2PFCR : public Register<0x5a001114> {
            using PF = Field<0, 3>;    // PF
        };

        // This register defines the constant alpha value (divided by 255 by hardware), that is used in the alpha blending. Refer to LTDC_LxBFCR register.
        struct LTDC_L2CACR : public Register<0x5a001118> {
            using CONSTA = Field<0, 8>;    // CONSTA
        };

        // This register defines the default color of a layer in the format ARGB. The default color is used outside the defined layer window or when a layer is disabled. The reset value of 0x00000000 defines a transparent black color.
        struct LTDC_L2DCCR : public Register<0x5a00111c> {
            using DCBLUE = Field<0, 8>;    // DCBLUE
            using DCGREEN = Field<8, 8>;    // DCGREEN
            using DCRED = Field<16, 8>;    // DCRED
            using DCALPHA = Field<24, 8>;    // DCALPHA
        };

        // This register defines the blending factors F1 and F2. The general blending formula is: BC = BF1 x C + BF2 x Cs BC = blended color BF1 = blend factor 1 C = current layer color BF2 = blend factor 2 Cs = subjacent layers blended color
        struct LTDC_L2BFCR : public Register<0x5a001120> {
            using BF2 = Field<0, 3>;    // BF2
            using BF1 = Field<8, 3>;    // BF1
        };

        // This register defines the color frame buffer start address which has to point to the address where the pixel data of the top left pixel of a layer is stored in the frame buffer.
        struct LTDC_L2CFBAR : public Register<0x5a00112c> {
            using CFBADD = Field<0, 32>;    // CFBADD
        };

        // This register defines the color frame buffer line length and pitch.
        struct LTDC_L2CFBLR : public Register<0x5a001130> {
            using CFBLL = Field<0, 14>;    // CFBLL
            using CFBP = Field<16, 14>;    // CFBP
        };

        // This register defines the number of lines in the color frame buffer.
        struct LTDC_L2CFBLNR : public Register<0x5a001134> {
            using CFBLNBR = Field<0, 12>;    // CFBLNBR
        };

        // This register defines the CLUT address and the RGB value.
        struct LTDC_L2CLUTWR : public RegisterWriteOnly<0x5a001144> {
            using BLUE = Field<0, 8>;    // BLUE
            using GREEN = Field<8, 8>;    // GREEN
            using RED = Field<16, 8>;    // RED
            using CLUTADD = Field<24, 8>;    // CLUTADD
        };

    };

    // USBPHYC
    struct USBPHYC {
        // This register is used to control the PLL of the HS PHY.
        struct USBPHYC_PLL : public Register<0x5a006000> {
            using PLLNDIV = Field<0, 7>;    // PLLNDIV
            using PLLODF = Field<7, 3>;    // PLLODF
            using PLLFRACIN = Field<10, 16>;    // PLLFRACIN
            using PLLEN = Field<26, 1>;    // PLLEN
            using PLLSTRB = Field<27, 1>;    // PLLSTRB
            using PLLSTRBYP = Field<28, 1>;    // PLLSTRBYP
            using PLLFRACCTL = Field<29, 1>;    // PLLFRACCTL
            using PLLDITHEN0 = Field<30, 1>;    // PLLDITHEN0
            using PLLDITHEN1 = Field<31, 1>;    // PLLDITHEN1
        };

        // This register is used to control the switch between controllers for the HS PHY.
        struct USBPHYC_MISC : public Register<0x5a006008> {
            using SWITHOST = Field<0, 1>;    // SWITHOST
            using PPCKDIS = Field<1, 2>;    // PPCKDIS
        };

        // This register is used to control the tune interface of the HS PHY, port #x.
        struct USBPHYC_TUNE1 : public Register<0x5a00610c> {
            using INCURREN = Field<0, 1>;    // INCURREN
            using INCURRINT = Field<1, 1>;    // INCURRINT
            using LFSCAPEN = Field<2, 1>;    // LFSCAPEN
            using HSDRVSLEW = Field<3, 1>;    // HSDRVSLEW
            using HSDRVDCCUR = Field<4, 1>;    // HSDRVDCCUR
            using HSDRVDCLEV = Field<5, 1>;    // HSDRVDCLEV
            using HSDRVCURINCR = Field<6, 1>;    // HSDRVCURINCR
            using FSDRVRFADJ = Field<7, 1>;    // FSDRVRFADJ
            using HSDRVRFRED = Field<8, 1>;    // HSDRVRFRED
            using HSDRVCHKITRM = Field<9, 4>;    // HSDRVCHKITRM
            using HSDRVCHKZTRM = Field<13, 2>;    // HSDRVCHKZTRM
            using OTPCOMP = Field<15, 5>;    // OTPCOMP
            using SQLCHCTL = Field<20, 2>;    // SQLCHCTL
            using HDRXGNEQEN = Field<22, 1>;    // HDRXGNEQEN
            using HSRXOFF = Field<23, 2>;    // HSRXOFF
            using HSFALLPREEM = Field<25, 1>;    // HSFALLPREEM
            using SHTCCTCTLPROT = Field<26, 1>;    // SHTCCTCTLPROT
            using STAGSEL = Field<27, 1>;    // STAGSEL
        };

        // This register is used to control the tune interface of the HS PHY, port #x.
        struct USBPHYC_TUNE2 : public Register<0x5a00620c> {
            using INCURREN = Field<0, 1>;    // INCURREN
            using INCURRINT = Field<1, 1>;    // INCURRINT
            using LFSCAPEN = Field<2, 1>;    // LFSCAPEN
            using HSDRVSLEW = Field<3, 1>;    // HSDRVSLEW
            using HSDRVDCCUR = Field<4, 1>;    // HSDRVDCCUR
            using HSDRVDCLEV = Field<5, 1>;    // HSDRVDCLEV
            using HSDRVCURINCR = Field<6, 1>;    // HSDRVCURINCR
            using FSDRVRFADJ = Field<7, 1>;    // FSDRVRFADJ
            using HSDRVRFRED = Field<8, 1>;    // HSDRVRFRED
            using HSDRVCHKITRM = Field<9, 4>;    // HSDRVCHKITRM
            using HSDRVCHKZTRM = Field<13, 2>;    // HSDRVCHKZTRM
            using OTPCOMP = Field<15, 5>;    // OTPCOMP
            using SQLCHCTL = Field<20, 2>;    // SQLCHCTL
            using HDRXGNEQEN = Field<22, 1>;    // HDRXGNEQEN
            using HSRXOFF = Field<23, 2>;    // HSRXOFF
            using HSFALLPREEM = Field<25, 1>;    // HSFALLPREEM
            using SHTCCTCTLPROT = Field<26, 1>;    // SHTCCTCTLPROT
            using STAGSEL = Field<27, 1>;    // STAGSEL
        };

        // This register defines the version of this IP.
        struct USBPHYC_VERR : public RegisterReadOnly<0x5a006ffc> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

    };

    // CRC1
    struct CRC1 {
        // CRC data register
        struct CRC_DR : public Register<0x58009000> {
            using DR = Field<0, 32>;    // DR
        };

        // CRC independent data register
        struct CRC_IDR : public Register<0x58009004> {
            using IDR = Field<0, 32>;    // IDR
        };

        // CRC control register
        struct CRC_CR : public Register<0x58009008> {
            using RESET = Field<0, 1>;    // RESET
            using POLYSIZE = Field<3, 2>;    // POLYSIZE
            using REV_IN = Field<5, 2>;    // REV_IN
            using REV_OUT = Field<7, 1>;    // REV_OUT
        };

        // CRC initial value
        struct CRC_INIT : public Register<0x58009010> {
            using Field = Field<0, 32>;    // CRC_INIT
        };

        // CRC polynomial
        struct CRC_POL : public Register<0x58009014> {
            using POL = Field<0, 32>;    // POL
        };

    };

    // CRC1
    struct CRC2 {
        // CRC data register
        struct CRC_DR : public Register<0x4c004000> {
            using DR = Field<0, 32>;    // DR
        };

        // CRC independent data register
        struct CRC_IDR : public Register<0x4c004004> {
            using IDR = Field<0, 32>;    // IDR
        };

        // CRC control register
        struct CRC_CR : public Register<0x4c004008> {
            using RESET = Field<0, 1>;    // RESET
            using POLYSIZE = Field<3, 2>;    // POLYSIZE
            using REV_IN = Field<5, 2>;    // REV_IN
            using REV_OUT = Field<7, 1>;    // REV_OUT
        };

        // CRC initial value
        struct CRC_INIT : public Register<0x4c004010> {
            using Field = Field<0, 32>;    // CRC_INIT
        };

        // CRC polynomial
        struct CRC_POL : public Register<0x4c004014> {
            using POL = Field<0, 32>;    // POL
        };

    };

    // SDMMC1
    struct SDMMC1 {
        // SDMMC power control register
        struct SDMMC_POWER : public Register<0x58005000> {
            using PWRCTRL = Field<0, 2>;    // PWRCTRL
            using VSWITCH = Field<2, 1>;    // VSWITCH
            using VSWITCHEN = Field<3, 1>;    // VSWITCHEN
            using DIRPOL = Field<4, 1>;    // DIRPOL
        };

        // The SDMMC_CLKCR register controls the SDMMC_CK output clock, the sdmmc_rx_ck receive clock, and the bus width.
        struct SDMMC_CLKCR : public Register<0x58005004> {
            using CLKDIV = Field<0, 10>;    // CLKDIV
            using PWRSAV = Field<12, 1>;    // PWRSAV
            using WIDBUS = Field<14, 2>;    // WIDBUS
            using NEGEDGE = Field<16, 1>;    // NEGEDGE
            using HWFC_EN = Field<17, 1>;    // HWFC_EN
            using DDR = Field<18, 1>;    // DDR
            using BUSSPEED = Field<19, 1>;    // BUSSPEED
            using SELCLKRX = Field<20, 2>;    // SELCLKRX
        };

        // The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message.
        struct SDMMC_ARGR : public Register<0x58005008> {
            using CMDARG = Field<0, 32>;    // CMDARG
        };

        // The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM).
        struct SDMMC_CMDR : public Register<0x5800500c> {
            using CMDINDEX = Field<0, 6>;    // CMDINDEX
            using CMDTRANS = Field<6, 1>;    // CMDTRANS
            using CMDSTOP = Field<7, 1>;    // CMDSTOP
            using WAITRESP = Field<8, 2>;    // WAITRESP
            using WAITINT = Field<10, 1>;    // WAITINT
            using WAITPEND = Field<11, 1>;    // WAITPEND
            using CPSMEN = Field<12, 1>;    // CPSMEN
            using DTHOLD = Field<13, 1>;    // DTHOLD
            using BOOTMODE = Field<14, 1>;    // BOOTMODE
            using BOOTEN = Field<15, 1>;    // BOOTEN
            using CMDSUSPEND = Field<16, 1>;    // CMDSUSPEND
        };

        // The SDMMC_RESPCMDR register contains the command index field of the last command response received. If the command response transmission does not contain the command index field (long or OCR response), the RESPCMD field is unknown, although it must contain 111111b (the value of the reserved field from the response).
        struct SDMMC_RESPCMDR : public RegisterReadOnly<0x58005010> {
            using RESPCMD = Field<0, 6>;    // RESPCMD
        };

        // The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
        struct SDMMC_RESP1R : public RegisterReadOnly<0x58005014> {
            using CARDSTATUS1 = Field<0, 32>;    // CARDSTATUS1
        };

        // The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
        struct SDMMC_RESP2R : public RegisterReadOnly<0x58005018> {
            using CARDSTATUS2 = Field<0, 32>;    // CARDSTATUS2
        };

        // The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
        struct SDMMC_RESP3R : public RegisterReadOnly<0x5800501c> {
            using CARDSTATUS3 = Field<0, 32>;    // CARDSTATUS3
        };

        // The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
        struct SDMMC_RESP4R : public RegisterReadOnly<0x58005020> {
            using CARDSTATUS4 = Field<0, 32>;    // CARDSTATUS4
        };

        // The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_R or Busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set.
        struct SDMMC_DTIMER : public Register<0x58005024> {
            using DATATIME = Field<0, 32>;    // DATATIME
        };

        // The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts.
        struct SDMMC_DLENR : public Register<0x58005028> {
            using DATALENGTH = Field<0, 25>;    // DATALENGTH
        };

        // The SDMMC_DCTRL register control the data path state machine (DPSM).
        struct SDMMC_DCTRL : public Register<0x5800502c> {
            using DTEN = Field<0, 1>;    // DTEN
            using DTDIR = Field<1, 1>;    // DTDIR
            using DTMODE = Field<2, 2>;    // DTMODE
            using DBLOCKSIZE = Field<4, 4>;    // DBLOCKSIZE
            using RWSTART = Field<8, 1>;    // RWSTART
            using RWSTOP = Field<9, 1>;    // RWSTOP
            using RWMOD = Field<10, 1>;    // RWMOD
            using SDIOEN = Field<11, 1>;    // SDIOEN
            using BOOTACKEN = Field<12, 1>;    // BOOTACKEN
            using FIFORST = Field<13, 1>;    // FIFORST
        };

        // The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the Idle state to the Wait_R or Wait_S state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the Idle state and when there has been no error, the data status end flag (DATAEND) is set.
        struct SDMMC_DCNTR : public RegisterReadOnly<0x58005030> {
            using DATACOUNT = Field<0, 25>;    // DATACOUNT
        };

        // The SDMMC_STAR register is a read-only register. It contains two types of flag: Static flags (bits [28, 21, 11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt Clear register (see SDMMC_ICR) Dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO)
        struct SDMMC_STAR : public RegisterReadOnly<0x58005034> {
            using CCRCFAIL = Field<0, 1>;    // CCRCFAIL
            using DCRCFAIL = Field<1, 1>;    // DCRCFAIL
            using CTIMEOUT = Field<2, 1>;    // CTIMEOUT
            using DTIMEOUT = Field<3, 1>;    // DTIMEOUT
            using TXUNDERR = Field<4, 1>;    // TXUNDERR
            using RXOVERR = Field<5, 1>;    // RXOVERR
            using CMDREND = Field<6, 1>;    // CMDREND
            using CMDSENT = Field<7, 1>;    // CMDSENT
            using DATAEND = Field<8, 1>;    // DATAEND
            using DHOLD = Field<9, 1>;    // DHOLD
            using DBCKEND = Field<10, 1>;    // DBCKEND
            using DABORT = Field<11, 1>;    // DABORT
            using DPSMACT = Field<12, 1>;    // DPSMACT
            using CPSMACT = Field<13, 1>;    // CPSMACT
            using TXFIFOHE = Field<14, 1>;    // TXFIFOHE
            using RXFIFOHF = Field<15, 1>;    // RXFIFOHF
            using TXFIFOF = Field<16, 1>;    // TXFIFOF
            using RXFIFOF = Field<17, 1>;    // RXFIFOF
            using TXFIFOE = Field<18, 1>;    // TXFIFOE
            using RXFIFOE = Field<19, 1>;    // RXFIFOE
            using BUSYD0 = Field<20, 1>;    // BUSYD0
            using BUSYD0END = Field<21, 1>;    // BUSYD0END
            using SDIOIT = Field<22, 1>;    // SDIOIT
            using ACKFAIL = Field<23, 1>;    // ACKFAIL
            using ACKTIMEOUT = Field<24, 1>;    // ACKTIMEOUT
            using VSWEND = Field<25, 1>;    // VSWEND
            using CKSTOP = Field<26, 1>;    // CKSTOP
            using IDMATE = Field<27, 1>;    // IDMATE
            using IDMABTC = Field<28, 1>;    // IDMABTC
        };

        // The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register.
        struct SDMMC_ICR : public Register<0x58005038> {
            using CCRCFAILC = Field<0, 1>;    // CCRCFAILC
            using DCRCFAILC = Field<1, 1>;    // DCRCFAILC
            using CTIMEOUTC = Field<2, 1>;    // CTIMEOUTC
            using DTIMEOUTC = Field<3, 1>;    // DTIMEOUTC
            using TXUNDERRC = Field<4, 1>;    // TXUNDERRC
            using RXOVERRC = Field<5, 1>;    // RXOVERRC
            using CMDRENDC = Field<6, 1>;    // CMDRENDC
            using CMDSENTC = Field<7, 1>;    // CMDSENTC
            using DATAENDC = Field<8, 1>;    // DATAENDC
            using DHOLDC = Field<9, 1>;    // DHOLDC
            using DBCKENDC = Field<10, 1>;    // DBCKENDC
            using DABORTC = Field<11, 1>;    // DABORTC
            using BUSYD0ENDC = Field<21, 1>;    // BUSYD0ENDC
            using SDIOITC = Field<22, 1>;    // SDIOITC
            using ACKFAILC = Field<23, 1>;    // ACKFAILC
            using ACKTIMEOUTC = Field<24, 1>;    // ACKTIMEOUTC
            using VSWENDC = Field<25, 1>;    // VSWENDC
            using CKSTOPC = Field<26, 1>;    // CKSTOPC
            using IDMATEC = Field<27, 1>;    // IDMATEC
            using IDMABTCC = Field<28, 1>;    // IDMABTCC
        };

        // The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1.
        struct SDMMC_MASKR : public Register<0x5800503c> {
            using CCRCFAILIE = Field<0, 1>;    // CCRCFAILIE
            using DCRCFAILIE = Field<1, 1>;    // DCRCFAILIE
            using CTIMEOUTIE = Field<2, 1>;    // CTIMEOUTIE
            using DTIMEOUTIE = Field<3, 1>;    // DTIMEOUTIE
            using TXUNDERRIE = Field<4, 1>;    // TXUNDERRIE
            using RXOVERRIE = Field<5, 1>;    // RXOVERRIE
            using CMDRENDIE = Field<6, 1>;    // CMDRENDIE
            using CMDSENTIE = Field<7, 1>;    // CMDSENTIE
            using DATAENDIE = Field<8, 1>;    // DATAENDIE
            using DHOLDIE = Field<9, 1>;    // DHOLDIE
            using DBCKENDIE = Field<10, 1>;    // DBCKENDIE
            using DABORTIE = Field<11, 1>;    // DABORTIE
            using TXFIFOHEIE = Field<14, 1>;    // TXFIFOHEIE
            using RXFIFOHFIE = Field<15, 1>;    // RXFIFOHFIE
            using RXFIFOFIE = Field<17, 1>;    // RXFIFOFIE
            using TXFIFOEIE = Field<18, 1>;    // TXFIFOEIE
            using BUSYD0ENDIE = Field<21, 1>;    // BUSYD0ENDIE
            using SDIOITIE = Field<22, 1>;    // SDIOITIE
            using ACKFAILIE = Field<23, 1>;    // ACKFAILIE
            using ACKTIMEOUTIE = Field<24, 1>;    // ACKTIMEOUTIE
            using VSWENDIE = Field<25, 1>;    // VSWENDIE
            using CKSTOPIE = Field<26, 1>;    // CKSTOPIE
            using IDMABTCIE = Field<28, 1>;    // IDMABTCIE
        };

        // The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_Ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set.
        struct SDMMC_ACKTIMER : public Register<0x58005040> {
            using ACKTIME = Field<0, 25>;    // ACKTIME
        };

        // The receive and transmit FIFOs can be read or written as 32-bit wide registers. The FIFOs contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.
        struct SDMMC_IDMACTRLR : public Register<0x58005050> {
            using IDMAEN = Field<0, 1>;    // IDMAEN
            using IDMABMODE = Field<1, 1>;    // IDMABMODE
        };

        // The SDMMC_IDMABSIZER register contains the buffer size when in linked list configuration.
        struct SDMMC_IDMABSIZER : public Register<0x58005054> {
            using IDMABNDT = Field<5, 12>;    // IDMABNDT
        };

        // The SDMMC_IDMABASER register contains the memory buffer base address in single buffer configuration and linked list configuration.
        struct SDMMC_IDMABASER : public Register<0x58005058> {
            using IDMABASE = Field<0, 32>;    // IDMABASE
        };

        // SDMMC IDMA linked list address register
        struct SDMMC_IDMALAR : public Register<0x58005064> {
            using IDMALA = Field<2, 14>;    // IDMALA
            using ABR = Field<29, 1>;    // ABR
            using ULS = Field<30, 1>;    // ULS
            using ULA = Field<31, 1>;    // ULA
        };

        // SDMMC IDMA linked list memory base register
        struct SDMMC_IDMABAR : public Register<0x58005068> {
            using IDMABA = Field<2, 30>;    // IDMABA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR0 : public Register<0x58005080> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR1 : public Register<0x58005084> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR2 : public Register<0x58005088> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR3 : public Register<0x5800508c> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR4 : public Register<0x58005090> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR5 : public Register<0x58005094> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR6 : public Register<0x58005098> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR7 : public Register<0x5800509c> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR8 : public Register<0x580050a0> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR9 : public Register<0x580050a4> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR10 : public Register<0x580050a8> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR11 : public Register<0x580050ac> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR12 : public Register<0x580050b0> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR13 : public Register<0x580050b4> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR14 : public Register<0x580050b8> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR15 : public Register<0x580050bc> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // SDMMC version register
        struct SDMMC_VERR : public RegisterReadOnly<0x580053f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // SDMMC identification register
        struct SDMMC_IPIDR : public RegisterReadOnly<0x580053f8> {
            using IP_ID = Field<0, 32>;    // IP_ID
        };

        // SDMMC size ID register
        struct SDMMC_SIDR : public RegisterReadOnly<0x580053fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // SDMMC1
    struct SDMMC2 {
        // SDMMC power control register
        struct SDMMC_POWER : public Register<0x58007000> {
            using PWRCTRL = Field<0, 2>;    // PWRCTRL
            using VSWITCH = Field<2, 1>;    // VSWITCH
            using VSWITCHEN = Field<3, 1>;    // VSWITCHEN
            using DIRPOL = Field<4, 1>;    // DIRPOL
        };

        // The SDMMC_CLKCR register controls the SDMMC_CK output clock, the sdmmc_rx_ck receive clock, and the bus width.
        struct SDMMC_CLKCR : public Register<0x58007004> {
            using CLKDIV = Field<0, 10>;    // CLKDIV
            using PWRSAV = Field<12, 1>;    // PWRSAV
            using WIDBUS = Field<14, 2>;    // WIDBUS
            using NEGEDGE = Field<16, 1>;    // NEGEDGE
            using HWFC_EN = Field<17, 1>;    // HWFC_EN
            using DDR = Field<18, 1>;    // DDR
            using BUSSPEED = Field<19, 1>;    // BUSSPEED
            using SELCLKRX = Field<20, 2>;    // SELCLKRX
        };

        // The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message.
        struct SDMMC_ARGR : public Register<0x58007008> {
            using CMDARG = Field<0, 32>;    // CMDARG
        };

        // The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM).
        struct SDMMC_CMDR : public Register<0x5800700c> {
            using CMDINDEX = Field<0, 6>;    // CMDINDEX
            using CMDTRANS = Field<6, 1>;    // CMDTRANS
            using CMDSTOP = Field<7, 1>;    // CMDSTOP
            using WAITRESP = Field<8, 2>;    // WAITRESP
            using WAITINT = Field<10, 1>;    // WAITINT
            using WAITPEND = Field<11, 1>;    // WAITPEND
            using CPSMEN = Field<12, 1>;    // CPSMEN
            using DTHOLD = Field<13, 1>;    // DTHOLD
            using BOOTMODE = Field<14, 1>;    // BOOTMODE
            using BOOTEN = Field<15, 1>;    // BOOTEN
            using CMDSUSPEND = Field<16, 1>;    // CMDSUSPEND
        };

        // The SDMMC_RESPCMDR register contains the command index field of the last command response received. If the command response transmission does not contain the command index field (long or OCR response), the RESPCMD field is unknown, although it must contain 111111b (the value of the reserved field from the response).
        struct SDMMC_RESPCMDR : public RegisterReadOnly<0x58007010> {
            using RESPCMD = Field<0, 6>;    // RESPCMD
        };

        // The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
        struct SDMMC_RESP1R : public RegisterReadOnly<0x58007014> {
            using CARDSTATUS1 = Field<0, 32>;    // CARDSTATUS1
        };

        // The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
        struct SDMMC_RESP2R : public RegisterReadOnly<0x58007018> {
            using CARDSTATUS2 = Field<0, 32>;    // CARDSTATUS2
        };

        // The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
        struct SDMMC_RESP3R : public RegisterReadOnly<0x5800701c> {
            using CARDSTATUS3 = Field<0, 32>;    // CARDSTATUS3
        };

        // The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
        struct SDMMC_RESP4R : public RegisterReadOnly<0x58007020> {
            using CARDSTATUS4 = Field<0, 32>;    // CARDSTATUS4
        };

        // The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_R or Busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set.
        struct SDMMC_DTIMER : public Register<0x58007024> {
            using DATATIME = Field<0, 32>;    // DATATIME
        };

        // The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts.
        struct SDMMC_DLENR : public Register<0x58007028> {
            using DATALENGTH = Field<0, 25>;    // DATALENGTH
        };

        // The SDMMC_DCTRL register control the data path state machine (DPSM).
        struct SDMMC_DCTRL : public Register<0x5800702c> {
            using DTEN = Field<0, 1>;    // DTEN
            using DTDIR = Field<1, 1>;    // DTDIR
            using DTMODE = Field<2, 2>;    // DTMODE
            using DBLOCKSIZE = Field<4, 4>;    // DBLOCKSIZE
            using RWSTART = Field<8, 1>;    // RWSTART
            using RWSTOP = Field<9, 1>;    // RWSTOP
            using RWMOD = Field<10, 1>;    // RWMOD
            using SDIOEN = Field<11, 1>;    // SDIOEN
            using BOOTACKEN = Field<12, 1>;    // BOOTACKEN
            using FIFORST = Field<13, 1>;    // FIFORST
        };

        // The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the Idle state to the Wait_R or Wait_S state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the Idle state and when there has been no error, the data status end flag (DATAEND) is set.
        struct SDMMC_DCNTR : public RegisterReadOnly<0x58007030> {
            using DATACOUNT = Field<0, 25>;    // DATACOUNT
        };

        // The SDMMC_STAR register is a read-only register. It contains two types of flag: Static flags (bits [28, 21, 11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt Clear register (see SDMMC_ICR) Dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO)
        struct SDMMC_STAR : public RegisterReadOnly<0x58007034> {
            using CCRCFAIL = Field<0, 1>;    // CCRCFAIL
            using DCRCFAIL = Field<1, 1>;    // DCRCFAIL
            using CTIMEOUT = Field<2, 1>;    // CTIMEOUT
            using DTIMEOUT = Field<3, 1>;    // DTIMEOUT
            using TXUNDERR = Field<4, 1>;    // TXUNDERR
            using RXOVERR = Field<5, 1>;    // RXOVERR
            using CMDREND = Field<6, 1>;    // CMDREND
            using CMDSENT = Field<7, 1>;    // CMDSENT
            using DATAEND = Field<8, 1>;    // DATAEND
            using DHOLD = Field<9, 1>;    // DHOLD
            using DBCKEND = Field<10, 1>;    // DBCKEND
            using DABORT = Field<11, 1>;    // DABORT
            using DPSMACT = Field<12, 1>;    // DPSMACT
            using CPSMACT = Field<13, 1>;    // CPSMACT
            using TXFIFOHE = Field<14, 1>;    // TXFIFOHE
            using RXFIFOHF = Field<15, 1>;    // RXFIFOHF
            using TXFIFOF = Field<16, 1>;    // TXFIFOF
            using RXFIFOF = Field<17, 1>;    // RXFIFOF
            using TXFIFOE = Field<18, 1>;    // TXFIFOE
            using RXFIFOE = Field<19, 1>;    // RXFIFOE
            using BUSYD0 = Field<20, 1>;    // BUSYD0
            using BUSYD0END = Field<21, 1>;    // BUSYD0END
            using SDIOIT = Field<22, 1>;    // SDIOIT
            using ACKFAIL = Field<23, 1>;    // ACKFAIL
            using ACKTIMEOUT = Field<24, 1>;    // ACKTIMEOUT
            using VSWEND = Field<25, 1>;    // VSWEND
            using CKSTOP = Field<26, 1>;    // CKSTOP
            using IDMATE = Field<27, 1>;    // IDMATE
            using IDMABTC = Field<28, 1>;    // IDMABTC
        };

        // The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register.
        struct SDMMC_ICR : public Register<0x58007038> {
            using CCRCFAILC = Field<0, 1>;    // CCRCFAILC
            using DCRCFAILC = Field<1, 1>;    // DCRCFAILC
            using CTIMEOUTC = Field<2, 1>;    // CTIMEOUTC
            using DTIMEOUTC = Field<3, 1>;    // DTIMEOUTC
            using TXUNDERRC = Field<4, 1>;    // TXUNDERRC
            using RXOVERRC = Field<5, 1>;    // RXOVERRC
            using CMDRENDC = Field<6, 1>;    // CMDRENDC
            using CMDSENTC = Field<7, 1>;    // CMDSENTC
            using DATAENDC = Field<8, 1>;    // DATAENDC
            using DHOLDC = Field<9, 1>;    // DHOLDC
            using DBCKENDC = Field<10, 1>;    // DBCKENDC
            using DABORTC = Field<11, 1>;    // DABORTC
            using BUSYD0ENDC = Field<21, 1>;    // BUSYD0ENDC
            using SDIOITC = Field<22, 1>;    // SDIOITC
            using ACKFAILC = Field<23, 1>;    // ACKFAILC
            using ACKTIMEOUTC = Field<24, 1>;    // ACKTIMEOUTC
            using VSWENDC = Field<25, 1>;    // VSWENDC
            using CKSTOPC = Field<26, 1>;    // CKSTOPC
            using IDMATEC = Field<27, 1>;    // IDMATEC
            using IDMABTCC = Field<28, 1>;    // IDMABTCC
        };

        // The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1.
        struct SDMMC_MASKR : public Register<0x5800703c> {
            using CCRCFAILIE = Field<0, 1>;    // CCRCFAILIE
            using DCRCFAILIE = Field<1, 1>;    // DCRCFAILIE
            using CTIMEOUTIE = Field<2, 1>;    // CTIMEOUTIE
            using DTIMEOUTIE = Field<3, 1>;    // DTIMEOUTIE
            using TXUNDERRIE = Field<4, 1>;    // TXUNDERRIE
            using RXOVERRIE = Field<5, 1>;    // RXOVERRIE
            using CMDRENDIE = Field<6, 1>;    // CMDRENDIE
            using CMDSENTIE = Field<7, 1>;    // CMDSENTIE
            using DATAENDIE = Field<8, 1>;    // DATAENDIE
            using DHOLDIE = Field<9, 1>;    // DHOLDIE
            using DBCKENDIE = Field<10, 1>;    // DBCKENDIE
            using DABORTIE = Field<11, 1>;    // DABORTIE
            using TXFIFOHEIE = Field<14, 1>;    // TXFIFOHEIE
            using RXFIFOHFIE = Field<15, 1>;    // RXFIFOHFIE
            using RXFIFOFIE = Field<17, 1>;    // RXFIFOFIE
            using TXFIFOEIE = Field<18, 1>;    // TXFIFOEIE
            using BUSYD0ENDIE = Field<21, 1>;    // BUSYD0ENDIE
            using SDIOITIE = Field<22, 1>;    // SDIOITIE
            using ACKFAILIE = Field<23, 1>;    // ACKFAILIE
            using ACKTIMEOUTIE = Field<24, 1>;    // ACKTIMEOUTIE
            using VSWENDIE = Field<25, 1>;    // VSWENDIE
            using CKSTOPIE = Field<26, 1>;    // CKSTOPIE
            using IDMABTCIE = Field<28, 1>;    // IDMABTCIE
        };

        // The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_Ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set.
        struct SDMMC_ACKTIMER : public Register<0x58007040> {
            using ACKTIME = Field<0, 25>;    // ACKTIME
        };

        // The receive and transmit FIFOs can be read or written as 32-bit wide registers. The FIFOs contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.
        struct SDMMC_IDMACTRLR : public Register<0x58007050> {
            using IDMAEN = Field<0, 1>;    // IDMAEN
            using IDMABMODE = Field<1, 1>;    // IDMABMODE
        };

        // The SDMMC_IDMABSIZER register contains the buffer size when in linked list configuration.
        struct SDMMC_IDMABSIZER : public Register<0x58007054> {
            using IDMABNDT = Field<5, 12>;    // IDMABNDT
        };

        // The SDMMC_IDMABASER register contains the memory buffer base address in single buffer configuration and linked list configuration.
        struct SDMMC_IDMABASER : public Register<0x58007058> {
            using IDMABASE = Field<0, 32>;    // IDMABASE
        };

        // SDMMC IDMA linked list address register
        struct SDMMC_IDMALAR : public Register<0x58007064> {
            using IDMALA = Field<2, 14>;    // IDMALA
            using ABR = Field<29, 1>;    // ABR
            using ULS = Field<30, 1>;    // ULS
            using ULA = Field<31, 1>;    // ULA
        };

        // SDMMC IDMA linked list memory base register
        struct SDMMC_IDMABAR : public Register<0x58007068> {
            using IDMABA = Field<2, 30>;    // IDMABA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR0 : public Register<0x58007080> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR1 : public Register<0x58007084> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR2 : public Register<0x58007088> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR3 : public Register<0x5800708c> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR4 : public Register<0x58007090> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR5 : public Register<0x58007094> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR6 : public Register<0x58007098> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR7 : public Register<0x5800709c> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR8 : public Register<0x580070a0> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR9 : public Register<0x580070a4> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR10 : public Register<0x580070a8> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR11 : public Register<0x580070ac> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR12 : public Register<0x580070b0> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR13 : public Register<0x580070b4> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR14 : public Register<0x580070b8> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR15 : public Register<0x580070bc> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // SDMMC version register
        struct SDMMC_VERR : public RegisterReadOnly<0x580073f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // SDMMC identification register
        struct SDMMC_IPIDR : public RegisterReadOnly<0x580073f8> {
            using IP_ID = Field<0, 32>;    // IP_ID
        };

        // SDMMC size ID register
        struct SDMMC_SIDR : public RegisterReadOnly<0x580073fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // SDMMC1
    struct SDMMC3 {
        // SDMMC power control register
        struct SDMMC_POWER : public Register<0x48004000> {
            using PWRCTRL = Field<0, 2>;    // PWRCTRL
            using VSWITCH = Field<2, 1>;    // VSWITCH
            using VSWITCHEN = Field<3, 1>;    // VSWITCHEN
            using DIRPOL = Field<4, 1>;    // DIRPOL
        };

        // The SDMMC_CLKCR register controls the SDMMC_CK output clock, the sdmmc_rx_ck receive clock, and the bus width.
        struct SDMMC_CLKCR : public Register<0x48004004> {
            using CLKDIV = Field<0, 10>;    // CLKDIV
            using PWRSAV = Field<12, 1>;    // PWRSAV
            using WIDBUS = Field<14, 2>;    // WIDBUS
            using NEGEDGE = Field<16, 1>;    // NEGEDGE
            using HWFC_EN = Field<17, 1>;    // HWFC_EN
            using DDR = Field<18, 1>;    // DDR
            using BUSSPEED = Field<19, 1>;    // BUSSPEED
            using SELCLKRX = Field<20, 2>;    // SELCLKRX
        };

        // The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message.
        struct SDMMC_ARGR : public Register<0x48004008> {
            using CMDARG = Field<0, 32>;    // CMDARG
        };

        // The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM).
        struct SDMMC_CMDR : public Register<0x4800400c> {
            using CMDINDEX = Field<0, 6>;    // CMDINDEX
            using CMDTRANS = Field<6, 1>;    // CMDTRANS
            using CMDSTOP = Field<7, 1>;    // CMDSTOP
            using WAITRESP = Field<8, 2>;    // WAITRESP
            using WAITINT = Field<10, 1>;    // WAITINT
            using WAITPEND = Field<11, 1>;    // WAITPEND
            using CPSMEN = Field<12, 1>;    // CPSMEN
            using DTHOLD = Field<13, 1>;    // DTHOLD
            using BOOTMODE = Field<14, 1>;    // BOOTMODE
            using BOOTEN = Field<15, 1>;    // BOOTEN
            using CMDSUSPEND = Field<16, 1>;    // CMDSUSPEND
        };

        // The SDMMC_RESPCMDR register contains the command index field of the last command response received. If the command response transmission does not contain the command index field (long or OCR response), the RESPCMD field is unknown, although it must contain 111111b (the value of the reserved field from the response).
        struct SDMMC_RESPCMDR : public RegisterReadOnly<0x48004010> {
            using RESPCMD = Field<0, 6>;    // RESPCMD
        };

        // The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
        struct SDMMC_RESP1R : public RegisterReadOnly<0x48004014> {
            using CARDSTATUS1 = Field<0, 32>;    // CARDSTATUS1
        };

        // The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
        struct SDMMC_RESP2R : public RegisterReadOnly<0x48004018> {
            using CARDSTATUS2 = Field<0, 32>;    // CARDSTATUS2
        };

        // The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
        struct SDMMC_RESP3R : public RegisterReadOnly<0x4800401c> {
            using CARDSTATUS3 = Field<0, 32>;    // CARDSTATUS3
        };

        // The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
        struct SDMMC_RESP4R : public RegisterReadOnly<0x48004020> {
            using CARDSTATUS4 = Field<0, 32>;    // CARDSTATUS4
        };

        // The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_R or Busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set.
        struct SDMMC_DTIMER : public Register<0x48004024> {
            using DATATIME = Field<0, 32>;    // DATATIME
        };

        // The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts.
        struct SDMMC_DLENR : public Register<0x48004028> {
            using DATALENGTH = Field<0, 25>;    // DATALENGTH
        };

        // The SDMMC_DCTRL register control the data path state machine (DPSM).
        struct SDMMC_DCTRL : public Register<0x4800402c> {
            using DTEN = Field<0, 1>;    // DTEN
            using DTDIR = Field<1, 1>;    // DTDIR
            using DTMODE = Field<2, 2>;    // DTMODE
            using DBLOCKSIZE = Field<4, 4>;    // DBLOCKSIZE
            using RWSTART = Field<8, 1>;    // RWSTART
            using RWSTOP = Field<9, 1>;    // RWSTOP
            using RWMOD = Field<10, 1>;    // RWMOD
            using SDIOEN = Field<11, 1>;    // SDIOEN
            using BOOTACKEN = Field<12, 1>;    // BOOTACKEN
            using FIFORST = Field<13, 1>;    // FIFORST
        };

        // The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the Idle state to the Wait_R or Wait_S state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the Idle state and when there has been no error, the data status end flag (DATAEND) is set.
        struct SDMMC_DCNTR : public RegisterReadOnly<0x48004030> {
            using DATACOUNT = Field<0, 25>;    // DATACOUNT
        };

        // The SDMMC_STAR register is a read-only register. It contains two types of flag: Static flags (bits [28, 21, 11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt Clear register (see SDMMC_ICR) Dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO)
        struct SDMMC_STAR : public RegisterReadOnly<0x48004034> {
            using CCRCFAIL = Field<0, 1>;    // CCRCFAIL
            using DCRCFAIL = Field<1, 1>;    // DCRCFAIL
            using CTIMEOUT = Field<2, 1>;    // CTIMEOUT
            using DTIMEOUT = Field<3, 1>;    // DTIMEOUT
            using TXUNDERR = Field<4, 1>;    // TXUNDERR
            using RXOVERR = Field<5, 1>;    // RXOVERR
            using CMDREND = Field<6, 1>;    // CMDREND
            using CMDSENT = Field<7, 1>;    // CMDSENT
            using DATAEND = Field<8, 1>;    // DATAEND
            using DHOLD = Field<9, 1>;    // DHOLD
            using DBCKEND = Field<10, 1>;    // DBCKEND
            using DABORT = Field<11, 1>;    // DABORT
            using DPSMACT = Field<12, 1>;    // DPSMACT
            using CPSMACT = Field<13, 1>;    // CPSMACT
            using TXFIFOHE = Field<14, 1>;    // TXFIFOHE
            using RXFIFOHF = Field<15, 1>;    // RXFIFOHF
            using TXFIFOF = Field<16, 1>;    // TXFIFOF
            using RXFIFOF = Field<17, 1>;    // RXFIFOF
            using TXFIFOE = Field<18, 1>;    // TXFIFOE
            using RXFIFOE = Field<19, 1>;    // RXFIFOE
            using BUSYD0 = Field<20, 1>;    // BUSYD0
            using BUSYD0END = Field<21, 1>;    // BUSYD0END
            using SDIOIT = Field<22, 1>;    // SDIOIT
            using ACKFAIL = Field<23, 1>;    // ACKFAIL
            using ACKTIMEOUT = Field<24, 1>;    // ACKTIMEOUT
            using VSWEND = Field<25, 1>;    // VSWEND
            using CKSTOP = Field<26, 1>;    // CKSTOP
            using IDMATE = Field<27, 1>;    // IDMATE
            using IDMABTC = Field<28, 1>;    // IDMABTC
        };

        // The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register.
        struct SDMMC_ICR : public Register<0x48004038> {
            using CCRCFAILC = Field<0, 1>;    // CCRCFAILC
            using DCRCFAILC = Field<1, 1>;    // DCRCFAILC
            using CTIMEOUTC = Field<2, 1>;    // CTIMEOUTC
            using DTIMEOUTC = Field<3, 1>;    // DTIMEOUTC
            using TXUNDERRC = Field<4, 1>;    // TXUNDERRC
            using RXOVERRC = Field<5, 1>;    // RXOVERRC
            using CMDRENDC = Field<6, 1>;    // CMDRENDC
            using CMDSENTC = Field<7, 1>;    // CMDSENTC
            using DATAENDC = Field<8, 1>;    // DATAENDC
            using DHOLDC = Field<9, 1>;    // DHOLDC
            using DBCKENDC = Field<10, 1>;    // DBCKENDC
            using DABORTC = Field<11, 1>;    // DABORTC
            using BUSYD0ENDC = Field<21, 1>;    // BUSYD0ENDC
            using SDIOITC = Field<22, 1>;    // SDIOITC
            using ACKFAILC = Field<23, 1>;    // ACKFAILC
            using ACKTIMEOUTC = Field<24, 1>;    // ACKTIMEOUTC
            using VSWENDC = Field<25, 1>;    // VSWENDC
            using CKSTOPC = Field<26, 1>;    // CKSTOPC
            using IDMATEC = Field<27, 1>;    // IDMATEC
            using IDMABTCC = Field<28, 1>;    // IDMABTCC
        };

        // The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1.
        struct SDMMC_MASKR : public Register<0x4800403c> {
            using CCRCFAILIE = Field<0, 1>;    // CCRCFAILIE
            using DCRCFAILIE = Field<1, 1>;    // DCRCFAILIE
            using CTIMEOUTIE = Field<2, 1>;    // CTIMEOUTIE
            using DTIMEOUTIE = Field<3, 1>;    // DTIMEOUTIE
            using TXUNDERRIE = Field<4, 1>;    // TXUNDERRIE
            using RXOVERRIE = Field<5, 1>;    // RXOVERRIE
            using CMDRENDIE = Field<6, 1>;    // CMDRENDIE
            using CMDSENTIE = Field<7, 1>;    // CMDSENTIE
            using DATAENDIE = Field<8, 1>;    // DATAENDIE
            using DHOLDIE = Field<9, 1>;    // DHOLDIE
            using DBCKENDIE = Field<10, 1>;    // DBCKENDIE
            using DABORTIE = Field<11, 1>;    // DABORTIE
            using TXFIFOHEIE = Field<14, 1>;    // TXFIFOHEIE
            using RXFIFOHFIE = Field<15, 1>;    // RXFIFOHFIE
            using RXFIFOFIE = Field<17, 1>;    // RXFIFOFIE
            using TXFIFOEIE = Field<18, 1>;    // TXFIFOEIE
            using BUSYD0ENDIE = Field<21, 1>;    // BUSYD0ENDIE
            using SDIOITIE = Field<22, 1>;    // SDIOITIE
            using ACKFAILIE = Field<23, 1>;    // ACKFAILIE
            using ACKTIMEOUTIE = Field<24, 1>;    // ACKTIMEOUTIE
            using VSWENDIE = Field<25, 1>;    // VSWENDIE
            using CKSTOPIE = Field<26, 1>;    // CKSTOPIE
            using IDMABTCIE = Field<28, 1>;    // IDMABTCIE
        };

        // The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_Ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set.
        struct SDMMC_ACKTIMER : public Register<0x48004040> {
            using ACKTIME = Field<0, 25>;    // ACKTIME
        };

        // The receive and transmit FIFOs can be read or written as 32-bit wide registers. The FIFOs contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.
        struct SDMMC_IDMACTRLR : public Register<0x48004050> {
            using IDMAEN = Field<0, 1>;    // IDMAEN
            using IDMABMODE = Field<1, 1>;    // IDMABMODE
        };

        // The SDMMC_IDMABSIZER register contains the buffer size when in linked list configuration.
        struct SDMMC_IDMABSIZER : public Register<0x48004054> {
            using IDMABNDT = Field<5, 12>;    // IDMABNDT
        };

        // The SDMMC_IDMABASER register contains the memory buffer base address in single buffer configuration and linked list configuration.
        struct SDMMC_IDMABASER : public Register<0x48004058> {
            using IDMABASE = Field<0, 32>;    // IDMABASE
        };

        // SDMMC IDMA linked list address register
        struct SDMMC_IDMALAR : public Register<0x48004064> {
            using IDMALA = Field<2, 14>;    // IDMALA
            using ABR = Field<29, 1>;    // ABR
            using ULS = Field<30, 1>;    // ULS
            using ULA = Field<31, 1>;    // ULA
        };

        // SDMMC IDMA linked list memory base register
        struct SDMMC_IDMABAR : public Register<0x48004068> {
            using IDMABA = Field<2, 30>;    // IDMABA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR0 : public Register<0x48004080> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR1 : public Register<0x48004084> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR2 : public Register<0x48004088> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR3 : public Register<0x4800408c> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR4 : public Register<0x48004090> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR5 : public Register<0x48004094> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR6 : public Register<0x48004098> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR7 : public Register<0x4800409c> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR8 : public Register<0x480040a0> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR9 : public Register<0x480040a4> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR10 : public Register<0x480040a8> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR11 : public Register<0x480040ac> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR12 : public Register<0x480040b0> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR13 : public Register<0x480040b4> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR14 : public Register<0x480040b8> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct SDMMC_FIFOR15 : public Register<0x480040bc> {
            using FIFODATA = Field<0, 32>;    // FIFODATA
        };

        // SDMMC version register
        struct SDMMC_VERR : public RegisterReadOnly<0x480043f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // SDMMC identification register
        struct SDMMC_IPIDR : public RegisterReadOnly<0x480043f8> {
            using IP_ID = Field<0, 32>;    // IP_ID
        };

        // SDMMC size ID register
        struct SDMMC_SIDR : public RegisterReadOnly<0x480043fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // QUADSPI1
    struct QUADSPI {
        // QUADSPI control register
        struct QUADSPI_CR : public Register<0x58003000> {
            using EN = Field<0, 1>;    // EN
            using ABORT = Field<1, 1>;    // ABORT
            using DMAEN = Field<2, 1>;    // DMAEN
            using TCEN = Field<3, 1>;    // TCEN
            using SSHIFT = Field<4, 1>;    // SSHIFT
            using DFM = Field<6, 1>;    // DFM
            using FSEL = Field<7, 1>;    // FSEL
            using FTHRES = Field<8, 4>;    // FTHRES
            using TEIE = Field<16, 1>;    // TEIE
            using TCIE = Field<17, 1>;    // TCIE
            using FTIE = Field<18, 1>;    // FTIE
            using SMIE = Field<19, 1>;    // SMIE
            using TOIE = Field<20, 1>;    // TOIE
            using APMS = Field<22, 1>;    // APMS
            using PMM = Field<23, 1>;    // PMM
            using PRESCALER = Field<24, 8>;    // PRESCALER
        };

        // QUADSPI device configuration register
        struct QUADSPI_DCR : public Register<0x58003004> {
            using CKMODE = Field<0, 1>;    // CKMODE
            using CSHT = Field<8, 3>;    // CSHT
            using FSIZE = Field<16, 5>;    // FSIZE
        };

        // QUADSPI status register
        struct QUADSPI_SR : public RegisterReadOnly<0x58003008> {
            using TEF = Field<0, 1>;    // TEF
            using TCF = Field<1, 1>;    // TCF
            using FTF = Field<2, 1>;    // FTF
            using SMF = Field<3, 1>;    // SMF
            using TOF = Field<4, 1>;    // TOF
            using BUSY = Field<5, 1>;    // BUSY
            using FLEVEL = Field<8, 5>;    // FLEVEL
        };

        // QUADSPI flag clear register
        struct QUADSPI_FCR : public RegisterWriteOnly<0x5800300c> {
            using CTEF = Field<0, 1>;    // CTEF
            using CTCF = Field<1, 1>;    // CTCF
            using CSMF = Field<3, 1>;    // CSMF
            using CTOF = Field<4, 1>;    // CTOF
        };

        // QUADSPI data length register
        struct QUADSPI_DLR : public Register<0x58003010> {
            using DL = Field<0, 32>;    // DL
        };

        // QUADSPI communication configuration register
        struct QUADSPI_CCR : public Register<0x58003014> {
            using INSTRUCTION = Field<0, 8>;    // INSTRUCTION
            using IMODE = Field<8, 2>;    // IMODE
            using ADMODE = Field<10, 2>;    // ADMODE
            using ADSIZE = Field<12, 2>;    // ADSIZE
            using ABMODE = Field<14, 2>;    // ABMODE
            using ABSIZE = Field<16, 2>;    // ABSIZE
            using DCYC = Field<18, 5>;    // DCYC
            using DMODE = Field<24, 2>;    // DMODE
            using FMODE = Field<26, 2>;    // FMODE
            using SIOO = Field<28, 1>;    // SIOO
            using FRCM = Field<29, 1>;    // FRCM
            using DHHC = Field<30, 1>;    // DHHC
            using DDRM = Field<31, 1>;    // DDRM
        };

        // QUADSPI address register
        struct QUADSPI_AR : public Register<0x58003018> {
            using ADDRESS = Field<0, 32>;    // ADDRESS
        };

        // QUADSPI alternate bytes registers
        struct QUADSPI_ABR : public Register<0x5800301c> {
            using ALTERNATE = Field<0, 32>;    // ALTERNATE
        };

        // QUADSPI data register
        struct QUADSPI_DR : public Register<0x58003020> {
            using DATA = Field<0, 32>;    // DATA
        };

        // QUADSPI polling status mask register
        struct QUADSPI_PSMKR : public Register<0x58003024> {
            using MASK = Field<0, 32>;    // MASK
        };

        // QUADSPI polling status match register
        struct QUADSPI_PSMAR : public Register<0x58003028> {
            using MATCH = Field<0, 32>;    // MATCH
        };

        // QUADSPI polling interval register
        struct QUADSPI_PIR : public Register<0x5800302c> {
            using INTERVAL = Field<0, 16>;    // INTERVAL
        };

        // QUADSPI low-power timeout register
        struct QUADSPI_LPTR : public Register<0x58003030> {
            using TIMEOUT = Field<0, 16>;    // TIMEOUT
        };

        // QUADSPI HW configuration register
        struct QUADSPI_HWCFGR : public RegisterReadOnly<0x580033f0> {
            using FIFOSIZE = Field<0, 4>;    // FIFOSIZE
            using FIFOPTR = Field<4, 4>;    // FIFOPTR
            using PRESCVAL = Field<8, 4>;    // PRESCVAL
            using IDLENGTH = Field<12, 4>;    // IDLENGTH
        };

        // QUADSPI version register
        struct QUADSPI_VERR : public RegisterReadOnly<0x580033f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // QUADSPI identification register
        struct QUADSPI_IPIDR : public RegisterReadOnly<0x580033f8> {
            using ID = Field<0, 32>;    // ID
        };

        // QUADSPI size identification register
        struct QUADSPI_SIDR : public RegisterReadOnly<0x580033fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // MDMA1
    struct MDMA {
        // MDMA global interrupt/status register
        struct MDMA_GISR0 : public RegisterReadOnly<0x58000000> {
            using GIF0 = Field<0, 1>;    // GIF0
            using GIF1 = Field<1, 1>;    // GIF1
            using GIF2 = Field<2, 1>;    // GIF2
            using GIF3 = Field<3, 1>;    // GIF3
            using GIF4 = Field<4, 1>;    // GIF4
            using GIF5 = Field<5, 1>;    // GIF5
            using GIF6 = Field<6, 1>;    // GIF6
            using GIF7 = Field<7, 1>;    // GIF7
            using GIF8 = Field<8, 1>;    // GIF8
            using GIF9 = Field<9, 1>;    // GIF9
            using GIF10 = Field<10, 1>;    // GIF10
            using GIF11 = Field<11, 1>;    // GIF11
            using GIF12 = Field<12, 1>;    // GIF12
            using GIF13 = Field<13, 1>;    // GIF13
            using GIF14 = Field<14, 1>;    // GIF14
            using GIF15 = Field<15, 1>;    // GIF15
            using GIF16 = Field<16, 1>;    // GIF16
            using GIF17 = Field<17, 1>;    // GIF17
            using GIF18 = Field<18, 1>;    // GIF18
            using GIF19 = Field<19, 1>;    // GIF19
            using GIF20 = Field<20, 1>;    // GIF20
            using GIF21 = Field<21, 1>;    // GIF21
            using GIF22 = Field<22, 1>;    // GIF22
            using GIF23 = Field<23, 1>;    // GIF23
            using GIF24 = Field<24, 1>;    // GIF24
            using GIF25 = Field<25, 1>;    // GIF25
            using GIF26 = Field<26, 1>;    // GIF26
            using GIF27 = Field<27, 1>;    // GIF27
            using GIF28 = Field<28, 1>;    // GIF28
            using GIF29 = Field<29, 1>;    // GIF29
            using GIF30 = Field<30, 1>;    // GIF30
            using GIF31 = Field<31, 1>;    // GIF31
        };

        // MDMA secure global interrupt/status register
        struct MDMA_SGISR0 : public RegisterReadOnly<0x58000008> {
            using GIF0 = Field<0, 1>;    // GIF0
            using GIF1 = Field<1, 1>;    // GIF1
            using GIF2 = Field<2, 1>;    // GIF2
            using GIF3 = Field<3, 1>;    // GIF3
            using GIF4 = Field<4, 1>;    // GIF4
            using GIF5 = Field<5, 1>;    // GIF5
            using GIF6 = Field<6, 1>;    // GIF6
            using GIF7 = Field<7, 1>;    // GIF7
            using GIF8 = Field<8, 1>;    // GIF8
            using GIF9 = Field<9, 1>;    // GIF9
            using GIF10 = Field<10, 1>;    // GIF10
            using GIF11 = Field<11, 1>;    // GIF11
            using GIF12 = Field<12, 1>;    // GIF12
            using GIF13 = Field<13, 1>;    // GIF13
            using GIF14 = Field<14, 1>;    // GIF14
            using GIF15 = Field<15, 1>;    // GIF15
            using GIF16 = Field<16, 1>;    // GIF16
            using GIF17 = Field<17, 1>;    // GIF17
            using GIF18 = Field<18, 1>;    // GIF18
            using GIF19 = Field<19, 1>;    // GIF19
            using GIF20 = Field<20, 1>;    // GIF20
            using GIF21 = Field<21, 1>;    // GIF21
            using GIF22 = Field<22, 1>;    // GIF22
            using GIF23 = Field<23, 1>;    // GIF23
            using GIF24 = Field<24, 1>;    // GIF24
            using GIF25 = Field<25, 1>;    // GIF25
            using GIF26 = Field<26, 1>;    // GIF26
            using GIF27 = Field<27, 1>;    // GIF27
            using GIF28 = Field<28, 1>;    // GIF28
            using GIF29 = Field<29, 1>;    // GIF29
            using GIF30 = Field<30, 1>;    // GIF30
            using GIF31 = Field<31, 1>;    // GIF31
        };

        // MDMA channel 0 interrupt/status register
        struct MDMA_C0ISR : public RegisterReadOnly<0x58000040> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 0 interrupt flag clear register
        struct MDMA_C0IFCR : public RegisterWriteOnly<0x58000044> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 0 error status register
        struct MDMA_C0ESR : public RegisterReadOnly<0x58000048> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C0CR : public Register<0x5800004c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C0TCR : public Register<0x58000050> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C0BNDTR : public Register<0x58000054> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C0SAR : public Register<0x58000058> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C0DAR : public Register<0x5800005c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C0BRUR : public Register<0x58000060> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C0LAR : public Register<0x58000064> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C0TBR : public Register<0x58000068> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C0MAR : public Register<0x58000070> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C0MDR : public Register<0x58000074> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 1 interrupt/status register
        struct MDMA_C1ISR : public RegisterReadOnly<0x58000080> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 1 interrupt flag clear register
        struct MDMA_C1IFCR : public RegisterWriteOnly<0x58000084> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 1 error status register
        struct MDMA_C1ESR : public RegisterReadOnly<0x58000088> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C1CR : public Register<0x5800008c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C1TCR : public Register<0x58000090> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C1BNDTR : public Register<0x58000094> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C1SAR : public Register<0x58000098> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C1DAR : public Register<0x5800009c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C1BRUR : public Register<0x580000a0> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C1LAR : public Register<0x580000a4> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C1TBR : public Register<0x580000a8> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C1MAR : public Register<0x580000b0> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C1MDR : public Register<0x580000b4> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 2 interrupt/status register
        struct MDMA_C2ISR : public RegisterReadOnly<0x580000c0> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 2 interrupt flag clear register
        struct MDMA_C2IFCR : public RegisterWriteOnly<0x580000c4> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 2 error status register
        struct MDMA_C2ESR : public RegisterReadOnly<0x580000c8> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C2CR : public Register<0x580000cc> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C2TCR : public Register<0x580000d0> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C2BNDTR : public Register<0x580000d4> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C2SAR : public Register<0x580000d8> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C2DAR : public Register<0x580000dc> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C2BRUR : public Register<0x580000e0> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C2LAR : public Register<0x580000e4> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C2TBR : public Register<0x580000e8> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C2MAR : public Register<0x580000f0> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C2MDR : public Register<0x580000f4> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 3 interrupt/status register
        struct MDMA_C3ISR : public RegisterReadOnly<0x58000100> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 3 interrupt flag clear register
        struct MDMA_C3IFCR : public RegisterWriteOnly<0x58000104> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 3 error status register
        struct MDMA_C3ESR : public RegisterReadOnly<0x58000108> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C3CR : public Register<0x5800010c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C3TCR : public Register<0x58000110> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C3BNDTR : public Register<0x58000114> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C3SAR : public Register<0x58000118> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C3DAR : public Register<0x5800011c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C3BRUR : public Register<0x58000120> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C3LAR : public Register<0x58000124> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C3TBR : public Register<0x58000128> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C3MAR : public Register<0x58000130> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C3MDR : public Register<0x58000134> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 4 interrupt/status register
        struct MDMA_C4ISR : public RegisterReadOnly<0x58000140> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 4 interrupt flag clear register
        struct MDMA_C4IFCR : public RegisterWriteOnly<0x58000144> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 4 error status register
        struct MDMA_C4ESR : public RegisterReadOnly<0x58000148> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C4CR : public Register<0x5800014c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C4TCR : public Register<0x58000150> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C4BNDTR : public Register<0x58000154> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C4SAR : public Register<0x58000158> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C4DAR : public Register<0x5800015c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C4BRUR : public Register<0x58000160> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C4LAR : public Register<0x58000164> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C4TBR : public Register<0x58000168> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C4MAR : public Register<0x58000170> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C4MDR : public Register<0x58000174> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 5 interrupt/status register
        struct MDMA_C5ISR : public RegisterReadOnly<0x58000180> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 5 interrupt flag clear register
        struct MDMA_C5IFCR : public RegisterWriteOnly<0x58000184> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 5 error status register
        struct MDMA_C5ESR : public RegisterReadOnly<0x58000188> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C5CR : public Register<0x5800018c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C5TCR : public Register<0x58000190> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C5BNDTR : public Register<0x58000194> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C5SAR : public Register<0x58000198> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C5DAR : public Register<0x5800019c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C5BRUR : public Register<0x580001a0> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C5LAR : public Register<0x580001a4> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C5TBR : public Register<0x580001a8> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C5MAR : public Register<0x580001b0> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C5MDR : public Register<0x580001b4> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 6 interrupt/status register
        struct MDMA_C6ISR : public RegisterReadOnly<0x580001c0> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 6 interrupt flag clear register
        struct MDMA_C6IFCR : public RegisterWriteOnly<0x580001c4> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 6 error status register
        struct MDMA_C6ESR : public RegisterReadOnly<0x580001c8> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C6CR : public Register<0x580001cc> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C6TCR : public Register<0x580001d0> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C6BNDTR : public Register<0x580001d4> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C6SAR : public Register<0x580001d8> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C6DAR : public Register<0x580001dc> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C6BRUR : public Register<0x580001e0> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C6LAR : public Register<0x580001e4> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C6TBR : public Register<0x580001e8> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C6MAR : public Register<0x580001f0> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C6MDR : public Register<0x580001f4> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 7 interrupt/status register
        struct MDMA_C7ISR : public RegisterReadOnly<0x58000200> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 7 interrupt flag clear register
        struct MDMA_C7IFCR : public RegisterWriteOnly<0x58000204> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 7 error status register
        struct MDMA_C7ESR : public RegisterReadOnly<0x58000208> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C7CR : public Register<0x5800020c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C7TCR : public Register<0x58000210> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C7BNDTR : public Register<0x58000214> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C7SAR : public Register<0x58000218> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C7DAR : public Register<0x5800021c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C7BRUR : public Register<0x58000220> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C7LAR : public Register<0x58000224> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C7TBR : public Register<0x58000228> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C7MAR : public Register<0x58000230> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C7MDR : public Register<0x58000234> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 8 interrupt/status register
        struct MDMA_C8ISR : public RegisterReadOnly<0x58000240> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 8 interrupt flag clear register
        struct MDMA_C8IFCR : public RegisterWriteOnly<0x58000244> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 8 error status register
        struct MDMA_C8ESR : public RegisterReadOnly<0x58000248> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C8CR : public Register<0x5800024c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C8TCR : public Register<0x58000250> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C8BNDTR : public Register<0x58000254> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C8SAR : public Register<0x58000258> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C8DAR : public Register<0x5800025c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C8BRUR : public Register<0x58000260> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C8LAR : public Register<0x58000264> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C8TBR : public Register<0x58000268> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C8MAR : public Register<0x58000270> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C8MDR : public Register<0x58000274> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 9 interrupt/status register
        struct MDMA_C9ISR : public RegisterReadOnly<0x58000280> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 9 interrupt flag clear register
        struct MDMA_C9IFCR : public RegisterWriteOnly<0x58000284> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 9 error status register
        struct MDMA_C9ESR : public RegisterReadOnly<0x58000288> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C9CR : public Register<0x5800028c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C9TCR : public Register<0x58000290> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C9BNDTR : public Register<0x58000294> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C9SAR : public Register<0x58000298> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C9DAR : public Register<0x5800029c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C9BRUR : public Register<0x580002a0> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C9LAR : public Register<0x580002a4> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C9TBR : public Register<0x580002a8> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C9MAR : public Register<0x580002b0> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C9MDR : public Register<0x580002b4> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 10 interrupt/status register
        struct MDMA_C10ISR : public RegisterReadOnly<0x580002c0> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 10 interrupt flag clear register
        struct MDMA_C10IFCR : public RegisterWriteOnly<0x580002c4> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 10 error status register
        struct MDMA_C10ESR : public RegisterReadOnly<0x580002c8> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C10CR : public Register<0x580002cc> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C10TCR : public Register<0x580002d0> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C10BNDTR : public Register<0x580002d4> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C10SAR : public Register<0x580002d8> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C10DAR : public Register<0x580002dc> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C10BRUR : public Register<0x580002e0> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C10LAR : public Register<0x580002e4> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C10TBR : public Register<0x580002e8> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C10MAR : public Register<0x580002f0> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C10MDR : public Register<0x580002f4> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 11 interrupt/status register
        struct MDMA_C11ISR : public RegisterReadOnly<0x58000300> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 11 interrupt flag clear register
        struct MDMA_C11IFCR : public RegisterWriteOnly<0x58000304> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 11 error status register
        struct MDMA_C11ESR : public RegisterReadOnly<0x58000308> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C11CR : public Register<0x5800030c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C11TCR : public Register<0x58000310> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C11BNDTR : public Register<0x58000314> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C11SAR : public Register<0x58000318> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C11DAR : public Register<0x5800031c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C11BRUR : public Register<0x58000320> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C11LAR : public Register<0x58000324> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C11TBR : public Register<0x58000328> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C11MAR : public Register<0x58000330> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C11MDR : public Register<0x58000334> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 12 interrupt/status register
        struct MDMA_C12ISR : public RegisterReadOnly<0x58000340> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 12 interrupt flag clear register
        struct MDMA_C12IFCR : public RegisterWriteOnly<0x58000344> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 12 error status register
        struct MDMA_C12ESR : public RegisterReadOnly<0x58000348> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C12CR : public Register<0x5800034c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C12TCR : public Register<0x58000350> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C12BNDTR : public Register<0x58000354> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C12SAR : public Register<0x58000358> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C12DAR : public Register<0x5800035c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C12BRUR : public Register<0x58000360> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C12LAR : public Register<0x58000364> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C12TBR : public Register<0x58000368> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C12MAR : public Register<0x58000370> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C12MDR : public Register<0x58000374> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 13 interrupt/status register
        struct MDMA_C13ISR : public RegisterReadOnly<0x58000380> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 13 interrupt flag clear register
        struct MDMA_C13IFCR : public RegisterWriteOnly<0x58000384> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 13 error status register
        struct MDMA_C13ESR : public RegisterReadOnly<0x58000388> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C13CR : public Register<0x5800038c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C13TCR : public Register<0x58000390> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C13BNDTR : public Register<0x58000394> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C13SAR : public Register<0x58000398> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C13DAR : public Register<0x5800039c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C13BRUR : public Register<0x580003a0> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C13LAR : public Register<0x580003a4> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C13TBR : public Register<0x580003a8> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C13MAR : public Register<0x580003b0> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C13MDR : public Register<0x580003b4> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 14 interrupt/status register
        struct MDMA_C14ISR : public RegisterReadOnly<0x580003c0> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 14 interrupt flag clear register
        struct MDMA_C14IFCR : public RegisterWriteOnly<0x580003c4> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 14 error status register
        struct MDMA_C14ESR : public RegisterReadOnly<0x580003c8> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C14CR : public Register<0x580003cc> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C14TCR : public Register<0x580003d0> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C14BNDTR : public Register<0x580003d4> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C14SAR : public Register<0x580003d8> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C14DAR : public Register<0x580003dc> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C14BRUR : public Register<0x580003e0> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C14LAR : public Register<0x580003e4> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C14TBR : public Register<0x580003e8> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C14MAR : public Register<0x580003f0> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C14MDR : public Register<0x580003f4> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 15 interrupt/status register
        struct MDMA_C15ISR : public RegisterReadOnly<0x58000400> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 15 interrupt flag clear register
        struct MDMA_C15IFCR : public RegisterWriteOnly<0x58000404> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 15 error status register
        struct MDMA_C15ESR : public RegisterReadOnly<0x58000408> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C15CR : public Register<0x5800040c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C15TCR : public Register<0x58000410> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C15BNDTR : public Register<0x58000414> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C15SAR : public Register<0x58000418> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C15DAR : public Register<0x5800041c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C15BRUR : public Register<0x58000420> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C15LAR : public Register<0x58000424> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C15TBR : public Register<0x58000428> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C15MAR : public Register<0x58000430> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C15MDR : public Register<0x58000434> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 16 interrupt/status register
        struct MDMA_C16ISR : public RegisterReadOnly<0x58000440> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 16 interrupt flag clear register
        struct MDMA_C16IFCR : public RegisterWriteOnly<0x58000444> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 16 error status register
        struct MDMA_C16ESR : public RegisterReadOnly<0x58000448> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C16CR : public Register<0x5800044c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C16TCR : public Register<0x58000450> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C16BNDTR : public Register<0x58000454> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C16SAR : public Register<0x58000458> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C16DAR : public Register<0x5800045c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C16BRUR : public Register<0x58000460> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C16LAR : public Register<0x58000464> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C16TBR : public Register<0x58000468> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C16MAR : public Register<0x58000470> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C16MDR : public Register<0x58000474> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 17 interrupt/status register
        struct MDMA_C17ISR : public RegisterReadOnly<0x58000480> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 17 interrupt flag clear register
        struct MDMA_C17IFCR : public RegisterWriteOnly<0x58000484> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 17 error status register
        struct MDMA_C17ESR : public RegisterReadOnly<0x58000488> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C17CR : public Register<0x5800048c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C17TCR : public Register<0x58000490> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C17BNDTR : public Register<0x58000494> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C17SAR : public Register<0x58000498> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C17DAR : public Register<0x5800049c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C17BRUR : public Register<0x580004a0> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C17LAR : public Register<0x580004a4> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C17TBR : public Register<0x580004a8> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C17MAR : public Register<0x580004b0> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C17MDR : public Register<0x580004b4> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 18 interrupt/status register
        struct MDMA_C18ISR : public RegisterReadOnly<0x580004c0> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 18 interrupt flag clear register
        struct MDMA_C18IFCR : public RegisterWriteOnly<0x580004c4> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 18 error status register
        struct MDMA_C18ESR : public RegisterReadOnly<0x580004c8> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C18CR : public Register<0x580004cc> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C18TCR : public Register<0x580004d0> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C18BNDTR : public Register<0x580004d4> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C18SAR : public Register<0x580004d8> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C18DAR : public Register<0x580004dc> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C18BRUR : public Register<0x580004e0> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C18LAR : public Register<0x580004e4> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C18TBR : public Register<0x580004e8> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C18MAR : public Register<0x580004f0> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C18MDR : public Register<0x580004f4> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 19 interrupt/status register
        struct MDMA_C19ISR : public RegisterReadOnly<0x58000500> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 19 interrupt flag clear register
        struct MDMA_C19IFCR : public RegisterWriteOnly<0x58000504> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 19 error status register
        struct MDMA_C19ESR : public RegisterReadOnly<0x58000508> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C19CR : public Register<0x5800050c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C19TCR : public Register<0x58000510> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C19BNDTR : public Register<0x58000514> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C19SAR : public Register<0x58000518> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C19DAR : public Register<0x5800051c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C19BRUR : public Register<0x58000520> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C19LAR : public Register<0x58000524> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C19TBR : public Register<0x58000528> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C19MAR : public Register<0x58000530> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C19MDR : public Register<0x58000534> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 20 interrupt/status register
        struct MDMA_C20ISR : public RegisterReadOnly<0x58000540> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 20 interrupt flag clear register
        struct MDMA_C20IFCR : public RegisterWriteOnly<0x58000544> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 20 error status register
        struct MDMA_C20ESR : public RegisterReadOnly<0x58000548> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C20CR : public Register<0x5800054c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C20TCR : public Register<0x58000550> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C20BNDTR : public Register<0x58000554> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C20SAR : public Register<0x58000558> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C20DAR : public Register<0x5800055c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C20BRUR : public Register<0x58000560> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C20LAR : public Register<0x58000564> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C20TBR : public Register<0x58000568> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C20MAR : public Register<0x58000570> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C20MDR : public Register<0x58000574> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 21 interrupt/status register
        struct MDMA_C21ISR : public RegisterReadOnly<0x58000580> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 21 interrupt flag clear register
        struct MDMA_C21IFCR : public RegisterWriteOnly<0x58000584> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 21 error status register
        struct MDMA_C21ESR : public RegisterReadOnly<0x58000588> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C21CR : public Register<0x5800058c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C21TCR : public Register<0x58000590> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C21BNDTR : public Register<0x58000594> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C21SAR : public Register<0x58000598> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C21DAR : public Register<0x5800059c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C21BRUR : public Register<0x580005a0> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C21LAR : public Register<0x580005a4> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C21TBR : public Register<0x580005a8> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C21MAR : public Register<0x580005b0> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C21MDR : public Register<0x580005b4> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 22 interrupt/status register
        struct MDMA_C22ISR : public RegisterReadOnly<0x580005c0> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 22 interrupt flag clear register
        struct MDMA_C22IFCR : public RegisterWriteOnly<0x580005c4> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 22 error status register
        struct MDMA_C22ESR : public RegisterReadOnly<0x580005c8> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C22CR : public Register<0x580005cc> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C22TCR : public Register<0x580005d0> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C22BNDTR : public Register<0x580005d4> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C22SAR : public Register<0x580005d8> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C22DAR : public Register<0x580005dc> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C22BRUR : public Register<0x580005e0> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C22LAR : public Register<0x580005e4> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C22TBR : public Register<0x580005e8> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C22MAR : public Register<0x580005f0> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C22MDR : public Register<0x580005f4> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 23 interrupt/status register
        struct MDMA_C23ISR : public RegisterReadOnly<0x58000600> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 23 interrupt flag clear register
        struct MDMA_C23IFCR : public RegisterWriteOnly<0x58000604> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 23 error status register
        struct MDMA_C23ESR : public RegisterReadOnly<0x58000608> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C23CR : public Register<0x5800060c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C23TCR : public Register<0x58000610> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C23BNDTR : public Register<0x58000614> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C23SAR : public Register<0x58000618> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C23DAR : public Register<0x5800061c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C23BRUR : public Register<0x58000620> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C23LAR : public Register<0x58000624> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C23TBR : public Register<0x58000628> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C23MAR : public Register<0x58000630> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C23MDR : public Register<0x58000634> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 24 interrupt/status register
        struct MDMA_C24ISR : public RegisterReadOnly<0x58000640> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 24 interrupt flag clear register
        struct MDMA_C24IFCR : public RegisterWriteOnly<0x58000644> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 24 error status register
        struct MDMA_C24ESR : public RegisterReadOnly<0x58000648> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C24CR : public Register<0x5800064c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C24TCR : public Register<0x58000650> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C24BNDTR : public Register<0x58000654> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C24SAR : public Register<0x58000658> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C24DAR : public Register<0x5800065c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C24BRUR : public Register<0x58000660> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C24LAR : public Register<0x58000664> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C24TBR : public Register<0x58000668> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C24MAR : public Register<0x58000670> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C24MDR : public Register<0x58000674> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 25 interrupt/status register
        struct MDMA_C25ISR : public RegisterReadOnly<0x58000680> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 25 interrupt flag clear register
        struct MDMA_C25IFCR : public RegisterWriteOnly<0x58000684> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 25 error status register
        struct MDMA_C25ESR : public RegisterReadOnly<0x58000688> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C25CR : public Register<0x5800068c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C25TCR : public Register<0x58000690> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C25BNDTR : public Register<0x58000694> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C25SAR : public Register<0x58000698> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C25DAR : public Register<0x5800069c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C25BRUR : public Register<0x580006a0> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C25LAR : public Register<0x580006a4> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C25TBR : public Register<0x580006a8> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C25MAR : public Register<0x580006b0> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C25MDR : public Register<0x580006b4> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 26 interrupt/status register
        struct MDMA_C26ISR : public RegisterReadOnly<0x580006c0> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 26 interrupt flag clear register
        struct MDMA_C26IFCR : public RegisterWriteOnly<0x580006c4> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 26 error status register
        struct MDMA_C26ESR : public RegisterReadOnly<0x580006c8> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C26CR : public Register<0x580006cc> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C26TCR : public Register<0x580006d0> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C26BNDTR : public Register<0x580006d4> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C26SAR : public Register<0x580006d8> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C26DAR : public Register<0x580006dc> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C26BRUR : public Register<0x580006e0> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C26LAR : public Register<0x580006e4> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C26TBR : public Register<0x580006e8> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C26MAR : public Register<0x580006f0> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C26MDR : public Register<0x580006f4> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 27 interrupt/status register
        struct MDMA_C27ISR : public RegisterReadOnly<0x58000700> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 27 interrupt flag clear register
        struct MDMA_C27IFCR : public RegisterWriteOnly<0x58000704> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 27 error status register
        struct MDMA_C27ESR : public RegisterReadOnly<0x58000708> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C27CR : public Register<0x5800070c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C27TCR : public Register<0x58000710> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C27BNDTR : public Register<0x58000714> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C27SAR : public Register<0x58000718> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C27DAR : public Register<0x5800071c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C27BRUR : public Register<0x58000720> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C27LAR : public Register<0x58000724> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C27TBR : public Register<0x58000728> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C27MAR : public Register<0x58000730> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C27MDR : public Register<0x58000734> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 28 interrupt/status register
        struct MDMA_C28ISR : public RegisterReadOnly<0x58000740> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 28 interrupt flag clear register
        struct MDMA_C28IFCR : public RegisterWriteOnly<0x58000744> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 28 error status register
        struct MDMA_C28ESR : public RegisterReadOnly<0x58000748> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C28CR : public Register<0x5800074c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C28TCR : public Register<0x58000750> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C28BNDTR : public Register<0x58000754> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C28SAR : public Register<0x58000758> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C28DAR : public Register<0x5800075c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C28BRUR : public Register<0x58000760> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C28LAR : public Register<0x58000764> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C28TBR : public Register<0x58000768> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C28MAR : public Register<0x58000770> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C28MDR : public Register<0x58000774> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 29 interrupt/status register
        struct MDMA_C29ISR : public RegisterReadOnly<0x58000780> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 29 interrupt flag clear register
        struct MDMA_C29IFCR : public RegisterWriteOnly<0x58000784> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 29 error status register
        struct MDMA_C29ESR : public RegisterReadOnly<0x58000788> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C29CR : public Register<0x5800078c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C29TCR : public Register<0x58000790> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C29BNDTR : public Register<0x58000794> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C29SAR : public Register<0x58000798> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C29DAR : public Register<0x5800079c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C29BRUR : public Register<0x580007a0> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C29LAR : public Register<0x580007a4> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C29TBR : public Register<0x580007a8> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C29MAR : public Register<0x580007b0> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C29MDR : public Register<0x580007b4> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 30 interrupt/status register
        struct MDMA_C30ISR : public RegisterReadOnly<0x580007c0> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 30 interrupt flag clear register
        struct MDMA_C30IFCR : public RegisterWriteOnly<0x580007c4> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 30 error status register
        struct MDMA_C30ESR : public RegisterReadOnly<0x580007c8> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C30CR : public Register<0x580007cc> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C30TCR : public Register<0x580007d0> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C30BNDTR : public Register<0x580007d4> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C30SAR : public Register<0x580007d8> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C30DAR : public Register<0x580007dc> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C30BRUR : public Register<0x580007e0> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C30LAR : public Register<0x580007e4> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C30TBR : public Register<0x580007e8> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C30MAR : public Register<0x580007f0> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C30MDR : public Register<0x580007f4> {
            using MDR = Field<0, 32>;    // MDR
        };

        // MDMA channel 31 interrupt/status register
        struct MDMA_C31ISR : public RegisterReadOnly<0x58000800> {
            using TEIF = Field<0, 1>;    // TEIF
            using CTCIF = Field<1, 1>;    // CTCIF
            using BRTIF = Field<2, 1>;    // BRTIF
            using BTIF = Field<3, 1>;    // BTIF
            using TCIF = Field<4, 1>;    // TCIF
            using CRQA = Field<16, 1>;    // CRQA
        };

        // MDMA channel 31 interrupt flag clear register
        struct MDMA_C31IFCR : public RegisterWriteOnly<0x58000804> {
            using CTEIF = Field<0, 1>;    // CTEIF
            using CCTCIF = Field<1, 1>;    // CCTCIF
            using CBRTIF = Field<2, 1>;    // CBRTIF
            using CBTIF = Field<3, 1>;    // CBTIF
            using CLTCIF = Field<4, 1>;    // CLTCIF
        };

        // MDMA channel 31 error status register
        struct MDMA_C31ESR : public RegisterReadOnly<0x58000808> {
            using TEA = Field<0, 7>;    // TEA
            using TED = Field<7, 1>;    // TED
            using TELD = Field<8, 1>;    // TELD
            using TEMD = Field<9, 1>;    // TEMD
            using ASE = Field<10, 1>;    // ASE
            using BSE = Field<11, 1>;    // BSE
        };

        // This register is used to control the concerned channel.
        struct MDMA_C31CR : public Register<0x5800080c> {
            using EN = Field<0, 1>;    // EN
            using TEIE = Field<1, 1>;    // TEIE
            using CTCIE = Field<2, 1>;    // CTCIE
            using BRTIE = Field<3, 1>;    // BRTIE
            using BTIE = Field<4, 1>;    // BTIE
            using TCIE = Field<5, 1>;    // TCIE
            using PL = Field<6, 2>;    // PL
            using BEX = Field<12, 1>;    // BEX
            using HEX = Field<13, 1>;    // HEX
            using WEX = Field<14, 1>;    // WEX
            using SWRQ = Field<16, 1>;    // SWRQ
        };

        // This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
        struct MDMA_C31TCR : public Register<0x58000810> {
            using SINC = Field<0, 2>;    // SINC
            using DINC = Field<2, 2>;    // DINC
            using SSIZE = Field<4, 2>;    // SSIZE
            using DSIZE = Field<6, 2>;    // DSIZE
            using SINCOS = Field<8, 2>;    // SINCOS
            using DINCOS = Field<10, 2>;    // DINCOS
            using SBURST = Field<12, 3>;    // SBURST
            using DBURST = Field<15, 3>;    // DBURST
            using TLEN = Field<18, 7>;    // TLEN
            using PKE = Field<25, 1>;    // PKE
            using PAM = Field<26, 2>;    // PAM
            using TRGM = Field<28, 2>;    // TRGM
            using SWRM = Field<30, 1>;    // SWRM
            using BWM = Field<31, 1>;    // BWM
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
        struct MDMA_C31BNDTR : public Register<0x58000814> {
            using BNDT = Field<0, 17>;    // BNDT
            using BRSUM = Field<18, 1>;    // BRSUM
            using BRDUM = Field<19, 1>;    // BRDUM
            using BRC = Field<20, 12>;    // BRC
        };

        // In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
        struct MDMA_C31SAR : public Register<0x58000818> {
            using SAR = Field<0, 32>;    // SAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
        struct MDMA_C31DAR : public Register<0x5800081c> {
            using DAR = Field<0, 32>;    // DAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
        struct MDMA_C31BRUR : public Register<0x58000820> {
            using SUV = Field<0, 16>;    // SUV
            using DUV = Field<16, 16>;    // DUV
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
        struct MDMA_C31LAR : public Register<0x58000824> {
            using LAR = Field<0, 32>;    // LAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
        struct MDMA_C31TBR : public Register<0x58000828> {
            using TSEL = Field<0, 6>;    // TSEL
            using SBUS = Field<16, 1>;    // SBUS
            using DBUS = Field<17, 1>;    // DBUS
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
        struct MDMA_C31MAR : public Register<0x58000830> {
            using MAR = Field<0, 32>;    // MAR
        };

        // In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
        struct MDMA_C31MDR : public Register<0x58000834> {
            using MDR = Field<0, 32>;    // MDR
        };

    };

    // GPIOA
    struct GPIOA {
        // GPIO port mode register
        struct GPIOA_MODER : public Register<0x50002000> {
            using MODER0 = Field<0, 2>;    // MODER0
            using MODER1 = Field<2, 2>;    // MODER1
            using MODER2 = Field<4, 2>;    // MODER2
            using MODER3 = Field<6, 2>;    // MODER3
            using MODER4 = Field<8, 2>;    // MODER4
            using MODER5 = Field<10, 2>;    // MODER5
            using MODER6 = Field<12, 2>;    // MODER6
            using MODER7 = Field<14, 2>;    // MODER7
            using MODER8 = Field<16, 2>;    // MODER8
            using MODER9 = Field<18, 2>;    // MODER9
            using MODER10 = Field<20, 2>;    // MODER10
            using MODER11 = Field<22, 2>;    // MODER11
            using MODER12 = Field<24, 2>;    // MODER12
            using MODER13 = Field<26, 2>;    // MODER13
            using MODER14 = Field<28, 2>;    // MODER14
            using MODER15 = Field<30, 2>;    // MODER15
        };

        // GPIO port output type register
        struct GPIOA_OTYPER : public Register<0x50002004> {
            using OT0 = Field<0, 1>;    // OT0
            using OT1 = Field<1, 1>;    // OT1
            using OT2 = Field<2, 1>;    // OT2
            using OT3 = Field<3, 1>;    // OT3
            using OT4 = Field<4, 1>;    // OT4
            using OT5 = Field<5, 1>;    // OT5
            using OT6 = Field<6, 1>;    // OT6
            using OT7 = Field<7, 1>;    // OT7
            using OT8 = Field<8, 1>;    // OT8
            using OT9 = Field<9, 1>;    // OT9
            using OT10 = Field<10, 1>;    // OT10
            using OT11 = Field<11, 1>;    // OT11
            using OT12 = Field<12, 1>;    // OT12
            using OT13 = Field<13, 1>;    // OT13
            using OT14 = Field<14, 1>;    // OT14
            using OT15 = Field<15, 1>;    // OT15
        };

        // GPIO port output speed register
        struct GPIOA_OSPEEDR : public Register<0x50002008> {
            using OSPEEDR0 = Field<0, 2>;    // OSPEEDR0
            using OSPEEDR1 = Field<2, 2>;    // OSPEEDR1
            using OSPEEDR2 = Field<4, 2>;    // OSPEEDR2
            using OSPEEDR3 = Field<6, 2>;    // OSPEEDR3
            using OSPEEDR4 = Field<8, 2>;    // OSPEEDR4
            using OSPEEDR5 = Field<10, 2>;    // OSPEEDR5
            using OSPEEDR6 = Field<12, 2>;    // OSPEEDR6
            using OSPEEDR7 = Field<14, 2>;    // OSPEEDR7
            using OSPEEDR8 = Field<16, 2>;    // OSPEEDR8
            using OSPEEDR9 = Field<18, 2>;    // OSPEEDR9
            using OSPEEDR10 = Field<20, 2>;    // OSPEEDR10
            using OSPEEDR11 = Field<22, 2>;    // OSPEEDR11
            using OSPEEDR12 = Field<24, 2>;    // OSPEEDR12
            using OSPEEDR13 = Field<26, 2>;    // OSPEEDR13
            using OSPEEDR14 = Field<28, 2>;    // OSPEEDR14
            using OSPEEDR15 = Field<30, 2>;    // OSPEEDR15
        };

        // GPIO port pull-up/pull-down register
        struct GPIOA_PUPDR : public Register<0x5000200c> {
            using PUPDR0 = Field<0, 2>;    // PUPDR0
            using PUPDR1 = Field<2, 2>;    // PUPDR1
            using PUPDR2 = Field<4, 2>;    // PUPDR2
            using PUPDR3 = Field<6, 2>;    // PUPDR3
            using PUPDR4 = Field<8, 2>;    // PUPDR4
            using PUPDR5 = Field<10, 2>;    // PUPDR5
            using PUPDR6 = Field<12, 2>;    // PUPDR6
            using PUPDR7 = Field<14, 2>;    // PUPDR7
            using PUPDR8 = Field<16, 2>;    // PUPDR8
            using PUPDR9 = Field<18, 2>;    // PUPDR9
            using PUPDR10 = Field<20, 2>;    // PUPDR10
            using PUPDR11 = Field<22, 2>;    // PUPDR11
            using PUPDR12 = Field<24, 2>;    // PUPDR12
            using PUPDR13 = Field<26, 2>;    // PUPDR13
            using PUPDR14 = Field<28, 2>;    // PUPDR14
            using PUPDR15 = Field<30, 2>;    // PUPDR15
        };

        // GPIO port input data register
        struct GPIOA_IDR : public RegisterReadOnly<0x50002010> {
            using IDR0 = Field<0, 1>;    // IDR0
            using IDR1 = Field<1, 1>;    // IDR1
            using IDR2 = Field<2, 1>;    // IDR2
            using IDR3 = Field<3, 1>;    // IDR3
            using IDR4 = Field<4, 1>;    // IDR4
            using IDR5 = Field<5, 1>;    // IDR5
            using IDR6 = Field<6, 1>;    // IDR6
            using IDR7 = Field<7, 1>;    // IDR7
            using IDR8 = Field<8, 1>;    // IDR8
            using IDR9 = Field<9, 1>;    // IDR9
            using IDR10 = Field<10, 1>;    // IDR10
            using IDR11 = Field<11, 1>;    // IDR11
            using IDR12 = Field<12, 1>;    // IDR12
            using IDR13 = Field<13, 1>;    // IDR13
            using IDR14 = Field<14, 1>;    // IDR14
            using IDR15 = Field<15, 1>;    // IDR15
        };

        // GPIO port output data register
        struct GPIOA_ODR : public Register<0x50002014> {
            using ODR0 = Field<0, 1>;    // ODR0
            using ODR1 = Field<1, 1>;    // ODR1
            using ODR2 = Field<2, 1>;    // ODR2
            using ODR3 = Field<3, 1>;    // ODR3
            using ODR4 = Field<4, 1>;    // ODR4
            using ODR5 = Field<5, 1>;    // ODR5
            using ODR6 = Field<6, 1>;    // ODR6
            using ODR7 = Field<7, 1>;    // ODR7
            using ODR8 = Field<8, 1>;    // ODR8
            using ODR9 = Field<9, 1>;    // ODR9
            using ODR10 = Field<10, 1>;    // ODR10
            using ODR11 = Field<11, 1>;    // ODR11
            using ODR12 = Field<12, 1>;    // ODR12
            using ODR13 = Field<13, 1>;    // ODR13
            using ODR14 = Field<14, 1>;    // ODR14
            using ODR15 = Field<15, 1>;    // ODR15
        };

        // GPIO port bit set/reset register
        struct GPIOA_BSRR : public RegisterWriteOnly<0x50002018> {
            using BS0 = Field<0, 1>;    // BS0
            using BS1 = Field<1, 1>;    // BS1
            using BS2 = Field<2, 1>;    // BS2
            using BS3 = Field<3, 1>;    // BS3
            using BS4 = Field<4, 1>;    // BS4
            using BS5 = Field<5, 1>;    // BS5
            using BS6 = Field<6, 1>;    // BS6
            using BS7 = Field<7, 1>;    // BS7
            using BS8 = Field<8, 1>;    // BS8
            using BS9 = Field<9, 1>;    // BS9
            using BS10 = Field<10, 1>;    // BS10
            using BS11 = Field<11, 1>;    // BS11
            using BS12 = Field<12, 1>;    // BS12
            using BS13 = Field<13, 1>;    // BS13
            using BS14 = Field<14, 1>;    // BS14
            using BS15 = Field<15, 1>;    // BS15
            using BR0 = Field<16, 1>;    // BR0
            using BR1 = Field<17, 1>;    // BR1
            using BR2 = Field<18, 1>;    // BR2
            using BR3 = Field<19, 1>;    // BR3
            using BR4 = Field<20, 1>;    // BR4
            using BR5 = Field<21, 1>;    // BR5
            using BR6 = Field<22, 1>;    // BR6
            using BR7 = Field<23, 1>;    // BR7
            using BR8 = Field<24, 1>;    // BR8
            using BR9 = Field<25, 1>;    // BR9
            using BR10 = Field<26, 1>;    // BR10
            using BR11 = Field<27, 1>;    // BR11
            using BR12 = Field<28, 1>;    // BR12
            using BR13 = Field<29, 1>;    // BR13
            using BR14 = Field<30, 1>;    // BR14
            using BR15 = Field<31, 1>;    // BR15
        };

        // This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
        struct GPIOA_LCKR : public Register<0x5000201c> {
            using LCK0 = Field<0, 1>;    // LCK0
            using LCK1 = Field<1, 1>;    // LCK1
            using LCK2 = Field<2, 1>;    // LCK2
            using LCK3 = Field<3, 1>;    // LCK3
            using LCK4 = Field<4, 1>;    // LCK4
            using LCK5 = Field<5, 1>;    // LCK5
            using LCK6 = Field<6, 1>;    // LCK6
            using LCK7 = Field<7, 1>;    // LCK7
            using LCK8 = Field<8, 1>;    // LCK8
            using LCK9 = Field<9, 1>;    // LCK9
            using LCK10 = Field<10, 1>;    // LCK10
            using LCK11 = Field<11, 1>;    // LCK11
            using LCK12 = Field<12, 1>;    // LCK12
            using LCK13 = Field<13, 1>;    // LCK13
            using LCK14 = Field<14, 1>;    // LCK14
            using LCK15 = Field<15, 1>;    // LCK15
            using LCKK = Field<16, 1>;    // LCKK
        };

        // GPIO alternate function low register
        struct GPIOA_AFRL : public Register<0x50002020> {
            using AFR0 = Field<0, 4>;    // AFR0
            using AFR1 = Field<4, 4>;    // AFR1
            using AFR2 = Field<8, 4>;    // AFR2
            using AFR3 = Field<12, 4>;    // AFR3
            using AFR4 = Field<16, 4>;    // AFR4
            using AFR5 = Field<20, 4>;    // AFR5
            using AFR6 = Field<24, 4>;    // AFR6
            using AFR7 = Field<28, 4>;    // AFR7
        };

        // GPIO alternate function high register
        struct GPIOA_AFRH : public Register<0x50002024> {
            using AFR8 = Field<0, 4>;    // AFR8
            using AFR9 = Field<4, 4>;    // AFR9
            using AFR10 = Field<8, 4>;    // AFR10
            using AFR11 = Field<12, 4>;    // AFR11
            using AFR12 = Field<16, 4>;    // AFR12
            using AFR13 = Field<20, 4>;    // AFR13
            using AFR14 = Field<24, 4>;    // AFR14
            using AFR15 = Field<28, 4>;    // AFR15
        };

        // GPIO port bit reset register
        struct GPIOA_BRR : public RegisterWriteOnly<0x50002028> {
            using BR0 = Field<0, 1>;    // BR0
            using BR1 = Field<1, 1>;    // BR1
            using BR2 = Field<2, 1>;    // BR2
            using BR3 = Field<3, 1>;    // BR3
            using BR4 = Field<4, 1>;    // BR4
            using BR5 = Field<5, 1>;    // BR5
            using BR6 = Field<6, 1>;    // BR6
            using BR7 = Field<7, 1>;    // BR7
            using BR8 = Field<8, 1>;    // BR8
            using BR9 = Field<9, 1>;    // BR9
            using BR10 = Field<10, 1>;    // BR10
            using BR11 = Field<11, 1>;    // BR11
            using BR12 = Field<12, 1>;    // BR12
            using BR13 = Field<13, 1>;    // BR13
            using BR14 = Field<14, 1>;    // BR14
            using BR15 = Field<15, 1>;    // BR15
        };

        // For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
        struct GPIOA_HWCFGR10 : public RegisterReadOnly<0x500023c8> {
            using AHB_IOP = Field<0, 4>;    // AHB_IOP
            using AF_SIZE = Field<4, 4>;    // AF_SIZE
            using SPEED_CFG = Field<8, 4>;    // SPEED_CFG
            using LOCK_CFG = Field<12, 4>;    // LOCK_CFG
            using SEC_CFG = Field<16, 4>;    // SEC_CFG
            using OR_CFG = Field<20, 4>;    // OR_CFG
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOA_HWCFGR9 : public RegisterReadOnly<0x500023cc> {
            using EN_IO = Field<0, 16>;    // EN_IO
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOA_HWCFGR8 : public RegisterReadOnly<0x500023d0> {
            using AF_PRIO8 = Field<0, 4>;    // AF_PRIO8
            using AF_PRIO9 = Field<4, 4>;    // AF_PRIO9
            using AF_PRIO10 = Field<8, 4>;    // AF_PRIO10
            using AF_PRIO11 = Field<12, 4>;    // AF_PRIO11
            using AF_PRIO12 = Field<16, 4>;    // AF_PRIO12
            using AF_PRIO13 = Field<20, 4>;    // AF_PRIO13
            using AF_PRIO14 = Field<24, 4>;    // AF_PRIO14
            using AF_PRIO15 = Field<28, 4>;    // AF_PRIO15
        };

        // GPIO hardware configuration register 7
        struct GPIOA_HWCFGR7 : public RegisterReadOnly<0x500023d4> {
            using AF_PRIO0 = Field<0, 4>;    // AF_PRIO0
            using AF_PRIO1 = Field<4, 4>;    // AF_PRIO1
            using AF_PRIO2 = Field<8, 4>;    // AF_PRIO2
            using AF_PRIO3 = Field<12, 4>;    // AF_PRIO3
            using AF_PRIO4 = Field<16, 4>;    // AF_PRIO4
            using AF_PRIO5 = Field<20, 4>;    // AF_PRIO5
            using AF_PRIO6 = Field<24, 4>;    // AF_PRIO6
            using AF_PRIO7 = Field<28, 4>;    // AF_PRIO7
        };

        // GPIO hardware configuration register 6
        struct GPIOA_HWCFGR6 : public RegisterReadOnly<0x500023d8> {
            using MODER_RES = Field<0, 32>;    // MODER_RES
        };

        // GPIO hardware configuration register 5
        struct GPIOA_HWCFGR5 : public RegisterReadOnly<0x500023dc> {
            using PUPDR_RES = Field<0, 32>;    // PUPDR_RES
        };

        // GPIO hardware configuration register 4
        struct GPIOA_HWCFGR4 : public RegisterReadOnly<0x500023e0> {
            using OSPEED_RES = Field<0, 32>;    // OSPEED_RES
        };

        // GPIO hardware configuration register 3
        struct GPIOA_HWCFGR3 : public RegisterReadOnly<0x500023e4> {
            using ODR_RES = Field<0, 16>;    // ODR_RES
            using OTYPER_RES = Field<16, 16>;    // OTYPER_RES
        };

        // GPIO hardware configuration register 2
        struct GPIOA_HWCFGR2 : public RegisterReadOnly<0x500023e8> {
            using AFRL_RES = Field<0, 32>;    // AFRL_RES
        };

        // GPIO hardware configuration register 1
        struct GPIOA_HWCFGR1 : public RegisterReadOnly<0x500023ec> {
            using AFRH_RES = Field<0, 32>;    // AFRH_RES
        };

        // GPIO hardware configuration register 0
        struct GPIOA_HWCFGR0 : public RegisterReadOnly<0x500023f0> {
            using OR_RES = Field<0, 16>;    // OR_RES
        };

        // GPIO version register
        struct GPIOA_VERR : public RegisterReadOnly<0x500023f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // GPIO identification register
        struct GPIOA_IPIDR : public RegisterReadOnly<0x500023f8> {
            using IPIDR = Field<0, 32>;    // IPIDR
        };

        // GPIO size identification register
        struct GPIOA_SIDR : public RegisterReadOnly<0x500023fc> {
            using SIDR = Field<0, 32>;    // SIDR
        };

    };

    // GPIOB
    struct GPIOB {
        // GPIO port mode register
        struct GPIOB_MODER : public Register<0x50003000> {
            using MODER0 = Field<0, 2>;    // MODER0
            using MODER1 = Field<2, 2>;    // MODER1
            using MODER2 = Field<4, 2>;    // MODER2
            using MODER3 = Field<6, 2>;    // MODER3
            using MODER4 = Field<8, 2>;    // MODER4
            using MODER5 = Field<10, 2>;    // MODER5
            using MODER6 = Field<12, 2>;    // MODER6
            using MODER7 = Field<14, 2>;    // MODER7
            using MODER8 = Field<16, 2>;    // MODER8
            using MODER9 = Field<18, 2>;    // MODER9
            using MODER10 = Field<20, 2>;    // MODER10
            using MODER11 = Field<22, 2>;    // MODER11
            using MODER12 = Field<24, 2>;    // MODER12
            using MODER13 = Field<26, 2>;    // MODER13
            using MODER14 = Field<28, 2>;    // MODER14
            using MODER15 = Field<30, 2>;    // MODER15
        };

        // GPIO port output type register
        struct GPIOB_OTYPER : public Register<0x50003004> {
            using OT0 = Field<0, 1>;    // OT0
            using OT1 = Field<1, 1>;    // OT1
            using OT2 = Field<2, 1>;    // OT2
            using OT3 = Field<3, 1>;    // OT3
            using OT4 = Field<4, 1>;    // OT4
            using OT5 = Field<5, 1>;    // OT5
            using OT6 = Field<6, 1>;    // OT6
            using OT7 = Field<7, 1>;    // OT7
            using OT8 = Field<8, 1>;    // OT8
            using OT9 = Field<9, 1>;    // OT9
            using OT10 = Field<10, 1>;    // OT10
            using OT11 = Field<11, 1>;    // OT11
            using OT12 = Field<12, 1>;    // OT12
            using OT13 = Field<13, 1>;    // OT13
            using OT14 = Field<14, 1>;    // OT14
            using OT15 = Field<15, 1>;    // OT15
        };

        // GPIO port output speed register
        struct GPIOB_OSPEEDR : public Register<0x50003008> {
            using OSPEEDR0 = Field<0, 2>;    // OSPEEDR0
            using OSPEEDR1 = Field<2, 2>;    // OSPEEDR1
            using OSPEEDR2 = Field<4, 2>;    // OSPEEDR2
            using OSPEEDR3 = Field<6, 2>;    // OSPEEDR3
            using OSPEEDR4 = Field<8, 2>;    // OSPEEDR4
            using OSPEEDR5 = Field<10, 2>;    // OSPEEDR5
            using OSPEEDR6 = Field<12, 2>;    // OSPEEDR6
            using OSPEEDR7 = Field<14, 2>;    // OSPEEDR7
            using OSPEEDR8 = Field<16, 2>;    // OSPEEDR8
            using OSPEEDR9 = Field<18, 2>;    // OSPEEDR9
            using OSPEEDR10 = Field<20, 2>;    // OSPEEDR10
            using OSPEEDR11 = Field<22, 2>;    // OSPEEDR11
            using OSPEEDR12 = Field<24, 2>;    // OSPEEDR12
            using OSPEEDR13 = Field<26, 2>;    // OSPEEDR13
            using OSPEEDR14 = Field<28, 2>;    // OSPEEDR14
            using OSPEEDR15 = Field<30, 2>;    // OSPEEDR15
        };

        // GPIO port pull-up/pull-down register
        struct GPIOB_PUPDR : public Register<0x5000300c> {
            using PUPDR0 = Field<0, 2>;    // PUPDR0
            using PUPDR1 = Field<2, 2>;    // PUPDR1
            using PUPDR2 = Field<4, 2>;    // PUPDR2
            using PUPDR3 = Field<6, 2>;    // PUPDR3
            using PUPDR4 = Field<8, 2>;    // PUPDR4
            using PUPDR5 = Field<10, 2>;    // PUPDR5
            using PUPDR6 = Field<12, 2>;    // PUPDR6
            using PUPDR7 = Field<14, 2>;    // PUPDR7
            using PUPDR8 = Field<16, 2>;    // PUPDR8
            using PUPDR9 = Field<18, 2>;    // PUPDR9
            using PUPDR10 = Field<20, 2>;    // PUPDR10
            using PUPDR11 = Field<22, 2>;    // PUPDR11
            using PUPDR12 = Field<24, 2>;    // PUPDR12
            using PUPDR13 = Field<26, 2>;    // PUPDR13
            using PUPDR14 = Field<28, 2>;    // PUPDR14
            using PUPDR15 = Field<30, 2>;    // PUPDR15
        };

        // GPIO port input data register
        struct GPIOB_IDR : public RegisterReadOnly<0x50003010> {
            using IDR0 = Field<0, 1>;    // IDR0
            using IDR1 = Field<1, 1>;    // IDR1
            using IDR2 = Field<2, 1>;    // IDR2
            using IDR3 = Field<3, 1>;    // IDR3
            using IDR4 = Field<4, 1>;    // IDR4
            using IDR5 = Field<5, 1>;    // IDR5
            using IDR6 = Field<6, 1>;    // IDR6
            using IDR7 = Field<7, 1>;    // IDR7
            using IDR8 = Field<8, 1>;    // IDR8
            using IDR9 = Field<9, 1>;    // IDR9
            using IDR10 = Field<10, 1>;    // IDR10
            using IDR11 = Field<11, 1>;    // IDR11
            using IDR12 = Field<12, 1>;    // IDR12
            using IDR13 = Field<13, 1>;    // IDR13
            using IDR14 = Field<14, 1>;    // IDR14
            using IDR15 = Field<15, 1>;    // IDR15
        };

        // GPIO port output data register
        struct GPIOB_ODR : public Register<0x50003014> {
            using ODR0 = Field<0, 1>;    // ODR0
            using ODR1 = Field<1, 1>;    // ODR1
            using ODR2 = Field<2, 1>;    // ODR2
            using ODR3 = Field<3, 1>;    // ODR3
            using ODR4 = Field<4, 1>;    // ODR4
            using ODR5 = Field<5, 1>;    // ODR5
            using ODR6 = Field<6, 1>;    // ODR6
            using ODR7 = Field<7, 1>;    // ODR7
            using ODR8 = Field<8, 1>;    // ODR8
            using ODR9 = Field<9, 1>;    // ODR9
            using ODR10 = Field<10, 1>;    // ODR10
            using ODR11 = Field<11, 1>;    // ODR11
            using ODR12 = Field<12, 1>;    // ODR12
            using ODR13 = Field<13, 1>;    // ODR13
            using ODR14 = Field<14, 1>;    // ODR14
            using ODR15 = Field<15, 1>;    // ODR15
        };

        // GPIO port bit set/reset register
        struct GPIOB_BSRR : public RegisterWriteOnly<0x50003018> {
            using BS0 = Field<0, 1>;    // BS0
            using BS1 = Field<1, 1>;    // BS1
            using BS2 = Field<2, 1>;    // BS2
            using BS3 = Field<3, 1>;    // BS3
            using BS4 = Field<4, 1>;    // BS4
            using BS5 = Field<5, 1>;    // BS5
            using BS6 = Field<6, 1>;    // BS6
            using BS7 = Field<7, 1>;    // BS7
            using BS8 = Field<8, 1>;    // BS8
            using BS9 = Field<9, 1>;    // BS9
            using BS10 = Field<10, 1>;    // BS10
            using BS11 = Field<11, 1>;    // BS11
            using BS12 = Field<12, 1>;    // BS12
            using BS13 = Field<13, 1>;    // BS13
            using BS14 = Field<14, 1>;    // BS14
            using BS15 = Field<15, 1>;    // BS15
            using BR0 = Field<16, 1>;    // BR0
            using BR1 = Field<17, 1>;    // BR1
            using BR2 = Field<18, 1>;    // BR2
            using BR3 = Field<19, 1>;    // BR3
            using BR4 = Field<20, 1>;    // BR4
            using BR5 = Field<21, 1>;    // BR5
            using BR6 = Field<22, 1>;    // BR6
            using BR7 = Field<23, 1>;    // BR7
            using BR8 = Field<24, 1>;    // BR8
            using BR9 = Field<25, 1>;    // BR9
            using BR10 = Field<26, 1>;    // BR10
            using BR11 = Field<27, 1>;    // BR11
            using BR12 = Field<28, 1>;    // BR12
            using BR13 = Field<29, 1>;    // BR13
            using BR14 = Field<30, 1>;    // BR14
            using BR15 = Field<31, 1>;    // BR15
        };

        // This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
        struct GPIOB_LCKR : public Register<0x5000301c> {
            using LCK0 = Field<0, 1>;    // LCK0
            using LCK1 = Field<1, 1>;    // LCK1
            using LCK2 = Field<2, 1>;    // LCK2
            using LCK3 = Field<3, 1>;    // LCK3
            using LCK4 = Field<4, 1>;    // LCK4
            using LCK5 = Field<5, 1>;    // LCK5
            using LCK6 = Field<6, 1>;    // LCK6
            using LCK7 = Field<7, 1>;    // LCK7
            using LCK8 = Field<8, 1>;    // LCK8
            using LCK9 = Field<9, 1>;    // LCK9
            using LCK10 = Field<10, 1>;    // LCK10
            using LCK11 = Field<11, 1>;    // LCK11
            using LCK12 = Field<12, 1>;    // LCK12
            using LCK13 = Field<13, 1>;    // LCK13
            using LCK14 = Field<14, 1>;    // LCK14
            using LCK15 = Field<15, 1>;    // LCK15
            using LCKK = Field<16, 1>;    // LCKK
        };

        // GPIO alternate function low register
        struct GPIOB_AFRL : public Register<0x50003020> {
            using AFR0 = Field<0, 4>;    // AFR0
            using AFR1 = Field<4, 4>;    // AFR1
            using AFR2 = Field<8, 4>;    // AFR2
            using AFR3 = Field<12, 4>;    // AFR3
            using AFR4 = Field<16, 4>;    // AFR4
            using AFR5 = Field<20, 4>;    // AFR5
            using AFR6 = Field<24, 4>;    // AFR6
            using AFR7 = Field<28, 4>;    // AFR7
        };

        // GPIO alternate function high register
        struct GPIOB_AFRH : public Register<0x50003024> {
            using AFR8 = Field<0, 4>;    // AFR8
            using AFR9 = Field<4, 4>;    // AFR9
            using AFR10 = Field<8, 4>;    // AFR10
            using AFR11 = Field<12, 4>;    // AFR11
            using AFR12 = Field<16, 4>;    // AFR12
            using AFR13 = Field<20, 4>;    // AFR13
            using AFR14 = Field<24, 4>;    // AFR14
            using AFR15 = Field<28, 4>;    // AFR15
        };

        // GPIO port bit reset register
        struct GPIOB_BRR : public RegisterWriteOnly<0x50003028> {
            using BR0 = Field<0, 1>;    // BR0
            using BR1 = Field<1, 1>;    // BR1
            using BR2 = Field<2, 1>;    // BR2
            using BR3 = Field<3, 1>;    // BR3
            using BR4 = Field<4, 1>;    // BR4
            using BR5 = Field<5, 1>;    // BR5
            using BR6 = Field<6, 1>;    // BR6
            using BR7 = Field<7, 1>;    // BR7
            using BR8 = Field<8, 1>;    // BR8
            using BR9 = Field<9, 1>;    // BR9
            using BR10 = Field<10, 1>;    // BR10
            using BR11 = Field<11, 1>;    // BR11
            using BR12 = Field<12, 1>;    // BR12
            using BR13 = Field<13, 1>;    // BR13
            using BR14 = Field<14, 1>;    // BR14
            using BR15 = Field<15, 1>;    // BR15
        };

        // For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
        struct GPIOB_HWCFGR10 : public RegisterReadOnly<0x500033c8> {
            using AHB_IOP = Field<0, 4>;    // AHB_IOP
            using AF_SIZE = Field<4, 4>;    // AF_SIZE
            using SPEED_CFG = Field<8, 4>;    // SPEED_CFG
            using LOCK_CFG = Field<12, 4>;    // LOCK_CFG
            using SEC_CFG = Field<16, 4>;    // SEC_CFG
            using OR_CFG = Field<20, 4>;    // OR_CFG
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOB_HWCFGR9 : public RegisterReadOnly<0x500033cc> {
            using EN_IO = Field<0, 16>;    // EN_IO
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOB_HWCFGR8 : public RegisterReadOnly<0x500033d0> {
            using AF_PRIO8 = Field<0, 4>;    // AF_PRIO8
            using AF_PRIO9 = Field<4, 4>;    // AF_PRIO9
            using AF_PRIO10 = Field<8, 4>;    // AF_PRIO10
            using AF_PRIO11 = Field<12, 4>;    // AF_PRIO11
            using AF_PRIO12 = Field<16, 4>;    // AF_PRIO12
            using AF_PRIO13 = Field<20, 4>;    // AF_PRIO13
            using AF_PRIO14 = Field<24, 4>;    // AF_PRIO14
            using AF_PRIO15 = Field<28, 4>;    // AF_PRIO15
        };

        // GPIO hardware configuration register 7
        struct GPIOB_HWCFGR7 : public RegisterReadOnly<0x500033d4> {
            using AF_PRIO0 = Field<0, 4>;    // AF_PRIO0
            using AF_PRIO1 = Field<4, 4>;    // AF_PRIO1
            using AF_PRIO2 = Field<8, 4>;    // AF_PRIO2
            using AF_PRIO3 = Field<12, 4>;    // AF_PRIO3
            using AF_PRIO4 = Field<16, 4>;    // AF_PRIO4
            using AF_PRIO5 = Field<20, 4>;    // AF_PRIO5
            using AF_PRIO6 = Field<24, 4>;    // AF_PRIO6
            using AF_PRIO7 = Field<28, 4>;    // AF_PRIO7
        };

        // GPIO hardware configuration register 6
        struct GPIOB_HWCFGR6 : public RegisterReadOnly<0x500033d8> {
            using MODER_RES = Field<0, 32>;    // MODER_RES
        };

        // GPIO hardware configuration register 5
        struct GPIOB_HWCFGR5 : public RegisterReadOnly<0x500033dc> {
            using PUPDR_RES = Field<0, 32>;    // PUPDR_RES
        };

        // GPIO hardware configuration register 4
        struct GPIOB_HWCFGR4 : public RegisterReadOnly<0x500033e0> {
            using OSPEED_RES = Field<0, 32>;    // OSPEED_RES
        };

        // GPIO hardware configuration register 3
        struct GPIOB_HWCFGR3 : public RegisterReadOnly<0x500033e4> {
            using ODR_RES = Field<0, 16>;    // ODR_RES
            using OTYPER_RES = Field<16, 16>;    // OTYPER_RES
        };

        // GPIO hardware configuration register 2
        struct GPIOB_HWCFGR2 : public RegisterReadOnly<0x500033e8> {
            using AFRL_RES = Field<0, 32>;    // AFRL_RES
        };

        // GPIO hardware configuration register 1
        struct GPIOB_HWCFGR1 : public RegisterReadOnly<0x500033ec> {
            using AFRH_RES = Field<0, 32>;    // AFRH_RES
        };

        // GPIO hardware configuration register 0
        struct GPIOB_HWCFGR0 : public RegisterReadOnly<0x500033f0> {
            using OR_RES = Field<0, 16>;    // OR_RES
        };

        // GPIO version register
        struct GPIOB_VERR : public RegisterReadOnly<0x500033f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // GPIO identification register
        struct GPIOB_IPIDR : public RegisterReadOnly<0x500033f8> {
            using IPIDR = Field<0, 32>;    // IPIDR
        };

        // GPIO size identification register
        struct GPIOB_SIDR : public RegisterReadOnly<0x500033fc> {
            using SIDR = Field<0, 32>;    // SIDR
        };

    };

    // GPIOC
    struct GPIOC {
        // GPIO port mode register
        struct GPIOC_MODER : public Register<0x50004000> {
            using MODER0 = Field<0, 2>;    // MODER0
            using MODER1 = Field<2, 2>;    // MODER1
            using MODER2 = Field<4, 2>;    // MODER2
            using MODER3 = Field<6, 2>;    // MODER3
            using MODER4 = Field<8, 2>;    // MODER4
            using MODER5 = Field<10, 2>;    // MODER5
            using MODER6 = Field<12, 2>;    // MODER6
            using MODER7 = Field<14, 2>;    // MODER7
            using MODER8 = Field<16, 2>;    // MODER8
            using MODER9 = Field<18, 2>;    // MODER9
            using MODER10 = Field<20, 2>;    // MODER10
            using MODER11 = Field<22, 2>;    // MODER11
            using MODER12 = Field<24, 2>;    // MODER12
            using MODER13 = Field<26, 2>;    // MODER13
            using MODER14 = Field<28, 2>;    // MODER14
            using MODER15 = Field<30, 2>;    // MODER15
        };

        // GPIO port output type register
        struct GPIOC_OTYPER : public Register<0x50004004> {
            using OT0 = Field<0, 1>;    // OT0
            using OT1 = Field<1, 1>;    // OT1
            using OT2 = Field<2, 1>;    // OT2
            using OT3 = Field<3, 1>;    // OT3
            using OT4 = Field<4, 1>;    // OT4
            using OT5 = Field<5, 1>;    // OT5
            using OT6 = Field<6, 1>;    // OT6
            using OT7 = Field<7, 1>;    // OT7
            using OT8 = Field<8, 1>;    // OT8
            using OT9 = Field<9, 1>;    // OT9
            using OT10 = Field<10, 1>;    // OT10
            using OT11 = Field<11, 1>;    // OT11
            using OT12 = Field<12, 1>;    // OT12
            using OT13 = Field<13, 1>;    // OT13
            using OT14 = Field<14, 1>;    // OT14
            using OT15 = Field<15, 1>;    // OT15
        };

        // GPIO port output speed register
        struct GPIOC_OSPEEDR : public Register<0x50004008> {
            using OSPEEDR0 = Field<0, 2>;    // OSPEEDR0
            using OSPEEDR1 = Field<2, 2>;    // OSPEEDR1
            using OSPEEDR2 = Field<4, 2>;    // OSPEEDR2
            using OSPEEDR3 = Field<6, 2>;    // OSPEEDR3
            using OSPEEDR4 = Field<8, 2>;    // OSPEEDR4
            using OSPEEDR5 = Field<10, 2>;    // OSPEEDR5
            using OSPEEDR6 = Field<12, 2>;    // OSPEEDR6
            using OSPEEDR7 = Field<14, 2>;    // OSPEEDR7
            using OSPEEDR8 = Field<16, 2>;    // OSPEEDR8
            using OSPEEDR9 = Field<18, 2>;    // OSPEEDR9
            using OSPEEDR10 = Field<20, 2>;    // OSPEEDR10
            using OSPEEDR11 = Field<22, 2>;    // OSPEEDR11
            using OSPEEDR12 = Field<24, 2>;    // OSPEEDR12
            using OSPEEDR13 = Field<26, 2>;    // OSPEEDR13
            using OSPEEDR14 = Field<28, 2>;    // OSPEEDR14
            using OSPEEDR15 = Field<30, 2>;    // OSPEEDR15
        };

        // GPIO port pull-up/pull-down register
        struct GPIOC_PUPDR : public Register<0x5000400c> {
            using PUPDR0 = Field<0, 2>;    // PUPDR0
            using PUPDR1 = Field<2, 2>;    // PUPDR1
            using PUPDR2 = Field<4, 2>;    // PUPDR2
            using PUPDR3 = Field<6, 2>;    // PUPDR3
            using PUPDR4 = Field<8, 2>;    // PUPDR4
            using PUPDR5 = Field<10, 2>;    // PUPDR5
            using PUPDR6 = Field<12, 2>;    // PUPDR6
            using PUPDR7 = Field<14, 2>;    // PUPDR7
            using PUPDR8 = Field<16, 2>;    // PUPDR8
            using PUPDR9 = Field<18, 2>;    // PUPDR9
            using PUPDR10 = Field<20, 2>;    // PUPDR10
            using PUPDR11 = Field<22, 2>;    // PUPDR11
            using PUPDR12 = Field<24, 2>;    // PUPDR12
            using PUPDR13 = Field<26, 2>;    // PUPDR13
            using PUPDR14 = Field<28, 2>;    // PUPDR14
            using PUPDR15 = Field<30, 2>;    // PUPDR15
        };

        // GPIO port input data register
        struct GPIOC_IDR : public RegisterReadOnly<0x50004010> {
            using IDR0 = Field<0, 1>;    // IDR0
            using IDR1 = Field<1, 1>;    // IDR1
            using IDR2 = Field<2, 1>;    // IDR2
            using IDR3 = Field<3, 1>;    // IDR3
            using IDR4 = Field<4, 1>;    // IDR4
            using IDR5 = Field<5, 1>;    // IDR5
            using IDR6 = Field<6, 1>;    // IDR6
            using IDR7 = Field<7, 1>;    // IDR7
            using IDR8 = Field<8, 1>;    // IDR8
            using IDR9 = Field<9, 1>;    // IDR9
            using IDR10 = Field<10, 1>;    // IDR10
            using IDR11 = Field<11, 1>;    // IDR11
            using IDR12 = Field<12, 1>;    // IDR12
            using IDR13 = Field<13, 1>;    // IDR13
            using IDR14 = Field<14, 1>;    // IDR14
            using IDR15 = Field<15, 1>;    // IDR15
        };

        // GPIO port output data register
        struct GPIOC_ODR : public Register<0x50004014> {
            using ODR0 = Field<0, 1>;    // ODR0
            using ODR1 = Field<1, 1>;    // ODR1
            using ODR2 = Field<2, 1>;    // ODR2
            using ODR3 = Field<3, 1>;    // ODR3
            using ODR4 = Field<4, 1>;    // ODR4
            using ODR5 = Field<5, 1>;    // ODR5
            using ODR6 = Field<6, 1>;    // ODR6
            using ODR7 = Field<7, 1>;    // ODR7
            using ODR8 = Field<8, 1>;    // ODR8
            using ODR9 = Field<9, 1>;    // ODR9
            using ODR10 = Field<10, 1>;    // ODR10
            using ODR11 = Field<11, 1>;    // ODR11
            using ODR12 = Field<12, 1>;    // ODR12
            using ODR13 = Field<13, 1>;    // ODR13
            using ODR14 = Field<14, 1>;    // ODR14
            using ODR15 = Field<15, 1>;    // ODR15
        };

        // GPIO port bit set/reset register
        struct GPIOC_BSRR : public RegisterWriteOnly<0x50004018> {
            using BS0 = Field<0, 1>;    // BS0
            using BS1 = Field<1, 1>;    // BS1
            using BS2 = Field<2, 1>;    // BS2
            using BS3 = Field<3, 1>;    // BS3
            using BS4 = Field<4, 1>;    // BS4
            using BS5 = Field<5, 1>;    // BS5
            using BS6 = Field<6, 1>;    // BS6
            using BS7 = Field<7, 1>;    // BS7
            using BS8 = Field<8, 1>;    // BS8
            using BS9 = Field<9, 1>;    // BS9
            using BS10 = Field<10, 1>;    // BS10
            using BS11 = Field<11, 1>;    // BS11
            using BS12 = Field<12, 1>;    // BS12
            using BS13 = Field<13, 1>;    // BS13
            using BS14 = Field<14, 1>;    // BS14
            using BS15 = Field<15, 1>;    // BS15
            using BR0 = Field<16, 1>;    // BR0
            using BR1 = Field<17, 1>;    // BR1
            using BR2 = Field<18, 1>;    // BR2
            using BR3 = Field<19, 1>;    // BR3
            using BR4 = Field<20, 1>;    // BR4
            using BR5 = Field<21, 1>;    // BR5
            using BR6 = Field<22, 1>;    // BR6
            using BR7 = Field<23, 1>;    // BR7
            using BR8 = Field<24, 1>;    // BR8
            using BR9 = Field<25, 1>;    // BR9
            using BR10 = Field<26, 1>;    // BR10
            using BR11 = Field<27, 1>;    // BR11
            using BR12 = Field<28, 1>;    // BR12
            using BR13 = Field<29, 1>;    // BR13
            using BR14 = Field<30, 1>;    // BR14
            using BR15 = Field<31, 1>;    // BR15
        };

        // This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
        struct GPIOC_LCKR : public Register<0x5000401c> {
            using LCK0 = Field<0, 1>;    // LCK0
            using LCK1 = Field<1, 1>;    // LCK1
            using LCK2 = Field<2, 1>;    // LCK2
            using LCK3 = Field<3, 1>;    // LCK3
            using LCK4 = Field<4, 1>;    // LCK4
            using LCK5 = Field<5, 1>;    // LCK5
            using LCK6 = Field<6, 1>;    // LCK6
            using LCK7 = Field<7, 1>;    // LCK7
            using LCK8 = Field<8, 1>;    // LCK8
            using LCK9 = Field<9, 1>;    // LCK9
            using LCK10 = Field<10, 1>;    // LCK10
            using LCK11 = Field<11, 1>;    // LCK11
            using LCK12 = Field<12, 1>;    // LCK12
            using LCK13 = Field<13, 1>;    // LCK13
            using LCK14 = Field<14, 1>;    // LCK14
            using LCK15 = Field<15, 1>;    // LCK15
            using LCKK = Field<16, 1>;    // LCKK
        };

        // GPIO alternate function low register
        struct GPIOC_AFRL : public Register<0x50004020> {
            using AFR0 = Field<0, 4>;    // AFR0
            using AFR1 = Field<4, 4>;    // AFR1
            using AFR2 = Field<8, 4>;    // AFR2
            using AFR3 = Field<12, 4>;    // AFR3
            using AFR4 = Field<16, 4>;    // AFR4
            using AFR5 = Field<20, 4>;    // AFR5
            using AFR6 = Field<24, 4>;    // AFR6
            using AFR7 = Field<28, 4>;    // AFR7
        };

        // GPIO alternate function high register
        struct GPIOC_AFRH : public Register<0x50004024> {
            using AFR8 = Field<0, 4>;    // AFR8
            using AFR9 = Field<4, 4>;    // AFR9
            using AFR10 = Field<8, 4>;    // AFR10
            using AFR11 = Field<12, 4>;    // AFR11
            using AFR12 = Field<16, 4>;    // AFR12
            using AFR13 = Field<20, 4>;    // AFR13
            using AFR14 = Field<24, 4>;    // AFR14
            using AFR15 = Field<28, 4>;    // AFR15
        };

        // GPIO port bit reset register
        struct GPIOC_BRR : public RegisterWriteOnly<0x50004028> {
            using BR0 = Field<0, 1>;    // BR0
            using BR1 = Field<1, 1>;    // BR1
            using BR2 = Field<2, 1>;    // BR2
            using BR3 = Field<3, 1>;    // BR3
            using BR4 = Field<4, 1>;    // BR4
            using BR5 = Field<5, 1>;    // BR5
            using BR6 = Field<6, 1>;    // BR6
            using BR7 = Field<7, 1>;    // BR7
            using BR8 = Field<8, 1>;    // BR8
            using BR9 = Field<9, 1>;    // BR9
            using BR10 = Field<10, 1>;    // BR10
            using BR11 = Field<11, 1>;    // BR11
            using BR12 = Field<12, 1>;    // BR12
            using BR13 = Field<13, 1>;    // BR13
            using BR14 = Field<14, 1>;    // BR14
            using BR15 = Field<15, 1>;    // BR15
        };

        // For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
        struct GPIOC_HWCFGR10 : public RegisterReadOnly<0x500043c8> {
            using AHB_IOP = Field<0, 4>;    // AHB_IOP
            using AF_SIZE = Field<4, 4>;    // AF_SIZE
            using SPEED_CFG = Field<8, 4>;    // SPEED_CFG
            using LOCK_CFG = Field<12, 4>;    // LOCK_CFG
            using SEC_CFG = Field<16, 4>;    // SEC_CFG
            using OR_CFG = Field<20, 4>;    // OR_CFG
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOC_HWCFGR9 : public RegisterReadOnly<0x500043cc> {
            using EN_IO = Field<0, 16>;    // EN_IO
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOC_HWCFGR8 : public RegisterReadOnly<0x500043d0> {
            using AF_PRIO8 = Field<0, 4>;    // AF_PRIO8
            using AF_PRIO9 = Field<4, 4>;    // AF_PRIO9
            using AF_PRIO10 = Field<8, 4>;    // AF_PRIO10
            using AF_PRIO11 = Field<12, 4>;    // AF_PRIO11
            using AF_PRIO12 = Field<16, 4>;    // AF_PRIO12
            using AF_PRIO13 = Field<20, 4>;    // AF_PRIO13
            using AF_PRIO14 = Field<24, 4>;    // AF_PRIO14
            using AF_PRIO15 = Field<28, 4>;    // AF_PRIO15
        };

        // GPIO hardware configuration register 7
        struct GPIOC_HWCFGR7 : public RegisterReadOnly<0x500043d4> {
            using AF_PRIO0 = Field<0, 4>;    // AF_PRIO0
            using AF_PRIO1 = Field<4, 4>;    // AF_PRIO1
            using AF_PRIO2 = Field<8, 4>;    // AF_PRIO2
            using AF_PRIO3 = Field<12, 4>;    // AF_PRIO3
            using AF_PRIO4 = Field<16, 4>;    // AF_PRIO4
            using AF_PRIO5 = Field<20, 4>;    // AF_PRIO5
            using AF_PRIO6 = Field<24, 4>;    // AF_PRIO6
            using AF_PRIO7 = Field<28, 4>;    // AF_PRIO7
        };

        // GPIO hardware configuration register 6
        struct GPIOC_HWCFGR6 : public RegisterReadOnly<0x500043d8> {
            using MODER_RES = Field<0, 32>;    // MODER_RES
        };

        // GPIO hardware configuration register 5
        struct GPIOC_HWCFGR5 : public RegisterReadOnly<0x500043dc> {
            using PUPDR_RES = Field<0, 32>;    // PUPDR_RES
        };

        // GPIO hardware configuration register 4
        struct GPIOC_HWCFGR4 : public RegisterReadOnly<0x500043e0> {
            using OSPEED_RES = Field<0, 32>;    // OSPEED_RES
        };

        // GPIO hardware configuration register 3
        struct GPIOC_HWCFGR3 : public RegisterReadOnly<0x500043e4> {
            using ODR_RES = Field<0, 16>;    // ODR_RES
            using OTYPER_RES = Field<16, 16>;    // OTYPER_RES
        };

        // GPIO hardware configuration register 2
        struct GPIOC_HWCFGR2 : public RegisterReadOnly<0x500043e8> {
            using AFRL_RES = Field<0, 32>;    // AFRL_RES
        };

        // GPIO hardware configuration register 1
        struct GPIOC_HWCFGR1 : public RegisterReadOnly<0x500043ec> {
            using AFRH_RES = Field<0, 32>;    // AFRH_RES
        };

        // GPIO hardware configuration register 0
        struct GPIOC_HWCFGR0 : public RegisterReadOnly<0x500043f0> {
            using OR_RES = Field<0, 16>;    // OR_RES
        };

        // GPIO version register
        struct GPIOC_VERR : public RegisterReadOnly<0x500043f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // GPIO identification register
        struct GPIOC_IPIDR : public RegisterReadOnly<0x500043f8> {
            using IPIDR = Field<0, 32>;    // IPIDR
        };

        // GPIO size identification register
        struct GPIOC_SIDR : public RegisterReadOnly<0x500043fc> {
            using SIDR = Field<0, 32>;    // SIDR
        };

    };

    // GPIOD
    struct GPIOD {
        // GPIO port mode register
        struct GPIOD_MODER : public Register<0x50005000> {
            using MODER0 = Field<0, 2>;    // MODER0
            using MODER1 = Field<2, 2>;    // MODER1
            using MODER2 = Field<4, 2>;    // MODER2
            using MODER3 = Field<6, 2>;    // MODER3
            using MODER4 = Field<8, 2>;    // MODER4
            using MODER5 = Field<10, 2>;    // MODER5
            using MODER6 = Field<12, 2>;    // MODER6
            using MODER7 = Field<14, 2>;    // MODER7
            using MODER8 = Field<16, 2>;    // MODER8
            using MODER9 = Field<18, 2>;    // MODER9
            using MODER10 = Field<20, 2>;    // MODER10
            using MODER11 = Field<22, 2>;    // MODER11
            using MODER12 = Field<24, 2>;    // MODER12
            using MODER13 = Field<26, 2>;    // MODER13
            using MODER14 = Field<28, 2>;    // MODER14
            using MODER15 = Field<30, 2>;    // MODER15
        };

        // GPIO port output type register
        struct GPIOD_OTYPER : public Register<0x50005004> {
            using OT0 = Field<0, 1>;    // OT0
            using OT1 = Field<1, 1>;    // OT1
            using OT2 = Field<2, 1>;    // OT2
            using OT3 = Field<3, 1>;    // OT3
            using OT4 = Field<4, 1>;    // OT4
            using OT5 = Field<5, 1>;    // OT5
            using OT6 = Field<6, 1>;    // OT6
            using OT7 = Field<7, 1>;    // OT7
            using OT8 = Field<8, 1>;    // OT8
            using OT9 = Field<9, 1>;    // OT9
            using OT10 = Field<10, 1>;    // OT10
            using OT11 = Field<11, 1>;    // OT11
            using OT12 = Field<12, 1>;    // OT12
            using OT13 = Field<13, 1>;    // OT13
            using OT14 = Field<14, 1>;    // OT14
            using OT15 = Field<15, 1>;    // OT15
        };

        // GPIO port output speed register
        struct GPIOD_OSPEEDR : public Register<0x50005008> {
            using OSPEEDR0 = Field<0, 2>;    // OSPEEDR0
            using OSPEEDR1 = Field<2, 2>;    // OSPEEDR1
            using OSPEEDR2 = Field<4, 2>;    // OSPEEDR2
            using OSPEEDR3 = Field<6, 2>;    // OSPEEDR3
            using OSPEEDR4 = Field<8, 2>;    // OSPEEDR4
            using OSPEEDR5 = Field<10, 2>;    // OSPEEDR5
            using OSPEEDR6 = Field<12, 2>;    // OSPEEDR6
            using OSPEEDR7 = Field<14, 2>;    // OSPEEDR7
            using OSPEEDR8 = Field<16, 2>;    // OSPEEDR8
            using OSPEEDR9 = Field<18, 2>;    // OSPEEDR9
            using OSPEEDR10 = Field<20, 2>;    // OSPEEDR10
            using OSPEEDR11 = Field<22, 2>;    // OSPEEDR11
            using OSPEEDR12 = Field<24, 2>;    // OSPEEDR12
            using OSPEEDR13 = Field<26, 2>;    // OSPEEDR13
            using OSPEEDR14 = Field<28, 2>;    // OSPEEDR14
            using OSPEEDR15 = Field<30, 2>;    // OSPEEDR15
        };

        // GPIO port pull-up/pull-down register
        struct GPIOD_PUPDR : public Register<0x5000500c> {
            using PUPDR0 = Field<0, 2>;    // PUPDR0
            using PUPDR1 = Field<2, 2>;    // PUPDR1
            using PUPDR2 = Field<4, 2>;    // PUPDR2
            using PUPDR3 = Field<6, 2>;    // PUPDR3
            using PUPDR4 = Field<8, 2>;    // PUPDR4
            using PUPDR5 = Field<10, 2>;    // PUPDR5
            using PUPDR6 = Field<12, 2>;    // PUPDR6
            using PUPDR7 = Field<14, 2>;    // PUPDR7
            using PUPDR8 = Field<16, 2>;    // PUPDR8
            using PUPDR9 = Field<18, 2>;    // PUPDR9
            using PUPDR10 = Field<20, 2>;    // PUPDR10
            using PUPDR11 = Field<22, 2>;    // PUPDR11
            using PUPDR12 = Field<24, 2>;    // PUPDR12
            using PUPDR13 = Field<26, 2>;    // PUPDR13
            using PUPDR14 = Field<28, 2>;    // PUPDR14
            using PUPDR15 = Field<30, 2>;    // PUPDR15
        };

        // GPIO port input data register
        struct GPIOD_IDR : public RegisterReadOnly<0x50005010> {
            using IDR0 = Field<0, 1>;    // IDR0
            using IDR1 = Field<1, 1>;    // IDR1
            using IDR2 = Field<2, 1>;    // IDR2
            using IDR3 = Field<3, 1>;    // IDR3
            using IDR4 = Field<4, 1>;    // IDR4
            using IDR5 = Field<5, 1>;    // IDR5
            using IDR6 = Field<6, 1>;    // IDR6
            using IDR7 = Field<7, 1>;    // IDR7
            using IDR8 = Field<8, 1>;    // IDR8
            using IDR9 = Field<9, 1>;    // IDR9
            using IDR10 = Field<10, 1>;    // IDR10
            using IDR11 = Field<11, 1>;    // IDR11
            using IDR12 = Field<12, 1>;    // IDR12
            using IDR13 = Field<13, 1>;    // IDR13
            using IDR14 = Field<14, 1>;    // IDR14
            using IDR15 = Field<15, 1>;    // IDR15
        };

        // GPIO port output data register
        struct GPIOD_ODR : public Register<0x50005014> {
            using ODR0 = Field<0, 1>;    // ODR0
            using ODR1 = Field<1, 1>;    // ODR1
            using ODR2 = Field<2, 1>;    // ODR2
            using ODR3 = Field<3, 1>;    // ODR3
            using ODR4 = Field<4, 1>;    // ODR4
            using ODR5 = Field<5, 1>;    // ODR5
            using ODR6 = Field<6, 1>;    // ODR6
            using ODR7 = Field<7, 1>;    // ODR7
            using ODR8 = Field<8, 1>;    // ODR8
            using ODR9 = Field<9, 1>;    // ODR9
            using ODR10 = Field<10, 1>;    // ODR10
            using ODR11 = Field<11, 1>;    // ODR11
            using ODR12 = Field<12, 1>;    // ODR12
            using ODR13 = Field<13, 1>;    // ODR13
            using ODR14 = Field<14, 1>;    // ODR14
            using ODR15 = Field<15, 1>;    // ODR15
        };

        // GPIO port bit set/reset register
        struct GPIOD_BSRR : public RegisterWriteOnly<0x50005018> {
            using BS0 = Field<0, 1>;    // BS0
            using BS1 = Field<1, 1>;    // BS1
            using BS2 = Field<2, 1>;    // BS2
            using BS3 = Field<3, 1>;    // BS3
            using BS4 = Field<4, 1>;    // BS4
            using BS5 = Field<5, 1>;    // BS5
            using BS6 = Field<6, 1>;    // BS6
            using BS7 = Field<7, 1>;    // BS7
            using BS8 = Field<8, 1>;    // BS8
            using BS9 = Field<9, 1>;    // BS9
            using BS10 = Field<10, 1>;    // BS10
            using BS11 = Field<11, 1>;    // BS11
            using BS12 = Field<12, 1>;    // BS12
            using BS13 = Field<13, 1>;    // BS13
            using BS14 = Field<14, 1>;    // BS14
            using BS15 = Field<15, 1>;    // BS15
            using BR0 = Field<16, 1>;    // BR0
            using BR1 = Field<17, 1>;    // BR1
            using BR2 = Field<18, 1>;    // BR2
            using BR3 = Field<19, 1>;    // BR3
            using BR4 = Field<20, 1>;    // BR4
            using BR5 = Field<21, 1>;    // BR5
            using BR6 = Field<22, 1>;    // BR6
            using BR7 = Field<23, 1>;    // BR7
            using BR8 = Field<24, 1>;    // BR8
            using BR9 = Field<25, 1>;    // BR9
            using BR10 = Field<26, 1>;    // BR10
            using BR11 = Field<27, 1>;    // BR11
            using BR12 = Field<28, 1>;    // BR12
            using BR13 = Field<29, 1>;    // BR13
            using BR14 = Field<30, 1>;    // BR14
            using BR15 = Field<31, 1>;    // BR15
        };

        // This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
        struct GPIOD_LCKR : public Register<0x5000501c> {
            using LCK0 = Field<0, 1>;    // LCK0
            using LCK1 = Field<1, 1>;    // LCK1
            using LCK2 = Field<2, 1>;    // LCK2
            using LCK3 = Field<3, 1>;    // LCK3
            using LCK4 = Field<4, 1>;    // LCK4
            using LCK5 = Field<5, 1>;    // LCK5
            using LCK6 = Field<6, 1>;    // LCK6
            using LCK7 = Field<7, 1>;    // LCK7
            using LCK8 = Field<8, 1>;    // LCK8
            using LCK9 = Field<9, 1>;    // LCK9
            using LCK10 = Field<10, 1>;    // LCK10
            using LCK11 = Field<11, 1>;    // LCK11
            using LCK12 = Field<12, 1>;    // LCK12
            using LCK13 = Field<13, 1>;    // LCK13
            using LCK14 = Field<14, 1>;    // LCK14
            using LCK15 = Field<15, 1>;    // LCK15
            using LCKK = Field<16, 1>;    // LCKK
        };

        // GPIO alternate function low register
        struct GPIOD_AFRL : public Register<0x50005020> {
            using AFR0 = Field<0, 4>;    // AFR0
            using AFR1 = Field<4, 4>;    // AFR1
            using AFR2 = Field<8, 4>;    // AFR2
            using AFR3 = Field<12, 4>;    // AFR3
            using AFR4 = Field<16, 4>;    // AFR4
            using AFR5 = Field<20, 4>;    // AFR5
            using AFR6 = Field<24, 4>;    // AFR6
            using AFR7 = Field<28, 4>;    // AFR7
        };

        // GPIO alternate function high register
        struct GPIOD_AFRH : public Register<0x50005024> {
            using AFR8 = Field<0, 4>;    // AFR8
            using AFR9 = Field<4, 4>;    // AFR9
            using AFR10 = Field<8, 4>;    // AFR10
            using AFR11 = Field<12, 4>;    // AFR11
            using AFR12 = Field<16, 4>;    // AFR12
            using AFR13 = Field<20, 4>;    // AFR13
            using AFR14 = Field<24, 4>;    // AFR14
            using AFR15 = Field<28, 4>;    // AFR15
        };

        // GPIO port bit reset register
        struct GPIOD_BRR : public RegisterWriteOnly<0x50005028> {
            using BR0 = Field<0, 1>;    // BR0
            using BR1 = Field<1, 1>;    // BR1
            using BR2 = Field<2, 1>;    // BR2
            using BR3 = Field<3, 1>;    // BR3
            using BR4 = Field<4, 1>;    // BR4
            using BR5 = Field<5, 1>;    // BR5
            using BR6 = Field<6, 1>;    // BR6
            using BR7 = Field<7, 1>;    // BR7
            using BR8 = Field<8, 1>;    // BR8
            using BR9 = Field<9, 1>;    // BR9
            using BR10 = Field<10, 1>;    // BR10
            using BR11 = Field<11, 1>;    // BR11
            using BR12 = Field<12, 1>;    // BR12
            using BR13 = Field<13, 1>;    // BR13
            using BR14 = Field<14, 1>;    // BR14
            using BR15 = Field<15, 1>;    // BR15
        };

        // For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
        struct GPIOD_HWCFGR10 : public RegisterReadOnly<0x500053c8> {
            using AHB_IOP = Field<0, 4>;    // AHB_IOP
            using AF_SIZE = Field<4, 4>;    // AF_SIZE
            using SPEED_CFG = Field<8, 4>;    // SPEED_CFG
            using LOCK_CFG = Field<12, 4>;    // LOCK_CFG
            using SEC_CFG = Field<16, 4>;    // SEC_CFG
            using OR_CFG = Field<20, 4>;    // OR_CFG
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOD_HWCFGR9 : public RegisterReadOnly<0x500053cc> {
            using EN_IO = Field<0, 16>;    // EN_IO
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOD_HWCFGR8 : public RegisterReadOnly<0x500053d0> {
            using AF_PRIO8 = Field<0, 4>;    // AF_PRIO8
            using AF_PRIO9 = Field<4, 4>;    // AF_PRIO9
            using AF_PRIO10 = Field<8, 4>;    // AF_PRIO10
            using AF_PRIO11 = Field<12, 4>;    // AF_PRIO11
            using AF_PRIO12 = Field<16, 4>;    // AF_PRIO12
            using AF_PRIO13 = Field<20, 4>;    // AF_PRIO13
            using AF_PRIO14 = Field<24, 4>;    // AF_PRIO14
            using AF_PRIO15 = Field<28, 4>;    // AF_PRIO15
        };

        // GPIO hardware configuration register 7
        struct GPIOD_HWCFGR7 : public RegisterReadOnly<0x500053d4> {
            using AF_PRIO0 = Field<0, 4>;    // AF_PRIO0
            using AF_PRIO1 = Field<4, 4>;    // AF_PRIO1
            using AF_PRIO2 = Field<8, 4>;    // AF_PRIO2
            using AF_PRIO3 = Field<12, 4>;    // AF_PRIO3
            using AF_PRIO4 = Field<16, 4>;    // AF_PRIO4
            using AF_PRIO5 = Field<20, 4>;    // AF_PRIO5
            using AF_PRIO6 = Field<24, 4>;    // AF_PRIO6
            using AF_PRIO7 = Field<28, 4>;    // AF_PRIO7
        };

        // GPIO hardware configuration register 6
        struct GPIOD_HWCFGR6 : public RegisterReadOnly<0x500053d8> {
            using MODER_RES = Field<0, 32>;    // MODER_RES
        };

        // GPIO hardware configuration register 5
        struct GPIOD_HWCFGR5 : public RegisterReadOnly<0x500053dc> {
            using PUPDR_RES = Field<0, 32>;    // PUPDR_RES
        };

        // GPIO hardware configuration register 4
        struct GPIOD_HWCFGR4 : public RegisterReadOnly<0x500053e0> {
            using OSPEED_RES = Field<0, 32>;    // OSPEED_RES
        };

        // GPIO hardware configuration register 3
        struct GPIOD_HWCFGR3 : public RegisterReadOnly<0x500053e4> {
            using ODR_RES = Field<0, 16>;    // ODR_RES
            using OTYPER_RES = Field<16, 16>;    // OTYPER_RES
        };

        // GPIO hardware configuration register 2
        struct GPIOD_HWCFGR2 : public RegisterReadOnly<0x500053e8> {
            using AFRL_RES = Field<0, 32>;    // AFRL_RES
        };

        // GPIO hardware configuration register 1
        struct GPIOD_HWCFGR1 : public RegisterReadOnly<0x500053ec> {
            using AFRH_RES = Field<0, 32>;    // AFRH_RES
        };

        // GPIO hardware configuration register 0
        struct GPIOD_HWCFGR0 : public RegisterReadOnly<0x500053f0> {
            using OR_RES = Field<0, 16>;    // OR_RES
        };

        // GPIO version register
        struct GPIOD_VERR : public RegisterReadOnly<0x500053f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // GPIO identification register
        struct GPIOD_IPIDR : public RegisterReadOnly<0x500053f8> {
            using IPIDR = Field<0, 32>;    // IPIDR
        };

        // GPIO size identification register
        struct GPIOD_SIDR : public RegisterReadOnly<0x500053fc> {
            using SIDR = Field<0, 32>;    // SIDR
        };

    };

    // GPIOE
    struct GPIOE {
        // GPIO port mode register
        struct GPIOE_MODER : public Register<0x50006000> {
            using MODER0 = Field<0, 2>;    // MODER0
            using MODER1 = Field<2, 2>;    // MODER1
            using MODER2 = Field<4, 2>;    // MODER2
            using MODER3 = Field<6, 2>;    // MODER3
            using MODER4 = Field<8, 2>;    // MODER4
            using MODER5 = Field<10, 2>;    // MODER5
            using MODER6 = Field<12, 2>;    // MODER6
            using MODER7 = Field<14, 2>;    // MODER7
            using MODER8 = Field<16, 2>;    // MODER8
            using MODER9 = Field<18, 2>;    // MODER9
            using MODER10 = Field<20, 2>;    // MODER10
            using MODER11 = Field<22, 2>;    // MODER11
            using MODER12 = Field<24, 2>;    // MODER12
            using MODER13 = Field<26, 2>;    // MODER13
            using MODER14 = Field<28, 2>;    // MODER14
            using MODER15 = Field<30, 2>;    // MODER15
        };

        // GPIO port output type register
        struct GPIOE_OTYPER : public Register<0x50006004> {
            using OT0 = Field<0, 1>;    // OT0
            using OT1 = Field<1, 1>;    // OT1
            using OT2 = Field<2, 1>;    // OT2
            using OT3 = Field<3, 1>;    // OT3
            using OT4 = Field<4, 1>;    // OT4
            using OT5 = Field<5, 1>;    // OT5
            using OT6 = Field<6, 1>;    // OT6
            using OT7 = Field<7, 1>;    // OT7
            using OT8 = Field<8, 1>;    // OT8
            using OT9 = Field<9, 1>;    // OT9
            using OT10 = Field<10, 1>;    // OT10
            using OT11 = Field<11, 1>;    // OT11
            using OT12 = Field<12, 1>;    // OT12
            using OT13 = Field<13, 1>;    // OT13
            using OT14 = Field<14, 1>;    // OT14
            using OT15 = Field<15, 1>;    // OT15
        };

        // GPIO port output speed register
        struct GPIOE_OSPEEDR : public Register<0x50006008> {
            using OSPEEDR0 = Field<0, 2>;    // OSPEEDR0
            using OSPEEDR1 = Field<2, 2>;    // OSPEEDR1
            using OSPEEDR2 = Field<4, 2>;    // OSPEEDR2
            using OSPEEDR3 = Field<6, 2>;    // OSPEEDR3
            using OSPEEDR4 = Field<8, 2>;    // OSPEEDR4
            using OSPEEDR5 = Field<10, 2>;    // OSPEEDR5
            using OSPEEDR6 = Field<12, 2>;    // OSPEEDR6
            using OSPEEDR7 = Field<14, 2>;    // OSPEEDR7
            using OSPEEDR8 = Field<16, 2>;    // OSPEEDR8
            using OSPEEDR9 = Field<18, 2>;    // OSPEEDR9
            using OSPEEDR10 = Field<20, 2>;    // OSPEEDR10
            using OSPEEDR11 = Field<22, 2>;    // OSPEEDR11
            using OSPEEDR12 = Field<24, 2>;    // OSPEEDR12
            using OSPEEDR13 = Field<26, 2>;    // OSPEEDR13
            using OSPEEDR14 = Field<28, 2>;    // OSPEEDR14
            using OSPEEDR15 = Field<30, 2>;    // OSPEEDR15
        };

        // GPIO port pull-up/pull-down register
        struct GPIOE_PUPDR : public Register<0x5000600c> {
            using PUPDR0 = Field<0, 2>;    // PUPDR0
            using PUPDR1 = Field<2, 2>;    // PUPDR1
            using PUPDR2 = Field<4, 2>;    // PUPDR2
            using PUPDR3 = Field<6, 2>;    // PUPDR3
            using PUPDR4 = Field<8, 2>;    // PUPDR4
            using PUPDR5 = Field<10, 2>;    // PUPDR5
            using PUPDR6 = Field<12, 2>;    // PUPDR6
            using PUPDR7 = Field<14, 2>;    // PUPDR7
            using PUPDR8 = Field<16, 2>;    // PUPDR8
            using PUPDR9 = Field<18, 2>;    // PUPDR9
            using PUPDR10 = Field<20, 2>;    // PUPDR10
            using PUPDR11 = Field<22, 2>;    // PUPDR11
            using PUPDR12 = Field<24, 2>;    // PUPDR12
            using PUPDR13 = Field<26, 2>;    // PUPDR13
            using PUPDR14 = Field<28, 2>;    // PUPDR14
            using PUPDR15 = Field<30, 2>;    // PUPDR15
        };

        // GPIO port input data register
        struct GPIOE_IDR : public RegisterReadOnly<0x50006010> {
            using IDR0 = Field<0, 1>;    // IDR0
            using IDR1 = Field<1, 1>;    // IDR1
            using IDR2 = Field<2, 1>;    // IDR2
            using IDR3 = Field<3, 1>;    // IDR3
            using IDR4 = Field<4, 1>;    // IDR4
            using IDR5 = Field<5, 1>;    // IDR5
            using IDR6 = Field<6, 1>;    // IDR6
            using IDR7 = Field<7, 1>;    // IDR7
            using IDR8 = Field<8, 1>;    // IDR8
            using IDR9 = Field<9, 1>;    // IDR9
            using IDR10 = Field<10, 1>;    // IDR10
            using IDR11 = Field<11, 1>;    // IDR11
            using IDR12 = Field<12, 1>;    // IDR12
            using IDR13 = Field<13, 1>;    // IDR13
            using IDR14 = Field<14, 1>;    // IDR14
            using IDR15 = Field<15, 1>;    // IDR15
        };

        // GPIO port output data register
        struct GPIOE_ODR : public Register<0x50006014> {
            using ODR0 = Field<0, 1>;    // ODR0
            using ODR1 = Field<1, 1>;    // ODR1
            using ODR2 = Field<2, 1>;    // ODR2
            using ODR3 = Field<3, 1>;    // ODR3
            using ODR4 = Field<4, 1>;    // ODR4
            using ODR5 = Field<5, 1>;    // ODR5
            using ODR6 = Field<6, 1>;    // ODR6
            using ODR7 = Field<7, 1>;    // ODR7
            using ODR8 = Field<8, 1>;    // ODR8
            using ODR9 = Field<9, 1>;    // ODR9
            using ODR10 = Field<10, 1>;    // ODR10
            using ODR11 = Field<11, 1>;    // ODR11
            using ODR12 = Field<12, 1>;    // ODR12
            using ODR13 = Field<13, 1>;    // ODR13
            using ODR14 = Field<14, 1>;    // ODR14
            using ODR15 = Field<15, 1>;    // ODR15
        };

        // GPIO port bit set/reset register
        struct GPIOE_BSRR : public RegisterWriteOnly<0x50006018> {
            using BS0 = Field<0, 1>;    // BS0
            using BS1 = Field<1, 1>;    // BS1
            using BS2 = Field<2, 1>;    // BS2
            using BS3 = Field<3, 1>;    // BS3
            using BS4 = Field<4, 1>;    // BS4
            using BS5 = Field<5, 1>;    // BS5
            using BS6 = Field<6, 1>;    // BS6
            using BS7 = Field<7, 1>;    // BS7
            using BS8 = Field<8, 1>;    // BS8
            using BS9 = Field<9, 1>;    // BS9
            using BS10 = Field<10, 1>;    // BS10
            using BS11 = Field<11, 1>;    // BS11
            using BS12 = Field<12, 1>;    // BS12
            using BS13 = Field<13, 1>;    // BS13
            using BS14 = Field<14, 1>;    // BS14
            using BS15 = Field<15, 1>;    // BS15
            using BR0 = Field<16, 1>;    // BR0
            using BR1 = Field<17, 1>;    // BR1
            using BR2 = Field<18, 1>;    // BR2
            using BR3 = Field<19, 1>;    // BR3
            using BR4 = Field<20, 1>;    // BR4
            using BR5 = Field<21, 1>;    // BR5
            using BR6 = Field<22, 1>;    // BR6
            using BR7 = Field<23, 1>;    // BR7
            using BR8 = Field<24, 1>;    // BR8
            using BR9 = Field<25, 1>;    // BR9
            using BR10 = Field<26, 1>;    // BR10
            using BR11 = Field<27, 1>;    // BR11
            using BR12 = Field<28, 1>;    // BR12
            using BR13 = Field<29, 1>;    // BR13
            using BR14 = Field<30, 1>;    // BR14
            using BR15 = Field<31, 1>;    // BR15
        };

        // This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
        struct GPIOE_LCKR : public Register<0x5000601c> {
            using LCK0 = Field<0, 1>;    // LCK0
            using LCK1 = Field<1, 1>;    // LCK1
            using LCK2 = Field<2, 1>;    // LCK2
            using LCK3 = Field<3, 1>;    // LCK3
            using LCK4 = Field<4, 1>;    // LCK4
            using LCK5 = Field<5, 1>;    // LCK5
            using LCK6 = Field<6, 1>;    // LCK6
            using LCK7 = Field<7, 1>;    // LCK7
            using LCK8 = Field<8, 1>;    // LCK8
            using LCK9 = Field<9, 1>;    // LCK9
            using LCK10 = Field<10, 1>;    // LCK10
            using LCK11 = Field<11, 1>;    // LCK11
            using LCK12 = Field<12, 1>;    // LCK12
            using LCK13 = Field<13, 1>;    // LCK13
            using LCK14 = Field<14, 1>;    // LCK14
            using LCK15 = Field<15, 1>;    // LCK15
            using LCKK = Field<16, 1>;    // LCKK
        };

        // GPIO alternate function low register
        struct GPIOE_AFRL : public Register<0x50006020> {
            using AFR0 = Field<0, 4>;    // AFR0
            using AFR1 = Field<4, 4>;    // AFR1
            using AFR2 = Field<8, 4>;    // AFR2
            using AFR3 = Field<12, 4>;    // AFR3
            using AFR4 = Field<16, 4>;    // AFR4
            using AFR5 = Field<20, 4>;    // AFR5
            using AFR6 = Field<24, 4>;    // AFR6
            using AFR7 = Field<28, 4>;    // AFR7
        };

        // GPIO alternate function high register
        struct GPIOE_AFRH : public Register<0x50006024> {
            using AFR8 = Field<0, 4>;    // AFR8
            using AFR9 = Field<4, 4>;    // AFR9
            using AFR10 = Field<8, 4>;    // AFR10
            using AFR11 = Field<12, 4>;    // AFR11
            using AFR12 = Field<16, 4>;    // AFR12
            using AFR13 = Field<20, 4>;    // AFR13
            using AFR14 = Field<24, 4>;    // AFR14
            using AFR15 = Field<28, 4>;    // AFR15
        };

        // GPIO port bit reset register
        struct GPIOE_BRR : public RegisterWriteOnly<0x50006028> {
            using BR0 = Field<0, 1>;    // BR0
            using BR1 = Field<1, 1>;    // BR1
            using BR2 = Field<2, 1>;    // BR2
            using BR3 = Field<3, 1>;    // BR3
            using BR4 = Field<4, 1>;    // BR4
            using BR5 = Field<5, 1>;    // BR5
            using BR6 = Field<6, 1>;    // BR6
            using BR7 = Field<7, 1>;    // BR7
            using BR8 = Field<8, 1>;    // BR8
            using BR9 = Field<9, 1>;    // BR9
            using BR10 = Field<10, 1>;    // BR10
            using BR11 = Field<11, 1>;    // BR11
            using BR12 = Field<12, 1>;    // BR12
            using BR13 = Field<13, 1>;    // BR13
            using BR14 = Field<14, 1>;    // BR14
            using BR15 = Field<15, 1>;    // BR15
        };

        // For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
        struct GPIOE_HWCFGR10 : public RegisterReadOnly<0x500063c8> {
            using AHB_IOP = Field<0, 4>;    // AHB_IOP
            using AF_SIZE = Field<4, 4>;    // AF_SIZE
            using SPEED_CFG = Field<8, 4>;    // SPEED_CFG
            using LOCK_CFG = Field<12, 4>;    // LOCK_CFG
            using SEC_CFG = Field<16, 4>;    // SEC_CFG
            using OR_CFG = Field<20, 4>;    // OR_CFG
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOE_HWCFGR9 : public RegisterReadOnly<0x500063cc> {
            using EN_IO = Field<0, 16>;    // EN_IO
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOE_HWCFGR8 : public RegisterReadOnly<0x500063d0> {
            using AF_PRIO8 = Field<0, 4>;    // AF_PRIO8
            using AF_PRIO9 = Field<4, 4>;    // AF_PRIO9
            using AF_PRIO10 = Field<8, 4>;    // AF_PRIO10
            using AF_PRIO11 = Field<12, 4>;    // AF_PRIO11
            using AF_PRIO12 = Field<16, 4>;    // AF_PRIO12
            using AF_PRIO13 = Field<20, 4>;    // AF_PRIO13
            using AF_PRIO14 = Field<24, 4>;    // AF_PRIO14
            using AF_PRIO15 = Field<28, 4>;    // AF_PRIO15
        };

        // GPIO hardware configuration register 7
        struct GPIOE_HWCFGR7 : public RegisterReadOnly<0x500063d4> {
            using AF_PRIO0 = Field<0, 4>;    // AF_PRIO0
            using AF_PRIO1 = Field<4, 4>;    // AF_PRIO1
            using AF_PRIO2 = Field<8, 4>;    // AF_PRIO2
            using AF_PRIO3 = Field<12, 4>;    // AF_PRIO3
            using AF_PRIO4 = Field<16, 4>;    // AF_PRIO4
            using AF_PRIO5 = Field<20, 4>;    // AF_PRIO5
            using AF_PRIO6 = Field<24, 4>;    // AF_PRIO6
            using AF_PRIO7 = Field<28, 4>;    // AF_PRIO7
        };

        // GPIO hardware configuration register 6
        struct GPIOE_HWCFGR6 : public RegisterReadOnly<0x500063d8> {
            using MODER_RES = Field<0, 32>;    // MODER_RES
        };

        // GPIO hardware configuration register 5
        struct GPIOE_HWCFGR5 : public RegisterReadOnly<0x500063dc> {
            using PUPDR_RES = Field<0, 32>;    // PUPDR_RES
        };

        // GPIO hardware configuration register 4
        struct GPIOE_HWCFGR4 : public RegisterReadOnly<0x500063e0> {
            using OSPEED_RES = Field<0, 32>;    // OSPEED_RES
        };

        // GPIO hardware configuration register 3
        struct GPIOE_HWCFGR3 : public RegisterReadOnly<0x500063e4> {
            using ODR_RES = Field<0, 16>;    // ODR_RES
            using OTYPER_RES = Field<16, 16>;    // OTYPER_RES
        };

        // GPIO hardware configuration register 2
        struct GPIOE_HWCFGR2 : public RegisterReadOnly<0x500063e8> {
            using AFRL_RES = Field<0, 32>;    // AFRL_RES
        };

        // GPIO hardware configuration register 1
        struct GPIOE_HWCFGR1 : public RegisterReadOnly<0x500063ec> {
            using AFRH_RES = Field<0, 32>;    // AFRH_RES
        };

        // GPIO hardware configuration register 0
        struct GPIOE_HWCFGR0 : public RegisterReadOnly<0x500063f0> {
            using OR_RES = Field<0, 16>;    // OR_RES
        };

        // GPIO version register
        struct GPIOE_VERR : public RegisterReadOnly<0x500063f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // GPIO identification register
        struct GPIOE_IPIDR : public RegisterReadOnly<0x500063f8> {
            using IPIDR = Field<0, 32>;    // IPIDR
        };

        // GPIO size identification register
        struct GPIOE_SIDR : public RegisterReadOnly<0x500063fc> {
            using SIDR = Field<0, 32>;    // SIDR
        };

    };

    // GPIOF
    struct GPIOF {
        // GPIO port mode register
        struct GPIOF_MODER : public Register<0x50007000> {
            using MODER0 = Field<0, 2>;    // MODER0
            using MODER1 = Field<2, 2>;    // MODER1
            using MODER2 = Field<4, 2>;    // MODER2
            using MODER3 = Field<6, 2>;    // MODER3
            using MODER4 = Field<8, 2>;    // MODER4
            using MODER5 = Field<10, 2>;    // MODER5
            using MODER6 = Field<12, 2>;    // MODER6
            using MODER7 = Field<14, 2>;    // MODER7
            using MODER8 = Field<16, 2>;    // MODER8
            using MODER9 = Field<18, 2>;    // MODER9
            using MODER10 = Field<20, 2>;    // MODER10
            using MODER11 = Field<22, 2>;    // MODER11
            using MODER12 = Field<24, 2>;    // MODER12
            using MODER13 = Field<26, 2>;    // MODER13
            using MODER14 = Field<28, 2>;    // MODER14
            using MODER15 = Field<30, 2>;    // MODER15
        };

        // GPIO port output type register
        struct GPIOF_OTYPER : public Register<0x50007004> {
            using OT0 = Field<0, 1>;    // OT0
            using OT1 = Field<1, 1>;    // OT1
            using OT2 = Field<2, 1>;    // OT2
            using OT3 = Field<3, 1>;    // OT3
            using OT4 = Field<4, 1>;    // OT4
            using OT5 = Field<5, 1>;    // OT5
            using OT6 = Field<6, 1>;    // OT6
            using OT7 = Field<7, 1>;    // OT7
            using OT8 = Field<8, 1>;    // OT8
            using OT9 = Field<9, 1>;    // OT9
            using OT10 = Field<10, 1>;    // OT10
            using OT11 = Field<11, 1>;    // OT11
            using OT12 = Field<12, 1>;    // OT12
            using OT13 = Field<13, 1>;    // OT13
            using OT14 = Field<14, 1>;    // OT14
            using OT15 = Field<15, 1>;    // OT15
        };

        // GPIO port output speed register
        struct GPIOF_OSPEEDR : public Register<0x50007008> {
            using OSPEEDR0 = Field<0, 2>;    // OSPEEDR0
            using OSPEEDR1 = Field<2, 2>;    // OSPEEDR1
            using OSPEEDR2 = Field<4, 2>;    // OSPEEDR2
            using OSPEEDR3 = Field<6, 2>;    // OSPEEDR3
            using OSPEEDR4 = Field<8, 2>;    // OSPEEDR4
            using OSPEEDR5 = Field<10, 2>;    // OSPEEDR5
            using OSPEEDR6 = Field<12, 2>;    // OSPEEDR6
            using OSPEEDR7 = Field<14, 2>;    // OSPEEDR7
            using OSPEEDR8 = Field<16, 2>;    // OSPEEDR8
            using OSPEEDR9 = Field<18, 2>;    // OSPEEDR9
            using OSPEEDR10 = Field<20, 2>;    // OSPEEDR10
            using OSPEEDR11 = Field<22, 2>;    // OSPEEDR11
            using OSPEEDR12 = Field<24, 2>;    // OSPEEDR12
            using OSPEEDR13 = Field<26, 2>;    // OSPEEDR13
            using OSPEEDR14 = Field<28, 2>;    // OSPEEDR14
            using OSPEEDR15 = Field<30, 2>;    // OSPEEDR15
        };

        // GPIO port pull-up/pull-down register
        struct GPIOF_PUPDR : public Register<0x5000700c> {
            using PUPDR0 = Field<0, 2>;    // PUPDR0
            using PUPDR1 = Field<2, 2>;    // PUPDR1
            using PUPDR2 = Field<4, 2>;    // PUPDR2
            using PUPDR3 = Field<6, 2>;    // PUPDR3
            using PUPDR4 = Field<8, 2>;    // PUPDR4
            using PUPDR5 = Field<10, 2>;    // PUPDR5
            using PUPDR6 = Field<12, 2>;    // PUPDR6
            using PUPDR7 = Field<14, 2>;    // PUPDR7
            using PUPDR8 = Field<16, 2>;    // PUPDR8
            using PUPDR9 = Field<18, 2>;    // PUPDR9
            using PUPDR10 = Field<20, 2>;    // PUPDR10
            using PUPDR11 = Field<22, 2>;    // PUPDR11
            using PUPDR12 = Field<24, 2>;    // PUPDR12
            using PUPDR13 = Field<26, 2>;    // PUPDR13
            using PUPDR14 = Field<28, 2>;    // PUPDR14
            using PUPDR15 = Field<30, 2>;    // PUPDR15
        };

        // GPIO port input data register
        struct GPIOF_IDR : public RegisterReadOnly<0x50007010> {
            using IDR0 = Field<0, 1>;    // IDR0
            using IDR1 = Field<1, 1>;    // IDR1
            using IDR2 = Field<2, 1>;    // IDR2
            using IDR3 = Field<3, 1>;    // IDR3
            using IDR4 = Field<4, 1>;    // IDR4
            using IDR5 = Field<5, 1>;    // IDR5
            using IDR6 = Field<6, 1>;    // IDR6
            using IDR7 = Field<7, 1>;    // IDR7
            using IDR8 = Field<8, 1>;    // IDR8
            using IDR9 = Field<9, 1>;    // IDR9
            using IDR10 = Field<10, 1>;    // IDR10
            using IDR11 = Field<11, 1>;    // IDR11
            using IDR12 = Field<12, 1>;    // IDR12
            using IDR13 = Field<13, 1>;    // IDR13
            using IDR14 = Field<14, 1>;    // IDR14
            using IDR15 = Field<15, 1>;    // IDR15
        };

        // GPIO port output data register
        struct GPIOF_ODR : public Register<0x50007014> {
            using ODR0 = Field<0, 1>;    // ODR0
            using ODR1 = Field<1, 1>;    // ODR1
            using ODR2 = Field<2, 1>;    // ODR2
            using ODR3 = Field<3, 1>;    // ODR3
            using ODR4 = Field<4, 1>;    // ODR4
            using ODR5 = Field<5, 1>;    // ODR5
            using ODR6 = Field<6, 1>;    // ODR6
            using ODR7 = Field<7, 1>;    // ODR7
            using ODR8 = Field<8, 1>;    // ODR8
            using ODR9 = Field<9, 1>;    // ODR9
            using ODR10 = Field<10, 1>;    // ODR10
            using ODR11 = Field<11, 1>;    // ODR11
            using ODR12 = Field<12, 1>;    // ODR12
            using ODR13 = Field<13, 1>;    // ODR13
            using ODR14 = Field<14, 1>;    // ODR14
            using ODR15 = Field<15, 1>;    // ODR15
        };

        // GPIO port bit set/reset register
        struct GPIOF_BSRR : public RegisterWriteOnly<0x50007018> {
            using BS0 = Field<0, 1>;    // BS0
            using BS1 = Field<1, 1>;    // BS1
            using BS2 = Field<2, 1>;    // BS2
            using BS3 = Field<3, 1>;    // BS3
            using BS4 = Field<4, 1>;    // BS4
            using BS5 = Field<5, 1>;    // BS5
            using BS6 = Field<6, 1>;    // BS6
            using BS7 = Field<7, 1>;    // BS7
            using BS8 = Field<8, 1>;    // BS8
            using BS9 = Field<9, 1>;    // BS9
            using BS10 = Field<10, 1>;    // BS10
            using BS11 = Field<11, 1>;    // BS11
            using BS12 = Field<12, 1>;    // BS12
            using BS13 = Field<13, 1>;    // BS13
            using BS14 = Field<14, 1>;    // BS14
            using BS15 = Field<15, 1>;    // BS15
            using BR0 = Field<16, 1>;    // BR0
            using BR1 = Field<17, 1>;    // BR1
            using BR2 = Field<18, 1>;    // BR2
            using BR3 = Field<19, 1>;    // BR3
            using BR4 = Field<20, 1>;    // BR4
            using BR5 = Field<21, 1>;    // BR5
            using BR6 = Field<22, 1>;    // BR6
            using BR7 = Field<23, 1>;    // BR7
            using BR8 = Field<24, 1>;    // BR8
            using BR9 = Field<25, 1>;    // BR9
            using BR10 = Field<26, 1>;    // BR10
            using BR11 = Field<27, 1>;    // BR11
            using BR12 = Field<28, 1>;    // BR12
            using BR13 = Field<29, 1>;    // BR13
            using BR14 = Field<30, 1>;    // BR14
            using BR15 = Field<31, 1>;    // BR15
        };

        // This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
        struct GPIOF_LCKR : public Register<0x5000701c> {
            using LCK0 = Field<0, 1>;    // LCK0
            using LCK1 = Field<1, 1>;    // LCK1
            using LCK2 = Field<2, 1>;    // LCK2
            using LCK3 = Field<3, 1>;    // LCK3
            using LCK4 = Field<4, 1>;    // LCK4
            using LCK5 = Field<5, 1>;    // LCK5
            using LCK6 = Field<6, 1>;    // LCK6
            using LCK7 = Field<7, 1>;    // LCK7
            using LCK8 = Field<8, 1>;    // LCK8
            using LCK9 = Field<9, 1>;    // LCK9
            using LCK10 = Field<10, 1>;    // LCK10
            using LCK11 = Field<11, 1>;    // LCK11
            using LCK12 = Field<12, 1>;    // LCK12
            using LCK13 = Field<13, 1>;    // LCK13
            using LCK14 = Field<14, 1>;    // LCK14
            using LCK15 = Field<15, 1>;    // LCK15
            using LCKK = Field<16, 1>;    // LCKK
        };

        // GPIO alternate function low register
        struct GPIOF_AFRL : public Register<0x50007020> {
            using AFR0 = Field<0, 4>;    // AFR0
            using AFR1 = Field<4, 4>;    // AFR1
            using AFR2 = Field<8, 4>;    // AFR2
            using AFR3 = Field<12, 4>;    // AFR3
            using AFR4 = Field<16, 4>;    // AFR4
            using AFR5 = Field<20, 4>;    // AFR5
            using AFR6 = Field<24, 4>;    // AFR6
            using AFR7 = Field<28, 4>;    // AFR7
        };

        // GPIO alternate function high register
        struct GPIOF_AFRH : public Register<0x50007024> {
            using AFR8 = Field<0, 4>;    // AFR8
            using AFR9 = Field<4, 4>;    // AFR9
            using AFR10 = Field<8, 4>;    // AFR10
            using AFR11 = Field<12, 4>;    // AFR11
            using AFR12 = Field<16, 4>;    // AFR12
            using AFR13 = Field<20, 4>;    // AFR13
            using AFR14 = Field<24, 4>;    // AFR14
            using AFR15 = Field<28, 4>;    // AFR15
        };

        // GPIO port bit reset register
        struct GPIOF_BRR : public RegisterWriteOnly<0x50007028> {
            using BR0 = Field<0, 1>;    // BR0
            using BR1 = Field<1, 1>;    // BR1
            using BR2 = Field<2, 1>;    // BR2
            using BR3 = Field<3, 1>;    // BR3
            using BR4 = Field<4, 1>;    // BR4
            using BR5 = Field<5, 1>;    // BR5
            using BR6 = Field<6, 1>;    // BR6
            using BR7 = Field<7, 1>;    // BR7
            using BR8 = Field<8, 1>;    // BR8
            using BR9 = Field<9, 1>;    // BR9
            using BR10 = Field<10, 1>;    // BR10
            using BR11 = Field<11, 1>;    // BR11
            using BR12 = Field<12, 1>;    // BR12
            using BR13 = Field<13, 1>;    // BR13
            using BR14 = Field<14, 1>;    // BR14
            using BR15 = Field<15, 1>;    // BR15
        };

        // For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
        struct GPIOF_HWCFGR10 : public RegisterReadOnly<0x500073c8> {
            using AHB_IOP = Field<0, 4>;    // AHB_IOP
            using AF_SIZE = Field<4, 4>;    // AF_SIZE
            using SPEED_CFG = Field<8, 4>;    // SPEED_CFG
            using LOCK_CFG = Field<12, 4>;    // LOCK_CFG
            using SEC_CFG = Field<16, 4>;    // SEC_CFG
            using OR_CFG = Field<20, 4>;    // OR_CFG
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOF_HWCFGR9 : public RegisterReadOnly<0x500073cc> {
            using EN_IO = Field<0, 16>;    // EN_IO
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOF_HWCFGR8 : public RegisterReadOnly<0x500073d0> {
            using AF_PRIO8 = Field<0, 4>;    // AF_PRIO8
            using AF_PRIO9 = Field<4, 4>;    // AF_PRIO9
            using AF_PRIO10 = Field<8, 4>;    // AF_PRIO10
            using AF_PRIO11 = Field<12, 4>;    // AF_PRIO11
            using AF_PRIO12 = Field<16, 4>;    // AF_PRIO12
            using AF_PRIO13 = Field<20, 4>;    // AF_PRIO13
            using AF_PRIO14 = Field<24, 4>;    // AF_PRIO14
            using AF_PRIO15 = Field<28, 4>;    // AF_PRIO15
        };

        // GPIO hardware configuration register 7
        struct GPIOF_HWCFGR7 : public RegisterReadOnly<0x500073d4> {
            using AF_PRIO0 = Field<0, 4>;    // AF_PRIO0
            using AF_PRIO1 = Field<4, 4>;    // AF_PRIO1
            using AF_PRIO2 = Field<8, 4>;    // AF_PRIO2
            using AF_PRIO3 = Field<12, 4>;    // AF_PRIO3
            using AF_PRIO4 = Field<16, 4>;    // AF_PRIO4
            using AF_PRIO5 = Field<20, 4>;    // AF_PRIO5
            using AF_PRIO6 = Field<24, 4>;    // AF_PRIO6
            using AF_PRIO7 = Field<28, 4>;    // AF_PRIO7
        };

        // GPIO hardware configuration register 6
        struct GPIOF_HWCFGR6 : public RegisterReadOnly<0x500073d8> {
            using MODER_RES = Field<0, 32>;    // MODER_RES
        };

        // GPIO hardware configuration register 5
        struct GPIOF_HWCFGR5 : public RegisterReadOnly<0x500073dc> {
            using PUPDR_RES = Field<0, 32>;    // PUPDR_RES
        };

        // GPIO hardware configuration register 4
        struct GPIOF_HWCFGR4 : public RegisterReadOnly<0x500073e0> {
            using OSPEED_RES = Field<0, 32>;    // OSPEED_RES
        };

        // GPIO hardware configuration register 3
        struct GPIOF_HWCFGR3 : public RegisterReadOnly<0x500073e4> {
            using ODR_RES = Field<0, 16>;    // ODR_RES
            using OTYPER_RES = Field<16, 16>;    // OTYPER_RES
        };

        // GPIO hardware configuration register 2
        struct GPIOF_HWCFGR2 : public RegisterReadOnly<0x500073e8> {
            using AFRL_RES = Field<0, 32>;    // AFRL_RES
        };

        // GPIO hardware configuration register 1
        struct GPIOF_HWCFGR1 : public RegisterReadOnly<0x500073ec> {
            using AFRH_RES = Field<0, 32>;    // AFRH_RES
        };

        // GPIO hardware configuration register 0
        struct GPIOF_HWCFGR0 : public RegisterReadOnly<0x500073f0> {
            using OR_RES = Field<0, 16>;    // OR_RES
        };

        // GPIO version register
        struct GPIOF_VERR : public RegisterReadOnly<0x500073f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // GPIO identification register
        struct GPIOF_IPIDR : public RegisterReadOnly<0x500073f8> {
            using IPIDR = Field<0, 32>;    // IPIDR
        };

        // GPIO size identification register
        struct GPIOF_SIDR : public RegisterReadOnly<0x500073fc> {
            using SIDR = Field<0, 32>;    // SIDR
        };

    };

    // GPIOG
    struct GPIOG {
        // GPIO port mode register
        struct GPIOG_MODER : public Register<0x50008000> {
            using MODER0 = Field<0, 2>;    // MODER0
            using MODER1 = Field<2, 2>;    // MODER1
            using MODER2 = Field<4, 2>;    // MODER2
            using MODER3 = Field<6, 2>;    // MODER3
            using MODER4 = Field<8, 2>;    // MODER4
            using MODER5 = Field<10, 2>;    // MODER5
            using MODER6 = Field<12, 2>;    // MODER6
            using MODER7 = Field<14, 2>;    // MODER7
            using MODER8 = Field<16, 2>;    // MODER8
            using MODER9 = Field<18, 2>;    // MODER9
            using MODER10 = Field<20, 2>;    // MODER10
            using MODER11 = Field<22, 2>;    // MODER11
            using MODER12 = Field<24, 2>;    // MODER12
            using MODER13 = Field<26, 2>;    // MODER13
            using MODER14 = Field<28, 2>;    // MODER14
            using MODER15 = Field<30, 2>;    // MODER15
        };

        // GPIO port output type register
        struct GPIOG_OTYPER : public Register<0x50008004> {
            using OT0 = Field<0, 1>;    // OT0
            using OT1 = Field<1, 1>;    // OT1
            using OT2 = Field<2, 1>;    // OT2
            using OT3 = Field<3, 1>;    // OT3
            using OT4 = Field<4, 1>;    // OT4
            using OT5 = Field<5, 1>;    // OT5
            using OT6 = Field<6, 1>;    // OT6
            using OT7 = Field<7, 1>;    // OT7
            using OT8 = Field<8, 1>;    // OT8
            using OT9 = Field<9, 1>;    // OT9
            using OT10 = Field<10, 1>;    // OT10
            using OT11 = Field<11, 1>;    // OT11
            using OT12 = Field<12, 1>;    // OT12
            using OT13 = Field<13, 1>;    // OT13
            using OT14 = Field<14, 1>;    // OT14
            using OT15 = Field<15, 1>;    // OT15
        };

        // GPIO port output speed register
        struct GPIOG_OSPEEDR : public Register<0x50008008> {
            using OSPEEDR0 = Field<0, 2>;    // OSPEEDR0
            using OSPEEDR1 = Field<2, 2>;    // OSPEEDR1
            using OSPEEDR2 = Field<4, 2>;    // OSPEEDR2
            using OSPEEDR3 = Field<6, 2>;    // OSPEEDR3
            using OSPEEDR4 = Field<8, 2>;    // OSPEEDR4
            using OSPEEDR5 = Field<10, 2>;    // OSPEEDR5
            using OSPEEDR6 = Field<12, 2>;    // OSPEEDR6
            using OSPEEDR7 = Field<14, 2>;    // OSPEEDR7
            using OSPEEDR8 = Field<16, 2>;    // OSPEEDR8
            using OSPEEDR9 = Field<18, 2>;    // OSPEEDR9
            using OSPEEDR10 = Field<20, 2>;    // OSPEEDR10
            using OSPEEDR11 = Field<22, 2>;    // OSPEEDR11
            using OSPEEDR12 = Field<24, 2>;    // OSPEEDR12
            using OSPEEDR13 = Field<26, 2>;    // OSPEEDR13
            using OSPEEDR14 = Field<28, 2>;    // OSPEEDR14
            using OSPEEDR15 = Field<30, 2>;    // OSPEEDR15
        };

        // GPIO port pull-up/pull-down register
        struct GPIOG_PUPDR : public Register<0x5000800c> {
            using PUPDR0 = Field<0, 2>;    // PUPDR0
            using PUPDR1 = Field<2, 2>;    // PUPDR1
            using PUPDR2 = Field<4, 2>;    // PUPDR2
            using PUPDR3 = Field<6, 2>;    // PUPDR3
            using PUPDR4 = Field<8, 2>;    // PUPDR4
            using PUPDR5 = Field<10, 2>;    // PUPDR5
            using PUPDR6 = Field<12, 2>;    // PUPDR6
            using PUPDR7 = Field<14, 2>;    // PUPDR7
            using PUPDR8 = Field<16, 2>;    // PUPDR8
            using PUPDR9 = Field<18, 2>;    // PUPDR9
            using PUPDR10 = Field<20, 2>;    // PUPDR10
            using PUPDR11 = Field<22, 2>;    // PUPDR11
            using PUPDR12 = Field<24, 2>;    // PUPDR12
            using PUPDR13 = Field<26, 2>;    // PUPDR13
            using PUPDR14 = Field<28, 2>;    // PUPDR14
            using PUPDR15 = Field<30, 2>;    // PUPDR15
        };

        // GPIO port input data register
        struct GPIOG_IDR : public RegisterReadOnly<0x50008010> {
            using IDR0 = Field<0, 1>;    // IDR0
            using IDR1 = Field<1, 1>;    // IDR1
            using IDR2 = Field<2, 1>;    // IDR2
            using IDR3 = Field<3, 1>;    // IDR3
            using IDR4 = Field<4, 1>;    // IDR4
            using IDR5 = Field<5, 1>;    // IDR5
            using IDR6 = Field<6, 1>;    // IDR6
            using IDR7 = Field<7, 1>;    // IDR7
            using IDR8 = Field<8, 1>;    // IDR8
            using IDR9 = Field<9, 1>;    // IDR9
            using IDR10 = Field<10, 1>;    // IDR10
            using IDR11 = Field<11, 1>;    // IDR11
            using IDR12 = Field<12, 1>;    // IDR12
            using IDR13 = Field<13, 1>;    // IDR13
            using IDR14 = Field<14, 1>;    // IDR14
            using IDR15 = Field<15, 1>;    // IDR15
        };

        // GPIO port output data register
        struct GPIOG_ODR : public Register<0x50008014> {
            using ODR0 = Field<0, 1>;    // ODR0
            using ODR1 = Field<1, 1>;    // ODR1
            using ODR2 = Field<2, 1>;    // ODR2
            using ODR3 = Field<3, 1>;    // ODR3
            using ODR4 = Field<4, 1>;    // ODR4
            using ODR5 = Field<5, 1>;    // ODR5
            using ODR6 = Field<6, 1>;    // ODR6
            using ODR7 = Field<7, 1>;    // ODR7
            using ODR8 = Field<8, 1>;    // ODR8
            using ODR9 = Field<9, 1>;    // ODR9
            using ODR10 = Field<10, 1>;    // ODR10
            using ODR11 = Field<11, 1>;    // ODR11
            using ODR12 = Field<12, 1>;    // ODR12
            using ODR13 = Field<13, 1>;    // ODR13
            using ODR14 = Field<14, 1>;    // ODR14
            using ODR15 = Field<15, 1>;    // ODR15
        };

        // GPIO port bit set/reset register
        struct GPIOG_BSRR : public RegisterWriteOnly<0x50008018> {
            using BS0 = Field<0, 1>;    // BS0
            using BS1 = Field<1, 1>;    // BS1
            using BS2 = Field<2, 1>;    // BS2
            using BS3 = Field<3, 1>;    // BS3
            using BS4 = Field<4, 1>;    // BS4
            using BS5 = Field<5, 1>;    // BS5
            using BS6 = Field<6, 1>;    // BS6
            using BS7 = Field<7, 1>;    // BS7
            using BS8 = Field<8, 1>;    // BS8
            using BS9 = Field<9, 1>;    // BS9
            using BS10 = Field<10, 1>;    // BS10
            using BS11 = Field<11, 1>;    // BS11
            using BS12 = Field<12, 1>;    // BS12
            using BS13 = Field<13, 1>;    // BS13
            using BS14 = Field<14, 1>;    // BS14
            using BS15 = Field<15, 1>;    // BS15
            using BR0 = Field<16, 1>;    // BR0
            using BR1 = Field<17, 1>;    // BR1
            using BR2 = Field<18, 1>;    // BR2
            using BR3 = Field<19, 1>;    // BR3
            using BR4 = Field<20, 1>;    // BR4
            using BR5 = Field<21, 1>;    // BR5
            using BR6 = Field<22, 1>;    // BR6
            using BR7 = Field<23, 1>;    // BR7
            using BR8 = Field<24, 1>;    // BR8
            using BR9 = Field<25, 1>;    // BR9
            using BR10 = Field<26, 1>;    // BR10
            using BR11 = Field<27, 1>;    // BR11
            using BR12 = Field<28, 1>;    // BR12
            using BR13 = Field<29, 1>;    // BR13
            using BR14 = Field<30, 1>;    // BR14
            using BR15 = Field<31, 1>;    // BR15
        };

        // This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
        struct GPIOG_LCKR : public Register<0x5000801c> {
            using LCK0 = Field<0, 1>;    // LCK0
            using LCK1 = Field<1, 1>;    // LCK1
            using LCK2 = Field<2, 1>;    // LCK2
            using LCK3 = Field<3, 1>;    // LCK3
            using LCK4 = Field<4, 1>;    // LCK4
            using LCK5 = Field<5, 1>;    // LCK5
            using LCK6 = Field<6, 1>;    // LCK6
            using LCK7 = Field<7, 1>;    // LCK7
            using LCK8 = Field<8, 1>;    // LCK8
            using LCK9 = Field<9, 1>;    // LCK9
            using LCK10 = Field<10, 1>;    // LCK10
            using LCK11 = Field<11, 1>;    // LCK11
            using LCK12 = Field<12, 1>;    // LCK12
            using LCK13 = Field<13, 1>;    // LCK13
            using LCK14 = Field<14, 1>;    // LCK14
            using LCK15 = Field<15, 1>;    // LCK15
            using LCKK = Field<16, 1>;    // LCKK
        };

        // GPIO alternate function low register
        struct GPIOG_AFRL : public Register<0x50008020> {
            using AFR0 = Field<0, 4>;    // AFR0
            using AFR1 = Field<4, 4>;    // AFR1
            using AFR2 = Field<8, 4>;    // AFR2
            using AFR3 = Field<12, 4>;    // AFR3
            using AFR4 = Field<16, 4>;    // AFR4
            using AFR5 = Field<20, 4>;    // AFR5
            using AFR6 = Field<24, 4>;    // AFR6
            using AFR7 = Field<28, 4>;    // AFR7
        };

        // GPIO alternate function high register
        struct GPIOG_AFRH : public Register<0x50008024> {
            using AFR8 = Field<0, 4>;    // AFR8
            using AFR9 = Field<4, 4>;    // AFR9
            using AFR10 = Field<8, 4>;    // AFR10
            using AFR11 = Field<12, 4>;    // AFR11
            using AFR12 = Field<16, 4>;    // AFR12
            using AFR13 = Field<20, 4>;    // AFR13
            using AFR14 = Field<24, 4>;    // AFR14
            using AFR15 = Field<28, 4>;    // AFR15
        };

        // GPIO port bit reset register
        struct GPIOG_BRR : public RegisterWriteOnly<0x50008028> {
            using BR0 = Field<0, 1>;    // BR0
            using BR1 = Field<1, 1>;    // BR1
            using BR2 = Field<2, 1>;    // BR2
            using BR3 = Field<3, 1>;    // BR3
            using BR4 = Field<4, 1>;    // BR4
            using BR5 = Field<5, 1>;    // BR5
            using BR6 = Field<6, 1>;    // BR6
            using BR7 = Field<7, 1>;    // BR7
            using BR8 = Field<8, 1>;    // BR8
            using BR9 = Field<9, 1>;    // BR9
            using BR10 = Field<10, 1>;    // BR10
            using BR11 = Field<11, 1>;    // BR11
            using BR12 = Field<12, 1>;    // BR12
            using BR13 = Field<13, 1>;    // BR13
            using BR14 = Field<14, 1>;    // BR14
            using BR15 = Field<15, 1>;    // BR15
        };

        // For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
        struct GPIOG_HWCFGR10 : public RegisterReadOnly<0x500083c8> {
            using AHB_IOP = Field<0, 4>;    // AHB_IOP
            using AF_SIZE = Field<4, 4>;    // AF_SIZE
            using SPEED_CFG = Field<8, 4>;    // SPEED_CFG
            using LOCK_CFG = Field<12, 4>;    // LOCK_CFG
            using SEC_CFG = Field<16, 4>;    // SEC_CFG
            using OR_CFG = Field<20, 4>;    // OR_CFG
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOG_HWCFGR9 : public RegisterReadOnly<0x500083cc> {
            using EN_IO = Field<0, 16>;    // EN_IO
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOG_HWCFGR8 : public RegisterReadOnly<0x500083d0> {
            using AF_PRIO8 = Field<0, 4>;    // AF_PRIO8
            using AF_PRIO9 = Field<4, 4>;    // AF_PRIO9
            using AF_PRIO10 = Field<8, 4>;    // AF_PRIO10
            using AF_PRIO11 = Field<12, 4>;    // AF_PRIO11
            using AF_PRIO12 = Field<16, 4>;    // AF_PRIO12
            using AF_PRIO13 = Field<20, 4>;    // AF_PRIO13
            using AF_PRIO14 = Field<24, 4>;    // AF_PRIO14
            using AF_PRIO15 = Field<28, 4>;    // AF_PRIO15
        };

        // GPIO hardware configuration register 7
        struct GPIOG_HWCFGR7 : public RegisterReadOnly<0x500083d4> {
            using AF_PRIO0 = Field<0, 4>;    // AF_PRIO0
            using AF_PRIO1 = Field<4, 4>;    // AF_PRIO1
            using AF_PRIO2 = Field<8, 4>;    // AF_PRIO2
            using AF_PRIO3 = Field<12, 4>;    // AF_PRIO3
            using AF_PRIO4 = Field<16, 4>;    // AF_PRIO4
            using AF_PRIO5 = Field<20, 4>;    // AF_PRIO5
            using AF_PRIO6 = Field<24, 4>;    // AF_PRIO6
            using AF_PRIO7 = Field<28, 4>;    // AF_PRIO7
        };

        // GPIO hardware configuration register 6
        struct GPIOG_HWCFGR6 : public RegisterReadOnly<0x500083d8> {
            using MODER_RES = Field<0, 32>;    // MODER_RES
        };

        // GPIO hardware configuration register 5
        struct GPIOG_HWCFGR5 : public RegisterReadOnly<0x500083dc> {
            using PUPDR_RES = Field<0, 32>;    // PUPDR_RES
        };

        // GPIO hardware configuration register 4
        struct GPIOG_HWCFGR4 : public RegisterReadOnly<0x500083e0> {
            using OSPEED_RES = Field<0, 32>;    // OSPEED_RES
        };

        // GPIO hardware configuration register 3
        struct GPIOG_HWCFGR3 : public RegisterReadOnly<0x500083e4> {
            using ODR_RES = Field<0, 16>;    // ODR_RES
            using OTYPER_RES = Field<16, 16>;    // OTYPER_RES
        };

        // GPIO hardware configuration register 2
        struct GPIOG_HWCFGR2 : public RegisterReadOnly<0x500083e8> {
            using AFRL_RES = Field<0, 32>;    // AFRL_RES
        };

        // GPIO hardware configuration register 1
        struct GPIOG_HWCFGR1 : public RegisterReadOnly<0x500083ec> {
            using AFRH_RES = Field<0, 32>;    // AFRH_RES
        };

        // GPIO hardware configuration register 0
        struct GPIOG_HWCFGR0 : public RegisterReadOnly<0x500083f0> {
            using OR_RES = Field<0, 16>;    // OR_RES
        };

        // GPIO version register
        struct GPIOG_VERR : public RegisterReadOnly<0x500083f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // GPIO identification register
        struct GPIOG_IPIDR : public RegisterReadOnly<0x500083f8> {
            using IPIDR = Field<0, 32>;    // IPIDR
        };

        // GPIO size identification register
        struct GPIOG_SIDR : public RegisterReadOnly<0x500083fc> {
            using SIDR = Field<0, 32>;    // SIDR
        };

    };

    // GPIOH
    struct GPIOH {
        // GPIO port mode register
        struct GPIOH_MODER : public Register<0x50009000> {
            using MODER0 = Field<0, 2>;    // MODER0
            using MODER1 = Field<2, 2>;    // MODER1
            using MODER2 = Field<4, 2>;    // MODER2
            using MODER3 = Field<6, 2>;    // MODER3
            using MODER4 = Field<8, 2>;    // MODER4
            using MODER5 = Field<10, 2>;    // MODER5
            using MODER6 = Field<12, 2>;    // MODER6
            using MODER7 = Field<14, 2>;    // MODER7
            using MODER8 = Field<16, 2>;    // MODER8
            using MODER9 = Field<18, 2>;    // MODER9
            using MODER10 = Field<20, 2>;    // MODER10
            using MODER11 = Field<22, 2>;    // MODER11
            using MODER12 = Field<24, 2>;    // MODER12
            using MODER13 = Field<26, 2>;    // MODER13
            using MODER14 = Field<28, 2>;    // MODER14
            using MODER15 = Field<30, 2>;    // MODER15
        };

        // GPIO port output type register
        struct GPIOH_OTYPER : public Register<0x50009004> {
            using OT0 = Field<0, 1>;    // OT0
            using OT1 = Field<1, 1>;    // OT1
            using OT2 = Field<2, 1>;    // OT2
            using OT3 = Field<3, 1>;    // OT3
            using OT4 = Field<4, 1>;    // OT4
            using OT5 = Field<5, 1>;    // OT5
            using OT6 = Field<6, 1>;    // OT6
            using OT7 = Field<7, 1>;    // OT7
            using OT8 = Field<8, 1>;    // OT8
            using OT9 = Field<9, 1>;    // OT9
            using OT10 = Field<10, 1>;    // OT10
            using OT11 = Field<11, 1>;    // OT11
            using OT12 = Field<12, 1>;    // OT12
            using OT13 = Field<13, 1>;    // OT13
            using OT14 = Field<14, 1>;    // OT14
            using OT15 = Field<15, 1>;    // OT15
        };

        // GPIO port output speed register
        struct GPIOH_OSPEEDR : public Register<0x50009008> {
            using OSPEEDR0 = Field<0, 2>;    // OSPEEDR0
            using OSPEEDR1 = Field<2, 2>;    // OSPEEDR1
            using OSPEEDR2 = Field<4, 2>;    // OSPEEDR2
            using OSPEEDR3 = Field<6, 2>;    // OSPEEDR3
            using OSPEEDR4 = Field<8, 2>;    // OSPEEDR4
            using OSPEEDR5 = Field<10, 2>;    // OSPEEDR5
            using OSPEEDR6 = Field<12, 2>;    // OSPEEDR6
            using OSPEEDR7 = Field<14, 2>;    // OSPEEDR7
            using OSPEEDR8 = Field<16, 2>;    // OSPEEDR8
            using OSPEEDR9 = Field<18, 2>;    // OSPEEDR9
            using OSPEEDR10 = Field<20, 2>;    // OSPEEDR10
            using OSPEEDR11 = Field<22, 2>;    // OSPEEDR11
            using OSPEEDR12 = Field<24, 2>;    // OSPEEDR12
            using OSPEEDR13 = Field<26, 2>;    // OSPEEDR13
            using OSPEEDR14 = Field<28, 2>;    // OSPEEDR14
            using OSPEEDR15 = Field<30, 2>;    // OSPEEDR15
        };

        // GPIO port pull-up/pull-down register
        struct GPIOH_PUPDR : public Register<0x5000900c> {
            using PUPDR0 = Field<0, 2>;    // PUPDR0
            using PUPDR1 = Field<2, 2>;    // PUPDR1
            using PUPDR2 = Field<4, 2>;    // PUPDR2
            using PUPDR3 = Field<6, 2>;    // PUPDR3
            using PUPDR4 = Field<8, 2>;    // PUPDR4
            using PUPDR5 = Field<10, 2>;    // PUPDR5
            using PUPDR6 = Field<12, 2>;    // PUPDR6
            using PUPDR7 = Field<14, 2>;    // PUPDR7
            using PUPDR8 = Field<16, 2>;    // PUPDR8
            using PUPDR9 = Field<18, 2>;    // PUPDR9
            using PUPDR10 = Field<20, 2>;    // PUPDR10
            using PUPDR11 = Field<22, 2>;    // PUPDR11
            using PUPDR12 = Field<24, 2>;    // PUPDR12
            using PUPDR13 = Field<26, 2>;    // PUPDR13
            using PUPDR14 = Field<28, 2>;    // PUPDR14
            using PUPDR15 = Field<30, 2>;    // PUPDR15
        };

        // GPIO port input data register
        struct GPIOH_IDR : public RegisterReadOnly<0x50009010> {
            using IDR0 = Field<0, 1>;    // IDR0
            using IDR1 = Field<1, 1>;    // IDR1
            using IDR2 = Field<2, 1>;    // IDR2
            using IDR3 = Field<3, 1>;    // IDR3
            using IDR4 = Field<4, 1>;    // IDR4
            using IDR5 = Field<5, 1>;    // IDR5
            using IDR6 = Field<6, 1>;    // IDR6
            using IDR7 = Field<7, 1>;    // IDR7
            using IDR8 = Field<8, 1>;    // IDR8
            using IDR9 = Field<9, 1>;    // IDR9
            using IDR10 = Field<10, 1>;    // IDR10
            using IDR11 = Field<11, 1>;    // IDR11
            using IDR12 = Field<12, 1>;    // IDR12
            using IDR13 = Field<13, 1>;    // IDR13
            using IDR14 = Field<14, 1>;    // IDR14
            using IDR15 = Field<15, 1>;    // IDR15
        };

        // GPIO port output data register
        struct GPIOH_ODR : public Register<0x50009014> {
            using ODR0 = Field<0, 1>;    // ODR0
            using ODR1 = Field<1, 1>;    // ODR1
            using ODR2 = Field<2, 1>;    // ODR2
            using ODR3 = Field<3, 1>;    // ODR3
            using ODR4 = Field<4, 1>;    // ODR4
            using ODR5 = Field<5, 1>;    // ODR5
            using ODR6 = Field<6, 1>;    // ODR6
            using ODR7 = Field<7, 1>;    // ODR7
            using ODR8 = Field<8, 1>;    // ODR8
            using ODR9 = Field<9, 1>;    // ODR9
            using ODR10 = Field<10, 1>;    // ODR10
            using ODR11 = Field<11, 1>;    // ODR11
            using ODR12 = Field<12, 1>;    // ODR12
            using ODR13 = Field<13, 1>;    // ODR13
            using ODR14 = Field<14, 1>;    // ODR14
            using ODR15 = Field<15, 1>;    // ODR15
        };

        // GPIO port bit set/reset register
        struct GPIOH_BSRR : public RegisterWriteOnly<0x50009018> {
            using BS0 = Field<0, 1>;    // BS0
            using BS1 = Field<1, 1>;    // BS1
            using BS2 = Field<2, 1>;    // BS2
            using BS3 = Field<3, 1>;    // BS3
            using BS4 = Field<4, 1>;    // BS4
            using BS5 = Field<5, 1>;    // BS5
            using BS6 = Field<6, 1>;    // BS6
            using BS7 = Field<7, 1>;    // BS7
            using BS8 = Field<8, 1>;    // BS8
            using BS9 = Field<9, 1>;    // BS9
            using BS10 = Field<10, 1>;    // BS10
            using BS11 = Field<11, 1>;    // BS11
            using BS12 = Field<12, 1>;    // BS12
            using BS13 = Field<13, 1>;    // BS13
            using BS14 = Field<14, 1>;    // BS14
            using BS15 = Field<15, 1>;    // BS15
            using BR0 = Field<16, 1>;    // BR0
            using BR1 = Field<17, 1>;    // BR1
            using BR2 = Field<18, 1>;    // BR2
            using BR3 = Field<19, 1>;    // BR3
            using BR4 = Field<20, 1>;    // BR4
            using BR5 = Field<21, 1>;    // BR5
            using BR6 = Field<22, 1>;    // BR6
            using BR7 = Field<23, 1>;    // BR7
            using BR8 = Field<24, 1>;    // BR8
            using BR9 = Field<25, 1>;    // BR9
            using BR10 = Field<26, 1>;    // BR10
            using BR11 = Field<27, 1>;    // BR11
            using BR12 = Field<28, 1>;    // BR12
            using BR13 = Field<29, 1>;    // BR13
            using BR14 = Field<30, 1>;    // BR14
            using BR15 = Field<31, 1>;    // BR15
        };

        // This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
        struct GPIOH_LCKR : public Register<0x5000901c> {
            using LCK0 = Field<0, 1>;    // LCK0
            using LCK1 = Field<1, 1>;    // LCK1
            using LCK2 = Field<2, 1>;    // LCK2
            using LCK3 = Field<3, 1>;    // LCK3
            using LCK4 = Field<4, 1>;    // LCK4
            using LCK5 = Field<5, 1>;    // LCK5
            using LCK6 = Field<6, 1>;    // LCK6
            using LCK7 = Field<7, 1>;    // LCK7
            using LCK8 = Field<8, 1>;    // LCK8
            using LCK9 = Field<9, 1>;    // LCK9
            using LCK10 = Field<10, 1>;    // LCK10
            using LCK11 = Field<11, 1>;    // LCK11
            using LCK12 = Field<12, 1>;    // LCK12
            using LCK13 = Field<13, 1>;    // LCK13
            using LCK14 = Field<14, 1>;    // LCK14
            using LCK15 = Field<15, 1>;    // LCK15
            using LCKK = Field<16, 1>;    // LCKK
        };

        // GPIO alternate function low register
        struct GPIOH_AFRL : public Register<0x50009020> {
            using AFR0 = Field<0, 4>;    // AFR0
            using AFR1 = Field<4, 4>;    // AFR1
            using AFR2 = Field<8, 4>;    // AFR2
            using AFR3 = Field<12, 4>;    // AFR3
            using AFR4 = Field<16, 4>;    // AFR4
            using AFR5 = Field<20, 4>;    // AFR5
            using AFR6 = Field<24, 4>;    // AFR6
            using AFR7 = Field<28, 4>;    // AFR7
        };

        // GPIO alternate function high register
        struct GPIOH_AFRH : public Register<0x50009024> {
            using AFR8 = Field<0, 4>;    // AFR8
            using AFR9 = Field<4, 4>;    // AFR9
            using AFR10 = Field<8, 4>;    // AFR10
            using AFR11 = Field<12, 4>;    // AFR11
            using AFR12 = Field<16, 4>;    // AFR12
            using AFR13 = Field<20, 4>;    // AFR13
            using AFR14 = Field<24, 4>;    // AFR14
            using AFR15 = Field<28, 4>;    // AFR15
        };

        // GPIO port bit reset register
        struct GPIOH_BRR : public RegisterWriteOnly<0x50009028> {
            using BR0 = Field<0, 1>;    // BR0
            using BR1 = Field<1, 1>;    // BR1
            using BR2 = Field<2, 1>;    // BR2
            using BR3 = Field<3, 1>;    // BR3
            using BR4 = Field<4, 1>;    // BR4
            using BR5 = Field<5, 1>;    // BR5
            using BR6 = Field<6, 1>;    // BR6
            using BR7 = Field<7, 1>;    // BR7
            using BR8 = Field<8, 1>;    // BR8
            using BR9 = Field<9, 1>;    // BR9
            using BR10 = Field<10, 1>;    // BR10
            using BR11 = Field<11, 1>;    // BR11
            using BR12 = Field<12, 1>;    // BR12
            using BR13 = Field<13, 1>;    // BR13
            using BR14 = Field<14, 1>;    // BR14
            using BR15 = Field<15, 1>;    // BR15
        };

        // For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
        struct GPIOH_HWCFGR10 : public RegisterReadOnly<0x500093c8> {
            using AHB_IOP = Field<0, 4>;    // AHB_IOP
            using AF_SIZE = Field<4, 4>;    // AF_SIZE
            using SPEED_CFG = Field<8, 4>;    // SPEED_CFG
            using LOCK_CFG = Field<12, 4>;    // LOCK_CFG
            using SEC_CFG = Field<16, 4>;    // SEC_CFG
            using OR_CFG = Field<20, 4>;    // OR_CFG
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOH_HWCFGR9 : public RegisterReadOnly<0x500093cc> {
            using EN_IO = Field<0, 16>;    // EN_IO
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOH_HWCFGR8 : public RegisterReadOnly<0x500093d0> {
            using AF_PRIO8 = Field<0, 4>;    // AF_PRIO8
            using AF_PRIO9 = Field<4, 4>;    // AF_PRIO9
            using AF_PRIO10 = Field<8, 4>;    // AF_PRIO10
            using AF_PRIO11 = Field<12, 4>;    // AF_PRIO11
            using AF_PRIO12 = Field<16, 4>;    // AF_PRIO12
            using AF_PRIO13 = Field<20, 4>;    // AF_PRIO13
            using AF_PRIO14 = Field<24, 4>;    // AF_PRIO14
            using AF_PRIO15 = Field<28, 4>;    // AF_PRIO15
        };

        // GPIO hardware configuration register 7
        struct GPIOH_HWCFGR7 : public RegisterReadOnly<0x500093d4> {
            using AF_PRIO0 = Field<0, 4>;    // AF_PRIO0
            using AF_PRIO1 = Field<4, 4>;    // AF_PRIO1
            using AF_PRIO2 = Field<8, 4>;    // AF_PRIO2
            using AF_PRIO3 = Field<12, 4>;    // AF_PRIO3
            using AF_PRIO4 = Field<16, 4>;    // AF_PRIO4
            using AF_PRIO5 = Field<20, 4>;    // AF_PRIO5
            using AF_PRIO6 = Field<24, 4>;    // AF_PRIO6
            using AF_PRIO7 = Field<28, 4>;    // AF_PRIO7
        };

        // GPIO hardware configuration register 6
        struct GPIOH_HWCFGR6 : public RegisterReadOnly<0x500093d8> {
            using MODER_RES = Field<0, 32>;    // MODER_RES
        };

        // GPIO hardware configuration register 5
        struct GPIOH_HWCFGR5 : public RegisterReadOnly<0x500093dc> {
            using PUPDR_RES = Field<0, 32>;    // PUPDR_RES
        };

        // GPIO hardware configuration register 4
        struct GPIOH_HWCFGR4 : public RegisterReadOnly<0x500093e0> {
            using OSPEED_RES = Field<0, 32>;    // OSPEED_RES
        };

        // GPIO hardware configuration register 3
        struct GPIOH_HWCFGR3 : public RegisterReadOnly<0x500093e4> {
            using ODR_RES = Field<0, 16>;    // ODR_RES
            using OTYPER_RES = Field<16, 16>;    // OTYPER_RES
        };

        // GPIO hardware configuration register 2
        struct GPIOH_HWCFGR2 : public RegisterReadOnly<0x500093e8> {
            using AFRL_RES = Field<0, 32>;    // AFRL_RES
        };

        // GPIO hardware configuration register 1
        struct GPIOH_HWCFGR1 : public RegisterReadOnly<0x500093ec> {
            using AFRH_RES = Field<0, 32>;    // AFRH_RES
        };

        // GPIO hardware configuration register 0
        struct GPIOH_HWCFGR0 : public RegisterReadOnly<0x500093f0> {
            using OR_RES = Field<0, 16>;    // OR_RES
        };

        // GPIO version register
        struct GPIOH_VERR : public RegisterReadOnly<0x500093f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // GPIO identification register
        struct GPIOH_IPIDR : public RegisterReadOnly<0x500093f8> {
            using IPIDR = Field<0, 32>;    // IPIDR
        };

        // GPIO size identification register
        struct GPIOH_SIDR : public RegisterReadOnly<0x500093fc> {
            using SIDR = Field<0, 32>;    // SIDR
        };

    };

    // GPIOI
    struct GPIOI {
        // GPIO port mode register
        struct GPIOI_MODER : public Register<0x5000a000> {
            using MODER0 = Field<0, 2>;    // MODER0
            using MODER1 = Field<2, 2>;    // MODER1
            using MODER2 = Field<4, 2>;    // MODER2
            using MODER3 = Field<6, 2>;    // MODER3
            using MODER4 = Field<8, 2>;    // MODER4
            using MODER5 = Field<10, 2>;    // MODER5
            using MODER6 = Field<12, 2>;    // MODER6
            using MODER7 = Field<14, 2>;    // MODER7
            using MODER8 = Field<16, 2>;    // MODER8
            using MODER9 = Field<18, 2>;    // MODER9
            using MODER10 = Field<20, 2>;    // MODER10
            using MODER11 = Field<22, 2>;    // MODER11
            using MODER12 = Field<24, 2>;    // MODER12
            using MODER13 = Field<26, 2>;    // MODER13
            using MODER14 = Field<28, 2>;    // MODER14
            using MODER15 = Field<30, 2>;    // MODER15
        };

        // GPIO port output type register
        struct GPIOI_OTYPER : public Register<0x5000a004> {
            using OT0 = Field<0, 1>;    // OT0
            using OT1 = Field<1, 1>;    // OT1
            using OT2 = Field<2, 1>;    // OT2
            using OT3 = Field<3, 1>;    // OT3
            using OT4 = Field<4, 1>;    // OT4
            using OT5 = Field<5, 1>;    // OT5
            using OT6 = Field<6, 1>;    // OT6
            using OT7 = Field<7, 1>;    // OT7
            using OT8 = Field<8, 1>;    // OT8
            using OT9 = Field<9, 1>;    // OT9
            using OT10 = Field<10, 1>;    // OT10
            using OT11 = Field<11, 1>;    // OT11
            using OT12 = Field<12, 1>;    // OT12
            using OT13 = Field<13, 1>;    // OT13
            using OT14 = Field<14, 1>;    // OT14
            using OT15 = Field<15, 1>;    // OT15
        };

        // GPIO port output speed register
        struct GPIOI_OSPEEDR : public Register<0x5000a008> {
            using OSPEEDR0 = Field<0, 2>;    // OSPEEDR0
            using OSPEEDR1 = Field<2, 2>;    // OSPEEDR1
            using OSPEEDR2 = Field<4, 2>;    // OSPEEDR2
            using OSPEEDR3 = Field<6, 2>;    // OSPEEDR3
            using OSPEEDR4 = Field<8, 2>;    // OSPEEDR4
            using OSPEEDR5 = Field<10, 2>;    // OSPEEDR5
            using OSPEEDR6 = Field<12, 2>;    // OSPEEDR6
            using OSPEEDR7 = Field<14, 2>;    // OSPEEDR7
            using OSPEEDR8 = Field<16, 2>;    // OSPEEDR8
            using OSPEEDR9 = Field<18, 2>;    // OSPEEDR9
            using OSPEEDR10 = Field<20, 2>;    // OSPEEDR10
            using OSPEEDR11 = Field<22, 2>;    // OSPEEDR11
            using OSPEEDR12 = Field<24, 2>;    // OSPEEDR12
            using OSPEEDR13 = Field<26, 2>;    // OSPEEDR13
            using OSPEEDR14 = Field<28, 2>;    // OSPEEDR14
            using OSPEEDR15 = Field<30, 2>;    // OSPEEDR15
        };

        // GPIO port pull-up/pull-down register
        struct GPIOI_PUPDR : public Register<0x5000a00c> {
            using PUPDR0 = Field<0, 2>;    // PUPDR0
            using PUPDR1 = Field<2, 2>;    // PUPDR1
            using PUPDR2 = Field<4, 2>;    // PUPDR2
            using PUPDR3 = Field<6, 2>;    // PUPDR3
            using PUPDR4 = Field<8, 2>;    // PUPDR4
            using PUPDR5 = Field<10, 2>;    // PUPDR5
            using PUPDR6 = Field<12, 2>;    // PUPDR6
            using PUPDR7 = Field<14, 2>;    // PUPDR7
            using PUPDR8 = Field<16, 2>;    // PUPDR8
            using PUPDR9 = Field<18, 2>;    // PUPDR9
            using PUPDR10 = Field<20, 2>;    // PUPDR10
            using PUPDR11 = Field<22, 2>;    // PUPDR11
            using PUPDR12 = Field<24, 2>;    // PUPDR12
            using PUPDR13 = Field<26, 2>;    // PUPDR13
            using PUPDR14 = Field<28, 2>;    // PUPDR14
            using PUPDR15 = Field<30, 2>;    // PUPDR15
        };

        // GPIO port input data register
        struct GPIOI_IDR : public RegisterReadOnly<0x5000a010> {
            using IDR0 = Field<0, 1>;    // IDR0
            using IDR1 = Field<1, 1>;    // IDR1
            using IDR2 = Field<2, 1>;    // IDR2
            using IDR3 = Field<3, 1>;    // IDR3
            using IDR4 = Field<4, 1>;    // IDR4
            using IDR5 = Field<5, 1>;    // IDR5
            using IDR6 = Field<6, 1>;    // IDR6
            using IDR7 = Field<7, 1>;    // IDR7
            using IDR8 = Field<8, 1>;    // IDR8
            using IDR9 = Field<9, 1>;    // IDR9
            using IDR10 = Field<10, 1>;    // IDR10
            using IDR11 = Field<11, 1>;    // IDR11
            using IDR12 = Field<12, 1>;    // IDR12
            using IDR13 = Field<13, 1>;    // IDR13
            using IDR14 = Field<14, 1>;    // IDR14
            using IDR15 = Field<15, 1>;    // IDR15
        };

        // GPIO port output data register
        struct GPIOI_ODR : public Register<0x5000a014> {
            using ODR0 = Field<0, 1>;    // ODR0
            using ODR1 = Field<1, 1>;    // ODR1
            using ODR2 = Field<2, 1>;    // ODR2
            using ODR3 = Field<3, 1>;    // ODR3
            using ODR4 = Field<4, 1>;    // ODR4
            using ODR5 = Field<5, 1>;    // ODR5
            using ODR6 = Field<6, 1>;    // ODR6
            using ODR7 = Field<7, 1>;    // ODR7
            using ODR8 = Field<8, 1>;    // ODR8
            using ODR9 = Field<9, 1>;    // ODR9
            using ODR10 = Field<10, 1>;    // ODR10
            using ODR11 = Field<11, 1>;    // ODR11
            using ODR12 = Field<12, 1>;    // ODR12
            using ODR13 = Field<13, 1>;    // ODR13
            using ODR14 = Field<14, 1>;    // ODR14
            using ODR15 = Field<15, 1>;    // ODR15
        };

        // GPIO port bit set/reset register
        struct GPIOI_BSRR : public RegisterWriteOnly<0x5000a018> {
            using BS0 = Field<0, 1>;    // BS0
            using BS1 = Field<1, 1>;    // BS1
            using BS2 = Field<2, 1>;    // BS2
            using BS3 = Field<3, 1>;    // BS3
            using BS4 = Field<4, 1>;    // BS4
            using BS5 = Field<5, 1>;    // BS5
            using BS6 = Field<6, 1>;    // BS6
            using BS7 = Field<7, 1>;    // BS7
            using BS8 = Field<8, 1>;    // BS8
            using BS9 = Field<9, 1>;    // BS9
            using BS10 = Field<10, 1>;    // BS10
            using BS11 = Field<11, 1>;    // BS11
            using BS12 = Field<12, 1>;    // BS12
            using BS13 = Field<13, 1>;    // BS13
            using BS14 = Field<14, 1>;    // BS14
            using BS15 = Field<15, 1>;    // BS15
            using BR0 = Field<16, 1>;    // BR0
            using BR1 = Field<17, 1>;    // BR1
            using BR2 = Field<18, 1>;    // BR2
            using BR3 = Field<19, 1>;    // BR3
            using BR4 = Field<20, 1>;    // BR4
            using BR5 = Field<21, 1>;    // BR5
            using BR6 = Field<22, 1>;    // BR6
            using BR7 = Field<23, 1>;    // BR7
            using BR8 = Field<24, 1>;    // BR8
            using BR9 = Field<25, 1>;    // BR9
            using BR10 = Field<26, 1>;    // BR10
            using BR11 = Field<27, 1>;    // BR11
            using BR12 = Field<28, 1>;    // BR12
            using BR13 = Field<29, 1>;    // BR13
            using BR14 = Field<30, 1>;    // BR14
            using BR15 = Field<31, 1>;    // BR15
        };

        // This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
        struct GPIOI_LCKR : public Register<0x5000a01c> {
            using LCK0 = Field<0, 1>;    // LCK0
            using LCK1 = Field<1, 1>;    // LCK1
            using LCK2 = Field<2, 1>;    // LCK2
            using LCK3 = Field<3, 1>;    // LCK3
            using LCK4 = Field<4, 1>;    // LCK4
            using LCK5 = Field<5, 1>;    // LCK5
            using LCK6 = Field<6, 1>;    // LCK6
            using LCK7 = Field<7, 1>;    // LCK7
            using LCK8 = Field<8, 1>;    // LCK8
            using LCK9 = Field<9, 1>;    // LCK9
            using LCK10 = Field<10, 1>;    // LCK10
            using LCK11 = Field<11, 1>;    // LCK11
            using LCK12 = Field<12, 1>;    // LCK12
            using LCK13 = Field<13, 1>;    // LCK13
            using LCK14 = Field<14, 1>;    // LCK14
            using LCK15 = Field<15, 1>;    // LCK15
            using LCKK = Field<16, 1>;    // LCKK
        };

        // GPIO alternate function low register
        struct GPIOI_AFRL : public Register<0x5000a020> {
            using AFR0 = Field<0, 4>;    // AFR0
            using AFR1 = Field<4, 4>;    // AFR1
            using AFR2 = Field<8, 4>;    // AFR2
            using AFR3 = Field<12, 4>;    // AFR3
            using AFR4 = Field<16, 4>;    // AFR4
            using AFR5 = Field<20, 4>;    // AFR5
            using AFR6 = Field<24, 4>;    // AFR6
            using AFR7 = Field<28, 4>;    // AFR7
        };

        // GPIO alternate function high register
        struct GPIOI_AFRH : public Register<0x5000a024> {
            using AFR8 = Field<0, 4>;    // AFR8
            using AFR9 = Field<4, 4>;    // AFR9
            using AFR10 = Field<8, 4>;    // AFR10
            using AFR11 = Field<12, 4>;    // AFR11
            using AFR12 = Field<16, 4>;    // AFR12
            using AFR13 = Field<20, 4>;    // AFR13
            using AFR14 = Field<24, 4>;    // AFR14
            using AFR15 = Field<28, 4>;    // AFR15
        };

        // GPIO port bit reset register
        struct GPIOI_BRR : public RegisterWriteOnly<0x5000a028> {
            using BR0 = Field<0, 1>;    // BR0
            using BR1 = Field<1, 1>;    // BR1
            using BR2 = Field<2, 1>;    // BR2
            using BR3 = Field<3, 1>;    // BR3
            using BR4 = Field<4, 1>;    // BR4
            using BR5 = Field<5, 1>;    // BR5
            using BR6 = Field<6, 1>;    // BR6
            using BR7 = Field<7, 1>;    // BR7
            using BR8 = Field<8, 1>;    // BR8
            using BR9 = Field<9, 1>;    // BR9
            using BR10 = Field<10, 1>;    // BR10
            using BR11 = Field<11, 1>;    // BR11
            using BR12 = Field<12, 1>;    // BR12
            using BR13 = Field<13, 1>;    // BR13
            using BR14 = Field<14, 1>;    // BR14
            using BR15 = Field<15, 1>;    // BR15
        };

        // For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
        struct GPIOI_HWCFGR10 : public RegisterReadOnly<0x5000a3c8> {
            using AHB_IOP = Field<0, 4>;    // AHB_IOP
            using AF_SIZE = Field<4, 4>;    // AF_SIZE
            using SPEED_CFG = Field<8, 4>;    // SPEED_CFG
            using LOCK_CFG = Field<12, 4>;    // LOCK_CFG
            using SEC_CFG = Field<16, 4>;    // SEC_CFG
            using OR_CFG = Field<20, 4>;    // OR_CFG
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOI_HWCFGR9 : public RegisterReadOnly<0x5000a3cc> {
            using EN_IO = Field<0, 16>;    // EN_IO
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOI_HWCFGR8 : public RegisterReadOnly<0x5000a3d0> {
            using AF_PRIO8 = Field<0, 4>;    // AF_PRIO8
            using AF_PRIO9 = Field<4, 4>;    // AF_PRIO9
            using AF_PRIO10 = Field<8, 4>;    // AF_PRIO10
            using AF_PRIO11 = Field<12, 4>;    // AF_PRIO11
            using AF_PRIO12 = Field<16, 4>;    // AF_PRIO12
            using AF_PRIO13 = Field<20, 4>;    // AF_PRIO13
            using AF_PRIO14 = Field<24, 4>;    // AF_PRIO14
            using AF_PRIO15 = Field<28, 4>;    // AF_PRIO15
        };

        // GPIO hardware configuration register 7
        struct GPIOI_HWCFGR7 : public RegisterReadOnly<0x5000a3d4> {
            using AF_PRIO0 = Field<0, 4>;    // AF_PRIO0
            using AF_PRIO1 = Field<4, 4>;    // AF_PRIO1
            using AF_PRIO2 = Field<8, 4>;    // AF_PRIO2
            using AF_PRIO3 = Field<12, 4>;    // AF_PRIO3
            using AF_PRIO4 = Field<16, 4>;    // AF_PRIO4
            using AF_PRIO5 = Field<20, 4>;    // AF_PRIO5
            using AF_PRIO6 = Field<24, 4>;    // AF_PRIO6
            using AF_PRIO7 = Field<28, 4>;    // AF_PRIO7
        };

        // GPIO hardware configuration register 6
        struct GPIOI_HWCFGR6 : public RegisterReadOnly<0x5000a3d8> {
            using MODER_RES = Field<0, 32>;    // MODER_RES
        };

        // GPIO hardware configuration register 5
        struct GPIOI_HWCFGR5 : public RegisterReadOnly<0x5000a3dc> {
            using PUPDR_RES = Field<0, 32>;    // PUPDR_RES
        };

        // GPIO hardware configuration register 4
        struct GPIOI_HWCFGR4 : public RegisterReadOnly<0x5000a3e0> {
            using OSPEED_RES = Field<0, 32>;    // OSPEED_RES
        };

        // GPIO hardware configuration register 3
        struct GPIOI_HWCFGR3 : public RegisterReadOnly<0x5000a3e4> {
            using ODR_RES = Field<0, 16>;    // ODR_RES
            using OTYPER_RES = Field<16, 16>;    // OTYPER_RES
        };

        // GPIO hardware configuration register 2
        struct GPIOI_HWCFGR2 : public RegisterReadOnly<0x5000a3e8> {
            using AFRL_RES = Field<0, 32>;    // AFRL_RES
        };

        // GPIO hardware configuration register 1
        struct GPIOI_HWCFGR1 : public RegisterReadOnly<0x5000a3ec> {
            using AFRH_RES = Field<0, 32>;    // AFRH_RES
        };

        // GPIO hardware configuration register 0
        struct GPIOI_HWCFGR0 : public RegisterReadOnly<0x5000a3f0> {
            using OR_RES = Field<0, 16>;    // OR_RES
        };

        // GPIO version register
        struct GPIOI_VERR : public RegisterReadOnly<0x5000a3f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // GPIO identification register
        struct GPIOI_IPIDR : public RegisterReadOnly<0x5000a3f8> {
            using IPIDR = Field<0, 32>;    // IPIDR
        };

        // GPIO size identification register
        struct GPIOI_SIDR : public RegisterReadOnly<0x5000a3fc> {
            using SIDR = Field<0, 32>;    // SIDR
        };

    };

    // GPIOJ
    struct GPIOJ {
        // GPIO port mode register
        struct GPIOJ_MODER : public Register<0x5000b000> {
            using MODER0 = Field<0, 2>;    // MODER0
            using MODER1 = Field<2, 2>;    // MODER1
            using MODER2 = Field<4, 2>;    // MODER2
            using MODER3 = Field<6, 2>;    // MODER3
            using MODER4 = Field<8, 2>;    // MODER4
            using MODER5 = Field<10, 2>;    // MODER5
            using MODER6 = Field<12, 2>;    // MODER6
            using MODER7 = Field<14, 2>;    // MODER7
            using MODER8 = Field<16, 2>;    // MODER8
            using MODER9 = Field<18, 2>;    // MODER9
            using MODER10 = Field<20, 2>;    // MODER10
            using MODER11 = Field<22, 2>;    // MODER11
            using MODER12 = Field<24, 2>;    // MODER12
            using MODER13 = Field<26, 2>;    // MODER13
            using MODER14 = Field<28, 2>;    // MODER14
            using MODER15 = Field<30, 2>;    // MODER15
        };

        // GPIO port output type register
        struct GPIOJ_OTYPER : public Register<0x5000b004> {
            using OT0 = Field<0, 1>;    // OT0
            using OT1 = Field<1, 1>;    // OT1
            using OT2 = Field<2, 1>;    // OT2
            using OT3 = Field<3, 1>;    // OT3
            using OT4 = Field<4, 1>;    // OT4
            using OT5 = Field<5, 1>;    // OT5
            using OT6 = Field<6, 1>;    // OT6
            using OT7 = Field<7, 1>;    // OT7
            using OT8 = Field<8, 1>;    // OT8
            using OT9 = Field<9, 1>;    // OT9
            using OT10 = Field<10, 1>;    // OT10
            using OT11 = Field<11, 1>;    // OT11
            using OT12 = Field<12, 1>;    // OT12
            using OT13 = Field<13, 1>;    // OT13
            using OT14 = Field<14, 1>;    // OT14
            using OT15 = Field<15, 1>;    // OT15
        };

        // GPIO port output speed register
        struct GPIOJ_OSPEEDR : public Register<0x5000b008> {
            using OSPEEDR0 = Field<0, 2>;    // OSPEEDR0
            using OSPEEDR1 = Field<2, 2>;    // OSPEEDR1
            using OSPEEDR2 = Field<4, 2>;    // OSPEEDR2
            using OSPEEDR3 = Field<6, 2>;    // OSPEEDR3
            using OSPEEDR4 = Field<8, 2>;    // OSPEEDR4
            using OSPEEDR5 = Field<10, 2>;    // OSPEEDR5
            using OSPEEDR6 = Field<12, 2>;    // OSPEEDR6
            using OSPEEDR7 = Field<14, 2>;    // OSPEEDR7
            using OSPEEDR8 = Field<16, 2>;    // OSPEEDR8
            using OSPEEDR9 = Field<18, 2>;    // OSPEEDR9
            using OSPEEDR10 = Field<20, 2>;    // OSPEEDR10
            using OSPEEDR11 = Field<22, 2>;    // OSPEEDR11
            using OSPEEDR12 = Field<24, 2>;    // OSPEEDR12
            using OSPEEDR13 = Field<26, 2>;    // OSPEEDR13
            using OSPEEDR14 = Field<28, 2>;    // OSPEEDR14
            using OSPEEDR15 = Field<30, 2>;    // OSPEEDR15
        };

        // GPIO port pull-up/pull-down register
        struct GPIOJ_PUPDR : public Register<0x5000b00c> {
            using PUPDR0 = Field<0, 2>;    // PUPDR0
            using PUPDR1 = Field<2, 2>;    // PUPDR1
            using PUPDR2 = Field<4, 2>;    // PUPDR2
            using PUPDR3 = Field<6, 2>;    // PUPDR3
            using PUPDR4 = Field<8, 2>;    // PUPDR4
            using PUPDR5 = Field<10, 2>;    // PUPDR5
            using PUPDR6 = Field<12, 2>;    // PUPDR6
            using PUPDR7 = Field<14, 2>;    // PUPDR7
            using PUPDR8 = Field<16, 2>;    // PUPDR8
            using PUPDR9 = Field<18, 2>;    // PUPDR9
            using PUPDR10 = Field<20, 2>;    // PUPDR10
            using PUPDR11 = Field<22, 2>;    // PUPDR11
            using PUPDR12 = Field<24, 2>;    // PUPDR12
            using PUPDR13 = Field<26, 2>;    // PUPDR13
            using PUPDR14 = Field<28, 2>;    // PUPDR14
            using PUPDR15 = Field<30, 2>;    // PUPDR15
        };

        // GPIO port input data register
        struct GPIOJ_IDR : public RegisterReadOnly<0x5000b010> {
            using IDR0 = Field<0, 1>;    // IDR0
            using IDR1 = Field<1, 1>;    // IDR1
            using IDR2 = Field<2, 1>;    // IDR2
            using IDR3 = Field<3, 1>;    // IDR3
            using IDR4 = Field<4, 1>;    // IDR4
            using IDR5 = Field<5, 1>;    // IDR5
            using IDR6 = Field<6, 1>;    // IDR6
            using IDR7 = Field<7, 1>;    // IDR7
            using IDR8 = Field<8, 1>;    // IDR8
            using IDR9 = Field<9, 1>;    // IDR9
            using IDR10 = Field<10, 1>;    // IDR10
            using IDR11 = Field<11, 1>;    // IDR11
            using IDR12 = Field<12, 1>;    // IDR12
            using IDR13 = Field<13, 1>;    // IDR13
            using IDR14 = Field<14, 1>;    // IDR14
            using IDR15 = Field<15, 1>;    // IDR15
        };

        // GPIO port output data register
        struct GPIOJ_ODR : public Register<0x5000b014> {
            using ODR0 = Field<0, 1>;    // ODR0
            using ODR1 = Field<1, 1>;    // ODR1
            using ODR2 = Field<2, 1>;    // ODR2
            using ODR3 = Field<3, 1>;    // ODR3
            using ODR4 = Field<4, 1>;    // ODR4
            using ODR5 = Field<5, 1>;    // ODR5
            using ODR6 = Field<6, 1>;    // ODR6
            using ODR7 = Field<7, 1>;    // ODR7
            using ODR8 = Field<8, 1>;    // ODR8
            using ODR9 = Field<9, 1>;    // ODR9
            using ODR10 = Field<10, 1>;    // ODR10
            using ODR11 = Field<11, 1>;    // ODR11
            using ODR12 = Field<12, 1>;    // ODR12
            using ODR13 = Field<13, 1>;    // ODR13
            using ODR14 = Field<14, 1>;    // ODR14
            using ODR15 = Field<15, 1>;    // ODR15
        };

        // GPIO port bit set/reset register
        struct GPIOJ_BSRR : public RegisterWriteOnly<0x5000b018> {
            using BS0 = Field<0, 1>;    // BS0
            using BS1 = Field<1, 1>;    // BS1
            using BS2 = Field<2, 1>;    // BS2
            using BS3 = Field<3, 1>;    // BS3
            using BS4 = Field<4, 1>;    // BS4
            using BS5 = Field<5, 1>;    // BS5
            using BS6 = Field<6, 1>;    // BS6
            using BS7 = Field<7, 1>;    // BS7
            using BS8 = Field<8, 1>;    // BS8
            using BS9 = Field<9, 1>;    // BS9
            using BS10 = Field<10, 1>;    // BS10
            using BS11 = Field<11, 1>;    // BS11
            using BS12 = Field<12, 1>;    // BS12
            using BS13 = Field<13, 1>;    // BS13
            using BS14 = Field<14, 1>;    // BS14
            using BS15 = Field<15, 1>;    // BS15
            using BR0 = Field<16, 1>;    // BR0
            using BR1 = Field<17, 1>;    // BR1
            using BR2 = Field<18, 1>;    // BR2
            using BR3 = Field<19, 1>;    // BR3
            using BR4 = Field<20, 1>;    // BR4
            using BR5 = Field<21, 1>;    // BR5
            using BR6 = Field<22, 1>;    // BR6
            using BR7 = Field<23, 1>;    // BR7
            using BR8 = Field<24, 1>;    // BR8
            using BR9 = Field<25, 1>;    // BR9
            using BR10 = Field<26, 1>;    // BR10
            using BR11 = Field<27, 1>;    // BR11
            using BR12 = Field<28, 1>;    // BR12
            using BR13 = Field<29, 1>;    // BR13
            using BR14 = Field<30, 1>;    // BR14
            using BR15 = Field<31, 1>;    // BR15
        };

        // This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
        struct GPIOJ_LCKR : public Register<0x5000b01c> {
            using LCK0 = Field<0, 1>;    // LCK0
            using LCK1 = Field<1, 1>;    // LCK1
            using LCK2 = Field<2, 1>;    // LCK2
            using LCK3 = Field<3, 1>;    // LCK3
            using LCK4 = Field<4, 1>;    // LCK4
            using LCK5 = Field<5, 1>;    // LCK5
            using LCK6 = Field<6, 1>;    // LCK6
            using LCK7 = Field<7, 1>;    // LCK7
            using LCK8 = Field<8, 1>;    // LCK8
            using LCK9 = Field<9, 1>;    // LCK9
            using LCK10 = Field<10, 1>;    // LCK10
            using LCK11 = Field<11, 1>;    // LCK11
            using LCK12 = Field<12, 1>;    // LCK12
            using LCK13 = Field<13, 1>;    // LCK13
            using LCK14 = Field<14, 1>;    // LCK14
            using LCK15 = Field<15, 1>;    // LCK15
            using LCKK = Field<16, 1>;    // LCKK
        };

        // GPIO alternate function low register
        struct GPIOJ_AFRL : public Register<0x5000b020> {
            using AFR0 = Field<0, 4>;    // AFR0
            using AFR1 = Field<4, 4>;    // AFR1
            using AFR2 = Field<8, 4>;    // AFR2
            using AFR3 = Field<12, 4>;    // AFR3
            using AFR4 = Field<16, 4>;    // AFR4
            using AFR5 = Field<20, 4>;    // AFR5
            using AFR6 = Field<24, 4>;    // AFR6
            using AFR7 = Field<28, 4>;    // AFR7
        };

        // GPIO alternate function high register
        struct GPIOJ_AFRH : public Register<0x5000b024> {
            using AFR8 = Field<0, 4>;    // AFR8
            using AFR9 = Field<4, 4>;    // AFR9
            using AFR10 = Field<8, 4>;    // AFR10
            using AFR11 = Field<12, 4>;    // AFR11
            using AFR12 = Field<16, 4>;    // AFR12
            using AFR13 = Field<20, 4>;    // AFR13
            using AFR14 = Field<24, 4>;    // AFR14
            using AFR15 = Field<28, 4>;    // AFR15
        };

        // GPIO port bit reset register
        struct GPIOJ_BRR : public RegisterWriteOnly<0x5000b028> {
            using BR0 = Field<0, 1>;    // BR0
            using BR1 = Field<1, 1>;    // BR1
            using BR2 = Field<2, 1>;    // BR2
            using BR3 = Field<3, 1>;    // BR3
            using BR4 = Field<4, 1>;    // BR4
            using BR5 = Field<5, 1>;    // BR5
            using BR6 = Field<6, 1>;    // BR6
            using BR7 = Field<7, 1>;    // BR7
            using BR8 = Field<8, 1>;    // BR8
            using BR9 = Field<9, 1>;    // BR9
            using BR10 = Field<10, 1>;    // BR10
            using BR11 = Field<11, 1>;    // BR11
            using BR12 = Field<12, 1>;    // BR12
            using BR13 = Field<13, 1>;    // BR13
            using BR14 = Field<14, 1>;    // BR14
            using BR15 = Field<15, 1>;    // BR15
        };

        // For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
        struct GPIOJ_HWCFGR10 : public RegisterReadOnly<0x5000b3c8> {
            using AHB_IOP = Field<0, 4>;    // AHB_IOP
            using AF_SIZE = Field<4, 4>;    // AF_SIZE
            using SPEED_CFG = Field<8, 4>;    // SPEED_CFG
            using LOCK_CFG = Field<12, 4>;    // LOCK_CFG
            using SEC_CFG = Field<16, 4>;    // SEC_CFG
            using OR_CFG = Field<20, 4>;    // OR_CFG
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOJ_HWCFGR9 : public RegisterReadOnly<0x5000b3cc> {
            using EN_IO = Field<0, 16>;    // EN_IO
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOJ_HWCFGR8 : public RegisterReadOnly<0x5000b3d0> {
            using AF_PRIO8 = Field<0, 4>;    // AF_PRIO8
            using AF_PRIO9 = Field<4, 4>;    // AF_PRIO9
            using AF_PRIO10 = Field<8, 4>;    // AF_PRIO10
            using AF_PRIO11 = Field<12, 4>;    // AF_PRIO11
            using AF_PRIO12 = Field<16, 4>;    // AF_PRIO12
            using AF_PRIO13 = Field<20, 4>;    // AF_PRIO13
            using AF_PRIO14 = Field<24, 4>;    // AF_PRIO14
            using AF_PRIO15 = Field<28, 4>;    // AF_PRIO15
        };

        // GPIO hardware configuration register 7
        struct GPIOJ_HWCFGR7 : public RegisterReadOnly<0x5000b3d4> {
            using AF_PRIO0 = Field<0, 4>;    // AF_PRIO0
            using AF_PRIO1 = Field<4, 4>;    // AF_PRIO1
            using AF_PRIO2 = Field<8, 4>;    // AF_PRIO2
            using AF_PRIO3 = Field<12, 4>;    // AF_PRIO3
            using AF_PRIO4 = Field<16, 4>;    // AF_PRIO4
            using AF_PRIO5 = Field<20, 4>;    // AF_PRIO5
            using AF_PRIO6 = Field<24, 4>;    // AF_PRIO6
            using AF_PRIO7 = Field<28, 4>;    // AF_PRIO7
        };

        // GPIO hardware configuration register 6
        struct GPIOJ_HWCFGR6 : public RegisterReadOnly<0x5000b3d8> {
            using MODER_RES = Field<0, 32>;    // MODER_RES
        };

        // GPIO hardware configuration register 5
        struct GPIOJ_HWCFGR5 : public RegisterReadOnly<0x5000b3dc> {
            using PUPDR_RES = Field<0, 32>;    // PUPDR_RES
        };

        // GPIO hardware configuration register 4
        struct GPIOJ_HWCFGR4 : public RegisterReadOnly<0x5000b3e0> {
            using OSPEED_RES = Field<0, 32>;    // OSPEED_RES
        };

        // GPIO hardware configuration register 3
        struct GPIOJ_HWCFGR3 : public RegisterReadOnly<0x5000b3e4> {
            using ODR_RES = Field<0, 16>;    // ODR_RES
            using OTYPER_RES = Field<16, 16>;    // OTYPER_RES
        };

        // GPIO hardware configuration register 2
        struct GPIOJ_HWCFGR2 : public RegisterReadOnly<0x5000b3e8> {
            using AFRL_RES = Field<0, 32>;    // AFRL_RES
        };

        // GPIO hardware configuration register 1
        struct GPIOJ_HWCFGR1 : public RegisterReadOnly<0x5000b3ec> {
            using AFRH_RES = Field<0, 32>;    // AFRH_RES
        };

        // GPIO hardware configuration register 0
        struct GPIOJ_HWCFGR0 : public RegisterReadOnly<0x5000b3f0> {
            using OR_RES = Field<0, 16>;    // OR_RES
        };

        // GPIO version register
        struct GPIOJ_VERR : public RegisterReadOnly<0x5000b3f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // GPIO identification register
        struct GPIOJ_IPIDR : public RegisterReadOnly<0x5000b3f8> {
            using IPIDR = Field<0, 32>;    // IPIDR
        };

        // GPIO size identification register
        struct GPIOJ_SIDR : public RegisterReadOnly<0x5000b3fc> {
            using SIDR = Field<0, 32>;    // SIDR
        };

    };

    // GPIOK
    struct GPIOK {
        // GPIO port mode register
        struct GPIOK_MODER : public Register<0x5000c000> {
            using MODER0 = Field<0, 2>;    // MODER0
            using MODER1 = Field<2, 2>;    // MODER1
            using MODER2 = Field<4, 2>;    // MODER2
            using MODER3 = Field<6, 2>;    // MODER3
            using MODER4 = Field<8, 2>;    // MODER4
            using MODER5 = Field<10, 2>;    // MODER5
            using MODER6 = Field<12, 2>;    // MODER6
            using MODER7 = Field<14, 2>;    // MODER7
            using MODER8 = Field<16, 2>;    // MODER8
            using MODER9 = Field<18, 2>;    // MODER9
            using MODER10 = Field<20, 2>;    // MODER10
            using MODER11 = Field<22, 2>;    // MODER11
            using MODER12 = Field<24, 2>;    // MODER12
            using MODER13 = Field<26, 2>;    // MODER13
            using MODER14 = Field<28, 2>;    // MODER14
            using MODER15 = Field<30, 2>;    // MODER15
        };

        // GPIO port output type register
        struct GPIOK_OTYPER : public Register<0x5000c004> {
            using OT0 = Field<0, 1>;    // OT0
            using OT1 = Field<1, 1>;    // OT1
            using OT2 = Field<2, 1>;    // OT2
            using OT3 = Field<3, 1>;    // OT3
            using OT4 = Field<4, 1>;    // OT4
            using OT5 = Field<5, 1>;    // OT5
            using OT6 = Field<6, 1>;    // OT6
            using OT7 = Field<7, 1>;    // OT7
            using OT8 = Field<8, 1>;    // OT8
            using OT9 = Field<9, 1>;    // OT9
            using OT10 = Field<10, 1>;    // OT10
            using OT11 = Field<11, 1>;    // OT11
            using OT12 = Field<12, 1>;    // OT12
            using OT13 = Field<13, 1>;    // OT13
            using OT14 = Field<14, 1>;    // OT14
            using OT15 = Field<15, 1>;    // OT15
        };

        // GPIO port output speed register
        struct GPIOK_OSPEEDR : public Register<0x5000c008> {
            using OSPEEDR0 = Field<0, 2>;    // OSPEEDR0
            using OSPEEDR1 = Field<2, 2>;    // OSPEEDR1
            using OSPEEDR2 = Field<4, 2>;    // OSPEEDR2
            using OSPEEDR3 = Field<6, 2>;    // OSPEEDR3
            using OSPEEDR4 = Field<8, 2>;    // OSPEEDR4
            using OSPEEDR5 = Field<10, 2>;    // OSPEEDR5
            using OSPEEDR6 = Field<12, 2>;    // OSPEEDR6
            using OSPEEDR7 = Field<14, 2>;    // OSPEEDR7
            using OSPEEDR8 = Field<16, 2>;    // OSPEEDR8
            using OSPEEDR9 = Field<18, 2>;    // OSPEEDR9
            using OSPEEDR10 = Field<20, 2>;    // OSPEEDR10
            using OSPEEDR11 = Field<22, 2>;    // OSPEEDR11
            using OSPEEDR12 = Field<24, 2>;    // OSPEEDR12
            using OSPEEDR13 = Field<26, 2>;    // OSPEEDR13
            using OSPEEDR14 = Field<28, 2>;    // OSPEEDR14
            using OSPEEDR15 = Field<30, 2>;    // OSPEEDR15
        };

        // GPIO port pull-up/pull-down register
        struct GPIOK_PUPDR : public Register<0x5000c00c> {
            using PUPDR0 = Field<0, 2>;    // PUPDR0
            using PUPDR1 = Field<2, 2>;    // PUPDR1
            using PUPDR2 = Field<4, 2>;    // PUPDR2
            using PUPDR3 = Field<6, 2>;    // PUPDR3
            using PUPDR4 = Field<8, 2>;    // PUPDR4
            using PUPDR5 = Field<10, 2>;    // PUPDR5
            using PUPDR6 = Field<12, 2>;    // PUPDR6
            using PUPDR7 = Field<14, 2>;    // PUPDR7
            using PUPDR8 = Field<16, 2>;    // PUPDR8
            using PUPDR9 = Field<18, 2>;    // PUPDR9
            using PUPDR10 = Field<20, 2>;    // PUPDR10
            using PUPDR11 = Field<22, 2>;    // PUPDR11
            using PUPDR12 = Field<24, 2>;    // PUPDR12
            using PUPDR13 = Field<26, 2>;    // PUPDR13
            using PUPDR14 = Field<28, 2>;    // PUPDR14
            using PUPDR15 = Field<30, 2>;    // PUPDR15
        };

        // GPIO port input data register
        struct GPIOK_IDR : public RegisterReadOnly<0x5000c010> {
            using IDR0 = Field<0, 1>;    // IDR0
            using IDR1 = Field<1, 1>;    // IDR1
            using IDR2 = Field<2, 1>;    // IDR2
            using IDR3 = Field<3, 1>;    // IDR3
            using IDR4 = Field<4, 1>;    // IDR4
            using IDR5 = Field<5, 1>;    // IDR5
            using IDR6 = Field<6, 1>;    // IDR6
            using IDR7 = Field<7, 1>;    // IDR7
            using IDR8 = Field<8, 1>;    // IDR8
            using IDR9 = Field<9, 1>;    // IDR9
            using IDR10 = Field<10, 1>;    // IDR10
            using IDR11 = Field<11, 1>;    // IDR11
            using IDR12 = Field<12, 1>;    // IDR12
            using IDR13 = Field<13, 1>;    // IDR13
            using IDR14 = Field<14, 1>;    // IDR14
            using IDR15 = Field<15, 1>;    // IDR15
        };

        // GPIO port output data register
        struct GPIOK_ODR : public Register<0x5000c014> {
            using ODR0 = Field<0, 1>;    // ODR0
            using ODR1 = Field<1, 1>;    // ODR1
            using ODR2 = Field<2, 1>;    // ODR2
            using ODR3 = Field<3, 1>;    // ODR3
            using ODR4 = Field<4, 1>;    // ODR4
            using ODR5 = Field<5, 1>;    // ODR5
            using ODR6 = Field<6, 1>;    // ODR6
            using ODR7 = Field<7, 1>;    // ODR7
            using ODR8 = Field<8, 1>;    // ODR8
            using ODR9 = Field<9, 1>;    // ODR9
            using ODR10 = Field<10, 1>;    // ODR10
            using ODR11 = Field<11, 1>;    // ODR11
            using ODR12 = Field<12, 1>;    // ODR12
            using ODR13 = Field<13, 1>;    // ODR13
            using ODR14 = Field<14, 1>;    // ODR14
            using ODR15 = Field<15, 1>;    // ODR15
        };

        // GPIO port bit set/reset register
        struct GPIOK_BSRR : public RegisterWriteOnly<0x5000c018> {
            using BS0 = Field<0, 1>;    // BS0
            using BS1 = Field<1, 1>;    // BS1
            using BS2 = Field<2, 1>;    // BS2
            using BS3 = Field<3, 1>;    // BS3
            using BS4 = Field<4, 1>;    // BS4
            using BS5 = Field<5, 1>;    // BS5
            using BS6 = Field<6, 1>;    // BS6
            using BS7 = Field<7, 1>;    // BS7
            using BS8 = Field<8, 1>;    // BS8
            using BS9 = Field<9, 1>;    // BS9
            using BS10 = Field<10, 1>;    // BS10
            using BS11 = Field<11, 1>;    // BS11
            using BS12 = Field<12, 1>;    // BS12
            using BS13 = Field<13, 1>;    // BS13
            using BS14 = Field<14, 1>;    // BS14
            using BS15 = Field<15, 1>;    // BS15
            using BR0 = Field<16, 1>;    // BR0
            using BR1 = Field<17, 1>;    // BR1
            using BR2 = Field<18, 1>;    // BR2
            using BR3 = Field<19, 1>;    // BR3
            using BR4 = Field<20, 1>;    // BR4
            using BR5 = Field<21, 1>;    // BR5
            using BR6 = Field<22, 1>;    // BR6
            using BR7 = Field<23, 1>;    // BR7
            using BR8 = Field<24, 1>;    // BR8
            using BR9 = Field<25, 1>;    // BR9
            using BR10 = Field<26, 1>;    // BR10
            using BR11 = Field<27, 1>;    // BR11
            using BR12 = Field<28, 1>;    // BR12
            using BR13 = Field<29, 1>;    // BR13
            using BR14 = Field<30, 1>;    // BR14
            using BR15 = Field<31, 1>;    // BR15
        };

        // This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
        struct GPIOK_LCKR : public Register<0x5000c01c> {
            using LCK0 = Field<0, 1>;    // LCK0
            using LCK1 = Field<1, 1>;    // LCK1
            using LCK2 = Field<2, 1>;    // LCK2
            using LCK3 = Field<3, 1>;    // LCK3
            using LCK4 = Field<4, 1>;    // LCK4
            using LCK5 = Field<5, 1>;    // LCK5
            using LCK6 = Field<6, 1>;    // LCK6
            using LCK7 = Field<7, 1>;    // LCK7
            using LCK8 = Field<8, 1>;    // LCK8
            using LCK9 = Field<9, 1>;    // LCK9
            using LCK10 = Field<10, 1>;    // LCK10
            using LCK11 = Field<11, 1>;    // LCK11
            using LCK12 = Field<12, 1>;    // LCK12
            using LCK13 = Field<13, 1>;    // LCK13
            using LCK14 = Field<14, 1>;    // LCK14
            using LCK15 = Field<15, 1>;    // LCK15
            using LCKK = Field<16, 1>;    // LCKK
        };

        // GPIO alternate function low register
        struct GPIOK_AFRL : public Register<0x5000c020> {
            using AFR0 = Field<0, 4>;    // AFR0
            using AFR1 = Field<4, 4>;    // AFR1
            using AFR2 = Field<8, 4>;    // AFR2
            using AFR3 = Field<12, 4>;    // AFR3
            using AFR4 = Field<16, 4>;    // AFR4
            using AFR5 = Field<20, 4>;    // AFR5
            using AFR6 = Field<24, 4>;    // AFR6
            using AFR7 = Field<28, 4>;    // AFR7
        };

        // GPIO alternate function high register
        struct GPIOK_AFRH : public Register<0x5000c024> {
            using AFR8 = Field<0, 4>;    // AFR8
            using AFR9 = Field<4, 4>;    // AFR9
            using AFR10 = Field<8, 4>;    // AFR10
            using AFR11 = Field<12, 4>;    // AFR11
            using AFR12 = Field<16, 4>;    // AFR12
            using AFR13 = Field<20, 4>;    // AFR13
            using AFR14 = Field<24, 4>;    // AFR14
            using AFR15 = Field<28, 4>;    // AFR15
        };

        // GPIO port bit reset register
        struct GPIOK_BRR : public RegisterWriteOnly<0x5000c028> {
            using BR0 = Field<0, 1>;    // BR0
            using BR1 = Field<1, 1>;    // BR1
            using BR2 = Field<2, 1>;    // BR2
            using BR3 = Field<3, 1>;    // BR3
            using BR4 = Field<4, 1>;    // BR4
            using BR5 = Field<5, 1>;    // BR5
            using BR6 = Field<6, 1>;    // BR6
            using BR7 = Field<7, 1>;    // BR7
            using BR8 = Field<8, 1>;    // BR8
            using BR9 = Field<9, 1>;    // BR9
            using BR10 = Field<10, 1>;    // BR10
            using BR11 = Field<11, 1>;    // BR11
            using BR12 = Field<12, 1>;    // BR12
            using BR13 = Field<13, 1>;    // BR13
            using BR14 = Field<14, 1>;    // BR14
            using BR15 = Field<15, 1>;    // BR15
        };

        // For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
        struct GPIOK_HWCFGR10 : public RegisterReadOnly<0x5000c3c8> {
            using AHB_IOP = Field<0, 4>;    // AHB_IOP
            using AF_SIZE = Field<4, 4>;    // AF_SIZE
            using SPEED_CFG = Field<8, 4>;    // SPEED_CFG
            using LOCK_CFG = Field<12, 4>;    // LOCK_CFG
            using SEC_CFG = Field<16, 4>;    // SEC_CFG
            using OR_CFG = Field<20, 4>;    // OR_CFG
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOK_HWCFGR9 : public RegisterReadOnly<0x5000c3cc> {
            using EN_IO = Field<0, 16>;    // EN_IO
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOK_HWCFGR8 : public RegisterReadOnly<0x5000c3d0> {
            using AF_PRIO8 = Field<0, 4>;    // AF_PRIO8
            using AF_PRIO9 = Field<4, 4>;    // AF_PRIO9
            using AF_PRIO10 = Field<8, 4>;    // AF_PRIO10
            using AF_PRIO11 = Field<12, 4>;    // AF_PRIO11
            using AF_PRIO12 = Field<16, 4>;    // AF_PRIO12
            using AF_PRIO13 = Field<20, 4>;    // AF_PRIO13
            using AF_PRIO14 = Field<24, 4>;    // AF_PRIO14
            using AF_PRIO15 = Field<28, 4>;    // AF_PRIO15
        };

        // GPIO hardware configuration register 7
        struct GPIOK_HWCFGR7 : public RegisterReadOnly<0x5000c3d4> {
            using AF_PRIO0 = Field<0, 4>;    // AF_PRIO0
            using AF_PRIO1 = Field<4, 4>;    // AF_PRIO1
            using AF_PRIO2 = Field<8, 4>;    // AF_PRIO2
            using AF_PRIO3 = Field<12, 4>;    // AF_PRIO3
            using AF_PRIO4 = Field<16, 4>;    // AF_PRIO4
            using AF_PRIO5 = Field<20, 4>;    // AF_PRIO5
            using AF_PRIO6 = Field<24, 4>;    // AF_PRIO6
            using AF_PRIO7 = Field<28, 4>;    // AF_PRIO7
        };

        // GPIO hardware configuration register 6
        struct GPIOK_HWCFGR6 : public RegisterReadOnly<0x5000c3d8> {
            using MODER_RES = Field<0, 32>;    // MODER_RES
        };

        // GPIO hardware configuration register 5
        struct GPIOK_HWCFGR5 : public RegisterReadOnly<0x5000c3dc> {
            using PUPDR_RES = Field<0, 32>;    // PUPDR_RES
        };

        // GPIO hardware configuration register 4
        struct GPIOK_HWCFGR4 : public RegisterReadOnly<0x5000c3e0> {
            using OSPEED_RES = Field<0, 32>;    // OSPEED_RES
        };

        // GPIO hardware configuration register 3
        struct GPIOK_HWCFGR3 : public RegisterReadOnly<0x5000c3e4> {
            using ODR_RES = Field<0, 16>;    // ODR_RES
            using OTYPER_RES = Field<16, 16>;    // OTYPER_RES
        };

        // GPIO hardware configuration register 2
        struct GPIOK_HWCFGR2 : public RegisterReadOnly<0x5000c3e8> {
            using AFRL_RES = Field<0, 32>;    // AFRL_RES
        };

        // GPIO hardware configuration register 1
        struct GPIOK_HWCFGR1 : public RegisterReadOnly<0x5000c3ec> {
            using AFRH_RES = Field<0, 32>;    // AFRH_RES
        };

        // GPIO hardware configuration register 0
        struct GPIOK_HWCFGR0 : public RegisterReadOnly<0x5000c3f0> {
            using OR_RES = Field<0, 16>;    // OR_RES
        };

        // GPIO version register
        struct GPIOK_VERR : public RegisterReadOnly<0x5000c3f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // GPIO identification register
        struct GPIOK_IPIDR : public RegisterReadOnly<0x5000c3f8> {
            using IPIDR = Field<0, 32>;    // IPIDR
        };

        // GPIO size identification register
        struct GPIOK_SIDR : public RegisterReadOnly<0x5000c3fc> {
            using SIDR = Field<0, 32>;    // SIDR
        };

    };

    // GPIOZ
    struct GPIOZ {
        // GPIO port mode register
        struct GPIOZ_MODER : public Register<0x54004000> {
            using MODER0 = Field<0, 2>;    // MODER0
            using MODER1 = Field<2, 2>;    // MODER1
            using MODER2 = Field<4, 2>;    // MODER2
            using MODER3 = Field<6, 2>;    // MODER3
            using MODER4 = Field<8, 2>;    // MODER4
            using MODER5 = Field<10, 2>;    // MODER5
            using MODER6 = Field<12, 2>;    // MODER6
            using MODER7 = Field<14, 2>;    // MODER7
            using MODER8 = Field<16, 2>;    // MODER8
            using MODER9 = Field<18, 2>;    // MODER9
            using MODER10 = Field<20, 2>;    // MODER10
            using MODER11 = Field<22, 2>;    // MODER11
            using MODER12 = Field<24, 2>;    // MODER12
            using MODER13 = Field<26, 2>;    // MODER13
            using MODER14 = Field<28, 2>;    // MODER14
            using MODER15 = Field<30, 2>;    // MODER15
        };

        // GPIO port output type register
        struct GPIOZ_OTYPER : public Register<0x54004004> {
            using OT0 = Field<0, 1>;    // OT0
            using OT1 = Field<1, 1>;    // OT1
            using OT2 = Field<2, 1>;    // OT2
            using OT3 = Field<3, 1>;    // OT3
            using OT4 = Field<4, 1>;    // OT4
            using OT5 = Field<5, 1>;    // OT5
            using OT6 = Field<6, 1>;    // OT6
            using OT7 = Field<7, 1>;    // OT7
            using OT8 = Field<8, 1>;    // OT8
            using OT9 = Field<9, 1>;    // OT9
            using OT10 = Field<10, 1>;    // OT10
            using OT11 = Field<11, 1>;    // OT11
            using OT12 = Field<12, 1>;    // OT12
            using OT13 = Field<13, 1>;    // OT13
            using OT14 = Field<14, 1>;    // OT14
            using OT15 = Field<15, 1>;    // OT15
        };

        // GPIO port output speed register
        struct GPIOZ_OSPEEDR : public Register<0x54004008> {
            using OSPEEDR0 = Field<0, 2>;    // OSPEEDR0
            using OSPEEDR1 = Field<2, 2>;    // OSPEEDR1
            using OSPEEDR2 = Field<4, 2>;    // OSPEEDR2
            using OSPEEDR3 = Field<6, 2>;    // OSPEEDR3
            using OSPEEDR4 = Field<8, 2>;    // OSPEEDR4
            using OSPEEDR5 = Field<10, 2>;    // OSPEEDR5
            using OSPEEDR6 = Field<12, 2>;    // OSPEEDR6
            using OSPEEDR7 = Field<14, 2>;    // OSPEEDR7
            using OSPEEDR8 = Field<16, 2>;    // OSPEEDR8
            using OSPEEDR9 = Field<18, 2>;    // OSPEEDR9
            using OSPEEDR10 = Field<20, 2>;    // OSPEEDR10
            using OSPEEDR11 = Field<22, 2>;    // OSPEEDR11
            using OSPEEDR12 = Field<24, 2>;    // OSPEEDR12
            using OSPEEDR13 = Field<26, 2>;    // OSPEEDR13
            using OSPEEDR14 = Field<28, 2>;    // OSPEEDR14
            using OSPEEDR15 = Field<30, 2>;    // OSPEEDR15
        };

        // GPIO port pull-up/pull-down register
        struct GPIOZ_PUPDR : public Register<0x5400400c> {
            using PUPDR0 = Field<0, 2>;    // PUPDR0
            using PUPDR1 = Field<2, 2>;    // PUPDR1
            using PUPDR2 = Field<4, 2>;    // PUPDR2
            using PUPDR3 = Field<6, 2>;    // PUPDR3
            using PUPDR4 = Field<8, 2>;    // PUPDR4
            using PUPDR5 = Field<10, 2>;    // PUPDR5
            using PUPDR6 = Field<12, 2>;    // PUPDR6
            using PUPDR7 = Field<14, 2>;    // PUPDR7
            using PUPDR8 = Field<16, 2>;    // PUPDR8
            using PUPDR9 = Field<18, 2>;    // PUPDR9
            using PUPDR10 = Field<20, 2>;    // PUPDR10
            using PUPDR11 = Field<22, 2>;    // PUPDR11
            using PUPDR12 = Field<24, 2>;    // PUPDR12
            using PUPDR13 = Field<26, 2>;    // PUPDR13
            using PUPDR14 = Field<28, 2>;    // PUPDR14
            using PUPDR15 = Field<30, 2>;    // PUPDR15
        };

        // GPIO port input data register
        struct GPIOZ_IDR : public RegisterReadOnly<0x54004010> {
            using IDR0 = Field<0, 1>;    // IDR0
            using IDR1 = Field<1, 1>;    // IDR1
            using IDR2 = Field<2, 1>;    // IDR2
            using IDR3 = Field<3, 1>;    // IDR3
            using IDR4 = Field<4, 1>;    // IDR4
            using IDR5 = Field<5, 1>;    // IDR5
            using IDR6 = Field<6, 1>;    // IDR6
            using IDR7 = Field<7, 1>;    // IDR7
            using IDR8 = Field<8, 1>;    // IDR8
            using IDR9 = Field<9, 1>;    // IDR9
            using IDR10 = Field<10, 1>;    // IDR10
            using IDR11 = Field<11, 1>;    // IDR11
            using IDR12 = Field<12, 1>;    // IDR12
            using IDR13 = Field<13, 1>;    // IDR13
            using IDR14 = Field<14, 1>;    // IDR14
            using IDR15 = Field<15, 1>;    // IDR15
        };

        // GPIO port output data register
        struct GPIOZ_ODR : public Register<0x54004014> {
            using ODR0 = Field<0, 1>;    // ODR0
            using ODR1 = Field<1, 1>;    // ODR1
            using ODR2 = Field<2, 1>;    // ODR2
            using ODR3 = Field<3, 1>;    // ODR3
            using ODR4 = Field<4, 1>;    // ODR4
            using ODR5 = Field<5, 1>;    // ODR5
            using ODR6 = Field<6, 1>;    // ODR6
            using ODR7 = Field<7, 1>;    // ODR7
            using ODR8 = Field<8, 1>;    // ODR8
            using ODR9 = Field<9, 1>;    // ODR9
            using ODR10 = Field<10, 1>;    // ODR10
            using ODR11 = Field<11, 1>;    // ODR11
            using ODR12 = Field<12, 1>;    // ODR12
            using ODR13 = Field<13, 1>;    // ODR13
            using ODR14 = Field<14, 1>;    // ODR14
            using ODR15 = Field<15, 1>;    // ODR15
        };

        // GPIO port bit set/reset register
        struct GPIOZ_BSRR : public RegisterWriteOnly<0x54004018> {
            using BS0 = Field<0, 1>;    // BS0
            using BS1 = Field<1, 1>;    // BS1
            using BS2 = Field<2, 1>;    // BS2
            using BS3 = Field<3, 1>;    // BS3
            using BS4 = Field<4, 1>;    // BS4
            using BS5 = Field<5, 1>;    // BS5
            using BS6 = Field<6, 1>;    // BS6
            using BS7 = Field<7, 1>;    // BS7
            using BS8 = Field<8, 1>;    // BS8
            using BS9 = Field<9, 1>;    // BS9
            using BS10 = Field<10, 1>;    // BS10
            using BS11 = Field<11, 1>;    // BS11
            using BS12 = Field<12, 1>;    // BS12
            using BS13 = Field<13, 1>;    // BS13
            using BS14 = Field<14, 1>;    // BS14
            using BS15 = Field<15, 1>;    // BS15
            using BR0 = Field<16, 1>;    // BR0
            using BR1 = Field<17, 1>;    // BR1
            using BR2 = Field<18, 1>;    // BR2
            using BR3 = Field<19, 1>;    // BR3
            using BR4 = Field<20, 1>;    // BR4
            using BR5 = Field<21, 1>;    // BR5
            using BR6 = Field<22, 1>;    // BR6
            using BR7 = Field<23, 1>;    // BR7
            using BR8 = Field<24, 1>;    // BR8
            using BR9 = Field<25, 1>;    // BR9
            using BR10 = Field<26, 1>;    // BR10
            using BR11 = Field<27, 1>;    // BR11
            using BR12 = Field<28, 1>;    // BR12
            using BR13 = Field<29, 1>;    // BR13
            using BR14 = Field<30, 1>;    // BR14
            using BR15 = Field<31, 1>;    // BR15
        };

        // This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
        struct GPIOZ_LCKR : public Register<0x5400401c> {
            using LCK0 = Field<0, 1>;    // LCK0
            using LCK1 = Field<1, 1>;    // LCK1
            using LCK2 = Field<2, 1>;    // LCK2
            using LCK3 = Field<3, 1>;    // LCK3
            using LCK4 = Field<4, 1>;    // LCK4
            using LCK5 = Field<5, 1>;    // LCK5
            using LCK6 = Field<6, 1>;    // LCK6
            using LCK7 = Field<7, 1>;    // LCK7
            using LCK8 = Field<8, 1>;    // LCK8
            using LCK9 = Field<9, 1>;    // LCK9
            using LCK10 = Field<10, 1>;    // LCK10
            using LCK11 = Field<11, 1>;    // LCK11
            using LCK12 = Field<12, 1>;    // LCK12
            using LCK13 = Field<13, 1>;    // LCK13
            using LCK14 = Field<14, 1>;    // LCK14
            using LCK15 = Field<15, 1>;    // LCK15
            using LCKK = Field<16, 1>;    // LCKK
        };

        // GPIO alternate function low register
        struct GPIOZ_AFRL : public Register<0x54004020> {
            using AFR0 = Field<0, 4>;    // AFR0
            using AFR1 = Field<4, 4>;    // AFR1
            using AFR2 = Field<8, 4>;    // AFR2
            using AFR3 = Field<12, 4>;    // AFR3
            using AFR4 = Field<16, 4>;    // AFR4
            using AFR5 = Field<20, 4>;    // AFR5
            using AFR6 = Field<24, 4>;    // AFR6
            using AFR7 = Field<28, 4>;    // AFR7
        };

        // GPIO alternate function high register
        struct GPIOZ_AFRH : public Register<0x54004024> {
            using AFR8 = Field<0, 4>;    // AFR8
            using AFR9 = Field<4, 4>;    // AFR9
            using AFR10 = Field<8, 4>;    // AFR10
            using AFR11 = Field<12, 4>;    // AFR11
            using AFR12 = Field<16, 4>;    // AFR12
            using AFR13 = Field<20, 4>;    // AFR13
            using AFR14 = Field<24, 4>;    // AFR14
            using AFR15 = Field<28, 4>;    // AFR15
        };

        // GPIO port bit reset register
        struct GPIOZ_BRR : public RegisterWriteOnly<0x54004028> {
            using BR0 = Field<0, 1>;    // BR0
            using BR1 = Field<1, 1>;    // BR1
            using BR2 = Field<2, 1>;    // BR2
            using BR3 = Field<3, 1>;    // BR3
            using BR4 = Field<4, 1>;    // BR4
            using BR5 = Field<5, 1>;    // BR5
            using BR6 = Field<6, 1>;    // BR6
            using BR7 = Field<7, 1>;    // BR7
            using BR8 = Field<8, 1>;    // BR8
            using BR9 = Field<9, 1>;    // BR9
            using BR10 = Field<10, 1>;    // BR10
            using BR11 = Field<11, 1>;    // BR11
            using BR12 = Field<12, 1>;    // BR12
            using BR13 = Field<13, 1>;    // BR13
            using BR14 = Field<14, 1>;    // BR14
            using BR15 = Field<15, 1>;    // BR15
        };

        // This register provides write access security and can be written only by a secure access. It is used to configure a selected I/O as secure. A non-secure write access to this register is discarded.
        struct GPIOZ_SECCFGR : public RegisterWriteOnly<0x54004030> {
            using SEC0 = Field<0, 1>;    // SEC0
            using SEC1 = Field<1, 1>;    // SEC1
            using SEC2 = Field<2, 1>;    // SEC2
            using SEC3 = Field<3, 1>;    // SEC3
            using SEC4 = Field<4, 1>;    // SEC4
            using SEC5 = Field<5, 1>;    // SEC5
            using SEC6 = Field<6, 1>;    // SEC6
            using SEC7 = Field<7, 1>;    // SEC7
        };

        // For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
        struct GPIOZ_HWCFGR10 : public RegisterReadOnly<0x540043c8> {
            using AHB_IOP = Field<0, 4>;    // AHB_IOP
            using AF_SIZE = Field<4, 4>;    // AF_SIZE
            using SPEED_CFG = Field<8, 4>;    // SPEED_CFG
            using LOCK_CFG = Field<12, 4>;    // LOCK_CFG
            using SEC_CFG = Field<16, 4>;    // SEC_CFG
            using OR_CFG = Field<20, 4>;    // OR_CFG
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOZ_HWCFGR9 : public RegisterReadOnly<0x540043cc> {
            using EN_IO = Field<0, 16>;    // EN_IO
        };

        // For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
        struct GPIOZ_HWCFGR8 : public RegisterReadOnly<0x540043d0> {
            using AF_PRIO8 = Field<0, 4>;    // AF_PRIO8
            using AF_PRIO9 = Field<4, 4>;    // AF_PRIO9
            using AF_PRIO10 = Field<8, 4>;    // AF_PRIO10
            using AF_PRIO11 = Field<12, 4>;    // AF_PRIO11
            using AF_PRIO12 = Field<16, 4>;    // AF_PRIO12
            using AF_PRIO13 = Field<20, 4>;    // AF_PRIO13
            using AF_PRIO14 = Field<24, 4>;    // AF_PRIO14
            using AF_PRIO15 = Field<28, 4>;    // AF_PRIO15
        };

        // GPIO hardware configuration register 7
        struct GPIOZ_HWCFGR7 : public RegisterReadOnly<0x540043d4> {
            using AF_PRIO0 = Field<0, 4>;    // AF_PRIO0
            using AF_PRIO1 = Field<4, 4>;    // AF_PRIO1
            using AF_PRIO2 = Field<8, 4>;    // AF_PRIO2
            using AF_PRIO3 = Field<12, 4>;    // AF_PRIO3
            using AF_PRIO4 = Field<16, 4>;    // AF_PRIO4
            using AF_PRIO5 = Field<20, 4>;    // AF_PRIO5
            using AF_PRIO6 = Field<24, 4>;    // AF_PRIO6
            using AF_PRIO7 = Field<28, 4>;    // AF_PRIO7
        };

        // GPIO hardware configuration register 6
        struct GPIOZ_HWCFGR6 : public RegisterReadOnly<0x540043d8> {
            using MODER_RES = Field<0, 32>;    // MODER_RES
        };

        // GPIO hardware configuration register 5
        struct GPIOZ_HWCFGR5 : public RegisterReadOnly<0x540043dc> {
            using PUPDR_RES = Field<0, 32>;    // PUPDR_RES
        };

        // GPIO hardware configuration register 4
        struct GPIOZ_HWCFGR4 : public RegisterReadOnly<0x540043e0> {
            using OSPEED_RES = Field<0, 32>;    // OSPEED_RES
        };

        // GPIO hardware configuration register 3
        struct GPIOZ_HWCFGR3 : public RegisterReadOnly<0x540043e4> {
            using ODR_RES = Field<0, 16>;    // ODR_RES
            using OTYPER_RES = Field<16, 16>;    // OTYPER_RES
        };

        // GPIO hardware configuration register 2
        struct GPIOZ_HWCFGR2 : public RegisterReadOnly<0x540043e8> {
            using AFRL_RES = Field<0, 32>;    // AFRL_RES
        };

        // GPIO hardware configuration register 1
        struct GPIOZ_HWCFGR1 : public RegisterReadOnly<0x540043ec> {
            using AFRH_RES = Field<0, 32>;    // AFRH_RES
        };

        // GPIO hardware configuration register 0
        struct GPIOZ_HWCFGR0 : public RegisterReadOnly<0x540043f0> {
            using OR_RES = Field<0, 16>;    // OR_RES
        };

        // GPIO version register
        struct GPIOZ_VERR : public RegisterReadOnly<0x540043f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // GPIO identification register
        struct GPIOZ_IPIDR : public RegisterReadOnly<0x540043f8> {
            using IPIDR = Field<0, 32>;    // IPIDR
        };

        // GPIO size identification register
        struct GPIOZ_SIDR : public RegisterReadOnly<0x540043fc> {
            using SIDR = Field<0, 32>;    // SIDR
        };

    };

    // RNG1
    struct RNG1 {
        // RNG control register
        struct RNG_CR : public Register<0x54003000> {
            using RNGEN = Field<2, 1>;    // RNGEN
            using IE = Field<3, 1>;    // IE
            using CED = Field<5, 1>;    // CED
        };

        // RNG status register
        struct RNG_SR : public Register<0x54003004> {
            using DRDY = Field<0, 1>;    // DRDY
            using CECS = Field<1, 1>;    // CECS
            using SECS = Field<2, 1>;    // SECS
            using CEIS = Field<5, 1>;    // CEIS
            using SEIS = Field<6, 1>;    // SEIS
        };

        // The RNG_DR register is a read-only register.
        struct RNG_DR : public RegisterReadOnly<0x54003008> {
            using RNDATA = Field<0, 32>;    // RNDATA
        };

        // RNG hardware configuration register
        struct RNG_HWCFGR : public RegisterReadOnly<0x540033f0> {
        };

        // RNG version register
        struct RNG_VERR : public RegisterReadOnly<0x540033f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // RNG identification register
        struct RNG_IPIDR : public RegisterReadOnly<0x540033f8> {
            using ID = Field<0, 32>;    // ID
        };

        // RNG size ID register
        struct RNG_SIDR : public RegisterReadOnly<0x540033fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // RNG2
    struct RNG2 {
        // RNG control register
        struct RNG_CR : public Register<0x4c003000> {
            using RNGEN = Field<2, 1>;    // RNGEN
            using IE = Field<3, 1>;    // IE
            using CED = Field<5, 1>;    // CED
        };

        // RNG status register
        struct RNG_SR : public Register<0x4c003004> {
            using DRDY = Field<0, 1>;    // DRDY
            using CECS = Field<1, 1>;    // CECS
            using SECS = Field<2, 1>;    // SECS
            using CEIS = Field<5, 1>;    // CEIS
            using SEIS = Field<6, 1>;    // SEIS
        };

        // The RNG_DR register is a read-only register.
        struct RNG_DR : public RegisterReadOnly<0x4c003008> {
            using RNDATA = Field<0, 32>;    // RNDATA
        };

        // RNG hardware configuration register
        struct RNG_HWCFGR : public RegisterReadOnly<0x4c0033f0> {
        };

        // RNG version register
        struct RNG_VERR : public RegisterReadOnly<0x4c0033f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // RNG identification register
        struct RNG_IPIDR : public RegisterReadOnly<0x4c0033f8> {
            using ID = Field<0, 32>;    // ID
        };

        // RNG size ID register
        struct RNG_SIDR : public RegisterReadOnly<0x4c0033fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // HASH register block
    struct HASH1 {
        // HASH control register
        struct HASH_CR : public Register<0x54002000> {
            using INIT = Field<2, 1>;    // INIT
            using DMAE = Field<3, 1>;    // DMAE
            using DATATYPE = Field<4, 2>;    // DATATYPE
            using MODE = Field<6, 1>;    // MODE
            using ALGO0 = Field<7, 1>;    // ALGO0
            using NBW = Field<8, 4>;    // NBW
            using DINNE = Field<12, 1>;    // DINNE
            using MDMAT = Field<13, 1>;    // MDMAT
            using DMAA = Field<14, 1>;    // DMAA
            using LKEY = Field<16, 1>;    // LKEY
            using ALGO1 = Field<18, 1>;    // ALGO1
        };

        // HASH_DIN is the data input register.
        struct HASH_DIN : public Register<0x54002004> {
            using DATAIN = Field<0, 32>;    // DATAIN
        };

        // The HASH_STR register has two functions: It is used to define the number of valid bits in the last word of the message entered in the hash processor (that is the number of valid least significant bits in the last data written to the HASH_DIN register) It is used to start the processing of the last block in the message by writing the DCAL bit to 1
        struct HASH_STR : public Register<0x54002008> {
            using NBLW = Field<0, 5>;    // NBLW
            using DCAL = Field<8, 1>;    // DCAL
        };

        // HASH digest register 0
        struct HASH_HR0 : public RegisterReadOnly<0x5400200c> {
            using H0 = Field<0, 32>;    // H0
        };

        // HASH digest register 1
        struct HASH_HR1 : public RegisterReadOnly<0x54002010> {
            using H1 = Field<0, 32>;    // H1
        };

        // HASH digest register 2
        struct HASH_HR2 : public RegisterReadOnly<0x54002014> {
            using H2 = Field<0, 32>;    // H2
        };

        // HASH digest register 3
        struct HASH_HR3 : public RegisterReadOnly<0x54002018> {
            using H3 = Field<0, 32>;    // H3
        };

        // HASH digest register 4
        struct HASH_HR4 : public RegisterReadOnly<0x5400201c> {
            using H4 = Field<0, 32>;    // H4
        };

        // HASH interrupt enable register
        struct HASH_IMR : public Register<0x54002020> {
            using DINIE = Field<0, 1>;    // DINIE
            using DCIE = Field<1, 1>;    // DCIE
        };

        // HASH status register
        struct HASH_SR : public Register<0x54002024> {
            using DINIS = Field<0, 1>;    // DINIS
            using DCIS = Field<1, 1>;    // DCIS
            using DMAS = Field<2, 1>;    // DMAS
            using BUSY = Field<3, 1>;    // BUSY
        };

        // These registers contain the complete internal register states of the hash processor. They are useful when a context swap has to be done because a high-priority task needs to use the hash processor while it is already used by another task. When such an event occurs, the HASH_CSRx registers have to be read and the read values have to be saved in the system memory space. Then the hash processor can be used by the preemptive task, and when the hash computation is complete, the saved context can be read from memory and written back into the HASH_CSRx registers.
        struct HASH_CSR0 : public Register<0x540020f8> {
            using CS0 = Field<0, 32>;    // CS0
        };

        // HASH context swap registers
        struct HASH_CSR1 : public Register<0x540020fc> {
            using CS1 = Field<0, 32>;    // CS1
        };

        // HASH context swap registers
        struct HASH_CSR2 : public Register<0x54002100> {
            using CS2 = Field<0, 32>;    // CS2
        };

        // HASH context swap registers
        struct HASH_CSR3 : public Register<0x54002104> {
            using CS3 = Field<0, 32>;    // CS3
        };

        // HASH context swap registers
        struct HASH_CSR4 : public Register<0x54002108> {
            using CS4 = Field<0, 32>;    // CS4
        };

        // HASH context swap registers
        struct HASH_CSR5 : public Register<0x5400210c> {
            using CS5 = Field<0, 32>;    // CS5
        };

        // HASH context swap registers
        struct HASH_CSR6 : public Register<0x54002110> {
            using CS6 = Field<0, 32>;    // CS6
        };

        // HASH context swap registers
        struct HASH_CSR7 : public Register<0x54002114> {
            using CS7 = Field<0, 32>;    // CS7
        };

        // HASH context swap registers
        struct HASH_CSR8 : public Register<0x54002118> {
            using CS8 = Field<0, 32>;    // CS8
        };

        // HASH context swap registers
        struct HASH_CSR9 : public Register<0x5400211c> {
            using CS9 = Field<0, 32>;    // CS9
        };

        // HASH context swap registers
        struct HASH_CSR10 : public Register<0x54002120> {
            using CS10 = Field<0, 32>;    // CS10
        };

        // HASH context swap registers
        struct HASH_CSR11 : public Register<0x54002124> {
            using CS11 = Field<0, 32>;    // CS11
        };

        // HASH context swap registers
        struct HASH_CSR12 : public Register<0x54002128> {
            using CS12 = Field<0, 32>;    // CS12
        };

        // HASH context swap registers
        struct HASH_CSR13 : public Register<0x5400212c> {
            using CS13 = Field<0, 32>;    // CS13
        };

        // HASH context swap registers
        struct HASH_CSR14 : public Register<0x54002130> {
            using CS14 = Field<0, 32>;    // CS14
        };

        // HASH context swap registers
        struct HASH_CSR15 : public Register<0x54002134> {
            using CS15 = Field<0, 32>;    // CS15
        };

        // HASH context swap registers
        struct HASH_CSR16 : public Register<0x54002138> {
            using CS16 = Field<0, 32>;    // CS16
        };

        // HASH context swap registers
        struct HASH_CSR17 : public Register<0x5400213c> {
            using CS17 = Field<0, 32>;    // CS17
        };

        // HASH context swap registers
        struct HASH_CSR18 : public Register<0x54002140> {
            using CS18 = Field<0, 32>;    // CS18
        };

        // HASH context swap registers
        struct HASH_CSR19 : public Register<0x54002144> {
            using CS19 = Field<0, 32>;    // CS19
        };

        // HASH context swap registers
        struct HASH_CSR20 : public Register<0x54002148> {
            using CS20 = Field<0, 32>;    // CS20
        };

        // HASH context swap registers
        struct HASH_CSR21 : public Register<0x5400214c> {
            using CS21 = Field<0, 32>;    // CS21
        };

        // HASH context swap registers
        struct HASH_CSR22 : public Register<0x54002150> {
            using CS22 = Field<0, 32>;    // CS22
        };

        // HASH context swap registers
        struct HASH_CSR23 : public Register<0x54002154> {
            using CS23 = Field<0, 32>;    // CS23
        };

        // HASH context swap registers
        struct HASH_CSR24 : public Register<0x54002158> {
            using CS24 = Field<0, 32>;    // CS24
        };

        // HASH context swap registers
        struct HASH_CSR25 : public Register<0x5400215c> {
            using CS25 = Field<0, 32>;    // CS25
        };

        // HASH context swap registers
        struct HASH_CSR26 : public Register<0x54002160> {
            using CS26 = Field<0, 32>;    // CS26
        };

        // HASH context swap registers
        struct HASH_CSR27 : public Register<0x54002164> {
            using CS27 = Field<0, 32>;    // CS27
        };

        // HASH context swap registers
        struct HASH_CSR28 : public Register<0x54002168> {
            using CS28 = Field<0, 32>;    // CS28
        };

        // HASH context swap registers
        struct HASH_CSR29 : public Register<0x5400216c> {
            using CS29 = Field<0, 32>;    // CS29
        };

        // HASH context swap registers
        struct HASH_CSR30 : public Register<0x54002170> {
            using CS30 = Field<0, 32>;    // CS30
        };

        // HASH context swap registers
        struct HASH_CSR31 : public Register<0x54002174> {
            using CS31 = Field<0, 32>;    // CS31
        };

        // HASH context swap registers
        struct HASH_CSR32 : public Register<0x54002178> {
            using CS32 = Field<0, 32>;    // CS32
        };

        // HASH context swap registers
        struct HASH_CSR33 : public Register<0x5400217c> {
            using CS33 = Field<0, 32>;    // CS33
        };

        // HASH context swap registers
        struct HASH_CSR34 : public Register<0x54002180> {
            using CS34 = Field<0, 32>;    // CS34
        };

        // HASH context swap registers
        struct HASH_CSR35 : public Register<0x54002184> {
            using CS35 = Field<0, 32>;    // CS35
        };

        // HASH context swap registers
        struct HASH_CSR36 : public Register<0x54002188> {
            using CS36 = Field<0, 32>;    // CS36
        };

        // HASH context swap registers
        struct HASH_CSR37 : public Register<0x5400218c> {
            using CS37 = Field<0, 32>;    // CS37
        };

        // HASH context swap registers
        struct HASH_CSR38 : public Register<0x54002190> {
            using CS38 = Field<0, 32>;    // CS38
        };

        // HASH context swap registers
        struct HASH_CSR39 : public Register<0x54002194> {
            using CS39 = Field<0, 32>;    // CS39
        };

        // HASH context swap registers
        struct HASH_CSR40 : public Register<0x54002198> {
            using CS40 = Field<0, 32>;    // CS40
        };

        // HASH context swap registers
        struct HASH_CSR41 : public Register<0x5400219c> {
            using CS41 = Field<0, 32>;    // CS41
        };

        // HASH context swap registers
        struct HASH_CSR42 : public Register<0x540021a0> {
            using CS42 = Field<0, 32>;    // CS42
        };

        // HASH context swap registers
        struct HASH_CSR43 : public Register<0x540021a4> {
            using CS43 = Field<0, 32>;    // CS43
        };

        // HASH context swap registers
        struct HASH_CSR44 : public Register<0x540021a8> {
            using CS44 = Field<0, 32>;    // CS44
        };

        // HASH context swap registers
        struct HASH_CSR45 : public Register<0x540021ac> {
            using CS45 = Field<0, 32>;    // CS45
        };

        // HASH context swap registers
        struct HASH_CSR46 : public Register<0x540021b0> {
            using CS46 = Field<0, 32>;    // CS46
        };

        // HASH context swap registers
        struct HASH_CSR47 : public Register<0x540021b4> {
            using CS47 = Field<0, 32>;    // CS47
        };

        // HASH context swap registers
        struct HASH_CSR48 : public Register<0x540021b8> {
            using CS48 = Field<0, 32>;    // CS48
        };

        // HASH context swap registers
        struct HASH_CSR49 : public Register<0x540021bc> {
            using CS49 = Field<0, 32>;    // CS49
        };

        // HASH context swap registers
        struct HASH_CSR50 : public Register<0x540021c0> {
            using CS50 = Field<0, 32>;    // CS50
        };

        // HASH context swap registers
        struct HASH_CSR51 : public Register<0x540021c4> {
            using CS51 = Field<0, 32>;    // CS51
        };

        // HASH context swap registers
        struct HASH_CSR52 : public Register<0x540021c8> {
            using CS52 = Field<0, 32>;    // CS52
        };

        // HASH context swap registers
        struct HASH_CSR53 : public Register<0x540021cc> {
            using CS53 = Field<0, 32>;    // CS53
        };

        // HASH digest register 5
        struct HASH_HR5 : public RegisterReadOnly<0x54002324> {
            using H5 = Field<0, 32>;    // H5
        };

        // HASH digest register 6
        struct HASH_HR6 : public RegisterReadOnly<0x54002328> {
            using H6 = Field<0, 32>;    // H6
        };

        // HASH digest register 7
        struct HASH_HR7 : public RegisterReadOnly<0x5400232c> {
            using H7 = Field<0, 32>;    // H7
        };

        // HASH Hardware Configuration Register
        struct HASH_HWCFGR : public RegisterReadOnly<0x540023f0> {
            using CFG1 = Field<0, 4>;    // CFG1
        };

        // HASH Version Register
        struct HASH_VERR : public RegisterReadOnly<0x540023f4> {
            using VER = Field<0, 8>;    // VER
        };

        // HASH Identification
        struct HASH_IPIDR : public RegisterReadOnly<0x540023f8> {
            using ID = Field<0, 32>;    // ID
        };

        // HASH Hardware Magic ID
        struct HASH_MID : public RegisterReadOnly<0x540023fc> {
            using MID = Field<0, 32>;    // MID
        };

    };

    // HASH register block
    struct HASH2 {
        // HASH control register
        struct HASH_CR : public Register<0x4c002000> {
            using INIT = Field<2, 1>;    // INIT
            using DMAE = Field<3, 1>;    // DMAE
            using DATATYPE = Field<4, 2>;    // DATATYPE
            using MODE = Field<6, 1>;    // MODE
            using ALGO0 = Field<7, 1>;    // ALGO0
            using NBW = Field<8, 4>;    // NBW
            using DINNE = Field<12, 1>;    // DINNE
            using MDMAT = Field<13, 1>;    // MDMAT
            using DMAA = Field<14, 1>;    // DMAA
            using LKEY = Field<16, 1>;    // LKEY
            using ALGO1 = Field<18, 1>;    // ALGO1
        };

        // HASH_DIN is the data input register.
        struct HASH_DIN : public Register<0x4c002004> {
            using DATAIN = Field<0, 32>;    // DATAIN
        };

        // The HASH_STR register has two functions: It is used to define the number of valid bits in the last word of the message entered in the hash processor (that is the number of valid least significant bits in the last data written to the HASH_DIN register) It is used to start the processing of the last block in the message by writing the DCAL bit to 1
        struct HASH_STR : public Register<0x4c002008> {
            using NBLW = Field<0, 5>;    // NBLW
            using DCAL = Field<8, 1>;    // DCAL
        };

        // HASH digest register 0
        struct HASH_HR0 : public RegisterReadOnly<0x4c00200c> {
            using H0 = Field<0, 32>;    // H0
        };

        // HASH digest register 1
        struct HASH_HR1 : public RegisterReadOnly<0x4c002010> {
            using H1 = Field<0, 32>;    // H1
        };

        // HASH digest register 2
        struct HASH_HR2 : public RegisterReadOnly<0x4c002014> {
            using H2 = Field<0, 32>;    // H2
        };

        // HASH digest register 3
        struct HASH_HR3 : public RegisterReadOnly<0x4c002018> {
            using H3 = Field<0, 32>;    // H3
        };

        // HASH digest register 4
        struct HASH_HR4 : public RegisterReadOnly<0x4c00201c> {
            using H4 = Field<0, 32>;    // H4
        };

        // HASH interrupt enable register
        struct HASH_IMR : public Register<0x4c002020> {
            using DINIE = Field<0, 1>;    // DINIE
            using DCIE = Field<1, 1>;    // DCIE
        };

        // HASH status register
        struct HASH_SR : public Register<0x4c002024> {
            using DINIS = Field<0, 1>;    // DINIS
            using DCIS = Field<1, 1>;    // DCIS
            using DMAS = Field<2, 1>;    // DMAS
            using BUSY = Field<3, 1>;    // BUSY
        };

        // These registers contain the complete internal register states of the hash processor. They are useful when a context swap has to be done because a high-priority task needs to use the hash processor while it is already used by another task. When such an event occurs, the HASH_CSRx registers have to be read and the read values have to be saved in the system memory space. Then the hash processor can be used by the preemptive task, and when the hash computation is complete, the saved context can be read from memory and written back into the HASH_CSRx registers.
        struct HASH_CSR0 : public Register<0x4c0020f8> {
            using CS0 = Field<0, 32>;    // CS0
        };

        // HASH context swap registers
        struct HASH_CSR1 : public Register<0x4c0020fc> {
            using CS1 = Field<0, 32>;    // CS1
        };

        // HASH context swap registers
        struct HASH_CSR2 : public Register<0x4c002100> {
            using CS2 = Field<0, 32>;    // CS2
        };

        // HASH context swap registers
        struct HASH_CSR3 : public Register<0x4c002104> {
            using CS3 = Field<0, 32>;    // CS3
        };

        // HASH context swap registers
        struct HASH_CSR4 : public Register<0x4c002108> {
            using CS4 = Field<0, 32>;    // CS4
        };

        // HASH context swap registers
        struct HASH_CSR5 : public Register<0x4c00210c> {
            using CS5 = Field<0, 32>;    // CS5
        };

        // HASH context swap registers
        struct HASH_CSR6 : public Register<0x4c002110> {
            using CS6 = Field<0, 32>;    // CS6
        };

        // HASH context swap registers
        struct HASH_CSR7 : public Register<0x4c002114> {
            using CS7 = Field<0, 32>;    // CS7
        };

        // HASH context swap registers
        struct HASH_CSR8 : public Register<0x4c002118> {
            using CS8 = Field<0, 32>;    // CS8
        };

        // HASH context swap registers
        struct HASH_CSR9 : public Register<0x4c00211c> {
            using CS9 = Field<0, 32>;    // CS9
        };

        // HASH context swap registers
        struct HASH_CSR10 : public Register<0x4c002120> {
            using CS10 = Field<0, 32>;    // CS10
        };

        // HASH context swap registers
        struct HASH_CSR11 : public Register<0x4c002124> {
            using CS11 = Field<0, 32>;    // CS11
        };

        // HASH context swap registers
        struct HASH_CSR12 : public Register<0x4c002128> {
            using CS12 = Field<0, 32>;    // CS12
        };

        // HASH context swap registers
        struct HASH_CSR13 : public Register<0x4c00212c> {
            using CS13 = Field<0, 32>;    // CS13
        };

        // HASH context swap registers
        struct HASH_CSR14 : public Register<0x4c002130> {
            using CS14 = Field<0, 32>;    // CS14
        };

        // HASH context swap registers
        struct HASH_CSR15 : public Register<0x4c002134> {
            using CS15 = Field<0, 32>;    // CS15
        };

        // HASH context swap registers
        struct HASH_CSR16 : public Register<0x4c002138> {
            using CS16 = Field<0, 32>;    // CS16
        };

        // HASH context swap registers
        struct HASH_CSR17 : public Register<0x4c00213c> {
            using CS17 = Field<0, 32>;    // CS17
        };

        // HASH context swap registers
        struct HASH_CSR18 : public Register<0x4c002140> {
            using CS18 = Field<0, 32>;    // CS18
        };

        // HASH context swap registers
        struct HASH_CSR19 : public Register<0x4c002144> {
            using CS19 = Field<0, 32>;    // CS19
        };

        // HASH context swap registers
        struct HASH_CSR20 : public Register<0x4c002148> {
            using CS20 = Field<0, 32>;    // CS20
        };

        // HASH context swap registers
        struct HASH_CSR21 : public Register<0x4c00214c> {
            using CS21 = Field<0, 32>;    // CS21
        };

        // HASH context swap registers
        struct HASH_CSR22 : public Register<0x4c002150> {
            using CS22 = Field<0, 32>;    // CS22
        };

        // HASH context swap registers
        struct HASH_CSR23 : public Register<0x4c002154> {
            using CS23 = Field<0, 32>;    // CS23
        };

        // HASH context swap registers
        struct HASH_CSR24 : public Register<0x4c002158> {
            using CS24 = Field<0, 32>;    // CS24
        };

        // HASH context swap registers
        struct HASH_CSR25 : public Register<0x4c00215c> {
            using CS25 = Field<0, 32>;    // CS25
        };

        // HASH context swap registers
        struct HASH_CSR26 : public Register<0x4c002160> {
            using CS26 = Field<0, 32>;    // CS26
        };

        // HASH context swap registers
        struct HASH_CSR27 : public Register<0x4c002164> {
            using CS27 = Field<0, 32>;    // CS27
        };

        // HASH context swap registers
        struct HASH_CSR28 : public Register<0x4c002168> {
            using CS28 = Field<0, 32>;    // CS28
        };

        // HASH context swap registers
        struct HASH_CSR29 : public Register<0x4c00216c> {
            using CS29 = Field<0, 32>;    // CS29
        };

        // HASH context swap registers
        struct HASH_CSR30 : public Register<0x4c002170> {
            using CS30 = Field<0, 32>;    // CS30
        };

        // HASH context swap registers
        struct HASH_CSR31 : public Register<0x4c002174> {
            using CS31 = Field<0, 32>;    // CS31
        };

        // HASH context swap registers
        struct HASH_CSR32 : public Register<0x4c002178> {
            using CS32 = Field<0, 32>;    // CS32
        };

        // HASH context swap registers
        struct HASH_CSR33 : public Register<0x4c00217c> {
            using CS33 = Field<0, 32>;    // CS33
        };

        // HASH context swap registers
        struct HASH_CSR34 : public Register<0x4c002180> {
            using CS34 = Field<0, 32>;    // CS34
        };

        // HASH context swap registers
        struct HASH_CSR35 : public Register<0x4c002184> {
            using CS35 = Field<0, 32>;    // CS35
        };

        // HASH context swap registers
        struct HASH_CSR36 : public Register<0x4c002188> {
            using CS36 = Field<0, 32>;    // CS36
        };

        // HASH context swap registers
        struct HASH_CSR37 : public Register<0x4c00218c> {
            using CS37 = Field<0, 32>;    // CS37
        };

        // HASH context swap registers
        struct HASH_CSR38 : public Register<0x4c002190> {
            using CS38 = Field<0, 32>;    // CS38
        };

        // HASH context swap registers
        struct HASH_CSR39 : public Register<0x4c002194> {
            using CS39 = Field<0, 32>;    // CS39
        };

        // HASH context swap registers
        struct HASH_CSR40 : public Register<0x4c002198> {
            using CS40 = Field<0, 32>;    // CS40
        };

        // HASH context swap registers
        struct HASH_CSR41 : public Register<0x4c00219c> {
            using CS41 = Field<0, 32>;    // CS41
        };

        // HASH context swap registers
        struct HASH_CSR42 : public Register<0x4c0021a0> {
            using CS42 = Field<0, 32>;    // CS42
        };

        // HASH context swap registers
        struct HASH_CSR43 : public Register<0x4c0021a4> {
            using CS43 = Field<0, 32>;    // CS43
        };

        // HASH context swap registers
        struct HASH_CSR44 : public Register<0x4c0021a8> {
            using CS44 = Field<0, 32>;    // CS44
        };

        // HASH context swap registers
        struct HASH_CSR45 : public Register<0x4c0021ac> {
            using CS45 = Field<0, 32>;    // CS45
        };

        // HASH context swap registers
        struct HASH_CSR46 : public Register<0x4c0021b0> {
            using CS46 = Field<0, 32>;    // CS46
        };

        // HASH context swap registers
        struct HASH_CSR47 : public Register<0x4c0021b4> {
            using CS47 = Field<0, 32>;    // CS47
        };

        // HASH context swap registers
        struct HASH_CSR48 : public Register<0x4c0021b8> {
            using CS48 = Field<0, 32>;    // CS48
        };

        // HASH context swap registers
        struct HASH_CSR49 : public Register<0x4c0021bc> {
            using CS49 = Field<0, 32>;    // CS49
        };

        // HASH context swap registers
        struct HASH_CSR50 : public Register<0x4c0021c0> {
            using CS50 = Field<0, 32>;    // CS50
        };

        // HASH context swap registers
        struct HASH_CSR51 : public Register<0x4c0021c4> {
            using CS51 = Field<0, 32>;    // CS51
        };

        // HASH context swap registers
        struct HASH_CSR52 : public Register<0x4c0021c8> {
            using CS52 = Field<0, 32>;    // CS52
        };

        // HASH context swap registers
        struct HASH_CSR53 : public Register<0x4c0021cc> {
            using CS53 = Field<0, 32>;    // CS53
        };

        // HASH digest register 5
        struct HASH_HR5 : public RegisterReadOnly<0x4c002324> {
            using H5 = Field<0, 32>;    // H5
        };

        // HASH digest register 6
        struct HASH_HR6 : public RegisterReadOnly<0x4c002328> {
            using H6 = Field<0, 32>;    // H6
        };

        // HASH digest register 7
        struct HASH_HR7 : public RegisterReadOnly<0x4c00232c> {
            using H7 = Field<0, 32>;    // H7
        };

        // HASH Hardware Configuration Register
        struct HASH_HWCFGR : public RegisterReadOnly<0x4c0023f0> {
            using CFG1 = Field<0, 4>;    // CFG1
        };

        // HASH Version Register
        struct HASH_VERR : public RegisterReadOnly<0x4c0023f4> {
            using VER = Field<0, 8>;    // VER
        };

        // HASH Identification
        struct HASH_IPIDR : public RegisterReadOnly<0x4c0023f8> {
            using ID = Field<0, 32>;    // ID
        };

        // HASH Hardware Magic ID
        struct HASH_MID : public RegisterReadOnly<0x4c0023fc> {
            using MID = Field<0, 32>;    // MID
        };

    };

    // HSEM
    struct HSEM {
        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R0 : public Register<0x4c000000> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R1 : public Register<0x4c000004> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R2 : public Register<0x4c000008> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R3 : public Register<0x4c00000c> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R4 : public Register<0x4c000010> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R5 : public Register<0x4c000014> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R6 : public Register<0x4c000018> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R7 : public Register<0x4c00001c> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R8 : public Register<0x4c000020> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R9 : public Register<0x4c000024> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R10 : public Register<0x4c000028> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R11 : public Register<0x4c00002c> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R12 : public Register<0x4c000030> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R13 : public Register<0x4c000034> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R14 : public Register<0x4c000038> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R15 : public Register<0x4c00003c> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R16 : public Register<0x4c000040> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R17 : public Register<0x4c000044> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R18 : public Register<0x4c000048> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R19 : public Register<0x4c00004c> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R20 : public Register<0x4c000050> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R21 : public Register<0x4c000054> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R22 : public Register<0x4c000058> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R23 : public Register<0x4c00005c> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R24 : public Register<0x4c000060> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R25 : public Register<0x4c000064> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R26 : public Register<0x4c000068> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R27 : public Register<0x4c00006c> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R28 : public Register<0x4c000070> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R29 : public Register<0x4c000074> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R30 : public Register<0x4c000078> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_R31 : public Register<0x4c00007c> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR0 : public RegisterReadOnly<0x4c000080> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR1 : public RegisterReadOnly<0x4c000084> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR2 : public RegisterReadOnly<0x4c000088> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR3 : public RegisterReadOnly<0x4c00008c> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR4 : public RegisterReadOnly<0x4c000090> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR5 : public RegisterReadOnly<0x4c000094> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR6 : public RegisterReadOnly<0x4c000098> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR7 : public RegisterReadOnly<0x4c00009c> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR8 : public RegisterReadOnly<0x4c0000a0> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR9 : public RegisterReadOnly<0x4c0000a4> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR10 : public RegisterReadOnly<0x4c0000a8> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR11 : public RegisterReadOnly<0x4c0000ac> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR12 : public RegisterReadOnly<0x4c0000b0> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR13 : public RegisterReadOnly<0x4c0000b4> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR14 : public RegisterReadOnly<0x4c0000b8> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR15 : public RegisterReadOnly<0x4c0000bc> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR16 : public RegisterReadOnly<0x4c0000c0> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR17 : public RegisterReadOnly<0x4c0000c4> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR18 : public RegisterReadOnly<0x4c0000c8> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR19 : public RegisterReadOnly<0x4c0000cc> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR20 : public RegisterReadOnly<0x4c0000d0> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR21 : public RegisterReadOnly<0x4c0000d4> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR22 : public RegisterReadOnly<0x4c0000d8> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR23 : public RegisterReadOnly<0x4c0000dc> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR24 : public RegisterReadOnly<0x4c0000e0> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR25 : public RegisterReadOnly<0x4c0000e4> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR26 : public RegisterReadOnly<0x4c0000e8> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR27 : public RegisterReadOnly<0x4c0000ec> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR28 : public RegisterReadOnly<0x4c0000f0> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR29 : public RegisterReadOnly<0x4c0000f4> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR30 : public RegisterReadOnly<0x4c0000f8> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_RLR31 : public RegisterReadOnly<0x4c0000fc> {
            using PROCID = Field<0, 8>;    // PROCID
            using COREID = Field<8, 4>;    // COREID
            using LOCK = Field<31, 1>;    // LOCK
        };

        // HSEM i1terrupt enable register
        struct HSEM_C1IER : public Register<0x4c000100> {
            using ISE = Field<0, 32>;    // ISE
        };

        // HSEM i1terrupt clear register
        struct HSEM_C1ICR : public Register<0x4c000104> {
            using ISC = Field<0, 32>;    // ISC
        };

        // HSEM i1terrupt status register
        struct HSEM_C1ISR : public RegisterReadOnly<0x4c000108> {
            using ISF = Field<0, 32>;    // ISF
        };

        // HSEM i1terrupt status register
        struct HSEM_C1MISR : public RegisterReadOnly<0x4c00010c> {
            using MISF = Field<0, 32>;    // MISF
        };

        // HSEM i2terrupt enable register
        struct HSEM_C2IER : public Register<0x4c000110> {
            using ISE = Field<0, 32>;    // ISE
        };

        // HSEM i2terrupt clear register
        struct HSEM_C2ICR : public Register<0x4c000114> {
            using ISC = Field<0, 32>;    // ISC
        };

        // HSEM i2terrupt status register
        struct HSEM_C2ISR : public RegisterReadOnly<0x4c000118> {
            using ISF = Field<0, 32>;    // ISF
        };

        // HSEM i2terrupt status register
        struct HSEM_C2MISR : public RegisterReadOnly<0x4c00011c> {
            using MISF = Field<0, 32>;    // MISF
        };

        // Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
        struct HSEM_CR : public RegisterWriteOnly<0x4c000140> {
            using COREID = Field<8, 4>;    // COREID
            using KEY = Field<16, 16>;    // KEY
        };

        // HSEM interrupt clear register
        struct HSEM_KEYR : public Register<0x4c000144> {
            using KEY = Field<16, 16>;    // KEY
        };

        // HSEM hardware configuration register 2
        struct HSEM_HWCFGR2 : public RegisterReadOnly<0x4c0003ec> {
            using MASTERID1 = Field<0, 4>;    // MASTERID1
            using MASTERID2 = Field<4, 4>;    // MASTERID2
            using MASTERID3 = Field<8, 4>;    // MASTERID3
            using MASTERID4 = Field<12, 4>;    // MASTERID4
        };

        // HSEM hardware configuration register 1
        struct HSEM_HWCFGR1 : public RegisterReadOnly<0x4c0003f0> {
            using NBSEM = Field<0, 8>;    // NBSEM
            using NBINT = Field<8, 4>;    // NBINT
        };

        // HSEM IP version register
        struct HSEM_VERR : public RegisterReadOnly<0x4c0003f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // HSEM IP identification register
        struct HSEM_IPIDR : public RegisterReadOnly<0x4c0003f8> {
            using IPID = Field<0, 32>;    // IPID
        };

        // HSEM size identification register
        struct HSEM_SIDR : public RegisterReadOnly<0x4c0003fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // HDP
    struct HDP {
        // HDP Control
        struct HDP_CTRL : public Register<0x5002a000> {
            using EN = Field<0, 1>;    // EN
        };

        // HDP multiplexing
        struct HDP_MUX : public Register<0x5002a004> {
            using MUX0 = Field<0, 4>;    // MUX0
            using MUX1 = Field<4, 4>;    // MUX1
            using MUX2 = Field<8, 4>;    // MUX2
            using MUX3 = Field<12, 4>;    // MUX3
            using MUX4 = Field<16, 4>;    // MUX4
            using MUX5 = Field<20, 4>;    // MUX5
            using MUX6 = Field<24, 4>;    // MUX6
            using MUX7 = Field<28, 4>;    // MUX7
        };

        // HDP value
        struct HDP_VAL : public RegisterReadOnly<0x5002a010> {
            using HDPVAL = Field<0, 8>;    // HDPVAL
        };

        // HDP GPO set
        struct HDP_GPOSET : public RegisterWriteOnly<0x5002a014> {
            using HDPGPOSET = Field<0, 8>;    // HDPGPOSET
        };

        // HDP GPO clear
        struct HDP_GPOCLR : public RegisterWriteOnly<0x5002a018> {
            using HDPGPOCLR = Field<0, 8>;    // HDPGPOCLR
        };

        // HDP GPO value
        struct HDP_GPOVAL : public Register<0x5002a01c> {
            using HDPGPOVAL = Field<0, 8>;    // HDPGPOVAL
        };

        // HDP version register
        struct HDP_VERR : public RegisterReadOnly<0x5002a3f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // HDP IP identification register
        struct HDP_IPIDR : public RegisterReadOnly<0x5002a3f8> {
            using ID = Field<0, 32>;    // ID
        };

        // HDP size identification register
        struct HDP_SIDR : public RegisterReadOnly<0x5002a3fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // SAI1 register block
    struct SAI1 {
        // Global configuration register
        struct SAI_GCR : public Register<0x4400a000> {
            using SYNCIN = Field<0, 2>;    // SYNCIN
            using SYNCOUT = Field<4, 2>;    // SYNCOUT
        };

        // Configuration register 1
        struct SAI_ACR1 : public Register<0x4400a004> {
            using MODE = Field<0, 2>;    // MODE
            using PRTCFG = Field<2, 2>;    // PRTCFG
            using DS = Field<5, 3>;    // DS
            using LSBFIRST = Field<8, 1>;    // LSBFIRST
            using CKSTR = Field<9, 1>;    // CKSTR
            using SYNCEN = Field<10, 2>;    // SYNCEN
            using MONO = Field<12, 1>;    // MONO
            using OUTDRIV = Field<13, 1>;    // OUTDRIV
            using SAIEN = Field<16, 1>;    // SAIEN
            using DMAEN = Field<17, 1>;    // DMAEN
            using NODIV = Field<19, 1>;    // NODIV
            using MCKDIV = Field<20, 6>;    // MCKDIV
            using OSR = Field<26, 1>;    // OSR
            using MCKEN = Field<27, 1>;    // MCKEN
        };

        // Configuration register 2
        struct SAI_ACR2 : public Register<0x4400a008> {
            using FTH = Field<0, 3>;    // FTH
            using FFLUSH = Field<3, 1>;    // FFLUSH
            using TRIS = Field<4, 1>;    // TRIS
            using MUTE = Field<5, 1>;    // MUTE
            using MUTEVAL = Field<6, 1>;    // MUTEVAL
            using MUTECNT = Field<7, 6>;    // MUTECNT
            using CPL = Field<13, 1>;    // CPL
            using COMP = Field<14, 2>;    // COMP
        };

        // This register has no meaning in and SPDIF audio protocol
        struct SAI_AFRCR : public Register<0x4400a00c> {
            using FRL = Field<0, 8>;    // FRL
            using FSALL = Field<8, 7>;    // FSALL
            using FSDEF = Field<16, 1>;    // FSDEF
            using FSPOL = Field<17, 1>;    // FSPOL
            using FSOFF = Field<18, 1>;    // FSOFF
        };

        // This register has no meaning in and SPDIF audio protocol
        struct SAI_ASLOTR : public Register<0x4400a010> {
            using FBOFF = Field<0, 5>;    // FBOFF
            using SLOTSZ = Field<6, 2>;    // SLOTSZ
            using NBSLOT = Field<8, 4>;    // NBSLOT
            using SLOTEN = Field<16, 16>;    // SLOTEN
        };

        // Interrupt mask register
        struct SAI_AIM : public Register<0x4400a014> {
            using OVRUDRIE = Field<0, 1>;    // OVRUDRIE
            using MUTEDETIE = Field<1, 1>;    // MUTEDETIE
            using WCKCFGIE = Field<2, 1>;    // WCKCFGIE
            using FREQIE = Field<3, 1>;    // FREQIE
            using CNRDYIE = Field<4, 1>;    // CNRDYIE
            using AFSDETIE = Field<5, 1>;    // AFSDETIE
            using LFSDETIE = Field<6, 1>;    // LFSDETIE
        };

        // Status register
        struct SAI_ASR : public RegisterReadOnly<0x4400a018> {
            using OVRUDR = Field<0, 1>;    // OVRUDR
            using MUTEDET = Field<1, 1>;    // MUTEDET
            using WCKCFG = Field<2, 1>;    // WCKCFG
            using FREQ = Field<3, 1>;    // FREQ
            using CNRDY = Field<4, 1>;    // CNRDY
            using AFSDET = Field<5, 1>;    // AFSDET
            using LFSDET = Field<6, 1>;    // LFSDET
            using FLVL = Field<16, 3>;    // FLVL
        };

        // Clear flag register
        struct SAI_ACLRFR : public RegisterWriteOnly<0x4400a01c> {
            using COVRUDR = Field<0, 1>;    // COVRUDR
            using CMUTEDET = Field<1, 1>;    // CMUTEDET
            using CWCKCFG = Field<2, 1>;    // CWCKCFG
            using CCNRDY = Field<4, 1>;    // CCNRDY
            using CAFSDET = Field<5, 1>;    // CAFSDET
            using CLFSDET = Field<6, 1>;    // CLFSDET
        };

        // Data register
        struct SAI_ADR : public Register<0x4400a020> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Configuration register 1
        struct SAI_BCR1 : public Register<0x4400a024> {
            using MODE = Field<0, 2>;    // MODE
            using PRTCFG = Field<2, 2>;    // PRTCFG
            using DS = Field<5, 3>;    // DS
            using LSBFIRST = Field<8, 1>;    // LSBFIRST
            using CKSTR = Field<9, 1>;    // CKSTR
            using SYNCEN = Field<10, 2>;    // SYNCEN
            using MONO = Field<12, 1>;    // MONO
            using OUTDRIV = Field<13, 1>;    // OUTDRIV
            using SAIEN = Field<16, 1>;    // SAIEN
            using DMAEN = Field<17, 1>;    // DMAEN
            using NODIV = Field<19, 1>;    // NODIV
            using MCKDIV = Field<20, 6>;    // MCKDIV
            using OSR = Field<26, 1>;    // OSR
            using MCKEN = Field<27, 1>;    // MCKEN
        };

        // Configuration register 2
        struct SAI_BCR2 : public Register<0x4400a028> {
            using FTH = Field<0, 3>;    // FTH
            using FFLUSH = Field<3, 1>;    // FFLUSH
            using TRIS = Field<4, 1>;    // TRIS
            using MUTE = Field<5, 1>;    // MUTE
            using MUTEVAL = Field<6, 1>;    // MUTEVAL
            using MUTECNT = Field<7, 6>;    // MUTECNT
            using CPL = Field<13, 1>;    // CPL
            using COMP = Field<14, 2>;    // COMP
        };

        // This register has no meaning in and SPDIF audio protocol
        struct SAI_BFRCR : public Register<0x4400a02c> {
            using FRL = Field<0, 8>;    // FRL
            using FSALL = Field<8, 7>;    // FSALL
            using FSDEF = Field<16, 1>;    // FSDEF
            using FSPOL = Field<17, 1>;    // FSPOL
            using FSOFF = Field<18, 1>;    // FSOFF
        };

        // This register has no meaning in and SPDIF audio protocol
        struct SAI_BSLOTR : public Register<0x4400a030> {
            using FBOFF = Field<0, 5>;    // FBOFF
            using SLOTSZ = Field<6, 2>;    // SLOTSZ
            using NBSLOT = Field<8, 4>;    // NBSLOT
            using SLOTEN = Field<16, 16>;    // SLOTEN
        };

        // Interrupt mask register
        struct SAI_BIM : public Register<0x4400a034> {
            using OVRUDRIE = Field<0, 1>;    // OVRUDRIE
            using MUTEDETIE = Field<1, 1>;    // MUTEDETIE
            using WCKCFGIE = Field<2, 1>;    // WCKCFGIE
            using FREQIE = Field<3, 1>;    // FREQIE
            using CNRDYIE = Field<4, 1>;    // CNRDYIE
            using AFSDETIE = Field<5, 1>;    // AFSDETIE
            using LFSDETIE = Field<6, 1>;    // LFSDETIE
        };

        // Status register
        struct SAI_BSR : public RegisterReadOnly<0x4400a038> {
            using OVRUDR = Field<0, 1>;    // OVRUDR
            using MUTEDET = Field<1, 1>;    // MUTEDET
            using WCKCFG = Field<2, 1>;    // WCKCFG
            using FREQ = Field<3, 1>;    // FREQ
            using CNRDY = Field<4, 1>;    // CNRDY
            using AFSDET = Field<5, 1>;    // AFSDET
            using LFSDET = Field<6, 1>;    // LFSDET
            using FLVL = Field<16, 3>;    // FLVL
        };

        // Clear flag register
        struct SAI_BCLRFR : public RegisterWriteOnly<0x4400a03c> {
            using COVRUDR = Field<0, 1>;    // COVRUDR
            using CMUTEDET = Field<1, 1>;    // CMUTEDET
            using CWCKCFG = Field<2, 1>;    // CWCKCFG
            using CCNRDY = Field<4, 1>;    // CCNRDY
            using CAFSDET = Field<5, 1>;    // CAFSDET
            using CLFSDET = Field<6, 1>;    // CLFSDET
        };

        // Data register
        struct SAI_BDR : public Register<0x4400a040> {
            using DATA = Field<0, 32>;    // DATA
        };

        // PDM control register
        struct SAI_PDMCR : public Register<0x4400a044> {
            using PDMEN = Field<0, 1>;    // PDMEN
            using MICNBR = Field<4, 2>;    // MICNBR
            using CKEN1 = Field<8, 1>;    // CKEN1
            using CKEN2 = Field<9, 1>;    // CKEN2
            using CKEN3 = Field<10, 1>;    // CKEN3
            using CKEN4 = Field<11, 1>;    // CKEN4
        };

        // PDM delay register
        struct SAI_PDMDLY : public Register<0x4400a048> {
            using DLYM1L = Field<0, 3>;    // DLYM1L
            using DLYM1R = Field<4, 3>;    // DLYM1R
            using DLYM2L = Field<8, 3>;    // DLYM2L
            using DLYM2R = Field<12, 3>;    // DLYM2R
            using DLYM3L = Field<16, 3>;    // DLYM3L
            using DLYM3R = Field<20, 3>;    // DLYM3R
            using DLYM4L = Field<24, 3>;    // DLYM4L
            using DLYM4R = Field<28, 3>;    // DLYM4R
        };

        // SAI hardware configuration register
        struct SAI_HWCFGR : public RegisterReadOnly<0x4400a3f0> {
            using FIFO_SIZE = Field<0, 8>;    // FIFO_SIZE
            using SPDIF_PDM = Field<8, 4>;    // SPDIF_PDM
            using OPTION_REGOUT = Field<12, 8>;    // OPTION_REGOUT
        };

        // SAI version register
        struct SAI_VERR : public RegisterReadOnly<0x4400a3f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // SAI identification register
        struct SAI_IPIDR : public RegisterReadOnly<0x4400a3f8> {
            using ID = Field<0, 32>;    // ID
        };

        // SAI size identification register
        struct SAI_SIDR : public RegisterReadOnly<0x4400a3fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // SAI1 register block
    struct SAI2 {
        // Global configuration register
        struct SAI_GCR : public Register<0x4400b000> {
            using SYNCIN = Field<0, 2>;    // SYNCIN
            using SYNCOUT = Field<4, 2>;    // SYNCOUT
        };

        // Configuration register 1
        struct SAI_ACR1 : public Register<0x4400b004> {
            using MODE = Field<0, 2>;    // MODE
            using PRTCFG = Field<2, 2>;    // PRTCFG
            using DS = Field<5, 3>;    // DS
            using LSBFIRST = Field<8, 1>;    // LSBFIRST
            using CKSTR = Field<9, 1>;    // CKSTR
            using SYNCEN = Field<10, 2>;    // SYNCEN
            using MONO = Field<12, 1>;    // MONO
            using OUTDRIV = Field<13, 1>;    // OUTDRIV
            using SAIEN = Field<16, 1>;    // SAIEN
            using DMAEN = Field<17, 1>;    // DMAEN
            using NODIV = Field<19, 1>;    // NODIV
            using MCKDIV = Field<20, 6>;    // MCKDIV
            using OSR = Field<26, 1>;    // OSR
            using MCKEN = Field<27, 1>;    // MCKEN
        };

        // Configuration register 2
        struct SAI_ACR2 : public Register<0x4400b008> {
            using FTH = Field<0, 3>;    // FTH
            using FFLUSH = Field<3, 1>;    // FFLUSH
            using TRIS = Field<4, 1>;    // TRIS
            using MUTE = Field<5, 1>;    // MUTE
            using MUTEVAL = Field<6, 1>;    // MUTEVAL
            using MUTECNT = Field<7, 6>;    // MUTECNT
            using CPL = Field<13, 1>;    // CPL
            using COMP = Field<14, 2>;    // COMP
        };

        // This register has no meaning in and SPDIF audio protocol
        struct SAI_AFRCR : public Register<0x4400b00c> {
            using FRL = Field<0, 8>;    // FRL
            using FSALL = Field<8, 7>;    // FSALL
            using FSDEF = Field<16, 1>;    // FSDEF
            using FSPOL = Field<17, 1>;    // FSPOL
            using FSOFF = Field<18, 1>;    // FSOFF
        };

        // This register has no meaning in and SPDIF audio protocol
        struct SAI_ASLOTR : public Register<0x4400b010> {
            using FBOFF = Field<0, 5>;    // FBOFF
            using SLOTSZ = Field<6, 2>;    // SLOTSZ
            using NBSLOT = Field<8, 4>;    // NBSLOT
            using SLOTEN = Field<16, 16>;    // SLOTEN
        };

        // Interrupt mask register
        struct SAI_AIM : public Register<0x4400b014> {
            using OVRUDRIE = Field<0, 1>;    // OVRUDRIE
            using MUTEDETIE = Field<1, 1>;    // MUTEDETIE
            using WCKCFGIE = Field<2, 1>;    // WCKCFGIE
            using FREQIE = Field<3, 1>;    // FREQIE
            using CNRDYIE = Field<4, 1>;    // CNRDYIE
            using AFSDETIE = Field<5, 1>;    // AFSDETIE
            using LFSDETIE = Field<6, 1>;    // LFSDETIE
        };

        // Status register
        struct SAI_ASR : public RegisterReadOnly<0x4400b018> {
            using OVRUDR = Field<0, 1>;    // OVRUDR
            using MUTEDET = Field<1, 1>;    // MUTEDET
            using WCKCFG = Field<2, 1>;    // WCKCFG
            using FREQ = Field<3, 1>;    // FREQ
            using CNRDY = Field<4, 1>;    // CNRDY
            using AFSDET = Field<5, 1>;    // AFSDET
            using LFSDET = Field<6, 1>;    // LFSDET
            using FLVL = Field<16, 3>;    // FLVL
        };

        // Clear flag register
        struct SAI_ACLRFR : public RegisterWriteOnly<0x4400b01c> {
            using COVRUDR = Field<0, 1>;    // COVRUDR
            using CMUTEDET = Field<1, 1>;    // CMUTEDET
            using CWCKCFG = Field<2, 1>;    // CWCKCFG
            using CCNRDY = Field<4, 1>;    // CCNRDY
            using CAFSDET = Field<5, 1>;    // CAFSDET
            using CLFSDET = Field<6, 1>;    // CLFSDET
        };

        // Data register
        struct SAI_ADR : public Register<0x4400b020> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Configuration register 1
        struct SAI_BCR1 : public Register<0x4400b024> {
            using MODE = Field<0, 2>;    // MODE
            using PRTCFG = Field<2, 2>;    // PRTCFG
            using DS = Field<5, 3>;    // DS
            using LSBFIRST = Field<8, 1>;    // LSBFIRST
            using CKSTR = Field<9, 1>;    // CKSTR
            using SYNCEN = Field<10, 2>;    // SYNCEN
            using MONO = Field<12, 1>;    // MONO
            using OUTDRIV = Field<13, 1>;    // OUTDRIV
            using SAIEN = Field<16, 1>;    // SAIEN
            using DMAEN = Field<17, 1>;    // DMAEN
            using NODIV = Field<19, 1>;    // NODIV
            using MCKDIV = Field<20, 6>;    // MCKDIV
            using OSR = Field<26, 1>;    // OSR
            using MCKEN = Field<27, 1>;    // MCKEN
        };

        // Configuration register 2
        struct SAI_BCR2 : public Register<0x4400b028> {
            using FTH = Field<0, 3>;    // FTH
            using FFLUSH = Field<3, 1>;    // FFLUSH
            using TRIS = Field<4, 1>;    // TRIS
            using MUTE = Field<5, 1>;    // MUTE
            using MUTEVAL = Field<6, 1>;    // MUTEVAL
            using MUTECNT = Field<7, 6>;    // MUTECNT
            using CPL = Field<13, 1>;    // CPL
            using COMP = Field<14, 2>;    // COMP
        };

        // This register has no meaning in and SPDIF audio protocol
        struct SAI_BFRCR : public Register<0x4400b02c> {
            using FRL = Field<0, 8>;    // FRL
            using FSALL = Field<8, 7>;    // FSALL
            using FSDEF = Field<16, 1>;    // FSDEF
            using FSPOL = Field<17, 1>;    // FSPOL
            using FSOFF = Field<18, 1>;    // FSOFF
        };

        // This register has no meaning in and SPDIF audio protocol
        struct SAI_BSLOTR : public Register<0x4400b030> {
            using FBOFF = Field<0, 5>;    // FBOFF
            using SLOTSZ = Field<6, 2>;    // SLOTSZ
            using NBSLOT = Field<8, 4>;    // NBSLOT
            using SLOTEN = Field<16, 16>;    // SLOTEN
        };

        // Interrupt mask register
        struct SAI_BIM : public Register<0x4400b034> {
            using OVRUDRIE = Field<0, 1>;    // OVRUDRIE
            using MUTEDETIE = Field<1, 1>;    // MUTEDETIE
            using WCKCFGIE = Field<2, 1>;    // WCKCFGIE
            using FREQIE = Field<3, 1>;    // FREQIE
            using CNRDYIE = Field<4, 1>;    // CNRDYIE
            using AFSDETIE = Field<5, 1>;    // AFSDETIE
            using LFSDETIE = Field<6, 1>;    // LFSDETIE
        };

        // Status register
        struct SAI_BSR : public RegisterReadOnly<0x4400b038> {
            using OVRUDR = Field<0, 1>;    // OVRUDR
            using MUTEDET = Field<1, 1>;    // MUTEDET
            using WCKCFG = Field<2, 1>;    // WCKCFG
            using FREQ = Field<3, 1>;    // FREQ
            using CNRDY = Field<4, 1>;    // CNRDY
            using AFSDET = Field<5, 1>;    // AFSDET
            using LFSDET = Field<6, 1>;    // LFSDET
            using FLVL = Field<16, 3>;    // FLVL
        };

        // Clear flag register
        struct SAI_BCLRFR : public RegisterWriteOnly<0x4400b03c> {
            using COVRUDR = Field<0, 1>;    // COVRUDR
            using CMUTEDET = Field<1, 1>;    // CMUTEDET
            using CWCKCFG = Field<2, 1>;    // CWCKCFG
            using CCNRDY = Field<4, 1>;    // CCNRDY
            using CAFSDET = Field<5, 1>;    // CAFSDET
            using CLFSDET = Field<6, 1>;    // CLFSDET
        };

        // Data register
        struct SAI_BDR : public Register<0x4400b040> {
            using DATA = Field<0, 32>;    // DATA
        };

        // PDM control register
        struct SAI_PDMCR : public Register<0x4400b044> {
            using PDMEN = Field<0, 1>;    // PDMEN
            using MICNBR = Field<4, 2>;    // MICNBR
            using CKEN1 = Field<8, 1>;    // CKEN1
            using CKEN2 = Field<9, 1>;    // CKEN2
            using CKEN3 = Field<10, 1>;    // CKEN3
            using CKEN4 = Field<11, 1>;    // CKEN4
        };

        // PDM delay register
        struct SAI_PDMDLY : public Register<0x4400b048> {
            using DLYM1L = Field<0, 3>;    // DLYM1L
            using DLYM1R = Field<4, 3>;    // DLYM1R
            using DLYM2L = Field<8, 3>;    // DLYM2L
            using DLYM2R = Field<12, 3>;    // DLYM2R
            using DLYM3L = Field<16, 3>;    // DLYM3L
            using DLYM3R = Field<20, 3>;    // DLYM3R
            using DLYM4L = Field<24, 3>;    // DLYM4L
            using DLYM4R = Field<28, 3>;    // DLYM4R
        };

        // SAI hardware configuration register
        struct SAI_HWCFGR : public RegisterReadOnly<0x4400b3f0> {
            using FIFO_SIZE = Field<0, 8>;    // FIFO_SIZE
            using SPDIF_PDM = Field<8, 4>;    // SPDIF_PDM
            using OPTION_REGOUT = Field<12, 8>;    // OPTION_REGOUT
        };

        // SAI version register
        struct SAI_VERR : public RegisterReadOnly<0x4400b3f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // SAI identification register
        struct SAI_IPIDR : public RegisterReadOnly<0x4400b3f8> {
            using ID = Field<0, 32>;    // ID
        };

        // SAI size identification register
        struct SAI_SIDR : public RegisterReadOnly<0x4400b3fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // SAI1 register block
    struct SAI3 {
        // Global configuration register
        struct SAI_GCR : public Register<0x4400c000> {
            using SYNCIN = Field<0, 2>;    // SYNCIN
            using SYNCOUT = Field<4, 2>;    // SYNCOUT
        };

        // Configuration register 1
        struct SAI_ACR1 : public Register<0x4400c004> {
            using MODE = Field<0, 2>;    // MODE
            using PRTCFG = Field<2, 2>;    // PRTCFG
            using DS = Field<5, 3>;    // DS
            using LSBFIRST = Field<8, 1>;    // LSBFIRST
            using CKSTR = Field<9, 1>;    // CKSTR
            using SYNCEN = Field<10, 2>;    // SYNCEN
            using MONO = Field<12, 1>;    // MONO
            using OUTDRIV = Field<13, 1>;    // OUTDRIV
            using SAIEN = Field<16, 1>;    // SAIEN
            using DMAEN = Field<17, 1>;    // DMAEN
            using NODIV = Field<19, 1>;    // NODIV
            using MCKDIV = Field<20, 6>;    // MCKDIV
            using OSR = Field<26, 1>;    // OSR
            using MCKEN = Field<27, 1>;    // MCKEN
        };

        // Configuration register 2
        struct SAI_ACR2 : public Register<0x4400c008> {
            using FTH = Field<0, 3>;    // FTH
            using FFLUSH = Field<3, 1>;    // FFLUSH
            using TRIS = Field<4, 1>;    // TRIS
            using MUTE = Field<5, 1>;    // MUTE
            using MUTEVAL = Field<6, 1>;    // MUTEVAL
            using MUTECNT = Field<7, 6>;    // MUTECNT
            using CPL = Field<13, 1>;    // CPL
            using COMP = Field<14, 2>;    // COMP
        };

        // This register has no meaning in and SPDIF audio protocol
        struct SAI_AFRCR : public Register<0x4400c00c> {
            using FRL = Field<0, 8>;    // FRL
            using FSALL = Field<8, 7>;    // FSALL
            using FSDEF = Field<16, 1>;    // FSDEF
            using FSPOL = Field<17, 1>;    // FSPOL
            using FSOFF = Field<18, 1>;    // FSOFF
        };

        // This register has no meaning in and SPDIF audio protocol
        struct SAI_ASLOTR : public Register<0x4400c010> {
            using FBOFF = Field<0, 5>;    // FBOFF
            using SLOTSZ = Field<6, 2>;    // SLOTSZ
            using NBSLOT = Field<8, 4>;    // NBSLOT
            using SLOTEN = Field<16, 16>;    // SLOTEN
        };

        // Interrupt mask register
        struct SAI_AIM : public Register<0x4400c014> {
            using OVRUDRIE = Field<0, 1>;    // OVRUDRIE
            using MUTEDETIE = Field<1, 1>;    // MUTEDETIE
            using WCKCFGIE = Field<2, 1>;    // WCKCFGIE
            using FREQIE = Field<3, 1>;    // FREQIE
            using CNRDYIE = Field<4, 1>;    // CNRDYIE
            using AFSDETIE = Field<5, 1>;    // AFSDETIE
            using LFSDETIE = Field<6, 1>;    // LFSDETIE
        };

        // Status register
        struct SAI_ASR : public RegisterReadOnly<0x4400c018> {
            using OVRUDR = Field<0, 1>;    // OVRUDR
            using MUTEDET = Field<1, 1>;    // MUTEDET
            using WCKCFG = Field<2, 1>;    // WCKCFG
            using FREQ = Field<3, 1>;    // FREQ
            using CNRDY = Field<4, 1>;    // CNRDY
            using AFSDET = Field<5, 1>;    // AFSDET
            using LFSDET = Field<6, 1>;    // LFSDET
            using FLVL = Field<16, 3>;    // FLVL
        };

        // Clear flag register
        struct SAI_ACLRFR : public RegisterWriteOnly<0x4400c01c> {
            using COVRUDR = Field<0, 1>;    // COVRUDR
            using CMUTEDET = Field<1, 1>;    // CMUTEDET
            using CWCKCFG = Field<2, 1>;    // CWCKCFG
            using CCNRDY = Field<4, 1>;    // CCNRDY
            using CAFSDET = Field<5, 1>;    // CAFSDET
            using CLFSDET = Field<6, 1>;    // CLFSDET
        };

        // Data register
        struct SAI_ADR : public Register<0x4400c020> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Configuration register 1
        struct SAI_BCR1 : public Register<0x4400c024> {
            using MODE = Field<0, 2>;    // MODE
            using PRTCFG = Field<2, 2>;    // PRTCFG
            using DS = Field<5, 3>;    // DS
            using LSBFIRST = Field<8, 1>;    // LSBFIRST
            using CKSTR = Field<9, 1>;    // CKSTR
            using SYNCEN = Field<10, 2>;    // SYNCEN
            using MONO = Field<12, 1>;    // MONO
            using OUTDRIV = Field<13, 1>;    // OUTDRIV
            using SAIEN = Field<16, 1>;    // SAIEN
            using DMAEN = Field<17, 1>;    // DMAEN
            using NODIV = Field<19, 1>;    // NODIV
            using MCKDIV = Field<20, 6>;    // MCKDIV
            using OSR = Field<26, 1>;    // OSR
            using MCKEN = Field<27, 1>;    // MCKEN
        };

        // Configuration register 2
        struct SAI_BCR2 : public Register<0x4400c028> {
            using FTH = Field<0, 3>;    // FTH
            using FFLUSH = Field<3, 1>;    // FFLUSH
            using TRIS = Field<4, 1>;    // TRIS
            using MUTE = Field<5, 1>;    // MUTE
            using MUTEVAL = Field<6, 1>;    // MUTEVAL
            using MUTECNT = Field<7, 6>;    // MUTECNT
            using CPL = Field<13, 1>;    // CPL
            using COMP = Field<14, 2>;    // COMP
        };

        // This register has no meaning in and SPDIF audio protocol
        struct SAI_BFRCR : public Register<0x4400c02c> {
            using FRL = Field<0, 8>;    // FRL
            using FSALL = Field<8, 7>;    // FSALL
            using FSDEF = Field<16, 1>;    // FSDEF
            using FSPOL = Field<17, 1>;    // FSPOL
            using FSOFF = Field<18, 1>;    // FSOFF
        };

        // This register has no meaning in and SPDIF audio protocol
        struct SAI_BSLOTR : public Register<0x4400c030> {
            using FBOFF = Field<0, 5>;    // FBOFF
            using SLOTSZ = Field<6, 2>;    // SLOTSZ
            using NBSLOT = Field<8, 4>;    // NBSLOT
            using SLOTEN = Field<16, 16>;    // SLOTEN
        };

        // Interrupt mask register
        struct SAI_BIM : public Register<0x4400c034> {
            using OVRUDRIE = Field<0, 1>;    // OVRUDRIE
            using MUTEDETIE = Field<1, 1>;    // MUTEDETIE
            using WCKCFGIE = Field<2, 1>;    // WCKCFGIE
            using FREQIE = Field<3, 1>;    // FREQIE
            using CNRDYIE = Field<4, 1>;    // CNRDYIE
            using AFSDETIE = Field<5, 1>;    // AFSDETIE
            using LFSDETIE = Field<6, 1>;    // LFSDETIE
        };

        // Status register
        struct SAI_BSR : public RegisterReadOnly<0x4400c038> {
            using OVRUDR = Field<0, 1>;    // OVRUDR
            using MUTEDET = Field<1, 1>;    // MUTEDET
            using WCKCFG = Field<2, 1>;    // WCKCFG
            using FREQ = Field<3, 1>;    // FREQ
            using CNRDY = Field<4, 1>;    // CNRDY
            using AFSDET = Field<5, 1>;    // AFSDET
            using LFSDET = Field<6, 1>;    // LFSDET
            using FLVL = Field<16, 3>;    // FLVL
        };

        // Clear flag register
        struct SAI_BCLRFR : public RegisterWriteOnly<0x4400c03c> {
            using COVRUDR = Field<0, 1>;    // COVRUDR
            using CMUTEDET = Field<1, 1>;    // CMUTEDET
            using CWCKCFG = Field<2, 1>;    // CWCKCFG
            using CCNRDY = Field<4, 1>;    // CCNRDY
            using CAFSDET = Field<5, 1>;    // CAFSDET
            using CLFSDET = Field<6, 1>;    // CLFSDET
        };

        // Data register
        struct SAI_BDR : public Register<0x4400c040> {
            using DATA = Field<0, 32>;    // DATA
        };

        // PDM control register
        struct SAI_PDMCR : public Register<0x4400c044> {
            using PDMEN = Field<0, 1>;    // PDMEN
            using MICNBR = Field<4, 2>;    // MICNBR
            using CKEN1 = Field<8, 1>;    // CKEN1
            using CKEN2 = Field<9, 1>;    // CKEN2
            using CKEN3 = Field<10, 1>;    // CKEN3
            using CKEN4 = Field<11, 1>;    // CKEN4
        };

        // PDM delay register
        struct SAI_PDMDLY : public Register<0x4400c048> {
            using DLYM1L = Field<0, 3>;    // DLYM1L
            using DLYM1R = Field<4, 3>;    // DLYM1R
            using DLYM2L = Field<8, 3>;    // DLYM2L
            using DLYM2R = Field<12, 3>;    // DLYM2R
            using DLYM3L = Field<16, 3>;    // DLYM3L
            using DLYM3R = Field<20, 3>;    // DLYM3R
            using DLYM4L = Field<24, 3>;    // DLYM4L
            using DLYM4R = Field<28, 3>;    // DLYM4R
        };

        // SAI hardware configuration register
        struct SAI_HWCFGR : public RegisterReadOnly<0x4400c3f0> {
            using FIFO_SIZE = Field<0, 8>;    // FIFO_SIZE
            using SPDIF_PDM = Field<8, 4>;    // SPDIF_PDM
            using OPTION_REGOUT = Field<12, 8>;    // OPTION_REGOUT
        };

        // SAI version register
        struct SAI_VERR : public RegisterReadOnly<0x4400c3f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // SAI identification register
        struct SAI_IPIDR : public RegisterReadOnly<0x4400c3f8> {
            using ID = Field<0, 32>;    // ID
        };

        // SAI size identification register
        struct SAI_SIDR : public RegisterReadOnly<0x4400c3fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // SAI1 register block
    struct SAI4 {
        // Global configuration register
        struct SAI_GCR : public Register<0x50027000> {
            using SYNCIN = Field<0, 2>;    // SYNCIN
            using SYNCOUT = Field<4, 2>;    // SYNCOUT
        };

        // Configuration register 1
        struct SAI_ACR1 : public Register<0x50027004> {
            using MODE = Field<0, 2>;    // MODE
            using PRTCFG = Field<2, 2>;    // PRTCFG
            using DS = Field<5, 3>;    // DS
            using LSBFIRST = Field<8, 1>;    // LSBFIRST
            using CKSTR = Field<9, 1>;    // CKSTR
            using SYNCEN = Field<10, 2>;    // SYNCEN
            using MONO = Field<12, 1>;    // MONO
            using OUTDRIV = Field<13, 1>;    // OUTDRIV
            using SAIEN = Field<16, 1>;    // SAIEN
            using DMAEN = Field<17, 1>;    // DMAEN
            using NODIV = Field<19, 1>;    // NODIV
            using MCKDIV = Field<20, 6>;    // MCKDIV
            using OSR = Field<26, 1>;    // OSR
            using MCKEN = Field<27, 1>;    // MCKEN
        };

        // Configuration register 2
        struct SAI_ACR2 : public Register<0x50027008> {
            using FTH = Field<0, 3>;    // FTH
            using FFLUSH = Field<3, 1>;    // FFLUSH
            using TRIS = Field<4, 1>;    // TRIS
            using MUTE = Field<5, 1>;    // MUTE
            using MUTEVAL = Field<6, 1>;    // MUTEVAL
            using MUTECNT = Field<7, 6>;    // MUTECNT
            using CPL = Field<13, 1>;    // CPL
            using COMP = Field<14, 2>;    // COMP
        };

        // This register has no meaning in and SPDIF audio protocol
        struct SAI_AFRCR : public Register<0x5002700c> {
            using FRL = Field<0, 8>;    // FRL
            using FSALL = Field<8, 7>;    // FSALL
            using FSDEF = Field<16, 1>;    // FSDEF
            using FSPOL = Field<17, 1>;    // FSPOL
            using FSOFF = Field<18, 1>;    // FSOFF
        };

        // This register has no meaning in and SPDIF audio protocol
        struct SAI_ASLOTR : public Register<0x50027010> {
            using FBOFF = Field<0, 5>;    // FBOFF
            using SLOTSZ = Field<6, 2>;    // SLOTSZ
            using NBSLOT = Field<8, 4>;    // NBSLOT
            using SLOTEN = Field<16, 16>;    // SLOTEN
        };

        // Interrupt mask register
        struct SAI_AIM : public Register<0x50027014> {
            using OVRUDRIE = Field<0, 1>;    // OVRUDRIE
            using MUTEDETIE = Field<1, 1>;    // MUTEDETIE
            using WCKCFGIE = Field<2, 1>;    // WCKCFGIE
            using FREQIE = Field<3, 1>;    // FREQIE
            using CNRDYIE = Field<4, 1>;    // CNRDYIE
            using AFSDETIE = Field<5, 1>;    // AFSDETIE
            using LFSDETIE = Field<6, 1>;    // LFSDETIE
        };

        // Status register
        struct SAI_ASR : public RegisterReadOnly<0x50027018> {
            using OVRUDR = Field<0, 1>;    // OVRUDR
            using MUTEDET = Field<1, 1>;    // MUTEDET
            using WCKCFG = Field<2, 1>;    // WCKCFG
            using FREQ = Field<3, 1>;    // FREQ
            using CNRDY = Field<4, 1>;    // CNRDY
            using AFSDET = Field<5, 1>;    // AFSDET
            using LFSDET = Field<6, 1>;    // LFSDET
            using FLVL = Field<16, 3>;    // FLVL
        };

        // Clear flag register
        struct SAI_ACLRFR : public RegisterWriteOnly<0x5002701c> {
            using COVRUDR = Field<0, 1>;    // COVRUDR
            using CMUTEDET = Field<1, 1>;    // CMUTEDET
            using CWCKCFG = Field<2, 1>;    // CWCKCFG
            using CCNRDY = Field<4, 1>;    // CCNRDY
            using CAFSDET = Field<5, 1>;    // CAFSDET
            using CLFSDET = Field<6, 1>;    // CLFSDET
        };

        // Data register
        struct SAI_ADR : public Register<0x50027020> {
            using DATA = Field<0, 32>;    // DATA
        };

        // Configuration register 1
        struct SAI_BCR1 : public Register<0x50027024> {
            using MODE = Field<0, 2>;    // MODE
            using PRTCFG = Field<2, 2>;    // PRTCFG
            using DS = Field<5, 3>;    // DS
            using LSBFIRST = Field<8, 1>;    // LSBFIRST
            using CKSTR = Field<9, 1>;    // CKSTR
            using SYNCEN = Field<10, 2>;    // SYNCEN
            using MONO = Field<12, 1>;    // MONO
            using OUTDRIV = Field<13, 1>;    // OUTDRIV
            using SAIEN = Field<16, 1>;    // SAIEN
            using DMAEN = Field<17, 1>;    // DMAEN
            using NODIV = Field<19, 1>;    // NODIV
            using MCKDIV = Field<20, 6>;    // MCKDIV
            using OSR = Field<26, 1>;    // OSR
            using MCKEN = Field<27, 1>;    // MCKEN
        };

        // Configuration register 2
        struct SAI_BCR2 : public Register<0x50027028> {
            using FTH = Field<0, 3>;    // FTH
            using FFLUSH = Field<3, 1>;    // FFLUSH
            using TRIS = Field<4, 1>;    // TRIS
            using MUTE = Field<5, 1>;    // MUTE
            using MUTEVAL = Field<6, 1>;    // MUTEVAL
            using MUTECNT = Field<7, 6>;    // MUTECNT
            using CPL = Field<13, 1>;    // CPL
            using COMP = Field<14, 2>;    // COMP
        };

        // This register has no meaning in and SPDIF audio protocol
        struct SAI_BFRCR : public Register<0x5002702c> {
            using FRL = Field<0, 8>;    // FRL
            using FSALL = Field<8, 7>;    // FSALL
            using FSDEF = Field<16, 1>;    // FSDEF
            using FSPOL = Field<17, 1>;    // FSPOL
            using FSOFF = Field<18, 1>;    // FSOFF
        };

        // This register has no meaning in and SPDIF audio protocol
        struct SAI_BSLOTR : public Register<0x50027030> {
            using FBOFF = Field<0, 5>;    // FBOFF
            using SLOTSZ = Field<6, 2>;    // SLOTSZ
            using NBSLOT = Field<8, 4>;    // NBSLOT
            using SLOTEN = Field<16, 16>;    // SLOTEN
        };

        // Interrupt mask register
        struct SAI_BIM : public Register<0x50027034> {
            using OVRUDRIE = Field<0, 1>;    // OVRUDRIE
            using MUTEDETIE = Field<1, 1>;    // MUTEDETIE
            using WCKCFGIE = Field<2, 1>;    // WCKCFGIE
            using FREQIE = Field<3, 1>;    // FREQIE
            using CNRDYIE = Field<4, 1>;    // CNRDYIE
            using AFSDETIE = Field<5, 1>;    // AFSDETIE
            using LFSDETIE = Field<6, 1>;    // LFSDETIE
        };

        // Status register
        struct SAI_BSR : public RegisterReadOnly<0x50027038> {
            using OVRUDR = Field<0, 1>;    // OVRUDR
            using MUTEDET = Field<1, 1>;    // MUTEDET
            using WCKCFG = Field<2, 1>;    // WCKCFG
            using FREQ = Field<3, 1>;    // FREQ
            using CNRDY = Field<4, 1>;    // CNRDY
            using AFSDET = Field<5, 1>;    // AFSDET
            using LFSDET = Field<6, 1>;    // LFSDET
            using FLVL = Field<16, 3>;    // FLVL
        };

        // Clear flag register
        struct SAI_BCLRFR : public RegisterWriteOnly<0x5002703c> {
            using COVRUDR = Field<0, 1>;    // COVRUDR
            using CMUTEDET = Field<1, 1>;    // CMUTEDET
            using CWCKCFG = Field<2, 1>;    // CWCKCFG
            using CCNRDY = Field<4, 1>;    // CCNRDY
            using CAFSDET = Field<5, 1>;    // CAFSDET
            using CLFSDET = Field<6, 1>;    // CLFSDET
        };

        // Data register
        struct SAI_BDR : public Register<0x50027040> {
            using DATA = Field<0, 32>;    // DATA
        };

        // PDM control register
        struct SAI_PDMCR : public Register<0x50027044> {
            using PDMEN = Field<0, 1>;    // PDMEN
            using MICNBR = Field<4, 2>;    // MICNBR
            using CKEN1 = Field<8, 1>;    // CKEN1
            using CKEN2 = Field<9, 1>;    // CKEN2
            using CKEN3 = Field<10, 1>;    // CKEN3
            using CKEN4 = Field<11, 1>;    // CKEN4
        };

        // PDM delay register
        struct SAI_PDMDLY : public Register<0x50027048> {
            using DLYM1L = Field<0, 3>;    // DLYM1L
            using DLYM1R = Field<4, 3>;    // DLYM1R
            using DLYM2L = Field<8, 3>;    // DLYM2L
            using DLYM2R = Field<12, 3>;    // DLYM2R
            using DLYM3L = Field<16, 3>;    // DLYM3L
            using DLYM3R = Field<20, 3>;    // DLYM3R
            using DLYM4L = Field<24, 3>;    // DLYM4L
            using DLYM4R = Field<28, 3>;    // DLYM4R
        };

        // SAI hardware configuration register
        struct SAI_HWCFGR : public RegisterReadOnly<0x500273f0> {
            using FIFO_SIZE = Field<0, 8>;    // FIFO_SIZE
            using SPDIF_PDM = Field<8, 4>;    // SPDIF_PDM
            using OPTION_REGOUT = Field<12, 8>;    // OPTION_REGOUT
        };

        // SAI version register
        struct SAI_VERR : public RegisterReadOnly<0x500273f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // SAI identification register
        struct SAI_IPIDR : public RegisterReadOnly<0x500273f8> {
            using ID = Field<0, 32>;    // ID
        };

        // SAI size identification register
        struct SAI_SIDR : public RegisterReadOnly<0x500273fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // VREFBUF
    struct VREFBUF {
        // VREFBUF control and status register
        struct VREFBUF_CSR : public Register<0x50025000> {
            using ENVR = Field<0, 1>;    // ENVR
            using HIZ = Field<1, 1>;    // HIZ
            using VRR = Field<3, 1>;    // VRR
            using VRS = Field<4, 3>;    // VRS
        };

        // VREFBUF calibration control register
        struct VREFBUF_CCR : public Register<0x50025004> {
            using TRIM = Field<0, 6>;    // TRIM
        };

    };

    // LPTIM1
    struct LPTIM1 {
        // LPTIM interrupt and status register
        struct LPTIM_ISR : public RegisterReadOnly<0x40009000> {
            using CMPM = Field<0, 1>;    // CMPM
            using ARRM = Field<1, 1>;    // ARRM
            using EXTTRIG = Field<2, 1>;    // EXTTRIG
            using CMPOK = Field<3, 1>;    // CMPOK
            using ARROK = Field<4, 1>;    // ARROK
            using UP = Field<5, 1>;    // UP
            using DOWN = Field<6, 1>;    // DOWN
        };

        // LPTIM interrupt clear register
        struct LPTIM_ICR : public RegisterWriteOnly<0x40009004> {
            using CMPMCF = Field<0, 1>;    // CMPMCF
            using ARRMCF = Field<1, 1>;    // ARRMCF
            using EXTTRIGCF = Field<2, 1>;    // EXTTRIGCF
            using CMPOKCF = Field<3, 1>;    // CMPOKCF
            using ARROKCF = Field<4, 1>;    // ARROKCF
            using UPCF = Field<5, 1>;    // UPCF
            using DOWNCF = Field<6, 1>;    // DOWNCF
        };

        // LPTIM interrupt enable register
        struct LPTIM_IER : public Register<0x40009008> {
            using CMPMIE = Field<0, 1>;    // CMPMIE
            using ARRMIE = Field<1, 1>;    // ARRMIE
            using EXTTRIGIE = Field<2, 1>;    // EXTTRIGIE
            using CMPOKIE = Field<3, 1>;    // CMPOKIE
            using ARROKIE = Field<4, 1>;    // ARROKIE
            using UPIE = Field<5, 1>;    // UPIE
            using DOWNIE = Field<6, 1>;    // DOWNIE
        };

        // LPTIM configuration register
        struct LPTIM_CFGR : public Register<0x4000900c> {
            using CKSEL = Field<0, 1>;    // CKSEL
            using CKPOL = Field<1, 2>;    // CKPOL
            using CKFLT = Field<3, 2>;    // CKFLT
            using TRGFLT = Field<6, 2>;    // TRGFLT
            using PRESC = Field<9, 3>;    // PRESC
            using TRIGSEL = Field<13, 3>;    // TRIGSEL
            using TRIGEN = Field<17, 2>;    // TRIGEN
            using TIMOUT = Field<19, 1>;    // TIMOUT
            using WAVE = Field<20, 1>;    // WAVE
            using WAVPOL = Field<21, 1>;    // WAVPOL
            using PRELOAD = Field<22, 1>;    // PRELOAD
            using COUNTMODE = Field<23, 1>;    // COUNTMODE
            using ENC = Field<24, 1>;    // ENC
        };

        // LPTIM control register
        struct LPTIM_CR : public Register<0x40009010> {
            using ENABLE = Field<0, 1>;    // ENABLE
            using SNGSTRT = Field<1, 1>;    // SNGSTRT
            using CNTSTRT = Field<2, 1>;    // CNTSTRT
            using COUNTRST = Field<3, 1>;    // COUNTRST
            using RSTARE = Field<4, 1>;    // RSTARE
        };

        // LPTIM compare register
        struct LPTIM_CMP : public Register<0x40009014> {
            using CMP = Field<0, 16>;    // CMP
        };

        // LPTIM autoreload register
        struct LPTIM_ARR : public Register<0x40009018> {
            using ARR = Field<0, 16>;    // ARR
        };

        // LPTIM counter register
        struct LPTIM_CNT : public RegisterReadOnly<0x4000901c> {
            using CNT = Field<0, 16>;    // CNT
        };

        // LPTIM configuration register 2
        struct LPTIM_CFGR2 : public Register<0x40009024> {
            using IN1SEL = Field<0, 2>;    // IN1SEL
            using IN2SEL = Field<4, 2>;    // IN2SEL
        };

        // LPTIM 1 peripheral hardware configuration register
        struct LPTIM1_HWCFGR : public RegisterReadOnly<0x400093f0> {
            using CFG1 = Field<0, 8>;    // CFG1
            using CFG2 = Field<8, 8>;    // CFG2
            using CFG3 = Field<16, 4>;    // CFG3
            using CFG4 = Field<24, 8>;    // CFG4
        };

        // LPTIM peripheral version identification register
        struct LPTIM_VERR : public RegisterReadOnly<0x400093f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // LPTIM peripheral type identification register
        struct LPTIM_PIDR : public RegisterReadOnly<0x400093f8> {
            using P_ID = Field<0, 32>;    // P_ID
        };

        // LPTIM registers map size identification register
        struct LPTIM_SIDR : public RegisterReadOnly<0x400093fc> {
            using S_ID = Field<0, 32>;    // S_ID
        };

    };

    // LPTIM2
    struct LPTIM2 {
        // LPTIM 2 peripheral hardware configuration register
        struct LPTIM2_HWCFGR : public RegisterReadOnly<0x500213f0> {
            using CFG1 = Field<0, 8>;    // CFG1
            using CFG2 = Field<8, 8>;    // CFG2
            using CFG3 = Field<16, 4>;    // CFG3
            using CFG4 = Field<24, 8>;    // CFG4
        };

        // LPTIM interrupt and status register
        struct LPTIM_ISR : public RegisterReadOnly<0x50021000> {
            using CMPM = Field<0, 1>;    // CMPM
            using ARRM = Field<1, 1>;    // ARRM
            using EXTTRIG = Field<2, 1>;    // EXTTRIG
            using CMPOK = Field<3, 1>;    // CMPOK
            using ARROK = Field<4, 1>;    // ARROK
            using UP = Field<5, 1>;    // UP
            using DOWN = Field<6, 1>;    // DOWN
        };

        // LPTIM interrupt clear register
        struct LPTIM_ICR : public RegisterWriteOnly<0x50021004> {
            using CMPMCF = Field<0, 1>;    // CMPMCF
            using ARRMCF = Field<1, 1>;    // ARRMCF
            using EXTTRIGCF = Field<2, 1>;    // EXTTRIGCF
            using CMPOKCF = Field<3, 1>;    // CMPOKCF
            using ARROKCF = Field<4, 1>;    // ARROKCF
            using UPCF = Field<5, 1>;    // UPCF
            using DOWNCF = Field<6, 1>;    // DOWNCF
        };

        // LPTIM interrupt enable register
        struct LPTIM_IER : public Register<0x50021008> {
            using CMPMIE = Field<0, 1>;    // CMPMIE
            using ARRMIE = Field<1, 1>;    // ARRMIE
            using EXTTRIGIE = Field<2, 1>;    // EXTTRIGIE
            using CMPOKIE = Field<3, 1>;    // CMPOKIE
            using ARROKIE = Field<4, 1>;    // ARROKIE
            using UPIE = Field<5, 1>;    // UPIE
            using DOWNIE = Field<6, 1>;    // DOWNIE
        };

        // LPTIM configuration register
        struct LPTIM_CFGR : public Register<0x5002100c> {
            using CKSEL = Field<0, 1>;    // CKSEL
            using CKPOL = Field<1, 2>;    // CKPOL
            using CKFLT = Field<3, 2>;    // CKFLT
            using TRGFLT = Field<6, 2>;    // TRGFLT
            using PRESC = Field<9, 3>;    // PRESC
            using TRIGSEL = Field<13, 3>;    // TRIGSEL
            using TRIGEN = Field<17, 2>;    // TRIGEN
            using TIMOUT = Field<19, 1>;    // TIMOUT
            using WAVE = Field<20, 1>;    // WAVE
            using WAVPOL = Field<21, 1>;    // WAVPOL
            using PRELOAD = Field<22, 1>;    // PRELOAD
            using COUNTMODE = Field<23, 1>;    // COUNTMODE
            using ENC = Field<24, 1>;    // ENC
        };

        // LPTIM control register
        struct LPTIM_CR : public Register<0x50021010> {
            using ENABLE = Field<0, 1>;    // ENABLE
            using SNGSTRT = Field<1, 1>;    // SNGSTRT
            using CNTSTRT = Field<2, 1>;    // CNTSTRT
            using COUNTRST = Field<3, 1>;    // COUNTRST
            using RSTARE = Field<4, 1>;    // RSTARE
        };

        // LPTIM compare register
        struct LPTIM_CMP : public Register<0x50021014> {
            using CMP = Field<0, 16>;    // CMP
        };

        // LPTIM autoreload register
        struct LPTIM_ARR : public Register<0x50021018> {
            using ARR = Field<0, 16>;    // ARR
        };

        // LPTIM counter register
        struct LPTIM_CNT : public RegisterReadOnly<0x5002101c> {
            using CNT = Field<0, 16>;    // CNT
        };

        // LPTIM configuration register 2
        struct LPTIM_CFGR2 : public Register<0x50021024> {
            using IN1SEL = Field<0, 2>;    // IN1SEL
            using IN2SEL = Field<4, 2>;    // IN2SEL
        };

        // LPTIM peripheral version identification register
        struct LPTIM_VERR : public RegisterReadOnly<0x500213f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // LPTIM peripheral type identification register
        struct LPTIM_PIDR : public RegisterReadOnly<0x500213f8> {
            using P_ID = Field<0, 32>;    // P_ID
        };

        // LPTIM registers map size identification register
        struct LPTIM_SIDR : public RegisterReadOnly<0x500213fc> {
            using S_ID = Field<0, 32>;    // S_ID
        };

    };

    // LPTIM4
    struct LPTIM4 {
        // LPTIM 4 peripheral hardware configuration register
        struct LPTIM4_HWCFGR : public RegisterReadOnly<0x500233f0> {
            using CFG1 = Field<0, 8>;    // CFG1
            using CFG2 = Field<8, 8>;    // CFG2
            using CFG3 = Field<16, 4>;    // CFG3
            using CFG4 = Field<24, 8>;    // CFG4
        };

        // LPTIM interrupt and status register
        struct LPTIM_ISR : public RegisterReadOnly<0x50023000> {
            using CMPM = Field<0, 1>;    // CMPM
            using ARRM = Field<1, 1>;    // ARRM
            using EXTTRIG = Field<2, 1>;    // EXTTRIG
            using CMPOK = Field<3, 1>;    // CMPOK
            using ARROK = Field<4, 1>;    // ARROK
            using UP = Field<5, 1>;    // UP
            using DOWN = Field<6, 1>;    // DOWN
        };

        // LPTIM interrupt clear register
        struct LPTIM_ICR : public RegisterWriteOnly<0x50023004> {
            using CMPMCF = Field<0, 1>;    // CMPMCF
            using ARRMCF = Field<1, 1>;    // ARRMCF
            using EXTTRIGCF = Field<2, 1>;    // EXTTRIGCF
            using CMPOKCF = Field<3, 1>;    // CMPOKCF
            using ARROKCF = Field<4, 1>;    // ARROKCF
            using UPCF = Field<5, 1>;    // UPCF
            using DOWNCF = Field<6, 1>;    // DOWNCF
        };

        // LPTIM interrupt enable register
        struct LPTIM_IER : public Register<0x50023008> {
            using CMPMIE = Field<0, 1>;    // CMPMIE
            using ARRMIE = Field<1, 1>;    // ARRMIE
            using EXTTRIGIE = Field<2, 1>;    // EXTTRIGIE
            using CMPOKIE = Field<3, 1>;    // CMPOKIE
            using ARROKIE = Field<4, 1>;    // ARROKIE
            using UPIE = Field<5, 1>;    // UPIE
            using DOWNIE = Field<6, 1>;    // DOWNIE
        };

        // LPTIM configuration register
        struct LPTIM_CFGR : public Register<0x5002300c> {
            using CKSEL = Field<0, 1>;    // CKSEL
            using CKPOL = Field<1, 2>;    // CKPOL
            using CKFLT = Field<3, 2>;    // CKFLT
            using TRGFLT = Field<6, 2>;    // TRGFLT
            using PRESC = Field<9, 3>;    // PRESC
            using TRIGSEL = Field<13, 3>;    // TRIGSEL
            using TRIGEN = Field<17, 2>;    // TRIGEN
            using TIMOUT = Field<19, 1>;    // TIMOUT
            using WAVE = Field<20, 1>;    // WAVE
            using WAVPOL = Field<21, 1>;    // WAVPOL
            using PRELOAD = Field<22, 1>;    // PRELOAD
            using COUNTMODE = Field<23, 1>;    // COUNTMODE
            using ENC = Field<24, 1>;    // ENC
        };

        // LPTIM control register
        struct LPTIM_CR : public Register<0x50023010> {
            using ENABLE = Field<0, 1>;    // ENABLE
            using SNGSTRT = Field<1, 1>;    // SNGSTRT
            using CNTSTRT = Field<2, 1>;    // CNTSTRT
            using COUNTRST = Field<3, 1>;    // COUNTRST
            using RSTARE = Field<4, 1>;    // RSTARE
        };

        // LPTIM compare register
        struct LPTIM_CMP : public Register<0x50023014> {
            using CMP = Field<0, 16>;    // CMP
        };

        // LPTIM autoreload register
        struct LPTIM_ARR : public Register<0x50023018> {
            using ARR = Field<0, 16>;    // ARR
        };

        // LPTIM counter register
        struct LPTIM_CNT : public RegisterReadOnly<0x5002301c> {
            using CNT = Field<0, 16>;    // CNT
        };

        // LPTIM configuration register 2
        struct LPTIM_CFGR2 : public Register<0x50023024> {
            using IN1SEL = Field<0, 2>;    // IN1SEL
            using IN2SEL = Field<4, 2>;    // IN2SEL
        };

        // LPTIM peripheral version identification register
        struct LPTIM_VERR : public RegisterReadOnly<0x500233f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // LPTIM peripheral type identification register
        struct LPTIM_PIDR : public RegisterReadOnly<0x500233f8> {
            using P_ID = Field<0, 32>;    // P_ID
        };

        // LPTIM registers map size identification register
        struct LPTIM_SIDR : public RegisterReadOnly<0x500233fc> {
            using S_ID = Field<0, 32>;    // S_ID
        };

    };

    // LPTIM5
    struct LPTIM5 {
        // LPTIM 5 peripheral hardware configuration register
        struct LPTIM5_HWCFGR : public RegisterReadOnly<0x500243f0> {
            using CFG1 = Field<0, 8>;    // CFG1
            using CFG2 = Field<8, 8>;    // CFG2
            using CFG3 = Field<16, 4>;    // CFG3
            using CFG4 = Field<24, 8>;    // CFG4
        };

        // LPTIM interrupt and status register
        struct LPTIM_ISR : public RegisterReadOnly<0x50024000> {
            using CMPM = Field<0, 1>;    // CMPM
            using ARRM = Field<1, 1>;    // ARRM
            using EXTTRIG = Field<2, 1>;    // EXTTRIG
            using CMPOK = Field<3, 1>;    // CMPOK
            using ARROK = Field<4, 1>;    // ARROK
            using UP = Field<5, 1>;    // UP
            using DOWN = Field<6, 1>;    // DOWN
        };

        // LPTIM interrupt clear register
        struct LPTIM_ICR : public RegisterWriteOnly<0x50024004> {
            using CMPMCF = Field<0, 1>;    // CMPMCF
            using ARRMCF = Field<1, 1>;    // ARRMCF
            using EXTTRIGCF = Field<2, 1>;    // EXTTRIGCF
            using CMPOKCF = Field<3, 1>;    // CMPOKCF
            using ARROKCF = Field<4, 1>;    // ARROKCF
            using UPCF = Field<5, 1>;    // UPCF
            using DOWNCF = Field<6, 1>;    // DOWNCF
        };

        // LPTIM interrupt enable register
        struct LPTIM_IER : public Register<0x50024008> {
            using CMPMIE = Field<0, 1>;    // CMPMIE
            using ARRMIE = Field<1, 1>;    // ARRMIE
            using EXTTRIGIE = Field<2, 1>;    // EXTTRIGIE
            using CMPOKIE = Field<3, 1>;    // CMPOKIE
            using ARROKIE = Field<4, 1>;    // ARROKIE
            using UPIE = Field<5, 1>;    // UPIE
            using DOWNIE = Field<6, 1>;    // DOWNIE
        };

        // LPTIM configuration register
        struct LPTIM_CFGR : public Register<0x5002400c> {
            using CKSEL = Field<0, 1>;    // CKSEL
            using CKPOL = Field<1, 2>;    // CKPOL
            using CKFLT = Field<3, 2>;    // CKFLT
            using TRGFLT = Field<6, 2>;    // TRGFLT
            using PRESC = Field<9, 3>;    // PRESC
            using TRIGSEL = Field<13, 3>;    // TRIGSEL
            using TRIGEN = Field<17, 2>;    // TRIGEN
            using TIMOUT = Field<19, 1>;    // TIMOUT
            using WAVE = Field<20, 1>;    // WAVE
            using WAVPOL = Field<21, 1>;    // WAVPOL
            using PRELOAD = Field<22, 1>;    // PRELOAD
            using COUNTMODE = Field<23, 1>;    // COUNTMODE
            using ENC = Field<24, 1>;    // ENC
        };

        // LPTIM control register
        struct LPTIM_CR : public Register<0x50024010> {
            using ENABLE = Field<0, 1>;    // ENABLE
            using SNGSTRT = Field<1, 1>;    // SNGSTRT
            using CNTSTRT = Field<2, 1>;    // CNTSTRT
            using COUNTRST = Field<3, 1>;    // COUNTRST
            using RSTARE = Field<4, 1>;    // RSTARE
        };

        // LPTIM compare register
        struct LPTIM_CMP : public Register<0x50024014> {
            using CMP = Field<0, 16>;    // CMP
        };

        // LPTIM autoreload register
        struct LPTIM_ARR : public Register<0x50024018> {
            using ARR = Field<0, 16>;    // ARR
        };

        // LPTIM counter register
        struct LPTIM_CNT : public RegisterReadOnly<0x5002401c> {
            using CNT = Field<0, 16>;    // CNT
        };

        // LPTIM configuration register 2
        struct LPTIM_CFGR2 : public Register<0x50024024> {
            using IN1SEL = Field<0, 2>;    // IN1SEL
            using IN2SEL = Field<4, 2>;    // IN2SEL
        };

        // LPTIM peripheral version identification register
        struct LPTIM_VERR : public RegisterReadOnly<0x500243f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // LPTIM peripheral type identification register
        struct LPTIM_PIDR : public RegisterReadOnly<0x500243f8> {
            using P_ID = Field<0, 32>;    // P_ID
        };

        // LPTIM registers map size identification register
        struct LPTIM_SIDR : public RegisterReadOnly<0x500243fc> {
            using S_ID = Field<0, 32>;    // S_ID
        };

    };

    // SYSCFG
    struct SYSCFG {
        // This register is used to know the state of BOOT pins and to control pull-up to reduce the static power consumption on the pin set to high level. )
        struct SYSCFG_BOOTR : public Register<0x50020000> {
            using BOOT0 = Field<0, 1>;    // BOOT0
            using BOOT1 = Field<1, 1>;    // BOOT1
            using BOOT2 = Field<2, 1>;    // BOOT2
            using BOOT0_PD = Field<4, 1>;    // BOOT0_PD
            using BOOT1_PD = Field<5, 1>;    // BOOT1_PD
            using BOOT2_PD = Field<6, 1>;    // BOOT2_PD
        };

        // SYSCFG peripheral mode configuration set register
        struct SYSCFG_PMCSETR : public Register<0x50020004> {
            using I2C1_FMP = Field<0, 1>;    // I2C1_FMP
            using I2C2_FMP = Field<1, 1>;    // I2C2_FMP
            using I2C3_FMP = Field<2, 1>;    // I2C3_FMP
            using I2C4_FMP = Field<3, 1>;    // I2C4_FMP
            using I2C5_FMP = Field<4, 1>;    // I2C5_FMP
            using I2C6_FMP = Field<5, 1>;    // I2C6_FMP
            using EN_BOOSTER = Field<8, 1>;    // EN_BOOSTER
            using ANASWVDD = Field<9, 1>;    // ANASWVDD
            using ETH_CLK_SEL = Field<16, 1>;    // ETH_CLK_SEL
            using ETH_REF_CLK_SEL = Field<17, 1>;    // ETH_REF_CLK_SEL
            using ETH_SELMII = Field<20, 1>;    // ETH_SELMII
            using ETH_SEL = Field<21, 3>;    // ETH_SEL
            using ANA0_SEL = Field<24, 1>;    // ANA0_SEL
            using ANA1_SEL = Field<25, 1>;    // ANA1_SEL
        };

        // SYSCFG IO control register
        struct SYSCFG_IOCTRLSETR : public Register<0x50020018> {
            using HSLVEN_TRACE = Field<0, 1>;    // HSLVEN_TRACE
            using HSLVEN_QUADSPI = Field<1, 1>;    // HSLVEN_QUADSPI
            using HSLVEN_ETH = Field<2, 1>;    // HSLVEN_ETH
            using HSLVEN_SDMMC = Field<3, 1>;    // HSLVEN_SDMMC
            using HSLVEN_SPI = Field<4, 1>;    // HSLVEN_SPI
        };

        // SYSCFG interconnect control register
        struct SYSCFG_ICNR : public Register<0x5002001c> {
            using AXI_M0 = Field<0, 1>;    // AXI_M0
            using AXI_M1 = Field<1, 1>;    // AXI_M1
            using AXI_M2 = Field<2, 1>;    // AXI_M2
            using AXI_M3 = Field<3, 1>;    // AXI_M3
            using AXI_M5 = Field<5, 1>;    // AXI_M5
            using AXI_M6 = Field<6, 1>;    // AXI_M6
            using AXI_M7 = Field<7, 1>;    // AXI_M7
            using AXI_M8 = Field<8, 1>;    // AXI_M8
            using AXI_M9 = Field<9, 1>;    // AXI_M9
            using AXI_M10 = Field<10, 1>;    // AXI_M10
        };

        // SYSCFG compensation cell control register
        struct SYSCFG_CMPCR : public Register<0x50020020> {
            using SW_CTRL = Field<1, 1>;    // SW_CTRL
            using READY = Field<8, 1>;    // READY
            using RANSRC = Field<16, 4>;    // RANSRC
            using RAPSRC = Field<20, 4>;    // RAPSRC
            using ANSRC = Field<24, 4>;    // ANSRC
            using APSRC = Field<28, 4>;    // APSRC
        };

        // SYSCFG compensation cell enable set register
        struct SYSCFG_CMPENSETR : public Register<0x50020024> {
            using MPU_EN = Field<0, 1>;    // MPU_EN
            using MCU_EN = Field<1, 1>;    // MCU_EN
        };

        // SYSCFG compensation cell enable set register
        struct SYSCFG_CMPENCLRR : public Register<0x50020028> {
            using MPU_EN = Field<0, 1>;    // MPU_EN
            using MCU_EN = Field<1, 1>;    // MCU_EN
        };

        // SYSCFG control timer break register
        struct SYSCFG_CBR : public Register<0x5002002c> {
            using CLL = Field<0, 1>;    // CLL
            using PVDL = Field<2, 1>;    // PVDL
        };

        // SYSCFG peripheral mode configuration clear register
        struct SYSCFG_PMCCLRR : public Register<0x50020044> {
            using I2C1_FMP = Field<0, 1>;    // I2C1_FMP
            using I2C2_FMP = Field<1, 1>;    // I2C2_FMP
            using I2C3_FMP = Field<2, 1>;    // I2C3_FMP
            using I2C4_FMP = Field<3, 1>;    // I2C4_FMP
            using I2C5_FMP = Field<4, 1>;    // I2C5_FMP
            using I2C6_FMP = Field<5, 1>;    // I2C6_FMP
            using EN_BOOSTER = Field<8, 1>;    // EN_BOOSTER
            using ANASWVDD = Field<9, 1>;    // ANASWVDD
            using ETH_CLK_SEL = Field<16, 1>;    // ETH_CLK_SEL
            using ETH_REF_CLK_SEL = Field<17, 1>;    // ETH_REF_CLK_SEL
            using ETH_SELMII = Field<20, 1>;    // ETH_SELMII
            using ETH_SEL = Field<21, 3>;    // ETH_SEL
            using ANA0_SEL = Field<24, 1>;    // ANA0_SEL
            using ANA1_SEL = Field<25, 1>;    // ANA1_SEL
        };

        // SYSCFG IO control register
        struct SYSCFG_IOCTRLCLRR : public Register<0x50020058> {
            using HSLVEN_TRACE = Field<0, 1>;    // HSLVEN_TRACE
            using HSLVEN_QUADSPI = Field<1, 1>;    // HSLVEN_QUADSPI
            using HSLVEN_ETH = Field<2, 1>;    // HSLVEN_ETH
            using HSLVEN_SDMMC = Field<3, 1>;    // HSLVEN_SDMMC
            using HSLVEN_SPI = Field<4, 1>;    // HSLVEN_SPI
        };

        // SYSCFG version register
        struct SYSCFG_VERR : public RegisterReadOnly<0x500203f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // SYSCFG identification register
        struct SYSCFG_IPIDR : public RegisterReadOnly<0x500203f8> {
            using ID = Field<0, 32>;    // ID
        };

        // SYSCFG size identification register
        struct SYSCFG_SIDR : public RegisterReadOnly<0x500203fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // LPTIM3
    struct LPTIM3 {
        // LPTIM3 configuration register 2
        struct LPTIM3_CFGR2 : public Register<0x50022024> {
            using IN1SEL = Field<0, 2>;    // IN1SEL
        };

        // LPTIM interrupt and status register
        struct LPTIM_ISR : public RegisterReadOnly<0x50022000> {
            using CMPM = Field<0, 1>;    // CMPM
            using ARRM = Field<1, 1>;    // ARRM
            using EXTTRIG = Field<2, 1>;    // EXTTRIG
            using CMPOK = Field<3, 1>;    // CMPOK
            using ARROK = Field<4, 1>;    // ARROK
            using UP = Field<5, 1>;    // UP
            using DOWN = Field<6, 1>;    // DOWN
        };

        // LPTIM interrupt clear register
        struct LPTIM_ICR : public RegisterWriteOnly<0x50022004> {
            using CMPMCF = Field<0, 1>;    // CMPMCF
            using ARRMCF = Field<1, 1>;    // ARRMCF
            using EXTTRIGCF = Field<2, 1>;    // EXTTRIGCF
            using CMPOKCF = Field<3, 1>;    // CMPOKCF
            using ARROKCF = Field<4, 1>;    // ARROKCF
            using UPCF = Field<5, 1>;    // UPCF
            using DOWNCF = Field<6, 1>;    // DOWNCF
        };

        // LPTIM interrupt enable register
        struct LPTIM_IER : public Register<0x50022008> {
            using CMPMIE = Field<0, 1>;    // CMPMIE
            using ARRMIE = Field<1, 1>;    // ARRMIE
            using EXTTRIGIE = Field<2, 1>;    // EXTTRIGIE
            using CMPOKIE = Field<3, 1>;    // CMPOKIE
            using ARROKIE = Field<4, 1>;    // ARROKIE
            using UPIE = Field<5, 1>;    // UPIE
            using DOWNIE = Field<6, 1>;    // DOWNIE
        };

        // LPTIM configuration register
        struct LPTIM_CFGR : public Register<0x5002200c> {
            using CKSEL = Field<0, 1>;    // CKSEL
            using CKPOL = Field<1, 2>;    // CKPOL
            using CKFLT = Field<3, 2>;    // CKFLT
            using TRGFLT = Field<6, 2>;    // TRGFLT
            using PRESC = Field<9, 3>;    // PRESC
            using TRIGSEL = Field<13, 3>;    // TRIGSEL
            using TRIGEN = Field<17, 2>;    // TRIGEN
            using TIMOUT = Field<19, 1>;    // TIMOUT
            using WAVE = Field<20, 1>;    // WAVE
            using WAVPOL = Field<21, 1>;    // WAVPOL
            using PRELOAD = Field<22, 1>;    // PRELOAD
            using COUNTMODE = Field<23, 1>;    // COUNTMODE
            using ENC = Field<24, 1>;    // ENC
        };

        // LPTIM control register
        struct LPTIM_CR : public Register<0x50022010> {
            using ENABLE = Field<0, 1>;    // ENABLE
            using SNGSTRT = Field<1, 1>;    // SNGSTRT
            using CNTSTRT = Field<2, 1>;    // CNTSTRT
            using COUNTRST = Field<3, 1>;    // COUNTRST
            using RSTARE = Field<4, 1>;    // RSTARE
        };

        // LPTIM compare register
        struct LPTIM_CMP : public Register<0x50022014> {
            using CMP = Field<0, 16>;    // CMP
        };

        // LPTIM autoreload register
        struct LPTIM_ARR : public Register<0x50022018> {
            using ARR = Field<0, 16>;    // ARR
        };

        // LPTIM counter register
        struct LPTIM_CNT : public RegisterReadOnly<0x5002201c> {
            using CNT = Field<0, 16>;    // CNT
        };

        // LPTIM peripheral version identification register
        struct LPTIM_VERR : public RegisterReadOnly<0x500223f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // LPTIM peripheral type identification register
        struct LPTIM_PIDR : public RegisterReadOnly<0x500223f8> {
            using P_ID = Field<0, 32>;    // P_ID
        };

        // LPTIM registers map size identification register
        struct LPTIM_SIDR : public RegisterReadOnly<0x500223fc> {
            using S_ID = Field<0, 32>;    // S_ID
        };

        // LPTIM 3 peripheral hardware configuration register
        struct LPTIM3_HWCFGR : public RegisterReadOnly<0x500223f0> {
            using CFG1 = Field<0, 8>;    // CFG1
            using CFG2 = Field<8, 8>;    // CFG2
            using CFG3 = Field<16, 4>;    // CFG3
            using CFG4 = Field<24, 8>;    // CFG4
        };

    };

    // PWR
    struct PWR {
        // Reset on any system reset. This register provides write access security when enabled by TZEN register bit in Section10: Reset and clock control (RCC). When security is enabled a non-secure write access generates a bus error. Secure and non-secure read accesses are granted and return the register value.
        struct PWR_CR1 : public Register<0x50001000> {
            using LPDS = Field<0, 1>;    // LPDS
            using LPCFG = Field<1, 1>;    // LPCFG
            using LVDS = Field<2, 1>;    // LVDS
            using PVDEN = Field<4, 1>;    // PVDEN
            using PLS = Field<5, 3>;    // PLS
            using DBP = Field<8, 1>;    // DBP
            using AVDEN = Field<16, 1>;    // AVDEN
            using ALS = Field<17, 2>;    // ALS
        };

        // Reset on any system reset.
        struct PWR_CSR1 : public RegisterReadOnly<0x50001004> {
            using PVDO = Field<4, 1>;    // PVDO
            using AVDO = Field<16, 1>;    // AVDO
        };

        // Not reset by wakeup from Standby mode, Application reset (NRST, IWDG, ...) and VDD POR, but reset only by VSW POR and VSWRST. Access 6 wait states when writing this register. After reset the register is write-protected and the DBP bit in the PWR control register 1 (PWR_CR1) has to be set before it can be written. When DBP is cleared, there is no bus errors generated when writing this register. This register shall not be accessed when the RCC VSWRST register bit in Section10.7.89: RCC Backup Domain Control Register (RCC_BDCR) resets the VSW domain. This register provides Write access security when enabled by TZEN register bit in Section10.7.2: RCC TrustZone Control Register (RCC_TZCR). When security is enabled a non-secure write access generates a bus error. Secure and non-secure read accesses are granted and return the register value. When a system reset occurs during the register write cycle the written data is not guaranteed.
        struct PWR_CR2 : public Register<0x50001008> {
            using BREN = Field<0, 1>;    // BREN
            using RREN = Field<1, 1>;    // RREN
            using MONEN = Field<4, 1>;    // MONEN
            using BRRDY = Field<16, 1>;    // BRRDY
            using RRRDY = Field<17, 1>;    // RRRDY
            using VBATL = Field<20, 1>;    // VBATL
            using VBATH = Field<21, 1>;    // VBATH
            using TEMPL = Field<22, 1>;    // TEMPL
            using TEMPH = Field<23, 1>;    // TEMPH
        };

        // Not reset by wakeup from Standby mode and Application reset (such as NRST, IWDG) but only reset by VDD POR. Access 6 wait states when writing this register. This register provides Write access security when enabled by TZEN register bit in Section10: Reset and clock control (RCC). When security is enabled a non-secure write access generates a bus error. Secure and non-secure read accesses are granted and return the register value. When a system reset occurs during the register write cycle the written data is not guaranteed.
        struct PWR_CR3 : public Register<0x5000100c> {
            using VBE = Field<8, 1>;    // VBE
            using VBRS = Field<9, 1>;    // VBRS
            using DDRSREN = Field<10, 1>;    // DDRSREN
            using DDRSRDIS = Field<11, 1>;    // DDRSRDIS
            using DDRRETEN = Field<12, 1>;    // DDRRETEN
            using POPL = Field<17, 5>;    // POPL
            using USB33DEN = Field<24, 1>;    // USB33DEN
            using USB33RDY = Field<26, 1>;    // USB33RDY
            using REG18EN = Field<28, 1>;    // REG18EN
            using REG18RDY = Field<29, 1>;    // REG18RDY
            using REG11EN = Field<30, 1>;    // REG11EN
            using REG11RDY = Field<31, 1>;    // REG11RDY
        };

        // See individual bits for reset condition. Access 6 wait states when writing this register. This register provides Write access security when enabled by TZEN register bit in Section10: Reset and clock control (RCC). When security is enabled a non-secure write access generates a bus error. Secure and non-secure read accesses are granted and return the register value. When a system reset occurs during the register write cycle the written data is not guaranteed.
        struct PWR_MPUCR : public Register<0x50001010> {
            using PDDS = Field<0, 1>;    // PDDS
            using CSTBYDIS = Field<3, 1>;    // CSTBYDIS
            using STOPF = Field<5, 1>;    // STOPF
            using SBF = Field<6, 1>;    // SBF
            using SBFMPU = Field<7, 1>;    // SBFMPU
            using CSSF = Field<9, 1>;    // CSSF
            using STANDBYWFIL2 = Field<15, 1>;    // STANDBYWFIL2
        };

        // See individual bits for reset condition. Access 6 wait states when writing this register. This register is always non-secure. When a system reset occurs during the register write cycle the written data is not guaranteed.
        struct PWR_MCUCR : public Register<0x50001014> {
            using PDDS = Field<0, 1>;    // PDDS
            using STOPF = Field<5, 1>;    // STOPF
            using SBF = Field<6, 1>;    // SBF
            using CSSF = Field<9, 1>;    // CSSF
            using DEEPSLEEP = Field<15, 1>;    // DEEPSLEEP
        };

        // Not reset by wakeup from Standby mode, but by any application reset (such as NRST, IWDG). Access 6 wait states when writing this register (when clearing a WKUPF, the AHB write access completes after the WKUPF has cleared). This register provides Write access security when enabled by TZEN register bit in Section10: Reset and clock control (RCC). When security is enabled a non-secure write access on individual WKUPC[6:1], WKUPP[6:1] bits and WKUPPUPD[6:1] bit pairs are discarded when the corresponding WKUPEN[6:1] bit in PWR MPU wakeup enable register (PWR_MPUWKUPENR) is set. No bus error is generated. Secure and non-secure read accesses are granted and return the register value. When a system reset occurs during the register write cycle the written data is not guaranteed.
        struct PWR_WKUPCR : public Register<0x50001020> {
            using WKUPC1 = Field<0, 1>;    // WKUPC1
            using WKUPC2 = Field<1, 1>;    // WKUPC2
            using WKUPC3 = Field<2, 1>;    // WKUPC3
            using WKUPC4 = Field<3, 1>;    // WKUPC4
            using WKUPC5 = Field<4, 1>;    // WKUPC5
            using WKUPC6 = Field<5, 1>;    // WKUPC6
            using WKUPP1 = Field<8, 1>;    // WKUPP1
            using WKUPP2 = Field<9, 1>;    // WKUPP2
            using WKUPP3 = Field<10, 1>;    // WKUPP3
            using WKUPP4 = Field<11, 1>;    // WKUPP4
            using WKUPP5 = Field<12, 1>;    // WKUPP5
            using WKUPP6 = Field<13, 1>;    // WKUPP6
            using WKUPPUPD1 = Field<16, 2>;    // WKUPPUPD1
            using WKUPPUPD2 = Field<18, 2>;    // WKUPPUPD2
            using WKUPPUPD3 = Field<20, 2>;    // WKUPPUPD3
            using WKUPPUPD4 = Field<22, 2>;    // WKUPPUPD4
            using WKUPPUPD5 = Field<24, 2>;    // WKUPPUPD5
            using WKUPPUPD6 = Field<26, 2>;    // WKUPPUPD6
        };

        // Not reset by wakeup from Standby mode but by any Application reset (NRST, IWDG, ...)
        struct PWR_WKUPFR : public RegisterReadOnly<0x50001024> {
            using WKUPF1 = Field<0, 1>;    // WKUPF1
            using WKUPF2 = Field<1, 1>;    // WKUPF2
            using WKUPF3 = Field<2, 1>;    // WKUPF3
            using WKUPF4 = Field<3, 1>;    // WKUPF4
            using WKUPF5 = Field<4, 1>;    // WKUPF5
            using WKUPF6 = Field<5, 1>;    // WKUPF6
        };

        // Not reset by wakeup from Standby mode but by any Application reset (NRST, IWDG, ...). Access 6 wait states when writing this register. This register provides Write access security when enabled by TZEN register bit in Section10: Reset and clock control (RCC). When security is enabled a non-secure write access is discarded and a bus error is generated. Secure and non-secure read accesses are granted and return the register value. When a system reset occurs during the register write cycle the written data is not guaranteed.
        struct PWR_MPUWKUPENR : public Register<0x50001028> {
            using WKUPEN1 = Field<0, 1>;    // WKUPEN1
            using WKUPEN2 = Field<1, 1>;    // WKUPEN2
            using WKUPEN3 = Field<2, 1>;    // WKUPEN3
            using WKUPEN4 = Field<3, 1>;    // WKUPEN4
            using WKUPEN5 = Field<4, 1>;    // WKUPEN5
            using WKUPEN6 = Field<5, 1>;    // WKUPEN6
        };

        // Not reset by wakeup from Standby mode but by any Application reset (NRST, IWDG, ...) Access 6 wait states when writing this register. When a system reset occurs during the register write cycle the written data is not guaranteed.
        struct PWR_MCUWKUPENR : public Register<0x5000102c> {
            using WKUPEN1 = Field<0, 1>;    // WKUPEN1
            using WKUPEN2 = Field<1, 1>;    // WKUPEN2
            using WKUPEN3 = Field<2, 1>;    // WKUPEN3
            using WKUPEN4 = Field<3, 1>;    // WKUPEN4
            using WKUPEN5 = Field<4, 1>;    // WKUPEN5
            using WKUPEN6 = Field<5, 1>;    // WKUPEN6
        };

        // PWR IP version register
        struct PWR_VER : public RegisterReadOnly<0x500013f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // PWR IP identification register
        struct PWR_ID : public RegisterReadOnly<0x500013f8> {
            using IPID = Field<0, 32>;    // IPID
        };

        // PWR size ID register
        struct PWR_SID : public RegisterReadOnly<0x500013fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // RCC
    struct RCC {
        // This register is used to switch the RCC into secure mode. This register can only be accessed in secure mode.
        struct RCC_TZCR : public Register<0x50000000> {
            using TZEN = Field<0, 1>;    // TZEN
            using MCKPROT = Field<1, 1>;    // MCKPROT
        };

        // This register is used to control the oscillators.Writing to this register has no effect, writing will set the corresponding bits. Reading will give the effective values of each bit.If TZEN = MCKPROT = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
        struct RCC_OCENSETR : public Register<0x5000000c> {
            using HSION = Field<0, 1>;    // HSION
            using HSIKERON = Field<1, 1>;    // HSIKERON
            using CSION = Field<4, 1>;    // CSION
            using CSIKERON = Field<5, 1>;    // CSIKERON
            using DIGBYP = Field<7, 1>;    // DIGBYP
            using HSEON = Field<8, 1>;    // HSEON
            using HSEKERON = Field<9, 1>;    // HSEKERON
            using HSEBYP = Field<10, 1>;    // HSEBYP
            using HSECSSON = Field<11, 1>;    // HSECSSON
        };

        // This register is used to control the oscillators.Writing to this register has no effect, writing will clear the corresponding bits. Reading will give the effective values of the enable bits.If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
        struct RCC_OCENCLRR : public Register<0x50000010> {
            using HSION = Field<0, 1>;    // HSION
            using HSIKERON = Field<1, 1>;    // HSIKERON
            using CSION = Field<4, 1>;    // CSION
            using CSIKERON = Field<5, 1>;    // CSIKERON
            using DIGBYP = Field<7, 1>;    // DIGBYP
            using HSEON = Field<8, 1>;    // HSEON
            using HSEKERON = Field<9, 1>;    // HSEKERON
            using HSEBYP = Field<10, 1>;    // HSEBYP
        };

        // This register is used to configure the HSI. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
        struct RCC_HSICFGR : public Register<0x50000018> {
            using HSIDIV = Field<0, 2>;    // HSIDIV
            using HSITRIM = Field<8, 7>;    // HSITRIM
            using HSICAL = Field<16, 12>;    // HSICAL
        };

        // This register is used to fine-tune the CSI frequency. If TZEN = MCKPROT = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See The clock restore sequence description for details.
        struct RCC_CSICFGR : public Register<0x5000001c> {
            using CSITRIM = Field<8, 5>;    // CSITRIM
            using CSICAL = Field<16, 8>;    // CSICAL
        };

        // This register is used to select the clock source for the MPU. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
        struct RCC_MPCKSELR : public Register<0x50000020> {
            using MPUSRC = Field<0, 2>;    // MPUSRC
            using MPUSRCRDY = Field<31, 1>;    // MPUSRCRDY
        };

        // This register is used to select the clock source for the AXI sub-system. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
        struct RCC_ASSCKSELR : public Register<0x50000024> {
            using AXISSRC = Field<0, 3>;    // AXISSRC
            using AXISSRCRDY = Field<31, 1>;    // AXISSRCRDY
        };

        // This register is used to select the reference clock for PLL1 and PLL2. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
        struct RCC_RCK12SELR : public Register<0x50000028> {
            using PLL12SRC = Field<0, 2>;    // PLL12SRC
            using PLL12SRCRDY = Field<31, 1>;    // PLL12SRCRDY
        };

        // This register is used to control the MPU clock prescaler. Refer to Section: Sub-system clock generation for additional information. If TZEN = , this register can only be modified in secure mode.
        struct RCC_MPCKDIVR : public Register<0x5000002c> {
            using MPUDIV = Field<0, 3>;    // MPUDIV
            using MPUDIVRDY = Field<31, 1>;    // MPUDIVRDY
        };

        // This register is used to control the AXI Matrix clock prescaler. Refer to Section: Sub-system clock generation for additional information. If TZEN = , this register can only be modified in secure mode.
        struct RCC_AXIDIVR : public Register<0x50000030> {
            using AXIDIV = Field<0, 3>;    // AXIDIV
            using AXIDIVRDY = Field<31, 1>;    // AXIDIVRDY
        };

        // This register is used to control the APB4 clock divider. Refer to Section: Sub-system clock generation for additional information. If TZEN = , this register can only be modified in secure mode.
        struct RCC_APB4DIVR : public Register<0x5000003c> {
            using APB4DIV = Field<0, 3>;    // APB4DIV
            using APB4DIVRDY = Field<31, 1>;    // APB4DIVRDY
        };

        // This register is used to control the APB5 clock divider. Refer to Section: Sub-system clock generation for additional information. If TZEN = , this register can only be modified in secure mode.
        struct RCC_APB5DIVR : public Register<0x50000040> {
            using APB5DIV = Field<0, 3>;    // APB5DIV
            using APB5DIVRDY = Field<31, 1>;    // APB5DIVRDY
        };

        // This register is used to divide the HSE clock for RTC. If TZEN = , this register can only be modified in secure mode.
        struct RCC_RTCDIVR : public Register<0x50000044> {
            using RTCDIV = Field<0, 6>;    // RTCDIV
        };

        // This register is used to select the clock source for the MCU sub-system, including the MCU itself. If TZEN = MCKPROT = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
        struct RCC_MSSCKSELR : public Register<0x50000048> {
            using MCUSSRC = Field<0, 2>;    // MCUSSRC
            using MCUSSRCRDY = Field<31, 1>;    // MCUSSRCRDY
        };

        // This register is used to control the PLL1. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
        struct RCC_PLL1CR : public Register<0x50000080> {
            using PLLON = Field<0, 1>;    // PLLON
            using PLL1RDY = Field<1, 1>;    // PLL1RDY
            using SSCG_CTRL = Field<2, 1>;    // SSCG_CTRL
            using DIVPEN = Field<4, 1>;    // DIVPEN
            using DIVQEN = Field<5, 1>;    // DIVQEN
            using DIVREN = Field<6, 1>;    // DIVREN
        };

        // This register is used to configure the PLL1. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
        struct RCC_PLL1CFGR1 : public Register<0x50000084> {
            using DIVN = Field<0, 9>;    // DIVN
            using DIVM1 = Field<16, 6>;    // DIVM1
        };

        // This register is used to configure the PLL1. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
        struct RCC_PLL1CFGR2 : public Register<0x50000088> {
            using DIVP = Field<0, 7>;    // DIVP
            using DIVQ = Field<8, 7>;    // DIVQ
            using DIVR = Field<16, 7>;    // DIVR
        };

        // This register is used to fine-tune the frequency of the PLL1 VCO. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
        struct RCC_PLL1FRACR : public Register<0x5000008c> {
            using FRACV = Field<3, 13>;    // FRACV
            using FRACLE = Field<16, 1>;    // FRACLE
        };

        // This register is used to configure the PLL1.It is not recommended to change the content of this register when the PLL1 is enabled (PLLON = ). Refer to Section: Using the PLLs in spread spectrum mode for details. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
        struct RCC_PLL1CSGR : public Register<0x50000090> {
            using MOD_PER = Field<0, 13>;    // MOD_PER
            using TPDFN_DIS = Field<13, 1>;    // TPDFN_DIS
            using RPDFN_DIS = Field<14, 1>;    // RPDFN_DIS
            using SSCG_MODE = Field<15, 1>;    // SSCG_MODE
            using INC_STEP = Field<16, 15>;    // INC_STEP
        };

        // This register is used to control the PLL2. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
        struct RCC_PLL2CR : public Register<0x50000094> {
            using PLLON = Field<0, 1>;    // PLLON
            using PLL2RDY = Field<1, 1>;    // PLL2RDY
            using SSCG_CTRL = Field<2, 1>;    // SSCG_CTRL
            using DIVPEN = Field<4, 1>;    // DIVPEN
            using DIVQEN = Field<5, 1>;    // DIVQEN
            using DIVREN = Field<6, 1>;    // DIVREN
        };

        // This register is used to configure the PLL2. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
        struct RCC_PLL2CFGR1 : public Register<0x50000098> {
            using DIVN = Field<0, 9>;    // DIVN
            using DIVM2 = Field<16, 6>;    // DIVM2
        };

        // This register is used to configure the PLL2. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
        struct RCC_PLL2CFGR2 : public Register<0x5000009c> {
            using DIVP = Field<0, 7>;    // DIVP
            using DIVQ = Field<8, 7>;    // DIVQ
            using DIVR = Field<16, 7>;    // DIVR
        };

        // This register is used to fine-tune the frequency of the PLL2 VCO. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
        struct RCC_PLL2FRACR : public Register<0x500000a0> {
            using FRACV = Field<3, 13>;    // FRACV
            using FRACLE = Field<16, 1>;    // FRACLE
        };

        // This register is used to configure the PLL2. It is not recommended to change the content of this register when the PLL2 is enabled (PLLON = ). Refer to Section: Using the PLLs in spread spectrum mode for details. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
        struct RCC_PLL2CSGR : public Register<0x500000a4> {
            using MOD_PER = Field<0, 13>;    // MOD_PER
            using TPDFN_DIS = Field<13, 1>;    // TPDFN_DIS
            using RPDFN_DIS = Field<14, 1>;    // RPDFN_DIS
            using SSCG_MODE = Field<15, 1>;    // SSCG_MODE
            using INC_STEP = Field<16, 15>;    // INC_STEP
        };

        // This register is used to control the selection of the kernel clock for the I2C4 and I2C6. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays. If TZEN = , this register can only be modified in secure mode.
        struct RCC_I2C46CKSELR : public Register<0x500000c0> {
            using I2C46SRC = Field<0, 3>;    // I2C46SRC
        };

        // This register is used to control the selection of the kernel clock for the SPI6. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays. If TZEN = , this register can only be modified in secure mode.
        struct RCC_SPI6CKSELR : public Register<0x500000c4> {
            using SPI6SRC = Field<0, 3>;    // SPI6SRC
        };

        // This register is used to control the selection of the kernel clock for the USART1. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays. If TZEN = , this register can only be modified in secure mode.
        struct RCC_UART1CKSELR : public Register<0x500000c8> {
            using UART1SRC = Field<0, 3>;    // UART1SRC
        };

        // This register is used to control the selection of the kernel clock for the RNG1. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays. If TZEN = , this register can only be modified in secure mode.
        struct RCC_RNG1CKSELR : public Register<0x500000cc> {
            using RNG1SRC = Field<0, 2>;    // RNG1SRC
        };

        // This register is used to select an oscillator source as kernel clock for the per_ck clock. The per_ck clock is distributed to several peripherals. Refer to Section: Clock enabling delays.
        struct RCC_CPERCKSELR : public Register<0x500000d0> {
            using CKPERSRC = Field<0, 2>;    // CKPERSRC
        };

        // This register is used to select the peripheral clock for the STGEN block. Note that this clock is used to provide a time reference for the application. Refer to Section: Clock enabling delays. If TZEN = , this register can only be modified in secure mode.
        struct RCC_STGENCKSELR : public Register<0x500000d4> {
            using STGENSRC = Field<0, 2>;    // STGENSRC
        };

        // This register is used to control the DDR interface, including the DDRC and DDRPHYC. If TZEN = , this register can only be modified in secure mode.
        struct RCC_DDRITFCR : public Register<0x500000d8> {
            using DDRC1EN = Field<0, 1>;    // DDRC1EN
            using DDRC1LPEN = Field<1, 1>;    // DDRC1LPEN
            using DDRC2EN = Field<2, 1>;    // DDRC2EN
            using DDRC2LPEN = Field<3, 1>;    // DDRC2LPEN
            using DDRPHYCEN = Field<4, 1>;    // DDRPHYCEN
            using DDRPHYCLPEN = Field<5, 1>;    // DDRPHYCLPEN
            using DDRCAPBEN = Field<6, 1>;    // DDRCAPBEN
            using DDRCAPBLPEN = Field<7, 1>;    // DDRCAPBLPEN
            using AXIDCGEN = Field<8, 1>;    // AXIDCGEN
            using DDRPHYCAPBEN = Field<9, 1>;    // DDRPHYCAPBEN
            using DDRPHYCAPBLPEN = Field<10, 1>;    // DDRPHYCAPBLPEN
            using KERDCG_DLY = Field<11, 3>;    // KERDCG_DLY
            using DDRCAPBRST = Field<14, 1>;    // DDRCAPBRST
            using DDRCAXIRST = Field<15, 1>;    // DDRCAXIRST
            using DDRCORERST = Field<16, 1>;    // DDRCORERST
            using DPHYAPBRST = Field<17, 1>;    // DPHYAPBRST
            using DPHYRST = Field<18, 1>;    // DPHYRST
            using DPHYCTLRST = Field<19, 1>;    // DPHYCTLRST
            using DDRCKMOD = Field<20, 3>;    // DDRCKMOD
            using GSKPMOD = Field<23, 1>;    // GSKPMOD
            using GSKPCTRL = Field<24, 1>;    // GSKPCTRL
            using DFILP_WIDTH = Field<25, 3>;    // DFILP_WIDTH
            using GSKP_DUR = Field<28, 4>;    // GSKP_DUR
        };

        // This register is used to control the HOLD boot function when the system exits from Standby. Refer to Section: MCU HOLD_BOOT after processor reset. This register is reset when a system reset occurs, but not when the circuit exits from Standby (app_rst reset).If TZEN = , this register can only be modified in secure mode. This register can only be accessed by the MPU.
        struct RCC_MP_BOOTCR : public Register<0x50000100> {
            using MCU_BEN = Field<0, 1>;    // MCU_BEN
            using MPU_BEN = Field<1, 1>;    // MPU_BEN
        };

        // Writing has no effect, reading will return the values of the bits. Writing a sets the corresponding bit to . The MCU cannot access to this register. If TZEN = , this register can only be modified in secure mode.
        struct RCC_MP_SREQSETR : public Register<0x50000104> {
            using STPREQ_P0 = Field<0, 1>;    // STPREQ_P0
            using STPREQ_P1 = Field<1, 1>;    // STPREQ_P1
        };

        // Writing has no effect, reading will return the effective values of the bits. Writing a sets the corresponding bit to . The MCU cannot access to this register. If TZEN = , this register can only be modified in secure mode.
        struct RCC_MP_SREQCLRR : public Register<0x50000108> {
            using STPREQ_P0 = Field<0, 1>;    // STPREQ_P0
            using STPREQ_P1 = Field<1, 1>;    // STPREQ_P1
        };

        // The register contains global control bits. If TZEN = , this register can only be modified in secure mode.
        struct RCC_MP_GCR : public Register<0x5000010c> {
            using BOOT_MCU = Field<0, 1>;    // BOOT_MCU
        };

        // This register is used to control the behavior of the warm reset. If TZEN = , this register can only be modified in secure mode.
        struct RCC_MP_APRSTCR : public Register<0x50000110> {
            using RDCTLEN = Field<0, 1>;    // RDCTLEN
            using RSTTO = Field<8, 7>;    // RSTTO
        };

        // This register provides a status of the RDCTL. If TZEN = , this register can only be modified in secure mode.
        struct RCC_MP_APRSTSR : public RegisterReadOnly<0x50000114> {
            using RSTTOV = Field<8, 7>;    // RSTTOV
        };

        // This register is used to control the LSE function. Wait states are inserted in case of successive write accesses to this register. The number of wait states may be up to 7 cycles of AHB4 clock.After a system reset, the register RCC_BDCR is write-protected. In order to modify this register, the DBP bit in the PWR control register 1 (PWR_CR1) has to be set to . Bits of RCC_BDCR register are only reset after a backup domain reset: nreset_vsw (see Section10.3.6: Backup domain reset). Any other internal or external reset will not have any effect on these bits.This register is located into the VSW domain. If TZEN = , this register can only be modified in secure mode.
        struct RCC_BDCR : public Register<0x50000140> {
            using LSEON = Field<0, 1>;    // LSEON
            using LSEBYP = Field<1, 1>;    // LSEBYP
            using LSERDY = Field<2, 1>;    // LSERDY
            using DIGBYP = Field<3, 1>;    // DIGBYP
            using LSEDRV = Field<4, 2>;    // LSEDRV
            using LSECSSON = Field<8, 1>;    // LSECSSON
            using LSECSSD = Field<9, 1>;    // LSECSSD
            using RTCSRC = Field<16, 2>;    // RTCSRC
            using RTCCKEN = Field<20, 1>;    // RTCCKEN
            using VSWRST = Field<31, 1>;    // VSWRST
        };

        // This register is used to control the minimum NRST active duration and LSI function.0 to 7 wait states are inserted for word, half-word and byte accesses. Wait states are inserted in case of successive accesses to this register.This register is reset by the por_rst reset, and it is located into the VDD domain. If TZEN = , this register can only be modified in secure mode.
        struct RCC_RDLSICR : public Register<0x50000144> {
            using LSION = Field<0, 1>;    // LSION
            using LSIRDY = Field<1, 1>;    // LSIRDY
            using MRD = Field<16, 5>;    // MRD
            using EADLY = Field<24, 3>;    // EADLY
            using SPARE = Field<27, 5>;    // SPARE
        };

        // This register is used to activate the reset of the corresponding peripheral. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a activates the reset of the corresponding peripheral.
        struct RCC_APB4RSTSETR : public Register<0x50000180> {
            using LTDCRST = Field<0, 1>;    // LTDCRST
            using DSIRST = Field<4, 1>;    // DSIRST
            using DDRPERFMRST = Field<8, 1>;    // DDRPERFMRST
            using USBPHYRST = Field<16, 1>;    // USBPHYRST
        };

        // This register is used to release the reset of the corresponding peripheral. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a releases the reset of the corresponding peripheral.
        struct RCC_APB4RSTCLRR : public Register<0x50000184> {
            using LTDCRST = Field<0, 1>;    // LTDCRST
            using DSIRST = Field<4, 1>;    // DSIRST
            using DDRPERFMRST = Field<8, 1>;    // DDRPERFMRST
            using USBPHYRST = Field<16, 1>;    // USBPHYRST
        };

        // This register is used to activate the reset of the corresponding peripheral. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a activates the reset of the corresponding peripheral. If TZEN = , this register can only be modified in secure mode.
        struct RCC_APB5RSTSETR : public Register<0x50000188> {
            using SPI6RST = Field<0, 1>;    // SPI6RST
            using I2C4RST = Field<2, 1>;    // I2C4RST
            using I2C6RST = Field<3, 1>;    // I2C6RST
            using USART1RST = Field<4, 1>;    // USART1RST
            using STGENRST = Field<20, 1>;    // STGENRST
        };

        // This register is used to release the reset of the corresponding peripheral. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a releases the reset of the corresponding peripheral. If TZEN = , this register can only be modified in secure mode.
        struct RCC_APB5RSTCLRR : public Register<0x5000018c> {
            using SPI6RST = Field<0, 1>;    // SPI6RST
            using I2C4RST = Field<2, 1>;    // I2C4RST
            using I2C6RST = Field<3, 1>;    // I2C6RST
            using USART1RST = Field<4, 1>;    // USART1RST
            using STGENRST = Field<20, 1>;    // STGENRST
        };

        // This register is used to activate the reset of the corresponding peripheral. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a activates the reset of the corresponding peripheral. If TZEN = , this register can only be modified in secure mode.
        struct RCC_AHB5RSTSETR : public Register<0x50000190> {
            using GPIOZRST = Field<0, 1>;    // GPIOZRST
            using CRYP1RST = Field<4, 1>;    // CRYP1RST
            using HASH1RST = Field<5, 1>;    // HASH1RST
            using RNG1RST = Field<6, 1>;    // RNG1RST
            using AXIMCRST = Field<16, 1>;    // AXIMCRST
        };

        // This register is used to release the reset of the corresponding peripheral. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a releases the reset of the corresponding peripheral. If TZEN = , this register can only be modified in secure mode.
        struct RCC_AHB5RSTCLRR : public Register<0x50000194> {
            using GPIOZRST = Field<0, 1>;    // GPIOZRST
            using CRYP1RST = Field<4, 1>;    // CRYP1RST
            using HASH1RST = Field<5, 1>;    // HASH1RST
            using RNG1RST = Field<6, 1>;    // RNG1RST
            using AXIMCRST = Field<16, 1>;    // AXIMCRST
        };

        // This register is used to activate the reset of the corresponding peripheral. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a activates the reset of the corresponding peripheral.
        struct RCC_AHB6RSTSETR : public Register<0x50000198> {
            using GPURST = Field<5, 1>;    // GPURST
            using ETHMACRST = Field<10, 1>;    // ETHMACRST
            using FMCRST = Field<12, 1>;    // FMCRST
            using QSPIRST = Field<14, 1>;    // QSPIRST
            using SDMMC1RST = Field<16, 1>;    // SDMMC1RST
            using SDMMC2RST = Field<17, 1>;    // SDMMC2RST
            using CRC1RST = Field<20, 1>;    // CRC1RST
            using USBHRST = Field<24, 1>;    // USBHRST
        };

        // This register is used to release the reset of the corresponding peripheral. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a releases the reset of the corresponding peripheral.
        struct RCC_AHB6RSTCLRR : public Register<0x5000019c> {
            using ETHMACRST = Field<10, 1>;    // ETHMACRST
            using FMCRST = Field<12, 1>;    // FMCRST
            using QSPIRST = Field<14, 1>;    // QSPIRST
            using SDMMC1RST = Field<16, 1>;    // SDMMC1RST
            using SDMMC2RST = Field<17, 1>;    // SDMMC2RST
            using CRC1RST = Field<20, 1>;    // CRC1RST
            using USBHRST = Field<24, 1>;    // USBHRST
        };

        // This register is used to activate the reset of the corresponding peripheral. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a activates the reset of the corresponding peripheral. If TZEN = , this register can only be modified in secure mode.
        struct RCC_TZAHB6RSTSETR : public Register<0x500001a0> {
            using MDMARST = Field<0, 1>;    // MDMARST
        };

        // This register is used to release the reset of the corresponding peripheral. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a releases the reset of the corresponding peripheral. If TZEN = , this register can only be modified in secure mode.
        struct RCC_TZAHB6RSTCLRR : public Register<0x500001a4> {
            using MDMARST = Field<0, 1>;    // MDMARST
        };

        // This register is used to set the peripheral clock enable bit of the corresponding peripheral to . It shall be used to allocate a peripheral to the MPU. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to .
        struct RCC_MP_APB4ENSETR : public Register<0x50000200> {
            using LTDCEN = Field<0, 1>;    // LTDCEN
            using DSIEN = Field<4, 1>;    // DSIEN
            using DDRPERFMEN = Field<8, 1>;    // DDRPERFMEN
            using IWDG2APBEN = Field<15, 1>;    // IWDG2APBEN
            using USBPHYEN = Field<16, 1>;    // USBPHYEN
            using STGENROEN = Field<20, 1>;    // STGENROEN
        };

        // This register is used to clear the peripheral clock enable bit of the corresponding peripheral. It shall be used to deallocate a peripheral from MPU. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to .
        struct RCC_MP_APB4ENCLRR : public Register<0x50000204> {
            using LTDCEN = Field<0, 1>;    // LTDCEN
            using DSIEN = Field<4, 1>;    // DSIEN
            using DDRPERFMEN = Field<8, 1>;    // DDRPERFMEN
            using IWDG2APBEN = Field<15, 1>;    // IWDG2APBEN
            using USBPHYEN = Field<16, 1>;    // USBPHYEN
            using STGENROEN = Field<20, 1>;    // STGENROEN
        };

        // This register is used to set the peripheral clock enable bit of the corresponding peripheral to . It shall be used to allocate a peripheral to the MPU. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to .
        struct RCC_MP_APB5ENSETR : public Register<0x50000208> {
            using SPI6EN = Field<0, 1>;    // SPI6EN
            using I2C4EN = Field<2, 1>;    // I2C4EN
            using I2C6EN = Field<3, 1>;    // I2C6EN
            using USART1EN = Field<4, 1>;    // USART1EN
            using RTCAPBEN = Field<8, 1>;    // RTCAPBEN
            using TZC1EN = Field<11, 1>;    // TZC1EN
            using TZC2EN = Field<12, 1>;    // TZC2EN
            using TZPCEN = Field<13, 1>;    // TZPCEN
            using IWDG1APBEN = Field<15, 1>;    // IWDG1APBEN
            using BSECEN = Field<16, 1>;    // BSECEN
            using STGENEN = Field<20, 1>;    // STGENEN
        };

        // This register is used to clear the peripheral clock enable bit of the corresponding peripheral. It shall be used to deallocate a peripheral from MPU. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to .
        struct RCC_MP_APB5ENCLRR : public Register<0x5000020c> {
            using SPI6EN = Field<0, 1>;    // SPI6EN
            using I2C4EN = Field<2, 1>;    // I2C4EN
            using I2C6EN = Field<3, 1>;    // I2C6EN
            using USART1EN = Field<4, 1>;    // USART1EN
            using RTCAPBEN = Field<8, 1>;    // RTCAPBEN
            using TZC1EN = Field<11, 1>;    // TZC1EN
            using TZC2EN = Field<12, 1>;    // TZC2EN
            using TZPCEN = Field<13, 1>;    // TZPCEN
            using IWDG1APBEN = Field<15, 1>;    // IWDG1APBEN
            using BSECEN = Field<16, 1>;    // BSECEN
            using STGENEN = Field<20, 1>;    // STGENEN
        };

        // This register is used to set the peripheral clock enable bit of the corresponding peripheral to . It shall be used to allocate a peripheral to the MPU. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to . If TZEN = , this register can only be modified in secure mode.
        struct RCC_MP_AHB5ENSETR : public Register<0x50000210> {
            using GPIOZEN = Field<0, 1>;    // GPIOZEN
            using CRYP1EN = Field<4, 1>;    // CRYP1EN
            using HASH1EN = Field<5, 1>;    // HASH1EN
            using RNG1EN = Field<6, 1>;    // RNG1EN
            using BKPSRAMEN = Field<8, 1>;    // BKPSRAMEN
            using AXIMCEN = Field<16, 1>;    // AXIMCEN
        };

        // This register is used to clear the peripheral clock enable bit of the corresponding peripheral. It shall be used to deallocate a peripheral from MPU. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to . If TZEN = , this register can only be modified in secure mode.
        struct RCC_MP_AHB5ENCLRR : public Register<0x50000214> {
            using GPIOZEN = Field<0, 1>;    // GPIOZEN
            using CRYP1EN = Field<4, 1>;    // CRYP1EN
            using HASH1EN = Field<5, 1>;    // HASH1EN
            using RNG1EN = Field<6, 1>;    // RNG1EN
            using BKPSRAMEN = Field<8, 1>;    // BKPSRAMEN
            using AXIMCEN = Field<16, 1>;    // AXIMCEN
        };

        // This register is used to set the peripheral clock enable bit of the corresponding peripheral to . It shall be used to allocate a peripheral to the MPU. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to .
        struct RCC_MP_AHB6ENSETR : public Register<0x50000218> {
            using MDMAEN = Field<0, 1>;    // MDMAEN
            using GPUEN = Field<5, 1>;    // GPUEN
            using ETHCKEN = Field<7, 1>;    // ETHCKEN
            using ETHTXEN = Field<8, 1>;    // ETHTXEN
            using ETHRXEN = Field<9, 1>;    // ETHRXEN
            using ETHMACEN = Field<10, 1>;    // ETHMACEN
            using FMCEN = Field<12, 1>;    // FMCEN
            using QSPIEN = Field<14, 1>;    // QSPIEN
            using SDMMC1EN = Field<16, 1>;    // SDMMC1EN
            using SDMMC2EN = Field<17, 1>;    // SDMMC2EN
            using CRC1EN = Field<20, 1>;    // CRC1EN
            using USBHEN = Field<24, 1>;    // USBHEN
        };

        // This register is used to clear the peripheral clock enable bit of the corresponding peripheral. It shall be used to deallocate a peripheral from MPU. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to .
        struct RCC_MP_AHB6ENCLRR : public Register<0x5000021c> {
            using MDMAEN = Field<0, 1>;    // MDMAEN
            using GPUEN = Field<5, 1>;    // GPUEN
            using ETHCKEN = Field<7, 1>;    // ETHCKEN
            using ETHTXEN = Field<8, 1>;    // ETHTXEN
            using ETHRXEN = Field<9, 1>;    // ETHRXEN
            using ETHMACEN = Field<10, 1>;    // ETHMACEN
            using FMCEN = Field<12, 1>;    // FMCEN
            using QSPIEN = Field<14, 1>;    // QSPIEN
            using SDMMC1EN = Field<16, 1>;    // SDMMC1EN
            using SDMMC2EN = Field<17, 1>;    // SDMMC2EN
            using CRC1EN = Field<20, 1>;    // CRC1EN
            using USBHEN = Field<24, 1>;    // USBHEN
        };

        // This register is used to set the peripheral clock enable bit of the corresponding peripheral to . It shall be used to allocate a peripheral to the MPU. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to . If TZEN = , this register can only be modified in secure mode.
        struct RCC_MP_TZAHB6ENSETR : public Register<0x50000220> {
            using MDMAEN = Field<0, 1>;    // MDMAEN
        };

        // This register is used to clear the peripheral clock enable bit of the corresponding peripheral. It shall be used to deallocate a peripheral from MPU. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to . If TZEN = , this register can only be modified in secure mode.
        struct RCC_MP_TZAHB6ENCLRR : public Register<0x50000224> {
            using MDMAEN = Field<0, 1>;    // MDMAEN
        };

        // This register is used to set the peripheral clock enable bit
        struct RCC_MC_APB4ENSETR : public Register<0x50000280> {
            using LTDCEN = Field<0, 1>;    // LTDCEN
            using DSIEN = Field<4, 1>;    // DSIEN
            using DDRPERFMEN = Field<8, 1>;    // DDRPERFMEN
            using USBPHYEN = Field<16, 1>;    // USBPHYEN
            using STGENROEN = Field<20, 1>;    // STGENROEN
        };

        // This register is used to clear the peripheral clock enable bit
        struct RCC_MC_APB4ENCLRR : public Register<0x50000284> {
            using LTDCEN = Field<0, 1>;    // LTDCEN
            using DSIEN = Field<4, 1>;    // DSIEN
            using DDRPERFMEN = Field<8, 1>;    // DDRPERFMEN
            using USBPHYEN = Field<16, 1>;    // USBPHYEN
            using STGENROEN = Field<20, 1>;    // STGENROEN
        };

        // This register is used to set the peripheral clock enable bit
        struct RCC_MC_APB5ENSETR : public Register<0x50000288> {
            using SPI6EN = Field<0, 1>;    // SPI6EN
            using I2C4EN = Field<2, 1>;    // I2C4EN
            using I2C6EN = Field<3, 1>;    // I2C6EN
            using USART1EN = Field<4, 1>;    // USART1EN
            using RTCAPBEN = Field<8, 1>;    // RTCAPBEN
            using TZC1EN = Field<11, 1>;    // TZC1EN
            using TZC2EN = Field<12, 1>;    // TZC2EN
            using TZPCEN = Field<13, 1>;    // TZPCEN
            using BSECEN = Field<16, 1>;    // BSECEN
            using STGENEN = Field<20, 1>;    // STGENEN
        };

        // This register is used to clear the peripheral clock enable bit
        struct RCC_MC_APB5ENCLRR : public Register<0x5000028c> {
            using SPI6EN = Field<0, 1>;    // SPI6EN
            using I2C4EN = Field<2, 1>;    // I2C4EN
            using I2C6EN = Field<3, 1>;    // I2C6EN
            using USART1EN = Field<4, 1>;    // USART1EN
            using RTCAPBEN = Field<8, 1>;    // RTCAPBEN
            using TZC1EN = Field<11, 1>;    // TZC1EN
            using TZC2EN = Field<12, 1>;    // TZC2EN
            using TZPCEN = Field<13, 1>;    // TZPCEN
            using BSECEN = Field<16, 1>;    // BSECEN
            using STGENEN = Field<20, 1>;    // STGENEN
        };

        // This register is used to set the peripheral clock enable bit If TZEN = , this register can only be modified in secure mode.
        struct RCC_MC_AHB5ENSETR : public Register<0x50000290> {
            using GPIOZEN = Field<0, 1>;    // GPIOZEN
            using CRYP1EN = Field<4, 1>;    // CRYP1EN
            using HASH1EN = Field<5, 1>;    // HASH1EN
            using RNG1EN = Field<6, 1>;    // RNG1EN
            using BKPSRAMEN = Field<8, 1>;    // BKPSRAMEN
        };

        // This register is used to clear the peripheral clock enable bit If TZEN = , this register can only be modified in secure mode.
        struct RCC_MC_AHB5ENCLRR : public Register<0x50000294> {
            using GPIOZEN = Field<0, 1>;    // GPIOZEN
            using CRYP1EN = Field<4, 1>;    // CRYP1EN
            using HASH1EN = Field<5, 1>;    // HASH1EN
            using RNG1EN = Field<6, 1>;    // RNG1EN
            using BKPSRAMEN = Field<8, 1>;    // BKPSRAMEN
        };

        // This register is used to set the peripheral clock enable bit
        struct RCC_MC_AHB6ENSETR : public Register<0x50000298> {
            using MDMAEN = Field<0, 1>;    // MDMAEN
            using GPUEN = Field<5, 1>;    // GPUEN
            using ETHCKEN = Field<7, 1>;    // ETHCKEN
            using ETHTXEN = Field<8, 1>;    // ETHTXEN
            using ETHRXEN = Field<9, 1>;    // ETHRXEN
            using ETHMACEN = Field<10, 1>;    // ETHMACEN
            using FMCEN = Field<12, 1>;    // FMCEN
            using QSPIEN = Field<14, 1>;    // QSPIEN
            using SDMMC1EN = Field<16, 1>;    // SDMMC1EN
            using SDMMC2EN = Field<17, 1>;    // SDMMC2EN
            using CRC1EN = Field<20, 1>;    // CRC1EN
            using USBHEN = Field<24, 1>;    // USBHEN
        };

        // This register is used to clear the peripheral clock enable bit
        struct RCC_MC_AHB6ENCLRR : public Register<0x5000029c> {
            using MDMAEN = Field<0, 1>;    // MDMAEN
            using GPUEN = Field<5, 1>;    // GPUEN
            using ETHCKEN = Field<7, 1>;    // ETHCKEN
            using ETHTXEN = Field<8, 1>;    // ETHTXEN
            using ETHRXEN = Field<9, 1>;    // ETHRXEN
            using ETHMACEN = Field<10, 1>;    // ETHMACEN
            using FMCEN = Field<12, 1>;    // FMCEN
            using QSPIEN = Field<14, 1>;    // QSPIEN
            using SDMMC1EN = Field<16, 1>;    // SDMMC1EN
            using SDMMC2EN = Field<17, 1>;    // SDMMC2EN
            using CRC1EN = Field<20, 1>;    // CRC1EN
            using USBHEN = Field<24, 1>;    // USBHEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bits
        struct RCC_MP_APB4LPENSETR : public Register<0x50000300> {
            using LTDCLPEN = Field<0, 1>;    // LTDCLPEN
            using DSILPEN = Field<4, 1>;    // DSILPEN
            using DDRPERFMLPEN = Field<8, 1>;    // DDRPERFMLPEN
            using IWDG2APBLPEN = Field<15, 1>;    // IWDG2APBLPEN
            using USBPHYLPEN = Field<16, 1>;    // USBPHYLPEN
            using STGENROLPEN = Field<20, 1>;    // STGENROLPEN
            using STGENROSTPEN = Field<21, 1>;    // STGENROSTPEN
        };

        // This register is used by the MCU
        struct RCC_MP_APB4LPENCLRR : public Register<0x50000304> {
            using LTDCLPEN = Field<0, 1>;    // LTDCLPEN
            using DSILPEN = Field<4, 1>;    // DSILPEN
            using DDRPERFMLPEN = Field<8, 1>;    // DDRPERFMLPEN
            using IWDG2APBLPEN = Field<15, 1>;    // IWDG2APBLPEN
            using USBPHYLPEN = Field<16, 1>;    // USBPHYLPEN
            using STGENROLPEN = Field<20, 1>;    // STGENROLPEN
            using STGENROSTPEN = Field<21, 1>;    // STGENROSTPEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bits If TZEN = , this register can only be modified in secure mode.
        struct RCC_MP_APB5LPENSETR : public Register<0x50000308> {
            using SPI6LPEN = Field<0, 1>;    // SPI6LPEN
            using I2C4LPEN = Field<2, 1>;    // I2C4LPEN
            using I2C6LPEN = Field<3, 1>;    // I2C6LPEN
            using USART1LPEN = Field<4, 1>;    // USART1LPEN
            using RTCAPBLPEN = Field<8, 1>;    // RTCAPBLPEN
            using TZC1LPEN = Field<11, 1>;    // TZC1LPEN
            using TZC2LPEN = Field<12, 1>;    // TZC2LPEN
            using TZPCLPEN = Field<13, 1>;    // TZPCLPEN
            using IWDG1APBLPEN = Field<15, 1>;    // IWDG1APBLPEN
            using BSECLPEN = Field<16, 1>;    // BSECLPEN
            using STGENLPEN = Field<20, 1>;    // STGENLPEN
            using STGENSTPEN = Field<21, 1>;    // STGENSTPEN
        };

        // This register is used by the Mpu.
        struct RCC_MP_APB5LPENCLRR : public Register<0x5000030c> {
            using SPI6LPEN = Field<0, 1>;    // SPI6LPEN
            using I2C4LPEN = Field<2, 1>;    // I2C4LPEN
            using I2C6LPEN = Field<3, 1>;    // I2C6LPEN
            using USART1LPEN = Field<4, 1>;    // USART1LPEN
            using RTCAPBLPEN = Field<8, 1>;    // RTCAPBLPEN
            using TZC1LPEN = Field<11, 1>;    // TZC1LPEN
            using TZC2LPEN = Field<12, 1>;    // TZC2LPEN
            using TZPCLPEN = Field<13, 1>;    // TZPCLPEN
            using IWDG1APBLPEN = Field<15, 1>;    // IWDG1APBLPEN
            using BSECLPEN = Field<16, 1>;    // BSECLPEN
            using STGENLPEN = Field<20, 1>;    // STGENLPEN
            using STGENSTPEN = Field<21, 1>;    // STGENSTPEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bits If TZEN = , this register can only be modified in secure mode.
        struct RCC_MP_AHB5LPENSETR : public Register<0x50000310> {
            using GPIOZLPEN = Field<0, 1>;    // GPIOZLPEN
            using CRYP1LPEN = Field<4, 1>;    // CRYP1LPEN
            using HASH1LPEN = Field<5, 1>;    // HASH1LPEN
            using RNG1LPEN = Field<6, 1>;    // RNG1LPEN
            using BKPSRAMLPEN = Field<8, 1>;    // BKPSRAMLPEN
        };

        // This register is used by the MCU
        struct RCC_MP_AHB5LPENCLRR : public Register<0x50000314> {
            using GPIOZLPEN = Field<0, 1>;    // GPIOZLPEN
            using CRYP1LPEN = Field<4, 1>;    // CRYP1LPEN
            using HASH1LPEN = Field<5, 1>;    // HASH1LPEN
            using RNG1LPEN = Field<6, 1>;    // RNG1LPEN
            using BKPSRAMLPEN = Field<8, 1>;    // BKPSRAMLPEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bits
        struct RCC_MP_AHB6LPENSETR : public Register<0x50000318> {
            using MDMALPEN = Field<0, 1>;    // MDMALPEN
            using GPULPEN = Field<5, 1>;    // GPULPEN
            using ETHCKLPEN = Field<7, 1>;    // ETHCKLPEN
            using ETHTXLPEN = Field<8, 1>;    // ETHTXLPEN
            using ETHRXLPEN = Field<9, 1>;    // ETHRXLPEN
            using ETHMACLPEN = Field<10, 1>;    // ETHMACLPEN
            using ETHSTPEN = Field<11, 1>;    // ETHSTPEN
            using FMCLPEN = Field<12, 1>;    // FMCLPEN
            using QSPILPEN = Field<14, 1>;    // QSPILPEN
            using SDMMC1LPEN = Field<16, 1>;    // SDMMC1LPEN
            using SDMMC2LPEN = Field<17, 1>;    // SDMMC2LPEN
            using CRC1LPEN = Field<20, 1>;    // CRC1LPEN
            using USBHLPEN = Field<24, 1>;    // USBHLPEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bits
        struct RCC_MP_AHB6LPENCLRR : public Register<0x5000031c> {
            using MDMALPEN = Field<0, 1>;    // MDMALPEN
            using GPULPEN = Field<5, 1>;    // GPULPEN
            using ETHCKLPEN = Field<7, 1>;    // ETHCKLPEN
            using ETHTXLPEN = Field<8, 1>;    // ETHTXLPEN
            using ETHRXLPEN = Field<9, 1>;    // ETHRXLPEN
            using ETHMACLPEN = Field<10, 1>;    // ETHMACLPEN
            using ETHSTPEN = Field<11, 1>;    // ETHSTPEN
            using FMCLPEN = Field<12, 1>;    // FMCLPEN
            using QSPILPEN = Field<14, 1>;    // QSPILPEN
            using SDMMC1LPEN = Field<16, 1>;    // SDMMC1LPEN
            using SDMMC2LPEN = Field<17, 1>;    // SDMMC2LPEN
            using CRC1LPEN = Field<20, 1>;    // CRC1LPEN
            using USBHLPEN = Field<24, 1>;    // USBHLPEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bits If TZEN = , this register can only be modified in secure mode.
        struct RCC_MP_TZAHB6LPENSETR : public Register<0x50000320> {
            using MDMALPEN = Field<0, 1>;    // MDMALPEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bits If TZEN = , this register can only be modified in secure mode.
        struct RCC_MP_TZAHB6LPENCLRR : public Register<0x50000324> {
            using MDMALPEN = Field<0, 1>;    // MDMALPEN
        };

        // This register is used by the MCU in order to set the PERxLPEN bit.
        struct RCC_MC_APB4LPENSETR : public Register<0x50000380> {
            using LTDCLPEN = Field<0, 1>;    // LTDCLPEN
            using DSILPEN = Field<4, 1>;    // DSILPEN
            using DDRPERFMLPEN = Field<8, 1>;    // DDRPERFMLPEN
            using USBPHYLPEN = Field<16, 1>;    // USBPHYLPEN
            using STGENROLPEN = Field<20, 1>;    // STGENROLPEN
            using STGENROSTPEN = Field<21, 1>;    // STGENROSTPEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bit
        struct RCC_MC_APB4LPENCLRR : public Register<0x50000384> {
            using LTDCLPEN = Field<0, 1>;    // LTDCLPEN
            using DSILPEN = Field<4, 1>;    // DSILPEN
            using DDRPERFMLPEN = Field<8, 1>;    // DDRPERFMLPEN
            using USBPHYLPEN = Field<16, 1>;    // USBPHYLPEN
            using STGENROLPEN = Field<20, 1>;    // STGENROLPEN
            using STGENROSTPEN = Field<21, 1>;    // STGENROSTPEN
        };

        // This register is used by the MCU in order to set the PERxLPEN bit.
        struct RCC_MC_APB5LPENSETR : public Register<0x50000388> {
            using SPI6LPEN = Field<0, 1>;    // SPI6LPEN
            using I2C4LPEN = Field<2, 1>;    // I2C4LPEN
            using I2C6LPEN = Field<3, 1>;    // I2C6LPEN
            using USART1LPEN = Field<4, 1>;    // USART1LPEN
            using RTCAPBLPEN = Field<8, 1>;    // RTCAPBLPEN
            using TZC1LPEN = Field<11, 1>;    // TZC1LPEN
            using TZC2LPEN = Field<12, 1>;    // TZC2LPEN
            using TZPCLPEN = Field<13, 1>;    // TZPCLPEN
            using BSECLPEN = Field<16, 1>;    // BSECLPEN
            using STGENLPEN = Field<20, 1>;    // STGENLPEN
            using STGENSTPEN = Field<21, 1>;    // STGENSTPEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bit
        struct RCC_MC_APB5LPENCLRR : public Register<0x5000038c> {
            using SPI6LPEN = Field<0, 1>;    // SPI6LPEN
            using I2C4LPEN = Field<2, 1>;    // I2C4LPEN
            using I2C6LPEN = Field<3, 1>;    // I2C6LPEN
            using USART1LPEN = Field<4, 1>;    // USART1LPEN
            using RTCAPBLPEN = Field<8, 1>;    // RTCAPBLPEN
            using TZC1LPEN = Field<11, 1>;    // TZC1LPEN
            using TZC2LPEN = Field<12, 1>;    // TZC2LPEN
            using TZPCLPEN = Field<13, 1>;    // TZPCLPEN
            using BSECLPEN = Field<16, 1>;    // BSECLPEN
            using STGENLPEN = Field<20, 1>;    // STGENLPEN
            using STGENSTPEN = Field<21, 1>;    // STGENSTPEN
        };

        // This register is used by the MCU in order to set the PERxLPEN bit. If TZEN = , this register can only be modified in secure mode.
        struct RCC_MC_AHB5LPENSETR : public Register<0x50000390> {
            using GPIOZLPEN = Field<0, 1>;    // GPIOZLPEN
            using CRYP1LPEN = Field<4, 1>;    // CRYP1LPEN
            using HASH1LPEN = Field<5, 1>;    // HASH1LPEN
            using RNG1LPEN = Field<6, 1>;    // RNG1LPEN
            using BKPSRAMLPEN = Field<8, 1>;    // BKPSRAMLPEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bit If TZEN = , this register can only be modified in secure mode.
        struct RCC_MC_AHB5LPENCLRR : public Register<0x50000394> {
            using GPIOZLPEN = Field<0, 1>;    // GPIOZLPEN
            using CRYP1LPEN = Field<4, 1>;    // CRYP1LPEN
            using HASH1LPEN = Field<5, 1>;    // HASH1LPEN
            using RNG1LPEN = Field<6, 1>;    // RNG1LPEN
            using BKPSRAMLPEN = Field<8, 1>;    // BKPSRAMLPEN
        };

        // This register is used by the MCU in order to set the PERxLPEN bit.
        struct RCC_MC_AHB6LPENSETR : public Register<0x50000398> {
            using MDMALPEN = Field<0, 1>;    // MDMALPEN
            using GPULPEN = Field<5, 1>;    // GPULPEN
            using ETHCKLPEN = Field<7, 1>;    // ETHCKLPEN
            using ETHTXLPEN = Field<8, 1>;    // ETHTXLPEN
            using ETHRXLPEN = Field<9, 1>;    // ETHRXLPEN
            using ETHMACLPEN = Field<10, 1>;    // ETHMACLPEN
            using ETHSTPEN = Field<11, 1>;    // ETHSTPEN
            using FMCLPEN = Field<12, 1>;    // FMCLPEN
            using QSPILPEN = Field<14, 1>;    // QSPILPEN
            using SDMMC1LPEN = Field<16, 1>;    // SDMMC1LPEN
            using SDMMC2LPEN = Field<17, 1>;    // SDMMC2LPEN
            using CRC1LPEN = Field<20, 1>;    // CRC1LPEN
            using USBHLPEN = Field<24, 1>;    // USBHLPEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bit
        struct RCC_MC_AHB6LPENCLRR : public Register<0x5000039c> {
            using MDMALPEN = Field<0, 1>;    // MDMALPEN
            using GPULPEN = Field<5, 1>;    // GPULPEN
            using ETHCKLPEN = Field<7, 1>;    // ETHCKLPEN
            using ETHTXLPEN = Field<8, 1>;    // ETHTXLPEN
            using ETHRXLPEN = Field<9, 1>;    // ETHRXLPEN
            using ETHMACLPEN = Field<10, 1>;    // ETHMACLPEN
            using ETHSTPEN = Field<11, 1>;    // ETHSTPEN
            using FMCLPEN = Field<12, 1>;    // FMCLPEN
            using QSPILPEN = Field<14, 1>;    // QSPILPEN
            using SDMMC1LPEN = Field<16, 1>;    // SDMMC1LPEN
            using SDMMC2LPEN = Field<17, 1>;    // SDMMC2LPEN
            using CRC1LPEN = Field<20, 1>;    // CRC1LPEN
            using USBHLPEN = Field<24, 1>;    // USBHLPEN
        };

        // This register is used by the BOOTROM to check the reset source. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a clears the corresponding bit to . In order to identify the reset source, the MPU application must use RCC MPU Reset Status Clear Register (RCC_MP_RSTSCLRR), and the MCU application must use the RCC MCU Reset Status Clear Register (RCC_MC_RSTSCLRR). Refer to Section10.3.13: Reset source identification for details.This register except MPUP[1:0]RSTF flags is located into VDD domain, and is reset by por_rst reset. The MPUP[1:0]RSTF flags are located into VDDCORE and are reset by nreset. If TZEN = , this register can only be modified in secure mode.
        struct RCC_BR_RSTSCLRR : public Register<0x50000400> {
            using PORRSTF = Field<0, 1>;    // PORRSTF
            using BORRSTF = Field<1, 1>;    // BORRSTF
            using PADRSTF = Field<2, 1>;    // PADRSTF
            using HCSSRSTF = Field<3, 1>;    // HCSSRSTF
            using VCORERSTF = Field<4, 1>;    // VCORERSTF
            using MPSYSRSTF = Field<6, 1>;    // MPSYSRSTF
            using MCSYSRSTF = Field<7, 1>;    // MCSYSRSTF
            using IWDG1RSTF = Field<8, 1>;    // IWDG1RSTF
            using IWDG2RSTF = Field<9, 1>;    // IWDG2RSTF
            using MPUP0RSTF = Field<13, 1>;    // MPUP0RSTF
            using MPUP1RSTF = Field<14, 1>;    // MPUP1RSTF
        };

        // This register is used by the MPU in order to generate either a MCU reset or a system reset or a reset of one of the two MPU processors. Writing has no effect, reading returns the effective values of the corresponding bits. Writing a activates the reset.
        struct RCC_MP_GRSTCSETR : public Register<0x50000404> {
            using MPSYSRST = Field<0, 1>;    // MPSYSRST
            using MCURST = Field<1, 1>;    // MCURST
            using MPUP0RST = Field<4, 1>;    // MPUP0RST
            using MPUP1RST = Field<5, 1>;    // MPUP1RST
        };

        // This register is used by the MPU to check the reset source. This register is updated by the BOOTROM code, after a power-on reset (por_rst), a system reset (nreset), or an exit from Standby or CStandby.Writing has no effect, reading will return the effective values of the corresponding bits. Writing a clears the corresponding bit to .Refer to Section10.3.13: Reset source identification for details.The register is located in VDDCORE.If TZEN = , this register can only be modified in secure mode.
        struct RCC_MP_RSTSCLRR : public Register<0x50000408> {
            using PORRSTF = Field<0, 1>;    // PORRSTF
            using BORRSTF = Field<1, 1>;    // BORRSTF
            using PADRSTF = Field<2, 1>;    // PADRSTF
            using HCSSRSTF = Field<3, 1>;    // HCSSRSTF
            using VCORERSTF = Field<4, 1>;    // VCORERSTF
            using MPSYSRSTF = Field<6, 1>;    // MPSYSRSTF
            using MCSYSRSTF = Field<7, 1>;    // MCSYSRSTF
            using IWDG1RSTF = Field<8, 1>;    // IWDG1RSTF
            using IWDG2RSTF = Field<9, 1>;    // IWDG2RSTF
            using STDBYRSTF = Field<11, 1>;    // STDBYRSTF
            using CSTDBYRSTF = Field<12, 1>;    // CSTDBYRSTF
            using MPUP0RSTF = Field<13, 1>;    // MPUP0RSTF
            using MPUP1RSTF = Field<14, 1>;    // MPUP1RSTF
            using SPARE = Field<15, 1>;    // SPARE
        };

        // This register is used by the BOOTROM in order to freeze the IWDGs clocks. After a system reset or Standby reset (nreset), or a CStandby reset (cstby_rst) the MPU is allowed to write it once.Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to . If TZEN = , this register can only be modified in secure mode.
        struct RCC_MP_IWDGFZSETR : public Register<0x5000040c> {
            using FZ_IWDG1 = Field<0, 1>;    // FZ_IWDG1
            using FZ_IWDG2 = Field<1, 1>;    // FZ_IWDG2
        };

        // This register is used by the BOOTROM in order to unfreeze the IWDGs clocks. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a clears the corresponding bit to . If TZEN = , this register can only be modified in secure mode.
        struct RCC_MP_IWDGFZCLRR : public Register<0x50000410> {
            using FZ_IWDG1 = Field<0, 1>;    // FZ_IWDG1
            using FZ_IWDG2 = Field<1, 1>;    // FZ_IWDG2
        };

        // This register shall be used by the MPU to control the interrupt source enable. Refer to Section10.5: RCC interrupts for more details. If TZEN = , this register can only be modified in secure mode.
        struct RCC_MP_CIER : public Register<0x50000414> {
            using LSIRDYIE = Field<0, 1>;    // LSIRDYIE
            using LSERDYIE = Field<1, 1>;    // LSERDYIE
            using HSIRDYIE = Field<2, 1>;    // HSIRDYIE
            using HSERDYIE = Field<3, 1>;    // HSERDYIE
            using CSIRDYIE = Field<4, 1>;    // CSIRDYIE
            using PLL1DYIE = Field<8, 1>;    // PLL1DYIE
            using PLL2DYIE = Field<9, 1>;    // PLL2DYIE
            using PLL3DYIE = Field<10, 1>;    // PLL3DYIE
            using PLL4DYIE = Field<11, 1>;    // PLL4DYIE
            using LSECSSIE = Field<16, 1>;    // LSECSSIE
            using WKUPIE = Field<20, 1>;    // WKUPIE
        };

        // This register shall be used by the MPU in order to read and clear the interrupt flags.Writing has no effect, writing will clear the corresponding flag.Refer to Section10.5: RCC interrupts for more details. If TZEN = , this register can only be modified in secure mode.
        struct RCC_MP_CIFR : public Register<0x50000418> {
            using LSIRDYF = Field<0, 1>;    // LSIRDYF
            using LSERDYF = Field<1, 1>;    // LSERDYF
            using HSIRDYF = Field<2, 1>;    // HSIRDYF
            using HSERDYF = Field<3, 1>;    // HSERDYF
            using CSIRDYF = Field<4, 1>;    // CSIRDYF
            using PLL1DYF = Field<8, 1>;    // PLL1DYF
            using PLL2DYF = Field<9, 1>;    // PLL2DYF
            using PLL3DYF = Field<10, 1>;    // PLL3DYF
            using PLL4DYF = Field<11, 1>;    // PLL4DYF
            using LSECSSF = Field<16, 1>;    // LSECSSF
            using WKUPF = Field<20, 1>;    // WKUPF
        };

        // This register is used to program the delay between the moment where the system exits from one of the Stop modes, and the moment where it is allowed to enable the PLLs and provide a clock to bridges and processors. If TZEN = , this register can only be modified in secure mode.
        struct RCC_PWRLPDLYCR : public Register<0x5000041c> {
            using PWRLP_DLY = Field<0, 22>;    // PWRLP_DLY
            using MCTMPSKP = Field<24, 1>;    // MCTMPSKP
        };

        // This register is dedicated to the BOOTROM code in order to update the reset source. This register is updated by the BOOTROM code, after a power-on reset (por_rst), a system reset (nreset), or an exit from Standby or CStandby. The application software shall not use this register. In order to identify the reset source, the MPU application must use RCC MPU Reset Status Clear Register (RCC_MP_RSTSCLRR), and the MCU application must use the RCC MCU Reset Status Clear Register (RCC_MC_RSTSCLRR).Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to .Refer to Section10.3.13: Reset source identification for details.The register is located in VDDCORE.If TZEN = , this register can only be modified in secure mode.
        struct RCC_MP_RSTSSETR : public Register<0x50000420> {
            using PORRSTF = Field<0, 1>;    // PORRSTF
            using BORRSTF = Field<1, 1>;    // BORRSTF
            using PADRSTF = Field<2, 1>;    // PADRSTF
            using HCSSRSTF = Field<3, 1>;    // HCSSRSTF
            using VCORERSTF = Field<4, 1>;    // VCORERSTF
            using MPSYSRSTF = Field<6, 1>;    // MPSYSRSTF
            using MCSYSRSTF = Field<7, 1>;    // MCSYSRSTF
            using IWDG1RSTF = Field<8, 1>;    // IWDG1RSTF
            using IWDG2RSTF = Field<9, 1>;    // IWDG2RSTF
            using STDBYRSTF = Field<11, 1>;    // STDBYRSTF
            using CSTDBYRSTF = Field<12, 1>;    // CSTDBYRSTF
            using MPUP0RSTF = Field<13, 1>;    // MPUP0RSTF
            using MPUP1RSTF = Field<14, 1>;    // MPUP1RSTF
            using SPARE = Field<15, 1>;    // SPARE
        };

        // This register is used to select the clock generated on MCO1 output.
        struct RCC_MCO1CFGR : public Register<0x50000800> {
            using MCO1SEL = Field<0, 3>;    // MCO1SEL
            using MCO1DIV = Field<4, 4>;    // MCO1DIV
            using MCO1ON = Field<12, 1>;    // MCO1ON
        };

        // This register is used to select the clock generated on MCO2 output.
        struct RCC_MCO2CFGR : public Register<0x50000804> {
            using MCO2SEL = Field<0, 3>;    // MCO2SEL
            using MCO2DIV = Field<4, 4>;    // MCO2DIV
            using MCO2ON = Field<12, 1>;    // MCO2ON
        };

        // This is a read-only access register, It contains the status flags of oscillators. Writing has no effect.
        struct RCC_OCRDYR : public RegisterReadOnly<0x50000808> {
            using HSIRDY = Field<0, 1>;    // HSIRDY
            using HSIDIVRDY = Field<2, 1>;    // HSIDIVRDY
            using CSIRDY = Field<4, 1>;    // CSIRDY
            using HSERDY = Field<8, 1>;    // HSERDY
            using MPUCKRDY = Field<23, 1>;    // MPUCKRDY
            using AXICKRDY = Field<24, 1>;    // AXICKRDY
            using CKREST = Field<25, 1>;    // CKREST
        };

        // This is register contains the enable control of the debug and trace function, and the clock divider for the trace function.
        struct RCC_DBGCFGR : public Register<0x5000080c> {
            using TRACEDIV = Field<0, 3>;    // TRACEDIV
            using DBGCKEN = Field<8, 1>;    // DBGCKEN
            using TRACECKEN = Field<9, 1>;    // TRACECKEN
            using DBGRST = Field<12, 1>;    // DBGRST
        };

        // This register is used to select the reference clock for PLL3. If TZEN = MCKPROT = , this register can only be modified in secure mode.
        struct RCC_RCK3SELR : public Register<0x50000820> {
            using PLL3SRC = Field<0, 2>;    // PLL3SRC
            using PLL3SRCRDY = Field<31, 1>;    // PLL3SRCRDY
        };

        // This register is used to select the reference clock for PLL4.
        struct RCC_RCK4SELR : public Register<0x50000824> {
            using PLL4SRC = Field<0, 2>;    // PLL4SRC
            using PLL4SRCRDY = Field<31, 1>;    // PLL4SRCRDY
        };

        // This register is used to control the prescaler value of timers located into APB1 domain. It concerns TIM2, TIM3, TIM4, TIM5, TIM6, TIM7, TIM12, TIM13 and TIM14. Refer to Section: Sub-system clock generation for additional information.
        struct RCC_TIMG1PRER : public Register<0x50000828> {
            using TIMG1PRE = Field<0, 1>;    // TIMG1PRE
            using TIMG1PRERDY = Field<31, 1>;    // TIMG1PRERDY
        };

        // This register is used to control the prescaler value of timers located into APB2 domain. It concerns TIM1, TIM8, TIM15, TIM16, and TIM17. Refer to Section: Sub-system clock generation for additional information.
        struct RCC_TIMG2PRER : public Register<0x5000082c> {
            using TIMG2PRE = Field<0, 1>;    // TIMG2PRE
            using TIMG2PRERDY = Field<31, 1>;    // TIMG2PRERDY
        };

        // This register is used to control the MCU sub-system clock prescaler. Refer to Section: Sub-system clock generation for additional information. If TZEN = , this register can only be modified in secure mode.
        struct RCC_MCUDIVR : public Register<0x50000830> {
            using MCUDIV = Field<0, 4>;    // MCUDIV
            using MCUDIVRDY = Field<31, 1>;    // MCUDIVRDY
        };

        // This register is used to control the APB1 clock prescaler. Refer to section Section1.4.6.3: Sub-System Clock Generation for additional information.
        struct RCC_APB1DIVR : public Register<0x50000834> {
            using APB1DIV = Field<0, 3>;    // APB1DIV
            using APB1DIVRDY = Field<31, 1>;    // APB1DIVRDY
        };

        // This register is used to control the APB2 clock prescaler. Refer to Section: Sub-system clock generation for additional information.
        struct RCC_APB2DIVR : public Register<0x50000838> {
            using APB2DIV = Field<0, 3>;    // APB2DIV
            using APB2DIVRDY = Field<31, 1>;    // APB2DIVRDY
        };

        // This register is used to control the APB3 clock prescaler. Refer to Section: Sub-system clock generation for additional information.
        struct RCC_APB3DIVR : public Register<0x5000083c> {
            using APB3DIV = Field<0, 3>;    // APB3DIV
            using APB3DIVRDY = Field<31, 1>;    // APB3DIVRDY
        };

        // This register is used to control the PLL3. If TZEN = MCKPROT = , this register can only be modified in secure mode.
        struct RCC_PLL3CR : public Register<0x50000880> {
            using PLLON = Field<0, 1>;    // PLLON
            using PLL3RDY = Field<1, 1>;    // PLL3RDY
            using SSCG_CTRL = Field<2, 1>;    // SSCG_CTRL
            using DIVPEN = Field<4, 1>;    // DIVPEN
            using DIVQEN = Field<5, 1>;    // DIVQEN
            using DIVREN = Field<6, 1>;    // DIVREN
        };

        // This register is used to configure the PLL3. If TZEN = MCKPROT = , this register can only be modified in secure mode.
        struct RCC_PLL3CFGR1 : public Register<0x50000884> {
            using DIVN = Field<0, 9>;    // DIVN
            using DIVM3 = Field<16, 6>;    // DIVM3
            using IFRGE = Field<24, 2>;    // IFRGE
        };

        // This register is used to configure the PLL3. If TZEN = MCKPROT = , this register can only be modified in secure mode.
        struct RCC_PLL3CFGR2 : public Register<0x50000888> {
            using DIVP = Field<0, 7>;    // DIVP
            using DIVQ = Field<8, 7>;    // DIVQ
            using DIVR = Field<16, 7>;    // DIVR
        };

        // This register is used to fine-tune the frequency of the PLL3 VCO. If TZEN = MCKPROT = , this register can only be modified in secure mode.
        struct RCC_PLL3FRACR : public Register<0x5000088c> {
            using FRACV = Field<3, 13>;    // FRACV
            using FRACLE = Field<16, 1>;    // FRACLE
        };

        // This register is used to configure the PLL3.It is not recommended to change the content of this register when the PLL3 is enabled (PLLON = ). Refer to Section: Using the PLLs in spread spectrum mode for details. If TZEN = MCKPROT = , this register can only be modified in secure mode.
        struct RCC_PLL3CSGR : public Register<0x50000890> {
            using MOD_PER = Field<0, 13>;    // MOD_PER
            using TPDFN_DIS = Field<13, 1>;    // TPDFN_DIS
            using RPDFN_DIS = Field<14, 1>;    // RPDFN_DIS
            using SSCG_MODE = Field<15, 1>;    // SSCG_MODE
            using INC_STEP = Field<16, 15>;    // INC_STEP
        };

        // This register is used to control the PLL4.
        struct RCC_PLL4CR : public Register<0x50000894> {
            using PLLON = Field<0, 1>;    // PLLON
            using PLL4RDY = Field<1, 1>;    // PLL4RDY
            using SSCG_CTRL = Field<2, 1>;    // SSCG_CTRL
            using DIVPEN = Field<4, 1>;    // DIVPEN
            using DIVQEN = Field<5, 1>;    // DIVQEN
            using DIVREN = Field<6, 1>;    // DIVREN
        };

        // This register is used to configure the PLL4.
        struct RCC_PLL4CFGR1 : public Register<0x50000898> {
            using DIVN = Field<0, 9>;    // DIVN
            using DIVM4 = Field<16, 6>;    // DIVM4
            using IFRGE = Field<24, 2>;    // IFRGE
        };

        // This register is used to configure the PLL4.
        struct RCC_PLL4CFGR2 : public Register<0x5000089c> {
            using DIVP = Field<0, 7>;    // DIVP
            using DIVQ = Field<8, 7>;    // DIVQ
            using DIVR = Field<16, 7>;    // DIVR
        };

        // This register is used to fine-tune the frequency of the PLL4 VCO.
        struct RCC_PLL4FRACR : public Register<0x500008a0> {
            using FRACV = Field<3, 13>;    // FRACV
            using FRACLE = Field<16, 1>;    // FRACLE
        };

        // This register is used to configure the PLL4.It is not recommended to change the content of this register when the PLL4 is enabled (PLLON = ). Refer to Section: Using the PLLs in spread spectrum mode for details. If TZEN = MCKPROT = , this register can only be modified in secure mode.
        struct RCC_PLL4CSGR : public Register<0x500008a4> {
            using MOD_PER = Field<0, 13>;    // MOD_PER
            using TPDFN_DIS = Field<13, 1>;    // TPDFN_DIS
            using RPDFN_DIS = Field<14, 1>;    // RPDFN_DIS
            using SSCG_MODE = Field<15, 1>;    // SSCG_MODE
            using INC_STEP = Field<16, 15>;    // INC_STEP
        };

        // This register is used to control the selection of the kernel clock for the I2C1 and I2C2. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
        struct RCC_I2C12CKSELR : public Register<0x500008c0> {
            using I2C12SRC = Field<0, 3>;    // I2C12SRC
        };

        // This register is used to control the selection of the kernel clock for the I2C3 and I2C5. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
        struct RCC_I2C35CKSELR : public Register<0x500008c4> {
            using I2C35SRC = Field<0, 3>;    // I2C35SRC
        };

        // This register is used to control the selection of the kernel clock for the SAI1 and DFSDM audio clock. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
        struct RCC_SAI1CKSELR : public Register<0x500008c8> {
            using SAI1SRC = Field<0, 3>;    // SAI1SRC
        };

        // This register is used to control the selection of the kernel clock for the SAI2. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
        struct RCC_SAI2CKSELR : public Register<0x500008cc> {
            using SAI2SRC = Field<0, 3>;    // SAI2SRC
        };

        // This register is used to control the selection of the kernel clock for the SAI3. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
        struct RCC_SAI3CKSELR : public Register<0x500008d0> {
            using SAI3SRC = Field<0, 3>;    // SAI3SRC
        };

        // This register is used to control the selection of the kernel clock for the SAI4. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
        struct RCC_SAI4CKSELR : public Register<0x500008d4> {
            using SAI4SRC = Field<0, 3>;    // SAI4SRC
        };

        // This register is used to control the selection of the kernel clock for the SPI/I2S1. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
        struct RCC_SPI2S1CKSELR : public Register<0x500008d8> {
            using SPI1SRC = Field<0, 3>;    // SPI1SRC
        };

        // This register is used to control the selection of the kernel clock for the SPI/I2S2,3. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
        struct RCC_SPI2S23CKSELR : public Register<0x500008dc> {
            using SPI23SRC = Field<0, 3>;    // SPI23SRC
        };

        // This register is used to control the selection of the kernel clock for the SPI4,5. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
        struct RCC_SPI45CKSELR : public Register<0x500008e0> {
            using SPI45SRC = Field<0, 3>;    // SPI45SRC
        };

        // This register is used to control the selection of the kernel clock for the USART6. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
        struct RCC_UART6CKSELR : public Register<0x500008e4> {
            using UART6SRC = Field<0, 3>;    // UART6SRC
        };

        // This register is used to control the selection of the kernel clock for the USART2 and UART4. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
        struct RCC_UART24CKSELR : public Register<0x500008e8> {
            using UART24SRC = Field<0, 3>;    // UART24SRC
        };

        // This register is used to control the selection of the kernel clock for the USART3 and UART5. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
        struct RCC_UART35CKSELR : public Register<0x500008ec> {
            using UART35SRC = Field<0, 3>;    // UART35SRC
        };

        // This register is used to control the selection of the kernel clock for the UART7 and UART8. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
        struct RCC_UART78CKSELR : public Register<0x500008f0> {
            using UART78SRC = Field<0, 3>;    // UART78SRC
        };

        // This register is used to control the selection of the kernel clock for the SDMMC1 and SDMMC2. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
        struct RCC_SDMMC12CKSELR : public Register<0x500008f4> {
            using SDMMC12SRC = Field<0, 3>;    // SDMMC12SRC
        };

        // This register is used to control the selection of the kernel clock for the SDMMC3. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
        struct RCC_SDMMC3CKSELR : public Register<0x500008f8> {
            using SDMMC3SRC = Field<0, 3>;    // SDMMC3SRC
        };

        // This register is used to control the selection of the kernel clock for the ETH block. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
        struct RCC_ETHCKSELR : public Register<0x500008fc> {
            using ETHSRC = Field<0, 2>;    // ETHSRC
            using ETHPTPDIV = Field<4, 4>;    // ETHPTPDIV
        };

        // This register is used to control the selection of the kernel clock for the QUADSPI. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
        struct RCC_QSPICKSELR : public Register<0x50000900> {
            using QSPISRC = Field<0, 2>;    // QSPISRC
        };

        // This register is used to control the selection of the kernel clock for the FMC block. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
        struct RCC_FMCCKSELR : public Register<0x50000904> {
            using FMCSRC = Field<0, 2>;    // FMCSRC
        };

        // This register is used to control the selection of the kernel clock for the FDCAN block. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
        struct RCC_FDCANCKSELR : public Register<0x5000090c> {
            using FDCANSRC = Field<0, 2>;    // FDCANSRC
        };

        // This register is used to control the selection of the kernel clock for the SPDIFRX. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
        struct RCC_SPDIFCKSELR : public Register<0x50000914> {
            using SPDIFSRC = Field<0, 2>;    // SPDIFSRC
        };

        // This register is used to control the selection of the kernel clock for the CEC-HDMI.
        struct RCC_CECCKSELR : public Register<0x50000918> {
            using CECSRC = Field<0, 2>;    // CECSRC
        };

        // This register is used to control the selection of the kernel clock for the USBPHY PLL of the USB HOST and USB OTG
        struct RCC_USBCKSELR : public Register<0x5000091c> {
            using USBPHYSRC = Field<0, 2>;    // USBPHYSRC
            using USBOSRC = Field<4, 1>;    // USBOSRC
        };

        // This register is used to control the selection of the kernel clock for the RNG2.
        struct RCC_RNG2CKSELR : public Register<0x50000920> {
            using RNG2SRC = Field<0, 2>;    // RNG2SRC
        };

        // This register is used to control the selection of the kernel clock for the DSI block.
        struct RCC_DSICKSELR : public Register<0x50000924> {
            using DSISRC = Field<0, 1>;    // DSISRC
        };

        // This register is used to control the selection of the kernel clock for the ADC block.
        struct RCC_ADCCKSELR : public Register<0x50000928> {
            using ADCSRC = Field<0, 2>;    // ADCSRC
        };

        // This register is used to control the selection of the kernel clock for the LPTIM4 and LPTIM5 blocks.
        struct RCC_LPTIM45CKSELR : public Register<0x5000092c> {
            using LPTIM45SRC = Field<0, 3>;    // LPTIM45SRC
        };

        // This register is used to control the selection of the kernel clock for the LPTIM2 and LPTIM3 blocks.
        struct RCC_LPTIM23CKSELR : public Register<0x50000930> {
            using LPTIM23SRC = Field<0, 3>;    // LPTIM23SRC
        };

        // This register is used to control the selection of the kernel clock for the LPTIM1 block.
        struct RCC_LPTIM1CKSELR : public Register<0x50000934> {
            using LPTIM1SRC = Field<0, 3>;    // LPTIM1SRC
        };

        // This register is used to activate the reset of the corresponding peripheral.
        struct RCC_APB1RSTSETR : public Register<0x50000980> {
            using TIM2RST = Field<0, 1>;    // TIM2RST
            using TIM3RST = Field<1, 1>;    // TIM3RST
            using TIM4RST = Field<2, 1>;    // TIM4RST
            using TIM5RST = Field<3, 1>;    // TIM5RST
            using TIM6RST = Field<4, 1>;    // TIM6RST
            using TIM7RST = Field<5, 1>;    // TIM7RST
            using TIM12RST = Field<6, 1>;    // TIM12RST
            using TIM13RST = Field<7, 1>;    // TIM13RST
            using TIM14RST = Field<8, 1>;    // TIM14RST
            using LPTIM1RST = Field<9, 1>;    // LPTIM1RST
            using SPI2RST = Field<11, 1>;    // SPI2RST
            using SPI3RST = Field<12, 1>;    // SPI3RST
            using USART2RST = Field<14, 1>;    // USART2RST
            using USART3RST = Field<15, 1>;    // USART3RST
            using UART4RST = Field<16, 1>;    // UART4RST
            using UART5RST = Field<17, 1>;    // UART5RST
            using UART7RST = Field<18, 1>;    // UART7RST
            using UART8RST = Field<19, 1>;    // UART8RST
            using I2C1RST = Field<21, 1>;    // I2C1RST
            using I2C2RST = Field<22, 1>;    // I2C2RST
            using I2C3RST = Field<23, 1>;    // I2C3RST
            using I2C5RST = Field<24, 1>;    // I2C5RST
            using SPDIFRST = Field<26, 1>;    // SPDIFRST
            using CECRST = Field<27, 1>;    // CECRST
            using DAC12RST = Field<29, 1>;    // DAC12RST
            using MDIOSRST = Field<31, 1>;    // MDIOSRST
        };

        // This register is used to release the reset of the corresponding peripheral.
        struct RCC_APB1RSTCLRR : public Register<0x50000984> {
            using TIM2RST = Field<0, 1>;    // TIM2RST
            using TIM3RST = Field<1, 1>;    // TIM3RST
            using TIM4RST = Field<2, 1>;    // TIM4RST
            using TIM5RST = Field<3, 1>;    // TIM5RST
            using TIM6RST = Field<4, 1>;    // TIM6RST
            using TIM7RST = Field<5, 1>;    // TIM7RST
            using TIM12RST = Field<6, 1>;    // TIM12RST
            using TIM13RST = Field<7, 1>;    // TIM13RST
            using TIM14RST = Field<8, 1>;    // TIM14RST
            using LPTIM1RST = Field<9, 1>;    // LPTIM1RST
            using SPI2RST = Field<11, 1>;    // SPI2RST
            using SPI3RST = Field<12, 1>;    // SPI3RST
            using USART2RST = Field<14, 1>;    // USART2RST
            using USART3RST = Field<15, 1>;    // USART3RST
            using UART4RST = Field<16, 1>;    // UART4RST
            using UART5RST = Field<17, 1>;    // UART5RST
            using UART7RST = Field<18, 1>;    // UART7RST
            using UART8RST = Field<19, 1>;    // UART8RST
            using I2C1RST = Field<21, 1>;    // I2C1RST
            using I2C2RST = Field<22, 1>;    // I2C2RST
            using I2C3RST = Field<23, 1>;    // I2C3RST
            using I2C5RST = Field<24, 1>;    // I2C5RST
            using SPDIFRST = Field<26, 1>;    // SPDIFRST
            using CECRST = Field<27, 1>;    // CECRST
            using DAC12RST = Field<29, 1>;    // DAC12RST
            using MDIOSRST = Field<31, 1>;    // MDIOSRST
        };

        // This register is used to activate the reset of the corresponding peripheral.
        struct RCC_APB2RSTSETR : public Register<0x50000988> {
            using TIM1RST = Field<0, 1>;    // TIM1RST
            using TIM8RST = Field<1, 1>;    // TIM8RST
            using TIM15RST = Field<2, 1>;    // TIM15RST
            using TIM16RST = Field<3, 1>;    // TIM16RST
            using TIM17RST = Field<4, 1>;    // TIM17RST
            using SPI1RST = Field<8, 1>;    // SPI1RST
            using SPI4RST = Field<9, 1>;    // SPI4RST
            using SPI5RST = Field<10, 1>;    // SPI5RST
            using USART6RST = Field<13, 1>;    // USART6RST
            using SAI1RST = Field<16, 1>;    // SAI1RST
            using SAI2RST = Field<17, 1>;    // SAI2RST
            using SAI3RST = Field<18, 1>;    // SAI3RST
            using DFSDMRST = Field<20, 1>;    // DFSDMRST
            using FDCANRST = Field<24, 1>;    // FDCANRST
        };

        // This register is used to release the reset of the corresponding peripheral.
        struct RCC_APB2RSTCLRR : public Register<0x5000098c> {
            using TIM1RST = Field<0, 1>;    // TIM1RST
            using TIM8RST = Field<1, 1>;    // TIM8RST
            using TIM15RST = Field<2, 1>;    // TIM15RST
            using TIM16RST = Field<3, 1>;    // TIM16RST
            using TIM17RST = Field<4, 1>;    // TIM17RST
            using SPI1RST = Field<8, 1>;    // SPI1RST
            using SPI4RST = Field<9, 1>;    // SPI4RST
            using SPI5RST = Field<10, 1>;    // SPI5RST
            using USART6RST = Field<13, 1>;    // USART6RST
            using SAI1RST = Field<16, 1>;    // SAI1RST
            using SAI2RST = Field<17, 1>;    // SAI2RST
            using SAI3RST = Field<18, 1>;    // SAI3RST
            using DFSDMRST = Field<20, 1>;    // DFSDMRST
            using FDCANRST = Field<24, 1>;    // FDCANRST
        };

        // This register is used to activate the reset of the corresponding peripheral.
        struct RCC_APB3RSTSETR : public Register<0x50000990> {
            using LPTIM2RST = Field<0, 1>;    // LPTIM2RST
            using LPTIM3RST = Field<1, 1>;    // LPTIM3RST
            using LPTIM4RST = Field<2, 1>;    // LPTIM4RST
            using LPTIM5RST = Field<3, 1>;    // LPTIM5RST
            using SAI4RST = Field<8, 1>;    // SAI4RST
            using SYSCFGRST = Field<11, 1>;    // SYSCFGRST
            using VREFRST = Field<13, 1>;    // VREFRST
            using DTSRST = Field<16, 1>;    // DTSRST
        };

        // This register is used to release the reset of the corresponding peripheral.
        struct RCC_APB3RSTCLRR : public Register<0x50000994> {
            using LPTIM2RST = Field<0, 1>;    // LPTIM2RST
            using LPTIM3RST = Field<1, 1>;    // LPTIM3RST
            using LPTIM4RST = Field<2, 1>;    // LPTIM4RST
            using LPTIM5RST = Field<3, 1>;    // LPTIM5RST
            using SAI4RST = Field<8, 1>;    // SAI4RST
            using SYSCFGRST = Field<11, 1>;    // SYSCFGRST
            using VREFRST = Field<13, 1>;    // VREFRST
            using DTSRST = Field<16, 1>;    // DTSRST
        };

        // This register is used to activate the reset of the corresponding peripheral.
        struct RCC_AHB2RSTSETR : public Register<0x50000998> {
            using DMA1RST = Field<0, 1>;    // DMA1RST
            using DMA2RST = Field<1, 1>;    // DMA2RST
            using DMAMUXRST = Field<2, 1>;    // DMAMUXRST
            using ADC12RST = Field<5, 1>;    // ADC12RST
            using USBORST = Field<8, 1>;    // USBORST
            using SDMMC3RST = Field<16, 1>;    // SDMMC3RST
        };

        // This register is used to release the reset of the corresponding peripheral.
        struct RCC_AHB2RSTCLRR : public Register<0x5000099c> {
            using DMA1RST = Field<0, 1>;    // DMA1RST
            using DMA2RST = Field<1, 1>;    // DMA2RST
            using DMAMUXRST = Field<2, 1>;    // DMAMUXRST
            using ADC12RST = Field<5, 1>;    // ADC12RST
            using USBORST = Field<8, 1>;    // USBORST
            using SDMMC3RST = Field<16, 1>;    // SDMMC3RST
        };

        // This register is used to activate the reset of the corresponding peripheral.
        struct RCC_AHB3RSTSETR : public Register<0x500009a0> {
            using DCMIRST = Field<0, 1>;    // DCMIRST
            using CRYP2RST = Field<4, 1>;    // CRYP2RST
            using HASH2RST = Field<5, 1>;    // HASH2RST
            using RNG2RST = Field<6, 1>;    // RNG2RST
            using CRC2RST = Field<7, 1>;    // CRC2RST
            using HSEMRST = Field<11, 1>;    // HSEMRST
            using IPCCRST = Field<12, 1>;    // IPCCRST
        };

        // This register is used to release the reset of the corresponding peripheral.
        struct RCC_AHB3RSTCLRR : public Register<0x500009a4> {
            using DCMIRST = Field<0, 1>;    // DCMIRST
            using CRYP2RST = Field<4, 1>;    // CRYP2RST
            using HASH2RST = Field<5, 1>;    // HASH2RST
            using RNG2RST = Field<6, 1>;    // RNG2RST
            using CRC2RST = Field<7, 1>;    // CRC2RST
            using HSEMRST = Field<11, 1>;    // HSEMRST
            using IPCCRST = Field<12, 1>;    // IPCCRST
        };

        // This register is used to activate the reset of the corresponding peripheral
        struct RCC_AHB4RSTSETR : public Register<0x500009a8> {
            using GPIOARST = Field<0, 1>;    // GPIOARST
            using GPIOBRST = Field<1, 1>;    // GPIOBRST
            using GPIOCRST = Field<2, 1>;    // GPIOCRST
            using GPIODRST = Field<3, 1>;    // GPIODRST
            using GPIOERST = Field<4, 1>;    // GPIOERST
            using GPIOFRST = Field<5, 1>;    // GPIOFRST
            using GPIOGRST = Field<6, 1>;    // GPIOGRST
            using GPIOHRST = Field<7, 1>;    // GPIOHRST
            using GPIOIRST = Field<8, 1>;    // GPIOIRST
            using GPIOJRST = Field<9, 1>;    // GPIOJRST
            using GPIOKRST = Field<10, 1>;    // GPIOKRST
        };

        // This register is used to release the reset of the corresponding peripheral.
        struct RCC_AHB4RSTCLRR : public Register<0x500009ac> {
            using GPIOARST = Field<0, 1>;    // GPIOARST
            using GPIOBRST = Field<1, 1>;    // GPIOBRST
            using GPIOCRST = Field<2, 1>;    // GPIOCRST
            using GPIODRST = Field<3, 1>;    // GPIODRST
            using GPIOERST = Field<4, 1>;    // GPIOERST
            using GPIOFRST = Field<5, 1>;    // GPIOFRST
            using GPIOGRST = Field<6, 1>;    // GPIOGRST
            using GPIOHRST = Field<7, 1>;    // GPIOHRST
            using GPIOIRST = Field<8, 1>;    // GPIOIRST
            using GPIOJRST = Field<9, 1>;    // GPIOJRST
            using GPIOKRST = Field<10, 1>;    // GPIOKRST
        };

        // This register is used to set the peripheral clock enable bit
        struct RCC_MP_APB1ENSETR : public Register<0x50000a00> {
            using TIM2EN = Field<0, 1>;    // TIM2EN
            using TIM3EN = Field<1, 1>;    // TIM3EN
            using TIM4EN = Field<2, 1>;    // TIM4EN
            using TIM5EN = Field<3, 1>;    // TIM5EN
            using TIM6EN = Field<4, 1>;    // TIM6EN
            using TIM7EN = Field<5, 1>;    // TIM7EN
            using TIM12EN = Field<6, 1>;    // TIM12EN
            using TIM13EN = Field<7, 1>;    // TIM13EN
            using TIM14EN = Field<8, 1>;    // TIM14EN
            using LPTIM1EN = Field<9, 1>;    // LPTIM1EN
            using SPI2EN = Field<11, 1>;    // SPI2EN
            using SPI3EN = Field<12, 1>;    // SPI3EN
            using USART2EN = Field<14, 1>;    // USART2EN
            using USART3EN = Field<15, 1>;    // USART3EN
            using UART4EN = Field<16, 1>;    // UART4EN
            using UART5EN = Field<17, 1>;    // UART5EN
            using UART7EN = Field<18, 1>;    // UART7EN
            using UART8EN = Field<19, 1>;    // UART8EN
            using I2C1EN = Field<21, 1>;    // I2C1EN
            using I2C2EN = Field<22, 1>;    // I2C2EN
            using I2C3EN = Field<23, 1>;    // I2C3EN
            using I2C5EN = Field<24, 1>;    // I2C5EN
            using SPDIFEN = Field<26, 1>;    // SPDIFEN
            using CECEN = Field<27, 1>;    // CECEN
            using DAC12EN = Field<29, 1>;    // DAC12EN
            using MDIOSEN = Field<31, 1>;    // MDIOSEN
        };

        // This register is used to clear the peripheral clock enable bit
        struct RCC_MP_APB1ENCLRR : public Register<0x50000a04> {
            using TIM2EN = Field<0, 1>;    // TIM2EN
            using TIM3EN = Field<1, 1>;    // TIM3EN
            using TIM4EN = Field<2, 1>;    // TIM4EN
            using TIM5EN = Field<3, 1>;    // TIM5EN
            using TIM6EN = Field<4, 1>;    // TIM6EN
            using TIM7EN = Field<5, 1>;    // TIM7EN
            using TIM12EN = Field<6, 1>;    // TIM12EN
            using TIM13EN = Field<7, 1>;    // TIM13EN
            using TIM14EN = Field<8, 1>;    // TIM14EN
            using LPTIM1EN = Field<9, 1>;    // LPTIM1EN
            using SPI2EN = Field<11, 1>;    // SPI2EN
            using SPI3EN = Field<12, 1>;    // SPI3EN
            using USART2EN = Field<14, 1>;    // USART2EN
            using USART3EN = Field<15, 1>;    // USART3EN
            using UART4EN = Field<16, 1>;    // UART4EN
            using UART5EN = Field<17, 1>;    // UART5EN
            using UART7EN = Field<18, 1>;    // UART7EN
            using UART8EN = Field<19, 1>;    // UART8EN
            using I2C1EN = Field<21, 1>;    // I2C1EN
            using I2C2EN = Field<22, 1>;    // I2C2EN
            using I2C3EN = Field<23, 1>;    // I2C3EN
            using I2C5EN = Field<24, 1>;    // I2C5EN
            using SPDIFEN = Field<26, 1>;    // SPDIFEN
            using CECEN = Field<27, 1>;    // CECEN
            using DAC12EN = Field<29, 1>;    // DAC12EN
            using MDIOSEN = Field<31, 1>;    // MDIOSEN
        };

        // This register is used to set the peripheral clock enable bit
        struct RCC_MP_APB2ENSETR : public Register<0x50000a08> {
            using TIM1EN = Field<0, 1>;    // TIM1EN
            using TIM8EN = Field<1, 1>;    // TIM8EN
            using TIM15EN = Field<2, 1>;    // TIM15EN
            using TIM16EN = Field<3, 1>;    // TIM16EN
            using TIM17EN = Field<4, 1>;    // TIM17EN
            using SPI1EN = Field<8, 1>;    // SPI1EN
            using SPI4EN = Field<9, 1>;    // SPI4EN
            using SPI5EN = Field<10, 1>;    // SPI5EN
            using USART6EN = Field<13, 1>;    // USART6EN
            using SAI1EN = Field<16, 1>;    // SAI1EN
            using SAI2EN = Field<17, 1>;    // SAI2EN
            using SAI3EN = Field<18, 1>;    // SAI3EN
            using DFSDMEN = Field<20, 1>;    // DFSDMEN
            using ADFSDMEN = Field<21, 1>;    // ADFSDMEN
            using FDCANEN = Field<24, 1>;    // FDCANEN
        };

        // This register is used to clear the peripheral clock enable bit of the corresponding peripheral.
        struct RCC_MP_APB2ENCLRR : public Register<0x50000a0c> {
            using TIM1EN = Field<0, 1>;    // TIM1EN
            using TIM8EN = Field<1, 1>;    // TIM8EN
            using TIM15EN = Field<2, 1>;    // TIM15EN
            using TIM16EN = Field<3, 1>;    // TIM16EN
            using TIM17EN = Field<4, 1>;    // TIM17EN
            using SPI1EN = Field<8, 1>;    // SPI1EN
            using SPI4EN = Field<9, 1>;    // SPI4EN
            using SPI5EN = Field<10, 1>;    // SPI5EN
            using USART6EN = Field<13, 1>;    // USART6EN
            using SAI1EN = Field<16, 1>;    // SAI1EN
            using SAI2EN = Field<17, 1>;    // SAI2EN
            using SAI3EN = Field<18, 1>;    // SAI3EN
            using DFSDMEN = Field<20, 1>;    // DFSDMEN
            using ADFSDMEN = Field<21, 1>;    // ADFSDMEN
            using FDCANEN = Field<24, 1>;    // FDCANEN
        };

        // This register is used to set the peripheral clock enable bit
        struct RCC_MP_APB3ENSETR : public Register<0x50000a10> {
            using LPTIM2EN = Field<0, 1>;    // LPTIM2EN
            using LPTIM3EN = Field<1, 1>;    // LPTIM3EN
            using LPTIM4EN = Field<2, 1>;    // LPTIM4EN
            using LPTIM5EN = Field<3, 1>;    // LPTIM5EN
            using SAI4EN = Field<8, 1>;    // SAI4EN
            using SYSCFGEN = Field<11, 1>;    // SYSCFGEN
            using VREFEN = Field<13, 1>;    // VREFEN
            using DTSEN = Field<16, 1>;    // DTSEN
            using HDPEN = Field<20, 1>;    // HDPEN
        };

        // This register is used to clear the peripheral clock enable bit of the corresponding peripheral.
        struct RCC_MP_APB3ENCLRR : public Register<0x50000a14> {
            using LPTIM2EN = Field<0, 1>;    // LPTIM2EN
            using LPTIM3EN = Field<1, 1>;    // LPTIM3EN
            using LPTIM4EN = Field<2, 1>;    // LPTIM4EN
            using LPTIM5EN = Field<3, 1>;    // LPTIM5EN
            using SAI4EN = Field<8, 1>;    // SAI4EN
            using SYSCFGEN = Field<11, 1>;    // SYSCFGEN
            using VREFEN = Field<13, 1>;    // VREFEN
            using DTSEN = Field<16, 1>;    // DTSEN
            using HDPEN = Field<20, 1>;    // HDPEN
        };

        // This register is used to set the peripheral clock enable bit of the corresponding peripheral
        struct RCC_MP_AHB2ENSETR : public Register<0x50000a18> {
            using DMA1EN = Field<0, 1>;    // DMA1EN
            using DMA2EN = Field<1, 1>;    // DMA2EN
            using DMAMUXEN = Field<2, 1>;    // DMAMUXEN
            using ADC12EN = Field<5, 1>;    // ADC12EN
            using USBOEN = Field<8, 1>;    // USBOEN
            using SDMMC3EN = Field<16, 1>;    // SDMMC3EN
        };

        // This register is used to clear the peripheral clock enable bit of the corresponding peripheral.
        struct RCC_MP_AHB2ENCLRR : public Register<0x50000a1c> {
            using DMA1EN = Field<0, 1>;    // DMA1EN
            using DMA2EN = Field<1, 1>;    // DMA2EN
            using DMAMUXEN = Field<2, 1>;    // DMAMUXEN
            using ADC12EN = Field<5, 1>;    // ADC12EN
            using USBOEN = Field<8, 1>;    // USBOEN
            using SDMMC3EN = Field<16, 1>;    // SDMMC3EN
        };

        // This register is used to set the peripheral clock enable bit of the corresponding peripheral
        struct RCC_MP_AHB3ENSETR : public Register<0x50000a20> {
            using DCMIEN = Field<0, 1>;    // DCMIEN
            using CRYP2EN = Field<4, 1>;    // CRYP2EN
            using HASH2EN = Field<5, 1>;    // HASH2EN
            using RNG2EN = Field<6, 1>;    // RNG2EN
            using CRC2EN = Field<7, 1>;    // CRC2EN
            using HSEMEN = Field<11, 1>;    // HSEMEN
            using IPCCEN = Field<12, 1>;    // IPCCEN
        };

        // This register is used to clear the peripheral clock enable bit of the corresponding peripheral.
        struct RCC_MP_AHB3ENCLRR : public Register<0x50000a24> {
            using DCMIEN = Field<0, 1>;    // DCMIEN
            using CRYP2EN = Field<4, 1>;    // CRYP2EN
            using HASH2EN = Field<5, 1>;    // HASH2EN
            using RNG2EN = Field<6, 1>;    // RNG2EN
            using CRC2EN = Field<7, 1>;    // CRC2EN
            using HSEMEN = Field<11, 1>;    // HSEMEN
            using IPCCEN = Field<12, 1>;    // IPCCEN
        };

        // This register is used to set the peripheral clock enable bit of the corresponding peripheral to . It shall be used to allocate a peripheral to the MPU.
        struct RCC_MP_AHB4ENSETR : public Register<0x50000a28> {
            using GPIOAEN = Field<0, 1>;    // GPIOAEN
            using GPIOBEN = Field<1, 1>;    // GPIOBEN
            using GPIOCEN = Field<2, 1>;    // GPIOCEN
            using GPIODEN = Field<3, 1>;    // GPIODEN
            using GPIOEEN = Field<4, 1>;    // GPIOEEN
            using GPIOFEN = Field<5, 1>;    // GPIOFEN
            using GPIOGEN = Field<6, 1>;    // GPIOGEN
            using GPIOHEN = Field<7, 1>;    // GPIOHEN
            using GPIOIEN = Field<8, 1>;    // GPIOIEN
            using GPIOJEN = Field<9, 1>;    // GPIOJEN
            using GPIOKEN = Field<10, 1>;    // GPIOKEN
        };

        // This register is used to clear the peripheral clock enable bit
        struct RCC_MP_AHB4ENCLRR : public Register<0x50000a2c> {
            using GPIOAEN = Field<0, 1>;    // GPIOAEN
            using GPIOBEN = Field<1, 1>;    // GPIOBEN
            using GPIOCEN = Field<2, 1>;    // GPIOCEN
            using GPIODEN = Field<3, 1>;    // GPIODEN
            using GPIOEEN = Field<4, 1>;    // GPIOEEN
            using GPIOFEN = Field<5, 1>;    // GPIOFEN
            using GPIOGEN = Field<6, 1>;    // GPIOGEN
            using GPIOHEN = Field<7, 1>;    // GPIOHEN
            using GPIOIEN = Field<8, 1>;    // GPIOIEN
            using GPIOJEN = Field<9, 1>;    // GPIOJEN
            using GPIOKEN = Field<10, 1>;    // GPIOKEN
        };

        // This register is used to set the peripheral clock enable bit
        struct RCC_MP_MLAHBENSETR : public Register<0x50000a38> {
            using RETRAMEN = Field<4, 1>;    // RETRAMEN
        };

        // This register is used to clear the peripheral clock enable bit.
        struct RCC_MP_MLAHBENCLRR : public Register<0x50000a3c> {
            using RETRAMEN = Field<4, 1>;    // RETRAMEN
        };

        // This register is used to set the peripheral clock enable bit of the corresponding peripheral to . It shall be used to allocate a peripheral to the MCU. Writing has no effect, reading will return . Writing a sets the corresponding bit to .
        struct RCC_MC_APB1ENSETR : public Register<0x50000a80> {
            using TIM2EN = Field<0, 1>;    // TIM2EN
            using TIM3EN = Field<1, 1>;    // TIM3EN
            using TIM4EN = Field<2, 1>;    // TIM4EN
            using TIM5EN = Field<3, 1>;    // TIM5EN
            using TIM6EN = Field<4, 1>;    // TIM6EN
            using TIM7EN = Field<5, 1>;    // TIM7EN
            using TIM12EN = Field<6, 1>;    // TIM12EN
            using TIM13EN = Field<7, 1>;    // TIM13EN
            using TIM14EN = Field<8, 1>;    // TIM14EN
            using LPTIM1EN = Field<9, 1>;    // LPTIM1EN
            using SPI2EN = Field<11, 1>;    // SPI2EN
            using SPI3EN = Field<12, 1>;    // SPI3EN
            using USART2EN = Field<14, 1>;    // USART2EN
            using USART3EN = Field<15, 1>;    // USART3EN
            using UART4EN = Field<16, 1>;    // UART4EN
            using UART5EN = Field<17, 1>;    // UART5EN
            using UART7EN = Field<18, 1>;    // UART7EN
            using UART8EN = Field<19, 1>;    // UART8EN
            using I2C1EN = Field<21, 1>;    // I2C1EN
            using I2C2EN = Field<22, 1>;    // I2C2EN
            using I2C3EN = Field<23, 1>;    // I2C3EN
            using I2C5EN = Field<24, 1>;    // I2C5EN
            using SPDIFEN = Field<26, 1>;    // SPDIFEN
            using CECEN = Field<27, 1>;    // CECEN
            using WWDG1EN = Field<28, 1>;    // WWDG1EN
            using DAC12EN = Field<29, 1>;    // DAC12EN
            using MDIOSEN = Field<31, 1>;    // MDIOSEN
        };

        // This register is used to clear the peripheral clock enable bit of the corresponding peripheral.
        struct RCC_MC_APB1ENCLRR : public Register<0x50000a84> {
            using TIM2EN = Field<0, 1>;    // TIM2EN
            using TIM3EN = Field<1, 1>;    // TIM3EN
            using TIM4EN = Field<2, 1>;    // TIM4EN
            using TIM5EN = Field<3, 1>;    // TIM5EN
            using TIM6EN = Field<4, 1>;    // TIM6EN
            using TIM7EN = Field<5, 1>;    // TIM7EN
            using TIM12EN = Field<6, 1>;    // TIM12EN
            using TIM13EN = Field<7, 1>;    // TIM13EN
            using TIM14EN = Field<8, 1>;    // TIM14EN
            using LPTIM1EN = Field<9, 1>;    // LPTIM1EN
            using SPI2EN = Field<11, 1>;    // SPI2EN
            using SPI3EN = Field<12, 1>;    // SPI3EN
            using USART2EN = Field<14, 1>;    // USART2EN
            using USART3EN = Field<15, 1>;    // USART3EN
            using UART4EN = Field<16, 1>;    // UART4EN
            using UART5EN = Field<17, 1>;    // UART5EN
            using UART7EN = Field<18, 1>;    // UART7EN
            using UART8EN = Field<19, 1>;    // UART8EN
            using I2C1EN = Field<21, 1>;    // I2C1EN
            using I2C2EN = Field<22, 1>;    // I2C2EN
            using I2C3EN = Field<23, 1>;    // I2C3EN
            using I2C5EN = Field<24, 1>;    // I2C5EN
            using SPDIFEN = Field<26, 1>;    // SPDIFEN
            using CECEN = Field<27, 1>;    // CECEN
            using DAC12EN = Field<29, 1>;    // DAC12EN
            using MDIOSEN = Field<31, 1>;    // MDIOSEN
        };

        // This register is used to set the peripheral clock enable bit
        struct RCC_MC_APB2ENSETR : public Register<0x50000a88> {
            using TIM1EN = Field<0, 1>;    // TIM1EN
            using TIM8EN = Field<1, 1>;    // TIM8EN
            using TIM15EN = Field<2, 1>;    // TIM15EN
            using TIM16EN = Field<3, 1>;    // TIM16EN
            using TIM17EN = Field<4, 1>;    // TIM17EN
            using SPI1EN = Field<8, 1>;    // SPI1EN
            using SPI4EN = Field<9, 1>;    // SPI4EN
            using SPI5EN = Field<10, 1>;    // SPI5EN
            using USART6EN = Field<13, 1>;    // USART6EN
            using SAI1EN = Field<16, 1>;    // SAI1EN
            using SAI2EN = Field<17, 1>;    // SAI2EN
            using SAI3EN = Field<18, 1>;    // SAI3EN
            using DFSDMEN = Field<20, 1>;    // DFSDMEN
            using ADFSDMEN = Field<21, 1>;    // ADFSDMEN
            using FDCANEN = Field<24, 1>;    // FDCANEN
        };

        // This register is used to clear the peripheral clock enable bit
        struct RCC_MC_APB2ENCLRR : public Register<0x50000a8c> {
            using TIM1EN = Field<0, 1>;    // TIM1EN
            using TIM8EN = Field<1, 1>;    // TIM8EN
            using TIM15EN = Field<2, 1>;    // TIM15EN
            using TIM16EN = Field<3, 1>;    // TIM16EN
            using TIM17EN = Field<4, 1>;    // TIM17EN
            using SPI1EN = Field<8, 1>;    // SPI1EN
            using SPI4EN = Field<9, 1>;    // SPI4EN
            using SPI5EN = Field<10, 1>;    // SPI5EN
            using USART6EN = Field<13, 1>;    // USART6EN
            using SAI1EN = Field<16, 1>;    // SAI1EN
            using SAI2EN = Field<17, 1>;    // SAI2EN
            using SAI3EN = Field<18, 1>;    // SAI3EN
            using DFSDMEN = Field<20, 1>;    // DFSDMEN
            using ADFSDMEN = Field<21, 1>;    // ADFSDMEN
            using FDCANEN = Field<24, 1>;    // FDCANEN
        };

        // This register is used to set the peripheral clock enable bit
        struct RCC_MC_APB3ENSETR : public Register<0x50000a90> {
            using LPTIM2EN = Field<0, 1>;    // LPTIM2EN
            using LPTIM3EN = Field<1, 1>;    // LPTIM3EN
            using LPTIM4EN = Field<2, 1>;    // LPTIM4EN
            using LPTIM5EN = Field<3, 1>;    // LPTIM5EN
            using SAI4EN = Field<8, 1>;    // SAI4EN
            using SYSCFGEN = Field<11, 1>;    // SYSCFGEN
            using VREFEN = Field<13, 1>;    // VREFEN
            using DTSEN = Field<16, 1>;    // DTSEN
            using HDPEN = Field<20, 1>;    // HDPEN
        };

        // This register is used to clear the peripheral clock enable bit
        struct RCC_MC_APB3ENCLRR : public Register<0x50000a94> {
            using LPTIM2EN = Field<0, 1>;    // LPTIM2EN
            using LPTIM3EN = Field<1, 1>;    // LPTIM3EN
            using LPTIM4EN = Field<2, 1>;    // LPTIM4EN
            using LPTIM5EN = Field<3, 1>;    // LPTIM5EN
            using SAI4EN = Field<8, 1>;    // SAI4EN
            using SYSCFGEN = Field<11, 1>;    // SYSCFGEN
            using VREFEN = Field<13, 1>;    // VREFEN
            using DTSEN = Field<16, 1>;    // DTSEN
            using HDPEN = Field<20, 1>;    // HDPEN
        };

        // This register is used to set the peripheral clock enable bit
        struct RCC_MC_AHB2ENSETR : public Register<0x50000a98> {
            using DMA1EN = Field<0, 1>;    // DMA1EN
            using DMA2EN = Field<1, 1>;    // DMA2EN
            using DMAMUXEN = Field<2, 1>;    // DMAMUXEN
            using ADC12EN = Field<5, 1>;    // ADC12EN
            using USBOEN = Field<8, 1>;    // USBOEN
            using SDMMC3EN = Field<16, 1>;    // SDMMC3EN
        };

        // This register is used to clear the peripheral clock enable bit
        struct RCC_MC_AHB2ENCLRR : public Register<0x50000a9c> {
            using DMA1EN = Field<0, 1>;    // DMA1EN
            using DMA2EN = Field<1, 1>;    // DMA2EN
            using DMAMUXEN = Field<2, 1>;    // DMAMUXEN
            using ADC12EN = Field<5, 1>;    // ADC12EN
            using USBOEN = Field<8, 1>;    // USBOEN
            using SDMMC3EN = Field<16, 1>;    // SDMMC3EN
        };

        // This register is used to set the peripheral clock enable bit
        struct RCC_MC_AHB3ENSETR : public Register<0x50000aa0> {
            using DCMIEN = Field<0, 1>;    // DCMIEN
            using CRYP2EN = Field<4, 1>;    // CRYP2EN
            using HASH2EN = Field<5, 1>;    // HASH2EN
            using RNG2EN = Field<6, 1>;    // RNG2EN
            using CRC2EN = Field<7, 1>;    // CRC2EN
            using HSEMEN = Field<11, 1>;    // HSEMEN
            using IPCCEN = Field<12, 1>;    // IPCCEN
        };

        // This register is used to clear the peripheral clock enable bit
        struct RCC_MC_AHB3ENCLRR : public Register<0x50000aa4> {
            using DCMIEN = Field<0, 1>;    // DCMIEN
            using CRYP2EN = Field<4, 1>;    // CRYP2EN
            using HASH2EN = Field<5, 1>;    // HASH2EN
            using RNG2EN = Field<6, 1>;    // RNG2EN
            using CRC2EN = Field<7, 1>;    // CRC2EN
            using HSEMEN = Field<11, 1>;    // HSEMEN
            using IPCCEN = Field<12, 1>;    // IPCCEN
        };

        // This register is used to set the peripheral clock enable bit
        struct RCC_MC_AHB4ENSETR : public Register<0x50000aa8> {
            using GPIOAEN = Field<0, 1>;    // GPIOAEN
            using GPIOBEN = Field<1, 1>;    // GPIOBEN
            using GPIOCEN = Field<2, 1>;    // GPIOCEN
            using GPIODEN = Field<3, 1>;    // GPIODEN
            using GPIOEEN = Field<4, 1>;    // GPIOEEN
            using GPIOFEN = Field<5, 1>;    // GPIOFEN
            using GPIOGEN = Field<6, 1>;    // GPIOGEN
            using GPIOHEN = Field<7, 1>;    // GPIOHEN
            using GPIOIEN = Field<8, 1>;    // GPIOIEN
            using GPIOJEN = Field<9, 1>;    // GPIOJEN
            using GPIOKEN = Field<10, 1>;    // GPIOKEN
        };

        // This register is used to clear the peripheral clock enable bit
        struct RCC_MC_AHB4ENCLRR : public Register<0x50000aac> {
            using GPIOAEN = Field<0, 1>;    // GPIOAEN
            using GPIOBEN = Field<1, 1>;    // GPIOBEN
            using GPIOCEN = Field<2, 1>;    // GPIOCEN
            using GPIODEN = Field<3, 1>;    // GPIODEN
            using GPIOEEN = Field<4, 1>;    // GPIOEEN
            using GPIOFEN = Field<5, 1>;    // GPIOFEN
            using GPIOGEN = Field<6, 1>;    // GPIOGEN
            using GPIOHEN = Field<7, 1>;    // GPIOHEN
            using GPIOIEN = Field<8, 1>;    // GPIOIEN
            using GPIOJEN = Field<9, 1>;    // GPIOJEN
            using GPIOKEN = Field<10, 1>;    // GPIOKEN
        };

        // This register is used to set the peripheral clock enable bit
        struct RCC_MC_AXIMENSETR : public Register<0x50000ab0> {
            using SYSRAMEN = Field<0, 1>;    // SYSRAMEN
        };

        // This register is used to clear the peripheral clock enable bit
        struct RCC_MC_AXIMENCLRR : public Register<0x50000ab4> {
            using SYSRAMEN = Field<0, 1>;    // SYSRAMEN
        };

        // This register is used to set the peripheral clock enable bit
        struct RCC_MC_MLAHBENSETR : public Register<0x50000ab8> {
            using RETRAMEN = Field<4, 1>;    // RETRAMEN
        };

        // This register is used to clear the peripheral clock enable bit
        struct RCC_MC_MLAHBENCLRR : public Register<0x50000abc> {
            using RETRAMEN = Field<4, 1>;    // RETRAMEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bits
        struct RCC_MP_APB1LPENSETR : public Register<0x50000b00> {
            using TIM2LPEN = Field<0, 1>;    // TIM2LPEN
            using TIM3LPEN = Field<1, 1>;    // TIM3LPEN
            using TIM4LPEN = Field<2, 1>;    // TIM4LPEN
            using TIM5LPEN = Field<3, 1>;    // TIM5LPEN
            using TIM6LPEN = Field<4, 1>;    // TIM6LPEN
            using TIM7LPEN = Field<5, 1>;    // TIM7LPEN
            using TIM12LPEN = Field<6, 1>;    // TIM12LPEN
            using TIM13LPEN = Field<7, 1>;    // TIM13LPEN
            using TIM14LPEN = Field<8, 1>;    // TIM14LPEN
            using LPTIM1LPEN = Field<9, 1>;    // LPTIM1LPEN
            using SPI2LPEN = Field<11, 1>;    // SPI2LPEN
            using SPI3LPEN = Field<12, 1>;    // SPI3LPEN
            using USART2LPEN = Field<14, 1>;    // USART2LPEN
            using USART3LPEN = Field<15, 1>;    // USART3LPEN
            using UART4LPEN = Field<16, 1>;    // UART4LPEN
            using UART5LPEN = Field<17, 1>;    // UART5LPEN
            using UART7LPEN = Field<18, 1>;    // UART7LPEN
            using UART8LPEN = Field<19, 1>;    // UART8LPEN
            using I2C1LPEN = Field<21, 1>;    // I2C1LPEN
            using I2C2LPEN = Field<22, 1>;    // I2C2LPEN
            using I2C3LPEN = Field<23, 1>;    // I2C3LPEN
            using I2C5LPEN = Field<24, 1>;    // I2C5LPEN
            using SPDIFLPEN = Field<26, 1>;    // SPDIFLPEN
            using CECLPEN = Field<27, 1>;    // CECLPEN
            using DAC12LPEN = Field<29, 1>;    // DAC12LPEN
            using MDIOSLPEN = Field<31, 1>;    // MDIOSLPEN
        };

        // This register is used by the MPU in order to clear the PERxLPEN bits .
        struct RCC_MP_APB1LPENCLRR : public Register<0x50000b04> {
            using TIM2LPEN = Field<0, 1>;    // TIM2LPEN
            using TIM3LPEN = Field<1, 1>;    // TIM3LPEN
            using TIM4LPEN = Field<2, 1>;    // TIM4LPEN
            using TIM5LPEN = Field<3, 1>;    // TIM5LPEN
            using TIM6LPEN = Field<4, 1>;    // TIM6LPEN
            using TIM7LPEN = Field<5, 1>;    // TIM7LPEN
            using TIM12LPEN = Field<6, 1>;    // TIM12LPEN
            using TIM13LPEN = Field<7, 1>;    // TIM13LPEN
            using TIM14LPEN = Field<8, 1>;    // TIM14LPEN
            using LPTIM1LPEN = Field<9, 1>;    // LPTIM1LPEN
            using SPI2LPEN = Field<11, 1>;    // SPI2LPEN
            using SPI3LPEN = Field<12, 1>;    // SPI3LPEN
            using USART2LPEN = Field<14, 1>;    // USART2LPEN
            using USART3LPEN = Field<15, 1>;    // USART3LPEN
            using UART4LPEN = Field<16, 1>;    // UART4LPEN
            using UART5LPEN = Field<17, 1>;    // UART5LPEN
            using UART7LPEN = Field<18, 1>;    // UART7LPEN
            using UART8LPEN = Field<19, 1>;    // UART8LPEN
            using I2C1LPEN = Field<21, 1>;    // I2C1LPEN
            using I2C2LPEN = Field<22, 1>;    // I2C2LPEN
            using I2C3LPEN = Field<23, 1>;    // I2C3LPEN
            using I2C5LPEN = Field<24, 1>;    // I2C5LPEN
            using SPDIFLPEN = Field<26, 1>;    // SPDIFLPEN
            using CECLPEN = Field<27, 1>;    // CECLPEN
            using DAC12LPEN = Field<29, 1>;    // DAC12LPEN
            using MDIOSLPEN = Field<31, 1>;    // MDIOSLPEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bits
        struct RCC_MP_APB2LPENSETR : public Register<0x50000b08> {
            using TIM1LPEN = Field<0, 1>;    // TIM1LPEN
            using TIM8LPEN = Field<1, 1>;    // TIM8LPEN
            using TIM15LPEN = Field<2, 1>;    // TIM15LPEN
            using TIM16LPEN = Field<3, 1>;    // TIM16LPEN
            using TIM17LPEN = Field<4, 1>;    // TIM17LPEN
            using SPI1LPEN = Field<8, 1>;    // SPI1LPEN
            using SPI4LPEN = Field<9, 1>;    // SPI4LPEN
            using SPI5LPEN = Field<10, 1>;    // SPI5LPEN
            using USART6LPEN = Field<13, 1>;    // USART6LPEN
            using SAI1LPEN = Field<16, 1>;    // SAI1LPEN
            using SAI2LPEN = Field<17, 1>;    // SAI2LPEN
            using SAI3LPEN = Field<18, 1>;    // SAI3LPEN
            using DFSDMLPEN = Field<20, 1>;    // DFSDMLPEN
            using ADFSDMLPEN = Field<21, 1>;    // ADFSDMLPEN
            using FDCANLPEN = Field<24, 1>;    // FDCANLPEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bits
        struct RCC_MP_APB2LPENCLRR : public Register<0x50000b0c> {
            using TIM1LPEN = Field<0, 1>;    // TIM1LPEN
            using TIM8LPEN = Field<1, 1>;    // TIM8LPEN
            using TIM15LPEN = Field<2, 1>;    // TIM15LPEN
            using TIM16LPEN = Field<3, 1>;    // TIM16LPEN
            using TIM17LPEN = Field<4, 1>;    // TIM17LPEN
            using SPI1LPEN = Field<8, 1>;    // SPI1LPEN
            using SPI4LPEN = Field<9, 1>;    // SPI4LPEN
            using SPI5LPEN = Field<10, 1>;    // SPI5LPEN
            using USART6LPEN = Field<13, 1>;    // USART6LPEN
            using SAI1LPEN = Field<16, 1>;    // SAI1LPEN
            using SAI2LPEN = Field<17, 1>;    // SAI2LPEN
            using SAI3LPEN = Field<18, 1>;    // SAI3LPEN
            using DFSDMLPEN = Field<20, 1>;    // DFSDMLPEN
            using ADFSDMLPEN = Field<21, 1>;    // ADFSDMLPEN
            using FDCANLPEN = Field<24, 1>;    // FDCANLPEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bits
        struct RCC_MP_APB3LPENSETR : public Register<0x50000b10> {
            using LPTIM2LPEN = Field<0, 1>;    // LPTIM2LPEN
            using LPTIM3LPEN = Field<1, 1>;    // LPTIM3LPEN
            using LPTIM4LPEN = Field<2, 1>;    // LPTIM4LPEN
            using LPTIM5LPEN = Field<3, 1>;    // LPTIM5LPEN
            using SAI4LPEN = Field<8, 1>;    // SAI4LPEN
            using SYSCFGLPEN = Field<11, 1>;    // SYSCFGLPEN
            using VREFLPEN = Field<13, 1>;    // VREFLPEN
            using DTSLPEN = Field<16, 1>;    // DTSLPEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bits
        struct RCC_MP_APB3LPENCLRR : public Register<0x50000b14> {
            using LPTIM2LPEN = Field<0, 1>;    // LPTIM2LPEN
            using LPTIM3LPEN = Field<1, 1>;    // LPTIM3LPEN
            using LPTIM4LPEN = Field<2, 1>;    // LPTIM4LPEN
            using LPTIM5LPEN = Field<3, 1>;    // LPTIM5LPEN
            using SAI4LPEN = Field<8, 1>;    // SAI4LPEN
            using SYSCFGLPEN = Field<11, 1>;    // SYSCFGLPEN
            using VREFLPEN = Field<13, 1>;    // VREFLPEN
            using DTSLPEN = Field<16, 1>;    // DTSLPEN
        };

        // This register is used by the MPU in order to set the PERxLPEN bit.
        struct RCC_MP_AHB2LPENSETR : public Register<0x50000b18> {
            using DMA1LPEN = Field<0, 1>;    // DMA1LPEN
            using DMA2LPEN = Field<1, 1>;    // DMA2LPEN
            using DMAMUXLPEN = Field<2, 1>;    // DMAMUXLPEN
            using ADC12LPEN = Field<5, 1>;    // ADC12LPEN
            using USBOLPEN = Field<8, 1>;    // USBOLPEN
            using SDMMC3LPEN = Field<16, 1>;    // SDMMC3LPEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bits
        struct RCC_MP_AHB2LPENCLRR : public Register<0x50000b1c> {
            using DMA1LPEN = Field<0, 1>;    // DMA1LPEN
            using DMA2LPEN = Field<1, 1>;    // DMA2LPEN
            using DMAMUXLPEN = Field<2, 1>;    // DMAMUXLPEN
            using ADC12LPEN = Field<5, 1>;    // ADC12LPEN
            using USBOLPEN = Field<8, 1>;    // USBOLPEN
            using SDMMC3LPEN = Field<16, 1>;    // SDMMC3LPEN
        };

        // This register is used by the MPU
        struct RCC_MP_AHB3LPENSETR : public Register<0x50000b20> {
            using DCMILPEN = Field<0, 1>;    // DCMILPEN
            using CRYP2LPEN = Field<4, 1>;    // CRYP2LPEN
            using HASH2LPEN = Field<5, 1>;    // HASH2LPEN
            using RNG2LPEN = Field<6, 1>;    // RNG2LPEN
            using CRC2LPEN = Field<7, 1>;    // CRC2LPEN
            using HSEMLPEN = Field<11, 1>;    // HSEMLPEN
            using IPCCLPEN = Field<12, 1>;    // IPCCLPEN
        };

        // This register is used by the MPU in order to clear the PERxLPEN bit
        struct RCC_MP_AHB3LPENCLRR : public Register<0x50000b24> {
            using DCMILPEN = Field<0, 1>;    // DCMILPEN
            using CRYP2LPEN = Field<4, 1>;    // CRYP2LPEN
            using HASH2LPEN = Field<5, 1>;    // HASH2LPEN
            using RNG2LPEN = Field<6, 1>;    // RNG2LPEN
            using CRC2LPEN = Field<7, 1>;    // CRC2LPEN
            using HSEMLPEN = Field<11, 1>;    // HSEMLPEN
            using IPCCLPEN = Field<12, 1>;    // IPCCLPEN
        };

        // This register is used by the MPU
        struct RCC_MP_AHB4LPENSETR : public Register<0x50000b28> {
            using GPIOALPEN = Field<0, 1>;    // GPIOALPEN
            using GPIOBLPEN = Field<1, 1>;    // GPIOBLPEN
            using GPIOCLPEN = Field<2, 1>;    // GPIOCLPEN
            using GPIODLPEN = Field<3, 1>;    // GPIODLPEN
            using GPIOELPEN = Field<4, 1>;    // GPIOELPEN
            using GPIOFLPEN = Field<5, 1>;    // GPIOFLPEN
            using GPIOGLPEN = Field<6, 1>;    // GPIOGLPEN
            using GPIOHLPEN = Field<7, 1>;    // GPIOHLPEN
            using GPIOILPEN = Field<8, 1>;    // GPIOILPEN
            using GPIOJLPEN = Field<9, 1>;    // GPIOJLPEN
            using GPIOKLPEN = Field<10, 1>;    // GPIOKLPEN
        };

        // This register is used by the MPU
        struct RCC_MP_AHB4LPENCLRR : public Register<0x50000b2c> {
            using GPIOALPEN = Field<0, 1>;    // GPIOALPEN
            using GPIOBLPEN = Field<1, 1>;    // GPIOBLPEN
            using GPIOCLPEN = Field<2, 1>;    // GPIOCLPEN
            using GPIODLPEN = Field<3, 1>;    // GPIODLPEN
            using GPIOELPEN = Field<4, 1>;    // GPIOELPEN
            using GPIOFLPEN = Field<5, 1>;    // GPIOFLPEN
            using GPIOGLPEN = Field<6, 1>;    // GPIOGLPEN
            using GPIOHLPEN = Field<7, 1>;    // GPIOHLPEN
            using GPIOILPEN = Field<8, 1>;    // GPIOILPEN
            using GPIOJLPEN = Field<9, 1>;    // GPIOJLPEN
            using GPIOKLPEN = Field<10, 1>;    // GPIOKLPEN
        };

        // This register is used by the MPU
        struct RCC_MP_AXIMLPENSETR : public Register<0x50000b30> {
            using SYSRAMLPEN = Field<0, 1>;    // SYSRAMLPEN
        };

        // This register is used by the MPU
        struct RCC_MP_AXIMLPENCLRR : public Register<0x50000b34> {
            using SYSRAMLPEN = Field<0, 1>;    // SYSRAMLPEN
        };

        // This register is used by the MPU in order to set the PERxLPEN bit
        struct RCC_MP_MLAHBLPENSETR : public Register<0x50000b38> {
            using SRAM1LPEN = Field<0, 1>;    // SRAM1LPEN
            using SRAM2LPEN = Field<1, 1>;    // SRAM2LPEN
            using SRAM34LPEN = Field<2, 1>;    // SRAM34LPEN
            using RETRAMLPEN = Field<4, 1>;    // RETRAMLPEN
        };

        // This register is used by the MPU in order to clear the PERxLPEN bit
        struct RCC_MP_MLAHBLPENCLRR : public Register<0x50000b3c> {
            using SRAM1LPEN = Field<0, 1>;    // SRAM1LPEN
            using SRAM2LPEN = Field<1, 1>;    // SRAM2LPEN
            using SRAM34LPEN = Field<2, 1>;    // SRAM34LPEN
            using RETRAMLPEN = Field<4, 1>;    // RETRAMLPEN
        };

        // This register is used by the MCU in order to set the PERxLPEN bit.
        struct RCC_MC_APB1LPENSETR : public Register<0x50000b80> {
            using TIM2LPEN = Field<0, 1>;    // TIM2LPEN
            using TIM3LPEN = Field<1, 1>;    // TIM3LPEN
            using TIM4LPEN = Field<2, 1>;    // TIM4LPEN
            using TIM5LPEN = Field<3, 1>;    // TIM5LPEN
            using TIM6LPEN = Field<4, 1>;    // TIM6LPEN
            using TIM7LPEN = Field<5, 1>;    // TIM7LPEN
            using TIM12LPEN = Field<6, 1>;    // TIM12LPEN
            using TIM13LPEN = Field<7, 1>;    // TIM13LPEN
            using TIM14LPEN = Field<8, 1>;    // TIM14LPEN
            using LPTIM1LPEN = Field<9, 1>;    // LPTIM1LPEN
            using SPI2LPEN = Field<11, 1>;    // SPI2LPEN
            using SPI3LPEN = Field<12, 1>;    // SPI3LPEN
            using USART2LPEN = Field<14, 1>;    // USART2LPEN
            using USART3LPEN = Field<15, 1>;    // USART3LPEN
            using UART4LPEN = Field<16, 1>;    // UART4LPEN
            using UART5LPEN = Field<17, 1>;    // UART5LPEN
            using UART7LPEN = Field<18, 1>;    // UART7LPEN
            using UART8LPEN = Field<19, 1>;    // UART8LPEN
            using I2C1LPEN = Field<21, 1>;    // I2C1LPEN
            using I2C2LPEN = Field<22, 1>;    // I2C2LPEN
            using I2C3LPEN = Field<23, 1>;    // I2C3LPEN
            using I2C5LPEN = Field<24, 1>;    // I2C5LPEN
            using SPDIFLPEN = Field<26, 1>;    // SPDIFLPEN
            using CECLPEN = Field<27, 1>;    // CECLPEN
            using WWDG1LPEN = Field<28, 1>;    // WWDG1LPEN
            using DAC12LPEN = Field<29, 1>;    // DAC12LPEN
            using MDIOSLPEN = Field<31, 1>;    // MDIOSLPEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bits
        struct RCC_MC_APB1LPENCLRR : public Register<0x50000b84> {
            using TIM2LPEN = Field<0, 1>;    // TIM2LPEN
            using TIM3LPEN = Field<1, 1>;    // TIM3LPEN
            using TIM4LPEN = Field<2, 1>;    // TIM4LPEN
            using TIM5LPEN = Field<3, 1>;    // TIM5LPEN
            using TIM6LPEN = Field<4, 1>;    // TIM6LPEN
            using TIM7LPEN = Field<5, 1>;    // TIM7LPEN
            using TIM12LPEN = Field<6, 1>;    // TIM12LPEN
            using TIM13LPEN = Field<7, 1>;    // TIM13LPEN
            using TIM14LPEN = Field<8, 1>;    // TIM14LPEN
            using LPTIM1LPEN = Field<9, 1>;    // LPTIM1LPEN
            using SPI2LPEN = Field<11, 1>;    // SPI2LPEN
            using SPI3LPEN = Field<12, 1>;    // SPI3LPEN
            using USART2LPEN = Field<14, 1>;    // USART2LPEN
            using USART3LPEN = Field<15, 1>;    // USART3LPEN
            using UART4LPEN = Field<16, 1>;    // UART4LPEN
            using UART5LPEN = Field<17, 1>;    // UART5LPEN
            using UART7LPEN = Field<18, 1>;    // UART7LPEN
            using UART8LPEN = Field<19, 1>;    // UART8LPEN
            using I2C1LPEN = Field<21, 1>;    // I2C1LPEN
            using I2C2LPEN = Field<22, 1>;    // I2C2LPEN
            using I2C3LPEN = Field<23, 1>;    // I2C3LPEN
            using I2C5LPEN = Field<24, 1>;    // I2C5LPEN
            using SPDIFLPEN = Field<26, 1>;    // SPDIFLPEN
            using CECLPEN = Field<27, 1>;    // CECLPEN
            using WWDG1LPEN = Field<28, 1>;    // WWDG1LPEN
            using DAC12LPEN = Field<29, 1>;    // DAC12LPEN
            using MDIOSLPEN = Field<31, 1>;    // MDIOSLPEN
        };

        // This register is used by the MCU in order to set the PERxLPEN bit.
        struct RCC_MC_APB2LPENSETR : public Register<0x50000b88> {
            using TIM1LPEN = Field<0, 1>;    // TIM1LPEN
            using TIM8LPEN = Field<1, 1>;    // TIM8LPEN
            using TIM15LPEN = Field<2, 1>;    // TIM15LPEN
            using TIM16LPEN = Field<3, 1>;    // TIM16LPEN
            using TIM17LPEN = Field<4, 1>;    // TIM17LPEN
            using SPI1LPEN = Field<8, 1>;    // SPI1LPEN
            using SPI4LPEN = Field<9, 1>;    // SPI4LPEN
            using SPI5LPEN = Field<10, 1>;    // SPI5LPEN
            using USART6LPEN = Field<13, 1>;    // USART6LPEN
            using SAI1LPEN = Field<16, 1>;    // SAI1LPEN
            using SAI2LPEN = Field<17, 1>;    // SAI2LPEN
            using SAI3LPEN = Field<18, 1>;    // SAI3LPEN
            using DFSDMLPEN = Field<20, 1>;    // DFSDMLPEN
            using ADFSDMLPEN = Field<21, 1>;    // ADFSDMLPEN
            using FDCANLPEN = Field<24, 1>;    // FDCANLPEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bit
        struct RCC_MC_APB2LPENCLRR : public Register<0x50000b8c> {
            using TIM1LPEN = Field<0, 1>;    // TIM1LPEN
            using TIM8LPEN = Field<1, 1>;    // TIM8LPEN
            using TIM15LPEN = Field<2, 1>;    // TIM15LPEN
            using TIM16LPEN = Field<3, 1>;    // TIM16LPEN
            using TIM17LPEN = Field<4, 1>;    // TIM17LPEN
            using SPI1LPEN = Field<8, 1>;    // SPI1LPEN
            using SPI4LPEN = Field<9, 1>;    // SPI4LPEN
            using SPI5LPEN = Field<10, 1>;    // SPI5LPEN
            using USART6LPEN = Field<13, 1>;    // USART6LPEN
            using SAI1LPEN = Field<16, 1>;    // SAI1LPEN
            using SAI2LPEN = Field<17, 1>;    // SAI2LPEN
            using SAI3LPEN = Field<18, 1>;    // SAI3LPEN
            using DFSDMLPEN = Field<20, 1>;    // DFSDMLPEN
            using ADFSDMLPEN = Field<21, 1>;    // ADFSDMLPEN
            using FDCANLPEN = Field<24, 1>;    // FDCANLPEN
        };

        // This register is used by the MCU in order to set the PERxLPEN bit.
        struct RCC_MC_APB3LPENSETR : public Register<0x50000b90> {
            using LPTIM2LPEN = Field<0, 1>;    // LPTIM2LPEN
            using LPTIM3LPEN = Field<1, 1>;    // LPTIM3LPEN
            using LPTIM4LPEN = Field<2, 1>;    // LPTIM4LPEN
            using LPTIM5LPEN = Field<3, 1>;    // LPTIM5LPEN
            using SAI4LPEN = Field<8, 1>;    // SAI4LPEN
            using SYSCFGLPEN = Field<11, 1>;    // SYSCFGLPEN
            using VREFLPEN = Field<13, 1>;    // VREFLPEN
            using DTSLPEN = Field<16, 1>;    // DTSLPEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bit
        struct RCC_MC_APB3LPENCLRR : public Register<0x50000b94> {
            using LPTIM2LPEN = Field<0, 1>;    // LPTIM2LPEN
            using LPTIM3LPEN = Field<1, 1>;    // LPTIM3LPEN
            using LPTIM4LPEN = Field<2, 1>;    // LPTIM4LPEN
            using LPTIM5LPEN = Field<3, 1>;    // LPTIM5LPEN
            using SAI4LPEN = Field<8, 1>;    // SAI4LPEN
            using SYSCFGLPEN = Field<11, 1>;    // SYSCFGLPEN
            using VREFLPEN = Field<13, 1>;    // VREFLPEN
            using DTSLPEN = Field<16, 1>;    // DTSLPEN
        };

        // This register is used by the MCU in order to set the PERxLPEN bit.
        struct RCC_MC_AHB2LPENSETR : public Register<0x50000b98> {
            using DMA1LPEN = Field<0, 1>;    // DMA1LPEN
            using DMA2LPEN = Field<1, 1>;    // DMA2LPEN
            using DMAMUXLPEN = Field<2, 1>;    // DMAMUXLPEN
            using ADC12LPEN = Field<5, 1>;    // ADC12LPEN
            using USBOLPEN = Field<8, 1>;    // USBOLPEN
            using SDMMC3LPEN = Field<16, 1>;    // SDMMC3LPEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bit
        struct RCC_MC_AHB2LPENCLRR : public Register<0x50000b9c> {
            using DMA1LPEN = Field<0, 1>;    // DMA1LPEN
            using DMA2LPEN = Field<1, 1>;    // DMA2LPEN
            using DMAMUXLPEN = Field<2, 1>;    // DMAMUXLPEN
            using ADC12LPEN = Field<5, 1>;    // ADC12LPEN
            using USBOLPEN = Field<8, 1>;    // USBOLPEN
            using SDMMC3LPEN = Field<16, 1>;    // SDMMC3LPEN
        };

        // This register is used by the MCU in order to set the PERxLPEN bit.
        struct RCC_MC_AHB3LPENSETR : public Register<0x50000ba0> {
            using DCMILPEN = Field<0, 1>;    // DCMILPEN
            using CRYP2LPEN = Field<4, 1>;    // CRYP2LPEN
            using HASH2LPEN = Field<5, 1>;    // HASH2LPEN
            using RNG2LPEN = Field<6, 1>;    // RNG2LPEN
            using CRC2LPEN = Field<7, 1>;    // CRC2LPEN
            using HSEMLPEN = Field<11, 1>;    // HSEMLPEN
            using IPCCLPEN = Field<12, 1>;    // IPCCLPEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bit
        struct RCC_MC_AHB3LPENCLRR : public Register<0x50000ba4> {
            using DCMILPEN = Field<0, 1>;    // DCMILPEN
            using CRYP2LPEN = Field<4, 1>;    // CRYP2LPEN
            using HASH2LPEN = Field<5, 1>;    // HASH2LPEN
            using RNG2LPEN = Field<6, 1>;    // RNG2LPEN
            using CRC2LPEN = Field<7, 1>;    // CRC2LPEN
            using HSEMLPEN = Field<11, 1>;    // HSEMLPEN
            using IPCCLPEN = Field<12, 1>;    // IPCCLPEN
        };

        // This register is used by the MCU in order to set the PERxLPEN bit.
        struct RCC_MC_AHB4LPENSETR : public Register<0x50000ba8> {
            using GPIOALPEN = Field<0, 1>;    // GPIOALPEN
            using GPIOBLPEN = Field<1, 1>;    // GPIOBLPEN
            using GPIOCLPEN = Field<2, 1>;    // GPIOCLPEN
            using GPIODLPEN = Field<3, 1>;    // GPIODLPEN
            using GPIOELPEN = Field<4, 1>;    // GPIOELPEN
            using GPIOFLPEN = Field<5, 1>;    // GPIOFLPEN
            using GPIOGLPEN = Field<6, 1>;    // GPIOGLPEN
            using GPIOHLPEN = Field<7, 1>;    // GPIOHLPEN
            using GPIOILPEN = Field<8, 1>;    // GPIOILPEN
            using GPIOJLPEN = Field<9, 1>;    // GPIOJLPEN
            using GPIOKLPEN = Field<10, 1>;    // GPIOKLPEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bit of the corresponding peripheral.
        struct RCC_MC_AHB4LPENCLRR : public Register<0x50000bac> {
            using GPIOALPEN = Field<0, 1>;    // GPIOALPEN
            using GPIOBLPEN = Field<1, 1>;    // GPIOBLPEN
            using GPIOCLPEN = Field<2, 1>;    // GPIOCLPEN
            using GPIODLPEN = Field<3, 1>;    // GPIODLPEN
            using GPIOELPEN = Field<4, 1>;    // GPIOELPEN
            using GPIOFLPEN = Field<5, 1>;    // GPIOFLPEN
            using GPIOGLPEN = Field<6, 1>;    // GPIOGLPEN
            using GPIOHLPEN = Field<7, 1>;    // GPIOHLPEN
            using GPIOILPEN = Field<8, 1>;    // GPIOILPEN
            using GPIOJLPEN = Field<9, 1>;    // GPIOJLPEN
            using GPIOKLPEN = Field<10, 1>;    // GPIOKLPEN
        };

        // This register is used by the MCU in order to set the PERxLPEN bit of the corresponding peripheral.
        struct RCC_MC_AXIMLPENSETR : public Register<0x50000bb0> {
            using SYSRAMLPEN = Field<0, 1>;    // SYSRAMLPEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bit of the corresponding peripheral.
        struct RCC_MC_AXIMLPENCLRR : public Register<0x50000bb4> {
            using SYSRAMLPEN = Field<0, 1>;    // SYSRAMLPEN
        };

        // This register is used by the MCU in order to set the PERxLPEN bit of the corresponding peripheral.
        struct RCC_MC_MLAHBLPENSETR : public Register<0x50000bb8> {
            using SRAM1LPEN = Field<0, 1>;    // SRAM1LPEN
            using SRAM2LPEN = Field<1, 1>;    // SRAM2LPEN
            using SRAM34LPEN = Field<2, 1>;    // SRAM34LPEN
            using RETRAMLPEN = Field<4, 1>;    // RETRAMLPEN
        };

        // This register is used by the MCU in order to clear the PERxLPEN bit of the corresponding peripheral.
        struct RCC_MC_MLAHBLPENCLRR : public Register<0x50000bbc> {
            using SRAM1LPEN = Field<0, 1>;    // SRAM1LPEN
            using SRAM2LPEN = Field<1, 1>;    // SRAM2LPEN
            using SRAM34LPEN = Field<2, 1>;    // SRAM34LPEN
            using RETRAMLPEN = Field<4, 1>;    // RETRAMLPEN
        };

        // This register is used by the MCU to check the reset source.
        struct RCC_MC_RSTSCLRR : public Register<0x50000c00> {
            using PORRSTF = Field<0, 1>;    // PORRSTF
            using BORRSTF = Field<1, 1>;    // BORRSTF
            using PADRSTF = Field<2, 1>;    // PADRSTF
            using HCSSRSTF = Field<3, 1>;    // HCSSRSTF
            using VCORERSTF = Field<4, 1>;    // VCORERSTF
            using MCURSTF = Field<5, 1>;    // MCURSTF
            using MPSYSRSTF = Field<6, 1>;    // MPSYSRSTF
            using MCSYSRSTF = Field<7, 1>;    // MCSYSRSTF
            using IWDG1RSTF = Field<8, 1>;    // IWDG1RSTF
            using IWDG2RSTF = Field<9, 1>;    // IWDG2RSTF
            using WWDG1RSTF = Field<10, 1>;    // WWDG1RSTF
        };

        // This register shall be used by the MCU to control the interrupt source enable. Refer to Section10.5: RCC interrupts for more details.
        struct RCC_MC_CIER : public Register<0x50000c14> {
            using LSIRDYIE = Field<0, 1>;    // LSIRDYIE
            using LSERDYIE = Field<1, 1>;    // LSERDYIE
            using HSIRDYIE = Field<2, 1>;    // HSIRDYIE
            using HSERDYIE = Field<3, 1>;    // HSERDYIE
            using CSIRDYIE = Field<4, 1>;    // CSIRDYIE
            using PLL1DYIE = Field<8, 1>;    // PLL1DYIE
            using PLL2DYIE = Field<9, 1>;    // PLL2DYIE
            using PLL3DYIE = Field<10, 1>;    // PLL3DYIE
            using PLL4DYIE = Field<11, 1>;    // PLL4DYIE
            using LSECSSIE = Field<16, 1>;    // LSECSSIE
            using WKUPIE = Field<20, 1>;    // WKUPIE
        };

        // This register shall be used by the MCU in order to read and clear the interrupt flags.
        struct RCC_MC_CIFR : public Register<0x50000c18> {
            using LSIRDYF = Field<0, 1>;    // LSIRDYF
            using LSERDYF = Field<1, 1>;    // LSERDYF
            using HSIRDYF = Field<2, 1>;    // HSIRDYF
            using HSERDYF = Field<3, 1>;    // HSERDYF
            using CSIRDYF = Field<4, 1>;    // CSIRDYF
            using PLL1DYF = Field<8, 1>;    // PLL1DYF
            using PLL2DYF = Field<9, 1>;    // PLL2DYF
            using PLL3DYF = Field<10, 1>;    // PLL3DYF
            using PLL4DYF = Field<11, 1>;    // PLL4DYF
            using LSECSSF = Field<16, 1>;    // LSECSSF
            using WKUPF = Field<20, 1>;    // WKUPF
        };

        // This register gives the IP version
        struct RCC_VERR : public RegisterReadOnly<0x50000ff4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // This register gives the unique identifier of the RCC
        struct RCC_IDR : public RegisterReadOnly<0x50000ff8> {
            using ID = Field<0, 32>;    // ID
        };

        // This register gives the decoding space, which is for the RCC of 4 kB.
        struct RCC_SIDR : public RegisterReadOnly<0x50000ffc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // IPCC
    struct IPCC {
        // IPCC Processor 1 control register
        struct IPCC_C1CR : public Register<0x4c001000> {
            using RXOIE = Field<0, 1>;    // RXOIE
            using TXFIE = Field<16, 1>;    // TXFIE
        };

        // IPCC Processor 1 mask register
        struct IPCC_C1MR : public Register<0x4c001004> {
            using CHxOM = Field<0, 6>;    // CHxOM
            using CHxFM = Field<16, 6>;    // CHxFM
        };

        // Reading this register will always return 0x0000 0000.
        struct IPCC_C1SCR : public Register<0x4c001008> {
            using CHxC = Field<0, 6>;    // CHxC
            using CHxS = Field<16, 6>;    // CHxS
        };

        // IPCC processor 1 to processor 2 status register
        struct IPCC_C1TOC2SR : public RegisterReadOnly<0x4c00100c> {
            using CHxF = Field<0, 6>;    // CHxF
        };

        // IPCC Processor 2 control register
        struct IPCC_C2CR : public Register<0x4c001010> {
            using RXOIE = Field<0, 1>;    // RXOIE
            using TXFIE = Field<16, 1>;    // TXFIE
        };

        // IPCC Processor 2 mask register
        struct IPCC_C2MR : public Register<0x4c001014> {
            using CHxOM = Field<0, 6>;    // CHxOM
            using CHxFM = Field<16, 6>;    // CHxFM
        };

        // Reading this register will always return 0x0000 0000.
        struct IPCC_C2SCR : public Register<0x4c001018> {
            using CHxC = Field<0, 6>;    // CHxC
            using CHxS = Field<16, 6>;    // CHxS
        };

        // IPCC processor 2 to processor 1 status register
        struct IPCC_C2TOC1SR : public RegisterReadOnly<0x4c00101c> {
            using CHxF = Field<0, 6>;    // CHxF
        };

        // IPCC Hardware configuration register
        struct IPCC_HWCFGR : public RegisterReadOnly<0x4c0013f0> {
            using CHANNELS = Field<0, 8>;    // CHANNELS
        };

        // IPCC IP Version register
        struct IPCC_VER : public RegisterReadOnly<0x4c0013f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // IPCC IP Identification register
        struct IPCC_ID : public RegisterReadOnly<0x4c0013f8> {
            using IPID = Field<0, 32>;    // IPID
        };

        // IPCC Size ID register
        struct IPCC_SID : public RegisterReadOnly<0x4c0013fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // OTGHSFS1
    struct OTGHSFS1 {
        // The OTG_GOTGCTL register controls the behavior and reflects the status of the OTG function of the core.
        struct OTG_GOTGCTL : public Register<0x49000000> {
            using SRQSCS = Field<0, 1>;    // SRQSCS
            using SRQ = Field<1, 1>;    // SRQ
            using VBVALOEN = Field<2, 1>;    // VBVALOEN
            using VBVALOVAL = Field<3, 1>;    // VBVALOVAL
            using AVALOEN = Field<4, 1>;    // AVALOEN
            using AVALOVAL = Field<5, 1>;    // AVALOVAL
            using BVALOEN = Field<6, 1>;    // BVALOEN
            using BVALOVAL = Field<7, 1>;    // BVALOVAL
            using HNGSCS = Field<8, 1>;    // HNGSCS
            using HNPRQ = Field<9, 1>;    // HNPRQ
            using HSHNPEN = Field<10, 1>;    // HSHNPEN
            using DHNPEN = Field<11, 1>;    // DHNPEN
            using EHEN = Field<12, 1>;    // EHEN
            using CIDSTS = Field<16, 1>;    // CIDSTS
            using DBCT = Field<17, 1>;    // DBCT
            using ASVLD = Field<18, 1>;    // ASVLD
            using BSVLD = Field<19, 1>;    // BSVLD
            using OTGVER = Field<20, 1>;    // OTGVER
            using CURMOD = Field<21, 1>;    // CURMOD
        };

        // The application reads this register whenever there is an OTG interrupt and clears the bits in this register to clear the OTG interrupt.
        struct OTG_GOTGINT : public Register<0x49000004> {
            using SEDET = Field<2, 1>;    // SEDET
            using SRSSCHG = Field<8, 1>;    // SRSSCHG
            using HNSSCHG = Field<9, 1>;    // HNSSCHG
            using HNGDET = Field<17, 1>;    // HNGDET
            using ADTOCHG = Field<18, 1>;    // ADTOCHG
            using DBCDNE = Field<19, 1>;    // DBCDNE
            using IDCHNG = Field<20, 1>;    // IDCHNG
        };

        // This register can be used to configure the core after power-on or a change in mode. This register mainly contains AHB system-related configuration parameters. Do not change this register after the initial programming. The application must program this register before starting any transactions on either the AHB or the USB.
        struct OTG_GAHBCFG : public Register<0x49000008> {
            using GINTMSK = Field<0, 1>;    // GINTMSK
            using HBSTLEN = Field<1, 4>;    // HBSTLEN
            using DMAEN = Field<5, 1>;    // DMAEN
            using TXFELVL = Field<7, 1>;    // TXFELVL
            using PTXFELVL = Field<8, 1>;    // PTXFELVL
        };

        // This register can be used to configure the core after power-on or a changing to host mode or device mode. It contains USB and USB-PHY related configuration parameters. The application must program this register before starting any transactions on either the AHB or the USB. Do not make changes to this register after the initial programming.
        struct OTG_GUSBCFG : public Register<0x4900000c> {
            using TOCAL = Field<0, 3>;    // TOCAL
            using PHYSEL = Field<6, 1>;    // PHYSEL
            using SRPCAP = Field<8, 1>;    // SRPCAP
            using HNPCAP = Field<9, 1>;    // HNPCAP
            using TRDT = Field<10, 4>;    // TRDT
            using PHYLPC = Field<15, 1>;    // PHYLPC
            using TSDPS = Field<22, 1>;    // TSDPS
            using FHMOD = Field<29, 1>;    // FHMOD
            using FDMOD = Field<30, 1>;    // FDMOD
        };

        // The application uses this register to reset various hardware features inside the core.
        struct OTG_GRSTCTL : public Register<0x49000010> {
            using CSRST = Field<0, 1>;    // CSRST
            using PSRST = Field<1, 1>;    // PSRST
            using RXFFLSH = Field<4, 1>;    // RXFFLSH
            using TXFFLSH = Field<5, 1>;    // TXFFLSH
            using TXFNUM = Field<6, 5>;    // TXFNUM
            using DMAREQ = Field<30, 1>;    // DMAREQ
            using AHBIDL = Field<31, 1>;    // AHBIDL
        };

        // This register interrupts the application for system-level events in the current mode (device mode or host mode). Some of the bits in this register are valid only in host mode, while others are valid in device mode only. This register also indicates the current mode. To clear the interrupt status bits of the rc_w1 type, the application must write 1 into the bit. The FIFO status interrupts are read-only; once software reads from or writes to the FIFO while servicing these interrupts, FIFO interrupt conditions are cleared automatically. The application must clear the OTG_GINTSTS register at initialization before unmasking the interrupt bit to avoid any interrupts generated prior to initialization.
        struct OTG_GINTSTS : public Register<0x49000014> {
            using CMOD = Field<0, 1>;    // CMOD
            using MMIS = Field<1, 1>;    // MMIS
            using OTGINT = Field<2, 1>;    // OTGINT
            using SOF = Field<3, 1>;    // SOF
            using RXFLVL = Field<4, 1>;    // RXFLVL
            using NPTXFE = Field<5, 1>;    // NPTXFE
            using GINAKEFF = Field<6, 1>;    // GINAKEFF
            using GONAKEFF = Field<7, 1>;    // GONAKEFF
            using ESUSP = Field<10, 1>;    // ESUSP
            using USBSUSP = Field<11, 1>;    // USBSUSP
            using USBRST = Field<12, 1>;    // USBRST
            using ENUMDNE = Field<13, 1>;    // ENUMDNE
            using ISOODRP = Field<14, 1>;    // ISOODRP
            using EOPF = Field<15, 1>;    // EOPF
            using IEPINT = Field<18, 1>;    // IEPINT
            using OEPINT = Field<19, 1>;    // OEPINT
            using IISOIXFR = Field<20, 1>;    // IISOIXFR
            using IPXFR = Field<21, 1>;    // IPXFR
            using DATAFSUSP = Field<22, 1>;    // DATAFSUSP
            using HPRTINT = Field<24, 1>;    // HPRTINT
            using HCINT = Field<25, 1>;    // HCINT
            using PTXFE = Field<26, 1>;    // PTXFE
            using CIDSCHG = Field<28, 1>;    // CIDSCHG
            using DISCINT = Field<29, 1>;    // DISCINT
            using SRQINT = Field<30, 1>;    // SRQINT
            using WKUPINT = Field<31, 1>;    // WKUPINT
        };

        // This register works with the core interrupt register to interrupt the application. When an interrupt bit is masked, the interrupt associated with that bit is not generated. However, the core interrupt (OTG_GINTSTS) register bit corresponding to that interrupt is still set.
        struct OTG_GINTMSK : public Register<0x49000018> {
            using MMISM = Field<1, 1>;    // MMISM
            using OTGINT = Field<2, 1>;    // OTGINT
            using SOFM = Field<3, 1>;    // SOFM
            using RXFLVLM = Field<4, 1>;    // RXFLVLM
            using NPTXFEM = Field<5, 1>;    // NPTXFEM
            using GINAKEFFM = Field<6, 1>;    // GINAKEFFM
            using GONAKEFFM = Field<7, 1>;    // GONAKEFFM
            using ESUSPM = Field<10, 1>;    // ESUSPM
            using USBSUSPM = Field<11, 1>;    // USBSUSPM
            using USBRST = Field<12, 1>;    // USBRST
            using ENUMDNEM = Field<13, 1>;    // ENUMDNEM
            using ISOODRPM = Field<14, 1>;    // ISOODRPM
            using EOPFM = Field<15, 1>;    // EOPFM
            using IEPINT = Field<18, 1>;    // IEPINT
            using OEPINT = Field<19, 1>;    // OEPINT
            using IISOIXFRM = Field<20, 1>;    // IISOIXFRM
            using IPXFRM = Field<21, 1>;    // IPXFRM
            using FSUSPM = Field<22, 1>;    // FSUSPM
            using RSTDETM = Field<23, 1>;    // RSTDETM
            using PRTIM = Field<24, 1>;    // PRTIM
            using HCIM = Field<25, 1>;    // HCIM
            using PTXFEM = Field<26, 1>;    // PTXFEM
            using LPMINTM = Field<27, 1>;    // LPMINTM
            using CIDSCHGM = Field<28, 1>;    // CIDSCHGM
            using DISCINT = Field<29, 1>;    // DISCINT
            using SRQIM = Field<30, 1>;    // SRQIM
            using WUIM = Field<31, 1>;    // WUIM
        };

        // This description is for register OTG_GRXSTSR in Device mode. A read to the receive status debug read register returns the contents of the top of the receive FIFO. The core ignores the receive status read when the receive FIFO is empty and returns a value of 0x00000000.
        struct OTG_GRXSTSR : public RegisterReadOnly<0x4900001c> {
            using EPNUM = Field<0, 4>;    // EPNUM
            using BCNT = Field<4, 11>;    // BCNT
            using DPID = Field<15, 2>;    // DPID
            using PKTSTS = Field<17, 4>;    // PKTSTS
            using FRMNUM = Field<21, 4>;    // FRMNUM
            using STSPHST = Field<27, 1>;    // STSPHST
        };

        // This description is for register OTG_GRXSTSP in Device mode. Similarly to OTG_GRXSTSR (receive status debug read register) where a read returns the contents of the top of the receive FIFO, a read to OTG_GRXSTSP (receive status read and pop register) additionally pops the top data entry out of the Rx FIFO. The core ignores the receive status pop/read when the receive FIFO is empty and returns a value of 0x00000000. The application must only pop the receive status FIFO when the receive FIFO non-empty bit of the core interrupt register (RXFLVL bit in OTG_GINTSTS) is asserted.
        struct OTG_GRXSTSP : public RegisterReadOnly<0x49000020> {
            using EPNUM = Field<0, 4>;    // EPNUM
            using BCNT = Field<4, 11>;    // BCNT
            using DPID = Field<15, 2>;    // DPID
            using PKTSTS = Field<17, 4>;    // PKTSTS
            using FRMNUM = Field<21, 4>;    // FRMNUM
            using STSPHST = Field<27, 1>;    // STSPHST
        };

        // The application can program the RAM size that must be allocated to the Rx FIFO.
        struct OTG_GRXFSIZ : public Register<0x49000024> {
            using RXFD = Field<0, 16>;    // RXFD
        };

        // Host mode
        struct OTG_HNPTXFSIZ : public Register<0x49000028> {
            using NPTXFSA = Field<0, 16>;    // NPTXFSA
            using NPTXFD = Field<16, 16>;    // NPTXFD
        };

        // In device mode, this register is not valid. This read-only register contains the free space information for the non-periodic Tx FIFO and the non-periodic transmit request queue.
        struct OTG_HNPTXSTS : public RegisterReadOnly<0x4900002c> {
            using NPTXFSAV = Field<0, 16>;    // NPTXFSAV
            using NPTQXSAV = Field<16, 8>;    // NPTQXSAV
            using NPTXQTOP = Field<24, 7>;    // NPTXQTOP
        };

        // OTG general core configuration register
        struct OTG_GCCFG : public Register<0x49000038> {
            using PDET = Field<1, 1>;    // PDET
            using SDET = Field<2, 1>;    // SDET
            using PS2DET = Field<3, 1>;    // PS2DET
            using PWRDWN = Field<16, 1>;    // PWRDWN
            using BCDEN = Field<17, 1>;    // BCDEN
            using PDEN = Field<19, 1>;    // PDEN
            using SDEN = Field<20, 1>;    // SDEN
            using VBDEN = Field<21, 1>;    // VBDEN
            using IDEN = Field<22, 1>;    // IDEN
        };

        // This is a register containing the Product ID as reset value.
        struct OTG_CID : public Register<0x4900003c> {
            using PRODUCT_ID = Field<0, 32>;    // PRODUCT_ID
        };

        // OTG core LPM configuration register
        struct OTG_GLPMCFG : public Register<0x49000054> {
            using LPMEN = Field<0, 1>;    // LPMEN
            using LPMACK = Field<1, 1>;    // LPMACK
            using BESL = Field<2, 4>;    // BESL
            using REMWAKE = Field<6, 1>;    // REMWAKE
            using L1SSEN = Field<7, 1>;    // L1SSEN
            using BESLTHRS = Field<8, 4>;    // BESLTHRS
            using L1DSEN = Field<12, 1>;    // L1DSEN
            using LPMRSP = Field<13, 2>;    // LPMRSP
            using SLPSTS = Field<15, 1>;    // SLPSTS
            using L1RSMOK = Field<16, 1>;    // L1RSMOK
            using LPMCHIDX = Field<17, 4>;    // LPMCHIDX
            using LPMRCNT = Field<21, 3>;    // LPMRCNT
            using SNDLPM = Field<24, 1>;    // SNDLPM
            using LPMRCNTSTS = Field<25, 3>;    // LPMRCNTSTS
            using ENBESL = Field<28, 1>;    // ENBESL
        };

        // OTG host periodic transmit FIFO size register
        struct OTG_HPTXFSIZ : public Register<0x49000100> {
            using PTXSA = Field<0, 16>;    // PTXSA
            using PTXFSIZ = Field<16, 16>;    // PTXFSIZ
        };

        // OTG device IN endpoint transmit FIFO 1 size register
        struct OTG_DIEPTXF1 : public Register<0x49000104> {
            using INEPTXSA = Field<0, 16>;    // INEPTXSA
            using INEPTXFD = Field<16, 16>;    // INEPTXFD
        };

        // OTG device IN endpoint transmit FIFO 2 size register
        struct OTG_DIEPTXF2 : public Register<0x49000108> {
            using INEPTXSA = Field<0, 16>;    // INEPTXSA
            using INEPTXFD = Field<16, 16>;    // INEPTXFD
        };

        // OTG device IN endpoint transmit FIFO 3 size register
        struct OTG_DIEPTXF3 : public Register<0x4900010c> {
            using INEPTXSA = Field<0, 16>;    // INEPTXSA
            using INEPTXFD = Field<16, 16>;    // INEPTXFD
        };

        // OTG device IN endpoint transmit FIFO 4 size register
        struct OTG_DIEPTXF4 : public Register<0x49000110> {
            using INEPTXSA = Field<0, 16>;    // INEPTXSA
            using INEPTXFD = Field<16, 16>;    // INEPTXFD
        };

        // OTG device IN endpoint transmit FIFO 5 size register
        struct OTG_DIEPTXF5 : public Register<0x49000114> {
            using INEPTXSA = Field<0, 16>;    // INEPTXSA
            using INEPTXFD = Field<16, 16>;    // INEPTXFD
        };

        // OTG device IN endpoint transmit FIFO 6 size register
        struct OTG_DIEPTXF6 : public Register<0x49000118> {
            using INEPTXSA = Field<0, 16>;    // INEPTXSA
            using INEPTXFD = Field<16, 16>;    // INEPTXFD
        };

        // OTG device IN endpoint transmit FIFO 7 size register
        struct OTG_DIEPTXF7 : public Register<0x4900011c> {
            using INEPTXSA = Field<0, 16>;    // INEPTXSA
            using INEPTXFD = Field<16, 16>;    // INEPTXFD
        };

        // OTG device IN endpoint transmit FIFO 8 size register
        struct OTG_DIEPTXF8 : public Register<0x49000120> {
            using INEPTXSA = Field<0, 16>;    // INEPTXSA
            using INEPTXFD = Field<16, 16>;    // INEPTXFD
        };

        // This register configures the core after power-on. Do not make changes to this register after initializing the host.
        struct OTG_HCFG : public Register<0x49000400> {
            using FSLSPCS = Field<0, 2>;    // FSLSPCS
            using FSLSS = Field<2, 1>;    // FSLSS
            using DESCDMA = Field<23, 1>;    // DESCDMA
            using FRLSTEN = Field<24, 2>;    // FRLSTEN
            using PERSSCHEDENA = Field<26, 1>;    // PERSSCHEDENA
        };

        // This register stores the frame interval information for the current speed to which the OTG controller has enumerated.
        struct OTG_HFIR : public Register<0x49000404> {
            using FRIVL = Field<0, 16>;    // FRIVL
            using RLDCTRL = Field<16, 1>;    // RLDCTRL
        };

        // This register indicates the current frame number. It also indicates the time remaining (in terms of the number of PHY clocks) in the current frame.
        struct OTG_HFNUM : public RegisterReadOnly<0x49000408> {
            using FRNUM = Field<0, 16>;    // FRNUM
            using FTREM = Field<16, 16>;    // FTREM
        };

        // This read-only register contains the free space information for the periodic Tx FIFO and the periodic transmit request queue.
        struct OTG_HPTXSTS : public RegisterReadOnly<0x49000410> {
            using PTXFSAVL = Field<0, 16>;    // PTXFSAVL
            using PTXQSAV = Field<16, 8>;    // PTXQSAV
            using PTXQTOP = Field<24, 8>;    // PTXQTOP
        };

        // When a significant event occurs on a channel, the host all channels interrupt register interrupts the application using the host channels interrupt bit of the core interrupt register (HCINT bit in OTG_GINTSTS). This is shown in Figure724. There is one interrupt bit per channel, up to a maximum of 16 bits. Bits in this register are set and cleared when the application sets and clears bits in the corresponding host channel-x interrupt register.
        struct OTG_HAINT : public RegisterReadOnly<0x49000414> {
            using HAINT = Field<0, 16>;    // HAINT
        };

        // The host all channel interrupt mask register works with the host all channel interrupt register to interrupt the application when an event occurs on a channel. There is one interrupt mask bit per channel, up to a maximum of 16 bits.
        struct OTG_HAINTMSK : public Register<0x49000418> {
            using HAINTM = Field<0, 16>;    // HAINTM
        };

        // This register holds the starting address of the frame list information (scatter/gather mode).
        struct OTG_HFLBADDR : public Register<0x4900041c> {
            using HFLBADDR = Field<0, 32>;    // HFLBADDR
        };

        // This register is available only in host mode. Currently, the OTG host supports only one port. A single register holds USB port-related information such as USB reset, enable, suspend, resume, connect status, and test mode for each port. It is shown in Figure724. The rc_w1 bits in this register can trigger an interrupt to the application through the host port interrupt bit of the core interrupt register (HPRTINT bit in OTG_GINTSTS). On a port interrupt, the application must read this register and clear the bit that caused the interrupt. For the rc_w1 bits, the application must write a 1 to the bit to clear the interrupt.
        struct OTG_HPRT : public Register<0x49000440> {
            using PCSTS = Field<0, 1>;    // PCSTS
            using PCDET = Field<1, 1>;    // PCDET
            using PENA = Field<2, 1>;    // PENA
            using PENCHNG = Field<3, 1>;    // PENCHNG
            using POCA = Field<4, 1>;    // POCA
            using POCCHNG = Field<5, 1>;    // POCCHNG
            using PRES = Field<6, 1>;    // PRES
            using PSUSP = Field<7, 1>;    // PSUSP
            using PRST = Field<8, 1>;    // PRST
            using PLSTS = Field<10, 2>;    // PLSTS
            using PPWR = Field<12, 1>;    // PPWR
            using PTCTL = Field<13, 4>;    // PTCTL
            using PSPD = Field<17, 2>;    // PSPD
        };

        // OTG host channel 0 characteristics register
        struct OTG_HCCHAR0 : public Register<0x49000500> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using EPNUM = Field<11, 4>;    // EPNUM
            using EPDIR = Field<15, 1>;    // EPDIR
            using LSDEV = Field<17, 1>;    // LSDEV
            using EPTYP = Field<18, 2>;    // EPTYP
            using MCNT = Field<20, 2>;    // MCNT
            using DAD = Field<22, 7>;    // DAD
            using CHDIS = Field<30, 1>;    // CHDIS
            using CHENA = Field<31, 1>;    // CHENA
        };

        // OTG host channel 0 split control register
        struct OTG_HCSPLT0 : public Register<0x49000504> {
            using PRTADDR = Field<0, 7>;    // PRTADDR
            using HUBADDR = Field<7, 7>;    // HUBADDR
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // COMPLSPLT
            using SPLITEN = Field<31, 1>;    // SPLITEN
        };

        // This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
        struct OTG_HCINT0 : public Register<0x49000508> {
            using XFRC = Field<0, 1>;    // XFRC
            using CHH = Field<1, 1>;    // CHH
            using AHBERR = Field<2, 1>;    // AHBERR
            using STALL = Field<3, 1>;    // STALL
            using NAK = Field<4, 1>;    // NAK
            using ACK = Field<5, 1>;    // ACK
            using NYET = Field<6, 1>;    // NYET
            using TXERR = Field<7, 1>;    // TXERR
            using BBERR = Field<8, 1>;    // BBERR
            using FRMOR = Field<9, 1>;    // FRMOR
            using DTERR = Field<10, 1>;    // DTERR
            using BNA = Field<11, 1>;    // BNA
            using XCSXACTERR = Field<12, 1>;    // XCSXACTERR
            using DESCLSTROLL = Field<13, 1>;    // DESCLSTROLL
        };

        // This register reflects the mask for each channel status described in the previous section.
        struct OTG_HCINTMSK0 : public Register<0x4900050c> {
            using XFRCM = Field<0, 1>;    // XFRCM
            using CHHM = Field<1, 1>;    // CHHM
            using AHBERRM = Field<2, 1>;    // AHBERRM
            using STALLM = Field<3, 1>;    // STALLM
            using NAKM = Field<4, 1>;    // NAKM
            using ACKM = Field<5, 1>;    // ACKM
            using NYET = Field<6, 1>;    // NYET
            using TXERRM = Field<7, 1>;    // TXERRM
            using BBERRM = Field<8, 1>;    // BBERRM
            using FRMORM = Field<9, 1>;    // FRMORM
            using DTERRM = Field<10, 1>;    // DTERRM
            using BNAMSK = Field<11, 1>;    // BNAMSK
            using DESCLSTROLLMSK = Field<13, 1>;    // DESCLSTROLLMSK
        };

        // OTG host channel 0 transfer size register
        struct OTG_HCTSIZ0 : public Register<0x49000510> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using DPID = Field<29, 2>;    // DPID
        };

        // OTG host channel 0 DMA address register in buffer DMA [alternate]
        struct OTG_HCDMA0 : public Register<0x49000514> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // OTG host channel-n DMA address buffer register
        struct OTG_HCDMAB0 : public RegisterReadOnly<0x4900051c> {
            using HCDMAB = Field<0, 32>;    // HCDMAB
        };

        // OTG host channel 1 characteristics register
        struct OTG_HCCHAR1 : public Register<0x49000520> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using EPNUM = Field<11, 4>;    // EPNUM
            using EPDIR = Field<15, 1>;    // EPDIR
            using LSDEV = Field<17, 1>;    // LSDEV
            using EPTYP = Field<18, 2>;    // EPTYP
            using MCNT = Field<20, 2>;    // MCNT
            using DAD = Field<22, 7>;    // DAD
            using CHDIS = Field<30, 1>;    // CHDIS
            using CHENA = Field<31, 1>;    // CHENA
        };

        // OTG host channel 1 split control register
        struct OTG_HCSPLT1 : public Register<0x49000524> {
            using PRTADDR = Field<0, 7>;    // PRTADDR
            using HUBADDR = Field<7, 7>;    // HUBADDR
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // COMPLSPLT
            using SPLITEN = Field<31, 1>;    // SPLITEN
        };

        // This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
        struct OTG_HCINT1 : public Register<0x49000528> {
            using XFRC = Field<0, 1>;    // XFRC
            using CHH = Field<1, 1>;    // CHH
            using AHBERR = Field<2, 1>;    // AHBERR
            using STALL = Field<3, 1>;    // STALL
            using NAK = Field<4, 1>;    // NAK
            using ACK = Field<5, 1>;    // ACK
            using NYET = Field<6, 1>;    // NYET
            using TXERR = Field<7, 1>;    // TXERR
            using BBERR = Field<8, 1>;    // BBERR
            using FRMOR = Field<9, 1>;    // FRMOR
            using DTERR = Field<10, 1>;    // DTERR
            using BNA = Field<11, 1>;    // BNA
            using XCSXACTERR = Field<12, 1>;    // XCSXACTERR
            using DESCLSTROLL = Field<13, 1>;    // DESCLSTROLL
        };

        // This register reflects the mask for each channel status described in the previous section.
        struct OTG_HCINTMSK1 : public Register<0x4900052c> {
            using XFRCM = Field<0, 1>;    // XFRCM
            using CHHM = Field<1, 1>;    // CHHM
            using AHBERRM = Field<2, 1>;    // AHBERRM
            using STALLM = Field<3, 1>;    // STALLM
            using NAKM = Field<4, 1>;    // NAKM
            using ACKM = Field<5, 1>;    // ACKM
            using NYET = Field<6, 1>;    // NYET
            using TXERRM = Field<7, 1>;    // TXERRM
            using BBERRM = Field<8, 1>;    // BBERRM
            using FRMORM = Field<9, 1>;    // FRMORM
            using DTERRM = Field<10, 1>;    // DTERRM
            using BNAMSK = Field<11, 1>;    // BNAMSK
            using DESCLSTROLLMSK = Field<13, 1>;    // DESCLSTROLLMSK
        };

        // OTG host channel 1 transfer size register
        struct OTG_HCTSIZ1 : public Register<0x49000530> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using DPID = Field<29, 2>;    // DPID
        };

        // OTG host channel 1 DMA address register in buffer DMA [alternate]
        struct OTG_HCDMA1 : public Register<0x49000534> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // OTG host channel-n DMA address buffer register
        struct OTG_HCDMAB1 : public RegisterReadOnly<0x4900053c> {
            using HCDMAB = Field<0, 32>;    // HCDMAB
        };

        // OTG host channel 2 characteristics register
        struct OTG_HCCHAR2 : public Register<0x49000540> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using EPNUM = Field<11, 4>;    // EPNUM
            using EPDIR = Field<15, 1>;    // EPDIR
            using LSDEV = Field<17, 1>;    // LSDEV
            using EPTYP = Field<18, 2>;    // EPTYP
            using MCNT = Field<20, 2>;    // MCNT
            using DAD = Field<22, 7>;    // DAD
            using CHDIS = Field<30, 1>;    // CHDIS
            using CHENA = Field<31, 1>;    // CHENA
        };

        // OTG host channel 2 split control register
        struct OTG_HCSPLT2 : public Register<0x49000544> {
            using PRTADDR = Field<0, 7>;    // PRTADDR
            using HUBADDR = Field<7, 7>;    // HUBADDR
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // COMPLSPLT
            using SPLITEN = Field<31, 1>;    // SPLITEN
        };

        // This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
        struct OTG_HCINT2 : public Register<0x49000548> {
            using XFRC = Field<0, 1>;    // XFRC
            using CHH = Field<1, 1>;    // CHH
            using AHBERR = Field<2, 1>;    // AHBERR
            using STALL = Field<3, 1>;    // STALL
            using NAK = Field<4, 1>;    // NAK
            using ACK = Field<5, 1>;    // ACK
            using NYET = Field<6, 1>;    // NYET
            using TXERR = Field<7, 1>;    // TXERR
            using BBERR = Field<8, 1>;    // BBERR
            using FRMOR = Field<9, 1>;    // FRMOR
            using DTERR = Field<10, 1>;    // DTERR
            using BNA = Field<11, 1>;    // BNA
            using XCSXACTERR = Field<12, 1>;    // XCSXACTERR
            using DESCLSTROLL = Field<13, 1>;    // DESCLSTROLL
        };

        // This register reflects the mask for each channel status described in the previous section.
        struct OTG_HCINTMSK2 : public Register<0x4900054c> {
            using XFRCM = Field<0, 1>;    // XFRCM
            using CHHM = Field<1, 1>;    // CHHM
            using AHBERRM = Field<2, 1>;    // AHBERRM
            using STALLM = Field<3, 1>;    // STALLM
            using NAKM = Field<4, 1>;    // NAKM
            using ACKM = Field<5, 1>;    // ACKM
            using NYET = Field<6, 1>;    // NYET
            using TXERRM = Field<7, 1>;    // TXERRM
            using BBERRM = Field<8, 1>;    // BBERRM
            using FRMORM = Field<9, 1>;    // FRMORM
            using DTERRM = Field<10, 1>;    // DTERRM
            using BNAMSK = Field<11, 1>;    // BNAMSK
            using DESCLSTROLLMSK = Field<13, 1>;    // DESCLSTROLLMSK
        };

        // OTG host channel 2 transfer size register
        struct OTG_HCTSIZ2 : public Register<0x49000550> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using DPID = Field<29, 2>;    // DPID
        };

        // OTG host channel 2 DMA address register in buffer DMA [alternate]
        struct OTG_HCDMA2 : public Register<0x49000554> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // OTG host channel-n DMA address buffer register
        struct OTG_HCDMAB2 : public RegisterReadOnly<0x4900055c> {
            using HCDMAB = Field<0, 32>;    // HCDMAB
        };

        // OTG host channel 3 characteristics register
        struct OTG_HCCHAR3 : public Register<0x49000560> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using EPNUM = Field<11, 4>;    // EPNUM
            using EPDIR = Field<15, 1>;    // EPDIR
            using LSDEV = Field<17, 1>;    // LSDEV
            using EPTYP = Field<18, 2>;    // EPTYP
            using MCNT = Field<20, 2>;    // MCNT
            using DAD = Field<22, 7>;    // DAD
            using CHDIS = Field<30, 1>;    // CHDIS
            using CHENA = Field<31, 1>;    // CHENA
        };

        // OTG host channel 3 split control register
        struct OTG_HCSPLT3 : public Register<0x49000564> {
            using PRTADDR = Field<0, 7>;    // PRTADDR
            using HUBADDR = Field<7, 7>;    // HUBADDR
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // COMPLSPLT
            using SPLITEN = Field<31, 1>;    // SPLITEN
        };

        // This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
        struct OTG_HCINT3 : public Register<0x49000568> {
            using XFRC = Field<0, 1>;    // XFRC
            using CHH = Field<1, 1>;    // CHH
            using AHBERR = Field<2, 1>;    // AHBERR
            using STALL = Field<3, 1>;    // STALL
            using NAK = Field<4, 1>;    // NAK
            using ACK = Field<5, 1>;    // ACK
            using NYET = Field<6, 1>;    // NYET
            using TXERR = Field<7, 1>;    // TXERR
            using BBERR = Field<8, 1>;    // BBERR
            using FRMOR = Field<9, 1>;    // FRMOR
            using DTERR = Field<10, 1>;    // DTERR
            using BNA = Field<11, 1>;    // BNA
            using XCSXACTERR = Field<12, 1>;    // XCSXACTERR
            using DESCLSTROLL = Field<13, 1>;    // DESCLSTROLL
        };

        // This register reflects the mask for each channel status described in the previous section.
        struct OTG_HCINTMSK3 : public Register<0x4900056c> {
            using XFRCM = Field<0, 1>;    // XFRCM
            using CHHM = Field<1, 1>;    // CHHM
            using AHBERRM = Field<2, 1>;    // AHBERRM
            using STALLM = Field<3, 1>;    // STALLM
            using NAKM = Field<4, 1>;    // NAKM
            using ACKM = Field<5, 1>;    // ACKM
            using NYET = Field<6, 1>;    // NYET
            using TXERRM = Field<7, 1>;    // TXERRM
            using BBERRM = Field<8, 1>;    // BBERRM
            using FRMORM = Field<9, 1>;    // FRMORM
            using DTERRM = Field<10, 1>;    // DTERRM
            using BNAMSK = Field<11, 1>;    // BNAMSK
            using DESCLSTROLLMSK = Field<13, 1>;    // DESCLSTROLLMSK
        };

        // OTG host channel 3 transfer size register
        struct OTG_HCTSIZ3 : public Register<0x49000570> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using DPID = Field<29, 2>;    // DPID
        };

        // OTG host channel 3 DMA address register in buffer DMA [alternate]
        struct OTG_HCDMA3 : public Register<0x49000574> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // OTG host channel-n DMA address buffer register
        struct OTG_HCDMAB3 : public RegisterReadOnly<0x4900057c> {
            using HCDMAB = Field<0, 32>;    // HCDMAB
        };

        // OTG host channel 4 characteristics register
        struct OTG_HCCHAR4 : public Register<0x49000580> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using EPNUM = Field<11, 4>;    // EPNUM
            using EPDIR = Field<15, 1>;    // EPDIR
            using LSDEV = Field<17, 1>;    // LSDEV
            using EPTYP = Field<18, 2>;    // EPTYP
            using MCNT = Field<20, 2>;    // MCNT
            using DAD = Field<22, 7>;    // DAD
            using CHDIS = Field<30, 1>;    // CHDIS
            using CHENA = Field<31, 1>;    // CHENA
        };

        // OTG host channel 4 split control register
        struct OTG_HCSPLT4 : public Register<0x49000584> {
            using PRTADDR = Field<0, 7>;    // PRTADDR
            using HUBADDR = Field<7, 7>;    // HUBADDR
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // COMPLSPLT
            using SPLITEN = Field<31, 1>;    // SPLITEN
        };

        // This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
        struct OTG_HCINT4 : public Register<0x49000588> {
            using XFRC = Field<0, 1>;    // XFRC
            using CHH = Field<1, 1>;    // CHH
            using AHBERR = Field<2, 1>;    // AHBERR
            using STALL = Field<3, 1>;    // STALL
            using NAK = Field<4, 1>;    // NAK
            using ACK = Field<5, 1>;    // ACK
            using NYET = Field<6, 1>;    // NYET
            using TXERR = Field<7, 1>;    // TXERR
            using BBERR = Field<8, 1>;    // BBERR
            using FRMOR = Field<9, 1>;    // FRMOR
            using DTERR = Field<10, 1>;    // DTERR
            using BNA = Field<11, 1>;    // BNA
            using XCSXACTERR = Field<12, 1>;    // XCSXACTERR
            using DESCLSTROLL = Field<13, 1>;    // DESCLSTROLL
        };

        // This register reflects the mask for each channel status described in the previous section.
        struct OTG_HCINTMSK4 : public Register<0x4900058c> {
            using XFRCM = Field<0, 1>;    // XFRCM
            using CHHM = Field<1, 1>;    // CHHM
            using AHBERRM = Field<2, 1>;    // AHBERRM
            using STALLM = Field<3, 1>;    // STALLM
            using NAKM = Field<4, 1>;    // NAKM
            using ACKM = Field<5, 1>;    // ACKM
            using NYET = Field<6, 1>;    // NYET
            using TXERRM = Field<7, 1>;    // TXERRM
            using BBERRM = Field<8, 1>;    // BBERRM
            using FRMORM = Field<9, 1>;    // FRMORM
            using DTERRM = Field<10, 1>;    // DTERRM
            using BNAMSK = Field<11, 1>;    // BNAMSK
            using DESCLSTROLLMSK = Field<13, 1>;    // DESCLSTROLLMSK
        };

        // OTG host channel 4 transfer size register
        struct OTG_HCTSIZ4 : public Register<0x49000590> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using DPID = Field<29, 2>;    // DPID
        };

        // OTG host channel 4 DMA address register in buffer DMA [alternate]
        struct OTG_HCDMA4 : public Register<0x49000594> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // OTG host channel-n DMA address buffer register
        struct OTG_HCDMAB4 : public RegisterReadOnly<0x4900059c> {
            using HCDMAB = Field<0, 32>;    // HCDMAB
        };

        // OTG host channel 5 characteristics register
        struct OTG_HCCHAR5 : public Register<0x490005a0> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using EPNUM = Field<11, 4>;    // EPNUM
            using EPDIR = Field<15, 1>;    // EPDIR
            using LSDEV = Field<17, 1>;    // LSDEV
            using EPTYP = Field<18, 2>;    // EPTYP
            using MCNT = Field<20, 2>;    // MCNT
            using DAD = Field<22, 7>;    // DAD
            using CHDIS = Field<30, 1>;    // CHDIS
            using CHENA = Field<31, 1>;    // CHENA
        };

        // OTG host channel 5 split control register
        struct OTG_HCSPLT5 : public Register<0x490005a4> {
            using PRTADDR = Field<0, 7>;    // PRTADDR
            using HUBADDR = Field<7, 7>;    // HUBADDR
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // COMPLSPLT
            using SPLITEN = Field<31, 1>;    // SPLITEN
        };

        // This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
        struct OTG_HCINT5 : public Register<0x490005a8> {
            using XFRC = Field<0, 1>;    // XFRC
            using CHH = Field<1, 1>;    // CHH
            using AHBERR = Field<2, 1>;    // AHBERR
            using STALL = Field<3, 1>;    // STALL
            using NAK = Field<4, 1>;    // NAK
            using ACK = Field<5, 1>;    // ACK
            using NYET = Field<6, 1>;    // NYET
            using TXERR = Field<7, 1>;    // TXERR
            using BBERR = Field<8, 1>;    // BBERR
            using FRMOR = Field<9, 1>;    // FRMOR
            using DTERR = Field<10, 1>;    // DTERR
            using BNA = Field<11, 1>;    // BNA
            using XCSXACTERR = Field<12, 1>;    // XCSXACTERR
            using DESCLSTROLL = Field<13, 1>;    // DESCLSTROLL
        };

        // This register reflects the mask for each channel status described in the previous section.
        struct OTG_HCINTMSK5 : public Register<0x490005ac> {
            using XFRCM = Field<0, 1>;    // XFRCM
            using CHHM = Field<1, 1>;    // CHHM
            using AHBERRM = Field<2, 1>;    // AHBERRM
            using STALLM = Field<3, 1>;    // STALLM
            using NAKM = Field<4, 1>;    // NAKM
            using ACKM = Field<5, 1>;    // ACKM
            using NYET = Field<6, 1>;    // NYET
            using TXERRM = Field<7, 1>;    // TXERRM
            using BBERRM = Field<8, 1>;    // BBERRM
            using FRMORM = Field<9, 1>;    // FRMORM
            using DTERRM = Field<10, 1>;    // DTERRM
            using BNAMSK = Field<11, 1>;    // BNAMSK
            using DESCLSTROLLMSK = Field<13, 1>;    // DESCLSTROLLMSK
        };

        // OTG host channel 5 transfer size register
        struct OTG_HCTSIZ5 : public Register<0x490005b0> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using DPID = Field<29, 2>;    // DPID
        };

        // OTG host channel 5 DMA address register in buffer DMA [alternate]
        struct OTG_HCDMA5 : public Register<0x490005b4> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // OTG host channel-n DMA address buffer register
        struct OTG_HCDMAB5 : public RegisterReadOnly<0x490005bc> {
            using HCDMAB = Field<0, 32>;    // HCDMAB
        };

        // OTG host channel 6 characteristics register
        struct OTG_HCCHAR6 : public Register<0x490005c0> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using EPNUM = Field<11, 4>;    // EPNUM
            using EPDIR = Field<15, 1>;    // EPDIR
            using LSDEV = Field<17, 1>;    // LSDEV
            using EPTYP = Field<18, 2>;    // EPTYP
            using MCNT = Field<20, 2>;    // MCNT
            using DAD = Field<22, 7>;    // DAD
            using CHDIS = Field<30, 1>;    // CHDIS
            using CHENA = Field<31, 1>;    // CHENA
        };

        // OTG host channel 6 split control register
        struct OTG_HCSPLT6 : public Register<0x490005c4> {
            using PRTADDR = Field<0, 7>;    // PRTADDR
            using HUBADDR = Field<7, 7>;    // HUBADDR
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // COMPLSPLT
            using SPLITEN = Field<31, 1>;    // SPLITEN
        };

        // This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
        struct OTG_HCINT6 : public Register<0x490005c8> {
            using XFRC = Field<0, 1>;    // XFRC
            using CHH = Field<1, 1>;    // CHH
            using AHBERR = Field<2, 1>;    // AHBERR
            using STALL = Field<3, 1>;    // STALL
            using NAK = Field<4, 1>;    // NAK
            using ACK = Field<5, 1>;    // ACK
            using NYET = Field<6, 1>;    // NYET
            using TXERR = Field<7, 1>;    // TXERR
            using BBERR = Field<8, 1>;    // BBERR
            using FRMOR = Field<9, 1>;    // FRMOR
            using DTERR = Field<10, 1>;    // DTERR
            using BNA = Field<11, 1>;    // BNA
            using XCSXACTERR = Field<12, 1>;    // XCSXACTERR
            using DESCLSTROLL = Field<13, 1>;    // DESCLSTROLL
        };

        // This register reflects the mask for each channel status described in the previous section.
        struct OTG_HCINTMSK6 : public Register<0x490005cc> {
            using XFRCM = Field<0, 1>;    // XFRCM
            using CHHM = Field<1, 1>;    // CHHM
            using AHBERRM = Field<2, 1>;    // AHBERRM
            using STALLM = Field<3, 1>;    // STALLM
            using NAKM = Field<4, 1>;    // NAKM
            using ACKM = Field<5, 1>;    // ACKM
            using NYET = Field<6, 1>;    // NYET
            using TXERRM = Field<7, 1>;    // TXERRM
            using BBERRM = Field<8, 1>;    // BBERRM
            using FRMORM = Field<9, 1>;    // FRMORM
            using DTERRM = Field<10, 1>;    // DTERRM
            using BNAMSK = Field<11, 1>;    // BNAMSK
            using DESCLSTROLLMSK = Field<13, 1>;    // DESCLSTROLLMSK
        };

        // OTG host channel 6 transfer size register
        struct OTG_HCTSIZ6 : public Register<0x490005d0> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using DPID = Field<29, 2>;    // DPID
        };

        // OTG host channel 6 DMA address register in buffer DMA [alternate]
        struct OTG_HCDMA6 : public Register<0x490005d4> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // OTG host channel-n DMA address buffer register
        struct OTG_HCDMAB6 : public RegisterReadOnly<0x490005dc> {
            using HCDMAB = Field<0, 32>;    // HCDMAB
        };

        // OTG host channel 7 characteristics register
        struct OTG_HCCHAR7 : public Register<0x490005e0> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using EPNUM = Field<11, 4>;    // EPNUM
            using EPDIR = Field<15, 1>;    // EPDIR
            using LSDEV = Field<17, 1>;    // LSDEV
            using EPTYP = Field<18, 2>;    // EPTYP
            using MCNT = Field<20, 2>;    // MCNT
            using DAD = Field<22, 7>;    // DAD
            using CHDIS = Field<30, 1>;    // CHDIS
            using CHENA = Field<31, 1>;    // CHENA
        };

        // OTG host channel 7 split control register
        struct OTG_HCSPLT7 : public Register<0x490005e4> {
            using PRTADDR = Field<0, 7>;    // PRTADDR
            using HUBADDR = Field<7, 7>;    // HUBADDR
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // COMPLSPLT
            using SPLITEN = Field<31, 1>;    // SPLITEN
        };

        // This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
        struct OTG_HCINT7 : public Register<0x490005e8> {
            using XFRC = Field<0, 1>;    // XFRC
            using CHH = Field<1, 1>;    // CHH
            using AHBERR = Field<2, 1>;    // AHBERR
            using STALL = Field<3, 1>;    // STALL
            using NAK = Field<4, 1>;    // NAK
            using ACK = Field<5, 1>;    // ACK
            using NYET = Field<6, 1>;    // NYET
            using TXERR = Field<7, 1>;    // TXERR
            using BBERR = Field<8, 1>;    // BBERR
            using FRMOR = Field<9, 1>;    // FRMOR
            using DTERR = Field<10, 1>;    // DTERR
            using BNA = Field<11, 1>;    // BNA
            using XCSXACTERR = Field<12, 1>;    // XCSXACTERR
            using DESCLSTROLL = Field<13, 1>;    // DESCLSTROLL
        };

        // This register reflects the mask for each channel status described in the previous section.
        struct OTG_HCINTMSK7 : public Register<0x490005ec> {
            using XFRCM = Field<0, 1>;    // XFRCM
            using CHHM = Field<1, 1>;    // CHHM
            using AHBERRM = Field<2, 1>;    // AHBERRM
            using STALLM = Field<3, 1>;    // STALLM
            using NAKM = Field<4, 1>;    // NAKM
            using ACKM = Field<5, 1>;    // ACKM
            using NYET = Field<6, 1>;    // NYET
            using TXERRM = Field<7, 1>;    // TXERRM
            using BBERRM = Field<8, 1>;    // BBERRM
            using FRMORM = Field<9, 1>;    // FRMORM
            using DTERRM = Field<10, 1>;    // DTERRM
            using BNAMSK = Field<11, 1>;    // BNAMSK
            using DESCLSTROLLMSK = Field<13, 1>;    // DESCLSTROLLMSK
        };

        // OTG host channel 7 transfer size register
        struct OTG_HCTSIZ7 : public Register<0x490005f0> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using DPID = Field<29, 2>;    // DPID
        };

        // OTG host channel 7 DMA address register in buffer DMA [alternate]
        struct OTG_HCDMA7 : public Register<0x490005f4> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // OTG host channel-n DMA address buffer register
        struct OTG_HCDMAB7 : public RegisterReadOnly<0x490005fc> {
            using HCDMAB = Field<0, 32>;    // HCDMAB
        };

        // OTG host channel 8 characteristics register
        struct OTG_HCCHAR8 : public Register<0x49000600> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using EPNUM = Field<11, 4>;    // EPNUM
            using EPDIR = Field<15, 1>;    // EPDIR
            using LSDEV = Field<17, 1>;    // LSDEV
            using EPTYP = Field<18, 2>;    // EPTYP
            using MCNT = Field<20, 2>;    // MCNT
            using DAD = Field<22, 7>;    // DAD
            using CHDIS = Field<30, 1>;    // CHDIS
            using CHENA = Field<31, 1>;    // CHENA
        };

        // OTG host channel 8 split control register
        struct OTG_HCSPLT8 : public Register<0x49000604> {
            using PRTADDR = Field<0, 7>;    // PRTADDR
            using HUBADDR = Field<7, 7>;    // HUBADDR
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // COMPLSPLT
            using SPLITEN = Field<31, 1>;    // SPLITEN
        };

        // This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
        struct OTG_HCINT8 : public Register<0x49000608> {
            using XFRC = Field<0, 1>;    // XFRC
            using CHH = Field<1, 1>;    // CHH
            using AHBERR = Field<2, 1>;    // AHBERR
            using STALL = Field<3, 1>;    // STALL
            using NAK = Field<4, 1>;    // NAK
            using ACK = Field<5, 1>;    // ACK
            using NYET = Field<6, 1>;    // NYET
            using TXERR = Field<7, 1>;    // TXERR
            using BBERR = Field<8, 1>;    // BBERR
            using FRMOR = Field<9, 1>;    // FRMOR
            using DTERR = Field<10, 1>;    // DTERR
            using BNA = Field<11, 1>;    // BNA
            using XCSXACTERR = Field<12, 1>;    // XCSXACTERR
            using DESCLSTROLL = Field<13, 1>;    // DESCLSTROLL
        };

        // This register reflects the mask for each channel status described in the previous section.
        struct OTG_HCINTMSK8 : public Register<0x4900060c> {
            using XFRCM = Field<0, 1>;    // XFRCM
            using CHHM = Field<1, 1>;    // CHHM
            using AHBERRM = Field<2, 1>;    // AHBERRM
            using STALLM = Field<3, 1>;    // STALLM
            using NAKM = Field<4, 1>;    // NAKM
            using ACKM = Field<5, 1>;    // ACKM
            using NYET = Field<6, 1>;    // NYET
            using TXERRM = Field<7, 1>;    // TXERRM
            using BBERRM = Field<8, 1>;    // BBERRM
            using FRMORM = Field<9, 1>;    // FRMORM
            using DTERRM = Field<10, 1>;    // DTERRM
            using BNAMSK = Field<11, 1>;    // BNAMSK
            using DESCLSTROLLMSK = Field<13, 1>;    // DESCLSTROLLMSK
        };

        // OTG host channel 8 transfer size register
        struct OTG_HCTSIZ8 : public Register<0x49000610> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using DPID = Field<29, 2>;    // DPID
        };

        // OTG host channel 8 DMA address register in buffer DMA [alternate]
        struct OTG_HCDMA8 : public Register<0x49000614> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // OTG host channel-n DMA address buffer register
        struct OTG_HCDMAB8 : public RegisterReadOnly<0x4900061c> {
            using HCDMAB = Field<0, 32>;    // HCDMAB
        };

        // OTG host channel 9 characteristics register
        struct OTG_HCCHAR9 : public Register<0x49000620> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using EPNUM = Field<11, 4>;    // EPNUM
            using EPDIR = Field<15, 1>;    // EPDIR
            using LSDEV = Field<17, 1>;    // LSDEV
            using EPTYP = Field<18, 2>;    // EPTYP
            using MCNT = Field<20, 2>;    // MCNT
            using DAD = Field<22, 7>;    // DAD
            using CHDIS = Field<30, 1>;    // CHDIS
            using CHENA = Field<31, 1>;    // CHENA
        };

        // OTG host channel 9 split control register
        struct OTG_HCSPLT9 : public Register<0x49000624> {
            using PRTADDR = Field<0, 7>;    // PRTADDR
            using HUBADDR = Field<7, 7>;    // HUBADDR
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // COMPLSPLT
            using SPLITEN = Field<31, 1>;    // SPLITEN
        };

        // This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
        struct OTG_HCINT9 : public Register<0x49000628> {
            using XFRC = Field<0, 1>;    // XFRC
            using CHH = Field<1, 1>;    // CHH
            using AHBERR = Field<2, 1>;    // AHBERR
            using STALL = Field<3, 1>;    // STALL
            using NAK = Field<4, 1>;    // NAK
            using ACK = Field<5, 1>;    // ACK
            using NYET = Field<6, 1>;    // NYET
            using TXERR = Field<7, 1>;    // TXERR
            using BBERR = Field<8, 1>;    // BBERR
            using FRMOR = Field<9, 1>;    // FRMOR
            using DTERR = Field<10, 1>;    // DTERR
            using BNA = Field<11, 1>;    // BNA
            using XCSXACTERR = Field<12, 1>;    // XCSXACTERR
            using DESCLSTROLL = Field<13, 1>;    // DESCLSTROLL
        };

        // This register reflects the mask for each channel status described in the previous section.
        struct OTG_HCINTMSK9 : public Register<0x4900062c> {
            using XFRCM = Field<0, 1>;    // XFRCM
            using CHHM = Field<1, 1>;    // CHHM
            using AHBERRM = Field<2, 1>;    // AHBERRM
            using STALLM = Field<3, 1>;    // STALLM
            using NAKM = Field<4, 1>;    // NAKM
            using ACKM = Field<5, 1>;    // ACKM
            using NYET = Field<6, 1>;    // NYET
            using TXERRM = Field<7, 1>;    // TXERRM
            using BBERRM = Field<8, 1>;    // BBERRM
            using FRMORM = Field<9, 1>;    // FRMORM
            using DTERRM = Field<10, 1>;    // DTERRM
            using BNAMSK = Field<11, 1>;    // BNAMSK
            using DESCLSTROLLMSK = Field<13, 1>;    // DESCLSTROLLMSK
        };

        // OTG host channel 9 transfer size register
        struct OTG_HCTSIZ9 : public Register<0x49000630> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using DPID = Field<29, 2>;    // DPID
        };

        // OTG host channel 9 DMA address register in buffer DMA [alternate]
        struct OTG_HCDMA9 : public Register<0x49000634> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // OTG host channel-n DMA address buffer register
        struct OTG_HCDMAB9 : public RegisterReadOnly<0x4900063c> {
            using HCDMAB = Field<0, 32>;    // HCDMAB
        };

        // OTG host channel 10 characteristics register
        struct OTG_HCCHAR10 : public Register<0x49000640> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using EPNUM = Field<11, 4>;    // EPNUM
            using EPDIR = Field<15, 1>;    // EPDIR
            using LSDEV = Field<17, 1>;    // LSDEV
            using EPTYP = Field<18, 2>;    // EPTYP
            using MCNT = Field<20, 2>;    // MCNT
            using DAD = Field<22, 7>;    // DAD
            using CHDIS = Field<30, 1>;    // CHDIS
            using CHENA = Field<31, 1>;    // CHENA
        };

        // OTG host channel 10 split control register
        struct OTG_HCSPLT10 : public Register<0x49000644> {
            using PRTADDR = Field<0, 7>;    // PRTADDR
            using HUBADDR = Field<7, 7>;    // HUBADDR
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // COMPLSPLT
            using SPLITEN = Field<31, 1>;    // SPLITEN
        };

        // This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
        struct OTG_HCINT10 : public Register<0x49000648> {
            using XFRC = Field<0, 1>;    // XFRC
            using CHH = Field<1, 1>;    // CHH
            using AHBERR = Field<2, 1>;    // AHBERR
            using STALL = Field<3, 1>;    // STALL
            using NAK = Field<4, 1>;    // NAK
            using ACK = Field<5, 1>;    // ACK
            using NYET = Field<6, 1>;    // NYET
            using TXERR = Field<7, 1>;    // TXERR
            using BBERR = Field<8, 1>;    // BBERR
            using FRMOR = Field<9, 1>;    // FRMOR
            using DTERR = Field<10, 1>;    // DTERR
            using BNA = Field<11, 1>;    // BNA
            using XCSXACTERR = Field<12, 1>;    // XCSXACTERR
            using DESCLSTROLL = Field<13, 1>;    // DESCLSTROLL
        };

        // This register reflects the mask for each channel status described in the previous section.
        struct OTG_HCINTMSK10 : public Register<0x4900064c> {
            using XFRCM = Field<0, 1>;    // XFRCM
            using CHHM = Field<1, 1>;    // CHHM
            using AHBERRM = Field<2, 1>;    // AHBERRM
            using STALLM = Field<3, 1>;    // STALLM
            using NAKM = Field<4, 1>;    // NAKM
            using ACKM = Field<5, 1>;    // ACKM
            using NYET = Field<6, 1>;    // NYET
            using TXERRM = Field<7, 1>;    // TXERRM
            using BBERRM = Field<8, 1>;    // BBERRM
            using FRMORM = Field<9, 1>;    // FRMORM
            using DTERRM = Field<10, 1>;    // DTERRM
            using BNAMSK = Field<11, 1>;    // BNAMSK
            using DESCLSTROLLMSK = Field<13, 1>;    // DESCLSTROLLMSK
        };

        // OTG host channel 10 transfer size register
        struct OTG_HCTSIZ10 : public Register<0x49000650> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using DPID = Field<29, 2>;    // DPID
        };

        // OTG host channel 10 DMA address register in buffer DMA [alternate]
        struct OTG_HCDMA10 : public Register<0x49000654> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // OTG host channel-n DMA address buffer register
        struct OTG_HCDMAB10 : public RegisterReadOnly<0x4900065c> {
            using HCDMAB = Field<0, 32>;    // HCDMAB
        };

        // OTG host channel 11 characteristics register
        struct OTG_HCCHAR11 : public Register<0x49000660> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using EPNUM = Field<11, 4>;    // EPNUM
            using EPDIR = Field<15, 1>;    // EPDIR
            using LSDEV = Field<17, 1>;    // LSDEV
            using EPTYP = Field<18, 2>;    // EPTYP
            using MCNT = Field<20, 2>;    // MCNT
            using DAD = Field<22, 7>;    // DAD
            using CHDIS = Field<30, 1>;    // CHDIS
            using CHENA = Field<31, 1>;    // CHENA
        };

        // OTG host channel 11 split control register
        struct OTG_HCSPLT11 : public Register<0x49000664> {
            using PRTADDR = Field<0, 7>;    // PRTADDR
            using HUBADDR = Field<7, 7>;    // HUBADDR
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // COMPLSPLT
            using SPLITEN = Field<31, 1>;    // SPLITEN
        };

        // This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
        struct OTG_HCINT11 : public Register<0x49000668> {
            using XFRC = Field<0, 1>;    // XFRC
            using CHH = Field<1, 1>;    // CHH
            using AHBERR = Field<2, 1>;    // AHBERR
            using STALL = Field<3, 1>;    // STALL
            using NAK = Field<4, 1>;    // NAK
            using ACK = Field<5, 1>;    // ACK
            using NYET = Field<6, 1>;    // NYET
            using TXERR = Field<7, 1>;    // TXERR
            using BBERR = Field<8, 1>;    // BBERR
            using FRMOR = Field<9, 1>;    // FRMOR
            using DTERR = Field<10, 1>;    // DTERR
            using BNA = Field<11, 1>;    // BNA
            using XCSXACTERR = Field<12, 1>;    // XCSXACTERR
            using DESCLSTROLL = Field<13, 1>;    // DESCLSTROLL
        };

        // This register reflects the mask for each channel status described in the previous section.
        struct OTG_HCINTMSK11 : public Register<0x4900066c> {
            using XFRCM = Field<0, 1>;    // XFRCM
            using CHHM = Field<1, 1>;    // CHHM
            using AHBERRM = Field<2, 1>;    // AHBERRM
            using STALLM = Field<3, 1>;    // STALLM
            using NAKM = Field<4, 1>;    // NAKM
            using ACKM = Field<5, 1>;    // ACKM
            using NYET = Field<6, 1>;    // NYET
            using TXERRM = Field<7, 1>;    // TXERRM
            using BBERRM = Field<8, 1>;    // BBERRM
            using FRMORM = Field<9, 1>;    // FRMORM
            using DTERRM = Field<10, 1>;    // DTERRM
            using BNAMSK = Field<11, 1>;    // BNAMSK
            using DESCLSTROLLMSK = Field<13, 1>;    // DESCLSTROLLMSK
        };

        // OTG host channel 11 transfer size register
        struct OTG_HCTSIZ11 : public Register<0x49000670> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using DPID = Field<29, 2>;    // DPID
        };

        // OTG host channel 11 DMA address register in buffer DMA [alternate]
        struct OTG_HCDMA11 : public Register<0x49000674> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // OTG host channel-n DMA address buffer register
        struct OTG_HCDMAB11 : public RegisterReadOnly<0x4900067c> {
            using HCDMAB = Field<0, 32>;    // HCDMAB
        };

        // OTG host channel 12 characteristics register
        struct OTG_HCCHAR12 : public Register<0x49000680> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using EPNUM = Field<11, 4>;    // EPNUM
            using EPDIR = Field<15, 1>;    // EPDIR
            using LSDEV = Field<17, 1>;    // LSDEV
            using EPTYP = Field<18, 2>;    // EPTYP
            using MCNT = Field<20, 2>;    // MCNT
            using DAD = Field<22, 7>;    // DAD
            using CHDIS = Field<30, 1>;    // CHDIS
            using CHENA = Field<31, 1>;    // CHENA
        };

        // OTG host channel 12 split control register
        struct OTG_HCSPLT12 : public Register<0x49000684> {
            using PRTADDR = Field<0, 7>;    // PRTADDR
            using HUBADDR = Field<7, 7>;    // HUBADDR
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // COMPLSPLT
            using SPLITEN = Field<31, 1>;    // SPLITEN
        };

        // This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
        struct OTG_HCINT12 : public Register<0x49000688> {
            using XFRC = Field<0, 1>;    // XFRC
            using CHH = Field<1, 1>;    // CHH
            using AHBERR = Field<2, 1>;    // AHBERR
            using STALL = Field<3, 1>;    // STALL
            using NAK = Field<4, 1>;    // NAK
            using ACK = Field<5, 1>;    // ACK
            using NYET = Field<6, 1>;    // NYET
            using TXERR = Field<7, 1>;    // TXERR
            using BBERR = Field<8, 1>;    // BBERR
            using FRMOR = Field<9, 1>;    // FRMOR
            using DTERR = Field<10, 1>;    // DTERR
            using BNA = Field<11, 1>;    // BNA
            using XCSXACTERR = Field<12, 1>;    // XCSXACTERR
            using DESCLSTROLL = Field<13, 1>;    // DESCLSTROLL
        };

        // This register reflects the mask for each channel status described in the previous section.
        struct OTG_HCINTMSK12 : public Register<0x4900068c> {
            using XFRCM = Field<0, 1>;    // XFRCM
            using CHHM = Field<1, 1>;    // CHHM
            using AHBERRM = Field<2, 1>;    // AHBERRM
            using STALLM = Field<3, 1>;    // STALLM
            using NAKM = Field<4, 1>;    // NAKM
            using ACKM = Field<5, 1>;    // ACKM
            using NYET = Field<6, 1>;    // NYET
            using TXERRM = Field<7, 1>;    // TXERRM
            using BBERRM = Field<8, 1>;    // BBERRM
            using FRMORM = Field<9, 1>;    // FRMORM
            using DTERRM = Field<10, 1>;    // DTERRM
            using BNAMSK = Field<11, 1>;    // BNAMSK
            using DESCLSTROLLMSK = Field<13, 1>;    // DESCLSTROLLMSK
        };

        // OTG host channel 12 transfer size register
        struct OTG_HCTSIZ12 : public Register<0x49000690> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using DPID = Field<29, 2>;    // DPID
        };

        // OTG host channel 12 DMA address register in buffer DMA [alternate]
        struct OTG_HCDMA12 : public Register<0x49000694> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // OTG host channel-n DMA address buffer register
        struct OTG_HCDMAB12 : public RegisterReadOnly<0x4900069c> {
            using HCDMAB = Field<0, 32>;    // HCDMAB
        };

        // OTG host channel 13 characteristics register
        struct OTG_HCCHAR13 : public Register<0x490006a0> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using EPNUM = Field<11, 4>;    // EPNUM
            using EPDIR = Field<15, 1>;    // EPDIR
            using LSDEV = Field<17, 1>;    // LSDEV
            using EPTYP = Field<18, 2>;    // EPTYP
            using MCNT = Field<20, 2>;    // MCNT
            using DAD = Field<22, 7>;    // DAD
            using CHDIS = Field<30, 1>;    // CHDIS
            using CHENA = Field<31, 1>;    // CHENA
        };

        // OTG host channel 13 split control register
        struct OTG_HCSPLT13 : public Register<0x490006a4> {
            using PRTADDR = Field<0, 7>;    // PRTADDR
            using HUBADDR = Field<7, 7>;    // HUBADDR
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // COMPLSPLT
            using SPLITEN = Field<31, 1>;    // SPLITEN
        };

        // This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
        struct OTG_HCINT13 : public Register<0x490006a8> {
            using XFRC = Field<0, 1>;    // XFRC
            using CHH = Field<1, 1>;    // CHH
            using AHBERR = Field<2, 1>;    // AHBERR
            using STALL = Field<3, 1>;    // STALL
            using NAK = Field<4, 1>;    // NAK
            using ACK = Field<5, 1>;    // ACK
            using NYET = Field<6, 1>;    // NYET
            using TXERR = Field<7, 1>;    // TXERR
            using BBERR = Field<8, 1>;    // BBERR
            using FRMOR = Field<9, 1>;    // FRMOR
            using DTERR = Field<10, 1>;    // DTERR
            using BNA = Field<11, 1>;    // BNA
            using XCSXACTERR = Field<12, 1>;    // XCSXACTERR
            using DESCLSTROLL = Field<13, 1>;    // DESCLSTROLL
        };

        // This register reflects the mask for each channel status described in the previous section.
        struct OTG_HCINTMSK13 : public Register<0x490006ac> {
            using XFRCM = Field<0, 1>;    // XFRCM
            using CHHM = Field<1, 1>;    // CHHM
            using AHBERRM = Field<2, 1>;    // AHBERRM
            using STALLM = Field<3, 1>;    // STALLM
            using NAKM = Field<4, 1>;    // NAKM
            using ACKM = Field<5, 1>;    // ACKM
            using NYET = Field<6, 1>;    // NYET
            using TXERRM = Field<7, 1>;    // TXERRM
            using BBERRM = Field<8, 1>;    // BBERRM
            using FRMORM = Field<9, 1>;    // FRMORM
            using DTERRM = Field<10, 1>;    // DTERRM
            using BNAMSK = Field<11, 1>;    // BNAMSK
            using DESCLSTROLLMSK = Field<13, 1>;    // DESCLSTROLLMSK
        };

        // OTG host channel 13 transfer size register
        struct OTG_HCTSIZ13 : public Register<0x490006b0> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using DPID = Field<29, 2>;    // DPID
        };

        // OTG host channel 13 DMA address register in buffer DMA [alternate]
        struct OTG_HCDMA13 : public Register<0x490006b4> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // OTG host channel-n DMA address buffer register
        struct OTG_HCDMAB13 : public RegisterReadOnly<0x490006bc> {
            using HCDMAB = Field<0, 32>;    // HCDMAB
        };

        // OTG host channel 14 characteristics register
        struct OTG_HCCHAR14 : public Register<0x490006c0> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using EPNUM = Field<11, 4>;    // EPNUM
            using EPDIR = Field<15, 1>;    // EPDIR
            using LSDEV = Field<17, 1>;    // LSDEV
            using EPTYP = Field<18, 2>;    // EPTYP
            using MCNT = Field<20, 2>;    // MCNT
            using DAD = Field<22, 7>;    // DAD
            using CHDIS = Field<30, 1>;    // CHDIS
            using CHENA = Field<31, 1>;    // CHENA
        };

        // OTG host channel 14 split control register
        struct OTG_HCSPLT14 : public Register<0x490006c4> {
            using PRTADDR = Field<0, 7>;    // PRTADDR
            using HUBADDR = Field<7, 7>;    // HUBADDR
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // COMPLSPLT
            using SPLITEN = Field<31, 1>;    // SPLITEN
        };

        // This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
        struct OTG_HCINT14 : public Register<0x490006c8> {
            using XFRC = Field<0, 1>;    // XFRC
            using CHH = Field<1, 1>;    // CHH
            using AHBERR = Field<2, 1>;    // AHBERR
            using STALL = Field<3, 1>;    // STALL
            using NAK = Field<4, 1>;    // NAK
            using ACK = Field<5, 1>;    // ACK
            using NYET = Field<6, 1>;    // NYET
            using TXERR = Field<7, 1>;    // TXERR
            using BBERR = Field<8, 1>;    // BBERR
            using FRMOR = Field<9, 1>;    // FRMOR
            using DTERR = Field<10, 1>;    // DTERR
            using BNA = Field<11, 1>;    // BNA
            using XCSXACTERR = Field<12, 1>;    // XCSXACTERR
            using DESCLSTROLL = Field<13, 1>;    // DESCLSTROLL
        };

        // This register reflects the mask for each channel status described in the previous section.
        struct OTG_HCINTMSK14 : public Register<0x490006cc> {
            using XFRCM = Field<0, 1>;    // XFRCM
            using CHHM = Field<1, 1>;    // CHHM
            using AHBERRM = Field<2, 1>;    // AHBERRM
            using STALLM = Field<3, 1>;    // STALLM
            using NAKM = Field<4, 1>;    // NAKM
            using ACKM = Field<5, 1>;    // ACKM
            using NYET = Field<6, 1>;    // NYET
            using TXERRM = Field<7, 1>;    // TXERRM
            using BBERRM = Field<8, 1>;    // BBERRM
            using FRMORM = Field<9, 1>;    // FRMORM
            using DTERRM = Field<10, 1>;    // DTERRM
            using BNAMSK = Field<11, 1>;    // BNAMSK
            using DESCLSTROLLMSK = Field<13, 1>;    // DESCLSTROLLMSK
        };

        // OTG host channel 14 transfer size register
        struct OTG_HCTSIZ14 : public Register<0x490006d0> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using DPID = Field<29, 2>;    // DPID
        };

        // OTG host channel 14 DMA address register in buffer DMA [alternate]
        struct OTG_HCDMA14 : public Register<0x490006d4> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // OTG host channel-n DMA address buffer register
        struct OTG_HCDMAB14 : public RegisterReadOnly<0x490006dc> {
            using HCDMAB = Field<0, 32>;    // HCDMAB
        };

        // OTG host channel 15 characteristics register
        struct OTG_HCCHAR15 : public Register<0x490006e0> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using EPNUM = Field<11, 4>;    // EPNUM
            using EPDIR = Field<15, 1>;    // EPDIR
            using LSDEV = Field<17, 1>;    // LSDEV
            using EPTYP = Field<18, 2>;    // EPTYP
            using MCNT = Field<20, 2>;    // MCNT
            using DAD = Field<22, 7>;    // DAD
            using CHDIS = Field<30, 1>;    // CHDIS
            using CHENA = Field<31, 1>;    // CHENA
        };

        // OTG host channel 15 split control register
        struct OTG_HCSPLT15 : public Register<0x490006e4> {
            using PRTADDR = Field<0, 7>;    // PRTADDR
            using HUBADDR = Field<7, 7>;    // HUBADDR
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // COMPLSPLT
            using SPLITEN = Field<31, 1>;    // SPLITEN
        };

        // This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
        struct OTG_HCINT15 : public Register<0x490006e8> {
            using XFRC = Field<0, 1>;    // XFRC
            using CHH = Field<1, 1>;    // CHH
            using AHBERR = Field<2, 1>;    // AHBERR
            using STALL = Field<3, 1>;    // STALL
            using NAK = Field<4, 1>;    // NAK
            using ACK = Field<5, 1>;    // ACK
            using NYET = Field<6, 1>;    // NYET
            using TXERR = Field<7, 1>;    // TXERR
            using BBERR = Field<8, 1>;    // BBERR
            using FRMOR = Field<9, 1>;    // FRMOR
            using DTERR = Field<10, 1>;    // DTERR
            using BNA = Field<11, 1>;    // BNA
            using XCSXACTERR = Field<12, 1>;    // XCSXACTERR
            using DESCLSTROLL = Field<13, 1>;    // DESCLSTROLL
        };

        // This register reflects the mask for each channel status described in the previous section.
        struct OTG_HCINTMSK15 : public Register<0x490006ec> {
            using XFRCM = Field<0, 1>;    // XFRCM
            using CHHM = Field<1, 1>;    // CHHM
            using AHBERRM = Field<2, 1>;    // AHBERRM
            using STALLM = Field<3, 1>;    // STALLM
            using NAKM = Field<4, 1>;    // NAKM
            using ACKM = Field<5, 1>;    // ACKM
            using NYET = Field<6, 1>;    // NYET
            using TXERRM = Field<7, 1>;    // TXERRM
            using BBERRM = Field<8, 1>;    // BBERRM
            using FRMORM = Field<9, 1>;    // FRMORM
            using DTERRM = Field<10, 1>;    // DTERRM
            using BNAMSK = Field<11, 1>;    // BNAMSK
            using DESCLSTROLLMSK = Field<13, 1>;    // DESCLSTROLLMSK
        };

        // OTG host channel 15 transfer size register
        struct OTG_HCTSIZ15 : public Register<0x490006f0> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using DPID = Field<29, 2>;    // DPID
        };

        // OTG host channel 15 DMA address register in buffer DMA [alternate]
        struct OTG_HCDMA15 : public Register<0x490006f4> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // OTG host channel-n DMA address buffer register
        struct OTG_HCDMAB15 : public RegisterReadOnly<0x490006fc> {
            using HCDMAB = Field<0, 32>;    // HCDMAB
        };

        // This register configures the core in device mode after power-on or after certain control commands or enumeration. Do not make changes to this register after initial programming.
        struct OTG_DCFG : public Register<0x49000800> {
            using DSPD = Field<0, 2>;    // DSPD
            using NZLSOHSK = Field<2, 1>;    // NZLSOHSK
            using DAD = Field<4, 7>;    // DAD
            using PFIVL = Field<11, 2>;    // PFIVL
            using XCVRDLY = Field<14, 1>;    // XCVRDLY
            using ERRATIM = Field<15, 1>;    // ERRATIM
            using PERSCHIVL = Field<24, 2>;    // PERSCHIVL
        };

        // OTG device control register
        struct OTG_DCTL : public Register<0x49000804> {
            using RWUSIG = Field<0, 1>;    // RWUSIG
            using SDIS = Field<1, 1>;    // SDIS
            using GINSTS = Field<2, 1>;    // GINSTS
            using GONSTS = Field<3, 1>;    // GONSTS
            using TCTL = Field<4, 3>;    // TCTL
            using SGINAK = Field<7, 1>;    // SGINAK
            using CGINAK = Field<8, 1>;    // CGINAK
            using SGONAK = Field<9, 1>;    // SGONAK
            using CGONAK = Field<10, 1>;    // CGONAK
            using POPRGDNE = Field<11, 1>;    // POPRGDNE
            using DSBESLRJCT = Field<18, 1>;    // DSBESLRJCT
        };

        // This register indicates the status of the core with respect to USB-related events. It must be read on interrupts from the device all interrupts (OTG_DAINT) register.
        struct OTG_DSTS : public RegisterReadOnly<0x49000808> {
            using SUSPSTS = Field<0, 1>;    // SUSPSTS
            using ENUMSPD = Field<1, 2>;    // ENUMSPD
            using EERR = Field<3, 1>;    // EERR
            using FNSOF = Field<8, 14>;    // FNSOF
            using DEVLNSTS = Field<22, 2>;    // DEVLNSTS
        };

        // This register works with each of the OTG_DIEPINTx registers for all endpoints to generate an interrupt per IN endpoint. The IN endpoint interrupt for a specific status in the OTG_DIEPINTx register can be masked by writing to the corresponding bit in this register. Status bits are masked by default.
        struct OTG_DIEPMSK : public Register<0x49000810> {
            using XFRCM = Field<0, 1>;    // XFRCM
            using EPDM = Field<1, 1>;    // EPDM
            using AHBERRM = Field<2, 1>;    // AHBERRM
            using TOM = Field<3, 1>;    // TOM
            using ITTXFEMSK = Field<4, 1>;    // ITTXFEMSK
            using INEPNMM = Field<5, 1>;    // INEPNMM
            using INEPNEM = Field<6, 1>;    // INEPNEM
            using TXFURM = Field<8, 1>;    // TXFURM
            using BNAM = Field<9, 1>;    // BNAM
            using NAKM = Field<13, 1>;    // NAKM
        };

        // This register works with each of the OTG_DOEPINTx registers for all endpoints to generate an interrupt per OUT endpoint. The OUT endpoint interrupt for a specific status in the OTG_DOEPINTx register can be masked by writing into the corresponding bit in this register. Status bits are masked by default.
        struct OTG_DOEPMSK : public Register<0x49000814> {
            using XFRCM = Field<0, 1>;    // XFRCM
            using EPDM = Field<1, 1>;    // EPDM
            using AHBERRM = Field<2, 1>;    // AHBERRM
            using STUPM = Field<3, 1>;    // STUPM
            using OTEPDM = Field<4, 1>;    // OTEPDM
            using STSPHSRXM = Field<5, 1>;    // STSPHSRXM
            using B2BSTUPM = Field<6, 1>;    // B2BSTUPM
            using OUTPKTERRM = Field<8, 1>;    // OUTPKTERRM
            using BNAM = Field<9, 1>;    // BNAM
            using BERRM = Field<12, 1>;    // BERRM
            using NAKMSK = Field<13, 1>;    // NAKMSK
            using NYETMSK = Field<14, 1>;    // NYETMSK
        };

        // When a significant event occurs on an endpoint, a OTG_DAINT register interrupts the application using the device OUT endpoints interrupt bit or device IN endpoints interrupt bit of the OTG_GINTSTS register (OEPINT or IEPINT in OTG_GINTSTS, respectively). There is one interrupt bit per endpoint, up to a maximum of 16 bits for OUT endpoints and 16 bits for IN endpoints. For a bidirectional endpoint, the corresponding IN and OUT interrupt bits are used. Bits in this register are set and cleared when the application sets and clears bits in the corresponding device endpoint-x interrupt register (OTG_DIEPINTx/OTG_DOEPINTx).
        struct OTG_DAINT : public RegisterReadOnly<0x49000818> {
            using IEPINT = Field<0, 16>;    // IEPINT
            using OEPINT = Field<16, 16>;    // OEPINT
        };

        // The OTG_DAINTMSK register works with the device endpoint interrupt register to interrupt the application when an event occurs on a device endpoint. However, the OTG_DAINT register bit corresponding to that interrupt is still set.
        struct OTG_DAINTMSK : public Register<0x4900081c> {
            using IEPM = Field<0, 16>;    // IEPM
            using OEPM = Field<16, 16>;    // OEPM
        };

        // This register specifies the VBUS discharge time after VBUS pulsing during SRP.
        struct OTG_DVBUSDIS : public Register<0x49000828> {
            using VBUSDT = Field<0, 16>;    // VBUSDT
        };

        // This register specifies the VBUS pulsing time during SRP.
        struct OTG_DVBUSPULSE : public Register<0x4900082c> {
            using DVBUSP = Field<0, 16>;    // DVBUSP
        };

        // OTG device threshold control register
        struct OTG_DTHRCTL : public Register<0x49000830> {
            using NONISOTHREN = Field<0, 1>;    // NONISOTHREN
            using ISOTHREN = Field<1, 1>;    // ISOTHREN
            using TXTHRLEN = Field<2, 9>;    // TXTHRLEN
            using RXTHREN = Field<16, 1>;    // RXTHREN
            using RXTHRLEN = Field<17, 9>;    // RXTHRLEN
            using ARPEN = Field<27, 1>;    // ARPEN
        };

        // This register is used to control the IN endpoint FIFO empty interrupt generation (TXFE_OTG_DIEPINTx).
        struct OTG_DIEPEMPMSK : public Register<0x49000834> {
            using INEPTXFEM = Field<0, 16>;    // INEPTXFEM
        };

        // OTG device each endpoint interrupt register
        struct OTG_DEACHINT : public RegisterReadOnly<0x49000838> {
            using IEP1INT = Field<1, 1>;    // IEP1INT
            using OEP1INT = Field<17, 1>;    // OEP1INT
        };

        // There is one interrupt bit for endpoint 1 IN and one interrupt bit for endpoint 1 OUT.
        struct OTG_DEACHINTMSK : public Register<0x4900083c> {
            using IEP1INTM = Field<1, 1>;    // IEP1INTM
            using OEP1INTM = Field<17, 1>;    // OEP1INTM
        };

        // This register works with the OTG_DIEPINT1 register to generate a dedicated interrupt OTG_HS_EP1_IN for endpoint #1. The IN endpoint interrupt for a specific status in the OTG_DOEPINT1 register can be masked by writing into the corresponding bit in this register. Status bits are masked by default.
        struct OTG_HS_DIEPEACHMSK1 : public Register<0x49000844> {
            using XFRCM = Field<0, 1>;    // XFRCM
            using EPDM = Field<1, 1>;    // EPDM
            using AHBERRM = Field<2, 1>;    // AHBERRM
            using TOM = Field<3, 1>;    // TOM
            using ITTXFEMSK = Field<4, 1>;    // ITTXFEMSK
            using INEPNEM = Field<6, 1>;    // INEPNEM
            using TXFURM = Field<8, 1>;    // TXFURM
            using BNAM = Field<9, 1>;    // BNAM
            using NAKM = Field<13, 1>;    // NAKM
        };

        // This register works with the OTG_DOEPINT1 register to generate a dedicated interrupt OTG_HS_EP1_OUT for endpoint #1. The OUT endpoint interrupt for a specific status in the OTG_DOEPINT1 register can be masked by writing into the corresponding bit in this register. Status bits are masked by default.
        struct OTG_HS_DOEPEACHMSK1 : public Register<0x49000884> {
            using XFRCM = Field<0, 1>;    // XFRCM
            using EPDM = Field<1, 1>;    // EPDM
            using AHBERRM = Field<2, 1>;    // AHBERRM
            using STUPM = Field<3, 1>;    // STUPM
            using OTEPDM = Field<4, 1>;    // OTEPDM
            using B2BSTUPM = Field<6, 1>;    // B2BSTUPM
            using OUTPKTERRM = Field<8, 1>;    // OUTPKTERRM
            using BNAM = Field<9, 1>;    // BNAM
            using BERRM = Field<12, 1>;    // BERRM
            using NAKMSK = Field<13, 1>;    // NAKMSK
            using NYETMSK = Field<14, 1>;    // NYETMSK
        };

        // The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
        struct OTG_DIEPCTL0 : public Register<0x49000900> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using USBAEP = Field<15, 1>;    // USBAEP
            using EONUM_DPIP = Field<16, 1>;    // EONUM_DPIP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EPTYP = Field<18, 2>;    // EPTYP
            using STALL = Field<21, 1>;    // STALL
            using TXFNUM = Field<22, 4>;    // TXFNUM
            using CNAK = Field<26, 1>;    // CNAK
            using SNAK = Field<27, 1>;    // SNAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID_SEVNFRM
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using EPDIS = Field<30, 1>;    // EPDIS
            using EPENA = Field<31, 1>;    // EPENA
        };

        // This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the IN endpoints interrupt bit of the core interrupt register (IEPINT in OTG_GINTSTS) is set. Before the application can read this register, it must first read the device all endpoints interrupt (OTG_DAINT) register to get the exact endpoint number for the device endpoint-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
        struct OTG_DIEPINT0 : public Register<0x49000908> {
            using XFRC = Field<0, 1>;    // XFRC
            using EPDISD = Field<1, 1>;    // EPDISD
            using AHBERR = Field<2, 1>;    // AHBERR
            using TOC = Field<3, 1>;    // TOC
            using ITTXFE = Field<4, 1>;    // ITTXFE
            using INEPNM = Field<5, 1>;    // INEPNM
            using INEPNE = Field<6, 1>;    // INEPNE
            using TXFE = Field<7, 1>;    // TXFE
            using TXFIFOUDRN = Field<8, 1>;    // TXFIFOUDRN
            using BNA = Field<9, 1>;    // BNA
            using PKTDRPSTS = Field<11, 1>;    // PKTDRPSTS
            using NAK = Field<13, 1>;    // NAK
        };

        // The application must modify this register before enabling endpoint 0.
        struct OTG_DIEPTSIZ0 : public Register<0x49000910> {
            using XFRSIZ = Field<0, 7>;    // XFRSIZ
            using PKTCNT = Field<19, 2>;    // PKTCNT
        };

        // OTG device IN endpoint 0 DMA address register
        struct OTG_DIEPDMA0 : public Register<0x49000914> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // This read-only register contains the free space information for the device IN endpoint Tx FIFO.
        struct OTG_DTXFSTS0 : public RegisterReadOnly<0x49000918> {
            using INEPTFSAV = Field<0, 16>;    // INEPTFSAV
        };

        // The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
        struct OTG_DIEPCTL1 : public Register<0x49000920> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using USBAEP = Field<15, 1>;    // USBAEP
            using EONUM_DPIP = Field<16, 1>;    // EONUM_DPIP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EPTYP = Field<18, 2>;    // EPTYP
            using STALL = Field<21, 1>;    // STALL
            using TXFNUM = Field<22, 4>;    // TXFNUM
            using CNAK = Field<26, 1>;    // CNAK
            using SNAK = Field<27, 1>;    // SNAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID_SEVNFRM
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using EPDIS = Field<30, 1>;    // EPDIS
            using EPENA = Field<31, 1>;    // EPENA
        };

        // This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the IN endpoints interrupt bit of the core interrupt register (IEPINT in OTG_GINTSTS) is set. Before the application can read this register, it must first read the device all endpoints interrupt (OTG_DAINT) register to get the exact endpoint number for the device endpoint-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
        struct OTG_DIEPINT1 : public Register<0x49000928> {
            using XFRC = Field<0, 1>;    // XFRC
            using EPDISD = Field<1, 1>;    // EPDISD
            using AHBERR = Field<2, 1>;    // AHBERR
            using TOC = Field<3, 1>;    // TOC
            using ITTXFE = Field<4, 1>;    // ITTXFE
            using INEPNM = Field<5, 1>;    // INEPNM
            using INEPNE = Field<6, 1>;    // INEPNE
            using TXFE = Field<7, 1>;    // TXFE
            using TXFIFOUDRN = Field<8, 1>;    // TXFIFOUDRN
            using BNA = Field<9, 1>;    // BNA
            using PKTDRPSTS = Field<11, 1>;    // PKTDRPSTS
            using NAK = Field<13, 1>;    // NAK
        };

        // The application must modify this register before enabling the endpoint. Once the endpoint is enabled using the endpoint enable bit in the OTG_DIEPCTLx registers (EPENA bit in OTG_DIEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
        struct OTG_DIEPTSIZ1 : public Register<0x49000930> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using MCNT = Field<29, 2>;    // MCNT
        };

        // OTG device IN endpoint 1 DMA address register
        struct OTG_DIEPDMA1 : public Register<0x49000934> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // This read-only register contains the free space information for the device IN endpoint Tx FIFO.
        struct OTG_DTXFSTS1 : public RegisterReadOnly<0x49000938> {
            using INEPTFSAV = Field<0, 16>;    // INEPTFSAV
        };

        // The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
        struct OTG_DIEPCTL2 : public Register<0x49000940> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using USBAEP = Field<15, 1>;    // USBAEP
            using EONUM_DPIP = Field<16, 1>;    // EONUM_DPIP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EPTYP = Field<18, 2>;    // EPTYP
            using STALL = Field<21, 1>;    // STALL
            using TXFNUM = Field<22, 4>;    // TXFNUM
            using CNAK = Field<26, 1>;    // CNAK
            using SNAK = Field<27, 1>;    // SNAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID_SEVNFRM
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using EPDIS = Field<30, 1>;    // EPDIS
            using EPENA = Field<31, 1>;    // EPENA
        };

        // This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the IN endpoints interrupt bit of the core interrupt register (IEPINT in OTG_GINTSTS) is set. Before the application can read this register, it must first read the device all endpoints interrupt (OTG_DAINT) register to get the exact endpoint number for the device endpoint-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
        struct OTG_DIEPINT2 : public Register<0x49000948> {
            using XFRC = Field<0, 1>;    // XFRC
            using EPDISD = Field<1, 1>;    // EPDISD
            using AHBERR = Field<2, 1>;    // AHBERR
            using TOC = Field<3, 1>;    // TOC
            using ITTXFE = Field<4, 1>;    // ITTXFE
            using INEPNM = Field<5, 1>;    // INEPNM
            using INEPNE = Field<6, 1>;    // INEPNE
            using TXFE = Field<7, 1>;    // TXFE
            using TXFIFOUDRN = Field<8, 1>;    // TXFIFOUDRN
            using BNA = Field<9, 1>;    // BNA
            using PKTDRPSTS = Field<11, 1>;    // PKTDRPSTS
            using NAK = Field<13, 1>;    // NAK
        };

        // The application must modify this register before enabling the endpoint. Once the endpoint is enabled using the endpoint enable bit in the OTG_DIEPCTLx registers (EPENA bit in OTG_DIEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
        struct OTG_DIEPTSIZ2 : public Register<0x49000950> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using MCNT = Field<29, 2>;    // MCNT
        };

        // OTG device IN endpoint 2 DMA address register
        struct OTG_DIEPDMA2 : public Register<0x49000954> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // This read-only register contains the free space information for the device IN endpoint Tx FIFO.
        struct OTG_DTXFSTS2 : public RegisterReadOnly<0x49000958> {
            using INEPTFSAV = Field<0, 16>;    // INEPTFSAV
        };

        // The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
        struct OTG_DIEPCTL3 : public Register<0x49000960> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using USBAEP = Field<15, 1>;    // USBAEP
            using EONUM_DPIP = Field<16, 1>;    // EONUM_DPIP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EPTYP = Field<18, 2>;    // EPTYP
            using STALL = Field<21, 1>;    // STALL
            using TXFNUM = Field<22, 4>;    // TXFNUM
            using CNAK = Field<26, 1>;    // CNAK
            using SNAK = Field<27, 1>;    // SNAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID_SEVNFRM
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using EPDIS = Field<30, 1>;    // EPDIS
            using EPENA = Field<31, 1>;    // EPENA
        };

        // This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the IN endpoints interrupt bit of the core interrupt register (IEPINT in OTG_GINTSTS) is set. Before the application can read this register, it must first read the device all endpoints interrupt (OTG_DAINT) register to get the exact endpoint number for the device endpoint-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
        struct OTG_DIEPINT3 : public Register<0x49000968> {
            using XFRC = Field<0, 1>;    // XFRC
            using EPDISD = Field<1, 1>;    // EPDISD
            using AHBERR = Field<2, 1>;    // AHBERR
            using TOC = Field<3, 1>;    // TOC
            using ITTXFE = Field<4, 1>;    // ITTXFE
            using INEPNM = Field<5, 1>;    // INEPNM
            using INEPNE = Field<6, 1>;    // INEPNE
            using TXFE = Field<7, 1>;    // TXFE
            using TXFIFOUDRN = Field<8, 1>;    // TXFIFOUDRN
            using BNA = Field<9, 1>;    // BNA
            using PKTDRPSTS = Field<11, 1>;    // PKTDRPSTS
            using NAK = Field<13, 1>;    // NAK
        };

        // The application must modify this register before enabling the endpoint. Once the endpoint is enabled using the endpoint enable bit in the OTG_DIEPCTLx registers (EPENA bit in OTG_DIEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
        struct OTG_DIEPTSIZ3 : public Register<0x49000970> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using MCNT = Field<29, 2>;    // MCNT
        };

        // OTG device IN endpoint 3 DMA address register
        struct OTG_DIEPDMA3 : public Register<0x49000974> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // This read-only register contains the free space information for the device IN endpoint Tx FIFO.
        struct OTG_DTXFSTS3 : public RegisterReadOnly<0x49000978> {
            using INEPTFSAV = Field<0, 16>;    // INEPTFSAV
        };

        // The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
        struct OTG_DIEPCTL4 : public Register<0x49000980> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using USBAEP = Field<15, 1>;    // USBAEP
            using EONUM_DPIP = Field<16, 1>;    // EONUM_DPIP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EPTYP = Field<18, 2>;    // EPTYP
            using STALL = Field<21, 1>;    // STALL
            using TXFNUM = Field<22, 4>;    // TXFNUM
            using CNAK = Field<26, 1>;    // CNAK
            using SNAK = Field<27, 1>;    // SNAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID_SEVNFRM
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using EPDIS = Field<30, 1>;    // EPDIS
            using EPENA = Field<31, 1>;    // EPENA
        };

        // This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the IN endpoints interrupt bit of the core interrupt register (IEPINT in OTG_GINTSTS) is set. Before the application can read this register, it must first read the device all endpoints interrupt (OTG_DAINT) register to get the exact endpoint number for the device endpoint-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
        struct OTG_DIEPINT4 : public Register<0x49000988> {
            using XFRC = Field<0, 1>;    // XFRC
            using EPDISD = Field<1, 1>;    // EPDISD
            using AHBERR = Field<2, 1>;    // AHBERR
            using TOC = Field<3, 1>;    // TOC
            using ITTXFE = Field<4, 1>;    // ITTXFE
            using INEPNM = Field<5, 1>;    // INEPNM
            using INEPNE = Field<6, 1>;    // INEPNE
            using TXFE = Field<7, 1>;    // TXFE
            using TXFIFOUDRN = Field<8, 1>;    // TXFIFOUDRN
            using BNA = Field<9, 1>;    // BNA
            using PKTDRPSTS = Field<11, 1>;    // PKTDRPSTS
            using NAK = Field<13, 1>;    // NAK
        };

        // The application must modify this register before enabling the endpoint. Once the endpoint is enabled using the endpoint enable bit in the OTG_DIEPCTLx registers (EPENA bit in OTG_DIEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
        struct OTG_DIEPTSIZ4 : public Register<0x49000990> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using MCNT = Field<29, 2>;    // MCNT
        };

        // OTG device IN endpoint 4 DMA address register
        struct OTG_DIEPDMA4 : public Register<0x49000994> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // This read-only register contains the free space information for the device IN endpoint Tx FIFO.
        struct OTG_DTXFSTS4 : public RegisterReadOnly<0x49000998> {
            using INEPTFSAV = Field<0, 16>;    // INEPTFSAV
        };

        // The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
        struct OTG_DIEPCTL5 : public Register<0x490009a0> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using USBAEP = Field<15, 1>;    // USBAEP
            using EONUM_DPIP = Field<16, 1>;    // EONUM_DPIP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EPTYP = Field<18, 2>;    // EPTYP
            using STALL = Field<21, 1>;    // STALL
            using TXFNUM = Field<22, 4>;    // TXFNUM
            using CNAK = Field<26, 1>;    // CNAK
            using SNAK = Field<27, 1>;    // SNAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID_SEVNFRM
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using EPDIS = Field<30, 1>;    // EPDIS
            using EPENA = Field<31, 1>;    // EPENA
        };

        // This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the IN endpoints interrupt bit of the core interrupt register (IEPINT in OTG_GINTSTS) is set. Before the application can read this register, it must first read the device all endpoints interrupt (OTG_DAINT) register to get the exact endpoint number for the device endpoint-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
        struct OTG_DIEPINT5 : public Register<0x490009a8> {
            using XFRC = Field<0, 1>;    // XFRC
            using EPDISD = Field<1, 1>;    // EPDISD
            using AHBERR = Field<2, 1>;    // AHBERR
            using TOC = Field<3, 1>;    // TOC
            using ITTXFE = Field<4, 1>;    // ITTXFE
            using INEPNM = Field<5, 1>;    // INEPNM
            using INEPNE = Field<6, 1>;    // INEPNE
            using TXFE = Field<7, 1>;    // TXFE
            using TXFIFOUDRN = Field<8, 1>;    // TXFIFOUDRN
            using BNA = Field<9, 1>;    // BNA
            using PKTDRPSTS = Field<11, 1>;    // PKTDRPSTS
            using NAK = Field<13, 1>;    // NAK
        };

        // The application must modify this register before enabling the endpoint. Once the endpoint is enabled using the endpoint enable bit in the OTG_DIEPCTLx registers (EPENA bit in OTG_DIEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
        struct OTG_DIEPTSIZ5 : public Register<0x490009b0> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using MCNT = Field<29, 2>;    // MCNT
        };

        // OTG device IN endpoint 5 DMA address register
        struct OTG_DIEPDMA5 : public Register<0x490009b4> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // This read-only register contains the free space information for the device IN endpoint Tx FIFO.
        struct OTG_DTXFSTS5 : public RegisterReadOnly<0x490009b8> {
            using INEPTFSAV = Field<0, 16>;    // INEPTFSAV
        };

        // The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
        struct OTG_DIEPCTL6 : public Register<0x490009c0> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using USBAEP = Field<15, 1>;    // USBAEP
            using EONUM_DPIP = Field<16, 1>;    // EONUM_DPIP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EPTYP = Field<18, 2>;    // EPTYP
            using STALL = Field<21, 1>;    // STALL
            using TXFNUM = Field<22, 4>;    // TXFNUM
            using CNAK = Field<26, 1>;    // CNAK
            using SNAK = Field<27, 1>;    // SNAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID_SEVNFRM
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using EPDIS = Field<30, 1>;    // EPDIS
            using EPENA = Field<31, 1>;    // EPENA
        };

        // This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the IN endpoints interrupt bit of the core interrupt register (IEPINT in OTG_GINTSTS) is set. Before the application can read this register, it must first read the device all endpoints interrupt (OTG_DAINT) register to get the exact endpoint number for the device endpoint-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
        struct OTG_DIEPINT6 : public Register<0x490009c8> {
            using XFRC = Field<0, 1>;    // XFRC
            using EPDISD = Field<1, 1>;    // EPDISD
            using AHBERR = Field<2, 1>;    // AHBERR
            using TOC = Field<3, 1>;    // TOC
            using ITTXFE = Field<4, 1>;    // ITTXFE
            using INEPNM = Field<5, 1>;    // INEPNM
            using INEPNE = Field<6, 1>;    // INEPNE
            using TXFE = Field<7, 1>;    // TXFE
            using TXFIFOUDRN = Field<8, 1>;    // TXFIFOUDRN
            using BNA = Field<9, 1>;    // BNA
            using PKTDRPSTS = Field<11, 1>;    // PKTDRPSTS
            using NAK = Field<13, 1>;    // NAK
        };

        // The application must modify this register before enabling the endpoint. Once the endpoint is enabled using the endpoint enable bit in the OTG_DIEPCTLx registers (EPENA bit in OTG_DIEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
        struct OTG_DIEPTSIZ6 : public Register<0x490009d0> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using MCNT = Field<29, 2>;    // MCNT
        };

        // OTG device IN endpoint 6 DMA address register
        struct OTG_DIEPDMA6 : public Register<0x490009d4> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // This read-only register contains the free space information for the device IN endpoint Tx FIFO.
        struct OTG_DTXFSTS6 : public RegisterReadOnly<0x490009d8> {
            using INEPTFSAV = Field<0, 16>;    // INEPTFSAV
        };

        // The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
        struct OTG_DIEPCTL7 : public Register<0x490009e0> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using USBAEP = Field<15, 1>;    // USBAEP
            using EONUM_DPIP = Field<16, 1>;    // EONUM_DPIP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EPTYP = Field<18, 2>;    // EPTYP
            using STALL = Field<21, 1>;    // STALL
            using TXFNUM = Field<22, 4>;    // TXFNUM
            using CNAK = Field<26, 1>;    // CNAK
            using SNAK = Field<27, 1>;    // SNAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID_SEVNFRM
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using EPDIS = Field<30, 1>;    // EPDIS
            using EPENA = Field<31, 1>;    // EPENA
        };

        // This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the IN endpoints interrupt bit of the core interrupt register (IEPINT in OTG_GINTSTS) is set. Before the application can read this register, it must first read the device all endpoints interrupt (OTG_DAINT) register to get the exact endpoint number for the device endpoint-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
        struct OTG_DIEPINT7 : public Register<0x490009e8> {
            using XFRC = Field<0, 1>;    // XFRC
            using EPDISD = Field<1, 1>;    // EPDISD
            using AHBERR = Field<2, 1>;    // AHBERR
            using TOC = Field<3, 1>;    // TOC
            using ITTXFE = Field<4, 1>;    // ITTXFE
            using INEPNM = Field<5, 1>;    // INEPNM
            using INEPNE = Field<6, 1>;    // INEPNE
            using TXFE = Field<7, 1>;    // TXFE
            using TXFIFOUDRN = Field<8, 1>;    // TXFIFOUDRN
            using BNA = Field<9, 1>;    // BNA
            using PKTDRPSTS = Field<11, 1>;    // PKTDRPSTS
            using NAK = Field<13, 1>;    // NAK
        };

        // The application must modify this register before enabling the endpoint. Once the endpoint is enabled using the endpoint enable bit in the OTG_DIEPCTLx registers (EPENA bit in OTG_DIEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
        struct OTG_DIEPTSIZ7 : public Register<0x490009f0> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using MCNT = Field<29, 2>;    // MCNT
        };

        // OTG device IN endpoint 7 DMA address register
        struct OTG_DIEPDMA7 : public Register<0x490009f4> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // This read-only register contains the free space information for the device IN endpoint Tx FIFO.
        struct OTG_DTXFSTS7 : public RegisterReadOnly<0x490009f8> {
            using INEPTFSAV = Field<0, 16>;    // INEPTFSAV
        };

        // The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
        struct OTG_DIEPCTL8 : public Register<0x49000a00> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using USBAEP = Field<15, 1>;    // USBAEP
            using EONUM_DPIP = Field<16, 1>;    // EONUM_DPIP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EPTYP = Field<18, 2>;    // EPTYP
            using STALL = Field<21, 1>;    // STALL
            using TXFNUM = Field<22, 4>;    // TXFNUM
            using CNAK = Field<26, 1>;    // CNAK
            using SNAK = Field<27, 1>;    // SNAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID_SEVNFRM
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using EPDIS = Field<30, 1>;    // EPDIS
            using EPENA = Field<31, 1>;    // EPENA
        };

        // This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the IN endpoints interrupt bit of the core interrupt register (IEPINT in OTG_GINTSTS) is set. Before the application can read this register, it must first read the device all endpoints interrupt (OTG_DAINT) register to get the exact endpoint number for the device endpoint-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
        struct OTG_DIEPINT8 : public Register<0x49000a08> {
            using XFRC = Field<0, 1>;    // XFRC
            using EPDISD = Field<1, 1>;    // EPDISD
            using AHBERR = Field<2, 1>;    // AHBERR
            using TOC = Field<3, 1>;    // TOC
            using ITTXFE = Field<4, 1>;    // ITTXFE
            using INEPNM = Field<5, 1>;    // INEPNM
            using INEPNE = Field<6, 1>;    // INEPNE
            using TXFE = Field<7, 1>;    // TXFE
            using TXFIFOUDRN = Field<8, 1>;    // TXFIFOUDRN
            using BNA = Field<9, 1>;    // BNA
            using PKTDRPSTS = Field<11, 1>;    // PKTDRPSTS
            using NAK = Field<13, 1>;    // NAK
        };

        // The application must modify this register before enabling the endpoint. Once the endpoint is enabled using the endpoint enable bit in the OTG_DIEPCTLx registers (EPENA bit in OTG_DIEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
        struct OTG_DIEPTSIZ8 : public Register<0x49000a10> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using MCNT = Field<29, 2>;    // MCNT
        };

        // OTG device IN endpoint 8 DMA address register
        struct OTG_DIEPDMA8 : public Register<0x49000a14> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // This read-only register contains the free space information for the device IN endpoint Tx FIFO.
        struct OTG_DTXFSTS8 : public RegisterReadOnly<0x49000a18> {
            using INEPTFSAV = Field<0, 16>;    // INEPTFSAV
        };

        // This section describes the OTG_DOEPCTL0 register.
        struct OTG_DOEPCTL0 : public Register<0x49000b00> {
            using MPSIZ = Field<0, 2>;    // MPSIZ
            using USBAEP = Field<15, 1>;    // USBAEP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EPTYP = Field<18, 2>;    // EPTYP
            using SNPM = Field<20, 1>;    // SNPM
            using STALL = Field<21, 1>;    // STALL
            using CNAK = Field<26, 1>;    // CNAK
            using SNAK = Field<27, 1>;    // SNAK
            using EPDIS = Field<30, 1>;    // EPDIS
            using EPENA = Field<31, 1>;    // EPENA
        };

        // This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the OUT endpoints interrupt bit of the OTG_GINTSTS register (OEPINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the OTG_DAINT register to get the exact endpoint number for the OTG_DOEPINTx register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
        struct OTG_DOEPINT0 : public Register<0x49000b08> {
            using XFRC = Field<0, 1>;    // XFRC
            using EPDISD = Field<1, 1>;    // EPDISD
            using AHBERR = Field<2, 1>;    // AHBERR
            using STUP = Field<3, 1>;    // STUP
            using OTEPDIS = Field<4, 1>;    // OTEPDIS
            using STSPHSRX = Field<5, 1>;    // STSPHSRX
            using B2BSTUP = Field<6, 1>;    // B2BSTUP
            using OUTPKTERR = Field<8, 1>;    // OUTPKTERR
            using BNA = Field<9, 1>;    // BNA
            using BERR = Field<12, 1>;    // BERR
            using NAK = Field<13, 1>;    // NAK
            using NYET = Field<14, 1>;    // NYET
            using STPKTRX = Field<15, 1>;    // STPKTRX
        };

        // The application must modify this register before enabling endpoint 0.
        struct OTG_DOEPTSIZ0 : public Register<0x49000b10> {
            using XFRSIZ = Field<0, 7>;    // XFRSIZ
            using PKTCNT = Field<19, 1>;    // PKTCNT
            using STUPCNT = Field<29, 2>;    // STUPCNT
        };

        // OTG device OUT endpoint 0 DMA address register
        struct OTG_DOEPDMA0 : public Register<0x49000b14> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
        struct OTG_DOEPCTL1 : public Register<0x49000b20> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using USBAEP = Field<15, 1>;    // USBAEP
            using EONUM_DPIP = Field<16, 1>;    // EONUM_DPIP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EPTYP = Field<18, 2>;    // EPTYP
            using SNPM = Field<20, 1>;    // SNPM
            using STALL = Field<21, 1>;    // STALL
            using CNAK = Field<26, 1>;    // CNAK
            using SNAK = Field<27, 1>;    // SNAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID_SEVNFRM
            using SD1PID_SODDFRM = Field<29, 1>;    // SD1PID_SODDFRM
            using EPDIS = Field<30, 1>;    // EPDIS
            using EPENA = Field<31, 1>;    // EPENA
        };

        // This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the OUT endpoints interrupt bit of the OTG_GINTSTS register (OEPINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the OTG_DAINT register to get the exact endpoint number for the OTG_DOEPINTx register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
        struct OTG_DOEPINT1 : public Register<0x49000b28> {
            using XFRC = Field<0, 1>;    // XFRC
            using EPDISD = Field<1, 1>;    // EPDISD
            using AHBERR = Field<2, 1>;    // AHBERR
            using STUP = Field<3, 1>;    // STUP
            using OTEPDIS = Field<4, 1>;    // OTEPDIS
            using STSPHSRX = Field<5, 1>;    // STSPHSRX
            using B2BSTUP = Field<6, 1>;    // B2BSTUP
            using OUTPKTERR = Field<8, 1>;    // OUTPKTERR
            using BNA = Field<9, 1>;    // BNA
            using BERR = Field<12, 1>;    // BERR
            using NAK = Field<13, 1>;    // NAK
            using NYET = Field<14, 1>;    // NYET
            using STPKTRX = Field<15, 1>;    // STPKTRX
        };

        // The application must modify this register before enabling the endpoint. Once the endpoint is enabled using endpoint enable bit of the OTG_DOEPCTLx registers (EPENA bit in OTG_DOEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
        struct OTG_DOEPTSIZ1 : public Register<0x49000b30> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using RXDPID_STUPCNT = Field<29, 2>;    // RXDPID_STUPCNT
        };

        // OTG device OUT endpoint 1 DMA address register
        struct OTG_DOEPDMA1 : public Register<0x49000b34> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
        struct OTG_DOEPCTL2 : public Register<0x49000b40> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using USBAEP = Field<15, 1>;    // USBAEP
            using EONUM_DPIP = Field<16, 1>;    // EONUM_DPIP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EPTYP = Field<18, 2>;    // EPTYP
            using SNPM = Field<20, 1>;    // SNPM
            using STALL = Field<21, 1>;    // STALL
            using CNAK = Field<26, 1>;    // CNAK
            using SNAK = Field<27, 1>;    // SNAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID_SEVNFRM
            using SD1PID_SODDFRM = Field<29, 1>;    // SD1PID_SODDFRM
            using EPDIS = Field<30, 1>;    // EPDIS
            using EPENA = Field<31, 1>;    // EPENA
        };

        // This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the OUT endpoints interrupt bit of the OTG_GINTSTS register (OEPINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the OTG_DAINT register to get the exact endpoint number for the OTG_DOEPINTx register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
        struct OTG_DOEPINT2 : public Register<0x49000b48> {
            using XFRC = Field<0, 1>;    // XFRC
            using EPDISD = Field<1, 1>;    // EPDISD
            using AHBERR = Field<2, 1>;    // AHBERR
            using STUP = Field<3, 1>;    // STUP
            using OTEPDIS = Field<4, 1>;    // OTEPDIS
            using STSPHSRX = Field<5, 1>;    // STSPHSRX
            using B2BSTUP = Field<6, 1>;    // B2BSTUP
            using OUTPKTERR = Field<8, 1>;    // OUTPKTERR
            using BNA = Field<9, 1>;    // BNA
            using BERR = Field<12, 1>;    // BERR
            using NAK = Field<13, 1>;    // NAK
            using NYET = Field<14, 1>;    // NYET
            using STPKTRX = Field<15, 1>;    // STPKTRX
        };

        // The application must modify this register before enabling the endpoint. Once the endpoint is enabled using endpoint enable bit of the OTG_DOEPCTLx registers (EPENA bit in OTG_DOEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
        struct OTG_DOEPTSIZ2 : public Register<0x49000b50> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using RXDPID_STUPCNT = Field<29, 2>;    // RXDPID_STUPCNT
        };

        // OTG device OUT endpoint 2 DMA address register
        struct OTG_DOEPDMA2 : public Register<0x49000b54> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
        struct OTG_DOEPCTL3 : public Register<0x49000b60> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using USBAEP = Field<15, 1>;    // USBAEP
            using EONUM_DPIP = Field<16, 1>;    // EONUM_DPIP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EPTYP = Field<18, 2>;    // EPTYP
            using SNPM = Field<20, 1>;    // SNPM
            using STALL = Field<21, 1>;    // STALL
            using CNAK = Field<26, 1>;    // CNAK
            using SNAK = Field<27, 1>;    // SNAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID_SEVNFRM
            using SD1PID_SODDFRM = Field<29, 1>;    // SD1PID_SODDFRM
            using EPDIS = Field<30, 1>;    // EPDIS
            using EPENA = Field<31, 1>;    // EPENA
        };

        // This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the OUT endpoints interrupt bit of the OTG_GINTSTS register (OEPINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the OTG_DAINT register to get the exact endpoint number for the OTG_DOEPINTx register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
        struct OTG_DOEPINT3 : public Register<0x49000b68> {
            using XFRC = Field<0, 1>;    // XFRC
            using EPDISD = Field<1, 1>;    // EPDISD
            using AHBERR = Field<2, 1>;    // AHBERR
            using STUP = Field<3, 1>;    // STUP
            using OTEPDIS = Field<4, 1>;    // OTEPDIS
            using STSPHSRX = Field<5, 1>;    // STSPHSRX
            using B2BSTUP = Field<6, 1>;    // B2BSTUP
            using OUTPKTERR = Field<8, 1>;    // OUTPKTERR
            using BNA = Field<9, 1>;    // BNA
            using BERR = Field<12, 1>;    // BERR
            using NAK = Field<13, 1>;    // NAK
            using NYET = Field<14, 1>;    // NYET
            using STPKTRX = Field<15, 1>;    // STPKTRX
        };

        // The application must modify this register before enabling the endpoint. Once the endpoint is enabled using endpoint enable bit of the OTG_DOEPCTLx registers (EPENA bit in OTG_DOEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
        struct OTG_DOEPTSIZ3 : public Register<0x49000b70> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using RXDPID_STUPCNT = Field<29, 2>;    // RXDPID_STUPCNT
        };

        // OTG device OUT endpoint 3 DMA address register
        struct OTG_DOEPDMA3 : public Register<0x49000b74> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
        struct OTG_DOEPCTL4 : public Register<0x49000b80> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using USBAEP = Field<15, 1>;    // USBAEP
            using EONUM_DPIP = Field<16, 1>;    // EONUM_DPIP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EPTYP = Field<18, 2>;    // EPTYP
            using SNPM = Field<20, 1>;    // SNPM
            using STALL = Field<21, 1>;    // STALL
            using CNAK = Field<26, 1>;    // CNAK
            using SNAK = Field<27, 1>;    // SNAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID_SEVNFRM
            using SD1PID_SODDFRM = Field<29, 1>;    // SD1PID_SODDFRM
            using EPDIS = Field<30, 1>;    // EPDIS
            using EPENA = Field<31, 1>;    // EPENA
        };

        // This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the OUT endpoints interrupt bit of the OTG_GINTSTS register (OEPINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the OTG_DAINT register to get the exact endpoint number for the OTG_DOEPINTx register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
        struct OTG_DOEPINT4 : public Register<0x49000b88> {
            using XFRC = Field<0, 1>;    // XFRC
            using EPDISD = Field<1, 1>;    // EPDISD
            using AHBERR = Field<2, 1>;    // AHBERR
            using STUP = Field<3, 1>;    // STUP
            using OTEPDIS = Field<4, 1>;    // OTEPDIS
            using STSPHSRX = Field<5, 1>;    // STSPHSRX
            using B2BSTUP = Field<6, 1>;    // B2BSTUP
            using OUTPKTERR = Field<8, 1>;    // OUTPKTERR
            using BNA = Field<9, 1>;    // BNA
            using BERR = Field<12, 1>;    // BERR
            using NAK = Field<13, 1>;    // NAK
            using NYET = Field<14, 1>;    // NYET
            using STPKTRX = Field<15, 1>;    // STPKTRX
        };

        // The application must modify this register before enabling the endpoint. Once the endpoint is enabled using endpoint enable bit of the OTG_DOEPCTLx registers (EPENA bit in OTG_DOEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
        struct OTG_DOEPTSIZ4 : public Register<0x49000b90> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using RXDPID_STUPCNT = Field<29, 2>;    // RXDPID_STUPCNT
        };

        // OTG device OUT endpoint 4 DMA address register
        struct OTG_DOEPDMA4 : public Register<0x49000b94> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
        struct OTG_DOEPCTL5 : public Register<0x49000ba0> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using USBAEP = Field<15, 1>;    // USBAEP
            using EONUM_DPIP = Field<16, 1>;    // EONUM_DPIP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EPTYP = Field<18, 2>;    // EPTYP
            using SNPM = Field<20, 1>;    // SNPM
            using STALL = Field<21, 1>;    // STALL
            using CNAK = Field<26, 1>;    // CNAK
            using SNAK = Field<27, 1>;    // SNAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID_SEVNFRM
            using SD1PID_SODDFRM = Field<29, 1>;    // SD1PID_SODDFRM
            using EPDIS = Field<30, 1>;    // EPDIS
            using EPENA = Field<31, 1>;    // EPENA
        };

        // This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the OUT endpoints interrupt bit of the OTG_GINTSTS register (OEPINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the OTG_DAINT register to get the exact endpoint number for the OTG_DOEPINTx register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
        struct OTG_DOEPINT5 : public Register<0x49000ba8> {
            using XFRC = Field<0, 1>;    // XFRC
            using EPDISD = Field<1, 1>;    // EPDISD
            using AHBERR = Field<2, 1>;    // AHBERR
            using STUP = Field<3, 1>;    // STUP
            using OTEPDIS = Field<4, 1>;    // OTEPDIS
            using STSPHSRX = Field<5, 1>;    // STSPHSRX
            using B2BSTUP = Field<6, 1>;    // B2BSTUP
            using OUTPKTERR = Field<8, 1>;    // OUTPKTERR
            using BNA = Field<9, 1>;    // BNA
            using BERR = Field<12, 1>;    // BERR
            using NAK = Field<13, 1>;    // NAK
            using NYET = Field<14, 1>;    // NYET
            using STPKTRX = Field<15, 1>;    // STPKTRX
        };

        // The application must modify this register before enabling the endpoint. Once the endpoint is enabled using endpoint enable bit of the OTG_DOEPCTLx registers (EPENA bit in OTG_DOEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
        struct OTG_DOEPTSIZ5 : public Register<0x49000bb0> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using RXDPID_STUPCNT = Field<29, 2>;    // RXDPID_STUPCNT
        };

        // OTG device OUT endpoint 5 DMA address register
        struct OTG_DOEPDMA5 : public Register<0x49000bb4> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
        struct OTG_DOEPCTL6 : public Register<0x49000bc0> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using USBAEP = Field<15, 1>;    // USBAEP
            using EONUM_DPIP = Field<16, 1>;    // EONUM_DPIP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EPTYP = Field<18, 2>;    // EPTYP
            using SNPM = Field<20, 1>;    // SNPM
            using STALL = Field<21, 1>;    // STALL
            using CNAK = Field<26, 1>;    // CNAK
            using SNAK = Field<27, 1>;    // SNAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID_SEVNFRM
            using SD1PID_SODDFRM = Field<29, 1>;    // SD1PID_SODDFRM
            using EPDIS = Field<30, 1>;    // EPDIS
            using EPENA = Field<31, 1>;    // EPENA
        };

        // This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the OUT endpoints interrupt bit of the OTG_GINTSTS register (OEPINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the OTG_DAINT register to get the exact endpoint number for the OTG_DOEPINTx register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
        struct OTG_DOEPINT6 : public Register<0x49000bc8> {
            using XFRC = Field<0, 1>;    // XFRC
            using EPDISD = Field<1, 1>;    // EPDISD
            using AHBERR = Field<2, 1>;    // AHBERR
            using STUP = Field<3, 1>;    // STUP
            using OTEPDIS = Field<4, 1>;    // OTEPDIS
            using STSPHSRX = Field<5, 1>;    // STSPHSRX
            using B2BSTUP = Field<6, 1>;    // B2BSTUP
            using OUTPKTERR = Field<8, 1>;    // OUTPKTERR
            using BNA = Field<9, 1>;    // BNA
            using BERR = Field<12, 1>;    // BERR
            using NAK = Field<13, 1>;    // NAK
            using NYET = Field<14, 1>;    // NYET
            using STPKTRX = Field<15, 1>;    // STPKTRX
        };

        // The application must modify this register before enabling the endpoint. Once the endpoint is enabled using endpoint enable bit of the OTG_DOEPCTLx registers (EPENA bit in OTG_DOEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
        struct OTG_DOEPTSIZ6 : public Register<0x49000bd0> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using RXDPID_STUPCNT = Field<29, 2>;    // RXDPID_STUPCNT
        };

        // OTG device OUT endpoint 6 DMA address register
        struct OTG_DOEPDMA6 : public Register<0x49000bd4> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
        struct OTG_DOEPCTL7 : public Register<0x49000be0> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using USBAEP = Field<15, 1>;    // USBAEP
            using EONUM_DPIP = Field<16, 1>;    // EONUM_DPIP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EPTYP = Field<18, 2>;    // EPTYP
            using SNPM = Field<20, 1>;    // SNPM
            using STALL = Field<21, 1>;    // STALL
            using CNAK = Field<26, 1>;    // CNAK
            using SNAK = Field<27, 1>;    // SNAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID_SEVNFRM
            using SD1PID_SODDFRM = Field<29, 1>;    // SD1PID_SODDFRM
            using EPDIS = Field<30, 1>;    // EPDIS
            using EPENA = Field<31, 1>;    // EPENA
        };

        // This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the OUT endpoints interrupt bit of the OTG_GINTSTS register (OEPINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the OTG_DAINT register to get the exact endpoint number for the OTG_DOEPINTx register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
        struct OTG_DOEPINT7 : public Register<0x49000be8> {
            using XFRC = Field<0, 1>;    // XFRC
            using EPDISD = Field<1, 1>;    // EPDISD
            using AHBERR = Field<2, 1>;    // AHBERR
            using STUP = Field<3, 1>;    // STUP
            using OTEPDIS = Field<4, 1>;    // OTEPDIS
            using STSPHSRX = Field<5, 1>;    // STSPHSRX
            using B2BSTUP = Field<6, 1>;    // B2BSTUP
            using OUTPKTERR = Field<8, 1>;    // OUTPKTERR
            using BNA = Field<9, 1>;    // BNA
            using BERR = Field<12, 1>;    // BERR
            using NAK = Field<13, 1>;    // NAK
            using NYET = Field<14, 1>;    // NYET
            using STPKTRX = Field<15, 1>;    // STPKTRX
        };

        // The application must modify this register before enabling the endpoint. Once the endpoint is enabled using endpoint enable bit of the OTG_DOEPCTLx registers (EPENA bit in OTG_DOEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
        struct OTG_DOEPTSIZ7 : public Register<0x49000bf0> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using RXDPID_STUPCNT = Field<29, 2>;    // RXDPID_STUPCNT
        };

        // OTG device OUT endpoint 7 DMA address register
        struct OTG_DOEPDMA7 : public Register<0x49000bf4> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
        struct OTG_DOEPCTL8 : public Register<0x49000c00> {
            using MPSIZ = Field<0, 11>;    // MPSIZ
            using USBAEP = Field<15, 1>;    // USBAEP
            using EONUM_DPIP = Field<16, 1>;    // EONUM_DPIP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EPTYP = Field<18, 2>;    // EPTYP
            using SNPM = Field<20, 1>;    // SNPM
            using STALL = Field<21, 1>;    // STALL
            using CNAK = Field<26, 1>;    // CNAK
            using SNAK = Field<27, 1>;    // SNAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID_SEVNFRM
            using SD1PID_SODDFRM = Field<29, 1>;    // SD1PID_SODDFRM
            using EPDIS = Field<30, 1>;    // EPDIS
            using EPENA = Field<31, 1>;    // EPENA
        };

        // This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the OUT endpoints interrupt bit of the OTG_GINTSTS register (OEPINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the OTG_DAINT register to get the exact endpoint number for the OTG_DOEPINTx register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
        struct OTG_DOEPINT8 : public Register<0x49000c08> {
            using XFRC = Field<0, 1>;    // XFRC
            using EPDISD = Field<1, 1>;    // EPDISD
            using AHBERR = Field<2, 1>;    // AHBERR
            using STUP = Field<3, 1>;    // STUP
            using OTEPDIS = Field<4, 1>;    // OTEPDIS
            using STSPHSRX = Field<5, 1>;    // STSPHSRX
            using B2BSTUP = Field<6, 1>;    // B2BSTUP
            using OUTPKTERR = Field<8, 1>;    // OUTPKTERR
            using BNA = Field<9, 1>;    // BNA
            using BERR = Field<12, 1>;    // BERR
            using NAK = Field<13, 1>;    // NAK
            using NYET = Field<14, 1>;    // NYET
            using STPKTRX = Field<15, 1>;    // STPKTRX
        };

        // The application must modify this register before enabling the endpoint. Once the endpoint is enabled using endpoint enable bit of the OTG_DOEPCTLx registers (EPENA bit in OTG_DOEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
        struct OTG_DOEPTSIZ8 : public Register<0x49000c10> {
            using XFRSIZ = Field<0, 19>;    // XFRSIZ
            using PKTCNT = Field<19, 10>;    // PKTCNT
            using RXDPID_STUPCNT = Field<29, 2>;    // RXDPID_STUPCNT
        };

        // OTG device OUT endpoint 8 DMA address register
        struct OTG_DOEPDMA8 : public Register<0x49000c14> {
            using DMAADDR = Field<0, 32>;    // DMAADDR
        };

        // This register is available in host and device modes.
        struct OTG_PCGCCTL : public Register<0x49000e00> {
            using STPPCLK = Field<0, 1>;    // STPPCLK
            using GATEHCLK = Field<1, 1>;    // GATEHCLK
            using PHYSUSP = Field<4, 1>;    // PHYSUSP
            using ENL1GTG = Field<5, 1>;    // ENL1GTG
            using PHYSLEEP = Field<6, 1>;    // PHYSLEEP
            using SUSP = Field<7, 1>;    // SUSP
        };

    };

    // MDIOS
    struct MDIOS {
        // MDIOS configuration register
        struct MDIOS_CR : public Register<0x4001c000> {
            using EN = Field<0, 1>;    // EN
            using WRIE = Field<1, 1>;    // WRIE
            using RDIE = Field<2, 1>;    // RDIE
            using EIE = Field<3, 1>;    // EIE
            using DPC = Field<7, 1>;    // DPC
            using PORT_ADDRESS = Field<8, 5>;    // PORT_ADDRESS
        };

        // MDIOS write flag register
        struct MDIOS_WRFR : public RegisterReadOnly<0x4001c004> {
            using WRF = Field<0, 32>;    // WRF
        };

        // MDIOS clear write flag register
        struct MDIOS_CWRFR : public Register<0x4001c008> {
            using CWRF = Field<0, 32>;    // CWRF
        };

        // MDIOS read flag register
        struct MDIOS_RDFR : public RegisterReadOnly<0x4001c00c> {
            using RDF = Field<0, 32>;    // RDF
        };

        // MDIOS clear read flag register
        struct MDIOS_CRDFR : public Register<0x4001c010> {
            using CRDF = Field<0, 32>;    // CRDF
        };

        // MDIOS status register
        struct MDIOS_SR : public RegisterReadOnly<0x4001c014> {
            using PERF = Field<0, 1>;    // PERF
            using SERF = Field<1, 1>;    // SERF
            using TERF = Field<2, 1>;    // TERF
        };

        // MDIOS clear flag register
        struct MDIOS_CLRFR : public Register<0x4001c018> {
            using CPERF = Field<0, 1>;    // CPERF
            using CSERF = Field<1, 1>;    // CSERF
            using CTERF = Field<2, 1>;    // CTERF
        };

        // MDIOS input data register
        struct MDIOS_DINR0 : public RegisterReadOnly<0x4001c100> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR1 : public RegisterReadOnly<0x4001c104> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR2 : public RegisterReadOnly<0x4001c108> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR3 : public RegisterReadOnly<0x4001c10c> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR4 : public RegisterReadOnly<0x4001c110> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR5 : public RegisterReadOnly<0x4001c114> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR6 : public RegisterReadOnly<0x4001c118> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR7 : public RegisterReadOnly<0x4001c11c> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR8 : public RegisterReadOnly<0x4001c120> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR9 : public RegisterReadOnly<0x4001c124> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR10 : public RegisterReadOnly<0x4001c128> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR11 : public RegisterReadOnly<0x4001c12c> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR12 : public RegisterReadOnly<0x4001c130> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR13 : public RegisterReadOnly<0x4001c134> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR14 : public RegisterReadOnly<0x4001c138> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR15 : public RegisterReadOnly<0x4001c13c> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR16 : public RegisterReadOnly<0x4001c140> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR17 : public RegisterReadOnly<0x4001c144> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR18 : public RegisterReadOnly<0x4001c148> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR19 : public RegisterReadOnly<0x4001c14c> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR20 : public RegisterReadOnly<0x4001c150> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR21 : public RegisterReadOnly<0x4001c154> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR22 : public RegisterReadOnly<0x4001c158> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR23 : public RegisterReadOnly<0x4001c15c> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR24 : public RegisterReadOnly<0x4001c160> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR25 : public RegisterReadOnly<0x4001c164> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR26 : public RegisterReadOnly<0x4001c168> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR27 : public RegisterReadOnly<0x4001c16c> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR28 : public RegisterReadOnly<0x4001c170> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR29 : public RegisterReadOnly<0x4001c174> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR30 : public RegisterReadOnly<0x4001c178> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DINR31 : public RegisterReadOnly<0x4001c17c> {
            using DIN = Field<0, 16>;    // DIN
        };

        // MDIOS input data register
        struct MDIOS_DOUTR0 : public RegisterReadOnly<0x4001c180> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS input data register
        struct MDIOS_DOUTR1 : public RegisterReadOnly<0x4001c184> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR2 : public RegisterReadOnly<0x4001c188> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR3 : public RegisterReadOnly<0x4001c18c> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR4 : public RegisterReadOnly<0x4001c190> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR5 : public RegisterReadOnly<0x4001c194> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR6 : public RegisterReadOnly<0x4001c198> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR7 : public RegisterReadOnly<0x4001c19c> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR8 : public RegisterReadOnly<0x4001c1a0> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR9 : public RegisterReadOnly<0x4001c1a4> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR10 : public RegisterReadOnly<0x4001c1a8> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR11 : public RegisterReadOnly<0x4001c1ac> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR12 : public RegisterReadOnly<0x4001c1b0> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR13 : public RegisterReadOnly<0x4001c1b4> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR14 : public RegisterReadOnly<0x4001c1b8> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR15 : public RegisterReadOnly<0x4001c1bc> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR16 : public RegisterReadOnly<0x4001c1c0> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR17 : public RegisterReadOnly<0x4001c1c4> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR18 : public RegisterReadOnly<0x4001c1c8> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR19 : public RegisterReadOnly<0x4001c1cc> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR20 : public RegisterReadOnly<0x4001c1d0> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR21 : public RegisterReadOnly<0x4001c1d4> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR22 : public RegisterReadOnly<0x4001c1d8> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR23 : public RegisterReadOnly<0x4001c1dc> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR24 : public RegisterReadOnly<0x4001c1e0> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR25 : public RegisterReadOnly<0x4001c1e4> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR26 : public RegisterReadOnly<0x4001c1e8> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR27 : public RegisterReadOnly<0x4001c1ec> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR28 : public RegisterReadOnly<0x4001c1f0> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR29 : public RegisterReadOnly<0x4001c1f4> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR30 : public RegisterReadOnly<0x4001c1f8> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS output data register
        struct MDIOS_DOUTR31 : public RegisterReadOnly<0x4001c1fc> {
            using DOUT = Field<0, 16>;    // DOUT
        };

        // MDIOS HW configuration register
        struct MDIOS_HWCFGR : public RegisterReadOnly<0x4001c3f0> {
            using NBREG = Field<0, 8>;    // NBREG
        };

        // MDIOS version register
        struct MDIOS_VERR : public RegisterReadOnly<0x4001c3f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // MDIOS identification register
        struct MDIOS_IPIDR : public RegisterReadOnly<0x4001c3f8> {
            using ID = Field<0, 32>;    // ID
        };

        // MDIOS size identification register
        struct MDIOS_SIDR : public RegisterReadOnly<0x4001c3fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // HDMI_CEC
    struct HDMI_CEC {
        // CEC control register
        struct CEC_CR : public Register<0x40016000> {
            using CECEN = Field<0, 1>;    // CECEN
            using TXSOM = Field<1, 1>;    // TXSOM
            using TXEOM = Field<2, 1>;    // TXEOM
        };

        // This register is used to configure the HDMI-CEC controller. It is mandatory to write CEC_CFGR only when CECEN=0.
        struct CEC_CFGR : public Register<0x40016004> {
            using SFT = Field<0, 3>;    // SFT
            using RXTOL = Field<3, 1>;    // RXTOL
            using BRESTP = Field<4, 1>;    // BRESTP
            using BREGEN = Field<5, 1>;    // BREGEN
            using LBPEGEN = Field<6, 1>;    // LBPEGEN
            using BRDNOGEN = Field<7, 1>;    // BRDNOGEN
            using SFTOP = Field<8, 1>;    // SFTOP
            using OAR = Field<16, 15>;    // OAR
            using LSTN = Field<31, 1>;    // LSTN
        };

        // CEC Tx data register
        struct CEC_TXDR : public Register<0x40016008> {
            using TXD = Field<0, 8>;    // TXD
        };

        // CEC Rx data register
        struct CEC_RXDR : public RegisterReadOnly<0x4001600c> {
            using RXD = Field<0, 8>;    // RXD
        };

        // CEC Interrupt and Status Register
        struct CEC_ISR : public Register<0x40016010> {
            using RXBR = Field<0, 1>;    // RXBR
            using RXEND = Field<1, 1>;    // RXEND
            using RXOVR = Field<2, 1>;    // RXOVR
            using BRE = Field<3, 1>;    // BRE
            using SBPE = Field<4, 1>;    // SBPE
            using LBPE = Field<5, 1>;    // LBPE
            using RXACKE = Field<6, 1>;    // RXACKE
            using ARBLST = Field<7, 1>;    // ARBLST
            using TXBR = Field<8, 1>;    // TXBR
            using TXEND = Field<9, 1>;    // TXEND
            using TXUDR = Field<10, 1>;    // TXUDR
            using TXERR = Field<11, 1>;    // TXERR
            using TXACKE = Field<12, 1>;    // TXACKE
        };

        // CEC interrupt enable register
        struct CEC_IER : public Register<0x40016014> {
            using RXBRIE = Field<0, 1>;    // RXBRIE
            using RXENDIE = Field<1, 1>;    // RXENDIE
            using RXOVRIE = Field<2, 1>;    // RXOVRIE
            using BREIE = Field<3, 1>;    // BREIE
            using SBPEIE = Field<4, 1>;    // SBPEIE
            using LBPEIE = Field<5, 1>;    // LBPEIE
            using RXACKIE = Field<6, 1>;    // RXACKIE
            using ARBLSTIE = Field<7, 1>;    // ARBLSTIE
            using TXBRIE = Field<8, 1>;    // TXBRIE
            using TXENDIE = Field<9, 1>;    // TXENDIE
            using TXUDRIE = Field<10, 1>;    // TXUDRIE
            using TXERRIE = Field<11, 1>;    // TXERRIE
            using TXACKIE = Field<12, 1>;    // TXACKIE
        };

    };

    // SPDIFRX
    struct SPDIFRX {
        // Control register
        struct SPDIFRX_CR : public Register<0x4000d000> {
            using SPDIFRXEN = Field<0, 2>;    // SPDIFRXEN
            using RXDMAEN = Field<2, 1>;    // RXDMAEN
            using RXSTEO = Field<3, 1>;    // RXSTEO
            using DRFMT = Field<4, 2>;    // DRFMT
            using PMSK = Field<6, 1>;    // PMSK
            using VMSK = Field<7, 1>;    // VMSK
            using CUMSK = Field<8, 1>;    // CUMSK
            using PTMSK = Field<9, 1>;    // PTMSK
            using CBDMAEN = Field<10, 1>;    // CBDMAEN
            using CHSEL = Field<11, 1>;    // CHSEL
            using NBTR = Field<12, 2>;    // NBTR
            using WFA = Field<14, 1>;    // WFA
            using INSEL = Field<16, 3>;    // INSEL
            using CKSEN = Field<20, 1>;    // CKSEN
            using CKSBKPEN = Field<21, 1>;    // CKSBKPEN
        };

        // Interrupt mask register
        struct SPDIFRX_IMR : public Register<0x4000d004> {
            using RXNEIE = Field<0, 1>;    // RXNEIE
            using CSRNEIE = Field<1, 1>;    // CSRNEIE
            using PERRIE = Field<2, 1>;    // PERRIE
            using OVRIE = Field<3, 1>;    // OVRIE
            using SBLKIE = Field<4, 1>;    // SBLKIE
            using SYNCDIE = Field<5, 1>;    // SYNCDIE
            using IFEIE = Field<6, 1>;    // IFEIE
        };

        // Status register
        struct SPDIFRX_SR : public RegisterReadOnly<0x4000d008> {
            using RXNE = Field<0, 1>;    // RXNE
            using CSRNE = Field<1, 1>;    // CSRNE
            using PERR = Field<2, 1>;    // PERR
            using OVR = Field<3, 1>;    // OVR
            using SBD = Field<4, 1>;    // SBD
            using SYNCD = Field<5, 1>;    // SYNCD
            using FERR = Field<6, 1>;    // FERR
            using SERR = Field<7, 1>;    // SERR
            using TERR = Field<8, 1>;    // TERR
            using WIDTH5 = Field<16, 15>;    // WIDTH5
        };

        // Interrupt flag clear register
        struct SPDIFRX_IFCR : public Register<0x4000d00c> {
            using PERRCF = Field<2, 1>;    // PERRCF
            using OVRCF = Field<3, 1>;    // OVRCF
            using SBDCF = Field<4, 1>;    // SBDCF
            using SYNCDCF = Field<5, 1>;    // SYNCDCF
        };

        // This register can take 3 different formats according to DRFMT. Here is the format when DRFMT = 00:
        struct SPDIFRX_FMT0_DR : public RegisterReadOnly<0x4000d010> {
            using DR = Field<0, 24>;    // DR
            using PE = Field<24, 1>;    // PE
            using V = Field<25, 1>;    // V
            using U = Field<26, 1>;    // U
            using C = Field<27, 1>;    // C
            using PT = Field<28, 2>;    // PT
        };

        // Channel status register
        struct SPDIFRX_CSR : public RegisterReadOnly<0x4000d014> {
            using USR = Field<0, 16>;    // USR
            using CS = Field<16, 8>;    // CS
            using SOB = Field<24, 1>;    // SOB
        };

        // Debug information register
        struct SPDIFRX_DIR : public RegisterReadOnly<0x4000d018> {
            using THI = Field<0, 13>;    // THI
            using TLO = Field<16, 13>;    // TLO
        };

        // SPDIFRX version register
        struct SPDIFRX_VERR : public RegisterReadOnly<0x4000d3f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // SPDIFRX identification register
        struct SPDIFRX_IPIDR : public RegisterReadOnly<0x4000d3f8> {
            using ID = Field<0, 32>;    // ID
        };

        // SPDIFRX size identification register
        struct SPDIFRX_SIDR : public RegisterReadOnly<0x4000d3fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // WWDG1
    struct WWDG1 {
        // Control register
        struct WWDG_CR : public Register<0x4000a000> {
            using T = Field<0, 7>;    // T
            using WDGA = Field<7, 1>;    // WDGA
        };

        // Configuration register
        struct WWDG_CFR : public Register<0x4000a004> {
            using W = Field<0, 7>;    // W
            using EWI = Field<9, 1>;    // EWI
            using WDGTB = Field<11, 3>;    // WDGTB
        };

        // Status register
        struct WWDG_SR : public Register<0x4000a008> {
            using EWIF = Field<0, 1>;    // EWIF
        };

        // WWDG hardware configuration register
        struct WWDG_HWCFGR : public RegisterReadOnly<0x4000a3f0> {
            using PREDIV = Field<0, 16>;    // PREDIV
        };

        // WWDG version register
        struct WWDG_VERR : public RegisterReadOnly<0x4000a3f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // WWDG ID register
        struct WWDG_IPIDR : public RegisterReadOnly<0x4000a3f8> {
            using ID = Field<0, 32>;    // ID
        };

        // WWDG size ID register
        struct WWDG_SIDR : public RegisterReadOnly<0x4000a3fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // AXIMC_Mx
    struct AXIMC_Mx {
        // AXIMC master 0 packing functionality register
        struct AXIMC_M0_FN_MOD2 : public Register<0x57042024> {
            using BYPASS_MERGE = Field<0, 1>;    // BYPASS_MERGE
        };

        // AXIMC master 0 read priority register
        struct AXIMC_M0_READ_QOS : public Register<0x57042100> {
            using AR_QOS = Field<0, 4>;    // AR_QOS
        };

        // AXIMC master 0 write priority register
        struct AXIMC_M0_WRITE_QOS : public Register<0x57042108> {
            using AW_QOS = Field<0, 4>;    // AW_QOS
        };

        // AXIMC master 0 issuing capability override functionality register
        struct AXIMC_M0_FN_MOD : public Register<0x57042104> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // READ_ISS_OVERRIDE
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // WRITE_ISS_OVERRIDE
        };

        // AXIMC master 1 packing functionality register
        struct AXIMC_M1_FN_MOD2 : public Register<0x57043024> {
            using BYPASS_MERGE = Field<0, 1>;    // BYPASS_MERGE
        };

        // AXIMC master 1 read priority register
        struct AXIMC_M1_READ_QOS : public Register<0x57043100> {
            using AR_QOS = Field<0, 4>;    // AR_QOS
        };

        // AXIMC master 1 write priority register
        struct AXIMC_M1_WRITE_QOS : public Register<0x57043104> {
            using AW_QOS = Field<0, 4>;    // AW_QOS
        };

        // AXIMC master 1 issuing capability override functionality register
        struct AXIMC_M1_FN_MOD : public Register<0x57043108> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // READ_ISS_OVERRIDE
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // WRITE_ISS_OVERRIDE
        };

        // AXIMC master 2 packing functionality register
        struct AXIMC_M2_FN_MOD2 : public Register<0x57044024> {
            using BYPASS_MERGE = Field<0, 1>;    // BYPASS_MERGE
        };

        // AXIMC master 2 read priority register
        struct AXIMC_M2_READ_QOS : public Register<0x57044100> {
            using AR_QOS = Field<0, 4>;    // AR_QOS
        };

        // AXIMC master 2 write priority register
        struct AXIMC_M2_WRITE_QOS : public Register<0x57044104> {
            using AW_QOS = Field<0, 4>;    // AW_QOS
        };

        // AXIMC master 2 issuing capability override functionality register
        struct AXIMC_M2_FN_MOD : public Register<0x57044108> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // READ_ISS_OVERRIDE
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // WRITE_ISS_OVERRIDE
        };

        // AXIMC master 5 packing functionality register
        struct AXIMC_M5_FN_MOD2 : public Register<0x57045024> {
            using BYPASS_MERGE = Field<0, 1>;    // BYPASS_MERGE
        };

        // AXIMC master 5 read priority register
        struct AXIMC_M5_READ_QOS : public Register<0x57045100> {
            using AR_QOS = Field<0, 4>;    // AR_QOS
        };

        // AXIMC master 5 write priority register
        struct AXIMC_M5_WRITE_QOS : public Register<0x57045104> {
            using AW_QOS = Field<0, 4>;    // AW_QOS
        };

        // AXIMC master 5 issuing capability override functionality register
        struct AXIMC_M5_FN_MOD : public Register<0x57045108> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // READ_ISS_OVERRIDE
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // WRITE_ISS_OVERRIDE
        };

        // AXIMC master 3 read priority register
        struct AXIMC_M3_READ_QOS : public Register<0x57046100> {
            using AR_QOS = Field<0, 4>;    // AR_QOS
        };

        // AXIMC master 3 write priority register
        struct AXIMC_M3_WRITE_QOS : public Register<0x57046104> {
            using AW_QOS = Field<0, 4>;    // AW_QOS
        };

        // AXIMC master 3 packing functionality register
        struct AXIMC_M3_FN_MOD : public Register<0x57046108> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // READ_ISS_OVERRIDE
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // WRITE_ISS_OVERRIDE
        };

        // AXIMC master 7 read priority register
        struct AXIMC_M7_READ_QOS : public Register<0x57047100> {
            using AR_QOS = Field<0, 4>;    // AR_QOS
        };

        // AXIMC master 7 write priority register
        struct AXIMC_M7_WRITE_QOS : public Register<0x57047104> {
            using AW_QOS = Field<0, 4>;    // AW_QOS
        };

        // AXIMC master 7 issuing capability override functionality register
        struct AXIMC_M7_FN_MOD : public Register<0x57047108> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // READ_ISS_OVERRIDE
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // WRITE_ISS_OVERRIDE
        };

        // AXIMC master 8 read priority register
        struct AXIMC_M8_READ_QOS : public Register<0x57048100> {
            using AR_QOS = Field<0, 4>;    // AR_QOS
        };

        // AXIMC master 8 write priority register
        struct AXIMC_M8_WRITE_QOS : public Register<0x57048104> {
            using AW_QOS = Field<0, 4>;    // AW_QOS
        };

        // AXIMC master 8 issuing capability override functionality register
        struct AXIMC_M8_FN_MOD : public Register<0x57048108> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // READ_ISS_OVERRIDE
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // WRITE_ISS_OVERRIDE
        };

        // AXIMC master 4 packing functionality register
        struct AXIMC_M4_FN_MOD2 : public Register<0x5704a024> {
            using BYPASS_MERGE = Field<0, 1>;    // BYPASS_MERGE
        };

        // AXIMC master 4 read priority register
        struct AXIMC_M4_READ_QOS : public Register<0x5704a100> {
            using AR_QOS = Field<0, 4>;    // AR_QOS
        };

        // AXIMC master 4 write priority register
        struct AXIMC_M4_WRITE_QOS : public Register<0x5704a104> {
            using AW_QOS = Field<0, 4>;    // AW_QOS
        };

        // AXIMC master 4 packing functionality register
        struct AXIMC_M4_FN_MOD : public Register<0x5704a108> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // READ_ISS_OVERRIDE
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // WRITE_ISS_OVERRIDE
        };

        // AXIMC master 9 read priority register
        struct AXIMC_M9_READ_QOS : public Register<0x5704b100> {
            using AR_QOS = Field<0, 4>;    // AR_QOS
        };

        // AXIMC master 9 write priority register
        struct AXIMC_M9_WRITE_QOS : public Register<0x5704b104> {
            using AW_QOS = Field<0, 4>;    // AW_QOS
        };

        // AXIMC master 9 issuing capability override functionality register
        struct AXIMC_M9_FN_MOD : public Register<0x5704b108> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // READ_ISS_OVERRIDE
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // WRITE_ISS_OVERRIDE
        };

        // AXIMC master 10 read priority register
        struct AXIMC_M10_READ_QOS : public Register<0x5704c100> {
            using AR_QOS = Field<0, 4>;    // AR_QOS
        };

        // AXIMC master 10 write priority register
        struct AXIMC_M10_WRITE_QOS : public Register<0x5704c104> {
            using AW_QOS = Field<0, 4>;    // AW_QOS
        };

        // AXIMC master 10 issuing capability override functionality register
        struct AXIMC_M10_FN_MOD : public Register<0x5704c108> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // READ_ISS_OVERRIDE
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // WRITE_ISS_OVERRIDE
        };

        // AXIMC master 6 packing functionality register
        struct AXIMC_M6_FN_MOD2 : public Register<0x5704d024> {
            using BYPASS_MERGE = Field<0, 1>;    // BYPASS_MERGE
        };

        // AXIMC master 6 read priority register
        struct AXIMC_M6_READ_QOS : public Register<0x5704d100> {
            using AR_QOS = Field<0, 4>;    // AR_QOS
        };

        // AXIMC master 6 write priority register
        struct AXIMC_M6_WRITE_QOS : public Register<0x5704d104> {
            using AW_QOS = Field<0, 4>;    // AW_QOS
        };

        // AXIMC master 6 issuing capability override functionality register
        struct AXIMC_M6_FN_MOD : public Register<0x5704d108> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // READ_ISS_OVERRIDE
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // WRITE_ISS_OVERRIDE
        };

        // AXIMC peripheral ID4 register
        struct AXIMC_PERIPH_ID_4 : public RegisterReadOnly<0x57043ff4> {
            using JEP106CON = Field<0, 4>;    // JEP106CON
            using K4COUNT = Field<4, 4>;    // K4COUNT
        };

        // AXIMC peripheral ID5 register
        struct AXIMC_PERIPH_ID_5 : public RegisterReadOnly<0x57043ff8> {
            using PERIPH_ID_5 = Field<0, 8>;    // PERIPH_ID_5
        };

        // AXIMC peripheral ID6 register
        struct AXIMC_PERIPH_ID_6 : public RegisterReadOnly<0x57043ffc> {
            using PERIPH_ID_6 = Field<0, 8>;    // PERIPH_ID_6
        };

        // AXIMC peripheral ID7 register
        struct AXIMC_PERIPH_ID_7 : public RegisterReadOnly<0x57044000> {
            using PERIPH_ID_7 = Field<0, 8>;    // PERIPH_ID_7
        };

        // AXIMC peripheral ID0 register
        struct AXIMC_PERIPH_ID_0 : public RegisterReadOnly<0x57044004> {
            using PERIPH_ID_0 = Field<0, 8>;    // PERIPH_ID_0
        };

        // AXIMC peripheral ID1 register
        struct AXIMC_PERIPH_ID_1 : public RegisterReadOnly<0x57044008> {
            using PERIPH_ID_1 = Field<0, 8>;    // PERIPH_ID_1
        };

        // AXIMC peripheral ID2 register
        struct AXIMC_PERIPH_ID_2 : public RegisterReadOnly<0x5704400c> {
            using PERIPH_ID_2 = Field<0, 8>;    // PERIPH_ID_2
        };

        // AXIMC peripheral ID3 register
        struct AXIMC_PERIPH_ID_3 : public RegisterReadOnly<0x57044010> {
            using CUST_MOD_NUM = Field<0, 4>;    // CUST_MOD_NUM
            using REV_AND = Field<4, 4>;    // REV_AND
        };

        // AXIMC component ID0 register
        struct AXIMC_COMP_ID_0 : public RegisterReadOnly<0x57044014> {
            using PREAMBLE = Field<0, 8>;    // PREAMBLE
        };

        // AXIMC component ID1 register
        struct AXIMC_COMP_ID_1 : public RegisterReadOnly<0x57044018> {
            using PREAMBLE = Field<0, 4>;    // PREAMBLE
            using CLASS = Field<4, 4>;    // CLASS
        };

        // AXIMC component ID2 register
        struct AXIMC_COMP_ID_2 : public RegisterReadOnly<0x5704401c> {
            using PREAMBLE = Field<0, 8>;    // PREAMBLE
        };

        // AXIMC component ID3 register
        struct AXIMC_COMP_ID_3 : public RegisterReadOnly<0x57044020> {
            using PREAMBLE = Field<0, 8>;    // PREAMBLE
        };

        // AXIMC master 0 AHB conversion override functionality register
        struct AXIMC_M0_FN_MOD_AHB : public Register<0x5708404c> {
            using RD_INC_OVERRIDE = Field<0, 1>;    // RD_INC_OVERRIDE
            using WR_INC_OVERRIDE = Field<1, 1>;    // WR_INC_OVERRIDE
        };

        // AXIMC master 1 AHB conversion override functionality register
        struct AXIMC_M1_FN_MOD_AHB : public Register<0x5708504c> {
            using RD_INC_OVERRIDE = Field<0, 1>;    // RD_INC_OVERRIDE
            using WR_INC_OVERRIDE = Field<1, 1>;    // WR_INC_OVERRIDE
        };

        // AXIMC master 2 AHB conversion override functionality register
        struct AXIMC_M2_FN_MOD_AHB : public Register<0x5708604c> {
            using RD_INC_OVERRIDE = Field<0, 1>;    // RD_INC_OVERRIDE
            using WR_INC_OVERRIDE = Field<1, 1>;    // WR_INC_OVERRIDE
        };

        // AXIMC master 5 AHB conversion override functionality register
        struct AXIMC_M5_FN_MOD_AHB : public Register<0x5708704c> {
            using RD_INC_OVERRIDE = Field<0, 1>;    // RD_INC_OVERRIDE
            using WR_INC_OVERRIDE = Field<1, 1>;    // WR_INC_OVERRIDE
        };

        // AXIMC master 6 AHB conversion override functionality register
        struct AXIMC_M6_FN_MOD_AHB : public Register<0x5708f04c> {
            using RD_INC_OVERRIDE = Field<0, 1>;    // RD_INC_OVERRIDE
            using WR_INC_OVERRIDE = Field<1, 1>;    // WR_INC_OVERRIDE
        };

        // AXIMC long burst capability inhibition register
        struct AXIMC_FN_MOD_LB : public Register<0x5708c050> {
            using FN_MOD_LB = Field<0, 1>;    // FN_MOD_LB
        };

    };

    // TZC
    struct TZC {
        // Provides information about TZC configuration.
        struct TZC_BUILD_CONFIG : public RegisterReadOnly<0x5c006000> {
            using NO_OF_REGIONS = Field<0, 5>;    // NO_OF_REGIONS
            using ADDRESS_WIDTH = Field<8, 6>;    // ADDRESS_WIDTH
            using NO_OF_FILTERS = Field<24, 2>;    // NO_OF_FILTERS
        };

        // Controls interrupt and bus error response behavior when regions permission failures occur.
        struct TZC_ACTION : public Register<0x5c006004> {
            using REACTION_VALUE = Field<0, 2>;    // REACTION_VALUE
        };

        // Provides control and status for the gate keeper in each filter unit implemented.
        struct TZC_GATE_KEEPER : public Register<0x5c006008> {
            using OPENREQ = Field<0, 2>;    // OPENREQ
            using OPENSTAT = Field<16, 2>;    // OPENSTAT
        };

        // Controls read and write access speculation.
        struct TZC_SPECULATION_CTRL : public Register<0x5c00600c> {
            using READSPEC_DISABLE = Field<0, 1>;    // READSPEC_DISABLE
            using WRITESPEC_DISABLE = Field<1, 1>;    // WRITESPEC_DISABLE
        };

        // Contains the status of the interrupt signal, TZCINT, that reports access security violations or region overlap errors.
        struct TZC_INT_STATUS : public RegisterReadOnly<0x5c006010> {
            using STATUS = Field<0, 2>;    // STATUS
            using OVERRUN = Field<8, 2>;    // OVERRUN
            using OVERLAP = Field<16, 2>;    // OVERLAP
        };

        // Interrupt clear for each filter.
        struct TZC_INT_CLEAR : public Register<0x5c006014> {
            using CLEAR = Field<0, 2>;    // CLEAR
        };

        // Status information about the first access that failed a region permission check in the associated filter (0 to 1).
        struct TZC_FAIL_CONTROL0 : public RegisterReadOnly<0x5c006028> {
            using PRIVILEGE = Field<20, 1>;    // PRIVILEGE
            using NON_SECURE = Field<21, 1>;    // NON_SECURE
            using DIRECTION = Field<24, 1>;    // DIRECTION
        };

        // Contains the master AXI ARID or AWID of the first access that failed a region permission check in the associated filter unit. This occurs even if the ACTION register is set to not drive the interrupt signal. AXI ID mapping is described in Table4: NSAID definition table (TBD).
        struct TZC_FAIL_ID0 : public RegisterReadOnly<0x5c00602c> {
            using ID = Field<0, 11>;    // ID
        };

        // Status information about the first access that failed a region permission check in the associated filter (0 to 1).
        struct TZC_FAIL_CONTROL1 : public RegisterReadOnly<0x5c006038> {
            using PRIVILEGE = Field<20, 1>;    // PRIVILEGE
            using NON_SECURE = Field<21, 1>;    // NON_SECURE
            using DIRECTION = Field<24, 1>;    // DIRECTION
        };

        // Contains the master AXI ARID or AWID of the first access that failed a region permission check in the associated filter unit. This occurs even if the ACTION register is set to not drive the interrupt signal. AXI ID mapping is described in Table4: NSAID definition table (TBD).
        struct TZC_FAIL_ID1 : public RegisterReadOnly<0x5c00603c> {
            using ID = Field<0, 11>;    // ID
        };

        // Region 0 attributes.
        struct TZC_REGION_ATTRIBUTE0 : public Register<0x5c006110> {
            using FILTER_EN = Field<0, 2>;    // FILTER_EN
            using S_RD_EN = Field<30, 1>;    // S_RD_EN
            using S_WR_EN = Field<31, 1>;    // S_WR_EN
        };

        // Region x attributes.
        struct TZC_REGION_ATTRIBUTE1 : public Register<0x5c006130> {
            using FILTER_EN = Field<0, 2>;    // FILTER_EN
            using S_RD_EN = Field<30, 1>;    // S_RD_EN
            using S_WR_EN = Field<31, 1>;    // S_WR_EN
        };

        // Region x attributes.
        struct TZC_REGION_ATTRIBUTE2 : public Register<0x5c006150> {
            using FILTER_EN = Field<0, 2>;    // FILTER_EN
            using S_RD_EN = Field<30, 1>;    // S_RD_EN
            using S_WR_EN = Field<31, 1>;    // S_WR_EN
        };

        // Region x attributes.
        struct TZC_REGION_ATTRIBUTE3 : public Register<0x5c006170> {
            using FILTER_EN = Field<0, 2>;    // FILTER_EN
            using S_RD_EN = Field<30, 1>;    // S_RD_EN
            using S_WR_EN = Field<31, 1>;    // S_WR_EN
        };

        // Region x attributes.
        struct TZC_REGION_ATTRIBUTE4 : public Register<0x5c006190> {
            using FILTER_EN = Field<0, 2>;    // FILTER_EN
            using S_RD_EN = Field<30, 1>;    // S_RD_EN
            using S_WR_EN = Field<31, 1>;    // S_WR_EN
        };

        // Region x attributes.
        struct TZC_REGION_ATTRIBUTE5 : public Register<0x5c0061b0> {
            using FILTER_EN = Field<0, 2>;    // FILTER_EN
            using S_RD_EN = Field<30, 1>;    // S_RD_EN
            using S_WR_EN = Field<31, 1>;    // S_WR_EN
        };

        // Region x attributes.
        struct TZC_REGION_ATTRIBUTE6 : public Register<0x5c0061d0> {
            using FILTER_EN = Field<0, 2>;    // FILTER_EN
            using S_RD_EN = Field<30, 1>;    // S_RD_EN
            using S_WR_EN = Field<31, 1>;    // S_WR_EN
        };

        // Region x attributes.
        struct TZC_REGION_ATTRIBUTE7 : public Register<0x5c0061f0> {
            using FILTER_EN = Field<0, 2>;    // FILTER_EN
            using S_RD_EN = Field<30, 1>;    // S_RD_EN
            using S_WR_EN = Field<31, 1>;    // S_WR_EN
        };

        // Region x attributes.
        struct TZC_REGION_ATTRIBUTE8 : public Register<0x5c006210> {
            using FILTER_EN = Field<0, 2>;    // FILTER_EN
            using S_RD_EN = Field<30, 1>;    // S_RD_EN
            using S_WR_EN = Field<31, 1>;    // S_WR_EN
        };

        // Peripheral ID 4.
        struct TZC_PID4 : public RegisterReadOnly<0x5c006fd0> {
            using PER_ID_4 = Field<0, 8>;    // PER_ID_4
        };

        // Peripheral ID 5.
        struct TZC_PID5 : public RegisterReadOnly<0x5c006fd4> {
            using PER_ID_5 = Field<0, 8>;    // PER_ID_5
        };

        // Peripheral ID 6.
        struct TZC_PID6 : public RegisterReadOnly<0x5c006fd8> {
            using PER_ID_6 = Field<0, 8>;    // PER_ID_6
        };

        // Peripheral ID 7.
        struct TZC_PID7 : public RegisterReadOnly<0x5c006fdc> {
            using PER_ID_7 = Field<0, 8>;    // PER_ID_7
        };

        // Peripheral ID 0.
        struct TZC_PID0 : public RegisterReadOnly<0x5c006fe0> {
            using PER_ID_0 = Field<0, 8>;    // PER_ID_0
        };

        // Peripheral ID 1.
        struct TZC_PID1 : public RegisterReadOnly<0x5c006fe4> {
            using PER_ID_1 = Field<0, 8>;    // PER_ID_1
        };

        // Peripheral ID 2.
        struct TZC_PID2 : public RegisterReadOnly<0x5c006fe8> {
            using PER_ID_2 = Field<0, 8>;    // PER_ID_2
        };

        // Peripheral ID 3.
        struct TZC_PID3 : public RegisterReadOnly<0x5c006fec> {
            using PER_ID_3 = Field<0, 8>;    // PER_ID_3
        };

        // Component ID 0.
        struct TZC_CID0 : public RegisterReadOnly<0x5c006ff0> {
            using COMP_ID_0 = Field<0, 8>;    // COMP_ID_0
        };

        // Component ID 1.
        struct TZC_CID1 : public RegisterReadOnly<0x5c006ff4> {
            using COMP_ID_1 = Field<0, 8>;    // COMP_ID_1
        };

        // Component ID 2.
        struct TZC_CID2 : public RegisterReadOnly<0x5c006ff8> {
            using COMP_ID_2 = Field<0, 8>;    // COMP_ID_2
        };

        // Component ID 3.
        struct TZC_CID3 : public RegisterReadOnly<0x5c006ffc> {
            using COMP_ID_3 = Field<0, 8>;    // COMP_ID_3
        };

        // Address low bits of the first failed access in the associated filter (0 to 1).
        struct TZC_FAIL_ADDRESS_LOW0 : public RegisterReadOnly<0x5c006020> {
            using ADDR_STATUS_LOW = Field<0, 32>;    // ADDR_STATUS_LOW
        };

        // Address high bit of the first failed access in the associated filter (0 to 1). Not used with 32bit address.
        struct TZC_FAIL_ADDRESS_HIGH0 : public RegisterReadOnly<0x5c006024> {
        };

        // Address low bits of the first failed access in the associated filter (0 to 1).
        struct TZC_FAIL_ADDRESS_LOW1 : public RegisterReadOnly<0x5c006030> {
            using ADDR_STATUS_LOW = Field<0, 32>;    // ADDR_STATUS_LOW
        };

        // Address high bit of the first failed access in the associated filter (0 to 1). Not used with 32bit address.
        struct TZC_FAIL_ADDRESS_HIGH1 : public RegisterReadOnly<0x5c006034> {
        };

        // Base address high are not used with 32-bit address.
        struct TZC_REGION_BASE_HIGH0 : public RegisterReadOnly<0x5c006104> {
        };

        // Top address bits [31:12] for region 0.
        struct TZC_REGION_TOP_LOW0 : public RegisterReadOnly<0x5c006108> {
            using TOP_ADDRESS_LOW = Field<12, 20>;    // TOP_ADDRESS_LOW
        };

        // Top address high of region are not used with 32-bit address.
        struct TZC_REGION_TOP_HIGH0 : public RegisterReadOnly<0x5c00610c> {
        };

        // Region non-secure access based on NSAID.
        struct TZC_REGION_ID_ACCESS0 : public Register<0x5c006114> {
            using NSAID_RD_EN = Field<0, 16>;    // NSAID_RD_EN
            using NSAID_WR_EN = Field<16, 16>;    // NSAID_WR_EN
        };

        // Base address low for regions 1 to 8.
        struct TZC_REGION_BASE_LOW1 : public Register<0x5c006120> {
            using BASE_ADDRESS_LOW = Field<12, 20>;    // BASE_ADDRESS_LOW
        };

        // Base address high are not used with 32-bit address.
        struct TZC_REGION_BASE_HIGH1 : public RegisterReadOnly<0x5c006124> {
        };

        // Top address bits [31:12] for region x.
        struct TZC_REGION_TOP_LOW1 : public Register<0x5c006128> {
            using TOP_ADDRESS_LOW = Field<12, 20>;    // TOP_ADDRESS_LOW
        };

        // Top address high of region are not used with 32-bit address.
        struct TZC_REGION_TOP_HIGH1 : public RegisterReadOnly<0x5c00612c> {
        };

        // Region non-secure access based on NSAID.
        struct TZC_REGION_ID_ACCESS1 : public Register<0x5c006134> {
            using NSAID_RD_EN = Field<0, 16>;    // NSAID_RD_EN
            using NSAID_WR_EN = Field<16, 16>;    // NSAID_WR_EN
        };

        // Base address low for regions 1 to 8.
        struct TZC_REGION_BASE_LOW2 : public Register<0x5c006140> {
            using BASE_ADDRESS_LOW = Field<12, 20>;    // BASE_ADDRESS_LOW
        };

        // Base address high are not used with 32-bit address.
        struct TZC_REGION_BASE_HIGH2 : public RegisterReadOnly<0x5c006144> {
        };

        // Top address bits [31:12] for region x.
        struct TZC_REGION_TOP_LOW2 : public Register<0x5c006148> {
            using TOP_ADDRESS_LOW = Field<12, 20>;    // TOP_ADDRESS_LOW
        };

        // Top address high of region are not used with 32-bit address.
        struct TZC_REGION_TOP_HIGH2 : public RegisterReadOnly<0x5c00614c> {
        };

        // Region non-secure access based on NSAID.
        struct TZC_REGION_ID_ACCESS2 : public Register<0x5c006154> {
            using NSAID_RD_EN = Field<0, 16>;    // NSAID_RD_EN
            using NSAID_WR_EN = Field<16, 16>;    // NSAID_WR_EN
        };

        // Base address low for regions 1 to 8.
        struct TZC_REGION_BASE_LOW3 : public Register<0x5c006160> {
            using BASE_ADDRESS_LOW = Field<12, 20>;    // BASE_ADDRESS_LOW
        };

        // Base address high are not used with 32-bit address.
        struct TZC_REGION_BASE_HIGH3 : public RegisterReadOnly<0x5c006164> {
        };

        // Top address bits [31:12] for region x.
        struct TZC_REGION_TOP_LOW3 : public Register<0x5c006168> {
            using TOP_ADDRESS_LOW = Field<12, 20>;    // TOP_ADDRESS_LOW
        };

        // Top address high of region are not used with 32-bit address.
        struct TZC_REGION_TOP_HIGH3 : public RegisterReadOnly<0x5c00616c> {
        };

        // Region non-secure access based on NSAID.
        struct TZC_REGION_ID_ACCESS3 : public Register<0x5c006174> {
            using NSAID_RD_EN = Field<0, 16>;    // NSAID_RD_EN
            using NSAID_WR_EN = Field<16, 16>;    // NSAID_WR_EN
        };

        // Base address low for regions 1 to 8.
        struct TZC_REGION_BASE_LOW4 : public Register<0x5c006180> {
            using BASE_ADDRESS_LOW = Field<12, 20>;    // BASE_ADDRESS_LOW
        };

        // Base address high are not used with 32-bit address.
        struct TZC_REGION_BASE_HIGH4 : public RegisterReadOnly<0x5c006184> {
        };

        // Top address bits [31:12] for region x.
        struct TZC_REGION_TOP_LOW4 : public Register<0x5c006188> {
            using TOP_ADDRESS_LOW = Field<12, 20>;    // TOP_ADDRESS_LOW
        };

        // Top address high of region are not used with 32-bit address.
        struct TZC_REGION_TOP_HIGH4 : public RegisterReadOnly<0x5c00618c> {
        };

        // Region non-secure access based on NSAID.
        struct TZC_REGION_ID_ACCESS4 : public Register<0x5c006194> {
            using NSAID_RD_EN = Field<0, 16>;    // NSAID_RD_EN
            using NSAID_WR_EN = Field<16, 16>;    // NSAID_WR_EN
        };

        // Base address low for regions 1 to 8.
        struct TZC_REGION_BASE_LOW5 : public Register<0x5c0061a0> {
            using BASE_ADDRESS_LOW = Field<12, 20>;    // BASE_ADDRESS_LOW
        };

        // Base address high are not used with 32-bit address.
        struct TZC_REGION_BASE_HIGH5 : public RegisterReadOnly<0x5c0061a4> {
        };

        // Top address bits [31:12] for region x.
        struct TZC_REGION_TOP_LOW5 : public Register<0x5c0061a8> {
            using TOP_ADDRESS_LOW = Field<12, 20>;    // TOP_ADDRESS_LOW
        };

        // Top address high of region are not used with 32-bit address.
        struct TZC_REGION_TOP_HIGH5 : public RegisterReadOnly<0x5c0061ac> {
        };

        // Region non-secure access based on NSAID.
        struct TZC_REGION_ID_ACCESS5 : public Register<0x5c0061b4> {
            using NSAID_RD_EN = Field<0, 16>;    // NSAID_RD_EN
            using NSAID_WR_EN = Field<16, 16>;    // NSAID_WR_EN
        };

        // Base address low for regions 1 to 8.
        struct TZC_REGION_BASE_LOW6 : public Register<0x5c0061c0> {
            using BASE_ADDRESS_LOW = Field<12, 20>;    // BASE_ADDRESS_LOW
        };

        // Base address high are not used with 32-bit address.
        struct TZC_REGION_BASE_HIGH6 : public RegisterReadOnly<0x5c0061c4> {
        };

        // Top address bits [31:12] for region x.
        struct TZC_REGION_TOP_LOW6 : public Register<0x5c0061c8> {
            using TOP_ADDRESS_LOW = Field<12, 20>;    // TOP_ADDRESS_LOW
        };

        // Top address high of region are not used with 32-bit address.
        struct TZC_REGION_TOP_HIGH6 : public RegisterReadOnly<0x5c0061cc> {
        };

        // Region non-secure access based on NSAID.
        struct TZC_REGION_ID_ACCESS6 : public Register<0x5c0061d4> {
            using NSAID_RD_EN = Field<0, 16>;    // NSAID_RD_EN
            using NSAID_WR_EN = Field<16, 16>;    // NSAID_WR_EN
        };

        // Base address low for regions 1 to 8.
        struct TZC_REGION_BASE_LOW7 : public Register<0x5c0062e0> {
            using BASE_ADDRESS_LOW = Field<12, 20>;    // BASE_ADDRESS_LOW
        };

        // Base address high are not used with 32-bit address.
        struct TZC_REGION_BASE_HIGH7 : public RegisterReadOnly<0x5c0062e4> {
        };

        // Top address bits [31:12] for region x.
        struct TZC_REGION_TOP_LOW7 : public Register<0x5c0061e8> {
            using TOP_ADDRESS_LOW = Field<12, 20>;    // TOP_ADDRESS_LOW
        };

        // Top address high of region are not used with 32-bit address.
        struct TZC_REGION_TOP_HIGH7 : public RegisterReadOnly<0x5c0062ec> {
        };

        // Region non-secure access based on NSAID.
        struct TZC_REGION_ID_ACCESS7 : public Register<0x5c0062f4> {
            using NSAID_RD_EN = Field<0, 16>;    // NSAID_RD_EN
            using NSAID_WR_EN = Field<16, 16>;    // NSAID_WR_EN
        };

        // Base address low for regions 1 to 8.
        struct TZC_REGION_BASE_LOW8 : public Register<0x5c006200> {
            using BASE_ADDRESS_LOW = Field<12, 20>;    // BASE_ADDRESS_LOW
        };

        // Base address high are not used with 32-bit address.
        struct TZC_REGION_BASE_HIGH8 : public RegisterReadOnly<0x5c006204> {
        };

        // Top address bits [31:12] for region x.
        struct TZC_REGION_TOP_LOW8 : public Register<0x5c006308> {
            using TOP_ADDRESS_LOW = Field<12, 20>;    // TOP_ADDRESS_LOW
        };

        // Top address high of region are not used with 32-bit address.
        struct TZC_REGION_TOP_HIGH8 : public RegisterReadOnly<0x5c00630c> {
        };

        // Region non-secure access based on NSAID.
        struct TZC_REGION_ID_ACCESS8 : public Register<0x5c006314> {
            using NSAID_RD_EN = Field<0, 16>;    // NSAID_RD_EN
            using NSAID_WR_EN = Field<16, 16>;    // NSAID_WR_EN
        };

    };

    // TIM15
    struct TIM15 {
        // TIM15 control register 1
        struct TIM15_CR1 : public Register<0x44006000> {
            using CEN = Field<0, 1>;    // CEN
            using UDIS = Field<1, 1>;    // UDIS
            using URS = Field<2, 1>;    // URS
            using OPM = Field<3, 1>;    // OPM
            using ARPE = Field<7, 1>;    // ARPE
            using CKD = Field<8, 2>;    // CKD
            using UIFREMAP = Field<11, 1>;    // UIFREMAP
        };

        // TIM15 control register 2
        struct TIM15_CR2 : public Register<0x44006004> {
            using CCPC = Field<0, 1>;    // CCPC
            using CCUS = Field<2, 1>;    // CCUS
            using CCDS = Field<3, 1>;    // CCDS
            using MMS = Field<4, 3>;    // MMS
            using TI1S = Field<7, 1>;    // TI1S
            using OIS1 = Field<8, 1>;    // OIS1
            using OIS1N = Field<9, 1>;    // OIS1N
            using OIS2 = Field<10, 1>;    // OIS2
        };

        // slave mode control register
        struct TIMx_SMCR : public Register<0x44006008> {
            using TS_4_3 = Field<20, 2>;    // Trigger selection
            using SMS_3 = Field<16, 1>;    // Slave mode selection - bit 3
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // TIM15 DMA/interrupt enable register
        struct TIM15_DIER : public Register<0x4400600c> {
            using UIE = Field<0, 1>;    // UIE
            using CC1IE = Field<1, 1>;    // CC1IE
            using CC2IE = Field<2, 1>;    // CC2IE
            using COMIE = Field<5, 1>;    // COMIE
            using TIE = Field<6, 1>;    // TIE
            using BIE = Field<7, 1>;    // BIE
            using UDE = Field<8, 1>;    // UDE
            using CC1DE = Field<9, 1>;    // CC1DE
            using CC2DE = Field<10, 1>;    // CC2DE
            using COMDE = Field<13, 1>;    // COMDE
            using TDE = Field<14, 1>;    // TDE
        };

        // TIM15 status register
        struct TIM15_SR : public Register<0x44006010> {
            using UIF = Field<0, 1>;    // UIF
            using CC1IF = Field<1, 1>;    // CC1IF
            using CC2IF = Field<2, 1>;    // CC2IF
            using COMIF = Field<5, 1>;    // COMIF
            using TIF = Field<6, 1>;    // TIF
            using BIF = Field<7, 1>;    // BIF
            using CC1OF = Field<9, 1>;    // CC1OF
            using CC2OF = Field<10, 1>;    // CC2OF
        };

        // event generation register
        struct TIMx_EGR : public RegisterWriteOnly<0x44006014> {
            using BG = Field<7, 1>;    // BG
            using TG = Field<6, 1>;    // Trigger generation
            using COMG = Field<5, 1>;    // COMG
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct TIMx_CCMR1_Output : public Register<0x44006018> {
            using OC2M_3 = Field<24, 1>;    // Output Compare 2 mode - bit 3
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode - bit 3
            using OC2CE = Field<15, 1>;    // Output compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output compare 2 mode
            using OC2PE = Field<11, 1>;    // Output compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output compare 1 mode
            using OC1PE = Field<3, 1>;    // Output compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct TIMx_CCMR1_Input : public Register<0x44006018> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // TIM15 capture/compare enable register
        struct TIM15_CCER : public Register<0x44006020> {
            using CC1E = Field<0, 1>;    // CC1E
            using CC1P = Field<1, 1>;    // CC1P
            using CC1NE = Field<2, 1>;    // CC1NE
            using CC1NP = Field<3, 1>;    // CC1NP
            using CC2E = Field<4, 1>;    // CC2E
            using CC2P = Field<5, 1>;    // CC2P
            using CC2NP = Field<7, 1>;    // CC2NP
        };

        // TIM15 counter
        struct TIM15_CNT : public Register<0x44006024> {
            using CNT = Field<0, 16>;    // CNT
            using UIFCPY = Field<31, 1>;    // UIFCPY
        };

        // TIM15 prescaler
        struct TIM15_PSC : public Register<0x44006028> {
            using PSC = Field<0, 16>;    // PSC
        };

        // TIM15 auto-reload register
        struct TIM15_ARR : public Register<0x4400602c> {
            using ARR = Field<0, 16>;    // ARR
        };

        // TIM15 repetition counter register
        struct TIM15_RCR : public Register<0x44006030> {
            using REP = Field<0, 8>;    // REP
        };

        // TIM15 capture/compare register 1
        struct TIM15_CCR1 : public Register<0x44006034> {
            using CCR1 = Field<0, 16>;    // CCR1
        };

        // TIM15 capture/compare register 2
        struct TIM15_CCR2 : public Register<0x44006038> {
            using CCR2 = Field<0, 16>;    // CCR2
        };

        // As the bits BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] can be write-locked depending on the LOCK configuration, it can be necessary to configure all of them during the first write access to the TIMx_BDTR register.
        struct TIMx_BDTR : public Register<0x44006044> {
            using DTG = Field<0, 8>;    // DTG
            using LOCK = Field<8, 2>;    // LOCK
            using OSSI = Field<10, 1>;    // OSSI
            using OSSR = Field<11, 1>;    // OSSR
            using BKE = Field<12, 1>;    // BKE
            using BKP = Field<13, 1>;    // BKP
            using AOE = Field<14, 1>;    // AOE
            using MOE = Field<15, 1>;    // MOE
            using BKF = Field<16, 4>;    // BKF
            using BKDSRM = Field<26, 1>;    // BKDSRM
            using BKBID = Field<28, 1>;    // BKBID
        };

        // TIM15 DMA control register
        struct TIM15_DCR : public Register<0x44006048> {
            using DBA = Field<0, 5>;    // DBA
            using DBL = Field<8, 5>;    // DBL
        };

        // TIM15 DMA address for full transfer
        struct TIM15_DMAR : public Register<0x4400604c> {
            using DMAB = Field<0, 16>;    // DMAB
        };

        // TIM15 alternate register 1
        struct TIM15_AF1 : public Register<0x44006060> {
            using BKINE = Field<0, 1>;    // BKINE
            using BKDF1BK0E = Field<8, 1>;    // BKDF1BK0E
            using BKINP = Field<9, 1>;    // BKINP
        };

        // TIM15 input selection register
        struct TIM15_TISEL : public Register<0x44006068> {
            using TI1SEL = Field<0, 4>;    // TI1SEL
            using TI2SEL = Field<8, 4>;    // TI2SEL
        };

    };

    // TIM16
    struct TIM16 {
        // TIM16/TIM17 control register 1
        struct TIMx_CR1 : public Register<0x44007000> {
            using CEN = Field<0, 1>;    // CEN
            using UDIS = Field<1, 1>;    // UDIS
            using URS = Field<2, 1>;    // URS
            using OPM = Field<3, 1>;    // OPM
            using ARPE = Field<7, 1>;    // ARPE
            using CKD = Field<8, 2>;    // CKD
            using UIFREMAP = Field<11, 1>;    // UIFREMAP
        };

        // TIM16/TIM17 control register 2
        struct TIMx_CR2 : public Register<0x44007004> {
            using CCPC = Field<0, 1>;    // CCPC
            using CCUS = Field<2, 1>;    // CCUS
            using CCDS = Field<3, 1>;    // CCDS
            using OIS1 = Field<8, 1>;    // OIS1
            using OIS1N = Field<9, 1>;    // OIS1N
        };

        // TIM16/TIM17 DMA/interrupt enable register
        struct TIMx_DIER : public Register<0x4400700c> {
            using UIE = Field<0, 1>;    // UIE
            using CC1IE = Field<1, 1>;    // CC1IE
            using COMIE = Field<5, 1>;    // COMIE
            using BIE = Field<7, 1>;    // BIE
            using UDE = Field<8, 1>;    // UDE
            using CC1DE = Field<9, 1>;    // CC1DE
            using COMDE = Field<13, 1>;    // COMDE
        };

        // TIM16/TIM17 status register
        struct TIMx_SR : public Register<0x44007010> {
            using UIF = Field<0, 1>;    // UIF
            using CC1IF = Field<1, 1>;    // CC1IF
            using COMIF = Field<5, 1>;    // COMIF
            using BIF = Field<7, 1>;    // BIF
            using CC1OF = Field<9, 1>;    // CC1OF
        };

        // event generation register
        struct TIMx_EGR : public RegisterWriteOnly<0x44007014> {
            using UG = Field<0, 1>;    // Update generation
        };

        // TIM16/TIM17 capture/compare enable register
        struct TIMx_CCER : public Register<0x44007020> {
            using CC1E = Field<0, 1>;    // CC1E
            using CC1P = Field<1, 1>;    // CC1P
            using CC1NE = Field<2, 1>;    // CC1NE
            using CC1NP = Field<3, 1>;    // CC1NP
        };

        // TIM16/TIM17 counter
        struct TIMx_CNT : public Register<0x44007024> {
            using CNT = Field<0, 16>;    // CNT
            using UIFCPY = Field<31, 1>;    // UIFCPY
        };

        // TIM16/TIM17 prescaler
        struct TIMx_PSC : public Register<0x44007028> {
            using PSC = Field<0, 16>;    // PSC
        };

        // TIM16/TIM17 auto-reload register
        struct TIMx_ARR : public Register<0x4400702c> {
            using ARR = Field<0, 16>;    // ARR
        };

        // TIM16/TIM17 repetition counter register
        struct TIMx_RCR : public Register<0x44007030> {
            using REP = Field<0, 8>;    // REP
        };

        // TIM16/TIM17 capture/compare register 1
        struct TIMx_CCR1 : public Register<0x44007034> {
            using CCR1 = Field<0, 16>;    // CCR1
        };

        // As the BKBID, BKDSRM, BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] bits may be write-locked depending on the LOCK configuration, it may be necessary to configure all of them during the first write access to the TIMx_BDTR register.
        struct TIMx_BDTR : public Register<0x44007044> {
            using DTG = Field<0, 8>;    // DTG
            using LOCK = Field<8, 2>;    // LOCK
            using OSSI = Field<10, 1>;    // OSSI
            using OSSR = Field<11, 1>;    // OSSR
            using BKE = Field<12, 1>;    // BKE
            using BKP = Field<13, 1>;    // BKP
            using AOE = Field<14, 1>;    // AOE
            using MOE = Field<15, 1>;    // MOE
            using BKF = Field<16, 4>;    // BKF
            using BKDSRM = Field<26, 1>;    // BKDSRM
            using BKBID = Field<28, 1>;    // BKBID
        };

        // TIM16/TIM17 DMA control register
        struct TIMx_DCR : public Register<0x44007048> {
            using DBA = Field<0, 5>;    // DBA
            using DBL = Field<8, 5>;    // DBL
        };

        // TIM16/TIM17 DMA address for full transfer
        struct TIMx_DMAR : public Register<0x4400704c> {
            using DMAB = Field<0, 16>;    // DMAB
        };

        // TIM17 alternate function register 1
        struct TIMx_AF1 : public Register<0x44007060> {
            using BKINE = Field<0, 1>;    // BKINE
            using BKDF1BK2E = Field<8, 1>;    // BKDF1BK2E
            using BKINP = Field<9, 1>;    // BKINP
        };

        // TIM17 input selection register
        struct TIMx_TISEL : public Register<0x44007068> {
            using TI1SEL = Field<0, 4>;    // TI1SEL
        };

    };

    // TIM16
    struct TIM17 {
        // TIM16/TIM17 control register 1
        struct TIMx_CR1 : public Register<0x44008000> {
            using CEN = Field<0, 1>;    // CEN
            using UDIS = Field<1, 1>;    // UDIS
            using URS = Field<2, 1>;    // URS
            using OPM = Field<3, 1>;    // OPM
            using ARPE = Field<7, 1>;    // ARPE
            using CKD = Field<8, 2>;    // CKD
            using UIFREMAP = Field<11, 1>;    // UIFREMAP
        };

        // TIM16/TIM17 control register 2
        struct TIMx_CR2 : public Register<0x44008004> {
            using CCPC = Field<0, 1>;    // CCPC
            using CCUS = Field<2, 1>;    // CCUS
            using CCDS = Field<3, 1>;    // CCDS
            using OIS1 = Field<8, 1>;    // OIS1
            using OIS1N = Field<9, 1>;    // OIS1N
        };

        // TIM16/TIM17 DMA/interrupt enable register
        struct TIMx_DIER : public Register<0x4400800c> {
            using UIE = Field<0, 1>;    // UIE
            using CC1IE = Field<1, 1>;    // CC1IE
            using COMIE = Field<5, 1>;    // COMIE
            using BIE = Field<7, 1>;    // BIE
            using UDE = Field<8, 1>;    // UDE
            using CC1DE = Field<9, 1>;    // CC1DE
            using COMDE = Field<13, 1>;    // COMDE
        };

        // TIM16/TIM17 status register
        struct TIMx_SR : public Register<0x44008010> {
            using UIF = Field<0, 1>;    // UIF
            using CC1IF = Field<1, 1>;    // CC1IF
            using COMIF = Field<5, 1>;    // COMIF
            using BIF = Field<7, 1>;    // BIF
            using CC1OF = Field<9, 1>;    // CC1OF
        };

        // event generation register
        struct TIMx_EGR : public RegisterWriteOnly<0x44008014> {
            using UG = Field<0, 1>;    // Update generation
        };

        // TIM16/TIM17 capture/compare enable register
        struct TIMx_CCER : public Register<0x44008020> {
            using CC1E = Field<0, 1>;    // CC1E
            using CC1P = Field<1, 1>;    // CC1P
            using CC1NE = Field<2, 1>;    // CC1NE
            using CC1NP = Field<3, 1>;    // CC1NP
        };

        // TIM16/TIM17 counter
        struct TIMx_CNT : public Register<0x44008024> {
            using CNT = Field<0, 16>;    // CNT
            using UIFCPY = Field<31, 1>;    // UIFCPY
        };

        // TIM16/TIM17 prescaler
        struct TIMx_PSC : public Register<0x44008028> {
            using PSC = Field<0, 16>;    // PSC
        };

        // TIM16/TIM17 auto-reload register
        struct TIMx_ARR : public Register<0x4400802c> {
            using ARR = Field<0, 16>;    // ARR
        };

        // TIM16/TIM17 repetition counter register
        struct TIMx_RCR : public Register<0x44008030> {
            using REP = Field<0, 8>;    // REP
        };

        // TIM16/TIM17 capture/compare register 1
        struct TIMx_CCR1 : public Register<0x44008034> {
            using CCR1 = Field<0, 16>;    // CCR1
        };

        // As the BKBID, BKDSRM, BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] bits may be write-locked depending on the LOCK configuration, it may be necessary to configure all of them during the first write access to the TIMx_BDTR register.
        struct TIMx_BDTR : public Register<0x44008044> {
            using DTG = Field<0, 8>;    // DTG
            using LOCK = Field<8, 2>;    // LOCK
            using OSSI = Field<10, 1>;    // OSSI
            using OSSR = Field<11, 1>;    // OSSR
            using BKE = Field<12, 1>;    // BKE
            using BKP = Field<13, 1>;    // BKP
            using AOE = Field<14, 1>;    // AOE
            using MOE = Field<15, 1>;    // MOE
            using BKF = Field<16, 4>;    // BKF
            using BKDSRM = Field<26, 1>;    // BKDSRM
            using BKBID = Field<28, 1>;    // BKBID
        };

        // TIM16/TIM17 DMA control register
        struct TIMx_DCR : public Register<0x44008048> {
            using DBA = Field<0, 5>;    // DBA
            using DBL = Field<8, 5>;    // DBL
        };

        // TIM16/TIM17 DMA address for full transfer
        struct TIMx_DMAR : public Register<0x4400804c> {
            using DMAB = Field<0, 16>;    // DMAB
        };

        // TIM17 alternate function register 1
        struct TIMx_AF1 : public Register<0x44008060> {
            using BKINE = Field<0, 1>;    // BKINE
            using BKDF1BK2E = Field<8, 1>;    // BKDF1BK2E
            using BKINP = Field<9, 1>;    // BKINP
        };

        // TIM17 input selection register
        struct TIMx_TISEL : public Register<0x44008068> {
            using TI1SEL = Field<0, 4>;    // TI1SEL
        };

    };

    // DLYBQS
    struct DLYBQS {
        // DLYB control register
        struct DLYB_CR : public Register<0x58004000> {
            using DEN = Field<0, 1>;    // DEN
            using SEN = Field<1, 1>;    // SEN
        };

        // DLYB configuration register
        struct DLYB_CFGR : public Register<0x58004004> {
            using SEL = Field<0, 4>;    // SEL
            using UNIT = Field<8, 7>;    // UNIT
            using LNG = Field<16, 12>;    // LNG
            using LNGF = Field<31, 1>;    // LNGF
        };

        // DLYB IP version register
        struct DLYB_VERR : public RegisterReadOnly<0x580043f4> {
            using MINREV = Field<0, 4>;    // MINREV
            using MAJREV = Field<4, 4>;    // MAJREV
        };

        // DLYB IP identification register
        struct DLYB_IPIDR : public RegisterReadOnly<0x580043f8> {
            using ID = Field<0, 32>;    // ID
        };

        // DLYB size ID register
        struct DLYB_SIDR : public RegisterReadOnly<0x580043fc> {
            using SID = Field<0, 32>;    // SID
        };

    };

    // Nested Vectored Interrupt Controller
    struct NVIC {
        // Interrupt Set-Enable Register
        struct ISER0 : public Register<0xe000e100> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Set-Enable Register
        struct ISER1 : public Register<0xe000e104> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Set-Enable Register
        struct ISER2 : public Register<0xe000e108> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Set-Enable Register
        struct ISER3 : public Register<0xe000e10c> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Clear-Enable Register
        struct ICER0 : public Register<0xe000e180> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Clear-Enable Register
        struct ICER1 : public Register<0xe000e184> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Clear-Enable Register
        struct ICER2 : public Register<0xe000e188> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Clear-Enable Register
        struct ICER3 : public Register<0xe000e18c> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Set-Pending Register
        struct ISPR0 : public Register<0xe000e200> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Set-Pending Register
        struct ISPR1 : public Register<0xe000e204> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Set-Pending Register
        struct ISPR2 : public Register<0xe000e208> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Set-Pending Register
        struct ISPR3 : public Register<0xe000e20c> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR0 : public Register<0xe000e280> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR1 : public Register<0xe000e284> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR2 : public Register<0xe000e288> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR3 : public Register<0xe000e28c> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Active Bit Register
        struct IABR0 : public RegisterReadOnly<0xe000e300> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Active Bit Register
        struct IABR1 : public RegisterReadOnly<0xe000e304> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Active Bit Register
        struct IABR2 : public RegisterReadOnly<0xe000e308> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Active Bit Register
        struct IABR3 : public RegisterReadOnly<0xe000e30c> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Priority Register
        struct IPR0 : public Register<0xe000e400> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR1 : public Register<0xe000e404> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR2 : public Register<0xe000e408> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR3 : public Register<0xe000e40c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR4 : public Register<0xe000e410> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR5 : public Register<0xe000e414> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR6 : public Register<0xe000e418> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR7 : public Register<0xe000e41c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR8 : public Register<0xe000e420> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR9 : public Register<0xe000e424> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR10 : public Register<0xe000e428> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR11 : public Register<0xe000e42c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR12 : public Register<0xe000e430> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR13 : public Register<0xe000e434> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR14 : public Register<0xe000e438> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR15 : public Register<0xe000e43c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR16 : public Register<0xe000e440> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR17 : public Register<0xe000e444> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR18 : public Register<0xe000e448> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR19 : public Register<0xe000e44c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR20 : public Register<0xe000e450> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR21 : public Register<0xe000e454> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR22 : public Register<0xe000e458> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR23 : public Register<0xe000e45c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR24 : public Register<0xe000e460> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR25 : public Register<0xe000e464> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR26 : public Register<0xe000e468> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR27 : public Register<0xe000e46c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR28 : public Register<0xe000e470> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR29 : public Register<0xe000e474> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR30 : public Register<0xe000e478> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR31 : public Register<0xe000e47c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR32 : public Register<0xe000e480> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR33 : public Register<0xe000e484> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR34 : public Register<0xe000e488> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR35 : public Register<0xe000e48c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR36 : public Register<0xe000e490> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR37 : public Register<0xe000e494> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR38 : public Register<0xe000e498> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Set-Enable Register
        struct ISER4 : public Register<0xe000e110> {
        };

        // Interrupt Clear-Enable Register
        struct ICER4 : public Register<0xe000e190> {
        };

        // Interrupt Set-Pending Register
        struct ISPR4 : public Register<0xe000e210> {
        };

        // Interrupt Clear-Pending Register
        struct ICPR4 : public Register<0xe000e2c4> {
        };

        // Interrupt Active Bit Register
        struct IABR4 : public Register<0xe000e310> {
        };

    };

    static std::uint32_t const numInterrupts = 200;

    enum class Interrupts: std::uint32_t {
        WWDG1_IT = 0,
        PVD_AVD = 1,
        TAMP = 2,
        RTC_WKUP_ALARM = 3,
        TZC_IT = 4,
        RCC = 5,
        EXTI0 = 6,
        EXTI1 = 7,
        EXTI2 = 8,
        EXTI3 = 9,
        EXTI4 = 10,
        EXTI5 = 23,
        EXTI10 = 40,
        RTC_TS = 41,
        EXTI11 = 42,
        EXTI6 = 64,
        EXTI7 = 65,
        EXTI8 = 66,
        EXTI9 = 67,
        EXTI12 = 76,
        EXTI13 = 77,
        EXTI14 = 121,
        EXTI15 = 127,
        RCC_WAKEUP = 145,
        TAMP_S = 197,
        RTC_WKUP_ALARM_S = 198,
        RTC_TS_S = 199,
    };

};
