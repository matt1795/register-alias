// This is a file generated by svd-alias.

#pragma once

#include "svd-alias/bit-field.hpp"
#include "svd-alias/register.hpp"

struct STM32H743x {
    // COMP1
    struct COMP1 {
        // Comparator status register
        struct SR : public RegisterReadOnly<0x58003800> {
            using C1VAL = Field<0, 1>;    // COMP channel 1 output status bit
            using C2VAL = Field<1, 1>;    // COMP channel 2 output status bit
            using C1IF = Field<16, 1>;    // COMP channel 1 Interrupt Flag
            using C2IF = Field<17, 1>;    // COMP channel 2 Interrupt Flag
        };

        // Comparator interrupt clear flag register
        struct ICFR : public RegisterWriteOnly<0x58003804> {
            using CC1IF = Field<16, 1>;    // Clear COMP channel 1 Interrupt Flag
            using CC2IF = Field<17, 1>;    // Clear COMP channel 2 Interrupt Flag
        };

        // Comparator option register
        struct OR : public Register<0x58003808> {
            using AFOP = Field<0, 11>;    // Selection of source for alternate function of output ports
            using Field = Field<11, 21>;    // Option Register
        };

        // Comparator configuration register 1
        struct CFGR1 : public Register<0x5800380c> {
            using EN = Field<0, 1>;    // COMP channel 1 enable bit
            using BRGEN = Field<1, 1>;    // Scaler bridge enable
            using SCALEN = Field<2, 1>;    // Voltage scaler enable bit
            using POLARITY = Field<3, 1>;    // COMP channel 1 polarity selection bit
            using ITEN = Field<6, 1>;    // COMP channel 1 interrupt enable
            using HYST = Field<8, 2>;    // COMP channel 1 hysteresis selection bits
            using PWRMODE = Field<12, 2>;    // Power Mode of the COMP channel 1
            using INMSEL = Field<16, 3>;    // COMP channel 1 inverting input selection field
            using INPSEL = Field<20, 1>;    // COMP channel 1 non-inverting input selection bit
            using BLANKING = Field<24, 4>;    // COMP channel 1 blanking source selection bits
            using LOCK = Field<31, 1>;    // Lock bit
        };

        // Comparator configuration register 2
        struct CFGR2 : public Register<0x58003810> {
            using EN = Field<0, 1>;    // COMP channel 1 enable bit
            using BRGEN = Field<1, 1>;    // Scaler bridge enable
            using SCALEN = Field<2, 1>;    // Voltage scaler enable bit
            using POLARITY = Field<3, 1>;    // COMP channel 1 polarity selection bit
            using WINMODE = Field<4, 1>;    // Window comparator mode selection bit
            using ITEN = Field<6, 1>;    // COMP channel 1 interrupt enable
            using HYST = Field<8, 2>;    // COMP channel 1 hysteresis selection bits
            using PWRMODE = Field<12, 2>;    // Power Mode of the COMP channel 1
            using INMSEL = Field<16, 3>;    // COMP channel 1 inverting input selection field
            using INPSEL = Field<20, 1>;    // COMP channel 1 non-inverting input selection bit
            using BLANKING = Field<24, 4>;    // COMP channel 1 blanking source selection bits
            using LOCK = Field<31, 1>;    // Lock bit
        };

    };

    // CRS
    struct CRS {
        // CRS control register
        struct CR : public Register<0x40008400> {
            using SYNCOKIE = Field<0, 1>;    // SYNC event OK interrupt enable
            using SYNCWARNIE = Field<1, 1>;    // SYNC warning interrupt enable
            using ERRIE = Field<2, 1>;    // Synchronization or trimming error interrupt enable
            using ESYNCIE = Field<3, 1>;    // Expected SYNC interrupt enable
            using CEN = Field<5, 1>;    // Frequency error counter enable This bit enables the oscillator clock for the frequency error counter. When this bit is set, the CRS_CFGR register is write-protected and cannot be modified.
            using AUTOTRIMEN = Field<6, 1>;    // Automatic trimming enable This bit enables the automatic hardware adjustment of TRIM bits according to the measured frequency error between two SYNC events. If this bit is set, the TRIM bits are read-only. The TRIM value can be adjusted by hardware by one or two steps at a time, depending on the measured frequency error value. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details.
            using SWSYNC = Field<7, 1>;    // Generate software SYNC event This bit is set by software in order to generate a software SYNC event. It is automatically cleared by hardware.
            using TRIM = Field<8, 6>;    // HSI48 oscillator smooth trimming These bits provide a user-programmable trimming value to the HSI48 oscillator. They can be programmed to adjust to variations in voltage and temperature that influence the frequency of the HSI48. The default value is 32, which corresponds to the middle of the trimming interval. The trimming step is around 67 kHz between two consecutive TRIM steps. A higher TRIM value corresponds to a higher output frequency. When the AUTOTRIMEN bit is set, this field is controlled by hardware and is read-only.
        };

        // This register can be written only when the frequency error counter is disabled (CEN bit is cleared in CRS_CR). When the counter is enabled, this register is write-protected.
        struct CFGR : public Register<0x40008404> {
            using RELOAD = Field<0, 16>;    // Counter reload value RELOAD is the value to be loaded in the frequency error counter with each SYNC event. Refer to Section7.3.3: Frequency error measurement for more details about counter behavior.
            using FELIM = Field<16, 8>;    // Frequency error limit FELIM contains the value to be used to evaluate the captured frequency error value latched in the FECAP[15:0] bits of the CRS_ISR register. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details about FECAP evaluation.
            using SYNCDIV = Field<24, 3>;    // SYNC divider These bits are set and cleared by software to control the division factor of the SYNC signal.
            using SYNCSRC = Field<28, 2>;    // SYNC signal source selection These bits are set and cleared by software to select the SYNC signal source. Note: When using USB LPM (Link Power Management) and the device is in Sleep mode, the periodic USB SOF will not be generated by the host. No SYNC signal will therefore be provided to the CRS to calibrate the HSI48 on the run. To guarantee the required clock precision after waking up from Sleep mode, the LSE or reference clock on the GPIOs should be used as SYNC signal.
            using SYNCPOL = Field<31, 1>;    // SYNC polarity selection This bit is set and cleared by software to select the input polarity for the SYNC signal source.
        };

        // CRS interrupt and status register
        struct ISR : public RegisterReadOnly<0x40008408> {
            using SYNCOKF = Field<0, 1>;    // SYNC event OK flag This flag is set by hardware when the measured frequency error is smaller than FELIM * 3. This means that either no adjustment of the TRIM value is needed or that an adjustment by one trimming step is enough to compensate the frequency error. An interrupt is generated if the SYNCOKIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCOKC bit in the CRS_ICR register.
            using SYNCWARNF = Field<1, 1>;    // SYNC warning flag This flag is set by hardware when the measured frequency error is greater than or equal to FELIM * 3, but smaller than FELIM * 128. This means that to compensate the frequency error, the TRIM value must be adjusted by two steps or more. An interrupt is generated if the SYNCWARNIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCWARNC bit in the CRS_ICR register.
            using ERRF = Field<2, 1>;    // Error flag This flag is set by hardware in case of any synchronization or trimming error. It is the logical OR of the TRIMOVF, SYNCMISS and SYNCERR bits. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software in reaction to setting the ERRC bit in the CRS_ICR register, which clears the TRIMOVF, SYNCMISS and SYNCERR bits.
            using ESYNCF = Field<3, 1>;    // Expected SYNC flag This flag is set by hardware when the frequency error counter reached a zero value. An interrupt is generated if the ESYNCIE bit is set in the CRS_CR register. It is cleared by software by setting the ESYNCC bit in the CRS_ICR register.
            using SYNCERR = Field<8, 1>;    // SYNC error This flag is set by hardware when the SYNC pulse arrives before the ESYNC event and the measured frequency error is greater than or equal to FELIM * 128. This means that the frequency error is too big (internal frequency too low) to be compensated by adjusting the TRIM value, and that some other action should be taken. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
            using SYNCMISS = Field<9, 1>;    // SYNC missed This flag is set by hardware when the frequency error counter reached value FELIM * 128 and no SYNC was detected, meaning either that a SYNC pulse was missed or that the frequency error is too big (internal frequency too high) to be compensated by adjusting the TRIM value, and that some other action should be taken. At this point, the frequency error counter is stopped (waiting for a next SYNC) and an interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
            using TRIMOVF = Field<10, 1>;    // Trimming overflow or underflow This flag is set by hardware when the automatic trimming tries to over- or under-flow the TRIM value. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
            using FEDIR = Field<15, 1>;    // Frequency error direction FEDIR is the counting direction of the frequency error counter latched in the time of the last SYNC event. It shows whether the actual frequency is below or above the target.
            using FECAP = Field<16, 16>;    // Frequency error capture FECAP is the frequency error counter value latched in the time of the last SYNC event. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details about FECAP usage.
        };

        // CRS interrupt flag clear register
        struct ICR : public Register<0x4000840c> {
            using SYNCOKC = Field<0, 1>;    // SYNC event OK clear flag Writing 1 to this bit clears the SYNCOKF flag in the CRS_ISR register.
            using SYNCWARNC = Field<1, 1>;    // SYNC warning clear flag Writing 1 to this bit clears the SYNCWARNF flag in the CRS_ISR register.
            using ERRC = Field<2, 1>;    // Error clear flag Writing 1 to this bit clears TRIMOVF, SYNCMISS and SYNCERR bits and consequently also the ERRF flag in the CRS_ISR register.
            using ESYNCC = Field<3, 1>;    // Expected SYNC clear flag Writing 1 to this bit clears the ESYNCF flag in the CRS_ISR register.
        };

    };

    // DAC
    struct DAC {
        // DAC control register
        struct CR : public Register<0x40007400> {
            using EN1 = Field<0, 1>;    // DAC channel1 enable This bit is set and cleared by software to enable/disable DAC channel1.
            using TEN1 = Field<1, 1>;    // DAC channel1 trigger enable
            using TSEL1 = Field<2, 3>;    // DAC channel1 trigger selection These bits select the external event used to trigger DAC channel1. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
            using WAVE1 = Field<6, 2>;    // DAC channel1 noise/triangle wave generation enable These bits are set and cleared by software. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
            using MAMP1 = Field<8, 4>;    // DAC channel1 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
            using DMAEN1 = Field<12, 1>;    // DAC channel1 DMA enable This bit is set and cleared by software.
            using DMAUDRIE1 = Field<13, 1>;    // DAC channel1 DMA Underrun Interrupt enable This bit is set and cleared by software.
            using CEN1 = Field<14, 1>;    // DAC Channel 1 calibration enable This bit is set and cleared by software to enable/disable DAC channel 1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
            using EN2 = Field<16, 1>;    // DAC channel2 enable This bit is set and cleared by software to enable/disable DAC channel2.
            using TEN2 = Field<17, 1>;    // DAC channel2 trigger enable
            using TSEL2 = Field<18, 3>;    // DAC channel2 trigger selection These bits select the external event used to trigger DAC channel2 Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled).
            using WAVE2 = Field<22, 2>;    // DAC channel2 noise/triangle wave generation enable These bits are set/reset by software. 1x: Triangle wave generation enabled Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled)
            using MAMP2 = Field<24, 4>;    // DAC channel2 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
            using DMAEN2 = Field<28, 1>;    // DAC channel2 DMA enable This bit is set and cleared by software.
            using DMAUDRIE2 = Field<29, 1>;    // DAC channel2 DMA underrun interrupt enable This bit is set and cleared by software.
            using CEN2 = Field<30, 1>;    // DAC Channel 2 calibration enable This bit is set and cleared by software to enable/disable DAC channel 2 calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
        };

        // DAC software trigger register
        struct SWTRGR : public RegisterWriteOnly<0x40007404> {
            using SWTRIG1 = Field<0, 1>;    // DAC channel1 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register.
            using SWTRIG2 = Field<1, 1>;    // DAC channel2 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register.
        };

        // DAC channel1 12-bit right-aligned data holding register
        struct DHR12R1 : public Register<0x40007408> {
            using DACC1DHR = Field<0, 12>;    // DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
        };

        // DAC channel1 12-bit left aligned data holding register
        struct DHR12L1 : public Register<0x4000740c> {
            using DACC1DHR = Field<4, 12>;    // DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
        };

        // DAC channel1 8-bit right aligned data holding register
        struct DHR8R1 : public Register<0x40007410> {
            using DACC1DHR = Field<0, 8>;    // DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
        };

        // DAC channel2 12-bit right aligned data holding register
        struct DHR12R2 : public Register<0x40007414> {
            using DACC2DHR = Field<0, 12>;    // DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
        };

        // DAC channel2 12-bit left aligned data holding register
        struct DHR12L2 : public Register<0x40007418> {
            using DACC2DHR = Field<4, 12>;    // DAC channel2 12-bit left-aligned data These bits are written by software which specify 12-bit data for DAC channel2.
        };

        // DAC channel2 8-bit right-aligned data holding register
        struct DHR8R2 : public Register<0x4000741c> {
            using DACC2DHR = Field<0, 8>;    // DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
        };

        // Dual DAC 12-bit right-aligned data holding register
        struct DHR12RD : public Register<0x40007420> {
            using DACC1DHR = Field<0, 12>;    // DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
            using DACC2DHR = Field<16, 12>;    // DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
        };

        // DUAL DAC 12-bit left aligned data holding register
        struct DHR12LD : public Register<0x40007424> {
            using DACC1DHR = Field<4, 12>;    // DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
            using DACC2DHR = Field<20, 12>;    // DAC channel2 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
        };

        // DUAL DAC 8-bit right aligned data holding register
        struct DHR8RD : public Register<0x40007428> {
            using DACC1DHR = Field<0, 8>;    // DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
            using DACC2DHR = Field<8, 8>;    // DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
        };

        // DAC channel1 data output register
        struct DOR1 : public RegisterReadOnly<0x4000742c> {
            using DACC1DOR = Field<0, 12>;    // DAC channel1 data output These bits are read-only, they contain data output for DAC channel1.
        };

        // DAC channel2 data output register
        struct DOR2 : public RegisterReadOnly<0x40007430> {
            using DACC2DOR = Field<0, 12>;    // DAC channel2 data output These bits are read-only, they contain data output for DAC channel2.
        };

        // DAC status register
        struct SR : public Register<0x40007434> {
            using DMAUDR1 = Field<13, 1>;    // DAC channel1 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
            using CAL_FLAG1 = Field<14, 1>;    // DAC Channel 1 calibration offset status This bit is set and cleared by hardware
            using BWST1 = Field<15, 1>;    // DAC Channel 1 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization).
            using DMAUDR2 = Field<29, 1>;    // DAC channel2 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
            using CAL_FLAG2 = Field<30, 1>;    // DAC Channel 2 calibration offset status This bit is set and cleared by hardware
            using BWST2 = Field<31, 1>;    // DAC Channel 2 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR2, It is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization).
        };

        // DAC calibration control register
        struct CCR : public Register<0x40007438> {
            using OTRIM1 = Field<0, 5>;    // DAC Channel 1 offset trimming value
            using OTRIM2 = Field<16, 5>;    // DAC Channel 2 offset trimming value
        };

        // DAC mode control register
        struct MCR : public Register<0x4000743c> {
            using MODE1 = Field<0, 3>;    // DAC Channel 1 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 1 mode: DAC Channel 1 in normal Mode DAC Channel 1 in sample &amp; hold mode
            using MODE2 = Field<16, 3>;    // DAC Channel 2 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 2 mode: DAC Channel 2 in normal Mode DAC Channel 2 in sample &amp; hold mode
        };

        // DAC Sample and Hold sample time register 1
        struct SHSR1 : public Register<0x40007440> {
            using TSAMPLE1 = Field<0, 10>;    // DAC Channel 1 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, If BWSTx=1, the write operation is ignored.
        };

        // DAC Sample and Hold sample time register 2
        struct SHSR2 : public Register<0x40007444> {
            using TSAMPLE2 = Field<0, 10>;    // DAC Channel 2 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel2 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, if BWSTx=1, the write operation is ignored.
        };

        // DAC Sample and Hold hold time register
        struct SHHR : public Register<0x40007448> {
            using THOLD1 = Field<0, 10>;    // DAC Channel 1 hold Time (only valid in sample &amp; hold mode) Hold time= (THOLD[9:0]) x T LSI
            using THOLD2 = Field<16, 10>;    // DAC Channel 2 hold time (only valid in sample &amp; hold mode). Hold time= (THOLD[9:0]) x T LSI
        };

        // DAC Sample and Hold refresh time register
        struct SHRR : public Register<0x4000744c> {
            using TREFRESH1 = Field<0, 8>;    // DAC Channel 1 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
            using TREFRESH2 = Field<16, 8>;    // DAC Channel 2 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
        };

    };

    // BDMA
    struct BDMA {
        // DMA interrupt status register
        struct ISR : public RegisterReadOnly<0x58025400> {
            using GIF1 = Field<0, 1>;    // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using TCIF1 = Field<1, 1>;    // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using HTIF1 = Field<2, 1>;    // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using TEIF1 = Field<3, 1>;    // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using GIF2 = Field<4, 1>;    // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using TCIF2 = Field<5, 1>;    // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using HTIF2 = Field<6, 1>;    // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using TEIF2 = Field<7, 1>;    // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using GIF3 = Field<8, 1>;    // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using TCIF3 = Field<9, 1>;    // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using HTIF3 = Field<10, 1>;    // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using TEIF3 = Field<11, 1>;    // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using GIF4 = Field<12, 1>;    // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using TCIF4 = Field<13, 1>;    // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using HTIF4 = Field<14, 1>;    // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using TEIF4 = Field<15, 1>;    // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using GIF5 = Field<16, 1>;    // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using TCIF5 = Field<17, 1>;    // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using HTIF5 = Field<18, 1>;    // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using TEIF5 = Field<19, 1>;    // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using GIF6 = Field<20, 1>;    // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using TCIF6 = Field<21, 1>;    // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using HTIF6 = Field<22, 1>;    // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using TEIF6 = Field<23, 1>;    // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using GIF7 = Field<24, 1>;    // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using TCIF7 = Field<25, 1>;    // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using HTIF7 = Field<26, 1>;    // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using TEIF7 = Field<27, 1>;    // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using GIF8 = Field<28, 1>;    // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using TCIF8 = Field<29, 1>;    // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using HTIF8 = Field<30, 1>;    // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
            using TEIF8 = Field<31, 1>;    // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        };

        // DMA interrupt flag clear register
        struct IFCR : public RegisterWriteOnly<0x58025404> {
            using CGIF1 = Field<0, 1>;    // Channel x global interrupt clear This bit is set and cleared by software.
            using CTCIF1 = Field<1, 1>;    // Channel x transfer complete clear This bit is set and cleared by software.
            using CHTIF1 = Field<2, 1>;    // Channel x half transfer clear This bit is set and cleared by software.
            using CTEIF1 = Field<3, 1>;    // Channel x transfer error clear This bit is set and cleared by software.
            using CGIF2 = Field<4, 1>;    // Channel x global interrupt clear This bit is set and cleared by software.
            using CTCIF2 = Field<5, 1>;    // Channel x transfer complete clear This bit is set and cleared by software.
            using CHTIF2 = Field<6, 1>;    // Channel x half transfer clear This bit is set and cleared by software.
            using CTEIF2 = Field<7, 1>;    // Channel x transfer error clear This bit is set and cleared by software.
            using CGIF3 = Field<8, 1>;    // Channel x global interrupt clear This bit is set and cleared by software.
            using CTCIF3 = Field<9, 1>;    // Channel x transfer complete clear This bit is set and cleared by software.
            using CHTIF3 = Field<10, 1>;    // Channel x half transfer clear This bit is set and cleared by software.
            using CTEIF3 = Field<11, 1>;    // Channel x transfer error clear This bit is set and cleared by software.
            using CGIF4 = Field<12, 1>;    // Channel x global interrupt clear This bit is set and cleared by software.
            using CTCIF4 = Field<13, 1>;    // Channel x transfer complete clear This bit is set and cleared by software.
            using CHTIF4 = Field<14, 1>;    // Channel x half transfer clear This bit is set and cleared by software.
            using CTEIF4 = Field<15, 1>;    // Channel x transfer error clear This bit is set and cleared by software.
            using CGIF5 = Field<16, 1>;    // Channel x global interrupt clear This bit is set and cleared by software.
            using CTCIF5 = Field<17, 1>;    // Channel x transfer complete clear This bit is set and cleared by software.
            using CHTIF5 = Field<18, 1>;    // Channel x half transfer clear This bit is set and cleared by software.
            using CTEIF5 = Field<19, 1>;    // Channel x transfer error clear This bit is set and cleared by software.
            using CGIF6 = Field<20, 1>;    // Channel x global interrupt clear This bit is set and cleared by software.
            using CTCIF6 = Field<21, 1>;    // Channel x transfer complete clear This bit is set and cleared by software.
            using CHTIF6 = Field<22, 1>;    // Channel x half transfer clear This bit is set and cleared by software.
            using CTEIF6 = Field<23, 1>;    // Channel x transfer error clear This bit is set and cleared by software.
            using CGIF7 = Field<24, 1>;    // Channel x global interrupt clear This bit is set and cleared by software.
            using CTCIF7 = Field<25, 1>;    // Channel x transfer complete clear This bit is set and cleared by software.
            using CHTIF7 = Field<26, 1>;    // Channel x half transfer clear This bit is set and cleared by software.
            using CTEIF7 = Field<27, 1>;    // Channel x transfer error clear This bit is set and cleared by software.
            using CGIF8 = Field<28, 1>;    // Channel x global interrupt clear This bit is set and cleared by software.
            using CTCIF8 = Field<29, 1>;    // Channel x transfer complete clear This bit is set and cleared by software.
            using CHTIF8 = Field<30, 1>;    // Channel x half transfer clear This bit is set and cleared by software.
            using CTEIF8 = Field<31, 1>;    // Channel x transfer error clear This bit is set and cleared by software.
        };

        // DMA channel x configuration register
        struct CCR1 : public Register<0x58025408> {
            using EN = Field<0, 1>;    // Channel enable This bit is set and cleared by software.
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable This bit is set and cleared by software.
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable This bit is set and cleared by software.
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using DIR = Field<4, 1>;    // Data transfer direction This bit is set and cleared by software.
            using CIRC = Field<5, 1>;    // Circular mode This bit is set and cleared by software.
            using PINC = Field<6, 1>;    // Peripheral increment mode This bit is set and cleared by software.
            using MINC = Field<7, 1>;    // Memory increment mode This bit is set and cleared by software.
            using PSIZE = Field<8, 2>;    // Peripheral size These bits are set and cleared by software.
            using MSIZE = Field<10, 2>;    // Memory size These bits are set and cleared by software.
            using PL = Field<12, 2>;    // Channel priority level These bits are set and cleared by software.
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode This bit is set and cleared by software.
        };

        // DMA channel x number of data register
        struct CNDTR1 : public Register<0x5802540c> {
            using NDT = Field<0, 16>;    // Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
        };

        // This register must not be written when the channel is enabled.
        struct CPAR1 : public Register<0x58025410> {
            using PA = Field<0, 32>;    // Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
        };

        // This register must not be written when the channel is enabled.
        struct CMAR1 : public Register<0x58025414> {
            using MA = Field<0, 32>;    // Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
        };

        // DMA channel x configuration register
        struct CCR2 : public Register<0x5802541c> {
            using EN = Field<0, 1>;    // Channel enable This bit is set and cleared by software.
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable This bit is set and cleared by software.
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable This bit is set and cleared by software.
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using DIR = Field<4, 1>;    // Data transfer direction This bit is set and cleared by software.
            using CIRC = Field<5, 1>;    // Circular mode This bit is set and cleared by software.
            using PINC = Field<6, 1>;    // Peripheral increment mode This bit is set and cleared by software.
            using MINC = Field<7, 1>;    // Memory increment mode This bit is set and cleared by software.
            using PSIZE = Field<8, 2>;    // Peripheral size These bits are set and cleared by software.
            using MSIZE = Field<10, 2>;    // Memory size These bits are set and cleared by software.
            using PL = Field<12, 2>;    // Channel priority level These bits are set and cleared by software.
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode This bit is set and cleared by software.
        };

        // DMA channel x number of data register
        struct CNDTR2 : public Register<0x58025420> {
            using NDT = Field<0, 16>;    // Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
        };

        // This register must not be written when the channel is enabled.
        struct CPAR2 : public Register<0x58025424> {
            using PA = Field<0, 32>;    // Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
        };

        // This register must not be written when the channel is enabled.
        struct CMAR2 : public Register<0x58025428> {
            using MA = Field<0, 32>;    // Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
        };

        // DMA channel x configuration register
        struct CCR3 : public Register<0x58025430> {
            using EN = Field<0, 1>;    // Channel enable This bit is set and cleared by software.
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable This bit is set and cleared by software.
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable This bit is set and cleared by software.
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using DIR = Field<4, 1>;    // Data transfer direction This bit is set and cleared by software.
            using CIRC = Field<5, 1>;    // Circular mode This bit is set and cleared by software.
            using PINC = Field<6, 1>;    // Peripheral increment mode This bit is set and cleared by software.
            using MINC = Field<7, 1>;    // Memory increment mode This bit is set and cleared by software.
            using PSIZE = Field<8, 2>;    // Peripheral size These bits are set and cleared by software.
            using MSIZE = Field<10, 2>;    // Memory size These bits are set and cleared by software.
            using PL = Field<12, 2>;    // Channel priority level These bits are set and cleared by software.
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode This bit is set and cleared by software.
        };

        // DMA channel x number of data register
        struct CNDTR3 : public Register<0x58025434> {
            using NDT = Field<0, 16>;    // Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
        };

        // This register must not be written when the channel is enabled.
        struct CPAR3 : public Register<0x58025438> {
            using PA = Field<0, 32>;    // Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
        };

        // This register must not be written when the channel is enabled.
        struct CMAR3 : public Register<0x5802543c> {
            using MA = Field<0, 32>;    // Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
        };

        // DMA channel x configuration register
        struct CCR4 : public Register<0x58025444> {
            using EN = Field<0, 1>;    // Channel enable This bit is set and cleared by software.
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable This bit is set and cleared by software.
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable This bit is set and cleared by software.
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using DIR = Field<4, 1>;    // Data transfer direction This bit is set and cleared by software.
            using CIRC = Field<5, 1>;    // Circular mode This bit is set and cleared by software.
            using PINC = Field<6, 1>;    // Peripheral increment mode This bit is set and cleared by software.
            using MINC = Field<7, 1>;    // Memory increment mode This bit is set and cleared by software.
            using PSIZE = Field<8, 2>;    // Peripheral size These bits are set and cleared by software.
            using MSIZE = Field<10, 2>;    // Memory size These bits are set and cleared by software.
            using PL = Field<12, 2>;    // Channel priority level These bits are set and cleared by software.
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode This bit is set and cleared by software.
        };

        // DMA channel x number of data register
        struct CNDTR4 : public Register<0x58025448> {
            using NDT = Field<0, 16>;    // Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
        };

        // This register must not be written when the channel is enabled.
        struct CPAR4 : public Register<0x5802544c> {
            using PA = Field<0, 32>;    // Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
        };

        // This register must not be written when the channel is enabled.
        struct CMAR4 : public Register<0x58025450> {
            using MA = Field<0, 32>;    // Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
        };

        // DMA channel x configuration register
        struct CCR5 : public Register<0x58025458> {
            using EN = Field<0, 1>;    // Channel enable This bit is set and cleared by software.
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable This bit is set and cleared by software.
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable This bit is set and cleared by software.
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using DIR = Field<4, 1>;    // Data transfer direction This bit is set and cleared by software.
            using CIRC = Field<5, 1>;    // Circular mode This bit is set and cleared by software.
            using PINC = Field<6, 1>;    // Peripheral increment mode This bit is set and cleared by software.
            using MINC = Field<7, 1>;    // Memory increment mode This bit is set and cleared by software.
            using PSIZE = Field<8, 2>;    // Peripheral size These bits are set and cleared by software.
            using MSIZE = Field<10, 2>;    // Memory size These bits are set and cleared by software.
            using PL = Field<12, 2>;    // Channel priority level These bits are set and cleared by software.
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode This bit is set and cleared by software.
        };

        // DMA channel x number of data register
        struct CNDTR5 : public Register<0x5802545c> {
            using NDT = Field<0, 16>;    // Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
        };

        // This register must not be written when the channel is enabled.
        struct CPAR5 : public Register<0x58025460> {
            using PA = Field<0, 32>;    // Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
        };

        // This register must not be written when the channel is enabled.
        struct CMAR5 : public Register<0x58025464> {
            using MA = Field<0, 32>;    // Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
        };

        // DMA channel x configuration register
        struct CCR6 : public Register<0x5802546c> {
            using EN = Field<0, 1>;    // Channel enable This bit is set and cleared by software.
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable This bit is set and cleared by software.
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable This bit is set and cleared by software.
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using DIR = Field<4, 1>;    // Data transfer direction This bit is set and cleared by software.
            using CIRC = Field<5, 1>;    // Circular mode This bit is set and cleared by software.
            using PINC = Field<6, 1>;    // Peripheral increment mode This bit is set and cleared by software.
            using MINC = Field<7, 1>;    // Memory increment mode This bit is set and cleared by software.
            using PSIZE = Field<8, 2>;    // Peripheral size These bits are set and cleared by software.
            using MSIZE = Field<10, 2>;    // Memory size These bits are set and cleared by software.
            using PL = Field<12, 2>;    // Channel priority level These bits are set and cleared by software.
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode This bit is set and cleared by software.
        };

        // DMA channel x number of data register
        struct CNDTR6 : public Register<0x58025470> {
            using NDT = Field<0, 16>;    // Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
        };

        // This register must not be written when the channel is enabled.
        struct CPAR6 : public Register<0x58025474> {
            using PA = Field<0, 32>;    // Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
        };

        // This register must not be written when the channel is enabled.
        struct CMAR6 : public Register<0x58025478> {
            using MA = Field<0, 32>;    // Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
        };

        // DMA channel x configuration register
        struct CCR7 : public Register<0x58025480> {
            using EN = Field<0, 1>;    // Channel enable This bit is set and cleared by software.
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable This bit is set and cleared by software.
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable This bit is set and cleared by software.
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using DIR = Field<4, 1>;    // Data transfer direction This bit is set and cleared by software.
            using CIRC = Field<5, 1>;    // Circular mode This bit is set and cleared by software.
            using PINC = Field<6, 1>;    // Peripheral increment mode This bit is set and cleared by software.
            using MINC = Field<7, 1>;    // Memory increment mode This bit is set and cleared by software.
            using PSIZE = Field<8, 2>;    // Peripheral size These bits are set and cleared by software.
            using MSIZE = Field<10, 2>;    // Memory size These bits are set and cleared by software.
            using PL = Field<12, 2>;    // Channel priority level These bits are set and cleared by software.
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode This bit is set and cleared by software.
        };

        // DMA channel x number of data register
        struct CNDTR7 : public Register<0x58025484> {
            using NDT = Field<0, 16>;    // Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
        };

        // This register must not be written when the channel is enabled.
        struct CPAR7 : public Register<0x58025488> {
            using PA = Field<0, 32>;    // Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
        };

        // This register must not be written when the channel is enabled.
        struct CMAR7 : public Register<0x5802548c> {
            using MA = Field<0, 32>;    // Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
        };

        // DMA channel x configuration register
        struct CCR8 : public Register<0x58025494> {
            using EN = Field<0, 1>;    // Channel enable This bit is set and cleared by software.
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable This bit is set and cleared by software.
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable This bit is set and cleared by software.
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using DIR = Field<4, 1>;    // Data transfer direction This bit is set and cleared by software.
            using CIRC = Field<5, 1>;    // Circular mode This bit is set and cleared by software.
            using PINC = Field<6, 1>;    // Peripheral increment mode This bit is set and cleared by software.
            using MINC = Field<7, 1>;    // Memory increment mode This bit is set and cleared by software.
            using PSIZE = Field<8, 2>;    // Peripheral size These bits are set and cleared by software.
            using MSIZE = Field<10, 2>;    // Memory size These bits are set and cleared by software.
            using PL = Field<12, 2>;    // Channel priority level These bits are set and cleared by software.
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode This bit is set and cleared by software.
        };

        // DMA channel x number of data register
        struct CNDTR8 : public Register<0x58025498> {
            using NDT = Field<0, 16>;    // Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
        };

        // This register must not be written when the channel is enabled.
        struct CPAR8 : public Register<0x5802549c> {
            using PA = Field<0, 32>;    // Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
        };

        // This register must not be written when the channel is enabled.
        struct CMAR8 : public Register<0x580254a0> {
            using MA = Field<0, 32>;    // Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
        };

    };

    // DMA2D
    struct DMA2D {
        // DMA2D control register
        struct CR : public Register<0x52001000> {
            using START = Field<0, 1>;    // Start This bit can be used to launch the DMA2D according to the parameters loaded in the various configuration registers
            using SUSP = Field<1, 1>;    // Suspend This bit can be used to suspend the current transfer. This bit is set and reset by software. It is automatically reset by hardware when the START bit is reset.
            using ABORT = Field<2, 1>;    // Abort This bit can be used to abort the current transfer. This bit is set by software and is automatically reset by hardware when the START bit is reset.
            using TEIE = Field<8, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using TCIE = Field<9, 1>;    // Transfer complete interrupt enable This bit is set and cleared by software.
            using TWIE = Field<10, 1>;    // Transfer watermark interrupt enable This bit is set and cleared by software.
            using CAEIE = Field<11, 1>;    // CLUT access error interrupt enable This bit is set and cleared by software.
            using CTCIE = Field<12, 1>;    // CLUT transfer complete interrupt enable This bit is set and cleared by software.
            using CEIE = Field<13, 1>;    // Configuration Error Interrupt Enable This bit is set and cleared by software.
            using MODE = Field<16, 2>;    // DMA2D mode This bit is set and cleared by software. It cannot be modified while a transfer is ongoing.
        };

        // DMA2D Interrupt Status Register
        struct ISR : public RegisterReadOnly<0x52001004> {
            using TEIF = Field<0, 1>;    // Transfer error interrupt flag This bit is set when an error occurs during a DMA transfer (data transfer or automatic CLUT loading).
            using TCIF = Field<1, 1>;    // Transfer complete interrupt flag This bit is set when a DMA2D transfer operation is complete (data transfer only).
            using TWIF = Field<2, 1>;    // Transfer watermark interrupt flag This bit is set when the last pixel of the watermarked line has been transferred.
            using CAEIF = Field<3, 1>;    // CLUT access error interrupt flag This bit is set when the CPU accesses the CLUT while the CLUT is being automatically copied from a system memory to the internal DMA2D.
            using CTCIF = Field<4, 1>;    // CLUT transfer complete interrupt flag This bit is set when the CLUT copy from a system memory area to the internal DMA2D memory is complete.
            using CEIF = Field<5, 1>;    // Configuration error interrupt flag This bit is set when the START bit of DMA2D_CR, DMA2DFGPFCCR or DMA2D_BGPFCCR is set and a wrong configuration has been programmed.
        };

        // DMA2D interrupt flag clear register
        struct IFCR : public Register<0x52001008> {
            using CTEIF = Field<0, 1>;    // Clear Transfer error interrupt flag Programming this bit to 1 clears the TEIF flag in the DMA2D_ISR register
            using CTCIF = Field<1, 1>;    // Clear transfer complete interrupt flag Programming this bit to 1 clears the TCIF flag in the DMA2D_ISR register
            using CTWIF = Field<2, 1>;    // Clear transfer watermark interrupt flag Programming this bit to 1 clears the TWIF flag in the DMA2D_ISR register
            using CAECIF = Field<3, 1>;    // Clear CLUT access error interrupt flag Programming this bit to 1 clears the CAEIF flag in the DMA2D_ISR register
            using CCTCIF = Field<4, 1>;    // Clear CLUT transfer complete interrupt flag Programming this bit to 1 clears the CTCIF flag in the DMA2D_ISR register
            using CCEIF = Field<5, 1>;    // Clear configuration error interrupt flag Programming this bit to 1 clears the CEIF flag in the DMA2D_ISR register
        };

        // DMA2D foreground memory address register
        struct FGMAR : public Register<0x5200100c> {
            using MA = Field<0, 32>;    // Memory address Address of the data used for the foreground image. This register can only be written when data transfers are disabled. Once the data transfer has started, this register is read-only. The address alignment must match the image format selected e.g. a 32-bit per pixel format must be 32-bit aligned, a 16-bit per pixel format must be 16-bit aligned and a 4-bit per pixel format must be 8-bit aligned.
        };

        // DMA2D foreground offset register
        struct FGOR : public Register<0x52001010> {
            using LO = Field<0, 14>;    // Line offset Line offset used for the foreground expressed in pixel. This value is used to generate the address. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once a data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even.
        };

        // DMA2D background memory address register
        struct BGMAR : public Register<0x52001014> {
            using MA = Field<0, 32>;    // Memory address Address of the data used for the background image. This register can only be written when data transfers are disabled. Once a data transfer has started, this register is read-only. The address alignment must match the image format selected e.g. a 32-bit per pixel format must be 32-bit aligned, a 16-bit per pixel format must be 16-bit aligned and a 4-bit per pixel format must be 8-bit aligned.
        };

        // DMA2D background offset register
        struct BGOR : public Register<0x52001018> {
            using LO = Field<0, 14>;    // Line offset Line offset used for the background image (expressed in pixel). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even.
        };

        // DMA2D foreground PFC control register
        struct FGPFCCR : public Register<0x5200101c> {
            using CM = Field<0, 4>;    // Color mode These bits defines the color format of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. others: meaningless
            using CCM = Field<4, 1>;    // CLUT color mode This bit defines the color format of the CLUT. It can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only.
            using START = Field<5, 1>;    // Start This bit can be set to start the automatic loading of the CLUT. It is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already ongoing (data transfer or automatic background CLUT transfer).
            using CS = Field<8, 8>;    // CLUT size These bits define the size of the CLUT used for the foreground image. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1.
            using AM = Field<16, 2>;    // Alpha mode These bits select the alpha channel value to be used for the foreground image. They can only be written data the transfer are disabled. Once the transfer has started, they become read-only. other configurations are meaningless
            using CSS = Field<18, 2>;    // Chroma Sub-Sampling These bits define the chroma sub-sampling mode for YCbCr color mode. Once the transfer has started, these bits are read-only. others: meaningless
            using AI = Field<20, 1>;    // Alpha Inverted This bit inverts the alpha value. Once the transfer has started, this bit is read-only.
            using RBS = Field<21, 1>;    // Red Blue Swap This bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only.
            using ALPHA = Field<24, 8>;    // Alpha value These bits define a fixed alpha channel value which can replace the original alpha value or be multiplied by the original alpha value according to the alpha mode selected through the AM[1:0] bits. These bits can only be written when data transfers are disabled. Once a transfer has started, they become read-only.
        };

        // DMA2D foreground color register
        struct FGCOLR : public Register<0x52001020> {
            using BLUE = Field<0, 8>;    // Blue Value These bits defines the blue value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, They are read-only.
            using GREEN = Field<8, 8>;    // Green Value These bits defines the green value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, They are read-only.
            using RED = Field<16, 8>;    // Red Value These bits defines the red value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
        };

        // DMA2D background PFC control register
        struct BGPFCCR : public Register<0x52001024> {
            using CM = Field<0, 4>;    // Color mode These bits define the color format of the foreground image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. others: meaningless
            using CCM = Field<4, 1>;    // CLUT Color mode These bits define the color format of the CLUT. This register can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only.
            using START = Field<5, 1>;    // Start This bit is set to start the automatic loading of the CLUT. This bit is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in the DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already on going (data transfer or automatic BackGround CLUT transfer).
            using CS = Field<8, 8>;    // CLUT size These bits define the size of the CLUT used for the BG. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1.
            using AM = Field<16, 2>;    // Alpha mode These bits define which alpha channel value to be used for the background image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. others: meaningless
            using AI = Field<20, 1>;    // Alpha Inverted This bit inverts the alpha value. Once the transfer has started, this bit is read-only.
            using RBS = Field<21, 1>;    // Red Blue Swap This bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only.
            using ALPHA = Field<24, 8>;    // Alpha value These bits define a fixed alpha channel value which can replace the original alpha value or be multiplied with the original alpha value according to the alpha mode selected with bits AM[1: 0]. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
        };

        // DMA2D background color register
        struct BGCOLR : public Register<0x52001028> {
            using BLUE = Field<0, 8>;    // Blue Value These bits define the blue value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
            using GREEN = Field<8, 8>;    // Green Value These bits define the green value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
            using RED = Field<16, 8>;    // Red Value These bits define the red value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
        };

        // DMA2D foreground CLUT memory address register
        struct FGCMAR : public Register<0x5200102c> {
            using MA = Field<0, 32>;    // Memory Address Address of the data used for the CLUT address dedicated to the foreground image. This register can only be written when no transfer is ongoing. Once the CLUT transfer has started, this register is read-only. If the foreground CLUT format is 32-bit, the address must be 32-bit aligned.
        };

        // DMA2D background CLUT memory address register
        struct BGCMAR : public Register<0x52001030> {
            using MA = Field<0, 32>;    // Memory address Address of the data used for the CLUT address dedicated to the background image. This register can only be written when no transfer is on going. Once the CLUT transfer has started, this register is read-only. If the background CLUT format is 32-bit, the address must be 32-bit aligned.
        };

        // DMA2D output PFC control register
        struct OPFCCR : public Register<0x52001034> {
            using CM = Field<0, 3>;    // Color mode These bits define the color format of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. others: meaningless
            using AI = Field<20, 1>;    // Alpha Inverted This bit inverts the alpha value. Once the transfer has started, this bit is read-only.
            using RBS = Field<21, 1>;    // Red Blue Swap This bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only.
        };

        // DMA2D output color register
        struct OCOLR : public Register<0x52001038> {
            using BLUE = Field<0, 8>;    // Blue Value These bits define the blue value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
            using GREEN = Field<8, 8>;    // Green Value These bits define the green value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
            using RED = Field<16, 8>;    // Red Value These bits define the red value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
            using ALPHA = Field<24, 8>;    // Alpha Channel Value These bits define the alpha channel of the output color. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
        };

        // DMA2D output memory address register
        struct OMAR : public Register<0x5200103c> {
            using MA = Field<0, 32>;    // Memory Address Address of the data used for the output FIFO. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. The address alignment must match the image format selected e.g. a 32-bit per pixel format must be 32-bit aligned and a 16-bit per pixel format must be 16-bit aligned.
        };

        // DMA2D output offset register
        struct OOR : public Register<0x52001040> {
            using LO = Field<0, 14>;    // Line Offset Line offset used for the output (expressed in pixels). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
        };

        // DMA2D number of line register
        struct NLR : public Register<0x52001044> {
            using NL = Field<0, 16>;    // Number of lines Number of lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
            using PL = Field<16, 14>;    // Pixel per lines Number of pixels per lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. If any of the input image format is 4-bit per pixel, pixel per lines must be even.
        };

        // DMA2D line watermark register
        struct LWR : public Register<0x52001048> {
            using LW = Field<0, 16>;    // Line watermark These bits allow to configure the line watermark for interrupt generation. An interrupt is raised when the last pixel of the watermarked line has been transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
        };

        // DMA2D AXI master timer configuration register
        struct AMTCR : public Register<0x5200104c> {
            using EN = Field<0, 1>;    // Enable Enables the dead time functionality.
            using DT = Field<8, 8>;    // Dead Time Dead time value in the AXI clock cycle inserted between two consecutive accesses on the AXI master port. These bits represent the minimum guaranteed number of cycles between two consecutive AXI accesses.
        };

    };

    // DMAMUX
    struct DMAMUX2 {
        // DMAMux - DMA request line multiplexer channel x control register
        struct C0CR : public Register<0x58025800> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C1CR : public Register<0x58025804> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C2CR : public Register<0x58025808> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C3CR : public Register<0x5802580c> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C4CR : public Register<0x58025810> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C5CR : public Register<0x58025814> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C6CR : public Register<0x58025818> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C7CR : public Register<0x5802581c> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request generator channel x control register
        struct RG0CR : public Register<0x58025900> {
            using SIG_ID = Field<0, 5>;    // DMA request trigger input selected
            using OIE = Field<8, 1>;    // Interrupt enable at trigger event overrun
            using GE = Field<16, 1>;    // DMA request generator channel enable/disable
            using GPOL = Field<17, 2>;    // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
            using GNBREQ = Field<19, 5>;    // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
        };

        // DMAMux - DMA request generator channel x control register
        struct RG1CR : public Register<0x58025904> {
            using SIG_ID = Field<0, 5>;    // DMA request trigger input selected
            using OIE = Field<8, 1>;    // Interrupt enable at trigger event overrun
            using GE = Field<16, 1>;    // DMA request generator channel enable/disable
            using GPOL = Field<17, 2>;    // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
            using GNBREQ = Field<19, 5>;    // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
        };

        // DMAMux - DMA request generator channel x control register
        struct RG2CR : public Register<0x58025908> {
            using SIG_ID = Field<0, 5>;    // DMA request trigger input selected
            using OIE = Field<8, 1>;    // Interrupt enable at trigger event overrun
            using GE = Field<16, 1>;    // DMA request generator channel enable/disable
            using GPOL = Field<17, 2>;    // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
            using GNBREQ = Field<19, 5>;    // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
        };

        // DMAMux - DMA request generator channel x control register
        struct RG3CR : public Register<0x5802590c> {
            using SIG_ID = Field<0, 5>;    // DMA request trigger input selected
            using OIE = Field<8, 1>;    // Interrupt enable at trigger event overrun
            using GE = Field<16, 1>;    // DMA request generator channel enable/disable
            using GPOL = Field<17, 2>;    // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
            using GNBREQ = Field<19, 5>;    // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
        };

        // DMAMux - DMA request generator channel x control register
        struct RG4CR : public Register<0x58025910> {
            using SIG_ID = Field<0, 5>;    // DMA request trigger input selected
            using OIE = Field<8, 1>;    // Interrupt enable at trigger event overrun
            using GE = Field<16, 1>;    // DMA request generator channel enable/disable
            using GPOL = Field<17, 2>;    // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
            using GNBREQ = Field<19, 5>;    // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
        };

        // DMAMux - DMA request generator channel x control register
        struct RG5CR : public Register<0x58025914> {
            using SIG_ID = Field<0, 5>;    // DMA request trigger input selected
            using OIE = Field<8, 1>;    // Interrupt enable at trigger event overrun
            using GE = Field<16, 1>;    // DMA request generator channel enable/disable
            using GPOL = Field<17, 2>;    // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
            using GNBREQ = Field<19, 5>;    // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
        };

        // DMAMux - DMA request generator channel x control register
        struct RG6CR : public Register<0x58025918> {
            using SIG_ID = Field<0, 5>;    // DMA request trigger input selected
            using OIE = Field<8, 1>;    // Interrupt enable at trigger event overrun
            using GE = Field<16, 1>;    // DMA request generator channel enable/disable
            using GPOL = Field<17, 2>;    // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
            using GNBREQ = Field<19, 5>;    // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
        };

        // DMAMux - DMA request generator channel x control register
        struct RG7CR : public Register<0x5802591c> {
            using SIG_ID = Field<0, 5>;    // DMA request trigger input selected
            using OIE = Field<8, 1>;    // Interrupt enable at trigger event overrun
            using GE = Field<16, 1>;    // DMA request generator channel enable/disable
            using GPOL = Field<17, 2>;    // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
            using GNBREQ = Field<19, 5>;    // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
        };

        // DMAMux - DMA request generator status register
        struct RGSR : public RegisterReadOnly<0x58025940> {
            using OF = Field<0, 8>;    // Trigger event overrun flag The flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding COFx bit in DMAMUX_RGCFR register.
        };

        // DMAMux - DMA request generator clear flag register
        struct RGCFR : public RegisterWriteOnly<0x58025944> {
            using COF = Field<0, 8>;    // Clear trigger event overrun flag Upon setting, this bit clears the corresponding overrun flag OFx in the DMAMUX_RGCSR register.
        };

        // DMAMUX request line multiplexer interrupt channel status register
        struct CSR : public RegisterReadOnly<0x58025880> {
            using SOF = Field<0, 16>;    // Synchronization overrun event flag
        };

        // DMAMUX request line multiplexer interrupt clear flag register
        struct CFR : public RegisterWriteOnly<0x58025884> {
            using CSOF = Field<0, 16>;    // Clear synchronization overrun event flag
        };

    };

    // FMC
    struct FMC {
        // This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
        struct BCR1 : public Register<0x52004000> {
            using MBKEN = Field<0, 1>;    // Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
            using MUXEN = Field<1, 1>;    // Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
            using MTYP = Field<2, 2>;    // Memory type These bits define the type of external memory attached to the corresponding memory bank:
            using MWID = Field<4, 2>;    // Memory data bus width Defines the external memory device width, valid for all type of memories.
            using FACCEN = Field<6, 1>;    // Flash access enable This bit enables NOR Flash memory access operations.
            using BURSTEN = Field<8, 1>;    // Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
            using WAITPOL = Field<9, 1>;    // Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
            using WAITCFG = Field<11, 1>;    // Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
            using WREN = Field<12, 1>;    // Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
            using WAITEN = Field<13, 1>;    // Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
            using EXTMOD = Field<14, 1>;    // Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
            using ASYNCWAIT = Field<15, 1>;    // Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
            using CPSIZE = Field<16, 3>;    // CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
            using CBURSTRW = Field<19, 1>;    // Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
            using CCLKEN = Field<20, 1>;    // Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
            using WFDIS = Field<21, 1>;    // Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
            using BMAP = Field<24, 2>;    // FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register.
            using FMCEN = Field<31, 1>;    // FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
        };

        // This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
        struct BTR1 : public Register<0x52004004> {
            using ADDSET = Field<0, 4>;    // Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.
            using ADDHLD = Field<4, 4>;    // Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
            using DATAST = Field<8, 8>;    // Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
            using BUSTURN = Field<16, 4>;    // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD = 126. ...
            using CLKDIV = Field<20, 4>;    // Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
            using DATLAT = Field<24, 4>;    // Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
            using ACCMOD = Field<28, 2>;    // Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
        };

        // This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
        struct BCR2 : public Register<0x52004008> {
            using MBKEN = Field<0, 1>;    // Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
            using MUXEN = Field<1, 1>;    // Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
            using MTYP = Field<2, 2>;    // Memory type These bits define the type of external memory attached to the corresponding memory bank:
            using MWID = Field<4, 2>;    // Memory data bus width Defines the external memory device width, valid for all type of memories.
            using FACCEN = Field<6, 1>;    // Flash access enable This bit enables NOR Flash memory access operations.
            using BURSTEN = Field<8, 1>;    // Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
            using WAITPOL = Field<9, 1>;    // Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
            using WAITCFG = Field<11, 1>;    // Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
            using WREN = Field<12, 1>;    // Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
            using WAITEN = Field<13, 1>;    // Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
            using EXTMOD = Field<14, 1>;    // Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
            using ASYNCWAIT = Field<15, 1>;    // Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
            using CPSIZE = Field<16, 3>;    // CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
            using CBURSTRW = Field<19, 1>;    // Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
            using CCLKEN = Field<20, 1>;    // Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
            using WFDIS = Field<21, 1>;    // Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
            using BMAP = Field<24, 2>;    // FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register.
            using FMCEN = Field<31, 1>;    // FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
        };

        // This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
        struct BTR2 : public Register<0x5200400c> {
            using ADDSET = Field<0, 4>;    // Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.
            using ADDHLD = Field<4, 4>;    // Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
            using DATAST = Field<8, 8>;    // Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
            using BUSTURN = Field<16, 4>;    // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD = 1. ...
            using CLKDIV = Field<20, 4>;    // Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
            using DATLAT = Field<24, 4>;    // Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
            using ACCMOD = Field<28, 2>;    // Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
        };

        // This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
        struct BCR3 : public Register<0x52004010> {
            using MBKEN = Field<0, 1>;    // Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
            using MUXEN = Field<1, 1>;    // Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
            using MTYP = Field<2, 2>;    // Memory type These bits define the type of external memory attached to the corresponding memory bank:
            using MWID = Field<4, 2>;    // Memory data bus width Defines the external memory device width, valid for all type of memories.
            using FACCEN = Field<6, 1>;    // Flash access enable This bit enables NOR Flash memory access operations.
            using BURSTEN = Field<8, 1>;    // Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
            using WAITPOL = Field<9, 1>;    // Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
            using WAITCFG = Field<11, 1>;    // Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
            using WREN = Field<12, 1>;    // Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
            using WAITEN = Field<13, 1>;    // Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
            using EXTMOD = Field<14, 1>;    // Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
            using ASYNCWAIT = Field<15, 1>;    // Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
            using CPSIZE = Field<16, 3>;    // CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
            using CBURSTRW = Field<19, 1>;    // Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
            using CCLKEN = Field<20, 1>;    // Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
            using WFDIS = Field<21, 1>;    // Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
            using BMAP = Field<24, 2>;    // FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register.
            using FMCEN = Field<31, 1>;    // FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
        };

        // This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
        struct BTR3 : public Register<0x52004014> {
            using ADDSET = Field<0, 4>;    // Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.
            using ADDHLD = Field<4, 4>;    // Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
            using DATAST = Field<8, 8>;    // Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
            using BUSTURN = Field<16, 4>;    // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD =1. ...
            using CLKDIV = Field<20, 4>;    // Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
            using DATLAT = Field<24, 4>;    // Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
            using ACCMOD = Field<28, 2>;    // Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
        };

        // This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
        struct BCR4 : public Register<0x52004018> {
            using MBKEN = Field<0, 1>;    // Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
            using MUXEN = Field<1, 1>;    // Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
            using MTYP = Field<2, 2>;    // Memory type These bits define the type of external memory attached to the corresponding memory bank:
            using MWID = Field<4, 2>;    // Memory data bus width Defines the external memory device width, valid for all type of memories.
            using FACCEN = Field<6, 1>;    // Flash access enable This bit enables NOR Flash memory access operations.
            using BURSTEN = Field<8, 1>;    // Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
            using WAITPOL = Field<9, 1>;    // Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
            using WAITCFG = Field<11, 1>;    // Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
            using WREN = Field<12, 1>;    // Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
            using WAITEN = Field<13, 1>;    // Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
            using EXTMOD = Field<14, 1>;    // Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
            using ASYNCWAIT = Field<15, 1>;    // Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
            using CPSIZE = Field<16, 3>;    // CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
            using CBURSTRW = Field<19, 1>;    // Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
            using CCLKEN = Field<20, 1>;    // Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
            using WFDIS = Field<21, 1>;    // Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
            using BMAP = Field<24, 2>;    // FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register.
            using FMCEN = Field<31, 1>;    // FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
        };

        // This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
        struct BTR4 : public Register<0x5200401c> {
            using ADDSET = Field<0, 4>;    // Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.
            using ADDHLD = Field<4, 4>;    // Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
            using DATAST = Field<8, 8>;    // Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
            using BUSTURN = Field<16, 4>;    // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD =1. ...
            using CLKDIV = Field<20, 4>;    // Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
            using DATLAT = Field<24, 4>;    // Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
            using ACCMOD = Field<28, 2>;    // Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
        };

        // NAND Flash control registers
        struct PCR : public Register<0x52004080> {
            using PWAITEN = Field<1, 1>;    // Wait feature enable bit. This bit enables the Wait feature for the NAND Flash memory bank:
            using PBKEN = Field<2, 1>;    // NAND Flash memory bank enable bit. This bit enables the memory bank. Accessing a disabled memory bank causes an ERROR on AXI bus
            using PWID = Field<4, 2>;    // Data bus width. These bits define the external memory device width.
            using ECCEN = Field<6, 1>;    // ECC computation logic enable bit
            using TCLR = Field<9, 4>;    // CLE to RE delay. These bits set time from CLE low to RE low in number of KCK_FMC clock cycles. The time is give by the following formula: t_clr = (TCLR + SET + 2) TKCK_FMC where TKCK_FMC is the KCK_FMC clock period Note: Set is MEMSET or ATTSET according to the addressed space.
            using TAR = Field<13, 4>;    // ALE to RE delay. These bits set time from ALE low to RE low in number of KCK_FMC clock cycles. Time is: t_ar = (TAR + SET + 2) TKCK_FMC where TKCK_FMC is the FMC clock period Note: Set is MEMSET or ATTSET according to the addressed space.
            using ECCPS = Field<17, 3>;    // ECC page size. These bits define the page size for the extended ECC:
        };

        // This register contains information about the FIFO status and interrupt. The FMC features a FIFO that is used when writing to memories to transfer up to 16 words of data.This is used to quickly write to the FIFO and free the AXI bus for transactions to peripherals other than the FMC, while the FMC is draining its FIFO into the memory. One of these register bits indicates the status of the FIFO, for ECC purposes.The ECC is calculated while the data are written to the memory. To read the correct ECC, the software must consequently wait until the FIFO is empty.
        struct SR : public Register<0x52004084> {
            using IRS = Field<0, 1>;    // Interrupt rising edge status The flag is set by hardware and reset by software. Note: If this bit is written by software to 1 it will be set.
            using ILS = Field<1, 1>;    // Interrupt high-level status The flag is set by hardware and reset by software.
            using IFS = Field<2, 1>;    // Interrupt falling edge status The flag is set by hardware and reset by software. Note: If this bit is written by software to 1 it will be set.
            using IREN = Field<3, 1>;    // Interrupt rising edge detection enable bit
            using ILEN = Field<4, 1>;    // Interrupt high-level detection enable bit
            using IFEN = Field<5, 1>;    // Interrupt falling edge detection enable bit
            using FEMPT = Field<6, 1>;    // FIFO empty. Read-only bit that provides the status of the FIFO
        };

        // The FMC_PMEM read/write register contains the timing information for NAND Flash memory bank. This information is used to access either the common memory space of the NAND Flash for command, address write access and data read/write access.
        struct PMEM : public Register<0x52004088> {
            using MEMSET = Field<0, 8>;    // Common memory x setup time These bits define the number of KCK_FMC (+1) clock cycles to set up the address before the command assertion (NWE, NOE), for NAND Flash read or write access to common memory space:
            using MEMWAIT = Field<8, 8>;    // Common memory wait time These bits define the minimum number of KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND Flash read or write access to common memory space. The duration of command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC:
            using MEMHOLD = Field<16, 8>;    // Common memory hold time These bits define the number of KCK_FMC clock cycles for write accesses and KCK_FMC+1 clock cycles for read accesses during which the address is held (and data for write accesses) after the command is de-asserted (NWE, NOE), for NAND Flash read or write access to common memory space:
            using MEMHIZ = Field<24, 8>;    // Common memory x data bus Hi-Z time These bits define the number of KCK_FMC clock cycles during which the data bus is kept Hi-Z after the start of a NAND Flash write access to common memory space. This is only valid for write transactions:
        };

        // The FMC_PATT read/write register contains the timing information for NAND Flash memory bank. It is used for 8-bit accesses to the attribute memory space of the NAND Flash for the last address write access if the timing must differ from that of previous accesses (for Ready/Busy management, refer to Section20.8.5: NAND Flash prewait feature).
        struct PATT : public Register<0x5200408c> {
            using ATTSET = Field<0, 8>;    // Attribute memory setup time These bits define the number of KCK_FMC (+1) clock cycles to set up address before the command assertion (NWE, NOE), for NAND Flash read or write access to attribute memory space:
            using ATTWAIT = Field<8, 8>;    // Attribute memory wait time These bits define the minimum number of x KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND Flash read or write access to attribute memory space. The duration for command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC:
            using ATTHOLD = Field<16, 8>;    // Attribute memory hold time These bits define the number of KCK_FMC clock cycles during which the address is held (and data for write access) after the command de-assertion (NWE, NOE), for NAND Flash read or write access to attribute memory space:
            using ATTHIZ = Field<24, 8>;    // Attribute memory data bus Hi-Z time These bits define the number of KCK_FMC clock cycles during which the data bus is kept in Hi-Z after the start of a NAND Flash write access to attribute memory space on socket. Only valid for writ transaction:
        };

        // This register contain the current error correction code value computed by the ECC computation modules of the FMC NAND controller. When the CPU reads/writes the data from a NAND Flash memory page at the correct address (refer to Section20.8.6: Computation of the error correction code (ECC) in NAND Flash memory), the data read/written from/to the NAND Flash memory are processed automatically by the ECC computation module. When X bytes have been read (according to the ECCPS field in the FMC_PCR registers), the CPU must read the computed ECC value from the FMC_ECC registers. It then verifies if these computed parity data are the same as the parity value recorded in the spare area, to determine whether a page is valid, and, to correct it otherwise. The FMC_ECCR register should be cleared after being read by setting the ECCEN bit to 0. To compute a new data block, the ECCEN bit must be set to 1.
        struct ECCR : public RegisterReadOnly<0x52004094> {
            using ECC = Field<0, 32>;    // ECC result This field contains the value computed by the ECC computation logic. Table167 describes the contents of these bit fields.
        };

        // This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
        struct BWTR1 : public Register<0x52004104> {
            using ADDSET = Field<0, 4>;    // Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.
            using ADDHLD = Field<4, 4>;    // Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
            using DATAST = Field<8, 8>;    // Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
            using BUSTURN = Field<16, 4>;    // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
            using ACCMOD = Field<28, 2>;    // Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
        };

        // This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
        struct BWTR2 : public Register<0x5200410c> {
            using ADDSET = Field<0, 4>;    // Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.
            using ADDHLD = Field<4, 4>;    // Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
            using DATAST = Field<8, 8>;    // Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
            using BUSTURN = Field<16, 4>;    // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
            using ACCMOD = Field<28, 2>;    // Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
        };

        // This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
        struct BWTR3 : public Register<0x52004114> {
            using ADDSET = Field<0, 4>;    // Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.
            using ADDHLD = Field<4, 4>;    // Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
            using DATAST = Field<8, 8>;    // Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
            using BUSTURN = Field<16, 4>;    // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
            using ACCMOD = Field<28, 2>;    // Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
        };

        // This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
        struct BWTR4 : public Register<0x5200411c> {
            using ADDSET = Field<0, 4>;    // Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.
            using ADDHLD = Field<4, 4>;    // Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
            using DATAST = Field<8, 8>;    // Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
            using BUSTURN = Field<16, 4>;    // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
            using ACCMOD = Field<28, 2>;    // Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
        };

        // This register contains the control parameters for each SDRAM memory bank
        struct SDCR1 : public Register<0x52004140> {
            using NC = Field<0, 2>;    // Number of column address bits These bits define the number of bits of a column address.
            using NR = Field<2, 2>;    // Number of row address bits These bits define the number of bits of a row address.
            using MWID = Field<4, 2>;    // Memory data bus width. These bits define the memory device width.
            using NB = Field<6, 1>;    // Number of internal banks This bit sets the number of internal banks.
            using CAS = Field<7, 2>;    // CAS Latency This bits sets the SDRAM CAS latency in number of memory clock cycles
            using WP = Field<9, 1>;    // Write protection This bit enables write mode access to the SDRAM bank.
            using SDCLK = Field<10, 2>;    // SDRAM clock configuration These bits define the SDRAM clock period for both SDRAM banks and allow disabling the clock before changing the frequency. In this case the SDRAM must be re-initialized. Note: The corresponding bits in the FMC_SDCR2 register is read only.
            using RBURST = Field<12, 1>;    // Burst read This bit enables burst read mode. The SDRAM controller anticipates the next read commands during the CAS latency and stores data in the Read FIFO. Note: The corresponding bit in the FMC_SDCR2 register is read only.
            using RPIPE = Field<13, 2>;    // Read pipe These bits define the delay, in KCK_FMC clock cycles, for reading data after CAS latency. Note: The corresponding bits in the FMC_SDCR2 register is read only.
        };

        // This register contains the control parameters for each SDRAM memory bank
        struct SDCR2 : public Register<0x52004144> {
            using NC = Field<0, 2>;    // Number of column address bits These bits define the number of bits of a column address.
            using NR = Field<2, 2>;    // Number of row address bits These bits define the number of bits of a row address.
            using MWID = Field<4, 2>;    // Memory data bus width. These bits define the memory device width.
            using NB = Field<6, 1>;    // Number of internal banks This bit sets the number of internal banks.
            using CAS = Field<7, 2>;    // CAS Latency This bits sets the SDRAM CAS latency in number of memory clock cycles
            using WP = Field<9, 1>;    // Write protection This bit enables write mode access to the SDRAM bank.
            using SDCLK = Field<10, 2>;    // SDRAM clock configuration These bits define the SDRAM clock period for both SDRAM banks and allow disabling the clock before changing the frequency. In this case the SDRAM must be re-initialized. Note: The corresponding bits in the FMC_SDCR2 register is read only.
            using RBURST = Field<12, 1>;    // Burst read This bit enables burst read mode. The SDRAM controller anticipates the next read commands during the CAS latency and stores data in the Read FIFO. Note: The corresponding bit in the FMC_SDCR2 register is read only.
            using RPIPE = Field<13, 2>;    // Read pipe These bits define the delay, in KCK_FMC clock cycles, for reading data after CAS latency. Note: The corresponding bits in the FMC_SDCR2 register is read only.
        };

        // This register contains the timing parameters of each SDRAM bank
        struct SDTR1 : public Register<0x52004148> {
            using TMRD = Field<0, 4>;    // Load Mode Register to Active These bits define the delay between a Load Mode Register command and an Active or Refresh command in number of memory clock cycles. ....
            using TXSR = Field<4, 4>;    // Exit Self-refresh delay These bits define the delay from releasing the Self-refresh command to issuing the Activate command in number of memory clock cycles. .... Note: If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TXSR timing corresponding to the slowest SDRAM device.
            using TRAS = Field<8, 4>;    // Self refresh time These bits define the minimum Self-refresh period in number of memory clock cycles. ....
            using TRC = Field<12, 4>;    // Row cycle delay These bits define the delay between the Refresh command and the Activate command, as well as the delay between two consecutive Refresh commands. It is expressed in number of memory clock cycles. The TRC timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRC must be programmed with the timings of the slowest device. .... Note: TRC must match the TRC and TRFC (Auto Refresh period) timings defined in the SDRAM device datasheet. Note: The corresponding bits in the FMC_SDTR2 register are dont care.
            using TWR = Field<16, 4>;    // Recovery delay These bits define the delay between a Write and a Precharge command in number of memory clock cycles. .... Note: TWR must be programmed to match the write recovery time (tWR) defined in the SDRAM datasheet, and to guarantee that: TWR &#8805; TRAS - TRCD and TWR &#8805;TRC - TRCD - TRP Example: TRAS= 4 cycles, TRCD= 2 cycles. So, TWR &gt;= 2 cycles. TWR must be programmed to 0x1. If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TWR timing corresponding to the slowest SDRAM device.
            using TRP = Field<20, 4>;    // Row precharge delay These bits define the delay between a Precharge command and another command in number of memory clock cycles. The TRP timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRP must be programmed with the timing of the slowest device. .... Note: The corresponding bits in the FMC_SDTR2 register are dont care.
            using TRCD = Field<24, 4>;    // Row to column delay These bits define the delay between the Activate command and a Read/Write command in number of memory clock cycles. ....
        };

        // This register contains the timing parameters of each SDRAM bank
        struct SDTR2 : public Register<0x5200414c> {
            using TMRD = Field<0, 4>;    // Load Mode Register to Active These bits define the delay between a Load Mode Register command and an Active or Refresh command in number of memory clock cycles. ....
            using TXSR = Field<4, 4>;    // Exit Self-refresh delay These bits define the delay from releasing the Self-refresh command to issuing the Activate command in number of memory clock cycles. .... Note: If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TXSR timing corresponding to the slowest SDRAM device.
            using TRAS = Field<8, 4>;    // Self refresh time These bits define the minimum Self-refresh period in number of memory clock cycles. ....
            using TRC = Field<12, 4>;    // Row cycle delay These bits define the delay between the Refresh command and the Activate command, as well as the delay between two consecutive Refresh commands. It is expressed in number of memory clock cycles. The TRC timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRC must be programmed with the timings of the slowest device. .... Note: TRC must match the TRC and TRFC (Auto Refresh period) timings defined in the SDRAM device datasheet. Note: The corresponding bits in the FMC_SDTR2 register are dont care.
            using TWR = Field<16, 4>;    // Recovery delay These bits define the delay between a Write and a Precharge command in number of memory clock cycles. .... Note: TWR must be programmed to match the write recovery time (tWR) defined in the SDRAM datasheet, and to guarantee that: TWR &#8805; TRAS - TRCD and TWR &#8805;TRC - TRCD - TRP Example: TRAS= 4 cycles, TRCD= 2 cycles. So, TWR &gt;= 2 cycles. TWR must be programmed to 0x1. If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TWR timing corresponding to the slowest SDRAM device.
            using TRP = Field<20, 4>;    // Row precharge delay These bits define the delay between a Precharge command and another command in number of memory clock cycles. The TRP timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRP must be programmed with the timing of the slowest device. .... Note: The corresponding bits in the FMC_SDTR2 register are dont care.
            using TRCD = Field<24, 4>;    // Row to column delay These bits define the delay between the Activate command and a Read/Write command in number of memory clock cycles. ....
        };

        // This register contains the command issued when the SDRAM device is accessed. This register is used to initialize the SDRAM device, and to activate the Self-refresh and the Power-down modes. As soon as the MODE field is written, the command will be issued only to one or to both SDRAM banks according to CTB1 and CTB2 command bits. This register is the same for both SDRAM banks.
        struct SDCMR : public Register<0x52004150> {
            using MODE = Field<0, 3>;    // Command mode These bits define the command issued to the SDRAM device. Note: When a command is issued, at least one Command Target Bank bit ( CTB1 or CTB2) must be set otherwise the command will be ignored. Note: If two SDRAM banks are used, the Auto-refresh and PALL command must be issued simultaneously to the two devices with CTB1 and CTB2 bits set otherwise the command will be ignored. Note: If only one SDRAM bank is used and a command is issued with its associated CTB bit set, the other CTB bit of the unused bank must be kept to 0.
            using CTB2 = Field<3, 1>;    // Command Target Bank 2 This bit indicates whether the command will be issued to SDRAM Bank 2 or not.
            using CTB1 = Field<4, 1>;    // Command Target Bank 1 This bit indicates whether the command will be issued to SDRAM Bank 1 or not.
            using NRFS = Field<5, 4>;    // Number of Auto-refresh These bits define the number of consecutive Auto-refresh commands issued when MODE = 011. ....
            using MRD = Field<9, 14>;    // Mode Register definition This 14-bit field defines the SDRAM Mode Register content. The Mode Register is programmed using the Load Mode Register command. The MRD[13:0] bits are also used to program the extended mode register for mobile SDRAM.
        };

        // This register sets the refresh rate in number of SDCLK clock cycles between the refresh cycles by configuring the Refresh Timer Count value.Examplewhere 64 ms is the SDRAM refresh period.The refresh rate must be increased by 20 SDRAM clock cycles (as in the above example) to obtain a safe margin if an internal refresh request occurs when a read request has been accepted. It corresponds to a COUNT value of 0000111000000 (448). This 13-bit field is loaded into a timer which is decremented using the SDRAM clock. This timer generates a refresh pulse when zero is reached. The COUNT value must be set at least to 41 SDRAM clock cycles.As soon as the FMC_SDRTR register is programmed, the timer starts counting. If the value programmed in the register is 0, no refresh is carried out. This register must not be reprogrammed after the initialization procedure to avoid modifying the refresh rate.Each time a refresh pulse is generated, this 13-bit COUNT field is reloaded into the counter.If a memory access is in progress, the Auto-refresh request is delayed. However, if the memory access and Auto-refresh requests are generated simultaneously, the Auto-refresh takes precedence. If the memory access occurs during a refresh operation, the request is buffered to be processed when the refresh is complete.This register is common to SDRAM bank 1 and bank 2.
        struct SDRTR : public Register<0x52004154> {
            using CRE = Field<0, 1>;    // Clear Refresh error flag This bit is used to clear the Refresh Error Flag (RE) in the Status Register.
            using COUNT = Field<1, 13>;    // Refresh Timer Count This 13-bit field defines the refresh rate of the SDRAM device. It is expressed in number of memory clock cycles. It must be set at least to 41 SDRAM clock cycles (0x29). Refresh rate = (COUNT + 1) x SDRAM frequency clock COUNT = (SDRAM refresh period / Number of rows) - 20
            using REIE = Field<14, 1>;    // RES Interrupt Enable
        };

        // SDRAM Status register
        struct SDSR : public RegisterReadOnly<0x52004158> {
            using RE = Field<0, 1>;    // Refresh error flag An interrupt is generated if REIE = 1 and RE = 1
            using MODES1 = Field<1, 2>;    // Status Mode for Bank 1 These bits define the Status Mode of SDRAM Bank 1.
            using MODES2 = Field<3, 2>;    // Status Mode for Bank 2 These bits define the Status Mode of SDRAM Bank 2.
        };

    };

    // CEC
    struct CEC {
        // CEC control register
        struct CR : public Register<0x40006c00> {
            using CECEN = Field<0, 1>;    // CEC Enable The CECEN bit is set and cleared by software. CECEN=1 starts message reception and enables the TXSOM control. CECEN=0 disables the CEC peripheral, clears all bits of CEC_CR register and aborts any on-going reception or transmission.
            using TXSOM = Field<1, 1>;    // Tx Start Of Message TXSOM is set by software to command transmission of the first byte of a CEC message. If the CEC message consists of only one byte, TXEOM must be set before of TXSOM. Start-Bit is effectively started on the CEC line after SFT is counted. If TXSOM is set while a message reception is ongoing, transmission will start after the end of reception. TXSOM is cleared by hardware after the last byte of the message is sent with a positive acknowledge (TXEND=1), in case of transmission underrun (TXUDR=1), negative acknowledge (TXACKE=1), and transmission error (TXERR=1). It is also cleared by CECEN=0. It is not cleared and transmission is automatically retried in case of arbitration lost (ARBLST=1). TXSOM can be also used as a status bit informing application whether any transmission request is pending or under execution. The application can abort a transmission request at any time by clearing the CECEN bit. Note: TXSOM must be set when CECEN=1 TXSOM must be set when transmission data is available into TXDR HEADERs first four bits containing own peripheral address are taken from TXDR[7:4], not from CEC_CFGR.OAR which is used only for reception
            using TXEOM = Field<2, 1>;    // Tx End Of Message The TXEOM bit is set by software to command transmission of the last byte of a CEC message. TXEOM is cleared by hardware at the same time and under the same conditions as for TXSOM. Note: TXEOM must be set when CECEN=1 TXEOM must be set before writing transmission data to TXDR If TXEOM is set when TXSOM=0, transmitted message will consist of 1 byte (HEADER) only (PING message)
        };

        // This register is used to configure the HDMI-CEC controller. It is mandatory to write CEC_CFGR only when CECEN=0.
        struct CFGR : public Register<0x40006c04> {
            using SFT = Field<0, 3>;    // Signal Free Time SFT bits are set by software. In the SFT=0x0 configuration the number of nominal data bit periods waited before transmission is ruled by hardware according to the transmission history. In all the other configurations the SFT number is determined by software. * 0x0 ** 2.5 Data-Bit periods if CEC is the last bus initiator with unsuccessful transmission (ARBLST=1, TXERR=1, TXUDR=1 or TXACKE= 1) ** 4 Data-Bit periods if CEC is the new bus initiator ** 6 Data-Bit periods if CEC is the last bus initiator with successful transmission (TXEOM=1) * 0x1: 0.5 nominal data bit periods * 0x2: 1.5 nominal data bit periods * 0x3: 2.5 nominal data bit periods * 0x4: 3.5 nominal data bit periods * 0x5: 4.5 nominal data bit periods * 0x6: 5.5 nominal data bit periods * 0x7: 6.5 nominal data bit periods
            using RXTOL = Field<3, 1>;    // Rx-Tolerance The RXTOL bit is set and cleared by software. ** Start-Bit, +/- 200 s rise, +/- 200 s fall. ** Data-Bit: +/- 200 s rise. +/- 350 s fall. ** Start-Bit: +/- 400 s rise, +/- 400 s fall ** Data-Bit: +/-300 s rise, +/- 500 s fall
            using BRESTP = Field<4, 1>;    // Rx-Stop on Bit Rising Error The BRESTP bit is set and cleared by software.
            using BREGEN = Field<5, 1>;    // Generate Error-Bit on Bit Rising Error The BREGEN bit is set and cleared by software. Note: If BRDNOGEN=0, an Error-bit is generated upon BRE detection with BRESTP=1 in broadcast even if BREGEN=0
            using LBPEGEN = Field<6, 1>;    // Generate Error-Bit on Long Bit Period Error The LBPEGEN bit is set and cleared by software. Note: If BRDNOGEN=0, an Error-bit is generated upon LBPE detection in broadcast even if LBPEGEN=0
            using BRDNOGEN = Field<7, 1>;    // Avoid Error-Bit Generation in Broadcast The BRDNOGEN bit is set and cleared by software.
            using SFTOPT = Field<8, 1>;    // SFT Option Bit The SFTOPT bit is set and cleared by software.
            using OAR = Field<16, 15>;    // Own addresses configuration The OAR bits are set by software to select which destination logical addresses has to be considered in receive mode. Each bit, when set, enables the CEC logical address identified by the given bit position. At the end of HEADER reception, the received destination address is compared with the enabled addresses. In case of matching address, the incoming message is acknowledged and received. In case of non-matching address, the incoming message is received only in listen mode (LSTN=1), but without acknowledge sent. Broadcast messages are always received. Example: OAR = 0b000 0000 0010 0001 means that CEC acknowledges addresses 0x0 and 0x5. Consequently, each message directed to one of these addresses is received.
            using LSTN = Field<31, 1>;    // Listen mode LSTN bit is set and cleared by software.
        };

        // CEC Tx data register
        struct TXDR : public RegisterWriteOnly<0x40006c08> {
            using TXD = Field<0, 8>;    // Tx Data register. TXD is a write-only register containing the data byte to be transmitted. Note: TXD must be written when TXSTART=1
        };

        // CEC Rx Data Register
        struct RXDR : public RegisterReadOnly<0x40006c0c> {
            using RXD = Field<0, 8>;    // Rx Data register. RXD is read-only and contains the last data byte which has been received from the CEC line.
        };

        // CEC Interrupt and Status Register
        struct ISR : public Register<0x40006c10> {
            using RXBR = Field<0, 1>;    // Rx-Byte Received The RXBR bit is set by hardware to inform application that a new byte has been received from the CEC line and stored into the RXD buffer. RXBR is cleared by software write at 1.
            using RXEND = Field<1, 1>;    // End Of Reception RXEND is set by hardware to inform application that the last byte of a CEC message is received from the CEC line and stored into the RXD buffer. RXEND is set at the same time of RXBR. RXEND is cleared by software write at 1.
            using RXOVR = Field<2, 1>;    // Rx-Overrun RXOVR is set by hardware if RXBR is not yet cleared at the time a new byte is received on the CEC line and stored into RXD. RXOVR assertion stops message reception so that no acknowledge is sent. In case of broadcast, a negative acknowledge is sent. RXOVR is cleared by software write at 1.
            using BRE = Field<3, 1>;    // Rx-Bit Rising Error BRE is set by hardware in case a Data-Bit waveform is detected with Bit Rising Error. BRE is set either at the time the misplaced rising edge occurs, or at the end of the maximum BRE tolerance allowed by RXTOL, in case rising edge is still longing. BRE stops message reception if BRESTP=1. BRE generates an Error-Bit on the CEC line if BREGEN=1. BRE is cleared by software write at 1.
            using SBPE = Field<4, 1>;    // Rx-Short Bit Period Error SBPE is set by hardware in case a Data-Bit waveform is detected with Short Bit Period Error. SBPE is set at the time the anticipated falling edge occurs. SBPE generates an Error-Bit on the CEC line. SBPE is cleared by software write at 1.
            using LBPE = Field<5, 1>;    // Rx-Long Bit Period Error LBPE is set by hardware in case a Data-Bit waveform is detected with Long Bit Period Error. LBPE is set at the end of the maximum bit-extension tolerance allowed by RXTOL, in case falling edge is still longing. LBPE always stops reception of the CEC message. LBPE generates an Error-Bit on the CEC line if LBPEGEN=1. In case of broadcast, Error-Bit is generated even in case of LBPEGEN=0. LBPE is cleared by software write at 1.
            using RXACKE = Field<6, 1>;    // Rx-Missing Acknowledge In receive mode, RXACKE is set by hardware to inform application that no acknowledge was seen on the CEC line. RXACKE applies only for broadcast messages and in listen mode also for not directly addressed messages (destination address not enabled in OAR). RXACKE aborts message reception. RXACKE is cleared by software write at 1.
            using ARBLST = Field<7, 1>;    // Arbitration Lost ARBLST is set by hardware to inform application that CEC device is switching to reception due to arbitration lost event following the TXSOM command. ARBLST can be due either to a contending CEC device starting earlier or starting at the same time but with higher HEADER priority. After ARBLST assertion TXSOM bit keeps pending for next transmission attempt. ARBLST is cleared by software write at 1.
            using TXBR = Field<8, 1>;    // Tx-Byte Request TXBR is set by hardware to inform application that the next transmission data has to be written to TXDR. TXBR is set when the 4th bit of currently transmitted byte is sent. Application must write the next byte to TXDR within 6 nominal data-bit periods before transmission underrun error occurs (TXUDR). TXBR is cleared by software write at 1.
            using TXEND = Field<9, 1>;    // End of Transmission TXEND is set by hardware to inform application that the last byte of the CEC message has been successfully transmitted. TXEND clears the TXSOM and TXEOM control bits. TXEND is cleared by software write at 1.
            using TXUDR = Field<10, 1>;    // Tx-Buffer Underrun In transmission mode, TXUDR is set by hardware if application was not in time to load TXDR before of next byte transmission. TXUDR aborts message transmission and clears TXSOM and TXEOM control bits. TXUDR is cleared by software write at 1
            using TXERR = Field<11, 1>;    // Tx-Error In transmission mode, TXERR is set by hardware if the CEC initiator detects low impedance on the CEC line while it is released. TXERR aborts message transmission and clears TXSOM and TXEOM controls. TXERR is cleared by software write at 1.
            using TXACKE = Field<12, 1>;    // Tx-Missing Acknowledge Error In transmission mode, TXACKE is set by hardware to inform application that no acknowledge was received. In case of broadcast transmission, TXACKE informs application that a negative acknowledge was received. TXACKE aborts message transmission and clears TXSOM and TXEOM controls. TXACKE is cleared by software write at 1.
        };

        // CEC interrupt enable register
        struct IER : public Register<0x40006c14> {
            using RXBRIE = Field<0, 1>;    // Rx-Byte Received Interrupt Enable The RXBRIE bit is set and cleared by software.
            using RXENDIE = Field<1, 1>;    // End Of Reception Interrupt Enable The RXENDIE bit is set and cleared by software.
            using RXOVRIE = Field<2, 1>;    // Rx-Buffer Overrun Interrupt Enable The RXOVRIE bit is set and cleared by software.
            using BREIE = Field<3, 1>;    // Bit Rising Error Interrupt Enable The BREIE bit is set and cleared by software.
            using SBPEIE = Field<4, 1>;    // Short Bit Period Error Interrupt Enable The SBPEIE bit is set and cleared by software.
            using LBPEIE = Field<5, 1>;    // Long Bit Period Error Interrupt Enable The LBPEIE bit is set and cleared by software.
            using RXACKIE = Field<6, 1>;    // Rx-Missing Acknowledge Error Interrupt Enable The RXACKIE bit is set and cleared by software.
            using ARBLSTIE = Field<7, 1>;    // Arbitration Lost Interrupt Enable The ARBLSTIE bit is set and cleared by software.
            using TXBRIE = Field<8, 1>;    // Tx-Byte Request Interrupt Enable The TXBRIE bit is set and cleared by software.
            using TXENDIE = Field<9, 1>;    // Tx-End Of Message Interrupt Enable The TXENDIE bit is set and cleared by software.
            using TXUDRIE = Field<10, 1>;    // Tx-Underrun Interrupt Enable The TXUDRIE bit is set and cleared by software.
            using TXERRIE = Field<11, 1>;    // Tx-Error Interrupt Enable The TXERRIE bit is set and cleared by software.
            using TXACKIE = Field<12, 1>;    // Tx-Missing Acknowledge Error Interrupt Enable The TXACKEIE bit is set and cleared by software.
        };

    };

    // HSEM
    struct HSEM {
        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R0 : public Register<0x58026400> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R1 : public Register<0x58026404> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R2 : public Register<0x58026408> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R3 : public Register<0x5802640c> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R4 : public Register<0x58026410> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R5 : public Register<0x58026414> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R6 : public Register<0x58026418> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R7 : public Register<0x5802641c> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R8 : public Register<0x58026420> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R9 : public Register<0x58026424> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R10 : public Register<0x58026428> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R11 : public Register<0x5802642c> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R12 : public Register<0x58026430> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R13 : public Register<0x58026434> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R14 : public Register<0x58026438> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R15 : public Register<0x5802643c> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R16 : public Register<0x58026440> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R17 : public Register<0x58026444> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R18 : public Register<0x58026448> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R19 : public Register<0x5802644c> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R20 : public Register<0x58026450> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R21 : public Register<0x58026454> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R22 : public Register<0x58026458> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R23 : public Register<0x5802645c> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R24 : public Register<0x58026460> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R25 : public Register<0x58026464> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R26 : public Register<0x58026468> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R27 : public Register<0x5802646c> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R28 : public Register<0x58026470> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R29 : public Register<0x58026474> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R30 : public Register<0x58026478> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM register HSEM_R0 HSEM_R31
        struct HSEM_R31 : public Register<0x5802647c> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR0 : public RegisterReadOnly<0x58026480> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR1 : public RegisterReadOnly<0x58026484> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR2 : public RegisterReadOnly<0x58026488> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR3 : public RegisterReadOnly<0x5802648c> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR4 : public RegisterReadOnly<0x58026490> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR5 : public RegisterReadOnly<0x58026494> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR6 : public RegisterReadOnly<0x58026498> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR7 : public RegisterReadOnly<0x5802649c> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR8 : public RegisterReadOnly<0x580264a0> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR9 : public RegisterReadOnly<0x580264a4> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR10 : public RegisterReadOnly<0x580264a8> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR11 : public RegisterReadOnly<0x580264ac> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR12 : public RegisterReadOnly<0x580264b0> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR13 : public RegisterReadOnly<0x580264b4> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR14 : public RegisterReadOnly<0x580264b8> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR15 : public RegisterReadOnly<0x580264bc> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR16 : public RegisterReadOnly<0x580264c0> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR17 : public RegisterReadOnly<0x580264c4> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR18 : public RegisterReadOnly<0x580264c8> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR19 : public RegisterReadOnly<0x580264cc> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR20 : public RegisterReadOnly<0x580264d0> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR21 : public RegisterReadOnly<0x580264d4> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR22 : public RegisterReadOnly<0x580264d8> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR23 : public RegisterReadOnly<0x580264dc> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR24 : public RegisterReadOnly<0x580264e0> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR25 : public RegisterReadOnly<0x580264e4> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR26 : public RegisterReadOnly<0x580264e8> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR27 : public RegisterReadOnly<0x580264ec> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR28 : public RegisterReadOnly<0x580264f0> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR29 : public RegisterReadOnly<0x580264f4> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR30 : public RegisterReadOnly<0x580264f8> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Read lock register
        struct HSEM_RLR31 : public RegisterReadOnly<0x580264fc> {
            using PROCID = Field<0, 8>;    // Semaphore ProcessID
            using MASTERID = Field<8, 8>;    // Semaphore MasterID
            using LOCK = Field<31, 1>;    // Lock indication
        };

        // HSEM Interrupt enable register
        struct HSEM_IER : public Register<0x58026500> {
            using ISEM0 = Field<0, 1>;    // Interrupt semaphore n enable bit
            using ISEM1 = Field<1, 1>;    // Interrupt semaphore n enable bit
            using ISEM2 = Field<2, 1>;    // Interrupt semaphore n enable bit
            using ISEM3 = Field<3, 1>;    // Interrupt semaphore n enable bit
            using ISEM4 = Field<4, 1>;    // Interrupt semaphore n enable bit
            using ISEM5 = Field<5, 1>;    // Interrupt semaphore n enable bit
            using ISEM6 = Field<6, 1>;    // Interrupt semaphore n enable bit
            using ISEM7 = Field<7, 1>;    // Interrupt semaphore n enable bit
            using ISEM8 = Field<8, 1>;    // Interrupt semaphore n enable bit
            using ISEM9 = Field<9, 1>;    // Interrupt semaphore n enable bit
            using ISEM10 = Field<10, 1>;    // Interrupt semaphore n enable bit
            using ISEM11 = Field<11, 1>;    // Interrupt semaphore n enable bit
            using ISEM12 = Field<12, 1>;    // Interrupt semaphore n enable bit
            using ISEM13 = Field<13, 1>;    // Interrupt semaphore n enable bit
            using ISEM14 = Field<14, 1>;    // Interrupt semaphore n enable bit
            using ISEM15 = Field<15, 1>;    // Interrupt semaphore n enable bit
            using ISEM16 = Field<16, 1>;    // Interrupt semaphore n enable bit
            using ISEM17 = Field<17, 1>;    // Interrupt semaphore n enable bit
            using ISEM18 = Field<18, 1>;    // Interrupt semaphore n enable bit
            using ISEM19 = Field<19, 1>;    // Interrupt semaphore n enable bit
            using ISEM20 = Field<20, 1>;    // Interrupt semaphore n enable bit
            using ISEM21 = Field<21, 1>;    // Interrupt semaphore n enable bit
            using ISEM22 = Field<22, 1>;    // Interrupt semaphore n enable bit
            using ISEM23 = Field<23, 1>;    // Interrupt semaphore n enable bit
            using ISEM24 = Field<24, 1>;    // Interrupt semaphore n enable bit
            using ISEM25 = Field<25, 1>;    // Interrupt semaphore n enable bit
            using ISEM26 = Field<26, 1>;    // Interrupt semaphore n enable bit
            using ISEM27 = Field<27, 1>;    // Interrupt semaphore n enable bit
            using ISEM28 = Field<28, 1>;    // Interrupt semaphore n enable bit
            using ISEM29 = Field<29, 1>;    // Interrupt semaphore n enable bit
            using ISEM30 = Field<30, 1>;    // Interrupt semaphore n enable bit
            using ISEM31 = Field<31, 1>;    // Interrupt(N) semaphore n enable bit.
        };

        // HSEM Interrupt clear register
        struct HSEM_ICR : public RegisterReadOnly<0x58026504> {
            using ISEM0 = Field<0, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM1 = Field<1, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM2 = Field<2, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM3 = Field<3, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM4 = Field<4, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM5 = Field<5, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM6 = Field<6, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM7 = Field<7, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM8 = Field<8, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM9 = Field<9, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM10 = Field<10, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM11 = Field<11, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM12 = Field<12, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM13 = Field<13, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM14 = Field<14, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM15 = Field<15, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM16 = Field<16, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM17 = Field<17, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM18 = Field<18, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM19 = Field<19, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM20 = Field<20, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM21 = Field<21, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM22 = Field<22, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM23 = Field<23, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM24 = Field<24, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM25 = Field<25, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM26 = Field<26, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM27 = Field<27, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM28 = Field<28, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM29 = Field<29, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM30 = Field<30, 1>;    // Interrupt(N) semaphore n clear bit
            using ISEM31 = Field<31, 1>;    // Interrupt(N) semaphore n clear bit
        };

        // HSEM Interrupt status register
        struct HSEM_ISR : public RegisterReadOnly<0x58026508> {
            using ISEM0 = Field<0, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM1 = Field<1, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM2 = Field<2, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM3 = Field<3, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM4 = Field<4, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM5 = Field<5, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM6 = Field<6, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM7 = Field<7, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM8 = Field<8, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM9 = Field<9, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM10 = Field<10, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM11 = Field<11, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM12 = Field<12, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM13 = Field<13, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM14 = Field<14, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM15 = Field<15, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM16 = Field<16, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM17 = Field<17, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM18 = Field<18, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM19 = Field<19, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM20 = Field<20, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM21 = Field<21, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM22 = Field<22, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM23 = Field<23, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM24 = Field<24, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM25 = Field<25, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM26 = Field<26, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM27 = Field<27, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM28 = Field<28, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM29 = Field<29, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM30 = Field<30, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
            using ISEM31 = Field<31, 1>;    // Interrupt(N) semaphore n status bit before enable (mask)
        };

        // HSEM Masked interrupt status register
        struct HSEM_MISR : public RegisterReadOnly<0x5802650c> {
            using ISEM0 = Field<0, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM1 = Field<1, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM2 = Field<2, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM3 = Field<3, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM4 = Field<4, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM5 = Field<5, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM6 = Field<6, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM7 = Field<7, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM8 = Field<8, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM9 = Field<9, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM10 = Field<10, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM11 = Field<11, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM12 = Field<12, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM13 = Field<13, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM14 = Field<14, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM15 = Field<15, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM16 = Field<16, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM17 = Field<17, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM18 = Field<18, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM19 = Field<19, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM20 = Field<20, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM21 = Field<21, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM22 = Field<22, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM23 = Field<23, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM24 = Field<24, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM25 = Field<25, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM26 = Field<26, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM27 = Field<27, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM28 = Field<28, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM29 = Field<29, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM30 = Field<30, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
            using ISEM31 = Field<31, 1>;    // masked interrupt(N) semaphore n status bit after enable (mask)
        };

        // HSEM Clear register
        struct HSEM_CR : public Register<0x58026540> {
            using MASTERID = Field<8, 8>;    // MasterID of semaphores to be cleared
            using KEY = Field<16, 16>;    // Semaphore clear Key
        };

        // HSEM Interrupt clear register
        struct HSEM_KEYR : public Register<0x58026544> {
            using KEY = Field<16, 16>;    // Semaphore Clear Key
        };

    };

    // I2C
    struct I2C1 {
        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
        struct CR1 : public Register<0x40005400> {
            using PE = Field<0, 1>;    // Peripheral enable Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.
            using TXIE = Field<1, 1>;    // TX Interrupt enable
            using RXIE = Field<2, 1>;    // RX Interrupt enable
            using ADDRIE = Field<3, 1>;    // Address match Interrupt enable (slave only)
            using NACKIE = Field<4, 1>;    // Not acknowledge received Interrupt enable
            using STOPIE = Field<5, 1>;    // STOP detection Interrupt enable
            using TCIE = Field<6, 1>;    // Transfer Complete interrupt enable Note: Any of these events will generate an interrupt: Transfer Complete (TC) Transfer Complete Reload (TCR)
            using ERRIE = Field<7, 1>;    // Error interrupts enable Note: Any of these errors generate an interrupt: Arbitration Loss (ARLO) Bus Error detection (BERR) Overrun/Underrun (OVR) Timeout detection (TIMEOUT) PEC error detection (PECERR) Alert pin event detection (ALERT)
            using DNF = Field<8, 4>;    // Digital noise filter These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF[3:0] * tI2CCLK ... Note: If the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0).
            using ANFOFF = Field<12, 1>;    // Analog noise filter OFF Note: This bit can only be programmed when the I2C is disabled (PE = 0).
            using TXDMAEN = Field<14, 1>;    // DMA transmission requests enable
            using RXDMAEN = Field<15, 1>;    // DMA reception requests enable
            using SBC = Field<16, 1>;    // Slave byte control This bit is used to enable hardware byte control in slave mode.
            using NOSTRETCH = Field<17, 1>;    // Clock stretching disable This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: This bit can only be programmed when the I2C is disabled (PE = 0).
            using WUPEN = Field<18, 1>;    // Wakeup from Stop mode enable Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation. Note: WUPEN can be set only when DNF = 0000
            using GCEN = Field<19, 1>;    // General call enable
            using SMBHEN = Field<20, 1>;    // SMBus Host address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using SMBDEN = Field<21, 1>;    // SMBus Device Default address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using ALERTEN = Field<22, 1>;    // SMBus alert enable Device mode (SMBHEN=0): Host mode (SMBHEN=1): Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using PECEN = Field<23, 1>;    // PEC enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
        struct CR2 : public Register<0x40005404> {
            using SADD0 = Field<0, 1>;    // Slave address bit 0 (master mode) In 7-bit addressing mode (ADD10 = 0): This bit is dont care In 10-bit addressing mode (ADD10 = 1): This bit should be written with bit 0 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
            using SADD1 = Field<1, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD2 = Field<2, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD3 = Field<3, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD4 = Field<4, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD5 = Field<5, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD6 = Field<6, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD7 = Field<7, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD8 = Field<8, 1>;    // Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
            using SADD9 = Field<9, 1>;    // Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
            using RD_WRN = Field<10, 1>;    // Transfer direction (master mode) Note: Changing this bit when the START bit is set is not allowed.
            using ADD10 = Field<11, 1>;    // 10-bit addressing mode (master mode) Note: Changing this bit when the START bit is set is not allowed.
            using HEAD10R = Field<12, 1>;    // 10-bit address header only read direction (master receiver mode) Note: Changing this bit when the START bit is set is not allowed.
            using START = Field<13, 1>;    // Start generation This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing 1 to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit will generate a START condition once the bus is free. Note: Writing 0 to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set.
            using STOP = Field<14, 1>;    // Stop generation (master mode) The bit is set by software, cleared by hardware when a Stop condition is detected, or when PE = 0. In Master Mode: Note: Writing 0 to this bit has no effect.
            using NACK = Field<15, 1>;    // NACK generation (slave mode) The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0. Note: Writing 0 to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.
            using NBYTES = Field<16, 8>;    // Number of bytes The number of bytes to be transmitted/received is programmed there. This field is dont care in slave mode with SBC=0. Note: Changing these bits when the START bit is set is not allowed.
            using RELOAD = Field<24, 1>;    // NBYTES reload mode This bit is set and cleared by software.
            using AUTOEND = Field<25, 1>;    // Automatic end mode (master mode) This bit is set and cleared by software. Note: This bit has no effect in slave mode or when the RELOAD bit is set.
            using PECBYTE = Field<26, 1>;    // Packet error checking byte This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0. Note: Writing 0 to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
        struct OAR1 : public Register<0x40005408> {
            using OA1 = Field<0, 10>;    // Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bits 9:8 of address Note: These bits can be written only when OA1EN=0. OA1[7:1]: Interface address Bits 7:1 of address Note: These bits can be written only when OA1EN=0. OA1[0]: Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bit 0 of address Note: This bit can be written only when OA1EN=0.
            using OA1MODE = Field<10, 1>;    // Own Address 1 10-bit mode Note: This bit can be written only when OA1EN=0.
            using OA1EN = Field<15, 1>;    // Own Address 1 enable
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
        struct OAR2 : public Register<0x4000540c> {
            using OA2 = Field<1, 7>;    // Interface address bits 7:1 of address Note: These bits can be written only when OA2EN=0.
            using OA2MSK = Field<8, 3>;    // Own Address 2 masks Note: These bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.
            using OA2EN = Field<15, 1>;    // Own Address 2 enable
        };

        // Access: No wait states
        struct TIMINGR : public Register<0x40005410> {
            using SCLL = Field<0, 8>;    // SCL low period (master mode) This field is used to generate the SCL low period in master mode. tSCLL = (SCLL+1) x tPRESC Note: SCLL is also used to generate tBUF and tSU:STA timings.
            using SCLH = Field<8, 8>;    // SCL high period (master mode) This field is used to generate the SCL high period in master mode. tSCLH = (SCLH+1) x tPRESC Note: SCLH is also used to generate tSU:STO and tHD:STA timing.
            using SDADEL = Field<16, 4>;    // Data hold time This field is used to generate the delay tSDADEL between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSDADEL. tSDADEL= SDADEL x tPRESC Note: SDADEL is used to generate tHD:DAT timing.
            using SCLDEL = Field<20, 4>;    // Data setup time This field is used to generate a delay tSCLDEL between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSCLDEL. tSCLDEL = (SCLDEL+1) x tPRESC Note: tSCLDEL is used to generate tSU:DAT timing.
            using PRESC = Field<28, 4>;    // Timing prescaler This field is used to prescale I2CCLK in order to generate the clock period tPRESC used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). tPRESC = (PRESC+1) x tI2CCLK
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
        struct TIMEOUTR : public Register<0x40005414> {
            using TIMEOUTA = Field<0, 12>;    // Bus Timeout A This field is used to configure: The SCL low timeout condition tTIMEOUT when TIDLE=0 tTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK The bus idle condition (both SCL and SDA high) when TIDLE=1 tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK Note: These bits can be written only when TIMOUTEN=0.
            using TIDLE = Field<12, 1>;    // Idle clock timeout detection Note: This bit can be written only when TIMOUTEN=0.
            using TIMOUTEN = Field<15, 1>;    // Clock timeout enable
            using TIMEOUTB = Field<16, 12>;    // Bus timeout B This field is used to configure the cumulative clock extension timeout: In master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected In slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK Note: These bits can be written only when TEXTEN=0.
            using TEXTEN = Field<31, 1>;    // Extended clock timeout enable
        };

        // Access: No wait states
        struct ISR : public Register<0x40005418> {
            using TXE = Field<0, 1>;    // Transmit data register empty (transmitters) This bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: This bit is set by hardware when PE=0.
            using TXIS = Field<1, 1>;    // Transmit interrupt status (transmitters) This bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1). Note: This bit is cleared by hardware when PE=0.
            using RXNE = Field<2, 1>;    // Receive data register not empty (receivers) This bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: This bit is cleared by hardware when PE=0.
            using ADDR = Field<3, 1>;    // Address matched (slave mode) This bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: This bit is cleared by hardware when PE=0.
            using NACKF = Field<4, 1>;    // Not Acknowledge received flag This flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: This bit is cleared by hardware when PE=0.
            using STOPF = Field<5, 1>;    // Stop detection flag This flag is set by hardware when a Stop condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: This bit is cleared by hardware when PE=0.
            using TC = Field<6, 1>;    // Transfer Complete (master mode) This flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: This bit is cleared by hardware when PE=0.
            using TCR = Field<7, 1>;    // Transfer Complete Reload This flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: This bit is cleared by hardware when PE=0. This flag is only for master mode, or for slave mode when the SBC bit is set.
            using BERR = Field<8, 1>;    // Bus error This flag is set by hardware when a misplaced Start or Stop condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: This bit is cleared by hardware when PE=0.
            using ARLO = Field<9, 1>;    // Arbitration lost This flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: This bit is cleared by hardware when PE=0.
            using OVR = Field<10, 1>;    // Overrun/Underrun (slave mode) This flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: This bit is cleared by hardware when PE=0.
            using PECERR = Field<11, 1>;    // PEC Error in reception This flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using TIMEOUT = Field<12, 1>;    // Timeout or tLOW detection flag This flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using ALERT = Field<13, 1>;    // SMBus alert This flag is set by hardware when SMBHEN=1 (SMBus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using BUSY = Field<15, 1>;    // Bus busy This flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a Stop condition is detected, or when PE=0.
            using DIR = Field<16, 1>;    // Transfer direction (Slave mode) This flag is updated when an address match event occurs (ADDR=1).
            using ADDCODE = Field<17, 7>;    // Address match code (Slave mode) These bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 MSBs of the address.
        };

        // Access: No wait states
        struct ICR : public RegisterWriteOnly<0x4000541c> {
            using ADDRCF = Field<3, 1>;    // Address matched flag clear Writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.
            using NACKCF = Field<4, 1>;    // Not Acknowledge flag clear Writing 1 to this bit clears the ACKF flag in I2C_ISR register.
            using STOPCF = Field<5, 1>;    // Stop detection flag clear Writing 1 to this bit clears the STOPF flag in the I2C_ISR register.
            using BERRCF = Field<8, 1>;    // Bus error flag clear Writing 1 to this bit clears the BERRF flag in the I2C_ISR register.
            using ARLOCF = Field<9, 1>;    // Arbitration Lost flag clear Writing 1 to this bit clears the ARLO flag in the I2C_ISR register.
            using OVRCF = Field<10, 1>;    // Overrun/Underrun flag clear Writing 1 to this bit clears the OVR flag in the I2C_ISR register.
            using PECCF = Field<11, 1>;    // PEC Error flag clear Writing 1 to this bit clears the PECERR flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using TIMOUTCF = Field<12, 1>;    // Timeout detection flag clear Writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using ALERTCF = Field<13, 1>;    // Alert flag clear Writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
        };

        // Access: No wait states
        struct PECR : public RegisterReadOnly<0x40005420> {
            using PEC = Field<0, 8>;    // Packet error checking register This field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0.
        };

        // Access: No wait states
        struct RXDR : public RegisterReadOnly<0x40005424> {
            using RXDATA = Field<0, 8>;    // 8-bit receive data Data byte received from the I2C bus.
        };

        // Access: No wait states
        struct TXDR : public Register<0x40005428> {
            using TXDATA = Field<0, 8>;    // 8-bit transmit data Data byte to be transmitted to the I2C bus. Note: These bits can be written only when TXE=1.
        };

    };

    // I2C
    struct I2C2 {
        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
        struct CR1 : public Register<0x40005800> {
            using PE = Field<0, 1>;    // Peripheral enable Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.
            using TXIE = Field<1, 1>;    // TX Interrupt enable
            using RXIE = Field<2, 1>;    // RX Interrupt enable
            using ADDRIE = Field<3, 1>;    // Address match Interrupt enable (slave only)
            using NACKIE = Field<4, 1>;    // Not acknowledge received Interrupt enable
            using STOPIE = Field<5, 1>;    // STOP detection Interrupt enable
            using TCIE = Field<6, 1>;    // Transfer Complete interrupt enable Note: Any of these events will generate an interrupt: Transfer Complete (TC) Transfer Complete Reload (TCR)
            using ERRIE = Field<7, 1>;    // Error interrupts enable Note: Any of these errors generate an interrupt: Arbitration Loss (ARLO) Bus Error detection (BERR) Overrun/Underrun (OVR) Timeout detection (TIMEOUT) PEC error detection (PECERR) Alert pin event detection (ALERT)
            using DNF = Field<8, 4>;    // Digital noise filter These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF[3:0] * tI2CCLK ... Note: If the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0).
            using ANFOFF = Field<12, 1>;    // Analog noise filter OFF Note: This bit can only be programmed when the I2C is disabled (PE = 0).
            using TXDMAEN = Field<14, 1>;    // DMA transmission requests enable
            using RXDMAEN = Field<15, 1>;    // DMA reception requests enable
            using SBC = Field<16, 1>;    // Slave byte control This bit is used to enable hardware byte control in slave mode.
            using NOSTRETCH = Field<17, 1>;    // Clock stretching disable This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: This bit can only be programmed when the I2C is disabled (PE = 0).
            using WUPEN = Field<18, 1>;    // Wakeup from Stop mode enable Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation. Note: WUPEN can be set only when DNF = 0000
            using GCEN = Field<19, 1>;    // General call enable
            using SMBHEN = Field<20, 1>;    // SMBus Host address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using SMBDEN = Field<21, 1>;    // SMBus Device Default address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using ALERTEN = Field<22, 1>;    // SMBus alert enable Device mode (SMBHEN=0): Host mode (SMBHEN=1): Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using PECEN = Field<23, 1>;    // PEC enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
        struct CR2 : public Register<0x40005804> {
            using SADD0 = Field<0, 1>;    // Slave address bit 0 (master mode) In 7-bit addressing mode (ADD10 = 0): This bit is dont care In 10-bit addressing mode (ADD10 = 1): This bit should be written with bit 0 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
            using SADD1 = Field<1, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD2 = Field<2, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD3 = Field<3, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD4 = Field<4, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD5 = Field<5, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD6 = Field<6, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD7 = Field<7, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD8 = Field<8, 1>;    // Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
            using SADD9 = Field<9, 1>;    // Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
            using RD_WRN = Field<10, 1>;    // Transfer direction (master mode) Note: Changing this bit when the START bit is set is not allowed.
            using ADD10 = Field<11, 1>;    // 10-bit addressing mode (master mode) Note: Changing this bit when the START bit is set is not allowed.
            using HEAD10R = Field<12, 1>;    // 10-bit address header only read direction (master receiver mode) Note: Changing this bit when the START bit is set is not allowed.
            using START = Field<13, 1>;    // Start generation This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing 1 to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit will generate a START condition once the bus is free. Note: Writing 0 to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set.
            using STOP = Field<14, 1>;    // Stop generation (master mode) The bit is set by software, cleared by hardware when a Stop condition is detected, or when PE = 0. In Master Mode: Note: Writing 0 to this bit has no effect.
            using NACK = Field<15, 1>;    // NACK generation (slave mode) The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0. Note: Writing 0 to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.
            using NBYTES = Field<16, 8>;    // Number of bytes The number of bytes to be transmitted/received is programmed there. This field is dont care in slave mode with SBC=0. Note: Changing these bits when the START bit is set is not allowed.
            using RELOAD = Field<24, 1>;    // NBYTES reload mode This bit is set and cleared by software.
            using AUTOEND = Field<25, 1>;    // Automatic end mode (master mode) This bit is set and cleared by software. Note: This bit has no effect in slave mode or when the RELOAD bit is set.
            using PECBYTE = Field<26, 1>;    // Packet error checking byte This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0. Note: Writing 0 to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
        struct OAR1 : public Register<0x40005808> {
            using OA1 = Field<0, 10>;    // Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bits 9:8 of address Note: These bits can be written only when OA1EN=0. OA1[7:1]: Interface address Bits 7:1 of address Note: These bits can be written only when OA1EN=0. OA1[0]: Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bit 0 of address Note: This bit can be written only when OA1EN=0.
            using OA1MODE = Field<10, 1>;    // Own Address 1 10-bit mode Note: This bit can be written only when OA1EN=0.
            using OA1EN = Field<15, 1>;    // Own Address 1 enable
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
        struct OAR2 : public Register<0x4000580c> {
            using OA2 = Field<1, 7>;    // Interface address bits 7:1 of address Note: These bits can be written only when OA2EN=0.
            using OA2MSK = Field<8, 3>;    // Own Address 2 masks Note: These bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.
            using OA2EN = Field<15, 1>;    // Own Address 2 enable
        };

        // Access: No wait states
        struct TIMINGR : public Register<0x40005810> {
            using SCLL = Field<0, 8>;    // SCL low period (master mode) This field is used to generate the SCL low period in master mode. tSCLL = (SCLL+1) x tPRESC Note: SCLL is also used to generate tBUF and tSU:STA timings.
            using SCLH = Field<8, 8>;    // SCL high period (master mode) This field is used to generate the SCL high period in master mode. tSCLH = (SCLH+1) x tPRESC Note: SCLH is also used to generate tSU:STO and tHD:STA timing.
            using SDADEL = Field<16, 4>;    // Data hold time This field is used to generate the delay tSDADEL between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSDADEL. tSDADEL= SDADEL x tPRESC Note: SDADEL is used to generate tHD:DAT timing.
            using SCLDEL = Field<20, 4>;    // Data setup time This field is used to generate a delay tSCLDEL between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSCLDEL. tSCLDEL = (SCLDEL+1) x tPRESC Note: tSCLDEL is used to generate tSU:DAT timing.
            using PRESC = Field<28, 4>;    // Timing prescaler This field is used to prescale I2CCLK in order to generate the clock period tPRESC used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). tPRESC = (PRESC+1) x tI2CCLK
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
        struct TIMEOUTR : public Register<0x40005814> {
            using TIMEOUTA = Field<0, 12>;    // Bus Timeout A This field is used to configure: The SCL low timeout condition tTIMEOUT when TIDLE=0 tTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK The bus idle condition (both SCL and SDA high) when TIDLE=1 tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK Note: These bits can be written only when TIMOUTEN=0.
            using TIDLE = Field<12, 1>;    // Idle clock timeout detection Note: This bit can be written only when TIMOUTEN=0.
            using TIMOUTEN = Field<15, 1>;    // Clock timeout enable
            using TIMEOUTB = Field<16, 12>;    // Bus timeout B This field is used to configure the cumulative clock extension timeout: In master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected In slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK Note: These bits can be written only when TEXTEN=0.
            using TEXTEN = Field<31, 1>;    // Extended clock timeout enable
        };

        // Access: No wait states
        struct ISR : public Register<0x40005818> {
            using TXE = Field<0, 1>;    // Transmit data register empty (transmitters) This bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: This bit is set by hardware when PE=0.
            using TXIS = Field<1, 1>;    // Transmit interrupt status (transmitters) This bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1). Note: This bit is cleared by hardware when PE=0.
            using RXNE = Field<2, 1>;    // Receive data register not empty (receivers) This bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: This bit is cleared by hardware when PE=0.
            using ADDR = Field<3, 1>;    // Address matched (slave mode) This bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: This bit is cleared by hardware when PE=0.
            using NACKF = Field<4, 1>;    // Not Acknowledge received flag This flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: This bit is cleared by hardware when PE=0.
            using STOPF = Field<5, 1>;    // Stop detection flag This flag is set by hardware when a Stop condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: This bit is cleared by hardware when PE=0.
            using TC = Field<6, 1>;    // Transfer Complete (master mode) This flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: This bit is cleared by hardware when PE=0.
            using TCR = Field<7, 1>;    // Transfer Complete Reload This flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: This bit is cleared by hardware when PE=0. This flag is only for master mode, or for slave mode when the SBC bit is set.
            using BERR = Field<8, 1>;    // Bus error This flag is set by hardware when a misplaced Start or Stop condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: This bit is cleared by hardware when PE=0.
            using ARLO = Field<9, 1>;    // Arbitration lost This flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: This bit is cleared by hardware when PE=0.
            using OVR = Field<10, 1>;    // Overrun/Underrun (slave mode) This flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: This bit is cleared by hardware when PE=0.
            using PECERR = Field<11, 1>;    // PEC Error in reception This flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using TIMEOUT = Field<12, 1>;    // Timeout or tLOW detection flag This flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using ALERT = Field<13, 1>;    // SMBus alert This flag is set by hardware when SMBHEN=1 (SMBus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using BUSY = Field<15, 1>;    // Bus busy This flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a Stop condition is detected, or when PE=0.
            using DIR = Field<16, 1>;    // Transfer direction (Slave mode) This flag is updated when an address match event occurs (ADDR=1).
            using ADDCODE = Field<17, 7>;    // Address match code (Slave mode) These bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 MSBs of the address.
        };

        // Access: No wait states
        struct ICR : public RegisterWriteOnly<0x4000581c> {
            using ADDRCF = Field<3, 1>;    // Address matched flag clear Writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.
            using NACKCF = Field<4, 1>;    // Not Acknowledge flag clear Writing 1 to this bit clears the ACKF flag in I2C_ISR register.
            using STOPCF = Field<5, 1>;    // Stop detection flag clear Writing 1 to this bit clears the STOPF flag in the I2C_ISR register.
            using BERRCF = Field<8, 1>;    // Bus error flag clear Writing 1 to this bit clears the BERRF flag in the I2C_ISR register.
            using ARLOCF = Field<9, 1>;    // Arbitration Lost flag clear Writing 1 to this bit clears the ARLO flag in the I2C_ISR register.
            using OVRCF = Field<10, 1>;    // Overrun/Underrun flag clear Writing 1 to this bit clears the OVR flag in the I2C_ISR register.
            using PECCF = Field<11, 1>;    // PEC Error flag clear Writing 1 to this bit clears the PECERR flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using TIMOUTCF = Field<12, 1>;    // Timeout detection flag clear Writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using ALERTCF = Field<13, 1>;    // Alert flag clear Writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
        };

        // Access: No wait states
        struct PECR : public RegisterReadOnly<0x40005820> {
            using PEC = Field<0, 8>;    // Packet error checking register This field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0.
        };

        // Access: No wait states
        struct RXDR : public RegisterReadOnly<0x40005824> {
            using RXDATA = Field<0, 8>;    // 8-bit receive data Data byte received from the I2C bus.
        };

        // Access: No wait states
        struct TXDR : public Register<0x40005828> {
            using TXDATA = Field<0, 8>;    // 8-bit transmit data Data byte to be transmitted to the I2C bus. Note: These bits can be written only when TXE=1.
        };

    };

    // I2C
    struct I2C3 {
        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
        struct CR1 : public Register<0x40005c00> {
            using PE = Field<0, 1>;    // Peripheral enable Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.
            using TXIE = Field<1, 1>;    // TX Interrupt enable
            using RXIE = Field<2, 1>;    // RX Interrupt enable
            using ADDRIE = Field<3, 1>;    // Address match Interrupt enable (slave only)
            using NACKIE = Field<4, 1>;    // Not acknowledge received Interrupt enable
            using STOPIE = Field<5, 1>;    // STOP detection Interrupt enable
            using TCIE = Field<6, 1>;    // Transfer Complete interrupt enable Note: Any of these events will generate an interrupt: Transfer Complete (TC) Transfer Complete Reload (TCR)
            using ERRIE = Field<7, 1>;    // Error interrupts enable Note: Any of these errors generate an interrupt: Arbitration Loss (ARLO) Bus Error detection (BERR) Overrun/Underrun (OVR) Timeout detection (TIMEOUT) PEC error detection (PECERR) Alert pin event detection (ALERT)
            using DNF = Field<8, 4>;    // Digital noise filter These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF[3:0] * tI2CCLK ... Note: If the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0).
            using ANFOFF = Field<12, 1>;    // Analog noise filter OFF Note: This bit can only be programmed when the I2C is disabled (PE = 0).
            using TXDMAEN = Field<14, 1>;    // DMA transmission requests enable
            using RXDMAEN = Field<15, 1>;    // DMA reception requests enable
            using SBC = Field<16, 1>;    // Slave byte control This bit is used to enable hardware byte control in slave mode.
            using NOSTRETCH = Field<17, 1>;    // Clock stretching disable This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: This bit can only be programmed when the I2C is disabled (PE = 0).
            using WUPEN = Field<18, 1>;    // Wakeup from Stop mode enable Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation. Note: WUPEN can be set only when DNF = 0000
            using GCEN = Field<19, 1>;    // General call enable
            using SMBHEN = Field<20, 1>;    // SMBus Host address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using SMBDEN = Field<21, 1>;    // SMBus Device Default address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using ALERTEN = Field<22, 1>;    // SMBus alert enable Device mode (SMBHEN=0): Host mode (SMBHEN=1): Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using PECEN = Field<23, 1>;    // PEC enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
        struct CR2 : public Register<0x40005c04> {
            using SADD0 = Field<0, 1>;    // Slave address bit 0 (master mode) In 7-bit addressing mode (ADD10 = 0): This bit is dont care In 10-bit addressing mode (ADD10 = 1): This bit should be written with bit 0 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
            using SADD1 = Field<1, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD2 = Field<2, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD3 = Field<3, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD4 = Field<4, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD5 = Field<5, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD6 = Field<6, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD7 = Field<7, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD8 = Field<8, 1>;    // Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
            using SADD9 = Field<9, 1>;    // Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
            using RD_WRN = Field<10, 1>;    // Transfer direction (master mode) Note: Changing this bit when the START bit is set is not allowed.
            using ADD10 = Field<11, 1>;    // 10-bit addressing mode (master mode) Note: Changing this bit when the START bit is set is not allowed.
            using HEAD10R = Field<12, 1>;    // 10-bit address header only read direction (master receiver mode) Note: Changing this bit when the START bit is set is not allowed.
            using START = Field<13, 1>;    // Start generation This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing 1 to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit will generate a START condition once the bus is free. Note: Writing 0 to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set.
            using STOP = Field<14, 1>;    // Stop generation (master mode) The bit is set by software, cleared by hardware when a Stop condition is detected, or when PE = 0. In Master Mode: Note: Writing 0 to this bit has no effect.
            using NACK = Field<15, 1>;    // NACK generation (slave mode) The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0. Note: Writing 0 to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.
            using NBYTES = Field<16, 8>;    // Number of bytes The number of bytes to be transmitted/received is programmed there. This field is dont care in slave mode with SBC=0. Note: Changing these bits when the START bit is set is not allowed.
            using RELOAD = Field<24, 1>;    // NBYTES reload mode This bit is set and cleared by software.
            using AUTOEND = Field<25, 1>;    // Automatic end mode (master mode) This bit is set and cleared by software. Note: This bit has no effect in slave mode or when the RELOAD bit is set.
            using PECBYTE = Field<26, 1>;    // Packet error checking byte This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0. Note: Writing 0 to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
        struct OAR1 : public Register<0x40005c08> {
            using OA1 = Field<0, 10>;    // Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bits 9:8 of address Note: These bits can be written only when OA1EN=0. OA1[7:1]: Interface address Bits 7:1 of address Note: These bits can be written only when OA1EN=0. OA1[0]: Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bit 0 of address Note: This bit can be written only when OA1EN=0.
            using OA1MODE = Field<10, 1>;    // Own Address 1 10-bit mode Note: This bit can be written only when OA1EN=0.
            using OA1EN = Field<15, 1>;    // Own Address 1 enable
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
        struct OAR2 : public Register<0x40005c0c> {
            using OA2 = Field<1, 7>;    // Interface address bits 7:1 of address Note: These bits can be written only when OA2EN=0.
            using OA2MSK = Field<8, 3>;    // Own Address 2 masks Note: These bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.
            using OA2EN = Field<15, 1>;    // Own Address 2 enable
        };

        // Access: No wait states
        struct TIMINGR : public Register<0x40005c10> {
            using SCLL = Field<0, 8>;    // SCL low period (master mode) This field is used to generate the SCL low period in master mode. tSCLL = (SCLL+1) x tPRESC Note: SCLL is also used to generate tBUF and tSU:STA timings.
            using SCLH = Field<8, 8>;    // SCL high period (master mode) This field is used to generate the SCL high period in master mode. tSCLH = (SCLH+1) x tPRESC Note: SCLH is also used to generate tSU:STO and tHD:STA timing.
            using SDADEL = Field<16, 4>;    // Data hold time This field is used to generate the delay tSDADEL between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSDADEL. tSDADEL= SDADEL x tPRESC Note: SDADEL is used to generate tHD:DAT timing.
            using SCLDEL = Field<20, 4>;    // Data setup time This field is used to generate a delay tSCLDEL between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSCLDEL. tSCLDEL = (SCLDEL+1) x tPRESC Note: tSCLDEL is used to generate tSU:DAT timing.
            using PRESC = Field<28, 4>;    // Timing prescaler This field is used to prescale I2CCLK in order to generate the clock period tPRESC used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). tPRESC = (PRESC+1) x tI2CCLK
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
        struct TIMEOUTR : public Register<0x40005c14> {
            using TIMEOUTA = Field<0, 12>;    // Bus Timeout A This field is used to configure: The SCL low timeout condition tTIMEOUT when TIDLE=0 tTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK The bus idle condition (both SCL and SDA high) when TIDLE=1 tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK Note: These bits can be written only when TIMOUTEN=0.
            using TIDLE = Field<12, 1>;    // Idle clock timeout detection Note: This bit can be written only when TIMOUTEN=0.
            using TIMOUTEN = Field<15, 1>;    // Clock timeout enable
            using TIMEOUTB = Field<16, 12>;    // Bus timeout B This field is used to configure the cumulative clock extension timeout: In master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected In slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK Note: These bits can be written only when TEXTEN=0.
            using TEXTEN = Field<31, 1>;    // Extended clock timeout enable
        };

        // Access: No wait states
        struct ISR : public Register<0x40005c18> {
            using TXE = Field<0, 1>;    // Transmit data register empty (transmitters) This bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: This bit is set by hardware when PE=0.
            using TXIS = Field<1, 1>;    // Transmit interrupt status (transmitters) This bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1). Note: This bit is cleared by hardware when PE=0.
            using RXNE = Field<2, 1>;    // Receive data register not empty (receivers) This bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: This bit is cleared by hardware when PE=0.
            using ADDR = Field<3, 1>;    // Address matched (slave mode) This bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: This bit is cleared by hardware when PE=0.
            using NACKF = Field<4, 1>;    // Not Acknowledge received flag This flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: This bit is cleared by hardware when PE=0.
            using STOPF = Field<5, 1>;    // Stop detection flag This flag is set by hardware when a Stop condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: This bit is cleared by hardware when PE=0.
            using TC = Field<6, 1>;    // Transfer Complete (master mode) This flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: This bit is cleared by hardware when PE=0.
            using TCR = Field<7, 1>;    // Transfer Complete Reload This flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: This bit is cleared by hardware when PE=0. This flag is only for master mode, or for slave mode when the SBC bit is set.
            using BERR = Field<8, 1>;    // Bus error This flag is set by hardware when a misplaced Start or Stop condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: This bit is cleared by hardware when PE=0.
            using ARLO = Field<9, 1>;    // Arbitration lost This flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: This bit is cleared by hardware when PE=0.
            using OVR = Field<10, 1>;    // Overrun/Underrun (slave mode) This flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: This bit is cleared by hardware when PE=0.
            using PECERR = Field<11, 1>;    // PEC Error in reception This flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using TIMEOUT = Field<12, 1>;    // Timeout or tLOW detection flag This flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using ALERT = Field<13, 1>;    // SMBus alert This flag is set by hardware when SMBHEN=1 (SMBus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using BUSY = Field<15, 1>;    // Bus busy This flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a Stop condition is detected, or when PE=0.
            using DIR = Field<16, 1>;    // Transfer direction (Slave mode) This flag is updated when an address match event occurs (ADDR=1).
            using ADDCODE = Field<17, 7>;    // Address match code (Slave mode) These bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 MSBs of the address.
        };

        // Access: No wait states
        struct ICR : public RegisterWriteOnly<0x40005c1c> {
            using ADDRCF = Field<3, 1>;    // Address matched flag clear Writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.
            using NACKCF = Field<4, 1>;    // Not Acknowledge flag clear Writing 1 to this bit clears the ACKF flag in I2C_ISR register.
            using STOPCF = Field<5, 1>;    // Stop detection flag clear Writing 1 to this bit clears the STOPF flag in the I2C_ISR register.
            using BERRCF = Field<8, 1>;    // Bus error flag clear Writing 1 to this bit clears the BERRF flag in the I2C_ISR register.
            using ARLOCF = Field<9, 1>;    // Arbitration Lost flag clear Writing 1 to this bit clears the ARLO flag in the I2C_ISR register.
            using OVRCF = Field<10, 1>;    // Overrun/Underrun flag clear Writing 1 to this bit clears the OVR flag in the I2C_ISR register.
            using PECCF = Field<11, 1>;    // PEC Error flag clear Writing 1 to this bit clears the PECERR flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using TIMOUTCF = Field<12, 1>;    // Timeout detection flag clear Writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using ALERTCF = Field<13, 1>;    // Alert flag clear Writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
        };

        // Access: No wait states
        struct PECR : public RegisterReadOnly<0x40005c20> {
            using PEC = Field<0, 8>;    // Packet error checking register This field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0.
        };

        // Access: No wait states
        struct RXDR : public RegisterReadOnly<0x40005c24> {
            using RXDATA = Field<0, 8>;    // 8-bit receive data Data byte received from the I2C bus.
        };

        // Access: No wait states
        struct TXDR : public Register<0x40005c28> {
            using TXDATA = Field<0, 8>;    // 8-bit transmit data Data byte to be transmitted to the I2C bus. Note: These bits can be written only when TXE=1.
        };

    };

    // I2C
    struct I2C4 {
        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
        struct CR1 : public Register<0x58001c00> {
            using PE = Field<0, 1>;    // Peripheral enable Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.
            using TXIE = Field<1, 1>;    // TX Interrupt enable
            using RXIE = Field<2, 1>;    // RX Interrupt enable
            using ADDRIE = Field<3, 1>;    // Address match Interrupt enable (slave only)
            using NACKIE = Field<4, 1>;    // Not acknowledge received Interrupt enable
            using STOPIE = Field<5, 1>;    // STOP detection Interrupt enable
            using TCIE = Field<6, 1>;    // Transfer Complete interrupt enable Note: Any of these events will generate an interrupt: Transfer Complete (TC) Transfer Complete Reload (TCR)
            using ERRIE = Field<7, 1>;    // Error interrupts enable Note: Any of these errors generate an interrupt: Arbitration Loss (ARLO) Bus Error detection (BERR) Overrun/Underrun (OVR) Timeout detection (TIMEOUT) PEC error detection (PECERR) Alert pin event detection (ALERT)
            using DNF = Field<8, 4>;    // Digital noise filter These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF[3:0] * tI2CCLK ... Note: If the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0).
            using ANFOFF = Field<12, 1>;    // Analog noise filter OFF Note: This bit can only be programmed when the I2C is disabled (PE = 0).
            using TXDMAEN = Field<14, 1>;    // DMA transmission requests enable
            using RXDMAEN = Field<15, 1>;    // DMA reception requests enable
            using SBC = Field<16, 1>;    // Slave byte control This bit is used to enable hardware byte control in slave mode.
            using NOSTRETCH = Field<17, 1>;    // Clock stretching disable This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: This bit can only be programmed when the I2C is disabled (PE = 0).
            using WUPEN = Field<18, 1>;    // Wakeup from Stop mode enable Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation. Note: WUPEN can be set only when DNF = 0000
            using GCEN = Field<19, 1>;    // General call enable
            using SMBHEN = Field<20, 1>;    // SMBus Host address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using SMBDEN = Field<21, 1>;    // SMBus Device Default address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using ALERTEN = Field<22, 1>;    // SMBus alert enable Device mode (SMBHEN=0): Host mode (SMBHEN=1): Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using PECEN = Field<23, 1>;    // PEC enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
        struct CR2 : public Register<0x58001c04> {
            using SADD0 = Field<0, 1>;    // Slave address bit 0 (master mode) In 7-bit addressing mode (ADD10 = 0): This bit is dont care In 10-bit addressing mode (ADD10 = 1): This bit should be written with bit 0 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
            using SADD1 = Field<1, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD2 = Field<2, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD3 = Field<3, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD4 = Field<4, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD5 = Field<5, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD6 = Field<6, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD7 = Field<7, 1>;    // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
            using SADD8 = Field<8, 1>;    // Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
            using SADD9 = Field<9, 1>;    // Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
            using RD_WRN = Field<10, 1>;    // Transfer direction (master mode) Note: Changing this bit when the START bit is set is not allowed.
            using ADD10 = Field<11, 1>;    // 10-bit addressing mode (master mode) Note: Changing this bit when the START bit is set is not allowed.
            using HEAD10R = Field<12, 1>;    // 10-bit address header only read direction (master receiver mode) Note: Changing this bit when the START bit is set is not allowed.
            using START = Field<13, 1>;    // Start generation This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing 1 to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit will generate a START condition once the bus is free. Note: Writing 0 to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set.
            using STOP = Field<14, 1>;    // Stop generation (master mode) The bit is set by software, cleared by hardware when a Stop condition is detected, or when PE = 0. In Master Mode: Note: Writing 0 to this bit has no effect.
            using NACK = Field<15, 1>;    // NACK generation (slave mode) The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0. Note: Writing 0 to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.
            using NBYTES = Field<16, 8>;    // Number of bytes The number of bytes to be transmitted/received is programmed there. This field is dont care in slave mode with SBC=0. Note: Changing these bits when the START bit is set is not allowed.
            using RELOAD = Field<24, 1>;    // NBYTES reload mode This bit is set and cleared by software.
            using AUTOEND = Field<25, 1>;    // Automatic end mode (master mode) This bit is set and cleared by software. Note: This bit has no effect in slave mode or when the RELOAD bit is set.
            using PECBYTE = Field<26, 1>;    // Packet error checking byte This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0. Note: Writing 0 to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
        struct OAR1 : public Register<0x58001c08> {
            using OA1 = Field<0, 10>;    // Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bits 9:8 of address Note: These bits can be written only when OA1EN=0. OA1[7:1]: Interface address Bits 7:1 of address Note: These bits can be written only when OA1EN=0. OA1[0]: Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bit 0 of address Note: This bit can be written only when OA1EN=0.
            using OA1MODE = Field<10, 1>;    // Own Address 1 10-bit mode Note: This bit can be written only when OA1EN=0.
            using OA1EN = Field<15, 1>;    // Own Address 1 enable
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
        struct OAR2 : public Register<0x58001c0c> {
            using OA2 = Field<1, 7>;    // Interface address bits 7:1 of address Note: These bits can be written only when OA2EN=0.
            using OA2MSK = Field<8, 3>;    // Own Address 2 masks Note: These bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.
            using OA2EN = Field<15, 1>;    // Own Address 2 enable
        };

        // Access: No wait states
        struct TIMINGR : public Register<0x58001c10> {
            using SCLL = Field<0, 8>;    // SCL low period (master mode) This field is used to generate the SCL low period in master mode. tSCLL = (SCLL+1) x tPRESC Note: SCLL is also used to generate tBUF and tSU:STA timings.
            using SCLH = Field<8, 8>;    // SCL high period (master mode) This field is used to generate the SCL high period in master mode. tSCLH = (SCLH+1) x tPRESC Note: SCLH is also used to generate tSU:STO and tHD:STA timing.
            using SDADEL = Field<16, 4>;    // Data hold time This field is used to generate the delay tSDADEL between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSDADEL. tSDADEL= SDADEL x tPRESC Note: SDADEL is used to generate tHD:DAT timing.
            using SCLDEL = Field<20, 4>;    // Data setup time This field is used to generate a delay tSCLDEL between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSCLDEL. tSCLDEL = (SCLDEL+1) x tPRESC Note: tSCLDEL is used to generate tSU:DAT timing.
            using PRESC = Field<28, 4>;    // Timing prescaler This field is used to prescale I2CCLK in order to generate the clock period tPRESC used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). tPRESC = (PRESC+1) x tI2CCLK
        };

        // Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
        struct TIMEOUTR : public Register<0x58001c14> {
            using TIMEOUTA = Field<0, 12>;    // Bus Timeout A This field is used to configure: The SCL low timeout condition tTIMEOUT when TIDLE=0 tTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK The bus idle condition (both SCL and SDA high) when TIDLE=1 tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK Note: These bits can be written only when TIMOUTEN=0.
            using TIDLE = Field<12, 1>;    // Idle clock timeout detection Note: This bit can be written only when TIMOUTEN=0.
            using TIMOUTEN = Field<15, 1>;    // Clock timeout enable
            using TIMEOUTB = Field<16, 12>;    // Bus timeout B This field is used to configure the cumulative clock extension timeout: In master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected In slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK Note: These bits can be written only when TEXTEN=0.
            using TEXTEN = Field<31, 1>;    // Extended clock timeout enable
        };

        // Access: No wait states
        struct ISR : public Register<0x58001c18> {
            using TXE = Field<0, 1>;    // Transmit data register empty (transmitters) This bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: This bit is set by hardware when PE=0.
            using TXIS = Field<1, 1>;    // Transmit interrupt status (transmitters) This bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1). Note: This bit is cleared by hardware when PE=0.
            using RXNE = Field<2, 1>;    // Receive data register not empty (receivers) This bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: This bit is cleared by hardware when PE=0.
            using ADDR = Field<3, 1>;    // Address matched (slave mode) This bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: This bit is cleared by hardware when PE=0.
            using NACKF = Field<4, 1>;    // Not Acknowledge received flag This flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: This bit is cleared by hardware when PE=0.
            using STOPF = Field<5, 1>;    // Stop detection flag This flag is set by hardware when a Stop condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: This bit is cleared by hardware when PE=0.
            using TC = Field<6, 1>;    // Transfer Complete (master mode) This flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: This bit is cleared by hardware when PE=0.
            using TCR = Field<7, 1>;    // Transfer Complete Reload This flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: This bit is cleared by hardware when PE=0. This flag is only for master mode, or for slave mode when the SBC bit is set.
            using BERR = Field<8, 1>;    // Bus error This flag is set by hardware when a misplaced Start or Stop condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: This bit is cleared by hardware when PE=0.
            using ARLO = Field<9, 1>;    // Arbitration lost This flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: This bit is cleared by hardware when PE=0.
            using OVR = Field<10, 1>;    // Overrun/Underrun (slave mode) This flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: This bit is cleared by hardware when PE=0.
            using PECERR = Field<11, 1>;    // PEC Error in reception This flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using TIMEOUT = Field<12, 1>;    // Timeout or tLOW detection flag This flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using ALERT = Field<13, 1>;    // SMBus alert This flag is set by hardware when SMBHEN=1 (SMBus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using BUSY = Field<15, 1>;    // Bus busy This flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a Stop condition is detected, or when PE=0.
            using DIR = Field<16, 1>;    // Transfer direction (Slave mode) This flag is updated when an address match event occurs (ADDR=1).
            using ADDCODE = Field<17, 7>;    // Address match code (Slave mode) These bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 MSBs of the address.
        };

        // Access: No wait states
        struct ICR : public RegisterWriteOnly<0x58001c1c> {
            using ADDRCF = Field<3, 1>;    // Address matched flag clear Writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.
            using NACKCF = Field<4, 1>;    // Not Acknowledge flag clear Writing 1 to this bit clears the ACKF flag in I2C_ISR register.
            using STOPCF = Field<5, 1>;    // Stop detection flag clear Writing 1 to this bit clears the STOPF flag in the I2C_ISR register.
            using BERRCF = Field<8, 1>;    // Bus error flag clear Writing 1 to this bit clears the BERRF flag in the I2C_ISR register.
            using ARLOCF = Field<9, 1>;    // Arbitration Lost flag clear Writing 1 to this bit clears the ARLO flag in the I2C_ISR register.
            using OVRCF = Field<10, 1>;    // Overrun/Underrun flag clear Writing 1 to this bit clears the OVR flag in the I2C_ISR register.
            using PECCF = Field<11, 1>;    // PEC Error flag clear Writing 1 to this bit clears the PECERR flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using TIMOUTCF = Field<12, 1>;    // Timeout detection flag clear Writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
            using ALERTCF = Field<13, 1>;    // Alert flag clear Writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
        };

        // Access: No wait states
        struct PECR : public RegisterReadOnly<0x58001c20> {
            using PEC = Field<0, 8>;    // Packet error checking register This field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0.
        };

        // Access: No wait states
        struct RXDR : public RegisterReadOnly<0x58001c24> {
            using RXDATA = Field<0, 8>;    // 8-bit receive data Data byte received from the I2C bus.
        };

        // Access: No wait states
        struct TXDR : public Register<0x58001c28> {
            using TXDATA = Field<0, 8>;    // 8-bit transmit data Data byte to be transmitted to the I2C bus. Note: These bits can be written only when TXE=1.
        };

    };

    // GPIO
    struct GPIOA {
        // GPIO port mode register
        struct MODER : public Register<0x58020000> {
            using MODE0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x58020004> {
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x58020008> {
            using OSPEED0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x5802000c> {
            using PUPD0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        };

        // GPIO port input data register
        struct IDR : public RegisterReadOnly<0x58020010> {
            using ID0 = Field<0, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID1 = Field<1, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID2 = Field<2, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID3 = Field<3, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID4 = Field<4, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID5 = Field<5, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID6 = Field<6, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID7 = Field<7, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID8 = Field<8, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID9 = Field<9, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID10 = Field<10, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID11 = Field<11, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID12 = Field<12, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID13 = Field<13, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID14 = Field<14, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID15 = Field<15, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        };

        // GPIO port output data register
        struct ODR : public Register<0x58020014> {
            using OD0 = Field<0, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD1 = Field<1, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD2 = Field<2, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD3 = Field<3, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD4 = Field<4, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD5 = Field<5, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD6 = Field<6, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD7 = Field<7, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD8 = Field<8, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD9 = Field<9, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD10 = Field<10, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD11 = Field<11, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD12 = Field<12, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD13 = Field<13, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD14 = Field<14, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD15 = Field<15, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        };

        // GPIO port bit set/reset register
        struct BSRR : public RegisterWriteOnly<0x58020018> {
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BR0 = Field<16, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        };

        // This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
        struct LCKR : public Register<0x5802001c> {
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCKK = Field<16, 1>;    // Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x58020020> {
            using AFSEL0 = Field<0, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL1 = Field<4, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL2 = Field<8, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL3 = Field<12, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL4 = Field<16, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL5 = Field<20, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL6 = Field<24, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL7 = Field<28, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x58020024> {
            using AFSEL8 = Field<0, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL9 = Field<4, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL10 = Field<8, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL11 = Field<12, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL12 = Field<16, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL13 = Field<20, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL14 = Field<24, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL15 = Field<28, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
        };

    };

    // GPIO
    struct GPIOB {
        // GPIO port mode register
        struct MODER : public Register<0x58020400> {
            using MODE0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x58020404> {
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x58020408> {
            using OSPEED0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x5802040c> {
            using PUPD0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        };

        // GPIO port input data register
        struct IDR : public RegisterReadOnly<0x58020410> {
            using ID0 = Field<0, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID1 = Field<1, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID2 = Field<2, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID3 = Field<3, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID4 = Field<4, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID5 = Field<5, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID6 = Field<6, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID7 = Field<7, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID8 = Field<8, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID9 = Field<9, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID10 = Field<10, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID11 = Field<11, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID12 = Field<12, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID13 = Field<13, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID14 = Field<14, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID15 = Field<15, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        };

        // GPIO port output data register
        struct ODR : public Register<0x58020414> {
            using OD0 = Field<0, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD1 = Field<1, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD2 = Field<2, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD3 = Field<3, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD4 = Field<4, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD5 = Field<5, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD6 = Field<6, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD7 = Field<7, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD8 = Field<8, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD9 = Field<9, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD10 = Field<10, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD11 = Field<11, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD12 = Field<12, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD13 = Field<13, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD14 = Field<14, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD15 = Field<15, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        };

        // GPIO port bit set/reset register
        struct BSRR : public RegisterWriteOnly<0x58020418> {
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BR0 = Field<16, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        };

        // This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
        struct LCKR : public Register<0x5802041c> {
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCKK = Field<16, 1>;    // Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x58020420> {
            using AFSEL0 = Field<0, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL1 = Field<4, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL2 = Field<8, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL3 = Field<12, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL4 = Field<16, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL5 = Field<20, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL6 = Field<24, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL7 = Field<28, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x58020424> {
            using AFSEL8 = Field<0, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL9 = Field<4, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL10 = Field<8, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL11 = Field<12, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL12 = Field<16, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL13 = Field<20, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL14 = Field<24, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL15 = Field<28, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
        };

    };

    // GPIO
    struct GPIOC {
        // GPIO port mode register
        struct MODER : public Register<0x58020800> {
            using MODE0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x58020804> {
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x58020808> {
            using OSPEED0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x5802080c> {
            using PUPD0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        };

        // GPIO port input data register
        struct IDR : public RegisterReadOnly<0x58020810> {
            using ID0 = Field<0, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID1 = Field<1, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID2 = Field<2, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID3 = Field<3, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID4 = Field<4, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID5 = Field<5, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID6 = Field<6, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID7 = Field<7, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID8 = Field<8, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID9 = Field<9, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID10 = Field<10, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID11 = Field<11, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID12 = Field<12, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID13 = Field<13, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID14 = Field<14, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID15 = Field<15, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        };

        // GPIO port output data register
        struct ODR : public Register<0x58020814> {
            using OD0 = Field<0, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD1 = Field<1, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD2 = Field<2, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD3 = Field<3, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD4 = Field<4, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD5 = Field<5, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD6 = Field<6, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD7 = Field<7, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD8 = Field<8, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD9 = Field<9, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD10 = Field<10, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD11 = Field<11, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD12 = Field<12, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD13 = Field<13, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD14 = Field<14, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD15 = Field<15, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        };

        // GPIO port bit set/reset register
        struct BSRR : public RegisterWriteOnly<0x58020818> {
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BR0 = Field<16, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        };

        // This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
        struct LCKR : public Register<0x5802081c> {
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCKK = Field<16, 1>;    // Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x58020820> {
            using AFSEL0 = Field<0, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL1 = Field<4, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL2 = Field<8, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL3 = Field<12, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL4 = Field<16, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL5 = Field<20, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL6 = Field<24, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL7 = Field<28, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x58020824> {
            using AFSEL8 = Field<0, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL9 = Field<4, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL10 = Field<8, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL11 = Field<12, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL12 = Field<16, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL13 = Field<20, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL14 = Field<24, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL15 = Field<28, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
        };

    };

    // GPIO
    struct GPIOD {
        // GPIO port mode register
        struct MODER : public Register<0x58020c00> {
            using MODE0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x58020c04> {
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x58020c08> {
            using OSPEED0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x58020c0c> {
            using PUPD0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        };

        // GPIO port input data register
        struct IDR : public RegisterReadOnly<0x58020c10> {
            using ID0 = Field<0, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID1 = Field<1, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID2 = Field<2, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID3 = Field<3, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID4 = Field<4, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID5 = Field<5, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID6 = Field<6, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID7 = Field<7, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID8 = Field<8, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID9 = Field<9, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID10 = Field<10, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID11 = Field<11, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID12 = Field<12, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID13 = Field<13, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID14 = Field<14, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID15 = Field<15, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        };

        // GPIO port output data register
        struct ODR : public Register<0x58020c14> {
            using OD0 = Field<0, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD1 = Field<1, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD2 = Field<2, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD3 = Field<3, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD4 = Field<4, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD5 = Field<5, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD6 = Field<6, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD7 = Field<7, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD8 = Field<8, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD9 = Field<9, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD10 = Field<10, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD11 = Field<11, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD12 = Field<12, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD13 = Field<13, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD14 = Field<14, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD15 = Field<15, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        };

        // GPIO port bit set/reset register
        struct BSRR : public RegisterWriteOnly<0x58020c18> {
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BR0 = Field<16, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        };

        // This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
        struct LCKR : public Register<0x58020c1c> {
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCKK = Field<16, 1>;    // Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x58020c20> {
            using AFSEL0 = Field<0, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL1 = Field<4, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL2 = Field<8, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL3 = Field<12, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL4 = Field<16, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL5 = Field<20, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL6 = Field<24, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL7 = Field<28, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x58020c24> {
            using AFSEL8 = Field<0, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL9 = Field<4, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL10 = Field<8, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL11 = Field<12, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL12 = Field<16, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL13 = Field<20, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL14 = Field<24, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL15 = Field<28, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
        };

    };

    // GPIO
    struct GPIOE {
        // GPIO port mode register
        struct MODER : public Register<0x58021000> {
            using MODE0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x58021004> {
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x58021008> {
            using OSPEED0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x5802100c> {
            using PUPD0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        };

        // GPIO port input data register
        struct IDR : public RegisterReadOnly<0x58021010> {
            using ID0 = Field<0, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID1 = Field<1, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID2 = Field<2, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID3 = Field<3, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID4 = Field<4, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID5 = Field<5, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID6 = Field<6, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID7 = Field<7, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID8 = Field<8, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID9 = Field<9, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID10 = Field<10, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID11 = Field<11, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID12 = Field<12, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID13 = Field<13, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID14 = Field<14, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID15 = Field<15, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        };

        // GPIO port output data register
        struct ODR : public Register<0x58021014> {
            using OD0 = Field<0, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD1 = Field<1, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD2 = Field<2, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD3 = Field<3, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD4 = Field<4, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD5 = Field<5, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD6 = Field<6, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD7 = Field<7, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD8 = Field<8, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD9 = Field<9, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD10 = Field<10, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD11 = Field<11, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD12 = Field<12, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD13 = Field<13, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD14 = Field<14, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD15 = Field<15, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        };

        // GPIO port bit set/reset register
        struct BSRR : public RegisterWriteOnly<0x58021018> {
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BR0 = Field<16, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        };

        // This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
        struct LCKR : public Register<0x5802101c> {
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCKK = Field<16, 1>;    // Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x58021020> {
            using AFSEL0 = Field<0, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL1 = Field<4, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL2 = Field<8, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL3 = Field<12, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL4 = Field<16, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL5 = Field<20, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL6 = Field<24, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL7 = Field<28, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x58021024> {
            using AFSEL8 = Field<0, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL9 = Field<4, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL10 = Field<8, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL11 = Field<12, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL12 = Field<16, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL13 = Field<20, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL14 = Field<24, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL15 = Field<28, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
        };

    };

    // GPIO
    struct GPIOF {
        // GPIO port mode register
        struct MODER : public Register<0x58021400> {
            using MODE0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x58021404> {
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x58021408> {
            using OSPEED0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x5802140c> {
            using PUPD0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        };

        // GPIO port input data register
        struct IDR : public RegisterReadOnly<0x58021410> {
            using ID0 = Field<0, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID1 = Field<1, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID2 = Field<2, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID3 = Field<3, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID4 = Field<4, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID5 = Field<5, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID6 = Field<6, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID7 = Field<7, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID8 = Field<8, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID9 = Field<9, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID10 = Field<10, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID11 = Field<11, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID12 = Field<12, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID13 = Field<13, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID14 = Field<14, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID15 = Field<15, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        };

        // GPIO port output data register
        struct ODR : public Register<0x58021414> {
            using OD0 = Field<0, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD1 = Field<1, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD2 = Field<2, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD3 = Field<3, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD4 = Field<4, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD5 = Field<5, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD6 = Field<6, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD7 = Field<7, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD8 = Field<8, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD9 = Field<9, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD10 = Field<10, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD11 = Field<11, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD12 = Field<12, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD13 = Field<13, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD14 = Field<14, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD15 = Field<15, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        };

        // GPIO port bit set/reset register
        struct BSRR : public RegisterWriteOnly<0x58021418> {
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BR0 = Field<16, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        };

        // This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
        struct LCKR : public Register<0x5802141c> {
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCKK = Field<16, 1>;    // Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x58021420> {
            using AFSEL0 = Field<0, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL1 = Field<4, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL2 = Field<8, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL3 = Field<12, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL4 = Field<16, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL5 = Field<20, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL6 = Field<24, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL7 = Field<28, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x58021424> {
            using AFSEL8 = Field<0, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL9 = Field<4, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL10 = Field<8, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL11 = Field<12, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL12 = Field<16, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL13 = Field<20, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL14 = Field<24, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL15 = Field<28, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
        };

    };

    // GPIO
    struct GPIOG {
        // GPIO port mode register
        struct MODER : public Register<0x58021800> {
            using MODE0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x58021804> {
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x58021808> {
            using OSPEED0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x5802180c> {
            using PUPD0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        };

        // GPIO port input data register
        struct IDR : public RegisterReadOnly<0x58021810> {
            using ID0 = Field<0, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID1 = Field<1, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID2 = Field<2, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID3 = Field<3, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID4 = Field<4, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID5 = Field<5, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID6 = Field<6, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID7 = Field<7, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID8 = Field<8, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID9 = Field<9, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID10 = Field<10, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID11 = Field<11, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID12 = Field<12, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID13 = Field<13, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID14 = Field<14, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID15 = Field<15, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        };

        // GPIO port output data register
        struct ODR : public Register<0x58021814> {
            using OD0 = Field<0, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD1 = Field<1, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD2 = Field<2, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD3 = Field<3, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD4 = Field<4, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD5 = Field<5, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD6 = Field<6, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD7 = Field<7, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD8 = Field<8, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD9 = Field<9, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD10 = Field<10, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD11 = Field<11, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD12 = Field<12, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD13 = Field<13, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD14 = Field<14, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD15 = Field<15, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        };

        // GPIO port bit set/reset register
        struct BSRR : public RegisterWriteOnly<0x58021818> {
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BR0 = Field<16, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        };

        // This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
        struct LCKR : public Register<0x5802181c> {
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCKK = Field<16, 1>;    // Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x58021820> {
            using AFSEL0 = Field<0, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL1 = Field<4, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL2 = Field<8, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL3 = Field<12, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL4 = Field<16, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL5 = Field<20, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL6 = Field<24, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL7 = Field<28, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x58021824> {
            using AFSEL8 = Field<0, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL9 = Field<4, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL10 = Field<8, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL11 = Field<12, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL12 = Field<16, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL13 = Field<20, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL14 = Field<24, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL15 = Field<28, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
        };

    };

    // GPIO
    struct GPIOH {
        // GPIO port mode register
        struct MODER : public Register<0x58021c00> {
            using MODE0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x58021c04> {
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x58021c08> {
            using OSPEED0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x58021c0c> {
            using PUPD0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        };

        // GPIO port input data register
        struct IDR : public RegisterReadOnly<0x58021c10> {
            using ID0 = Field<0, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID1 = Field<1, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID2 = Field<2, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID3 = Field<3, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID4 = Field<4, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID5 = Field<5, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID6 = Field<6, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID7 = Field<7, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID8 = Field<8, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID9 = Field<9, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID10 = Field<10, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID11 = Field<11, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID12 = Field<12, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID13 = Field<13, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID14 = Field<14, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID15 = Field<15, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        };

        // GPIO port output data register
        struct ODR : public Register<0x58021c14> {
            using OD0 = Field<0, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD1 = Field<1, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD2 = Field<2, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD3 = Field<3, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD4 = Field<4, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD5 = Field<5, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD6 = Field<6, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD7 = Field<7, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD8 = Field<8, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD9 = Field<9, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD10 = Field<10, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD11 = Field<11, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD12 = Field<12, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD13 = Field<13, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD14 = Field<14, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD15 = Field<15, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        };

        // GPIO port bit set/reset register
        struct BSRR : public RegisterWriteOnly<0x58021c18> {
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BR0 = Field<16, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        };

        // This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
        struct LCKR : public Register<0x58021c1c> {
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCKK = Field<16, 1>;    // Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x58021c20> {
            using AFSEL0 = Field<0, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL1 = Field<4, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL2 = Field<8, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL3 = Field<12, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL4 = Field<16, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL5 = Field<20, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL6 = Field<24, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL7 = Field<28, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x58021c24> {
            using AFSEL8 = Field<0, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL9 = Field<4, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL10 = Field<8, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL11 = Field<12, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL12 = Field<16, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL13 = Field<20, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL14 = Field<24, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL15 = Field<28, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
        };

    };

    // GPIO
    struct GPIOI {
        // GPIO port mode register
        struct MODER : public Register<0x58022000> {
            using MODE0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x58022004> {
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x58022008> {
            using OSPEED0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x5802200c> {
            using PUPD0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        };

        // GPIO port input data register
        struct IDR : public RegisterReadOnly<0x58022010> {
            using ID0 = Field<0, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID1 = Field<1, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID2 = Field<2, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID3 = Field<3, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID4 = Field<4, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID5 = Field<5, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID6 = Field<6, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID7 = Field<7, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID8 = Field<8, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID9 = Field<9, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID10 = Field<10, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID11 = Field<11, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID12 = Field<12, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID13 = Field<13, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID14 = Field<14, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID15 = Field<15, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        };

        // GPIO port output data register
        struct ODR : public Register<0x58022014> {
            using OD0 = Field<0, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD1 = Field<1, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD2 = Field<2, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD3 = Field<3, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD4 = Field<4, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD5 = Field<5, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD6 = Field<6, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD7 = Field<7, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD8 = Field<8, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD9 = Field<9, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD10 = Field<10, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD11 = Field<11, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD12 = Field<12, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD13 = Field<13, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD14 = Field<14, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD15 = Field<15, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        };

        // GPIO port bit set/reset register
        struct BSRR : public RegisterWriteOnly<0x58022018> {
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BR0 = Field<16, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        };

        // This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
        struct LCKR : public Register<0x5802201c> {
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCKK = Field<16, 1>;    // Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x58022020> {
            using AFSEL0 = Field<0, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL1 = Field<4, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL2 = Field<8, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL3 = Field<12, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL4 = Field<16, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL5 = Field<20, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL6 = Field<24, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL7 = Field<28, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x58022024> {
            using AFSEL8 = Field<0, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL9 = Field<4, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL10 = Field<8, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL11 = Field<12, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL12 = Field<16, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL13 = Field<20, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL14 = Field<24, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL15 = Field<28, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
        };

    };

    // GPIO
    struct GPIOJ {
        // GPIO port mode register
        struct MODER : public Register<0x58022400> {
            using MODE0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x58022404> {
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x58022408> {
            using OSPEED0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x5802240c> {
            using PUPD0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        };

        // GPIO port input data register
        struct IDR : public RegisterReadOnly<0x58022410> {
            using ID0 = Field<0, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID1 = Field<1, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID2 = Field<2, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID3 = Field<3, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID4 = Field<4, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID5 = Field<5, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID6 = Field<6, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID7 = Field<7, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID8 = Field<8, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID9 = Field<9, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID10 = Field<10, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID11 = Field<11, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID12 = Field<12, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID13 = Field<13, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID14 = Field<14, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID15 = Field<15, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        };

        // GPIO port output data register
        struct ODR : public Register<0x58022414> {
            using OD0 = Field<0, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD1 = Field<1, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD2 = Field<2, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD3 = Field<3, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD4 = Field<4, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD5 = Field<5, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD6 = Field<6, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD7 = Field<7, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD8 = Field<8, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD9 = Field<9, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD10 = Field<10, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD11 = Field<11, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD12 = Field<12, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD13 = Field<13, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD14 = Field<14, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD15 = Field<15, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        };

        // GPIO port bit set/reset register
        struct BSRR : public RegisterWriteOnly<0x58022418> {
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BR0 = Field<16, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        };

        // This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
        struct LCKR : public Register<0x5802241c> {
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCKK = Field<16, 1>;    // Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x58022420> {
            using AFSEL0 = Field<0, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL1 = Field<4, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL2 = Field<8, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL3 = Field<12, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL4 = Field<16, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL5 = Field<20, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL6 = Field<24, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL7 = Field<28, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x58022424> {
            using AFSEL8 = Field<0, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL9 = Field<4, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL10 = Field<8, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL11 = Field<12, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL12 = Field<16, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL13 = Field<20, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL14 = Field<24, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL15 = Field<28, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
        };

    };

    // GPIO
    struct GPIOK {
        // GPIO port mode register
        struct MODER : public Register<0x58022800> {
            using MODE0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
            using MODE15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x58022804> {
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x58022808> {
            using OSPEED0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
            using OSPEED15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x5802280c> {
            using PUPD0 = Field<0, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD1 = Field<2, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD2 = Field<4, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD3 = Field<6, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD4 = Field<8, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD5 = Field<10, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD6 = Field<12, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD7 = Field<14, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD8 = Field<16, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD9 = Field<18, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD10 = Field<20, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD11 = Field<22, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD12 = Field<24, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD13 = Field<26, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD14 = Field<28, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
            using PUPD15 = Field<30, 2>;    // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        };

        // GPIO port input data register
        struct IDR : public RegisterReadOnly<0x58022810> {
            using ID0 = Field<0, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID1 = Field<1, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID2 = Field<2, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID3 = Field<3, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID4 = Field<4, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID5 = Field<5, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID6 = Field<6, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID7 = Field<7, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID8 = Field<8, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID9 = Field<9, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID10 = Field<10, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID11 = Field<11, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID12 = Field<12, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID13 = Field<13, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID14 = Field<14, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
            using ID15 = Field<15, 1>;    // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        };

        // GPIO port output data register
        struct ODR : public Register<0x58022814> {
            using OD0 = Field<0, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD1 = Field<1, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD2 = Field<2, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD3 = Field<3, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD4 = Field<4, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD5 = Field<5, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD6 = Field<6, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD7 = Field<7, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD8 = Field<8, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD9 = Field<9, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD10 = Field<10, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD11 = Field<11, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD12 = Field<12, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD13 = Field<13, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD14 = Field<14, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
            using OD15 = Field<15, 1>;    // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        };

        // GPIO port bit set/reset register
        struct BSRR : public RegisterWriteOnly<0x58022818> {
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
            using BR0 = Field<16, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        };

        // This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
        struct LCKR : public Register<0x5802281c> {
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
            using LCKK = Field<16, 1>;    // Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x58022820> {
            using AFSEL0 = Field<0, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL1 = Field<4, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL2 = Field<8, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL3 = Field<12, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL4 = Field<16, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL5 = Field<20, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL6 = Field<24, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
            using AFSEL7 = Field<28, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x58022824> {
            using AFSEL8 = Field<0, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL9 = Field<4, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL10 = Field<8, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL11 = Field<12, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL12 = Field<16, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL13 = Field<20, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL14 = Field<24, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
            using AFSEL15 = Field<28, 4>;    // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
        };

    };

    // JPEG
    struct JPEG {
        // JPEG codec control register
        struct CONFR0 : public RegisterWriteOnly<0x52003000> {
            using START = Field<0, 1>;    // Start This bit start or stop the encoding or decoding process. Read this register always return 0.
        };

        // JPEG codec configuration register 1
        struct CONFR1 : public Register<0x52003004> {
            using NF = Field<0, 2>;    // Number of color components This field defines the number of color components minus 1.
            using DE = Field<3, 1>;    // Decoding Enable This bit selects the coding or decoding process
            using COLORSPACE = Field<4, 2>;    // Color Space This filed defines the number of quantization tables minus 1 to insert in the output stream.
            using NS = Field<6, 2>;    // Number of components for Scan This field defines the number of components minus 1 for scan header marker segment.
            using HDR = Field<8, 1>;    // Header Processing This bit enable the header processing (generation/parsing).
            using YSIZE = Field<16, 16>;    // Y Size This field defines the number of lines in source image.
        };

        // JPEG codec configuration register 2
        struct CONFR2 : public Register<0x52003008> {
            using NMCU = Field<0, 26>;    // Number of MCU For encoding: this field defines the number of MCU units minus 1 to encode. For decoding: this field indicates the number of complete MCU units minus 1 to be decoded (this field is updated after the JPEG header parsing). If the decoded image size has not a X or Y size multiple of 8 or 16 (depending on the sub-sampling process), the resulting incomplete or empty MCU must be added to this value to get the total number of MCU generated.
        };

        // JPEG codec configuration register 3
        struct CONFR3 : public Register<0x5200300c> {
            using XSIZE = Field<16, 16>;    // X size This field defines the number of pixels per line.
        };

        // JPEG codec configuration register 4-7
        struct CONFRN1 : public Register<0x52003010> {
            using HD = Field<0, 1>;    // Huffman DC Selects the Huffman table for encoding the DC coefficients.
            using HA = Field<1, 1>;    // Huffman AC Selects the Huffman table for encoding the AC coefficients.
            using QT = Field<2, 2>;    // Quantization Table Selects quantization table associated with a color component.
            using NB = Field<4, 4>;    // Number of Block Number of data units minus 1 that belong to a particular color in the MCU.
            using VSF = Field<8, 4>;    // Vertical Sampling Factor Vertical sampling factor for component i.
            using HSF = Field<12, 4>;    // Horizontal Sampling Factor Horizontal sampling factor for component i.
        };

        // JPEG codec configuration register 4-7
        struct CONFRN2 : public Register<0x52003014> {
            using HD = Field<0, 1>;    // Huffman DC Selects the Huffman table for encoding the DC coefficients.
            using HA = Field<1, 1>;    // Huffman AC Selects the Huffman table for encoding the AC coefficients.
            using QT = Field<2, 2>;    // Quantization Table Selects quantization table associated with a color component.
            using NB = Field<4, 4>;    // Number of Block Number of data units minus 1 that belong to a particular color in the MCU.
            using VSF = Field<8, 4>;    // Vertical Sampling Factor Vertical sampling factor for component i.
            using HSF = Field<12, 4>;    // Horizontal Sampling Factor Horizontal sampling factor for component i.
        };

        // JPEG codec configuration register 4-7
        struct CONFRN3 : public Register<0x52003018> {
            using HD = Field<0, 1>;    // Huffman DC Selects the Huffman table for encoding the DC coefficients.
            using HA = Field<1, 1>;    // Huffman AC Selects the Huffman table for encoding the AC coefficients.
            using QT = Field<2, 2>;    // Quantization Table Selects quantization table associated with a color component.
            using NB = Field<4, 4>;    // Number of Block Number of data units minus 1 that belong to a particular color in the MCU.
            using VSF = Field<8, 4>;    // Vertical Sampling Factor Vertical sampling factor for component i.
            using HSF = Field<12, 4>;    // Horizontal Sampling Factor Horizontal sampling factor for component i.
        };

        // JPEG codec configuration register 4-7
        struct CONFRN4 : public Register<0x5200301c> {
            using HD = Field<0, 1>;    // Huffman DC Selects the Huffman table for encoding the DC coefficients.
            using HA = Field<1, 1>;    // Huffman AC Selects the Huffman table for encoding the AC coefficients.
            using QT = Field<2, 2>;    // Quantization Table Selects quantization table associated with a color component.
            using NB = Field<4, 4>;    // Number of Block Number of data units minus 1 that belong to a particular color in the MCU.
            using VSF = Field<8, 4>;    // Vertical Sampling Factor Vertical sampling factor for component i.
            using HSF = Field<12, 4>;    // Horizontal Sampling Factor Horizontal sampling factor for component i.
        };

        // JPEG control register
        struct CR : public Register<0x52003030> {
            using JCEN = Field<0, 1>;    // JPEG Core Enable Enable the JPEG codec Core.
            using IFTIE = Field<1, 1>;    // Input FIFO Threshold Interrupt Enable This bit enables the interrupt generation when input FIFO reach the threshold.
            using IFNFIE = Field<2, 1>;    // Input FIFO Not Full Interrupt Enable This bit enables the interrupt generation when input FIFO is not empty.
            using OFTIE = Field<3, 1>;    // Output FIFO Threshold Interrupt Enable This bit enables the interrupt generation when output FIFO reach the threshold.
            using OFNEIE = Field<4, 1>;    // Output FIFO Not Empty Interrupt Enable This bit enables the interrupt generation when output FIFO is not empty.
            using EOCIE = Field<5, 1>;    // End of Conversion Interrupt Enable This bit enables the interrupt generation on the end of conversion.
            using HPDIE = Field<6, 1>;    // Header Parsing Done Interrupt Enable This bit enables the interrupt generation on the Header Parsing Operation.
            using IDMAEN = Field<11, 1>;    // Input DMA Enable Enable the DMA request generation for the input FIFO.
            using ODMAEN = Field<12, 1>;    // Output DMA Enable Enable the DMA request generation for the output FIFO.
            using IFF = Field<13, 1>;    // Input FIFO Flush This bit flush the input FIFO. This bit is always read as 0.
            using OFF = Field<14, 1>;    // Output FIFO Flush This bit flush the output FIFO. This bit is always read as 0.
        };

        // JPEG status register
        struct SR : public RegisterReadOnly<0x52003034> {
            using IFTF = Field<1, 1>;    // Input FIFO Threshold Flag This bit is set when the input FIFO is not full and is bellow its threshold.
            using IFNFF = Field<2, 1>;    // Input FIFO Not Full Flag This bit is set when the input FIFO is not full (a data can be written).
            using OFTF = Field<3, 1>;    // Output FIFO Threshold Flag This bit is set when the output FIFO is not empty and has reach its threshold.
            using OFNEF = Field<4, 1>;    // Output FIFO Not Empty Flag This bit is set when the output FIFO is not empty (a data is available).
            using EOCF = Field<5, 1>;    // End of Conversion Flag This bit is set when the JPEG codec core has finished the encoding or the decoding process and than last data has been sent to the output FIFO.
            using HPDF = Field<6, 1>;    // Header Parsing Done Flag This bit is set in decode mode when the JPEG codec has finished the parsing of the headers and the internal registers have been updated.
            using COF = Field<7, 1>;    // Codec Operation Flag This bit is set when when a JPEG codec operation is on going (encoding or decoding).
        };

        // JPEG clear flag register
        struct CFR : public Register<0x52003038> {
            using CEOCF = Field<5, 1>;    // Clear End of Conversion Flag Writing 1 clears the End of Conversion Flag of the JPEG Status Register.
            using CHPDF = Field<6, 1>;    // Clear Header Parsing Done Flag Writing 1 clears the Header Parsing Done Flag of the JPEG Status Register.
        };

        // JPEG data input register
        struct DIR : public RegisterWriteOnly<0x52003040> {
            using DATAIN = Field<0, 32>;    // Data Input FIFO Input FIFO data register.
        };

        // JPEG data output register
        struct DOR : public RegisterReadOnly<0x52003044> {
            using DATAOUT = Field<0, 32>;    // Data Output FIFO Output FIFO data register.
        };

    };

    // MDMA
    struct MDMA {
        // MDMA Global Interrupt/Status Register
        struct MDMA_GISR0 : public RegisterReadOnly<0x52000000> {
            using GIF0 = Field<0, 1>;    // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
            using GIF1 = Field<1, 1>;    // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
            using GIF2 = Field<2, 1>;    // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
            using GIF3 = Field<3, 1>;    // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
            using GIF4 = Field<4, 1>;    // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
            using GIF5 = Field<5, 1>;    // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
            using GIF6 = Field<6, 1>;    // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
            using GIF7 = Field<7, 1>;    // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
            using GIF8 = Field<8, 1>;    // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
            using GIF9 = Field<9, 1>;    // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
            using GIF10 = Field<10, 1>;    // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
            using GIF11 = Field<11, 1>;    // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
            using GIF12 = Field<12, 1>;    // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
            using GIF13 = Field<13, 1>;    // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
            using GIF14 = Field<14, 1>;    // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
            using GIF15 = Field<15, 1>;    // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
        };

        // MDMA channel x interrupt/status register
        struct MDMA_C0ISR : public RegisterReadOnly<0x52000040> {
            using TEIF0 = Field<0, 1>;    // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using CTCIF0 = Field<1, 1>;    // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
            using BRTIF0 = Field<2, 1>;    // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using BTIF0 = Field<3, 1>;    // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using TCIF0 = Field<4, 1>;    // channel x buffer transfer complete
            using CRQA0 = Field<16, 1>;    // channel x request active flag
        };

        // MDMA channel x interrupt flag clear register
        struct MDMA_C0IFCR : public RegisterWriteOnly<0x52000044> {
            using CTEIF0 = Field<0, 1>;    // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
            using CCTCIF0 = Field<1, 1>;    // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
            using CBRTIF0 = Field<2, 1>;    // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
            using CBTIF0 = Field<3, 1>;    // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
            using CLTCIF0 = Field<4, 1>;    // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
        };

        // MDMA Channel x error status register
        struct MDMA_C0ESR : public RegisterReadOnly<0x52000048> {
            using TEA = Field<0, 7>;    // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
            using TED = Field<7, 1>;    // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
            using TELD = Field<8, 1>;    // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using TEMD = Field<9, 1>;    // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using ASE = Field<10, 1>;    // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using BSE = Field<11, 1>;    // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
        };

        // This register is used to control the concerned channel.
        struct MDMA_C0CR : public Register<0x5200004c> {
            using EN = Field<0, 1>;    // channel enable
            using TEIE = Field<1, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using CTCIE = Field<2, 1>;    // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
            using BRTIE = Field<3, 1>;    // Block Repeat transfer interrupt enable This bit is set and cleared by software.
            using BTIE = Field<4, 1>;    // Block Transfer interrupt enable This bit is set and cleared by software.
            using TCIE = Field<5, 1>;    // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
            using PL = Field<6, 2>;    // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
            using BEX = Field<12, 1>;    // byte Endianness exchange
            using HEX = Field<13, 1>;    // Half word Endianes exchange
            using WEX = Field<14, 1>;    // Word Endianness exchange
            using SWRQ = Field<16, 1>;    // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
        };

        // This register is used to configure the concerned channel.
        struct MDMA_C0TCR : public Register<0x52000050> {
            using SINC = Field<0, 2>;    // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            using DINC = Field<2, 2>;    // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
            using SSIZE = Field<4, 2>;    // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
            using DSIZE = Field<6, 2>;    // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
            using SINCOS = Field<8, 2>;    // source increment offset size
            using DINCOS = Field<10, 2>;    // Destination increment offset
            using SBURST = Field<12, 3>;    // source burst transfer configuration
            using DBURST = Field<15, 3>;    // Destination burst transfer configuration
            using TLEN = Field<18, 7>;    // buffer transfer lengh
            using PKE = Field<25, 1>;    // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
            using PAM = Field<26, 2>;    // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
            using TRGM = Field<28, 2>;    // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
            using SWRM = Field<30, 1>;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
            using BWM = Field<31, 1>;    // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
        };

        // MDMA Channel x block number of data register
        struct MDMA_C0BNDTR : public Register<0x52000054> {
            using BNDT = Field<0, 17>;    // block number of data to transfer
            using BRSUM = Field<18, 1>;    // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
            using BRDUM = Field<19, 1>;    // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
            using BRC = Field<20, 12>;    // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
        };

        // MDMA channel x source address register
        struct MDMA_C0SAR : public Register<0x52000058> {
            using SAR = Field<0, 32>;    // source adr base
        };

        // MDMA channel x destination address register
        struct MDMA_C0DAR : public Register<0x5200005c> {
            using DAR = Field<0, 32>;    // Destination adr base
        };

        // MDMA channel x Block Repeat address Update register
        struct MDMA_C0BRUR : public Register<0x52000060> {
            using SUV = Field<0, 16>;    // source adresse update value
            using DUV = Field<16, 16>;    // destination address update
        };

        // MDMA channel x Link Address register
        struct MDMA_C0LAR : public Register<0x52000064> {
            using LAR = Field<0, 32>;    // Link address register
        };

        // MDMA channel x Trigger and Bus selection Register
        struct MDMA_C0TBR : public Register<0x52000068> {
            using TSEL = Field<0, 6>;    // Trigger selection
            using SBUS = Field<16, 1>;    // Source BUS select This bit is protected and can be written only if EN is 0.
            using DBUS = Field<17, 1>;    // Destination BUS slect This bit is protected and can be written only if EN is 0.
        };

        // MDMA channel x Mask address register
        struct MDMA_C0MAR : public Register<0x52000070> {
            using MAR = Field<0, 32>;    // Mask address
        };

        // MDMA channel x Mask Data register
        struct MDMA_C0MDR : public Register<0x52000074> {
            using MDR = Field<0, 32>;    // Mask data
        };

        // MDMA channel x interrupt/status register
        struct MDMA_C1ISR : public RegisterReadOnly<0x52000080> {
            using TEIF1 = Field<0, 1>;    // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using CTCIF1 = Field<1, 1>;    // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
            using BRTIF1 = Field<2, 1>;    // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using BTIF1 = Field<3, 1>;    // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using TCIF1 = Field<4, 1>;    // channel x buffer transfer complete
            using CRQA1 = Field<16, 1>;    // channel x request active flag
        };

        // MDMA channel x interrupt flag clear register
        struct MDMA_C1IFCR : public RegisterWriteOnly<0x52000084> {
            using CTEIF1 = Field<0, 1>;    // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
            using CCTCIF1 = Field<1, 1>;    // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
            using CBRTIF1 = Field<2, 1>;    // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
            using CBTIF1 = Field<3, 1>;    // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
            using CLTCIF1 = Field<4, 1>;    // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
        };

        // MDMA Channel x error status register
        struct MDMA_C1ESR : public RegisterReadOnly<0x52000088> {
            using TEA = Field<0, 7>;    // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
            using TED = Field<7, 1>;    // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
            using TELD = Field<8, 1>;    // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using TEMD = Field<9, 1>;    // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using ASE = Field<10, 1>;    // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using BSE = Field<11, 1>;    // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
        };

        // This register is used to control the concerned channel.
        struct MDMA_C1CR : public Register<0x5200008c> {
            using EN = Field<0, 1>;    // channel enable
            using TEIE = Field<1, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using CTCIE = Field<2, 1>;    // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
            using BRTIE = Field<3, 1>;    // Block Repeat transfer interrupt enable This bit is set and cleared by software.
            using BTIE = Field<4, 1>;    // Block Transfer interrupt enable This bit is set and cleared by software.
            using TCIE = Field<5, 1>;    // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
            using PL = Field<6, 2>;    // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
            using BEX = Field<12, 1>;    // byte Endianness exchange
            using HEX = Field<13, 1>;    // Half word Endianes exchange
            using WEX = Field<14, 1>;    // Word Endianness exchange
            using SWRQ = Field<16, 1>;    // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
        };

        // This register is used to configure the concerned channel.
        struct MDMA_C1TCR : public Register<0x52000090> {
            using SINC = Field<0, 2>;    // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            using DINC = Field<2, 2>;    // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
            using SSIZE = Field<4, 2>;    // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
            using DSIZE = Field<6, 2>;    // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
            using SINCOS = Field<8, 2>;    // source increment offset size
            using DINCOS = Field<10, 2>;    // Destination increment offset
            using SBURST = Field<12, 3>;    // source burst transfer configuration
            using DBURST = Field<15, 3>;    // Destination burst transfer configuration
            using TLEN = Field<18, 7>;    // buffer transfer lengh
            using PKE = Field<25, 1>;    // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
            using PAM = Field<26, 2>;    // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
            using TRGM = Field<28, 2>;    // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
            using SWRM = Field<30, 1>;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
            using BWM = Field<31, 1>;    // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
        };

        // MDMA Channel x block number of data register
        struct MDMA_C1BNDTR : public Register<0x52000094> {
            using BNDT = Field<0, 17>;    // block number of data to transfer
            using BRSUM = Field<18, 1>;    // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
            using BRDUM = Field<19, 1>;    // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
            using BRC = Field<20, 12>;    // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
        };

        // MDMA channel x source address register
        struct MDMA_C1SAR : public Register<0x52000098> {
            using SAR = Field<0, 32>;    // source adr base
        };

        // MDMA channel x destination address register
        struct MDMA_C1DAR : public Register<0x5200009c> {
            using DAR = Field<0, 32>;    // Destination adr base
        };

        // MDMA channel x Block Repeat address Update register
        struct MDMA_C1BRUR : public Register<0x520000a0> {
            using SUV = Field<0, 16>;    // source adresse update value
            using DUV = Field<16, 16>;    // destination address update
        };

        // MDMA channel x Link Address register
        struct MDMA_C1LAR : public Register<0x520000a4> {
            using LAR = Field<0, 32>;    // Link address register
        };

        // MDMA channel x Trigger and Bus selection Register
        struct MDMA_C1TBR : public Register<0x520000a8> {
            using TSEL = Field<0, 6>;    // Trigger selection
            using SBUS = Field<16, 1>;    // Source BUS select This bit is protected and can be written only if EN is 0.
            using DBUS = Field<17, 1>;    // Destination BUS slect This bit is protected and can be written only if EN is 0.
        };

        // MDMA channel x Mask address register
        struct MDMA_C1MAR : public Register<0x520000b0> {
            using MAR = Field<0, 32>;    // Mask address
        };

        // MDMA channel x Mask Data register
        struct MDMA_C1MDR : public Register<0x520000b4> {
            using MDR = Field<0, 32>;    // Mask data
        };

        // MDMA channel x interrupt/status register
        struct MDMA_C2ISR : public RegisterReadOnly<0x520000c0> {
            using TEIF2 = Field<0, 1>;    // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using CTCIF2 = Field<1, 1>;    // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
            using BRTIF2 = Field<2, 1>;    // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using BTIF2 = Field<3, 1>;    // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using TCIF2 = Field<4, 1>;    // channel x buffer transfer complete
            using CRQA2 = Field<16, 1>;    // channel x request active flag
        };

        // MDMA channel x interrupt flag clear register
        struct MDMA_C2IFCR : public RegisterWriteOnly<0x520000c4> {
            using CTEIF2 = Field<0, 1>;    // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
            using CCTCIF2 = Field<1, 1>;    // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
            using CBRTIF2 = Field<2, 1>;    // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
            using CBTIF2 = Field<3, 1>;    // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
            using CLTCIF2 = Field<4, 1>;    // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
        };

        // MDMA Channel x error status register
        struct MDMA_C2ESR : public RegisterReadOnly<0x520000c8> {
            using TEA = Field<0, 7>;    // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
            using TED = Field<7, 1>;    // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
            using TELD = Field<8, 1>;    // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using TEMD = Field<9, 1>;    // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using ASE = Field<10, 1>;    // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using BSE = Field<11, 1>;    // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
        };

        // This register is used to control the concerned channel.
        struct MDMA_C2CR : public Register<0x520000cc> {
            using EN = Field<0, 1>;    // channel enable
            using TEIE = Field<1, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using CTCIE = Field<2, 1>;    // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
            using BRTIE = Field<3, 1>;    // Block Repeat transfer interrupt enable This bit is set and cleared by software.
            using BTIE = Field<4, 1>;    // Block Transfer interrupt enable This bit is set and cleared by software.
            using TCIE = Field<5, 1>;    // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
            using PL = Field<6, 2>;    // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
            using BEX = Field<12, 1>;    // byte Endianness exchange
            using HEX = Field<13, 1>;    // Half word Endianes exchange
            using WEX = Field<14, 1>;    // Word Endianness exchange
            using SWRQ = Field<16, 1>;    // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
        };

        // This register is used to configure the concerned channel.
        struct MDMA_C2TCR : public Register<0x520000d0> {
            using SINC = Field<0, 2>;    // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            using DINC = Field<2, 2>;    // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
            using SSIZE = Field<4, 2>;    // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
            using DSIZE = Field<6, 2>;    // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
            using SINCOS = Field<8, 2>;    // source increment offset size
            using DINCOS = Field<10, 2>;    // Destination increment offset
            using SBURST = Field<12, 3>;    // source burst transfer configuration
            using DBURST = Field<15, 3>;    // Destination burst transfer configuration
            using TLEN = Field<18, 7>;    // buffer transfer lengh
            using PKE = Field<25, 1>;    // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
            using PAM = Field<26, 2>;    // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
            using TRGM = Field<28, 2>;    // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
            using SWRM = Field<30, 1>;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
            using BWM = Field<31, 1>;    // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
        };

        // MDMA Channel x block number of data register
        struct MDMA_C2BNDTR : public Register<0x520000d4> {
            using BNDT = Field<0, 17>;    // block number of data to transfer
            using BRSUM = Field<18, 1>;    // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
            using BRDUM = Field<19, 1>;    // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
            using BRC = Field<20, 12>;    // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
        };

        // MDMA channel x source address register
        struct MDMA_C2SAR : public Register<0x520000d8> {
            using SAR = Field<0, 32>;    // source adr base
        };

        // MDMA channel x destination address register
        struct MDMA_C2DAR : public Register<0x520000dc> {
            using DAR = Field<0, 32>;    // Destination adr base
        };

        // MDMA channel x Block Repeat address Update register
        struct MDMA_C2BRUR : public Register<0x520000e0> {
            using SUV = Field<0, 16>;    // source adresse update value
            using DUV = Field<16, 16>;    // destination address update
        };

        // MDMA channel x Link Address register
        struct MDMA_C2LAR : public Register<0x520000e4> {
            using LAR = Field<0, 32>;    // Link address register
        };

        // MDMA channel x Trigger and Bus selection Register
        struct MDMA_C2TBR : public Register<0x520000e8> {
            using TSEL = Field<0, 6>;    // Trigger selection
            using SBUS = Field<16, 1>;    // Source BUS select This bit is protected and can be written only if EN is 0.
            using DBUS = Field<17, 1>;    // Destination BUS slect This bit is protected and can be written only if EN is 0.
        };

        // MDMA channel x Mask address register
        struct MDMA_C2MAR : public Register<0x520000f0> {
            using MAR = Field<0, 32>;    // Mask address
        };

        // MDMA channel x Mask Data register
        struct MDMA_C2MDR : public Register<0x520000f4> {
            using MDR = Field<0, 32>;    // Mask data
        };

        // MDMA channel x interrupt/status register
        struct MDMA_C3ISR : public RegisterReadOnly<0x52000100> {
            using TEIF3 = Field<0, 1>;    // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using CTCIF3 = Field<1, 1>;    // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
            using BRTIF3 = Field<2, 1>;    // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using BTIF3 = Field<3, 1>;    // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using TCIF3 = Field<4, 1>;    // channel x buffer transfer complete
            using CRQA3 = Field<16, 1>;    // channel x request active flag
        };

        // MDMA channel x interrupt flag clear register
        struct MDMA_C3IFCR : public RegisterWriteOnly<0x52000104> {
            using CTEIF3 = Field<0, 1>;    // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
            using CCTCIF3 = Field<1, 1>;    // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
            using CBRTIF3 = Field<2, 1>;    // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
            using CBTIF3 = Field<3, 1>;    // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
            using CLTCIF3 = Field<4, 1>;    // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
        };

        // MDMA Channel x error status register
        struct MDMA_C3ESR : public RegisterReadOnly<0x52000108> {
            using TEA = Field<0, 7>;    // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
            using TED = Field<7, 1>;    // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
            using TELD = Field<8, 1>;    // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using TEMD = Field<9, 1>;    // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using ASE = Field<10, 1>;    // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using BSE = Field<11, 1>;    // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
        };

        // This register is used to control the concerned channel.
        struct MDMA_C3CR : public Register<0x5200010c> {
            using EN = Field<0, 1>;    // channel enable
            using TEIE = Field<1, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using CTCIE = Field<2, 1>;    // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
            using BRTIE = Field<3, 1>;    // Block Repeat transfer interrupt enable This bit is set and cleared by software.
            using BTIE = Field<4, 1>;    // Block Transfer interrupt enable This bit is set and cleared by software.
            using TCIE = Field<5, 1>;    // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
            using PL = Field<6, 2>;    // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
            using BEX = Field<12, 1>;    // byte Endianness exchange
            using HEX = Field<13, 1>;    // Half word Endianes exchange
            using WEX = Field<14, 1>;    // Word Endianness exchange
            using SWRQ = Field<16, 1>;    // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
        };

        // This register is used to configure the concerned channel.
        struct MDMA_C3TCR : public Register<0x52000110> {
            using SINC = Field<0, 2>;    // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            using DINC = Field<2, 2>;    // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
            using SSIZE = Field<4, 2>;    // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
            using DSIZE = Field<6, 2>;    // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
            using SINCOS = Field<8, 2>;    // source increment offset size
            using DINCOS = Field<10, 2>;    // Destination increment offset
            using SBURST = Field<12, 3>;    // source burst transfer configuration
            using DBURST = Field<15, 3>;    // Destination burst transfer configuration
            using TLEN = Field<18, 7>;    // buffer transfer lengh
            using PKE = Field<25, 1>;    // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
            using PAM = Field<26, 2>;    // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
            using TRGM = Field<28, 2>;    // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
            using SWRM = Field<30, 1>;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
            using BWM = Field<31, 1>;    // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
        };

        // MDMA Channel x block number of data register
        struct MDMA_C3BNDTR : public Register<0x52000114> {
            using BNDT = Field<0, 17>;    // block number of data to transfer
            using BRSUM = Field<18, 1>;    // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
            using BRDUM = Field<19, 1>;    // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
            using BRC = Field<20, 12>;    // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
        };

        // MDMA channel x source address register
        struct MDMA_C3SAR : public Register<0x52000118> {
            using SAR = Field<0, 32>;    // source adr base
        };

        // MDMA channel x destination address register
        struct MDMA_C3DAR : public Register<0x5200011c> {
            using DAR = Field<0, 32>;    // Destination adr base
        };

        // MDMA channel x Block Repeat address Update register
        struct MDMA_C3BRUR : public Register<0x52000120> {
            using SUV = Field<0, 16>;    // source adresse update value
            using DUV = Field<16, 16>;    // destination address update
        };

        // MDMA channel x Link Address register
        struct MDMA_C3LAR : public Register<0x52000124> {
            using LAR = Field<0, 32>;    // Link address register
        };

        // MDMA channel x Trigger and Bus selection Register
        struct MDMA_C3TBR : public Register<0x52000128> {
            using TSEL = Field<0, 6>;    // Trigger selection
            using SBUS = Field<16, 1>;    // Source BUS select This bit is protected and can be written only if EN is 0.
            using DBUS = Field<17, 1>;    // Destination BUS slect This bit is protected and can be written only if EN is 0.
        };

        // MDMA channel x Mask address register
        struct MDMA_C3MAR : public Register<0x52000130> {
            using MAR = Field<0, 32>;    // Mask address
        };

        // MDMA channel x Mask Data register
        struct MDMA_C3MDR : public Register<0x52000134> {
            using MDR = Field<0, 32>;    // Mask data
        };

        // MDMA channel x interrupt/status register
        struct MDMA_C4ISR : public RegisterReadOnly<0x52000140> {
            using TEIF4 = Field<0, 1>;    // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using CTCIF4 = Field<1, 1>;    // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
            using BRTIF4 = Field<2, 1>;    // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using BTIF4 = Field<3, 1>;    // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using TCIF4 = Field<4, 1>;    // channel x buffer transfer complete
            using CRQA4 = Field<16, 1>;    // channel x request active flag
        };

        // MDMA channel x interrupt flag clear register
        struct MDMA_C4IFCR : public RegisterWriteOnly<0x52000144> {
            using CTEIF4 = Field<0, 1>;    // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
            using CCTCIF4 = Field<1, 1>;    // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
            using CBRTIF4 = Field<2, 1>;    // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
            using CBTIF4 = Field<3, 1>;    // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
            using CLTCIF4 = Field<4, 1>;    // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
        };

        // MDMA Channel x error status register
        struct MDMA_C4ESR : public RegisterReadOnly<0x52000148> {
            using TEA = Field<0, 7>;    // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
            using TED = Field<7, 1>;    // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
            using TELD = Field<8, 1>;    // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using TEMD = Field<9, 1>;    // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using ASE = Field<10, 1>;    // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using BSE = Field<11, 1>;    // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
        };

        // This register is used to control the concerned channel.
        struct MDMA_C4CR : public Register<0x5200014c> {
            using EN = Field<0, 1>;    // channel enable
            using TEIE = Field<1, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using CTCIE = Field<2, 1>;    // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
            using BRTIE = Field<3, 1>;    // Block Repeat transfer interrupt enable This bit is set and cleared by software.
            using BTIE = Field<4, 1>;    // Block Transfer interrupt enable This bit is set and cleared by software.
            using TCIE = Field<5, 1>;    // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
            using PL = Field<6, 2>;    // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
            using BEX = Field<12, 1>;    // byte Endianness exchange
            using HEX = Field<13, 1>;    // Half word Endianes exchange
            using WEX = Field<14, 1>;    // Word Endianness exchange
            using SWRQ = Field<16, 1>;    // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
        };

        // This register is used to configure the concerned channel.
        struct MDMA_C4TCR : public Register<0x52000150> {
            using SINC = Field<0, 2>;    // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            using DINC = Field<2, 2>;    // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
            using SSIZE = Field<4, 2>;    // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
            using DSIZE = Field<6, 2>;    // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
            using SINCOS = Field<8, 2>;    // source increment offset size
            using DINCOS = Field<10, 2>;    // Destination increment offset
            using SBURST = Field<12, 3>;    // source burst transfer configuration
            using DBURST = Field<15, 3>;    // Destination burst transfer configuration
            using TLEN = Field<18, 7>;    // buffer transfer lengh
            using PKE = Field<25, 1>;    // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
            using PAM = Field<26, 2>;    // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
            using TRGM = Field<28, 2>;    // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
            using SWRM = Field<30, 1>;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
            using BWM = Field<31, 1>;    // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
        };

        // MDMA Channel x block number of data register
        struct MDMA_C4BNDTR : public Register<0x52000154> {
            using BNDT = Field<0, 17>;    // block number of data to transfer
            using BRSUM = Field<18, 1>;    // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
            using BRDUM = Field<19, 1>;    // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
            using BRC = Field<20, 12>;    // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
        };

        // MDMA channel x source address register
        struct MDMA_C4SAR : public Register<0x52000158> {
            using SAR = Field<0, 32>;    // source adr base
        };

        // MDMA channel x destination address register
        struct MDMA_C4DAR : public Register<0x5200015c> {
            using DAR = Field<0, 32>;    // Destination adr base
        };

        // MDMA channel x Block Repeat address Update register
        struct MDMA_C4BRUR : public Register<0x52000160> {
            using SUV = Field<0, 16>;    // source adresse update value
            using DUV = Field<16, 16>;    // destination address update
        };

        // MDMA channel x Link Address register
        struct MDMA_C4LAR : public Register<0x52000164> {
            using LAR = Field<0, 32>;    // Link address register
        };

        // MDMA channel x Trigger and Bus selection Register
        struct MDMA_C4TBR : public Register<0x52000168> {
            using TSEL = Field<0, 6>;    // Trigger selection
            using SBUS = Field<16, 1>;    // Source BUS select This bit is protected and can be written only if EN is 0.
            using DBUS = Field<17, 1>;    // Destination BUS slect This bit is protected and can be written only if EN is 0.
        };

        // MDMA channel x Mask address register
        struct MDMA_C4MAR : public Register<0x52000170> {
            using MAR = Field<0, 32>;    // Mask address
        };

        // MDMA channel x Mask Data register
        struct MDMA_C4MDR : public Register<0x52000174> {
            using MDR = Field<0, 32>;    // Mask data
        };

        // MDMA channel x interrupt/status register
        struct MDMA_C5ISR : public RegisterReadOnly<0x52000180> {
            using TEIF5 = Field<0, 1>;    // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using CTCIF5 = Field<1, 1>;    // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
            using BRTIF5 = Field<2, 1>;    // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using BTIF5 = Field<3, 1>;    // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using TCIF5 = Field<4, 1>;    // channel x buffer transfer complete
            using CRQA5 = Field<16, 1>;    // channel x request active flag
        };

        // MDMA channel x interrupt flag clear register
        struct MDMA_C5IFCR : public RegisterWriteOnly<0x52000184> {
            using CTEIF5 = Field<0, 1>;    // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
            using CCTCIF5 = Field<1, 1>;    // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
            using CBRTIF5 = Field<2, 1>;    // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
            using CBTIF5 = Field<3, 1>;    // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
            using CLTCIF5 = Field<4, 1>;    // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
        };

        // MDMA Channel x error status register
        struct MDMA_C5ESR : public RegisterReadOnly<0x52000188> {
            using TEA = Field<0, 7>;    // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
            using TED = Field<7, 1>;    // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
            using TELD = Field<8, 1>;    // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using TEMD = Field<9, 1>;    // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using ASE = Field<10, 1>;    // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using BSE = Field<11, 1>;    // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
        };

        // This register is used to control the concerned channel.
        struct MDMA_C5CR : public Register<0x5200018c> {
            using EN = Field<0, 1>;    // channel enable
            using TEIE = Field<1, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using CTCIE = Field<2, 1>;    // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
            using BRTIE = Field<3, 1>;    // Block Repeat transfer interrupt enable This bit is set and cleared by software.
            using BTIE = Field<4, 1>;    // Block Transfer interrupt enable This bit is set and cleared by software.
            using TCIE = Field<5, 1>;    // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
            using PL = Field<6, 2>;    // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
            using BEX = Field<12, 1>;    // byte Endianness exchange
            using HEX = Field<13, 1>;    // Half word Endianes exchange
            using WEX = Field<14, 1>;    // Word Endianness exchange
            using SWRQ = Field<16, 1>;    // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
        };

        // This register is used to configure the concerned channel.
        struct MDMA_C5TCR : public Register<0x52000190> {
            using SINC = Field<0, 2>;    // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            using DINC = Field<2, 2>;    // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
            using SSIZE = Field<4, 2>;    // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
            using DSIZE = Field<6, 2>;    // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
            using SINCOS = Field<8, 2>;    // source increment offset size
            using DINCOS = Field<10, 2>;    // Destination increment offset
            using SBURST = Field<12, 3>;    // source burst transfer configuration
            using DBURST = Field<15, 3>;    // Destination burst transfer configuration
            using TLEN = Field<18, 7>;    // buffer transfer lengh
            using PKE = Field<25, 1>;    // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
            using PAM = Field<26, 2>;    // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
            using TRGM = Field<28, 2>;    // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
            using SWRM = Field<30, 1>;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
            using BWM = Field<31, 1>;    // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
        };

        // MDMA Channel x block number of data register
        struct MDMA_C5BNDTR : public Register<0x52000194> {
            using BNDT = Field<0, 17>;    // block number of data to transfer
            using BRSUM = Field<18, 1>;    // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
            using BRDUM = Field<19, 1>;    // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
            using BRC = Field<20, 12>;    // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
        };

        // MDMA channel x source address register
        struct MDMA_C5SAR : public Register<0x52000198> {
            using SAR = Field<0, 32>;    // source adr base
        };

        // MDMA channel x destination address register
        struct MDMA_C5DAR : public Register<0x5200019c> {
            using DAR = Field<0, 32>;    // Destination adr base
        };

        // MDMA channel x Block Repeat address Update register
        struct MDMA_C5BRUR : public Register<0x520001a0> {
            using SUV = Field<0, 16>;    // source adresse update value
            using DUV = Field<16, 16>;    // destination address update
        };

        // MDMA channel x Link Address register
        struct MDMA_C5LAR : public Register<0x520001a4> {
            using LAR = Field<0, 32>;    // Link address register
        };

        // MDMA channel x Trigger and Bus selection Register
        struct MDMA_C5TBR : public Register<0x520001a8> {
            using TSEL = Field<0, 6>;    // Trigger selection
            using SBUS = Field<16, 1>;    // Source BUS select This bit is protected and can be written only if EN is 0.
            using DBUS = Field<17, 1>;    // Destination BUS slect This bit is protected and can be written only if EN is 0.
        };

        // MDMA channel x Mask address register
        struct MDMA_C5MAR : public Register<0x520001b0> {
            using MAR = Field<0, 32>;    // Mask address
        };

        // MDMA channel x Mask Data register
        struct MDMA_C5MDR : public Register<0x520001b4> {
            using MDR = Field<0, 32>;    // Mask data
        };

        // MDMA channel x interrupt/status register
        struct MDMA_C6ISR : public RegisterReadOnly<0x520001c0> {
            using TEIF6 = Field<0, 1>;    // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using CTCIF6 = Field<1, 1>;    // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
            using BRTIF6 = Field<2, 1>;    // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using BTIF6 = Field<3, 1>;    // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using TCIF6 = Field<4, 1>;    // channel x buffer transfer complete
            using CRQA6 = Field<16, 1>;    // channel x request active flag
        };

        // MDMA channel x interrupt flag clear register
        struct MDMA_C6IFCR : public RegisterWriteOnly<0x520001c4> {
            using CTEIF6 = Field<0, 1>;    // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
            using CCTCIF6 = Field<1, 1>;    // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
            using CBRTIF6 = Field<2, 1>;    // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
            using CBTIF6 = Field<3, 1>;    // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
            using CLTCIF6 = Field<4, 1>;    // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
        };

        // MDMA Channel x error status register
        struct MDMA_C6ESR : public RegisterReadOnly<0x520001c8> {
            using TEA = Field<0, 7>;    // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
            using TED = Field<7, 1>;    // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
            using TELD = Field<8, 1>;    // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using TEMD = Field<9, 1>;    // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using ASE = Field<10, 1>;    // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using BSE = Field<11, 1>;    // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
        };

        // This register is used to control the concerned channel.
        struct MDMA_C6CR : public Register<0x520001cc> {
            using EN = Field<0, 1>;    // channel enable
            using TEIE = Field<1, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using CTCIE = Field<2, 1>;    // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
            using BRTIE = Field<3, 1>;    // Block Repeat transfer interrupt enable This bit is set and cleared by software.
            using BTIE = Field<4, 1>;    // Block Transfer interrupt enable This bit is set and cleared by software.
            using TCIE = Field<5, 1>;    // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
            using PL = Field<6, 2>;    // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
            using BEX = Field<12, 1>;    // byte Endianness exchange
            using HEX = Field<13, 1>;    // Half word Endianes exchange
            using WEX = Field<14, 1>;    // Word Endianness exchange
            using SWRQ = Field<16, 1>;    // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
        };

        // This register is used to configure the concerned channel.
        struct MDMA_C6TCR : public Register<0x520001d0> {
            using SINC = Field<0, 2>;    // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            using DINC = Field<2, 2>;    // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
            using SSIZE = Field<4, 2>;    // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
            using DSIZE = Field<6, 2>;    // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
            using SINCOS = Field<8, 2>;    // source increment offset size
            using DINCOS = Field<10, 2>;    // Destination increment offset
            using SBURST = Field<12, 3>;    // source burst transfer configuration
            using DBURST = Field<15, 3>;    // Destination burst transfer configuration
            using TLEN = Field<18, 7>;    // buffer transfer lengh
            using PKE = Field<25, 1>;    // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
            using PAM = Field<26, 2>;    // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
            using TRGM = Field<28, 2>;    // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
            using SWRM = Field<30, 1>;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
            using BWM = Field<31, 1>;    // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
        };

        // MDMA Channel x block number of data register
        struct MDMA_C6BNDTR : public Register<0x520001d4> {
            using BNDT = Field<0, 17>;    // block number of data to transfer
            using BRSUM = Field<18, 1>;    // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
            using BRDUM = Field<19, 1>;    // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
            using BRC = Field<20, 12>;    // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0
        };

        // MDMA channel x source address register
        struct MDMA_C6SAR : public Register<0x520001d8> {
            using SAR = Field<0, 32>;    // source adr base
        };

        // MDMA channel x destination address register
        struct MDMA_C6DAR : public Register<0x520001dc> {
            using DAR = Field<0, 32>;    // Destination adr base
        };

        // MDMA channel x Block Repeat address Update register
        struct MDMA_C6BRUR : public Register<0x520001e0> {
            using SUV = Field<0, 16>;    // source adresse update value
            using DUV = Field<16, 16>;    // destination address update
        };

        // MDMA channel x Link Address register
        struct MDMA_C6LAR : public Register<0x520001e4> {
            using LAR = Field<0, 32>;    // Link address register
        };

        // MDMA channel x Trigger and Bus selection Register
        struct MDMA_C6TBR : public Register<0x520001e8> {
            using TSEL = Field<0, 6>;    // Trigger selection
            using SBUS = Field<16, 1>;    // Source BUS select This bit is protected and can be written only if EN is 0.
            using DBUS = Field<17, 1>;    // Destination BUS slect This bit is protected and can be written only if EN is 0.
        };

        // MDMA channel x Mask address register
        struct MDMA_C6MAR : public Register<0x520001f0> {
            using MAR = Field<0, 32>;    // Mask address
        };

        // MDMA channel x Mask Data register
        struct MDMA_C6MDR : public Register<0x520001f4> {
            using MDR = Field<0, 32>;    // Mask data
        };

        // MDMA channel x interrupt/status register
        struct MDMA_C7ISR : public RegisterReadOnly<0x52000200> {
            using TEIF7 = Field<0, 1>;    // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using CTCIF7 = Field<1, 1>;    // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
            using BRTIF7 = Field<2, 1>;    // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using BTIF7 = Field<3, 1>;    // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using TCIF7 = Field<4, 1>;    // channel x buffer transfer complete
            using CRQA7 = Field<16, 1>;    // channel x request active flag
        };

        // MDMA channel x interrupt flag clear register
        struct MDMA_C7IFCR : public RegisterWriteOnly<0x52000204> {
            using CTEIF7 = Field<0, 1>;    // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
            using CCTCIF7 = Field<1, 1>;    // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
            using CBRTIF7 = Field<2, 1>;    // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
            using CBTIF7 = Field<3, 1>;    // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
            using CLTCIF7 = Field<4, 1>;    // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
        };

        // MDMA Channel x error status register
        struct MDMA_C7ESR : public RegisterReadOnly<0x52000208> {
            using TEA = Field<0, 7>;    // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
            using TED = Field<7, 1>;    // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
            using TELD = Field<8, 1>;    // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using TEMD = Field<9, 1>;    // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using ASE = Field<10, 1>;    // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using BSE = Field<11, 1>;    // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
        };

        // This register is used to control the concerned channel.
        struct MDMA_C7CR : public Register<0x5200020c> {
            using EN = Field<0, 1>;    // channel enable
            using TEIE = Field<1, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using CTCIE = Field<2, 1>;    // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
            using BRTIE = Field<3, 1>;    // Block Repeat transfer interrupt enable This bit is set and cleared by software.
            using BTIE = Field<4, 1>;    // Block Transfer interrupt enable This bit is set and cleared by software.
            using TCIE = Field<5, 1>;    // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
            using PL = Field<6, 2>;    // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
            using BEX = Field<12, 1>;    // byte Endianness exchange
            using HEX = Field<13, 1>;    // Half word Endianes exchange
            using WEX = Field<14, 1>;    // Word Endianness exchange
            using SWRQ = Field<16, 1>;    // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
        };

        // This register is used to configure the concerned channel.
        struct MDMA_C7TCR : public Register<0x52000210> {
            using SINC = Field<0, 2>;    // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            using DINC = Field<2, 2>;    // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
            using SSIZE = Field<4, 2>;    // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
            using DSIZE = Field<6, 2>;    // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
            using SINCOS = Field<8, 2>;    // source increment offset size
            using DINCOS = Field<10, 2>;    // Destination increment offset
            using SBURST = Field<12, 3>;    // source burst transfer configuration
            using DBURST = Field<15, 3>;    // Destination burst transfer configuration
            using TLEN = Field<18, 7>;    // buffer transfer lengh
            using PKE = Field<25, 1>;    // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
            using PAM = Field<26, 2>;    // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
            using TRGM = Field<28, 2>;    // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
            using SWRM = Field<30, 1>;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
            using BWM = Field<31, 1>;    // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
        };

        // MDMA Channel x block number of data register
        struct MDMA_C7BNDTR : public Register<0x52000214> {
            using BNDT = Field<0, 17>;    // block number of data to transfer
            using BRSUM = Field<18, 1>;    // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
            using BRDUM = Field<19, 1>;    // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
            using BRC = Field<20, 12>;    // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
        };

        // MDMA channel x source address register
        struct MDMA_C7SAR : public Register<0x52000218> {
            using SAR = Field<0, 32>;    // source adr base
        };

        // MDMA channel x destination address register
        struct MDMA_C7DAR : public Register<0x5200021c> {
            using DAR = Field<0, 32>;    // Destination adr base
        };

        // MDMA channel x Block Repeat address Update register
        struct MDMA_C7BRUR : public Register<0x52000220> {
            using SUV = Field<0, 16>;    // source adresse update value
            using DUV = Field<16, 16>;    // destination address update
        };

        // MDMA channel x Link Address register
        struct MDMA_C7LAR : public Register<0x52000224> {
            using LAR = Field<0, 32>;    // Link address register
        };

        // MDMA channel x Trigger and Bus selection Register
        struct MDMA_C7TBR : public Register<0x52000228> {
            using TSEL = Field<0, 6>;    // Trigger selection
            using SBUS = Field<16, 1>;    // Source BUS select This bit is protected and can be written only if EN is 0.
            using DBUS = Field<17, 1>;    // Destination BUS slect This bit is protected and can be written only if EN is 0.
        };

        // MDMA channel x Mask address register
        struct MDMA_C7MAR : public Register<0x52000230> {
            using MAR = Field<0, 32>;    // Mask address
        };

        // MDMA channel x Mask Data register
        struct MDMA_C7MDR : public Register<0x52000234> {
            using MDR = Field<0, 32>;    // Mask data
        };

        // MDMA channel x interrupt/status register
        struct MDMA_C8ISR : public RegisterReadOnly<0x52000240> {
            using TEIF8 = Field<0, 1>;    // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using CTCIF8 = Field<1, 1>;    // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
            using BRTIF8 = Field<2, 1>;    // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using BTIF8 = Field<3, 1>;    // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using TCIF8 = Field<4, 1>;    // channel x buffer transfer complete
            using CRQA8 = Field<16, 1>;    // channel x request active flag
        };

        // MDMA channel x interrupt flag clear register
        struct MDMA_C8IFCR : public RegisterWriteOnly<0x52000244> {
            using CTEIF8 = Field<0, 1>;    // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
            using CCTCIF8 = Field<1, 1>;    // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
            using CBRTIF8 = Field<2, 1>;    // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
            using CBTIF8 = Field<3, 1>;    // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
            using CLTCIF8 = Field<4, 1>;    // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
        };

        // MDMA Channel x error status register
        struct MDMA_C8ESR : public RegisterReadOnly<0x52000248> {
            using TEA = Field<0, 7>;    // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
            using TED = Field<7, 1>;    // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
            using TELD = Field<8, 1>;    // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using TEMD = Field<9, 1>;    // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using ASE = Field<10, 1>;    // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using BSE = Field<11, 1>;    // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
        };

        // This register is used to control the concerned channel.
        struct MDMA_C8CR : public Register<0x5200024c> {
            using EN = Field<0, 1>;    // channel enable
            using TEIE = Field<1, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using CTCIE = Field<2, 1>;    // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
            using BRTIE = Field<3, 1>;    // Block Repeat transfer interrupt enable This bit is set and cleared by software.
            using BTIE = Field<4, 1>;    // Block Transfer interrupt enable This bit is set and cleared by software.
            using TCIE = Field<5, 1>;    // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
            using PL = Field<6, 2>;    // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
            using BEX = Field<12, 1>;    // byte Endianness exchange
            using HEX = Field<13, 1>;    // Half word Endianes exchange
            using WEX = Field<14, 1>;    // Word Endianness exchange
            using SWRQ = Field<16, 1>;    // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
        };

        // This register is used to configure the concerned channel.
        struct MDMA_C8TCR : public Register<0x52000250> {
            using SINC = Field<0, 2>;    // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            using DINC = Field<2, 2>;    // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
            using SSIZE = Field<4, 2>;    // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
            using DSIZE = Field<6, 2>;    // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
            using SINCOS = Field<8, 2>;    // source increment offset size
            using DINCOS = Field<10, 2>;    // Destination increment offset
            using SBURST = Field<12, 3>;    // source burst transfer configuration
            using DBURST = Field<15, 3>;    // Destination burst transfer configuration
            using TLEN = Field<18, 7>;    // buffer transfer lengh
            using PKE = Field<25, 1>;    // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
            using PAM = Field<26, 2>;    // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
            using TRGM = Field<28, 2>;    // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
            using SWRM = Field<30, 1>;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
            using BWM = Field<31, 1>;    // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
        };

        // MDMA Channel x block number of data register
        struct MDMA_C8BNDTR : public Register<0x52000254> {
            using BNDT = Field<0, 17>;    // block number of data to transfer
            using BRSUM = Field<18, 1>;    // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
            using BRDUM = Field<19, 1>;    // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
            using BRC = Field<20, 12>;    // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
        };

        // MDMA channel x source address register
        struct MDMA_C8SAR : public Register<0x52000258> {
            using SAR = Field<0, 32>;    // source adr base
        };

        // MDMA channel x destination address register
        struct MDMA_C8DAR : public Register<0x5200025c> {
            using DAR = Field<0, 32>;    // Destination adr base
        };

        // MDMA channel x Block Repeat address Update register
        struct MDMA_C8BRUR : public Register<0x52000260> {
            using SUV = Field<0, 16>;    // source adresse update value
            using DUV = Field<16, 16>;    // destination address update
        };

        // MDMA channel x Link Address register
        struct MDMA_C8LAR : public Register<0x52000264> {
            using LAR = Field<0, 32>;    // Link address register
        };

        // MDMA channel x Trigger and Bus selection Register
        struct MDMA_C8TBR : public Register<0x52000268> {
            using TSEL = Field<0, 6>;    // Trigger selection
            using SBUS = Field<16, 1>;    // Source BUS select This bit is protected and can be written only if EN is 0.
            using DBUS = Field<17, 1>;    // Destination BUS slect This bit is protected and can be written only if EN is 0.
        };

        // MDMA channel x Mask address register
        struct MDMA_C8MAR : public Register<0x52000270> {
            using MAR = Field<0, 32>;    // Mask address
        };

        // MDMA channel x Mask Data register
        struct MDMA_C8MDR : public Register<0x52000274> {
            using MDR = Field<0, 32>;    // Mask data
        };

        // MDMA channel x interrupt/status register
        struct MDMA_C9ISR : public RegisterReadOnly<0x52000280> {
            using TEIF9 = Field<0, 1>;    // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using CTCIF9 = Field<1, 1>;    // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
            using BRTIF9 = Field<2, 1>;    // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using BTIF9 = Field<3, 1>;    // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using TCIF9 = Field<4, 1>;    // channel x buffer transfer complete
            using CRQA9 = Field<16, 1>;    // channel x request active flag
        };

        // MDMA channel x interrupt flag clear register
        struct MDMA_C9IFCR : public RegisterWriteOnly<0x52000284> {
            using CTEIF9 = Field<0, 1>;    // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
            using CCTCIF9 = Field<1, 1>;    // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
            using CBRTIF9 = Field<2, 1>;    // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
            using CBTIF9 = Field<3, 1>;    // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
            using CLTCIF9 = Field<4, 1>;    // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
        };

        // MDMA Channel x error status register
        struct MDMA_C9ESR : public RegisterReadOnly<0x52000288> {
            using TEA = Field<0, 7>;    // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
            using TED = Field<7, 1>;    // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
            using TELD = Field<8, 1>;    // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using TEMD = Field<9, 1>;    // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using ASE = Field<10, 1>;    // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using BSE = Field<11, 1>;    // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
        };

        // This register is used to control the concerned channel.
        struct MDMA_C9CR : public Register<0x5200028c> {
            using EN = Field<0, 1>;    // channel enable
            using TEIE = Field<1, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using CTCIE = Field<2, 1>;    // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
            using BRTIE = Field<3, 1>;    // Block Repeat transfer interrupt enable This bit is set and cleared by software.
            using BTIE = Field<4, 1>;    // Block Transfer interrupt enable This bit is set and cleared by software.
            using TCIE = Field<5, 1>;    // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
            using PL = Field<6, 2>;    // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
            using BEX = Field<12, 1>;    // byte Endianness exchange
            using HEX = Field<13, 1>;    // Half word Endianes exchange
            using WEX = Field<14, 1>;    // Word Endianness exchange
            using SWRQ = Field<16, 1>;    // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
        };

        // This register is used to configure the concerned channel.
        struct MDMA_C9TCR : public Register<0x52000290> {
            using SINC = Field<0, 2>;    // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            using DINC = Field<2, 2>;    // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
            using SSIZE = Field<4, 2>;    // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
            using DSIZE = Field<6, 2>;    // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
            using SINCOS = Field<8, 2>;    // source increment offset size
            using DINCOS = Field<10, 2>;    // Destination increment offset
            using SBURST = Field<12, 3>;    // source burst transfer configuration
            using DBURST = Field<15, 3>;    // Destination burst transfer configuration
            using TLEN = Field<18, 7>;    // buffer transfer lengh
            using PKE = Field<25, 1>;    // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
            using PAM = Field<26, 2>;    // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
            using TRGM = Field<28, 2>;    // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
            using SWRM = Field<30, 1>;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
            using BWM = Field<31, 1>;    // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
        };

        // MDMA Channel x block number of data register
        struct MDMA_C9BNDTR : public Register<0x52000294> {
            using BNDT = Field<0, 17>;    // block number of data to transfer
            using BRSUM = Field<18, 1>;    // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
            using BRDUM = Field<19, 1>;    // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
            using BRC = Field<20, 12>;    // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
        };

        // MDMA channel x source address register
        struct MDMA_C9SAR : public Register<0x52000298> {
            using SAR = Field<0, 32>;    // source adr base
        };

        // MDMA channel x destination address register
        struct MDMA_C9DAR : public Register<0x5200029c> {
            using DAR = Field<0, 32>;    // Destination adr base
        };

        // MDMA channel x Block Repeat address Update register
        struct MDMA_C9BRUR : public Register<0x520002a0> {
            using SUV = Field<0, 16>;    // source adresse update value
            using DUV = Field<16, 16>;    // destination address update
        };

        // MDMA channel x Link Address register
        struct MDMA_C9LAR : public Register<0x520002a4> {
            using LAR = Field<0, 32>;    // Link address register
        };

        // MDMA channel x Trigger and Bus selection Register
        struct MDMA_C9TBR : public Register<0x520002a8> {
            using TSEL = Field<0, 6>;    // Trigger selection
            using SBUS = Field<16, 1>;    // Source BUS select This bit is protected and can be written only if EN is 0.
            using DBUS = Field<17, 1>;    // Destination BUS slect This bit is protected and can be written only if EN is 0.
        };

        // MDMA channel x Mask address register
        struct MDMA_C9MAR : public Register<0x520002b0> {
            using MAR = Field<0, 32>;    // Mask address
        };

        // MDMA channel x Mask Data register
        struct MDMA_C9MDR : public Register<0x520002b4> {
            using MDR = Field<0, 32>;    // Mask data
        };

        // MDMA channel x interrupt/status register
        struct MDMA_C10ISR : public RegisterReadOnly<0x520002c0> {
            using TEIF10 = Field<0, 1>;    // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using CTCIF10 = Field<1, 1>;    // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
            using BRTIF10 = Field<2, 1>;    // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using BTIF10 = Field<3, 1>;    // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using TCIF10 = Field<4, 1>;    // channel x buffer transfer complete
            using CRQA10 = Field<16, 1>;    // channel x request active flag
        };

        // MDMA channel x interrupt flag clear register
        struct MDMA_C10IFCR : public RegisterWriteOnly<0x520002c4> {
            using CTEIF10 = Field<0, 1>;    // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
            using CCTCIF10 = Field<1, 1>;    // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
            using CBRTIF10 = Field<2, 1>;    // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
            using CBTIF10 = Field<3, 1>;    // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
            using CLTCIF10 = Field<4, 1>;    // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
        };

        // MDMA Channel x error status register
        struct MDMA_C10ESR : public RegisterReadOnly<0x520002c8> {
            using TEA = Field<0, 7>;    // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
            using TED = Field<7, 1>;    // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
            using TELD = Field<8, 1>;    // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using TEMD = Field<9, 1>;    // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using ASE = Field<10, 1>;    // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using BSE = Field<11, 1>;    // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
        };

        // This register is used to control the concerned channel.
        struct MDMA_C10CR : public Register<0x520002cc> {
            using EN = Field<0, 1>;    // channel enable
            using TEIE = Field<1, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using CTCIE = Field<2, 1>;    // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
            using BRTIE = Field<3, 1>;    // Block Repeat transfer interrupt enable This bit is set and cleared by software.
            using BTIE = Field<4, 1>;    // Block Transfer interrupt enable This bit is set and cleared by software.
            using TCIE = Field<5, 1>;    // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
            using PL = Field<6, 2>;    // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
            using BEX = Field<12, 1>;    // byte Endianness exchange
            using HEX = Field<13, 1>;    // Half word Endianes exchange
            using WEX = Field<14, 1>;    // Word Endianness exchange
            using SWRQ = Field<16, 1>;    // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
        };

        // This register is used to configure the concerned channel.
        struct MDMA_C10TCR : public Register<0x520002d0> {
            using SINC = Field<0, 2>;    // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            using DINC = Field<2, 2>;    // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
            using SSIZE = Field<4, 2>;    // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
            using DSIZE = Field<6, 2>;    // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
            using SINCOS = Field<8, 2>;    // source increment offset size
            using DINCOS = Field<10, 2>;    // Destination increment offset
            using SBURST = Field<12, 3>;    // source burst transfer configuration
            using DBURST = Field<15, 3>;    // Destination burst transfer configuration
            using TLEN = Field<18, 7>;    // buffer transfer lengh
            using PKE = Field<25, 1>;    // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
            using PAM = Field<26, 2>;    // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
            using TRGM = Field<28, 2>;    // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
            using SWRM = Field<30, 1>;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
            using BWM = Field<31, 1>;    // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
        };

        // MDMA Channel x block number of data register
        struct MDMA_C10BNDTR : public Register<0x520002d4> {
            using BNDT = Field<0, 17>;    // block number of data to transfer
            using BRSUM = Field<18, 1>;    // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
            using BRDUM = Field<19, 1>;    // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
            using BRC = Field<20, 12>;    // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
        };

        // MDMA channel x source address register
        struct MDMA_C10SAR : public Register<0x520002d8> {
            using SAR = Field<0, 32>;    // source adr base
        };

        // MDMA channel x destination address register
        struct MDMA_C10DAR : public Register<0x520002dc> {
            using DAR = Field<0, 32>;    // Destination adr base
        };

        // MDMA channel x Block Repeat address Update register
        struct MDMA_C10BRUR : public Register<0x520002e0> {
            using SUV = Field<0, 16>;    // source adresse update value
            using DUV = Field<16, 16>;    // destination address update
        };

        // MDMA channel x Link Address register
        struct MDMA_C10LAR : public Register<0x520002e4> {
            using LAR = Field<0, 32>;    // Link address register
        };

        // MDMA channel x Trigger and Bus selection Register
        struct MDMA_C10TBR : public Register<0x520002e8> {
            using TSEL = Field<0, 6>;    // Trigger selection
            using SBUS = Field<16, 1>;    // Source BUS select This bit is protected and can be written only if EN is 0.
            using DBUS = Field<17, 1>;    // Destination BUS slect This bit is protected and can be written only if EN is 0.
        };

        // MDMA channel x Mask address register
        struct MDMA_C10MAR : public Register<0x520002f0> {
            using MAR = Field<0, 32>;    // Mask address
        };

        // MDMA channel x Mask Data register
        struct MDMA_C10MDR : public Register<0x520002f4> {
            using MDR = Field<0, 32>;    // Mask data
        };

        // MDMA channel x interrupt/status register
        struct MDMA_C11ISR : public RegisterReadOnly<0x52000300> {
            using TEIF11 = Field<0, 1>;    // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using CTCIF11 = Field<1, 1>;    // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
            using BRTIF11 = Field<2, 1>;    // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using BTIF11 = Field<3, 1>;    // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using TCIF11 = Field<4, 1>;    // channel x buffer transfer complete
            using CRQA11 = Field<16, 1>;    // channel x request active flag
        };

        // MDMA channel x interrupt flag clear register
        struct MDMA_C11IFCR : public RegisterWriteOnly<0x52000304> {
            using CTEIF11 = Field<0, 1>;    // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
            using CCTCIF11 = Field<1, 1>;    // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
            using CBRTIF11 = Field<2, 1>;    // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
            using CBTIF11 = Field<3, 1>;    // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
            using CLTCIF11 = Field<4, 1>;    // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
        };

        // MDMA Channel x error status register
        struct MDMA_C11ESR : public RegisterReadOnly<0x52000308> {
            using TEA = Field<0, 7>;    // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
            using TED = Field<7, 1>;    // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
            using TELD = Field<8, 1>;    // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using TEMD = Field<9, 1>;    // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using ASE = Field<10, 1>;    // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using BSE = Field<11, 1>;    // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
        };

        // This register is used to control the concerned channel.
        struct MDMA_C11CR : public Register<0x5200030c> {
            using EN = Field<0, 1>;    // channel enable
            using TEIE = Field<1, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using CTCIE = Field<2, 1>;    // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
            using BRTIE = Field<3, 1>;    // Block Repeat transfer interrupt enable This bit is set and cleared by software.
            using BTIE = Field<4, 1>;    // Block Transfer interrupt enable This bit is set and cleared by software.
            using TCIE = Field<5, 1>;    // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
            using PL = Field<6, 2>;    // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
            using BEX = Field<12, 1>;    // byte Endianness exchange
            using HEX = Field<13, 1>;    // Half word Endianes exchange
            using WEX = Field<14, 1>;    // Word Endianness exchange
            using SWRQ = Field<16, 1>;    // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
        };

        // This register is used to configure the concerned channel.
        struct MDMA_C11TCR : public Register<0x52000310> {
            using SINC = Field<0, 2>;    // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            using DINC = Field<2, 2>;    // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
            using SSIZE = Field<4, 2>;    // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
            using DSIZE = Field<6, 2>;    // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
            using SINCOS = Field<8, 2>;    // source increment offset size
            using DINCOS = Field<10, 2>;    // Destination increment offset
            using SBURST = Field<12, 3>;    // source burst transfer configuration
            using DBURST = Field<15, 3>;    // Destination burst transfer configuration
            using TLEN = Field<18, 7>;    // buffer transfer lengh
            using PKE = Field<25, 1>;    // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
            using PAM = Field<26, 2>;    // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
            using TRGM = Field<28, 2>;    // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
            using SWRM = Field<30, 1>;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
            using BWM = Field<31, 1>;    // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
        };

        // MDMA Channel x block number of data register
        struct MDMA_C11BNDTR : public Register<0x52000314> {
            using BNDT = Field<0, 17>;    // block number of data to transfer
            using BRSUM = Field<18, 1>;    // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
            using BRDUM = Field<19, 1>;    // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
            using BRC = Field<20, 12>;    // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
        };

        // MDMA channel x source address register
        struct MDMA_C11SAR : public Register<0x52000318> {
            using SAR = Field<0, 32>;    // source adr base
        };

        // MDMA channel x destination address register
        struct MDMA_C11DAR : public Register<0x5200031c> {
            using DAR = Field<0, 32>;    // Destination adr base
        };

        // MDMA channel x Block Repeat address Update register
        struct MDMA_C11BRUR : public Register<0x52000320> {
            using SUV = Field<0, 16>;    // source adresse update value
            using DUV = Field<16, 16>;    // destination address update
        };

        // MDMA channel x Link Address register
        struct MDMA_C11LAR : public Register<0x52000324> {
            using LAR = Field<0, 32>;    // Link address register
        };

        // MDMA channel x Trigger and Bus selection Register
        struct MDMA_C11TBR : public Register<0x52000328> {
            using TSEL = Field<0, 6>;    // Trigger selection
            using SBUS = Field<16, 1>;    // Source BUS select This bit is protected and can be written only if EN is 0.
            using DBUS = Field<17, 1>;    // Destination BUS slect This bit is protected and can be written only if EN is 0.
        };

        // MDMA channel x Mask address register
        struct MDMA_C11MAR : public Register<0x52000330> {
            using MAR = Field<0, 32>;    // Mask address
        };

        // MDMA channel x Mask Data register
        struct MDMA_C11MDR : public Register<0x52000334> {
            using MDR = Field<0, 32>;    // Mask data
        };

        // MDMA channel x interrupt/status register
        struct MDMA_C12ISR : public RegisterReadOnly<0x52000340> {
            using TEIF12 = Field<0, 1>;    // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using CTCIF12 = Field<1, 1>;    // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
            using BRTIF12 = Field<2, 1>;    // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using BTIF12 = Field<3, 1>;    // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using TCIF12 = Field<4, 1>;    // channel x buffer transfer complete
            using CRQA12 = Field<16, 1>;    // channel x request active flag
        };

        // MDMA channel x interrupt flag clear register
        struct MDMA_C12IFCR : public RegisterWriteOnly<0x52000344> {
            using CTEIF12 = Field<0, 1>;    // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
            using CCTCIF12 = Field<1, 1>;    // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
            using CBRTIF12 = Field<2, 1>;    // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
            using CBTIF12 = Field<3, 1>;    // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
            using CLTCIF12 = Field<4, 1>;    // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
        };

        // MDMA Channel x error status register
        struct MDMA_C12ESR : public RegisterReadOnly<0x52000348> {
            using TEA = Field<0, 7>;    // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
            using TED = Field<7, 1>;    // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
            using TELD = Field<8, 1>;    // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using TEMD = Field<9, 1>;    // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using ASE = Field<10, 1>;    // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using BSE = Field<11, 1>;    // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
        };

        // This register is used to control the concerned channel.
        struct MDMA_C12CR : public Register<0x5200034c> {
            using EN = Field<0, 1>;    // channel enable
            using TEIE = Field<1, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using CTCIE = Field<2, 1>;    // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
            using BRTIE = Field<3, 1>;    // Block Repeat transfer interrupt enable This bit is set and cleared by software.
            using BTIE = Field<4, 1>;    // Block Transfer interrupt enable This bit is set and cleared by software.
            using TCIE = Field<5, 1>;    // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
            using PL = Field<6, 2>;    // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
            using BEX = Field<12, 1>;    // byte Endianness exchange
            using HEX = Field<13, 1>;    // Half word Endianes exchange
            using WEX = Field<14, 1>;    // Word Endianness exchange
            using SWRQ = Field<16, 1>;    // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
        };

        // This register is used to configure the concerned channel.
        struct MDMA_C12TCR : public Register<0x52000350> {
            using SINC = Field<0, 2>;    // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            using DINC = Field<2, 2>;    // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
            using SSIZE = Field<4, 2>;    // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
            using DSIZE = Field<6, 2>;    // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
            using SINCOS = Field<8, 2>;    // source increment offset size
            using DINCOS = Field<10, 2>;    // Destination increment offset
            using SBURST = Field<12, 3>;    // source burst transfer configuration
            using DBURST = Field<15, 3>;    // Destination burst transfer configuration
            using TLEN = Field<18, 7>;    // buffer transfer lengh
            using PKE = Field<25, 1>;    // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
            using PAM = Field<26, 2>;    // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
            using TRGM = Field<28, 2>;    // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
            using SWRM = Field<30, 1>;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
            using BWM = Field<31, 1>;    // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
        };

        // MDMA Channel x block number of data register
        struct MDMA_C12BNDTR : public Register<0x52000354> {
            using BNDT = Field<0, 17>;    // block number of data to transfer
            using BRSUM = Field<18, 1>;    // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
            using BRDUM = Field<19, 1>;    // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
            using BRC = Field<20, 12>;    // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
        };

        // MDMA channel x source address register
        struct MDMA_C12SAR : public Register<0x52000358> {
            using SAR = Field<0, 32>;    // source adr base
        };

        // MDMA channel x destination address register
        struct MDMA_C12DAR : public Register<0x5200035c> {
            using DAR = Field<0, 32>;    // Destination adr base
        };

        // MDMA channel x Block Repeat address Update register
        struct MDMA_C12BRUR : public Register<0x52000360> {
            using SUV = Field<0, 16>;    // source adresse update value
            using DUV = Field<16, 16>;    // destination address update
        };

        // MDMA channel x Link Address register
        struct MDMA_C12LAR : public Register<0x52000364> {
            using LAR = Field<0, 32>;    // Link address register
        };

        // MDMA channel x Trigger and Bus selection Register
        struct MDMA_C12TBR : public Register<0x52000368> {
            using TSEL = Field<0, 6>;    // Trigger selection
            using SBUS = Field<16, 1>;    // Source BUS select This bit is protected and can be written only if EN is 0.
            using DBUS = Field<17, 1>;    // Destination BUS slect This bit is protected and can be written only if EN is 0.
        };

        // MDMA channel x Mask address register
        struct MDMA_C12MAR : public Register<0x52000370> {
            using MAR = Field<0, 32>;    // Mask address
        };

        // MDMA channel x Mask Data register
        struct MDMA_C12MDR : public Register<0x52000374> {
            using MDR = Field<0, 32>;    // Mask data
        };

        // MDMA channel x interrupt/status register
        struct MDMA_C13ISR : public RegisterReadOnly<0x52000380> {
            using TEIF13 = Field<0, 1>;    // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using CTCIF13 = Field<1, 1>;    // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
            using BRTIF13 = Field<2, 1>;    // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using BTIF13 = Field<3, 1>;    // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using TCIF13 = Field<4, 1>;    // channel x buffer transfer complete
            using CRQA13 = Field<16, 1>;    // channel x request active flag
        };

        // MDMA channel x interrupt flag clear register
        struct MDMA_C13IFCR : public RegisterWriteOnly<0x52000384> {
            using CTEIF13 = Field<0, 1>;    // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
            using CCTCIF13 = Field<1, 1>;    // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
            using CBRTIF13 = Field<2, 1>;    // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
            using CBTIF13 = Field<3, 1>;    // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
            using CLTCIF13 = Field<4, 1>;    // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
        };

        // MDMA Channel x error status register
        struct MDMA_C13ESR : public RegisterReadOnly<0x52000388> {
            using TEA = Field<0, 7>;    // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
            using TED = Field<7, 1>;    // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
            using TELD = Field<8, 1>;    // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using TEMD = Field<9, 1>;    // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using ASE = Field<10, 1>;    // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using BSE = Field<11, 1>;    // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
        };

        // This register is used to control the concerned channel.
        struct MDMA_C13CR : public Register<0x5200038c> {
            using EN = Field<0, 1>;    // channel enable
            using TEIE = Field<1, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using CTCIE = Field<2, 1>;    // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
            using BRTIE = Field<3, 1>;    // Block Repeat transfer interrupt enable This bit is set and cleared by software.
            using BTIE = Field<4, 1>;    // Block Transfer interrupt enable This bit is set and cleared by software.
            using TCIE = Field<5, 1>;    // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
            using PL = Field<6, 2>;    // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
            using BEX = Field<12, 1>;    // byte Endianness exchange
            using HEX = Field<13, 1>;    // Half word Endianes exchange
            using WEX = Field<14, 1>;    // Word Endianness exchange
            using SWRQ = Field<16, 1>;    // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
        };

        // This register is used to configure the concerned channel.
        struct MDMA_C13TCR : public Register<0x52000390> {
            using SINC = Field<0, 2>;    // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            using DINC = Field<2, 2>;    // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
            using SSIZE = Field<4, 2>;    // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
            using DSIZE = Field<6, 2>;    // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
            using SINCOS = Field<8, 2>;    // source increment offset size
            using DINCOS = Field<10, 2>;    // Destination increment offset
            using SBURST = Field<12, 3>;    // source burst transfer configuration
            using DBURST = Field<15, 3>;    // Destination burst transfer configuration
            using TLEN = Field<18, 7>;    // buffer transfer lengh
            using PKE = Field<25, 1>;    // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
            using PAM = Field<26, 2>;    // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
            using TRGM = Field<28, 2>;    // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
            using SWRM = Field<30, 1>;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
            using BWM = Field<31, 1>;    // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
        };

        // MDMA Channel x block number of data register
        struct MDMA_C13BNDTR : public Register<0x52000394> {
            using BNDT = Field<0, 17>;    // block number of data to transfer
            using BRSUM = Field<18, 1>;    // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
            using BRDUM = Field<19, 1>;    // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
            using BRC = Field<20, 12>;    // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
        };

        // MDMA channel x source address register
        struct MDMA_C13SAR : public Register<0x52000398> {
            using SAR = Field<0, 32>;    // source adr base
        };

        // MDMA channel x destination address register
        struct MDMA_C13DAR : public Register<0x5200039c> {
            using DAR = Field<0, 32>;    // Destination adr base
        };

        // MDMA channel x Block Repeat address Update register
        struct MDMA_C13BRUR : public Register<0x520003a0> {
            using SUV = Field<0, 16>;    // source adresse update value
            using DUV = Field<16, 16>;    // destination address update
        };

        // MDMA channel x Link Address register
        struct MDMA_C13LAR : public Register<0x520003a4> {
            using LAR = Field<0, 32>;    // Link address register
        };

        // MDMA channel x Trigger and Bus selection Register
        struct MDMA_C13TBR : public Register<0x520003a8> {
            using TSEL = Field<0, 6>;    // Trigger selection
            using SBUS = Field<16, 1>;    // Source BUS select This bit is protected and can be written only if EN is 0.
            using DBUS = Field<17, 1>;    // Destination BUS slect This bit is protected and can be written only if EN is 0.
        };

        // MDMA channel x Mask address register
        struct MDMA_C13MAR : public Register<0x520003b0> {
            using MAR = Field<0, 32>;    // Mask address
        };

        // MDMA channel x Mask Data register
        struct MDMA_C13MDR : public Register<0x520003b4> {
            using MDR = Field<0, 32>;    // Mask data
        };

        // MDMA channel x interrupt/status register
        struct MDMA_C14ISR : public RegisterReadOnly<0x520003c0> {
            using TEIF14 = Field<0, 1>;    // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using CTCIF14 = Field<1, 1>;    // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
            using BRTIF14 = Field<2, 1>;    // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using BTIF14 = Field<3, 1>;    // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using TCIF14 = Field<4, 1>;    // channel x buffer transfer complete
            using CRQA14 = Field<16, 1>;    // channel x request active flag
        };

        // MDMA channel x interrupt flag clear register
        struct MDMA_C14IFCR : public RegisterWriteOnly<0x520003c4> {
            using CTEIF14 = Field<0, 1>;    // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
            using CCTCIF14 = Field<1, 1>;    // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
            using CBRTIF14 = Field<2, 1>;    // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
            using CBTIF14 = Field<3, 1>;    // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
            using CLTCIF14 = Field<4, 1>;    // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
        };

        // MDMA Channel x error status register
        struct MDMA_C14ESR : public RegisterReadOnly<0x520003c8> {
            using TEA = Field<0, 7>;    // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
            using TED = Field<7, 1>;    // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
            using TELD = Field<8, 1>;    // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using TEMD = Field<9, 1>;    // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using ASE = Field<10, 1>;    // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using BSE = Field<11, 1>;    // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
        };

        // This register is used to control the concerned channel.
        struct MDMA_C14CR : public Register<0x520003cc> {
            using EN = Field<0, 1>;    // channel enable
            using TEIE = Field<1, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using CTCIE = Field<2, 1>;    // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
            using BRTIE = Field<3, 1>;    // Block Repeat transfer interrupt enable This bit is set and cleared by software.
            using BTIE = Field<4, 1>;    // Block Transfer interrupt enable This bit is set and cleared by software.
            using TCIE = Field<5, 1>;    // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
            using PL = Field<6, 2>;    // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
            using BEX = Field<12, 1>;    // byte Endianness exchange
            using HEX = Field<13, 1>;    // Half word Endianes exchange
            using WEX = Field<14, 1>;    // Word Endianness exchange
            using SWRQ = Field<16, 1>;    // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
        };

        // This register is used to configure the concerned channel.
        struct MDMA_C14TCR : public Register<0x520003d0> {
            using SINC = Field<0, 2>;    // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            using DINC = Field<2, 2>;    // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
            using SSIZE = Field<4, 2>;    // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
            using DSIZE = Field<6, 2>;    // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
            using SINCOS = Field<8, 2>;    // source increment offset size
            using DINCOS = Field<10, 2>;    // Destination increment offset
            using SBURST = Field<12, 3>;    // source burst transfer configuration
            using DBURST = Field<15, 3>;    // Destination burst transfer configuration
            using TLEN = Field<18, 7>;    // buffer transfer lengh
            using PKE = Field<25, 1>;    // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
            using PAM = Field<26, 2>;    // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
            using TRGM = Field<28, 2>;    // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
            using SWRM = Field<30, 1>;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
            using BWM = Field<31, 1>;    // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
        };

        // MDMA Channel x block number of data register
        struct MDMA_C14BNDTR : public Register<0x520003d4> {
            using BNDT = Field<0, 17>;    // block number of data to transfer
            using BRSUM = Field<18, 1>;    // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
            using BRDUM = Field<19, 1>;    // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
            using BRC = Field<20, 12>;    // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
        };

        // MDMA channel x source address register
        struct MDMA_C14SAR : public Register<0x520003d8> {
            using SAR = Field<0, 32>;    // source adr base
        };

        // MDMA channel x destination address register
        struct MDMA_C14DAR : public Register<0x520003dc> {
            using DAR = Field<0, 32>;    // Destination adr base
        };

        // MDMA channel x Block Repeat address Update register
        struct MDMA_C14BRUR : public Register<0x520003e0> {
            using SUV = Field<0, 16>;    // source adresse update value
            using DUV = Field<16, 16>;    // destination address update
        };

        // MDMA channel x Link Address register
        struct MDMA_C14LAR : public Register<0x520003e4> {
            using LAR = Field<0, 32>;    // Link address register
        };

        // MDMA channel x Trigger and Bus selection Register
        struct MDMA_C14TBR : public Register<0x520003e8> {
            using TSEL = Field<0, 6>;    // Trigger selection
            using SBUS = Field<16, 1>;    // Source BUS select This bit is protected and can be written only if EN is 0.
            using DBUS = Field<17, 1>;    // Destination BUS slect This bit is protected and can be written only if EN is 0.
        };

        // MDMA channel x Mask address register
        struct MDMA_C14MAR : public Register<0x520003f0> {
            using MAR = Field<0, 32>;    // Mask address
        };

        // MDMA channel x Mask Data register
        struct MDMA_C14MDR : public Register<0x520003f4> {
            using MDR = Field<0, 32>;    // Mask data
        };

        // MDMA channel x interrupt/status register
        struct MDMA_C15ISR : public RegisterReadOnly<0x52000400> {
            using TEIF15 = Field<0, 1>;    // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using CTCIF15 = Field<1, 1>;    // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
            using BRTIF15 = Field<2, 1>;    // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using BTIF15 = Field<3, 1>;    // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
            using TCIF15 = Field<4, 1>;    // channel x buffer transfer complete
            using CRQA15 = Field<16, 1>;    // channel x request active flag
        };

        // MDMA channel x interrupt flag clear register
        struct MDMA_C15IFCR : public RegisterWriteOnly<0x52000404> {
            using CTEIF15 = Field<0, 1>;    // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
            using CCTCIF15 = Field<1, 1>;    // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
            using CBRTIF15 = Field<2, 1>;    // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
            using CBTIF15 = Field<3, 1>;    // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
            using CLTCIF15 = Field<4, 1>;    // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
        };

        // MDMA Channel x error status register
        struct MDMA_C15ESR : public RegisterReadOnly<0x52000408> {
            using TEA = Field<0, 7>;    // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
            using TED = Field<7, 1>;    // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
            using TELD = Field<8, 1>;    // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using TEMD = Field<9, 1>;    // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using ASE = Field<10, 1>;    // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
            using BSE = Field<11, 1>;    // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
        };

        // This register is used to control the concerned channel.
        struct MDMA_C15CR : public Register<0x5200040c> {
            using EN = Field<0, 1>;    // channel enable
            using TEIE = Field<1, 1>;    // Transfer error interrupt enable This bit is set and cleared by software.
            using CTCIE = Field<2, 1>;    // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
            using BRTIE = Field<3, 1>;    // Block Repeat transfer interrupt enable This bit is set and cleared by software.
            using BTIE = Field<4, 1>;    // Block Transfer interrupt enable This bit is set and cleared by software.
            using TCIE = Field<5, 1>;    // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
            using PL = Field<6, 2>;    // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
            using BEX = Field<12, 1>;    // byte Endianness exchange
            using HEX = Field<13, 1>;    // Half word Endianes exchange
            using WEX = Field<14, 1>;    // Word Endianness exchange
            using SWRQ = Field<16, 1>;    // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
        };

        // This register is used to configure the concerned channel.
        struct MDMA_C15TCR : public Register<0x52000410> {
            using SINC = Field<0, 2>;    // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            using DINC = Field<2, 2>;    // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
            using SSIZE = Field<4, 2>;    // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
            using DSIZE = Field<6, 2>;    // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
            using SINCOS = Field<8, 2>;    // source increment offset size
            using DINCOS = Field<10, 2>;    // Destination increment offset
            using SBURST = Field<12, 3>;    // source burst transfer configuration
            using DBURST = Field<15, 3>;    // Destination burst transfer configuration
            using TLEN = Field<18, 7>;    // buffer transfer lengh
            using PKE = Field<25, 1>;    // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
            using PAM = Field<26, 2>;    // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
            using TRGM = Field<28, 2>;    // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
            using SWRM = Field<30, 1>;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
            using BWM = Field<31, 1>;    // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
        };

        // MDMA Channel x block number of data register
        struct MDMA_C15BNDTR : public Register<0x52000414> {
            using BNDT = Field<0, 17>;    // block number of data to transfer
            using BRSUM = Field<18, 1>;    // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
            using BRDUM = Field<19, 1>;    // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
            using BRC = Field<20, 12>;    // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
        };

        // MDMA channel x source address register
        struct MDMA_C15SAR : public Register<0x52000418> {
            using SAR = Field<0, 32>;    // source adr base
        };

        // MDMA channel x destination address register
        struct MDMA_C15DAR : public Register<0x5200041c> {
            using DAR = Field<0, 32>;    // Destination adr base
        };

        // MDMA channel x Block Repeat address Update register
        struct MDMA_C15BRUR : public Register<0x52000420> {
            using SUV = Field<0, 16>;    // source adresse update value
            using DUV = Field<16, 16>;    // destination address update
        };

        // MDMA channel x Link Address register
        struct MDMA_C15LAR : public Register<0x52000424> {
            using LAR = Field<0, 32>;    // Link address register
        };

        // MDMA channel x Trigger and Bus selection Register
        struct MDMA_C15TBR : public Register<0x52000428> {
            using TSEL = Field<0, 6>;    // Trigger selection
            using SBUS = Field<16, 1>;    // Source BUS select This bit is protected and can be written only if EN is 0.
            using DBUS = Field<17, 1>;    // Destination BUS slect This bit is protected and can be written only if EN is 0.
        };

        // MDMA channel x Mask address register
        struct MDMA_C15MAR : public Register<0x52000430> {
            using MAR = Field<0, 32>;    // Mask address
        };

        // MDMA channel x Mask Data register
        struct MDMA_C15MDR : public Register<0x52000434> {
            using MDR = Field<0, 32>;    // Mask data
        };

    };

    // QUADSPI
    struct QUADSPI {
        // QUADSPI control register
        struct CR : public Register<0x52005000> {
            using EN = Field<0, 1>;    // Enable Enable the QUADSPI.
            using ABORT = Field<1, 1>;    // Abort request This bit aborts the on-going command sequence. It is automatically reset once the abort is complete. This bit stops the current transfer. In polling mode or memory-mapped mode, this bit also reset the APM bit or the DM bit.
            using DMAEN = Field<2, 1>;    // DMA enable In indirect mode, DMA can be used to input or output data via the QUADSPI_DR register. DMA transfers are initiated when the FIFO threshold flag, FTF, is set.
            using TCEN = Field<3, 1>;    // Timeout counter enable This bit is valid only when memory-mapped mode (FMODE = 11) is selected. Activating this bit causes the chip select (nCS) to be released (and thus reduces consumption) if there has not been an access after a certain amount of time, where this time is defined by TIMEOUT[15:0] (QUADSPI_LPTR). Enable the timeout counter. By default, the QUADSPI never stops its prefetch operation, keeping the previous read operation active with nCS maintained low, even if no access to the Flash memory occurs for a long time. Since Flash memories tend to consume more when nCS is held low, the application might want to activate the timeout counter (TCEN = 1, QUADSPI_CR[3]) so that nCS is released after a period of TIMEOUT[15:0] (QUADSPI_LPTR) cycles have elapsed without an access since when the FIFO becomes full with prefetch data. This bit can be modified only when BUSY = 0.
            using SSHIFT = Field<4, 1>;    // Sample shift By default, the QUADSPI samples data 1/2 of a CLK cycle after the data is driven by the Flash memory. This bit allows the data is to be sampled later in order to account for external signal delays. Firmware must assure that SSHIFT = 0 when in DDR mode (when DDRM = 1). This field can be modified only when BUSY = 0.
            using DFM = Field<6, 1>;    // Dual-flash mode This bit activates dual-flash mode, where two external Flash memories are used simultaneously to double throughput and capacity. This bit can be modified only when BUSY = 0.
            using FSEL = Field<7, 1>;    // Flash memory selection This bit selects the Flash memory to be addressed in single flash mode (when DFM = 0). This bit can be modified only when BUSY = 0. This bit is ignored when DFM = 1.
            using FTHRES = Field<8, 5>;    // FIFO threshold level Defines, in indirect mode, the threshold number of bytes in the FIFO that will cause the FIFO threshold flag (FTF, QUADSPI_SR[2]) to be set. In indirect write mode (FMODE = 00): ... In indirect read mode (FMODE = 01): ... If DMAEN = 1, then the DMA controller for the corresponding channel must be disabled before changing the FTHRES value.
            using TEIE = Field<16, 1>;    // Transfer error interrupt enable This bit enables the transfer error interrupt.
            using TCIE = Field<17, 1>;    // Transfer complete interrupt enable This bit enables the transfer complete interrupt.
            using FTIE = Field<18, 1>;    // FIFO threshold interrupt enable This bit enables the FIFO threshold interrupt.
            using SMIE = Field<19, 1>;    // Status match interrupt enable This bit enables the status match interrupt.
            using TOIE = Field<20, 1>;    // TimeOut interrupt enable This bit enables the TimeOut interrupt.
            using APMS = Field<22, 1>;    // Automatic poll mode stop This bit determines if automatic polling is stopped after a match. This bit can be modified only when BUSY = 0.
            using PMM = Field<23, 1>;    // Polling match mode This bit indicates which method should be used for determining a match during automatic polling mode. This bit can be modified only when BUSY = 0.
            using PRESCALER = Field<24, 8>;    // clock prescaler
        };

        // QUADSPI device configuration register
        struct DCR : public Register<0x52005004> {
            using CKMODE = Field<0, 1>;    // indicates the level that clk takes between command
            using CSHT = Field<8, 3>;    // Chip select high time CSHT+1 defines the minimum number of CLK cycles which the chip select (nCS) must remain high between commands issued to the Flash memory. ... This field can be modified only when BUSY = 0.
            using FSIZE = Field<16, 5>;    // Flash memory size This field defines the size of external memory using the following formula: Number of bytes in Flash memory = 2[FSIZE+1] FSIZE+1 is effectively the number of address bits required to address the Flash memory. The Flash memory capacity can be up to 4GB (addressed using 32 bits) in indirect mode, but the addressable space in memory-mapped mode is limited to 256MB. If DFM = 1, FSIZE indicates the total capacity of the two Flash memories together. This field can be modified only when BUSY = 0.
        };

        // QUADSPI status register
        struct SR : public RegisterReadOnly<0x52005008> {
            using TEF = Field<0, 1>;    // Transfer error flag This bit is set in indirect mode when an invalid address is being accessed in indirect mode. It is cleared by writing 1 to CTEF.
            using TCF = Field<1, 1>;    // Transfer complete flag This bit is set in indirect mode when the programmed number of data has been transferred or in any mode when the transfer has been aborted.It is cleared by writing 1 to CTCF.
            using FTF = Field<2, 1>;    // FIFO threshold flag In indirect mode, this bit is set when the FIFO threshold has been reached, or if there is any data left in the FIFO after reads from the Flash memory are complete. It is cleared automatically as soon as threshold condition is no longer true. In automatic polling mode this bit is set every time the status register is read, and the bit is cleared when the data register is read.
            using SMF = Field<3, 1>;    // Status match flag This bit is set in automatic polling mode when the unmasked received data matches the corresponding bits in the match register (QUADSPI_PSMAR). It is cleared by writing 1 to CSMF.
            using TOF = Field<4, 1>;    // Timeout flag This bit is set when timeout occurs. It is cleared by writing 1 to CTOF.
            using BUSY = Field<5, 1>;    // Busy This bit is set when an operation is on going. This bit clears automatically when the operation with the Flash memory is finished and the FIFO is empty.
            using FLEVEL = Field<8, 6>;    // FIFO level This field gives the number of valid bytes which are being held in the FIFO. FLEVEL = 0 when the FIFO is empty, and 16 when it is full. In memory-mapped mode and in automatic status polling mode, FLEVEL is zero.
        };

        // QUADSPI flag clear register
        struct FCR : public Register<0x5200500c> {
            using CTEF = Field<0, 1>;    // Clear transfer error flag Writing 1 clears the TEF flag in the QUADSPI_SR register
            using CTCF = Field<1, 1>;    // Clear transfer complete flag Writing 1 clears the TCF flag in the QUADSPI_SR register
            using CSMF = Field<3, 1>;    // Clear status match flag Writing 1 clears the SMF flag in the QUADSPI_SR register
            using CTOF = Field<4, 1>;    // Clear timeout flag Writing 1 clears the TOF flag in the QUADSPI_SR register
        };

        // QUADSPI data length register
        struct DLR : public Register<0x52005010> {
            using DL = Field<0, 32>;    // Data length Number of data to be retrieved (value+1) in indirect and status-polling modes. A value no greater than 3 (indicating 4 bytes) should be used for status-polling mode. All 1s in indirect mode means undefined length, where QUADSPI will continue until the end of memory, as defined by FSIZE. 0x0000_0000: 1 byte is to be transferred 0x0000_0001: 2 bytes are to be transferred 0x0000_0002: 3 bytes are to be transferred 0x0000_0003: 4 bytes are to be transferred ... 0xFFFF_FFFD: 4,294,967,294 (4G-2) bytes are to be transferred 0xFFFF_FFFE: 4,294,967,295 (4G-1) bytes are to be transferred 0xFFFF_FFFF: undefined length -- all bytes until the end of Flash memory (as defined by FSIZE) are to be transferred. Continue reading indefinitely if FSIZE = 0x1F. DL[0] is stuck at 1 in dual-flash mode (DFM = 1) even when 0 is written to this bit, thus assuring that each access transfers an even number of bytes. This field has no effect when in memory-mapped mode (FMODE = 10). This field can be written only when BUSY = 0.
        };

        // QUADSPI communication configuration register
        struct CCR : public Register<0x52005014> {
            using INSTRUCTION = Field<0, 8>;    // Instruction Instruction to be send to the external SPI device. This field can be written only when BUSY = 0.
            using IMODE = Field<8, 2>;    // Instruction mode This field defines the instruction phase mode of operation: This field can be written only when BUSY = 0.
            using ADMODE = Field<10, 2>;    // Address mode This field defines the address phase mode of operation: This field can be written only when BUSY = 0.
            using ADSIZE = Field<12, 2>;    // Address size This bit defines address size: This field can be written only when BUSY = 0.
            using ABMODE = Field<14, 2>;    // Alternate bytes mode This field defines the alternate-bytes phase mode of operation: This field can be written only when BUSY = 0.
            using ABSIZE = Field<16, 2>;    // Alternate bytes size This bit defines alternate bytes size: This field can be written only when BUSY = 0.
            using DCYC = Field<18, 5>;    // Number of dummy cycles This field defines the duration of the dummy phase. In both SDR and DDR modes, it specifies a number of CLK cycles (0-31). This field can be written only when BUSY = 0.
            using DMODE = Field<24, 2>;    // Data mode This field defines the data phases mode of operation: This field also determines the dummy phase mode of operation. This field can be written only when BUSY = 0.
            using FMODE = Field<26, 2>;    // Functional mode This field defines the QUADSPI functional mode of operation. If DMAEN = 1 already, then the DMA controller for the corresponding channel must be disabled before changing the FMODE value. This field can be written only when BUSY = 0.
            using SIOO = Field<28, 1>;    // Send instruction only once mode See Section15.3.11: Sending the instruction only once on page13. This bit has no effect when IMODE = 00. This field can be written only when BUSY = 0.
            using DHHC = Field<30, 1>;    // DDR hold Delay the data output by 1/4 of the QUADSPI output clock cycle in DDR mode: This feature is only active in DDR mode. This field can be written only when BUSY = 0.
            using DDRM = Field<31, 1>;    // Double data rate mode This bit sets the DDR mode for the address, alternate byte and data phase: This field can be written only when BUSY = 0.
        };

        // QUADSPI address register
        struct AR : public Register<0x52005018> {
            using ADDRESS = Field<0, 32>;    // [31 0]: Address Address to be send to the external Flash memory Writes to this field are ignored when BUSY = 0 or when FMODE = 11 (memory-mapped mode). In dual flash mode, ADDRESS[0] is automatically stuck to 0 as the address should always be even
        };

        // QUADSPI alternate bytes registers
        struct ABR : public Register<0x5200501c> {
            using ALTERNATE = Field<0, 32>;    // Alternate Bytes Optional data to be send to the external SPI device right after the address. This field can be written only when BUSY = 0.
        };

        // QUADSPI data register
        struct DR : public Register<0x52005020> {
            using DATA = Field<0, 32>;    // Data Data to be sent/received to/from the external SPI device. In indirect write mode, data written to this register is stored on the FIFO before it is sent to the Flash memory during the data phase. If the FIFO is too full, a write operation is stalled until the FIFO has enough space to accept the amount of data being written. In indirect read mode, reading this register gives (via the FIFO) the data which was received from the Flash memory. If the FIFO does not have as many bytes as requested by the read operation and if BUSY=1, the read operation is stalled until enough data is present or until the transfer is complete, whichever happens first. In automatic polling mode, this register contains the last data read from the Flash memory (without masking). Word, halfword, and byte accesses to this register are supported. In indirect write mode, a byte write adds 1 byte to the FIFO, a halfword write 2, and a word write 4. Similarly, in indirect read mode, a byte read removes 1 byte from the FIFO, a halfword read 2, and a word read 4. Accesses in indirect mode must be aligned to the bottom of this register: a byte read must read DATA[7:0] and a halfword read must read DATA[15:0].
        };

        // QUADSPI polling status mask register
        struct PSMKR : public Register<0x52005024> {
            using MASK = Field<0, 32>;    // Status mask Mask to be applied to the status bytes received in polling mode. For bit n: This field can be written only when BUSY = 0.
        };

        // QUADSPI polling status match register
        struct PSMAR : public Register<0x52005028> {
            using MATCH = Field<0, 32>;    // Status match Value to be compared with the masked status register to get a match. This field can be written only when BUSY = 0.
        };

        // QUADSPI polling interval register
        struct PIR : public Register<0x5200502c> {
            using INTERVAL = Field<0, 16>;    // Polling interval Number of CLK cycles between to read during automatic polling phases. This field can be written only when BUSY = 0.
        };

        // QUADSPI low-power timeout register
        struct LPTR : public Register<0x52005030> {
            using TIMEOUT = Field<0, 16>;    // Timeout period After each access in memory-mapped mode, the QUADSPI prefetches the subsequent bytes and holds these bytes in the FIFO. This field indicates how many CLK cycles the QUADSPI waits after the FIFO becomes full until it raises nCS, putting the Flash memory in a lower-consumption state. This field can be written only when BUSY = 0.
        };

    };

    // RNG
    struct RNG {
        // RNG control register
        struct CR : public Register<0x48021800> {
            using RNGEN = Field<2, 1>;    // Random number generator enable
            using IE = Field<3, 1>;    // Interrupt enable
            using CED = Field<5, 1>;    // Clock error detection Note: The clock error detection can be used only when ck_rc48 or ck_pll1_q (ck_pll1_q = 48MHz) source is selected otherwise, CED bit must be equal to 1. The clock error detection cannot be enabled nor disabled on the fly when RNG peripheral is enabled, to enable or disable CED the RNG must be disabled.
        };

        // RNG status register
        struct SR : public Register<0x48021804> {
            using DRDY = Field<0, 1>;    // Data ready Note: If IE=1 in RNG_CR, an interrupt is generated when DRDY=1. It can rise when the peripheral is disabled. When the output buffer becomes empty (after reading RNG_DR), this bit returns to 0 until a new random value is generated.
            using CECS = Field<1, 1>;    // Clock error current status Note: This bit is meaningless if CED (Clock error detection) bit in RNG_CR is equal to 1.
            using SECS = Field<2, 1>;    // Seed error current status ** More than 64 consecutive bits at the same value (0 or 1) ** More than 32 consecutive alternances of 0 and 1 (0101010101...01)
            using CEIS = Field<5, 1>;    // Clock error interrupt status This bit is set at the same time as CECS. It is cleared by writing it to 0. An interrupt is pending if IE = 1 in the RNG_CR register. Note: This bit is meaningless if CED (Clock error detection) bit in RNG_CR is equal to 1.
            using SEIS = Field<6, 1>;    // Seed error interrupt status This bit is set at the same time as SECS. It is cleared by writing it to 0. ** More than 64 consecutive bits at the same value (0 or 1) ** More than 32 consecutive alternances of 0 and 1 (0101010101...01) An interrupt is pending if IE = 1 in the RNG_CR register.
        };

        // The RNG_DR register is a read-only register that delivers a 32-bit random value when read. The content of this register is valid when DRDY= 1, even if RNGEN=0.
        struct DR : public RegisterReadOnly<0x48021808> {
            using RNDATA = Field<0, 32>;    // Random data 32-bit random data which are valid when DRDY=1.
        };

    };

    // RTC
    struct RTC {
        // The RTC_TR is the calendar time shadow register. This register must be written in initialization mode only. Refer to Calendar initialization and configuration on page9 and Reading the calendar on page10.This register is write protected. The write access procedure is described in RTC register write protection on page9.
        struct RTC_TR : public Register<0x58004000> {
            using SU = Field<0, 4>;    // Second units in BCD format
            using ST = Field<4, 3>;    // Second tens in BCD format
            using MNU = Field<8, 4>;    // Minute units in BCD format
            using MNT = Field<12, 3>;    // Minute tens in BCD format
            using HU = Field<16, 4>;    // Hour units in BCD format
            using HT = Field<20, 2>;    // Hour tens in BCD format
            using PM = Field<22, 1>;    // AM/PM notation
        };

        // The RTC_DR is the calendar date shadow register. This register must be written in initialization mode only. Refer to Calendar initialization and configuration on page9 and Reading the calendar on page10.This register is write protected. The write access procedure is described in RTC register write protection on page9.
        struct RTC_DR : public Register<0x58004004> {
            using DU = Field<0, 4>;    // Date units in BCD format
            using DT = Field<4, 2>;    // Date tens in BCD format
            using MU = Field<8, 4>;    // Month units in BCD format
            using MT = Field<12, 1>;    // Month tens in BCD format
            using WDU = Field<13, 3>;    // Week day units
            using YU = Field<16, 4>;    // Year units in BCD format
            using YT = Field<20, 4>;    // Year tens in BCD format
        };

        // RTC control register
        struct RTC_CR : public Register<0x58004008> {
            using WUCKSEL = Field<0, 3>;    // Wakeup clock selection
            using TSEDGE = Field<3, 1>;    // Time-stamp event active edge TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting.
            using REFCKON = Field<4, 1>;    // RTC_REFIN reference clock detection enable (50 or 60Hz) Note: PREDIV_S must be 0x00FF.
            using BYPSHAD = Field<5, 1>;    // Bypass the shadow registers Note: If the frequency of the APB clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1.
            using FMT = Field<6, 1>;    // Hour format
            using ALRAE = Field<8, 1>;    // Alarm A enable
            using ALRBE = Field<9, 1>;    // Alarm B enable
            using WUTE = Field<10, 1>;    // Wakeup timer enable
            using TSE = Field<11, 1>;    // timestamp enable
            using ALRAIE = Field<12, 1>;    // Alarm A interrupt enable
            using ALRBIE = Field<13, 1>;    // Alarm B interrupt enable
            using WUTIE = Field<14, 1>;    // Wakeup timer interrupt enable
            using TSIE = Field<15, 1>;    // Time-stamp interrupt enable
            using ADD1H = Field<16, 1>;    // Add 1 hour (summer time change) When this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0.
            using SUB1H = Field<17, 1>;    // Subtract 1 hour (winter time change) When this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0. Setting this bit has no effect when current hour is 0.
            using BKP = Field<18, 1>;    // Backup This bit can be written by the user to memorize whether the daylight saving time change has been performed or not.
            using COSEL = Field<19, 1>;    // Calibration output selection When COE=1, this bit selects which signal is output on RTC_CALIB. These frequencies are valid for RTCCLK at 32.768 kHz and prescalers at their default values (PREDIV_A=127 and PREDIV_S=255). Refer to Section24.3.15: Calibration clock output
            using POL = Field<20, 1>;    // Output polarity This bit is used to configure the polarity of RTC_ALARM output
            using OSEL = Field<21, 2>;    // Output selection These bits are used to select the flag to be routed to RTC_ALARM output
            using COE = Field<23, 1>;    // Calibration output enable This bit enables the RTC_CALIB output
            using ITSE = Field<24, 1>;    // timestamp on internal event enable
        };

        // This register is write protected (except for RTC_ISR[13:8] bits). The write access procedure is described in RTC register write protection on page9.
        struct RTC_ISR : public Register<0x5800400c> {
            using ALRAWF = Field<0, 1>;    // Alarm A write flag This bit is set by hardware when Alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.
            using ALRBWF = Field<1, 1>;    // Alarm B write flag This bit is set by hardware when Alarm B values can be changed, after the ALRBE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.
            using WUTWF = Field<2, 1>;    // Wakeup timer write flag This bit is set by hardware up to 2 RTCCLK cycles after the WUTE bit has been set to 0 in RTC_CR, and is cleared up to 2 RTCCLK cycles after the WUTE bit has been set to 1. The wakeup timer values can be changed when WUTE bit is cleared and WUTWF is set.
            using SHPF = Field<3, 1>;    // Shift operation pending This flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect.
            using INITS = Field<4, 1>;    // Initialization status flag This bit is set by hardware when the calendar year field is different from 0 (Backup domain reset state).
            using RSF = Field<5, 1>;    // Registers synchronization flag This bit is set by hardware each time the calendar registers are copied into the shadow registers (RTC_SSRx, RTC_TRx and RTC_DRx). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF=1), or when in bypass shadow register mode (BYPSHAD=1). This bit can also be cleared by software. It is cleared either by software or by hardware in initialization mode.
            using INITF = Field<6, 1>;    // Initialization flag When this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated.
            using INIT = Field<7, 1>;    // Initialization mode
            using ALRAF = Field<8, 1>;    // Alarm A flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm A register (RTC_ALRMAR). This flag is cleared by software by writing 0.
            using ALRBF = Field<9, 1>;    // Alarm B flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm B register (RTC_ALRMBR). This flag is cleared by software by writing 0.
            using WUTF = Field<10, 1>;    // Wakeup timer flag This flag is set by hardware when the wakeup auto-reload counter reaches 0. This flag is cleared by software by writing 0. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again.
            using TSF = Field<11, 1>;    // Time-stamp flag This flag is set by hardware when a time-stamp event occurs. This flag is cleared by software by writing 0.
            using TSOVF = Field<12, 1>;    // Time-stamp overflow flag This flag is set by hardware when a time-stamp event occurs while TSF is already set. This flag is cleared by software by writing 0. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a time-stamp event occurs immediately before the TSF bit is cleared.
            using TAMP1F = Field<13, 1>;    // RTC_TAMP1 detection flag This flag is set by hardware when a tamper detection event is detected on the RTC_TAMP1 input. It is cleared by software writing 0
            using TAMP2F = Field<14, 1>;    // RTC_TAMP2 detection flag This flag is set by hardware when a tamper detection event is detected on the RTC_TAMP2 input. It is cleared by software writing 0
            using TAMP3F = Field<15, 1>;    // RTC_TAMP3 detection flag This flag is set by hardware when a tamper detection event is detected on the RTC_TAMP3 input. It is cleared by software writing 0
            using RECALPF = Field<16, 1>;    // Recalibration pending Flag The RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to Re-calibration on-the-fly.
            using ITSF = Field<17, 1>;    // Internal tTime-stamp flag
        };

        // This register must be written in initialization mode only. The initialization must be performed in two separate write accesses. Refer to Calendar initialization and configuration on page9.This register is write protected. The write access procedure is described in RTC register write protection on page9.
        struct RTC_PRER : public Register<0x58004010> {
            using PREDIV_S = Field<0, 15>;    // Synchronous prescaler factor This is the synchronous division factor: ck_spre frequency = ck_apre frequency/(PREDIV_S+1)
            using PREDIV_A = Field<16, 7>;    // Asynchronous prescaler factor This is the asynchronous division factor: ck_apre frequency = RTCCLK frequency/(PREDIV_A+1)
        };

        // This register can be written only when WUTWF is set to 1 in RTC_ISR.This register is write protected. The write access procedure is described in RTC register write protection on page9.
        struct RTC_WUTR : public Register<0x58004014> {
            using WUT = Field<0, 16>;    // Wakeup auto-reload value bits When the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0] + 1) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register When WUCKSEL[2] = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer. The first assertion of WUTF occurs (WUT+1) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] =011 (RTCCLK/2) is forbidden.
        };

        // This register can be written only when ALRAWF is set to 1 in RTC_ISR, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9.
        struct RTC_ALRMAR : public Register<0x5800401c> {
            using SU = Field<0, 4>;    // Second units in BCD format.
            using ST = Field<4, 3>;    // Second tens in BCD format.
            using MSK1 = Field<7, 1>;    // Alarm A seconds mask
            using MNU = Field<8, 4>;    // Minute units in BCD format.
            using MNT = Field<12, 3>;    // Minute tens in BCD format.
            using MSK2 = Field<15, 1>;    // Alarm A minutes mask
            using HU = Field<16, 4>;    // Hour units in BCD format.
            using HT = Field<20, 2>;    // Hour tens in BCD format.
            using PM = Field<22, 1>;    // AM/PM notation
            using MSK3 = Field<23, 1>;    // Alarm A hours mask
            using DU = Field<24, 4>;    // Date units or day in BCD format.
            using DT = Field<28, 2>;    // Date tens in BCD format.
            using WDSEL = Field<30, 1>;    // Week day selection
            using MSK4 = Field<31, 1>;    // Alarm A date mask
        };

        // This register can be written only when ALRBWF is set to 1 in RTC_ISR, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9.
        struct RTC_ALRMBR : public Register<0x58004020> {
            using SU = Field<0, 4>;    // Second units in BCD format
            using ST = Field<4, 3>;    // Second tens in BCD format
            using MSK1 = Field<7, 1>;    // Alarm B seconds mask
            using MNU = Field<8, 4>;    // Minute units in BCD format
            using MNT = Field<12, 3>;    // Minute tens in BCD format
            using MSK2 = Field<15, 1>;    // Alarm B minutes mask
            using HU = Field<16, 4>;    // Hour units in BCD format
            using HT = Field<20, 2>;    // Hour tens in BCD format
            using PM = Field<22, 1>;    // AM/PM notation
            using MSK3 = Field<23, 1>;    // Alarm B hours mask
            using DU = Field<24, 4>;    // Date units or day in BCD format
            using DT = Field<28, 2>;    // Date tens in BCD format
            using WDSEL = Field<30, 1>;    // Week day selection
            using MSK4 = Field<31, 1>;    // Alarm B date mask
        };

        // RTC write protection register
        struct RTC_WPR : public RegisterWriteOnly<0x58004024> {
            using KEY = Field<0, 8>;    // Write protection key This byte is written by software. Reading this byte always returns 0x00. Refer to RTC register write protection for a description of how to unlock RTC register write protection.
        };

        // RTC sub second register
        struct RTC_SSR : public RegisterReadOnly<0x58004028> {
            using SS = Field<0, 16>;    // Sub second value SS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below: Second fraction = (PREDIV_S - SS) / (PREDIV_S + 1) Note: SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR.
        };

        // This register is write protected. The write access procedure is described in RTC register write protection on page9.
        struct RTC_SHIFTR : public RegisterWriteOnly<0x5800402c> {
            using SUBFS = Field<0, 15>;    // Subtract a fraction of a second These bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). The value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by: Delay (seconds) = SUBFS / (PREDIV_S + 1) A fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by: Advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))). Note: Writing to SUBFS causes RSF to be cleared. Software can then wait until RSF=1 to be sure that the shadow registers have been updated with the shifted time.
            using ADD1S = Field<31, 1>;    // Add one second This bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). This function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation.
        };

        // The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset.
        struct RTC_TSTR : public RegisterReadOnly<0x58004030> {
            using SU = Field<0, 4>;    // Second units in BCD format.
            using ST = Field<4, 3>;    // Second tens in BCD format.
            using MNU = Field<8, 4>;    // Minute units in BCD format.
            using MNT = Field<12, 3>;    // Minute tens in BCD format.
            using HU = Field<16, 4>;    // Hour units in BCD format.
            using HT = Field<20, 2>;    // Hour tens in BCD format.
            using PM = Field<22, 1>;    // AM/PM notation
        };

        // The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset.
        struct RTC_TSDR : public RegisterReadOnly<0x58004034> {
            using DU = Field<0, 4>;    // Date units in BCD format
            using DT = Field<4, 2>;    // Date tens in BCD format
            using MU = Field<8, 4>;    // Month units in BCD format
            using MT = Field<12, 1>;    // Month tens in BCD format
            using WDU = Field<13, 3>;    // Week day units
        };

        // The content of this register is valid only when RTC_ISR/TSF is set. It is cleared when the RTC_ISR/TSF bit is reset.
        struct RTC_TSSSR : public RegisterReadOnly<0x58004038> {
            using SS = Field<0, 16>;    // Sub second value SS[15:0] is the value of the synchronous prescaler counter when the timestamp event occurred.
        };

        // This register is write protected. The write access procedure is described in RTC register write protection on page9.
        struct RTC_CALR : public Register<0x5800403c> {
            using CALM = Field<0, 9>;    // Calibration minus The frequency of the calendar is reduced by masking CALM out of 220 RTCCLK pulses (32 seconds if the input frequency is 32768 Hz). This decreases the frequency of the calendar with a resolution of 0.9537 ppm. To increase the frequency of the calendar, this feature should be used in conjunction with CALP. See Section24.3.12: RTC smooth digital calibration on page13.
            using CALW16 = Field<13, 1>;    // Use a 16-second calibration cycle period When CALW16 is set to 1, the 16-second calibration cycle period is selected.This bit must not be set to 1 if CALW8=1. Note: CALM[0] is stuck at 0 when CALW16= 1. Refer to Section24.3.12: RTC smooth digital calibration.
            using CALW8 = Field<14, 1>;    // Use an 8-second calibration cycle period When CALW8 is set to 1, the 8-second calibration cycle period is selected. Note: CALM[1:0] are stuck at 00; when CALW8= 1. Refer to Section24.3.12: RTC smooth digital calibration.
            using CALP = Field<15, 1>;    // Increase frequency of RTC by 488.5 ppm This feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. if the input frequency is 32768 Hz, the number of RTCCLK pulses added during a 32-second window is calculated as follows: (512 * CALP) - CALM. Refer to Section24.3.12: RTC smooth digital calibration.
        };

        // RTC tamper and alternate function configuration register
        struct RTC_TAMPCR : public Register<0x58004040> {
            using TAMP1E = Field<0, 1>;    // RTC_TAMP1 input detection enable
            using TAMP1TRG = Field<1, 1>;    // Active level for RTC_TAMP1 input If TAMPFLT != 00 if TAMPFLT = 00:
            using TAMPIE = Field<2, 1>;    // Tamper interrupt enable
            using TAMP2E = Field<3, 1>;    // RTC_TAMP2 input detection enable
            using TAMP2TRG = Field<4, 1>;    // Active level for RTC_TAMP2 input if TAMPFLT != 00: if TAMPFLT = 00:
            using TAMP3E = Field<5, 1>;    // RTC_TAMP3 detection enable
            using TAMP3TRG = Field<6, 1>;    // Active level for RTC_TAMP3 input if TAMPFLT != 00: if TAMPFLT = 00:
            using TAMPTS = Field<7, 1>;    // Activate timestamp on tamper detection event TAMPTS is valid even if TSE=0 in the RTC_CR register.
            using TAMPFREQ = Field<8, 3>;    // Tamper sampling frequency Determines the frequency at which each of the RTC_TAMPx inputs are sampled.
            using TAMPFLT = Field<11, 2>;    // RTC_TAMPx filter count These bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a Tamper event. TAMPFLT is valid for each of the RTC_TAMPx inputs.
            using TAMPPRCH = Field<13, 2>;    // RTC_TAMPx precharge duration These bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the RTC_TAMPx inputs.
            using TAMPPUDIS = Field<15, 1>;    // RTC_TAMPx pull-up disable This bit determines if each of the RTC_TAMPx pins are pre-charged before each sample.
            using TAMP1IE = Field<16, 1>;    // Tamper 1 interrupt enable
            using TAMP1NOERASE = Field<17, 1>;    // Tamper 1 no erase
            using TAMP1MF = Field<18, 1>;    // Tamper 1 mask flag
            using TAMP2IE = Field<19, 1>;    // Tamper 2 interrupt enable
            using TAMP2NOERASE = Field<20, 1>;    // Tamper 2 no erase
            using TAMP2MF = Field<21, 1>;    // Tamper 2 mask flag
            using TAMP3IE = Field<22, 1>;    // Tamper 3 interrupt enable
            using TAMP3NOERASE = Field<23, 1>;    // Tamper 3 no erase
            using TAMP3MF = Field<24, 1>;    // Tamper 3 mask flag
        };

        // This register can be written only when ALRAE is reset in RTC_CR register, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9
        struct RTC_ALRMASSR : public Register<0x58004044> {
            using SS = Field<0, 15>;    // Sub seconds value This value is compared with the contents of the synchronous prescaler counter to determine if Alarm A is to be activated. Only bits 0 up MASKSS-1 are compared.
            using MASKSS = Field<24, 4>;    // Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.
        };

        // This register can be written only when ALRBE is reset in RTC_CR register, or in initialization mode.This register is write protected.The write access procedure is described in Section: RTC register write protection.
        struct RTC_ALRMBSSR : public Register<0x58004048> {
            using SS = Field<0, 15>;    // Sub seconds value This value is compared with the contents of the synchronous prescaler counter to determine if Alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared.
            using MASKSS = Field<24, 4>;    // Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.
        };

        // RTC backup registers
        struct RTC_BKP0R : public Register<0x58004050> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP1R : public Register<0x58004054> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP2R : public Register<0x58004058> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP3R : public Register<0x5800405c> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP4R : public Register<0x58004060> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP5R : public Register<0x58004064> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP6R : public Register<0x58004068> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP7R : public Register<0x5800406c> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP8R : public Register<0x58004070> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP9R : public Register<0x58004074> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP10R : public Register<0x58004078> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP11R : public Register<0x5800407c> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP12R : public Register<0x58004080> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP13R : public Register<0x58004084> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP14R : public Register<0x58004088> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP15R : public Register<0x5800408c> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC option register
        struct RTC_OR : public Register<0x5800404c> {
            using RTC_ALARM_TYPE = Field<0, 1>;    // RTC_ALARM output type on PC13
            using RTC_OUT_RMP = Field<1, 1>;    // RTC_OUT remap
        };

        // RTC backup registers
        struct RTC_BKP16R : public Register<0x58004090> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP17R : public Register<0x58004094> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP18R : public Register<0x58004098> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP19R : public Register<0x5800409c> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP20R : public Register<0x580040a0> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP21R : public Register<0x580040a4> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP22R : public Register<0x580040a8> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP23R : public Register<0x580040ac> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP24R : public Register<0x580040b0> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP25R : public Register<0x580040b4> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP26R : public Register<0x580040b8> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP27R : public Register<0x580040bc> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP28R : public Register<0x580040c0> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP29R : public Register<0x580040c4> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP30R : public Register<0x580040c8> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

        // RTC backup registers
        struct RTC_BKP31R : public Register<0x580040cc> {
            using BKP = Field<0, 32>;    // The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
        };

    };

    // SAI
    struct SAI4 {
        // Global configuration register
        struct SAI_GCR : public Register<0x58005400> {
            using SYNCOUT = Field<4, 2>;    // Synchronization outputs These bits are set and cleared by software.
            using SYNCIN = Field<0, 2>;    // Synchronization inputs
        };

        // Configuration register 1
        struct SAI_ACR1 : public Register<0x58005404> {
            using MODE = Field<0, 2>;    // SAIx audio block mode immediately
            using PRTCFG = Field<2, 2>;    // Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled.
            using DS = Field<5, 3>;    // Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled.
            using LSBFIRST = Field<8, 1>;    // Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
            using CKSTR = Field<9, 1>;    // Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
            using SYNCEN = Field<10, 2>;    // Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled.
            using MONO = Field<12, 1>;    // Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
            using OUTDRIV = Field<13, 1>;    // Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
            using SAIXEN = Field<16, 1>;    // Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
            using DMAEN = Field<17, 1>;    // DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
            using NOMCK = Field<19, 1>;    // No divider
            using MCKDIV = Field<20, 4>;    // Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:
            using OSR = Field<26, 1>;    // Oversampling ratio for master clock
        };

        // Configuration register 2
        struct SAI_ACR2 : public Register<0x58005408> {
            using FTH = Field<0, 3>;    // FIFO threshold. This bit is set and cleared by software.
            using FFLUSH = Field<3, 1>;    // FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled.
            using TRIS = Field<4, 1>;    // Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details.
            using MUTE = Field<5, 1>;    // Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
            using MUTEVAL = Field<6, 1>;    // Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
            using MUTECNT = Field<7, 6>;    // Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details.
            using CPL = Field<13, 1>;    // Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm.
            using COMP = Field<14, 2>;    // Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected.
        };

        // This register has no meaning in AC97 and SPDIF audio protocol
        struct SAI_AFRCR : public Register<0x5800540c> {
            using FRL = Field<0, 8>;    // Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration.
            using FSALL = Field<8, 7>;    // Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled.
            using FSDEF = Field<16, 1>;    // Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled.
            using FSPOL = Field<17, 1>;    // Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
            using FSOFF = Field<18, 1>;    // Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
        };

        // This register has no meaning in AC97 and SPDIF audio protocol
        struct SAI_ASLOTR : public Register<0x58005410> {
            using FBOFF = Field<0, 5>;    // First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using SLOTSZ = Field<6, 2>;    // Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using NBSLOT = Field<8, 4>;    // Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using SLOTEN = Field<16, 16>;    // Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
        };

        // Interrupt mask register 2
        struct SAI_AIM : public Register<0x58005414> {
            using OVRUDRIE = Field<0, 1>;    // Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
            using MUTEDETIE = Field<1, 1>;    // Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
            using WCKCFGIE = Field<2, 1>;    // Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
            using FREQIE = Field<3, 1>;    // FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
            using CNRDYIE = Field<4, 1>;    // Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
            using AFSDETIE = Field<5, 1>;    // Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
            using LFSDETIE = Field<6, 1>;    // Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
        };

        // Status register
        struct SAI_ASR : public RegisterReadOnly<0x58005418> {
            using OVRUDR = Field<0, 1>;    // Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
            using MUTEDET = Field<1, 1>;    // Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
            using FREQ = Field<3, 1>;    // FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
            using CNRDY = Field<4, 1>;    // Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
            using AFSDET = Field<5, 1>;    // Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
            using LFSDET = Field<6, 1>;    // Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
            using FLVL = Field<16, 3>;    // FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver:
        };

        // Clear flag register
        struct SAI_ACLRFR : public RegisterWriteOnly<0x5800541c> {
            using COVRUDR = Field<0, 1>;    // Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
            using CMUTEDET = Field<1, 1>;    // Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
            using CWCKCFG = Field<2, 1>;    // Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
            using CCNRDY = Field<4, 1>;    // Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
            using CAFSDET = Field<5, 1>;    // Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
            using CLFSDET = Field<6, 1>;    // Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
        };

        // Data register
        struct SAI_ADR : public Register<0x58005420> {
            using DATA = Field<0, 32>;    // Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty.
        };

        // Configuration register 1
        struct SAI_BCR1 : public Register<0x58005424> {
            using MODE = Field<0, 2>;    // SAIx audio block mode immediately
            using PRTCFG = Field<2, 2>;    // Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled.
            using DS = Field<5, 3>;    // Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled.
            using LSBFIRST = Field<8, 1>;    // Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
            using CKSTR = Field<9, 1>;    // Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
            using SYNCEN = Field<10, 2>;    // Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled.
            using MONO = Field<12, 1>;    // Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
            using OUTDRIV = Field<13, 1>;    // Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
            using SAIXEN = Field<16, 1>;    // Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
            using DMAEN = Field<17, 1>;    // DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
            using NOMCK = Field<19, 1>;    // No divider
            using MCKDIV = Field<20, 4>;    // Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:
            using OSR = Field<26, 1>;    // Oversampling ratio for master clock
        };

        // Configuration register 2
        struct SAI_BCR2 : public Register<0x58005428> {
            using FTH = Field<0, 3>;    // FIFO threshold. This bit is set and cleared by software.
            using FFLUSH = Field<3, 1>;    // FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled.
            using TRIS = Field<4, 1>;    // Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details.
            using MUTE = Field<5, 1>;    // Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
            using MUTEVAL = Field<6, 1>;    // Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
            using MUTECNT = Field<7, 6>;    // Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details.
            using CPL = Field<13, 1>;    // Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm.
            using COMP = Field<14, 2>;    // Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected.
        };

        // This register has no meaning in AC97 and SPDIF audio protocol
        struct SAI_BFRCR : public Register<0x5800542c> {
            using FRL = Field<0, 8>;    // Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration.
            using FSALL = Field<8, 7>;    // Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled.
            using FSDEF = Field<16, 1>;    // Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled.
            using FSPOL = Field<17, 1>;    // Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
            using FSOFF = Field<18, 1>;    // Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
        };

        // This register has no meaning in AC97 and SPDIF audio protocol
        struct SAI_BSLOTR : public Register<0x58005430> {
            using FBOFF = Field<0, 5>;    // First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using SLOTSZ = Field<6, 2>;    // Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using NBSLOT = Field<8, 4>;    // Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using SLOTEN = Field<16, 16>;    // Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
        };

        // Interrupt mask register 2
        struct SAI_BIM : public Register<0x58005434> {
            using OVRUDRIE = Field<0, 1>;    // Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
            using MUTEDETIE = Field<1, 1>;    // Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
            using WCKCFGIE = Field<2, 1>;    // Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
            using FREQIE = Field<3, 1>;    // FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
            using CNRDYIE = Field<4, 1>;    // Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
            using AFSDETIE = Field<5, 1>;    // Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
            using LFSDETIE = Field<6, 1>;    // Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
        };

        // Status register
        struct SAI_BSR : public RegisterReadOnly<0x58005438> {
            using OVRUDR = Field<0, 1>;    // Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
            using MUTEDET = Field<1, 1>;    // Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
            using FREQ = Field<3, 1>;    // FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
            using CNRDY = Field<4, 1>;    // Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
            using AFSDET = Field<5, 1>;    // Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
            using LFSDET = Field<6, 1>;    // Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
            using FLVL = Field<16, 3>;    // FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver:
        };

        // Clear flag register
        struct SAI_BCLRFR : public RegisterWriteOnly<0x5800543c> {
            using COVRUDR = Field<0, 1>;    // Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
            using CMUTEDET = Field<1, 1>;    // Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
            using CWCKCFG = Field<2, 1>;    // Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
            using CCNRDY = Field<4, 1>;    // Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
            using CAFSDET = Field<5, 1>;    // Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
            using CLFSDET = Field<6, 1>;    // Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
        };

        // Data register
        struct SAI_BDR : public Register<0x58005440> {
            using DATA = Field<0, 32>;    // Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty.
        };

        // PDM control register
        struct SAI_PDMCR : public Register<0x58005444> {
            using PDMEN = Field<0, 1>;    // PDM enable
            using MICNBR = Field<4, 2>;    // Number of microphones
            using CKEN1 = Field<8, 1>;    // Clock enable of bitstream clock number 1
            using CKEN2 = Field<9, 1>;    // Clock enable of bitstream clock number 2
            using CKEN3 = Field<10, 1>;    // Clock enable of bitstream clock number 3
            using CKEN4 = Field<11, 1>;    // Clock enable of bitstream clock number 4
        };

        // PDM delay register
        struct SAI_PDMDLY : public Register<0x58005448> {
            using DLYM1L = Field<0, 3>;    // Delay line adjust for first microphone of pair 1
            using DLYM1R = Field<4, 3>;    // Delay line adjust for second microphone of pair 1
            using DLYM2L = Field<8, 3>;    // Delay line for first microphone of pair 2
            using DLYM2R = Field<12, 3>;    // Delay line for second microphone of pair 2
            using DLYM3L = Field<16, 3>;    // Delay line for first microphone of pair 3
            using DLYM3R = Field<20, 3>;    // Delay line for second microphone of pair 3
            using DLYM4L = Field<24, 3>;    // Delay line for first microphone of pair 4
            using DLYM4R = Field<28, 3>;    // Delay line for second microphone of pair 4
        };

    };

    // SAI
    struct SAI1 {
        // Global configuration register
        struct SAI_GCR : public Register<0x40015800> {
            using SYNCOUT = Field<4, 2>;    // Synchronization outputs These bits are set and cleared by software.
            using SYNCIN = Field<0, 2>;    // Synchronization inputs
        };

        // Configuration register 1
        struct SAI_ACR1 : public Register<0x40015804> {
            using MODE = Field<0, 2>;    // SAIx audio block mode immediately
            using PRTCFG = Field<2, 2>;    // Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled.
            using DS = Field<5, 3>;    // Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled.
            using LSBFIRST = Field<8, 1>;    // Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
            using CKSTR = Field<9, 1>;    // Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
            using SYNCEN = Field<10, 2>;    // Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled.
            using MONO = Field<12, 1>;    // Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
            using OUTDRIV = Field<13, 1>;    // Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
            using SAIXEN = Field<16, 1>;    // Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
            using DMAEN = Field<17, 1>;    // DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
            using NOMCK = Field<19, 1>;    // No divider
            using MCKDIV = Field<20, 4>;    // Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:
            using OSR = Field<26, 1>;    // Oversampling ratio for master clock
        };

        // Configuration register 2
        struct SAI_ACR2 : public Register<0x40015808> {
            using FTH = Field<0, 3>;    // FIFO threshold. This bit is set and cleared by software.
            using FFLUSH = Field<3, 1>;    // FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled.
            using TRIS = Field<4, 1>;    // Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details.
            using MUTE = Field<5, 1>;    // Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
            using MUTEVAL = Field<6, 1>;    // Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
            using MUTECNT = Field<7, 6>;    // Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details.
            using CPL = Field<13, 1>;    // Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm.
            using COMP = Field<14, 2>;    // Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected.
        };

        // This register has no meaning in AC97 and SPDIF audio protocol
        struct SAI_AFRCR : public Register<0x4001580c> {
            using FRL = Field<0, 8>;    // Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration.
            using FSALL = Field<8, 7>;    // Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled.
            using FSDEF = Field<16, 1>;    // Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled.
            using FSPOL = Field<17, 1>;    // Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
            using FSOFF = Field<18, 1>;    // Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
        };

        // This register has no meaning in AC97 and SPDIF audio protocol
        struct SAI_ASLOTR : public Register<0x40015810> {
            using FBOFF = Field<0, 5>;    // First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using SLOTSZ = Field<6, 2>;    // Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using NBSLOT = Field<8, 4>;    // Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using SLOTEN = Field<16, 16>;    // Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
        };

        // Interrupt mask register 2
        struct SAI_AIM : public Register<0x40015814> {
            using OVRUDRIE = Field<0, 1>;    // Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
            using MUTEDETIE = Field<1, 1>;    // Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
            using WCKCFGIE = Field<2, 1>;    // Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
            using FREQIE = Field<3, 1>;    // FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
            using CNRDYIE = Field<4, 1>;    // Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
            using AFSDETIE = Field<5, 1>;    // Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
            using LFSDETIE = Field<6, 1>;    // Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
        };

        // Status register
        struct SAI_ASR : public RegisterReadOnly<0x40015818> {
            using OVRUDR = Field<0, 1>;    // Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
            using MUTEDET = Field<1, 1>;    // Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
            using FREQ = Field<3, 1>;    // FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
            using CNRDY = Field<4, 1>;    // Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
            using AFSDET = Field<5, 1>;    // Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
            using LFSDET = Field<6, 1>;    // Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
            using FLVL = Field<16, 3>;    // FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver:
        };

        // Clear flag register
        struct SAI_ACLRFR : public RegisterWriteOnly<0x4001581c> {
            using COVRUDR = Field<0, 1>;    // Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
            using CMUTEDET = Field<1, 1>;    // Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
            using CWCKCFG = Field<2, 1>;    // Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
            using CCNRDY = Field<4, 1>;    // Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
            using CAFSDET = Field<5, 1>;    // Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
            using CLFSDET = Field<6, 1>;    // Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
        };

        // Data register
        struct SAI_ADR : public Register<0x40015820> {
            using DATA = Field<0, 32>;    // Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty.
        };

        // Configuration register 1
        struct SAI_BCR1 : public Register<0x40015824> {
            using MODE = Field<0, 2>;    // SAIx audio block mode immediately
            using PRTCFG = Field<2, 2>;    // Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled.
            using DS = Field<5, 3>;    // Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled.
            using LSBFIRST = Field<8, 1>;    // Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
            using CKSTR = Field<9, 1>;    // Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
            using SYNCEN = Field<10, 2>;    // Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled.
            using MONO = Field<12, 1>;    // Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
            using OUTDRIV = Field<13, 1>;    // Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
            using SAIXEN = Field<16, 1>;    // Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
            using DMAEN = Field<17, 1>;    // DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
            using NOMCK = Field<19, 1>;    // No divider
            using MCKDIV = Field<20, 4>;    // Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:
            using OSR = Field<26, 1>;    // Oversampling ratio for master clock
        };

        // Configuration register 2
        struct SAI_BCR2 : public Register<0x40015828> {
            using FTH = Field<0, 3>;    // FIFO threshold. This bit is set and cleared by software.
            using FFLUSH = Field<3, 1>;    // FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled.
            using TRIS = Field<4, 1>;    // Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details.
            using MUTE = Field<5, 1>;    // Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
            using MUTEVAL = Field<6, 1>;    // Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
            using MUTECNT = Field<7, 6>;    // Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details.
            using CPL = Field<13, 1>;    // Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm.
            using COMP = Field<14, 2>;    // Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected.
        };

        // This register has no meaning in AC97 and SPDIF audio protocol
        struct SAI_BFRCR : public Register<0x4001582c> {
            using FRL = Field<0, 8>;    // Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration.
            using FSALL = Field<8, 7>;    // Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled.
            using FSDEF = Field<16, 1>;    // Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled.
            using FSPOL = Field<17, 1>;    // Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
            using FSOFF = Field<18, 1>;    // Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
        };

        // This register has no meaning in AC97 and SPDIF audio protocol
        struct SAI_BSLOTR : public Register<0x40015830> {
            using FBOFF = Field<0, 5>;    // First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using SLOTSZ = Field<6, 2>;    // Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using NBSLOT = Field<8, 4>;    // Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using SLOTEN = Field<16, 16>;    // Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
        };

        // Interrupt mask register 2
        struct SAI_BIM : public Register<0x40015834> {
            using OVRUDRIE = Field<0, 1>;    // Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
            using MUTEDETIE = Field<1, 1>;    // Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
            using WCKCFGIE = Field<2, 1>;    // Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
            using FREQIE = Field<3, 1>;    // FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
            using CNRDYIE = Field<4, 1>;    // Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
            using AFSDETIE = Field<5, 1>;    // Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
            using LFSDETIE = Field<6, 1>;    // Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
        };

        // Status register
        struct SAI_BSR : public RegisterReadOnly<0x40015838> {
            using OVRUDR = Field<0, 1>;    // Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
            using MUTEDET = Field<1, 1>;    // Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
            using FREQ = Field<3, 1>;    // FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
            using CNRDY = Field<4, 1>;    // Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
            using AFSDET = Field<5, 1>;    // Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
            using LFSDET = Field<6, 1>;    // Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
            using FLVL = Field<16, 3>;    // FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver:
        };

        // Clear flag register
        struct SAI_BCLRFR : public RegisterWriteOnly<0x4001583c> {
            using COVRUDR = Field<0, 1>;    // Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
            using CMUTEDET = Field<1, 1>;    // Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
            using CWCKCFG = Field<2, 1>;    // Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
            using CCNRDY = Field<4, 1>;    // Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
            using CAFSDET = Field<5, 1>;    // Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
            using CLFSDET = Field<6, 1>;    // Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
        };

        // Data register
        struct SAI_BDR : public Register<0x40015840> {
            using DATA = Field<0, 32>;    // Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty.
        };

        // PDM control register
        struct SAI_PDMCR : public Register<0x40015844> {
            using PDMEN = Field<0, 1>;    // PDM enable
            using MICNBR = Field<4, 2>;    // Number of microphones
            using CKEN1 = Field<8, 1>;    // Clock enable of bitstream clock number 1
            using CKEN2 = Field<9, 1>;    // Clock enable of bitstream clock number 2
            using CKEN3 = Field<10, 1>;    // Clock enable of bitstream clock number 3
            using CKEN4 = Field<11, 1>;    // Clock enable of bitstream clock number 4
        };

        // PDM delay register
        struct SAI_PDMDLY : public Register<0x40015848> {
            using DLYM1L = Field<0, 3>;    // Delay line adjust for first microphone of pair 1
            using DLYM1R = Field<4, 3>;    // Delay line adjust for second microphone of pair 1
            using DLYM2L = Field<8, 3>;    // Delay line for first microphone of pair 2
            using DLYM2R = Field<12, 3>;    // Delay line for second microphone of pair 2
            using DLYM3L = Field<16, 3>;    // Delay line for first microphone of pair 3
            using DLYM3R = Field<20, 3>;    // Delay line for second microphone of pair 3
            using DLYM4L = Field<24, 3>;    // Delay line for first microphone of pair 4
            using DLYM4R = Field<28, 3>;    // Delay line for second microphone of pair 4
        };

    };

    // SAI
    struct SAI2 {
        // Global configuration register
        struct SAI_GCR : public Register<0x40015c00> {
            using SYNCOUT = Field<4, 2>;    // Synchronization outputs These bits are set and cleared by software.
            using SYNCIN = Field<0, 2>;    // Synchronization inputs
        };

        // Configuration register 1
        struct SAI_ACR1 : public Register<0x40015c04> {
            using MODE = Field<0, 2>;    // SAIx audio block mode immediately
            using PRTCFG = Field<2, 2>;    // Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled.
            using DS = Field<5, 3>;    // Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled.
            using LSBFIRST = Field<8, 1>;    // Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
            using CKSTR = Field<9, 1>;    // Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
            using SYNCEN = Field<10, 2>;    // Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled.
            using MONO = Field<12, 1>;    // Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
            using OUTDRIV = Field<13, 1>;    // Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
            using SAIXEN = Field<16, 1>;    // Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
            using DMAEN = Field<17, 1>;    // DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
            using NOMCK = Field<19, 1>;    // No divider
            using MCKDIV = Field<20, 4>;    // Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:
            using OSR = Field<26, 1>;    // Oversampling ratio for master clock
        };

        // Configuration register 2
        struct SAI_ACR2 : public Register<0x40015c08> {
            using FTH = Field<0, 3>;    // FIFO threshold. This bit is set and cleared by software.
            using FFLUSH = Field<3, 1>;    // FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled.
            using TRIS = Field<4, 1>;    // Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details.
            using MUTE = Field<5, 1>;    // Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
            using MUTEVAL = Field<6, 1>;    // Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
            using MUTECNT = Field<7, 6>;    // Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details.
            using CPL = Field<13, 1>;    // Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm.
            using COMP = Field<14, 2>;    // Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected.
        };

        // This register has no meaning in AC97 and SPDIF audio protocol
        struct SAI_AFRCR : public Register<0x40015c0c> {
            using FRL = Field<0, 8>;    // Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration.
            using FSALL = Field<8, 7>;    // Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled.
            using FSDEF = Field<16, 1>;    // Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled.
            using FSPOL = Field<17, 1>;    // Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
            using FSOFF = Field<18, 1>;    // Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
        };

        // This register has no meaning in AC97 and SPDIF audio protocol
        struct SAI_ASLOTR : public Register<0x40015c10> {
            using FBOFF = Field<0, 5>;    // First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using SLOTSZ = Field<6, 2>;    // Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using NBSLOT = Field<8, 4>;    // Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using SLOTEN = Field<16, 16>;    // Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
        };

        // Interrupt mask register 2
        struct SAI_AIM : public Register<0x40015c14> {
            using OVRUDRIE = Field<0, 1>;    // Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
            using MUTEDETIE = Field<1, 1>;    // Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
            using WCKCFGIE = Field<2, 1>;    // Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
            using FREQIE = Field<3, 1>;    // FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
            using CNRDYIE = Field<4, 1>;    // Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
            using AFSDETIE = Field<5, 1>;    // Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
            using LFSDETIE = Field<6, 1>;    // Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
        };

        // Status register
        struct SAI_ASR : public RegisterReadOnly<0x40015c18> {
            using OVRUDR = Field<0, 1>;    // Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
            using MUTEDET = Field<1, 1>;    // Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
            using FREQ = Field<3, 1>;    // FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
            using CNRDY = Field<4, 1>;    // Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
            using AFSDET = Field<5, 1>;    // Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
            using LFSDET = Field<6, 1>;    // Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
            using FLVL = Field<16, 3>;    // FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver:
        };

        // Clear flag register
        struct SAI_ACLRFR : public RegisterWriteOnly<0x40015c1c> {
            using COVRUDR = Field<0, 1>;    // Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
            using CMUTEDET = Field<1, 1>;    // Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
            using CWCKCFG = Field<2, 1>;    // Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
            using CCNRDY = Field<4, 1>;    // Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
            using CAFSDET = Field<5, 1>;    // Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
            using CLFSDET = Field<6, 1>;    // Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
        };

        // Data register
        struct SAI_ADR : public Register<0x40015c20> {
            using DATA = Field<0, 32>;    // Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty.
        };

        // Configuration register 1
        struct SAI_BCR1 : public Register<0x40015c24> {
            using MODE = Field<0, 2>;    // SAIx audio block mode immediately
            using PRTCFG = Field<2, 2>;    // Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled.
            using DS = Field<5, 3>;    // Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled.
            using LSBFIRST = Field<8, 1>;    // Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
            using CKSTR = Field<9, 1>;    // Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
            using SYNCEN = Field<10, 2>;    // Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled.
            using MONO = Field<12, 1>;    // Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
            using OUTDRIV = Field<13, 1>;    // Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
            using SAIXEN = Field<16, 1>;    // Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
            using DMAEN = Field<17, 1>;    // DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
            using NOMCK = Field<19, 1>;    // No divider
            using MCKDIV = Field<20, 4>;    // Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:
            using OSR = Field<26, 1>;    // Oversampling ratio for master clock
        };

        // Configuration register 2
        struct SAI_BCR2 : public Register<0x40015c28> {
            using FTH = Field<0, 3>;    // FIFO threshold. This bit is set and cleared by software.
            using FFLUSH = Field<3, 1>;    // FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled.
            using TRIS = Field<4, 1>;    // Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details.
            using MUTE = Field<5, 1>;    // Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
            using MUTEVAL = Field<6, 1>;    // Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
            using MUTECNT = Field<7, 6>;    // Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details.
            using CPL = Field<13, 1>;    // Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm.
            using COMP = Field<14, 2>;    // Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected.
        };

        // This register has no meaning in AC97 and SPDIF audio protocol
        struct SAI_BFRCR : public Register<0x40015c2c> {
            using FRL = Field<0, 8>;    // Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration.
            using FSALL = Field<8, 7>;    // Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled.
            using FSDEF = Field<16, 1>;    // Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled.
            using FSPOL = Field<17, 1>;    // Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
            using FSOFF = Field<18, 1>;    // Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
        };

        // This register has no meaning in AC97 and SPDIF audio protocol
        struct SAI_BSLOTR : public Register<0x40015c30> {
            using FBOFF = Field<0, 5>;    // First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using SLOTSZ = Field<6, 2>;    // Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using NBSLOT = Field<8, 4>;    // Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using SLOTEN = Field<16, 16>;    // Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
        };

        // Interrupt mask register 2
        struct SAI_BIM : public Register<0x40015c34> {
            using OVRUDRIE = Field<0, 1>;    // Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
            using MUTEDETIE = Field<1, 1>;    // Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
            using WCKCFGIE = Field<2, 1>;    // Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
            using FREQIE = Field<3, 1>;    // FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
            using CNRDYIE = Field<4, 1>;    // Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
            using AFSDETIE = Field<5, 1>;    // Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
            using LFSDETIE = Field<6, 1>;    // Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
        };

        // Status register
        struct SAI_BSR : public RegisterReadOnly<0x40015c38> {
            using OVRUDR = Field<0, 1>;    // Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
            using MUTEDET = Field<1, 1>;    // Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
            using FREQ = Field<3, 1>;    // FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
            using CNRDY = Field<4, 1>;    // Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
            using AFSDET = Field<5, 1>;    // Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
            using LFSDET = Field<6, 1>;    // Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
            using FLVL = Field<16, 3>;    // FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver:
        };

        // Clear flag register
        struct SAI_BCLRFR : public RegisterWriteOnly<0x40015c3c> {
            using COVRUDR = Field<0, 1>;    // Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
            using CMUTEDET = Field<1, 1>;    // Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
            using CWCKCFG = Field<2, 1>;    // Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
            using CCNRDY = Field<4, 1>;    // Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
            using CAFSDET = Field<5, 1>;    // Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
            using CLFSDET = Field<6, 1>;    // Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
        };

        // Data register
        struct SAI_BDR : public Register<0x40015c40> {
            using DATA = Field<0, 32>;    // Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty.
        };

        // PDM control register
        struct SAI_PDMCR : public Register<0x40015c44> {
            using PDMEN = Field<0, 1>;    // PDM enable
            using MICNBR = Field<4, 2>;    // Number of microphones
            using CKEN1 = Field<8, 1>;    // Clock enable of bitstream clock number 1
            using CKEN2 = Field<9, 1>;    // Clock enable of bitstream clock number 2
            using CKEN3 = Field<10, 1>;    // Clock enable of bitstream clock number 3
            using CKEN4 = Field<11, 1>;    // Clock enable of bitstream clock number 4
        };

        // PDM delay register
        struct SAI_PDMDLY : public Register<0x40015c48> {
            using DLYM1L = Field<0, 3>;    // Delay line adjust for first microphone of pair 1
            using DLYM1R = Field<4, 3>;    // Delay line adjust for second microphone of pair 1
            using DLYM2L = Field<8, 3>;    // Delay line for first microphone of pair 2
            using DLYM2R = Field<12, 3>;    // Delay line for second microphone of pair 2
            using DLYM3L = Field<16, 3>;    // Delay line for first microphone of pair 3
            using DLYM3R = Field<20, 3>;    // Delay line for second microphone of pair 3
            using DLYM4L = Field<24, 3>;    // Delay line for first microphone of pair 4
            using DLYM4R = Field<28, 3>;    // Delay line for second microphone of pair 4
        };

    };

    // SAI
    struct SAI3 {
        // Global configuration register
        struct SAI_GCR : public Register<0x40016000> {
            using SYNCOUT = Field<4, 2>;    // Synchronization outputs These bits are set and cleared by software.
            using SYNCIN = Field<0, 2>;    // Synchronization inputs
        };

        // Configuration register 1
        struct SAI_ACR1 : public Register<0x40016004> {
            using MODE = Field<0, 2>;    // SAIx audio block mode immediately
            using PRTCFG = Field<2, 2>;    // Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled.
            using DS = Field<5, 3>;    // Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled.
            using LSBFIRST = Field<8, 1>;    // Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
            using CKSTR = Field<9, 1>;    // Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
            using SYNCEN = Field<10, 2>;    // Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled.
            using MONO = Field<12, 1>;    // Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
            using OUTDRIV = Field<13, 1>;    // Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
            using SAIXEN = Field<16, 1>;    // Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
            using DMAEN = Field<17, 1>;    // DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
            using NOMCK = Field<19, 1>;    // No divider
            using MCKDIV = Field<20, 4>;    // Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:
            using OSR = Field<26, 1>;    // Oversampling ratio for master clock
        };

        // Configuration register 2
        struct SAI_ACR2 : public Register<0x40016008> {
            using FTH = Field<0, 3>;    // FIFO threshold. This bit is set and cleared by software.
            using FFLUSH = Field<3, 1>;    // FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled.
            using TRIS = Field<4, 1>;    // Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details.
            using MUTE = Field<5, 1>;    // Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
            using MUTEVAL = Field<6, 1>;    // Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
            using MUTECNT = Field<7, 6>;    // Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details.
            using CPL = Field<13, 1>;    // Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm.
            using COMP = Field<14, 2>;    // Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected.
        };

        // This register has no meaning in AC97 and SPDIF audio protocol
        struct SAI_AFRCR : public Register<0x4001600c> {
            using FRL = Field<0, 8>;    // Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration.
            using FSALL = Field<8, 7>;    // Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled.
            using FSDEF = Field<16, 1>;    // Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled.
            using FSPOL = Field<17, 1>;    // Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
            using FSOFF = Field<18, 1>;    // Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
        };

        // This register has no meaning in AC97 and SPDIF audio protocol
        struct SAI_ASLOTR : public Register<0x40016010> {
            using FBOFF = Field<0, 5>;    // First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using SLOTSZ = Field<6, 2>;    // Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using NBSLOT = Field<8, 4>;    // Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using SLOTEN = Field<16, 16>;    // Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
        };

        // Interrupt mask register 2
        struct SAI_AIM : public Register<0x40016014> {
            using OVRUDRIE = Field<0, 1>;    // Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
            using MUTEDETIE = Field<1, 1>;    // Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
            using WCKCFGIE = Field<2, 1>;    // Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
            using FREQIE = Field<3, 1>;    // FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
            using CNRDYIE = Field<4, 1>;    // Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
            using AFSDETIE = Field<5, 1>;    // Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
            using LFSDETIE = Field<6, 1>;    // Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
        };

        // Status register
        struct SAI_ASR : public RegisterReadOnly<0x40016018> {
            using OVRUDR = Field<0, 1>;    // Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
            using MUTEDET = Field<1, 1>;    // Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
            using FREQ = Field<3, 1>;    // FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
            using CNRDY = Field<4, 1>;    // Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
            using AFSDET = Field<5, 1>;    // Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
            using LFSDET = Field<6, 1>;    // Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
            using FLVL = Field<16, 3>;    // FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver:
        };

        // Clear flag register
        struct SAI_ACLRFR : public RegisterWriteOnly<0x4001601c> {
            using COVRUDR = Field<0, 1>;    // Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
            using CMUTEDET = Field<1, 1>;    // Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
            using CWCKCFG = Field<2, 1>;    // Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
            using CCNRDY = Field<4, 1>;    // Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
            using CAFSDET = Field<5, 1>;    // Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
            using CLFSDET = Field<6, 1>;    // Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
        };

        // Data register
        struct SAI_ADR : public Register<0x40016020> {
            using DATA = Field<0, 32>;    // Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty.
        };

        // Configuration register 1
        struct SAI_BCR1 : public Register<0x40016024> {
            using MODE = Field<0, 2>;    // SAIx audio block mode immediately
            using PRTCFG = Field<2, 2>;    // Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled.
            using DS = Field<5, 3>;    // Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled.
            using LSBFIRST = Field<8, 1>;    // Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
            using CKSTR = Field<9, 1>;    // Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
            using SYNCEN = Field<10, 2>;    // Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled.
            using MONO = Field<12, 1>;    // Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
            using OUTDRIV = Field<13, 1>;    // Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
            using SAIXEN = Field<16, 1>;    // Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
            using DMAEN = Field<17, 1>;    // DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
            using NOMCK = Field<19, 1>;    // No divider
            using MCKDIV = Field<20, 4>;    // Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:
            using OSR = Field<26, 1>;    // Oversampling ratio for master clock
        };

        // Configuration register 2
        struct SAI_BCR2 : public Register<0x40016028> {
            using FTH = Field<0, 3>;    // FIFO threshold. This bit is set and cleared by software.
            using FFLUSH = Field<3, 1>;    // FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled.
            using TRIS = Field<4, 1>;    // Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details.
            using MUTE = Field<5, 1>;    // Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
            using MUTEVAL = Field<6, 1>;    // Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
            using MUTECNT = Field<7, 6>;    // Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details.
            using CPL = Field<13, 1>;    // Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm.
            using COMP = Field<14, 2>;    // Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected.
        };

        // This register has no meaning in AC97 and SPDIF audio protocol
        struct SAI_BFRCR : public Register<0x4001602c> {
            using FRL = Field<0, 8>;    // Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration.
            using FSALL = Field<8, 7>;    // Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled.
            using FSDEF = Field<16, 1>;    // Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled.
            using FSPOL = Field<17, 1>;    // Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
            using FSOFF = Field<18, 1>;    // Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
        };

        // This register has no meaning in AC97 and SPDIF audio protocol
        struct SAI_BSLOTR : public Register<0x40016030> {
            using FBOFF = Field<0, 5>;    // First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using SLOTSZ = Field<6, 2>;    // Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using NBSLOT = Field<8, 4>;    // Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
            using SLOTEN = Field<16, 16>;    // Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
        };

        // Interrupt mask register 2
        struct SAI_BIM : public Register<0x40016034> {
            using OVRUDRIE = Field<0, 1>;    // Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
            using MUTEDETIE = Field<1, 1>;    // Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
            using WCKCFGIE = Field<2, 1>;    // Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
            using FREQIE = Field<3, 1>;    // FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
            using CNRDYIE = Field<4, 1>;    // Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
            using AFSDETIE = Field<5, 1>;    // Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
            using LFSDETIE = Field<6, 1>;    // Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
        };

        // Status register
        struct SAI_BSR : public RegisterReadOnly<0x40016038> {
            using OVRUDR = Field<0, 1>;    // Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
            using MUTEDET = Field<1, 1>;    // Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
            using FREQ = Field<3, 1>;    // FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
            using CNRDY = Field<4, 1>;    // Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
            using AFSDET = Field<5, 1>;    // Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
            using LFSDET = Field<6, 1>;    // Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
            using FLVL = Field<16, 3>;    // FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver:
        };

        // Clear flag register
        struct SAI_BCLRFR : public RegisterWriteOnly<0x4001603c> {
            using COVRUDR = Field<0, 1>;    // Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
            using CMUTEDET = Field<1, 1>;    // Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
            using CWCKCFG = Field<2, 1>;    // Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
            using CCNRDY = Field<4, 1>;    // Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
            using CAFSDET = Field<5, 1>;    // Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
            using CLFSDET = Field<6, 1>;    // Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
        };

        // Data register
        struct SAI_BDR : public Register<0x40016040> {
            using DATA = Field<0, 32>;    // Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty.
        };

        // PDM control register
        struct SAI_PDMCR : public Register<0x40016044> {
            using PDMEN = Field<0, 1>;    // PDM enable
            using MICNBR = Field<4, 2>;    // Number of microphones
            using CKEN1 = Field<8, 1>;    // Clock enable of bitstream clock number 1
            using CKEN2 = Field<9, 1>;    // Clock enable of bitstream clock number 2
            using CKEN3 = Field<10, 1>;    // Clock enable of bitstream clock number 3
            using CKEN4 = Field<11, 1>;    // Clock enable of bitstream clock number 4
        };

        // PDM delay register
        struct SAI_PDMDLY : public Register<0x40016048> {
            using DLYM1L = Field<0, 3>;    // Delay line adjust for first microphone of pair 1
            using DLYM1R = Field<4, 3>;    // Delay line adjust for second microphone of pair 1
            using DLYM2L = Field<8, 3>;    // Delay line for first microphone of pair 2
            using DLYM2R = Field<12, 3>;    // Delay line for second microphone of pair 2
            using DLYM3L = Field<16, 3>;    // Delay line for first microphone of pair 3
            using DLYM3R = Field<20, 3>;    // Delay line for second microphone of pair 3
            using DLYM4L = Field<24, 3>;    // Delay line for first microphone of pair 4
            using DLYM4R = Field<28, 3>;    // Delay line for second microphone of pair 4
        };

    };

    // SDMMC1
    struct SDMMC1 {
        // SDMMC power control register
        struct POWER : public Register<0x52007000> {
            using PWRCTRL = Field<0, 2>;    // SDMMC state control bits. These bits can only be written when the SDMMC is not in the power-on state (PWRCTRL?11). These bits are used to define the functional state of the SDMMC signals: Any further write will be ignored, PWRCTRL value will keep 11.
            using VSWITCH = Field<2, 1>;    // Voltage switch sequence start. This bit is used to start the timing critical section of the voltage switch sequence:
            using VSWITCHEN = Field<3, 1>;    // Voltage switch procedure enable. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). This bit is used to stop the SDMMC_CK after the voltage switch command response:
            using DIRPOL = Field<4, 1>;    // Data and command direction signals polarity selection. This bit can only be written when the SDMMC is in the power-off state (PWRCTRL = 00).
        };

        // The SDMMC_CLKCR register controls the SDMMC_CK output clock, the SDMMC_RX_CLK receive clock, and the bus width.
        struct CLKCR : public Register<0x52007004> {
            using CLKDIV = Field<0, 10>;    // Clock divide factor This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). This field defines the divide factor between the input clock (SDMMCCLK) and the output clock (SDMMC_CK): SDMMC_CK frequency = SDMMCCLK / [2 * CLKDIV]. 0xx: etc.. xxx: etc..
            using PWRSAV = Field<12, 1>;    // Power saving configuration bit This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) For power saving, the SDMMC_CK clock output can be disabled when the bus is idle by setting PWRSAV:
            using WIDBUS = Field<14, 2>;    // Wide bus mode enable bit This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
            using NEGEDGE = Field<16, 1>;    // SDMMC_CK dephasing selection bit for data and Command. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). When clock division = 1 (CLKDIV = 0), this bit has no effect. Data and Command change on SDMMC_CK falling edge. When clock division &gt;1 (CLKDIV &gt; 0) &amp; DDR = 0: - SDMMC_CK edge occurs on SDMMCCLK rising edge. When clock division >1 (CLKDIV > 0) & DDR = 1: - Data changed on the SDMMCCLK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. - Data changed on the SDMMC_CK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge.
            using HWFC_EN = Field<17, 1>;    // Hardware flow control enable This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) When Hardware flow control is enabled, the meaning of the TXFIFOE and RXFIFOF flags change, please see SDMMC status register definition in Section56.8.11.
            using DDR = Field<18, 1>;    // Data rate signaling selection This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) DDR rate shall only be selected with 4-bit or 8-bit wide bus mode. (WIDBUS &gt; 00). DDR = 1 has no effect when WIDBUS = 00 (1-bit wide bus). DDR rate shall only be selected with clock division &gt;1. (CLKDIV &gt; 0)
            using BUSSPEED = Field<19, 1>;    // Bus speed mode selection between DS, HS, SDR12, SDR25 and SDR50, DDR50, SDR104. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
            using SELCLKRX = Field<20, 2>;    // Receive clock selection. These bits can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
        };

        // The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message.
        struct ARGR : public Register<0x52007008> {
            using CMDARG = Field<0, 32>;    // Command argument. These bits can only be written by firmware when CPSM is disabled (CPSMEN = 0). Command argument sent to a card as part of a command message. If a command contains an argument, it must be loaded into this register before writing a command to the command register.
        };

        // The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM).
        struct CMDR : public Register<0x5200700c> {
            using CMDINDEX = Field<0, 6>;    // Command index. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). The command index is sent to the card as part of a command message.
            using CMDTRANS = Field<6, 1>;    // The CPSM treats the command as a data transfer command, stops the interrupt period, and signals DataEnable to the DPSM This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues an end of interrupt period and issues DataEnable signal to the DPSM when the command is sent.
            using CMDSTOP = Field<7, 1>;    // The CPSM treats the command as a Stop Transmission command and signals Abort to the DPSM. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues the Abort signal to the DPSM when the command is sent.
            using WAITRESP = Field<8, 2>;    // Wait for response bits. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). They are used to configure whether the CPSM is to wait for a response, and if yes, which kind of response.
            using WAITINT = Field<10, 1>;    // CPSM waits for interrupt request. If this bit is set, the CPSM disables command timeout and waits for an card interrupt request (Response). If this bit is cleared in the CPSM Wait state, will cause the abort of the interrupt mode.
            using WAITPEND = Field<11, 1>;    // CPSM Waits for end of data transfer (CmdPend internal signal) from DPSM. This bit when set, the CPSM waits for the end of data transfer trigger before it starts sending a command. WAITPEND is only taken into account when DTMODE = MMC stream data transfer, WIDBUS = 1-bit wide bus mode, DPSMACT = 1 and DTDIR = from host to card.
            using CPSMEN = Field<12, 1>;    // Command path state machine (CPSM) Enable bit This bit is written 1 by firmware, and cleared by hardware when the CPSM enters the Idle state. If this bit is set, the CPSM is enabled. When DTEN = 1, no command will be transfered nor boot procedure will be started. CPSMEN is cleared to 0.
            using DTHOLD = Field<13, 1>;    // Hold new data block transmission and reception in the DPSM. If this bit is set, the DPSM will not move from the Wait_S state to the Send state or from the Wait_R state to the Receive state.
            using BOOTMODE = Field<14, 1>;    // Select the boot mode procedure to be used. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0)
            using BOOTEN = Field<15, 1>;    // Enable boot mode procedure.
            using CMDSUSPEND = Field<16, 1>;    // The CPSM treats the command as a Suspend or Resume command and signals interrupt period start/end. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). CMDSUSPEND = 1 and CMDTRANS = 0 Suspend command, start interrupt period when response bit BS=0. CMDSUSPEND = 1 and CMDTRANS = 1 Resume command with data, end interrupt period when response bit DF=1.
        };

        // The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
        struct RESP1R : public RegisterReadOnly<0x52007014> {
            using CARDSTATUS1 = Field<0, 32>;    // see Table 432
        };

        // The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
        struct RESP2R : public RegisterReadOnly<0x52007018> {
            using CARDSTATUS2 = Field<0, 32>;    // see Table404.
        };

        // The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
        struct RESP3R : public RegisterReadOnly<0x5200701c> {
            using CARDSTATUS3 = Field<0, 32>;    // see Table404.
        };

        // The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
        struct RESP4R : public RegisterReadOnly<0x52007020> {
            using CARDSTATUS4 = Field<0, 32>;    // see Table404.
        };

        // The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_R or Busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set.
        struct DTIMER : public Register<0x52007024> {
            using DATATIME = Field<0, 32>;    // Data and R1b busy timeout period This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). Data and R1b busy timeout period expressed in card bus clock periods.
        };

        // The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts.
        struct DLENR : public Register<0x52007028> {
            using DATALENGTH = Field<0, 25>;    // Data length value This register can only be written by firmware when DPSM is inactive (DPSMACT = 0). Number of data bytes to be transferred. When DDR = 1 DATALENGTH is truncated to a multiple of 2. (The last odd byte is not transfered) When DATALENGTH = 0 no data will be transfered, when requested by a CPSMEN and CMDTRANS = 1 also no command will be transfered. DTEN and CPSMEN are cleared to 0.
        };

        // The SDMMC_DCTRL register control the data path state machine (DPSM).
        struct DCTRL : public Register<0x5200702c> {
            using DTEN = Field<0, 1>;    // Data transfer enable bit This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). This bit is cleared by Hardware when data transfer completes. This bit shall only be used to transfer data when no associated data transfer command is used, i.e. shall not be used with SD or eMMC cards.
            using DTDIR = Field<1, 1>;    // Data transfer direction selection This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
            using DTMODE = Field<2, 2>;    // Data transfer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
            using DBLOCKSIZE = Field<4, 4>;    // Data block size This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). Define the data block length when the block data transfer mode is selected: When DATALENGTH is not a multiple of DBLOCKSIZE, the transfered data is truncated at a multiple of DBLOCKSIZE. (Any remain data will not be transfered.) When DDR = 1, DBLOCKSIZE = 0000 shall not be used. (No data will be transfered)
            using RWSTART = Field<8, 1>;    // Read wait start. If this bit is set, read wait operation starts.
            using RWSTOP = Field<9, 1>;    // Read wait stop This bit is written by firmware and auto cleared by hardware when the DPSM moves from the READ_WAIT state to the WAIT_R or IDLE state.
            using RWMOD = Field<10, 1>;    // Read wait mode. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
            using SDIOEN = Field<11, 1>;    // SD I/O interrupt enable functions This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). If this bit is set, the DPSM enables the SD I/O card specific interrupt operation.
            using BOOTACKEN = Field<12, 1>;    // Enable the reception of the boot acknowledgment. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
            using FIFORST = Field<13, 1>;    // FIFO reset, will flush any remaining data. This bit can only be written by firmware when IDMAEN= 0 and DPSM is active (DPSMACT = 1). This bit will only take effect when a transfer error or transfer hold occurs.
        };

        // The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the Idle state to the Wait_R or Wait_S state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the Idle state and when there has been no error, the data status end flag (DATAEND) is set.
        struct DCNTR : public RegisterReadOnly<0x52007030> {
            using DATACOUNT = Field<0, 25>;    // Data count value When read, the number of remaining data bytes to be transferred is returned. Write has no effect.
        };

        // The SDMMC_STAR register is a read-only register. It contains two types of flag:Static flags (bits [29,21,11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt Clear register (see SDMMC_ICR)Dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO)
        struct STAR : public RegisterReadOnly<0x52007034> {
            using CCRCFAIL = Field<0, 1>;    // Command response received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using DCRCFAIL = Field<1, 1>;    // Data block sent/received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using CTIMEOUT = Field<2, 1>;    // Command response timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. The Command Timeout period has a fixed value of 64 SDMMC_CK clock periods.
            using DTIMEOUT = Field<3, 1>;    // Data timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using TXUNDERR = Field<4, 1>;    // Transmit FIFO underrun error or IDMA read transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using RXOVERR = Field<5, 1>;    // Received FIFO overrun error or IDMA write transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using CMDREND = Field<6, 1>;    // Command response received (CRC check passed, or no CRC). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using CMDSENT = Field<7, 1>;    // Command sent (no response required). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using DATAEND = Field<8, 1>;    // Data transfer ended correctly. (data counter, DATACOUNT is zero and no errors occur). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using DHOLD = Field<9, 1>;    // Data transfer Hold. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using DBCKEND = Field<10, 1>;    // Data block sent/received. (CRC check passed) and DPSM moves to the READWAIT state. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using DABORT = Field<11, 1>;    // Data transfer aborted by CMD12. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using DPSMACT = Field<12, 1>;    // Data path state machine active, i.e. not in Idle state. This is a hardware status flag only, does not generate an interrupt.
            using CPSMACT = Field<13, 1>;    // Command path state machine active, i.e. not in Idle state. This is a hardware status flag only, does not generate an interrupt.
            using TXFIFOHE = Field<14, 1>;    // Transmit FIFO half empty At least half the number of words can be written into the FIFO. This bit is cleared when the FIFO becomes half+1 full.
            using RXFIFOHF = Field<15, 1>;    // Receive FIFO half full There are at least half the number of words in the FIFO. This bit is cleared when the FIFO becomes half+1 empty.
            using TXFIFOF = Field<16, 1>;    // Transmit FIFO full This is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes empty.
            using RXFIFOF = Field<17, 1>;    // Receive FIFO full This bit is cleared when one FIFO location becomes empty.
            using TXFIFOE = Field<18, 1>;    // Transmit FIFO empty This bit is cleared when one FIFO location becomes full.
            using RXFIFOE = Field<19, 1>;    // Receive FIFO empty This is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes full.
            using BUSYD0 = Field<20, 1>;    // Inverted value of SDMMC_D0 line (Busy), sampled at the end of a CMD response and a second time 2 SDMMC_CK cycles after the CMD response. This bit is reset to not busy when the SDMMCD0 line changes from busy to not busy. This bit does not signal busy due to data transfer. This is a hardware status flag only, it does not generate an interrupt.
            using BUSYD0END = Field<21, 1>;    // end of SDMMC_D0 Busy following a CMD response detected. This indicates only end of busy following a CMD response. This bit does not signal busy due to data transfer. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using SDIOIT = Field<22, 1>;    // SDIO interrupt received. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using ACKFAIL = Field<23, 1>;    // Boot acknowledgment received (boot acknowledgment check fail). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using ACKTIMEOUT = Field<24, 1>;    // Boot acknowledgment timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using VSWEND = Field<25, 1>;    // Voltage switch critical timing section completion. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using CKSTOP = Field<26, 1>;    // SDMMC_CK stopped in Voltage switch procedure. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using IDMATE = Field<27, 1>;    // IDMA transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using IDMABTC = Field<28, 1>;    // IDMA buffer transfer complete. interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        };

        // The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register.
        struct ICR : public Register<0x52007038> {
            using CCRCFAILC = Field<0, 1>;    // CCRCFAIL flag clear bit Set by software to clear the CCRCFAIL flag.
            using DCRCFAILC = Field<1, 1>;    // DCRCFAIL flag clear bit Set by software to clear the DCRCFAIL flag.
            using CTIMEOUTC = Field<2, 1>;    // CTIMEOUT flag clear bit Set by software to clear the CTIMEOUT flag.
            using DTIMEOUTC = Field<3, 1>;    // DTIMEOUT flag clear bit Set by software to clear the DTIMEOUT flag.
            using TXUNDERRC = Field<4, 1>;    // TXUNDERR flag clear bit Set by software to clear TXUNDERR flag.
            using RXOVERRC = Field<5, 1>;    // RXOVERR flag clear bit Set by software to clear the RXOVERR flag.
            using CMDRENDC = Field<6, 1>;    // CMDREND flag clear bit Set by software to clear the CMDREND flag.
            using CMDSENTC = Field<7, 1>;    // CMDSENT flag clear bit Set by software to clear the CMDSENT flag.
            using DATAENDC = Field<8, 1>;    // DATAEND flag clear bit Set by software to clear the DATAEND flag.
            using DHOLDC = Field<9, 1>;    // DHOLD flag clear bit Set by software to clear the DHOLD flag.
            using DBCKENDC = Field<10, 1>;    // DBCKEND flag clear bit Set by software to clear the DBCKEND flag.
            using DABORTC = Field<11, 1>;    // DABORT flag clear bit Set by software to clear the DABORT flag.
            using BUSYD0ENDC = Field<21, 1>;    // BUSYD0END flag clear bit Set by software to clear the BUSYD0END flag.
            using SDIOITC = Field<22, 1>;    // SDIOIT flag clear bit Set by software to clear the SDIOIT flag.
            using ACKFAILC = Field<23, 1>;    // ACKFAIL flag clear bit Set by software to clear the ACKFAIL flag.
            using ACKTIMEOUTC = Field<24, 1>;    // ACKTIMEOUT flag clear bit Set by software to clear the ACKTIMEOUT flag.
            using VSWENDC = Field<25, 1>;    // VSWEND flag clear bit Set by software to clear the VSWEND flag.
            using CKSTOPC = Field<26, 1>;    // CKSTOP flag clear bit Set by software to clear the CKSTOP flag.
            using IDMATEC = Field<27, 1>;    // IDMA transfer error clear bit Set by software to clear the IDMATE flag.
            using IDMABTCC = Field<28, 1>;    // IDMA buffer transfer complete clear bit Set by software to clear the IDMABTC flag.
        };

        // The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1.
        struct MASKR : public Register<0x5200703c> {
            using CCRCFAILIE = Field<0, 1>;    // Command CRC fail interrupt enable Set and cleared by software to enable/disable interrupt caused by command CRC failure.
            using DCRCFAILIE = Field<1, 1>;    // Data CRC fail interrupt enable Set and cleared by software to enable/disable interrupt caused by data CRC failure.
            using CTIMEOUTIE = Field<2, 1>;    // Command timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by command timeout.
            using DTIMEOUTIE = Field<3, 1>;    // Data timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by data timeout.
            using TXUNDERRIE = Field<4, 1>;    // Tx FIFO underrun error interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO underrun error.
            using RXOVERRIE = Field<5, 1>;    // Rx FIFO overrun error interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO overrun error.
            using CMDRENDIE = Field<6, 1>;    // Command response received interrupt enable Set and cleared by software to enable/disable interrupt caused by receiving command response.
            using CMDSENTIE = Field<7, 1>;    // Command sent interrupt enable Set and cleared by software to enable/disable interrupt caused by sending command.
            using DATAENDIE = Field<8, 1>;    // Data end interrupt enable Set and cleared by software to enable/disable interrupt caused by data end.
            using DHOLDIE = Field<9, 1>;    // Data hold interrupt enable Set and cleared by software to enable/disable the interrupt generated when sending new data is hold in the DPSM Wait_S state.
            using DBCKENDIE = Field<10, 1>;    // Data block end interrupt enable Set and cleared by software to enable/disable interrupt caused by data block end.
            using DABORTIE = Field<11, 1>;    // Data transfer aborted interrupt enable Set and cleared by software to enable/disable interrupt caused by a data transfer being aborted.
            using TXFIFOHEIE = Field<14, 1>;    // Tx FIFO half empty interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO half empty.
            using RXFIFOHFIE = Field<15, 1>;    // Rx FIFO half full interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO half full.
            using RXFIFOFIE = Field<17, 1>;    // Rx FIFO full interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO full.
            using TXFIFOEIE = Field<18, 1>;    // Tx FIFO empty interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO empty.
            using BUSYD0ENDIE = Field<21, 1>;    // BUSYD0END interrupt enable Set and cleared by software to enable/disable the interrupt generated when SDMMC_D0 signal changes from busy to NOT busy following a CMD response.
            using SDIOITIE = Field<22, 1>;    // SDIO mode interrupt received interrupt enable Set and cleared by software to enable/disable the interrupt generated when receiving the SDIO mode interrupt.
            using ACKFAILIE = Field<23, 1>;    // Acknowledgment Fail interrupt enable Set and cleared by software to enable/disable interrupt caused by acknowledgment Fail.
            using ACKTIMEOUTIE = Field<24, 1>;    // Acknowledgment timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by acknowledgment timeout.
            using VSWENDIE = Field<25, 1>;    // Voltage switch critical timing section completion interrupt enable Set and cleared by software to enable/disable the interrupt generated when voltage switch critical timing section completion.
            using CKSTOPIE = Field<26, 1>;    // Voltage Switch clock stopped interrupt enable Set and cleared by software to enable/disable interrupt caused by Voltage Switch clock stopped.
            using IDMABTCIE = Field<28, 1>;    // IDMA buffer transfer complete interrupt enable Set and cleared by software to enable/disable the interrupt generated when the IDMA has transferred all data belonging to a memory buffer.
        };

        // The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_Ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set.
        struct ACKTIMER : public Register<0x52007040> {
            using ACKTIME = Field<0, 25>;    // Boot acknowledgment timeout period This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). Boot acknowledgment timeout period expressed in card bus clock periods.
        };

        // The receive and transmit FIFOs can be read or written as 32-bit wide registers. The FIFOs contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.
        struct IDMACTRLR : public Register<0x52007050> {
            using IDMAEN = Field<0, 1>;    // IDMA enable This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
            using IDMABMODE = Field<1, 1>;    // Buffer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
            using IDMABACT = Field<2, 1>;    // Double buffer mode active buffer indication This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). When IDMA is enabled this bit is toggled by hardware.
        };

        // The SDMMC_IDMABSIZER register contains the buffers size when in double buffer configuration.
        struct IDMABSIZER : public Register<0x52007054> {
            using IDMABNDT = Field<5, 8>;    // Number of transfers per buffer. This 8-bit value shall be multiplied by 8 to get the size of the buffer in 32-bit words and by 32 to get the size of the buffer in bytes. Example: IDMABNDT = 0x01: buffer size = 8 words = 32 bytes. These bits can only be written by firmware when DPSM is inactive (DPSMACT = 0).
        };

        // The SDMMC_IDMABASE0R register contains the memory buffer base address in single buffer configuration and the buffer 0 base address in double buffer configuration.
        struct IDMABASE0R : public Register<0x52007058> {
            using IDMABASE0 = Field<0, 32>;    // Buffer 0 memory base address bits [31:2], shall be word aligned (bit [1:0] are always 0 and read only). This register can be written by firmware when DPSM is inactive (DPSMACT = 0), and can dynamically be written by firmware when DPSM active (DPSMACT = 1) and memory buffer 0 is inactive (IDMABACT = 1).
        };

        // The SDMMC_IDMABASE1R register contains the double buffer configuration second buffer memory base address.
        struct IDMABASE1R : public Register<0x5200705c> {
            using IDMABASE1 = Field<0, 32>;    // Buffer 1 memory base address, shall be word aligned (bit [1:0] are always 0 and read only). This register can be written by firmware when DPSM is inactive (DPSMACT = 0), and can dynamically be written by firmware when DPSM active (DPSMACT = 1) and memory buffer 1 is inactive (IDMABACT = 0).
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct FIFOR : public Register<0x52007080> {
            using FIFODATA = Field<0, 32>;    // Receive and transmit FIFO data This register can only be read or written by firmware when the DPSM is active (DPSMACT=1). The FIFO data occupies 16 entries of 32-bit words.
        };

        // SDMMC IP version register
        struct VER : public RegisterReadOnly<0x520073f4> {
            using MINREV = Field<0, 4>;    // IP minor revision number.
            using MAJREV = Field<4, 4>;    // IP major revision number.
        };

        // SDMMC IP identification register
        struct ID : public RegisterReadOnly<0x520073f8> {
            using IP_ID = Field<0, 32>;    // SDMMC IP identification.
        };

        // SDMMC command response register
        struct RESPCMDR : public RegisterReadOnly<0x52007010> {
            using RESPCMD = Field<0, 6>;    // Response command index
        };

    };

    // SDMMC1
    struct SDMMC2 {
        // SDMMC power control register
        struct POWER : public Register<0x48022400> {
            using PWRCTRL = Field<0, 2>;    // SDMMC state control bits. These bits can only be written when the SDMMC is not in the power-on state (PWRCTRL?11). These bits are used to define the functional state of the SDMMC signals: Any further write will be ignored, PWRCTRL value will keep 11.
            using VSWITCH = Field<2, 1>;    // Voltage switch sequence start. This bit is used to start the timing critical section of the voltage switch sequence:
            using VSWITCHEN = Field<3, 1>;    // Voltage switch procedure enable. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). This bit is used to stop the SDMMC_CK after the voltage switch command response:
            using DIRPOL = Field<4, 1>;    // Data and command direction signals polarity selection. This bit can only be written when the SDMMC is in the power-off state (PWRCTRL = 00).
        };

        // The SDMMC_CLKCR register controls the SDMMC_CK output clock, the SDMMC_RX_CLK receive clock, and the bus width.
        struct CLKCR : public Register<0x48022404> {
            using CLKDIV = Field<0, 10>;    // Clock divide factor This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). This field defines the divide factor between the input clock (SDMMCCLK) and the output clock (SDMMC_CK): SDMMC_CK frequency = SDMMCCLK / [2 * CLKDIV]. 0xx: etc.. xxx: etc..
            using PWRSAV = Field<12, 1>;    // Power saving configuration bit This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) For power saving, the SDMMC_CK clock output can be disabled when the bus is idle by setting PWRSAV:
            using WIDBUS = Field<14, 2>;    // Wide bus mode enable bit This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
            using NEGEDGE = Field<16, 1>;    // SDMMC_CK dephasing selection bit for data and Command. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). When clock division = 1 (CLKDIV = 0), this bit has no effect. Data and Command change on SDMMC_CK falling edge. When clock division &gt;1 (CLKDIV &gt; 0) &amp; DDR = 0: - SDMMC_CK edge occurs on SDMMCCLK rising edge. When clock division >1 (CLKDIV > 0) & DDR = 1: - Data changed on the SDMMCCLK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. - Data changed on the SDMMC_CK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge.
            using HWFC_EN = Field<17, 1>;    // Hardware flow control enable This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) When Hardware flow control is enabled, the meaning of the TXFIFOE and RXFIFOF flags change, please see SDMMC status register definition in Section56.8.11.
            using DDR = Field<18, 1>;    // Data rate signaling selection This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) DDR rate shall only be selected with 4-bit or 8-bit wide bus mode. (WIDBUS &gt; 00). DDR = 1 has no effect when WIDBUS = 00 (1-bit wide bus). DDR rate shall only be selected with clock division &gt;1. (CLKDIV &gt; 0)
            using BUSSPEED = Field<19, 1>;    // Bus speed mode selection between DS, HS, SDR12, SDR25 and SDR50, DDR50, SDR104. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
            using SELCLKRX = Field<20, 2>;    // Receive clock selection. These bits can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
        };

        // The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message.
        struct ARGR : public Register<0x48022408> {
            using CMDARG = Field<0, 32>;    // Command argument. These bits can only be written by firmware when CPSM is disabled (CPSMEN = 0). Command argument sent to a card as part of a command message. If a command contains an argument, it must be loaded into this register before writing a command to the command register.
        };

        // The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM).
        struct CMDR : public Register<0x4802240c> {
            using CMDINDEX = Field<0, 6>;    // Command index. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). The command index is sent to the card as part of a command message.
            using CMDTRANS = Field<6, 1>;    // The CPSM treats the command as a data transfer command, stops the interrupt period, and signals DataEnable to the DPSM This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues an end of interrupt period and issues DataEnable signal to the DPSM when the command is sent.
            using CMDSTOP = Field<7, 1>;    // The CPSM treats the command as a Stop Transmission command and signals Abort to the DPSM. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues the Abort signal to the DPSM when the command is sent.
            using WAITRESP = Field<8, 2>;    // Wait for response bits. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). They are used to configure whether the CPSM is to wait for a response, and if yes, which kind of response.
            using WAITINT = Field<10, 1>;    // CPSM waits for interrupt request. If this bit is set, the CPSM disables command timeout and waits for an card interrupt request (Response). If this bit is cleared in the CPSM Wait state, will cause the abort of the interrupt mode.
            using WAITPEND = Field<11, 1>;    // CPSM Waits for end of data transfer (CmdPend internal signal) from DPSM. This bit when set, the CPSM waits for the end of data transfer trigger before it starts sending a command. WAITPEND is only taken into account when DTMODE = MMC stream data transfer, WIDBUS = 1-bit wide bus mode, DPSMACT = 1 and DTDIR = from host to card.
            using CPSMEN = Field<12, 1>;    // Command path state machine (CPSM) Enable bit This bit is written 1 by firmware, and cleared by hardware when the CPSM enters the Idle state. If this bit is set, the CPSM is enabled. When DTEN = 1, no command will be transfered nor boot procedure will be started. CPSMEN is cleared to 0.
            using DTHOLD = Field<13, 1>;    // Hold new data block transmission and reception in the DPSM. If this bit is set, the DPSM will not move from the Wait_S state to the Send state or from the Wait_R state to the Receive state.
            using BOOTMODE = Field<14, 1>;    // Select the boot mode procedure to be used. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0)
            using BOOTEN = Field<15, 1>;    // Enable boot mode procedure.
            using CMDSUSPEND = Field<16, 1>;    // The CPSM treats the command as a Suspend or Resume command and signals interrupt period start/end. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). CMDSUSPEND = 1 and CMDTRANS = 0 Suspend command, start interrupt period when response bit BS=0. CMDSUSPEND = 1 and CMDTRANS = 1 Resume command with data, end interrupt period when response bit DF=1.
        };

        // The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
        struct RESP1R : public RegisterReadOnly<0x48022414> {
            using CARDSTATUS1 = Field<0, 32>;    // see Table 432
        };

        // The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
        struct RESP2R : public RegisterReadOnly<0x48022418> {
            using CARDSTATUS2 = Field<0, 32>;    // see Table404.
        };

        // The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
        struct RESP3R : public RegisterReadOnly<0x4802241c> {
            using CARDSTATUS3 = Field<0, 32>;    // see Table404.
        };

        // The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
        struct RESP4R : public RegisterReadOnly<0x48022420> {
            using CARDSTATUS4 = Field<0, 32>;    // see Table404.
        };

        // The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_R or Busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set.
        struct DTIMER : public Register<0x48022424> {
            using DATATIME = Field<0, 32>;    // Data and R1b busy timeout period This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). Data and R1b busy timeout period expressed in card bus clock periods.
        };

        // The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts.
        struct DLENR : public Register<0x48022428> {
            using DATALENGTH = Field<0, 25>;    // Data length value This register can only be written by firmware when DPSM is inactive (DPSMACT = 0). Number of data bytes to be transferred. When DDR = 1 DATALENGTH is truncated to a multiple of 2. (The last odd byte is not transfered) When DATALENGTH = 0 no data will be transfered, when requested by a CPSMEN and CMDTRANS = 1 also no command will be transfered. DTEN and CPSMEN are cleared to 0.
        };

        // The SDMMC_DCTRL register control the data path state machine (DPSM).
        struct DCTRL : public Register<0x4802242c> {
            using DTEN = Field<0, 1>;    // Data transfer enable bit This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). This bit is cleared by Hardware when data transfer completes. This bit shall only be used to transfer data when no associated data transfer command is used, i.e. shall not be used with SD or eMMC cards.
            using DTDIR = Field<1, 1>;    // Data transfer direction selection This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
            using DTMODE = Field<2, 2>;    // Data transfer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
            using DBLOCKSIZE = Field<4, 4>;    // Data block size This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). Define the data block length when the block data transfer mode is selected: When DATALENGTH is not a multiple of DBLOCKSIZE, the transfered data is truncated at a multiple of DBLOCKSIZE. (Any remain data will not be transfered.) When DDR = 1, DBLOCKSIZE = 0000 shall not be used. (No data will be transfered)
            using RWSTART = Field<8, 1>;    // Read wait start. If this bit is set, read wait operation starts.
            using RWSTOP = Field<9, 1>;    // Read wait stop This bit is written by firmware and auto cleared by hardware when the DPSM moves from the READ_WAIT state to the WAIT_R or IDLE state.
            using RWMOD = Field<10, 1>;    // Read wait mode. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
            using SDIOEN = Field<11, 1>;    // SD I/O interrupt enable functions This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). If this bit is set, the DPSM enables the SD I/O card specific interrupt operation.
            using BOOTACKEN = Field<12, 1>;    // Enable the reception of the boot acknowledgment. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
            using FIFORST = Field<13, 1>;    // FIFO reset, will flush any remaining data. This bit can only be written by firmware when IDMAEN= 0 and DPSM is active (DPSMACT = 1). This bit will only take effect when a transfer error or transfer hold occurs.
        };

        // The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the Idle state to the Wait_R or Wait_S state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the Idle state and when there has been no error, the data status end flag (DATAEND) is set.
        struct DCNTR : public RegisterReadOnly<0x48022430> {
            using DATACOUNT = Field<0, 25>;    // Data count value When read, the number of remaining data bytes to be transferred is returned. Write has no effect.
        };

        // The SDMMC_STAR register is a read-only register. It contains two types of flag:Static flags (bits [29,21,11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt Clear register (see SDMMC_ICR)Dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO)
        struct STAR : public RegisterReadOnly<0x48022434> {
            using CCRCFAIL = Field<0, 1>;    // Command response received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using DCRCFAIL = Field<1, 1>;    // Data block sent/received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using CTIMEOUT = Field<2, 1>;    // Command response timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. The Command Timeout period has a fixed value of 64 SDMMC_CK clock periods.
            using DTIMEOUT = Field<3, 1>;    // Data timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using TXUNDERR = Field<4, 1>;    // Transmit FIFO underrun error or IDMA read transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using RXOVERR = Field<5, 1>;    // Received FIFO overrun error or IDMA write transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using CMDREND = Field<6, 1>;    // Command response received (CRC check passed, or no CRC). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using CMDSENT = Field<7, 1>;    // Command sent (no response required). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using DATAEND = Field<8, 1>;    // Data transfer ended correctly. (data counter, DATACOUNT is zero and no errors occur). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using DHOLD = Field<9, 1>;    // Data transfer Hold. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using DBCKEND = Field<10, 1>;    // Data block sent/received. (CRC check passed) and DPSM moves to the READWAIT state. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using DABORT = Field<11, 1>;    // Data transfer aborted by CMD12. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using DPSMACT = Field<12, 1>;    // Data path state machine active, i.e. not in Idle state. This is a hardware status flag only, does not generate an interrupt.
            using CPSMACT = Field<13, 1>;    // Command path state machine active, i.e. not in Idle state. This is a hardware status flag only, does not generate an interrupt.
            using TXFIFOHE = Field<14, 1>;    // Transmit FIFO half empty At least half the number of words can be written into the FIFO. This bit is cleared when the FIFO becomes half+1 full.
            using RXFIFOHF = Field<15, 1>;    // Receive FIFO half full There are at least half the number of words in the FIFO. This bit is cleared when the FIFO becomes half+1 empty.
            using TXFIFOF = Field<16, 1>;    // Transmit FIFO full This is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes empty.
            using RXFIFOF = Field<17, 1>;    // Receive FIFO full This bit is cleared when one FIFO location becomes empty.
            using TXFIFOE = Field<18, 1>;    // Transmit FIFO empty This bit is cleared when one FIFO location becomes full.
            using RXFIFOE = Field<19, 1>;    // Receive FIFO empty This is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes full.
            using BUSYD0 = Field<20, 1>;    // Inverted value of SDMMC_D0 line (Busy), sampled at the end of a CMD response and a second time 2 SDMMC_CK cycles after the CMD response. This bit is reset to not busy when the SDMMCD0 line changes from busy to not busy. This bit does not signal busy due to data transfer. This is a hardware status flag only, it does not generate an interrupt.
            using BUSYD0END = Field<21, 1>;    // end of SDMMC_D0 Busy following a CMD response detected. This indicates only end of busy following a CMD response. This bit does not signal busy due to data transfer. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using SDIOIT = Field<22, 1>;    // SDIO interrupt received. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using ACKFAIL = Field<23, 1>;    // Boot acknowledgment received (boot acknowledgment check fail). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using ACKTIMEOUT = Field<24, 1>;    // Boot acknowledgment timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using VSWEND = Field<25, 1>;    // Voltage switch critical timing section completion. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using CKSTOP = Field<26, 1>;    // SDMMC_CK stopped in Voltage switch procedure. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using IDMATE = Field<27, 1>;    // IDMA transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
            using IDMABTC = Field<28, 1>;    // IDMA buffer transfer complete. interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        };

        // The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register.
        struct ICR : public Register<0x48022438> {
            using CCRCFAILC = Field<0, 1>;    // CCRCFAIL flag clear bit Set by software to clear the CCRCFAIL flag.
            using DCRCFAILC = Field<1, 1>;    // DCRCFAIL flag clear bit Set by software to clear the DCRCFAIL flag.
            using CTIMEOUTC = Field<2, 1>;    // CTIMEOUT flag clear bit Set by software to clear the CTIMEOUT flag.
            using DTIMEOUTC = Field<3, 1>;    // DTIMEOUT flag clear bit Set by software to clear the DTIMEOUT flag.
            using TXUNDERRC = Field<4, 1>;    // TXUNDERR flag clear bit Set by software to clear TXUNDERR flag.
            using RXOVERRC = Field<5, 1>;    // RXOVERR flag clear bit Set by software to clear the RXOVERR flag.
            using CMDRENDC = Field<6, 1>;    // CMDREND flag clear bit Set by software to clear the CMDREND flag.
            using CMDSENTC = Field<7, 1>;    // CMDSENT flag clear bit Set by software to clear the CMDSENT flag.
            using DATAENDC = Field<8, 1>;    // DATAEND flag clear bit Set by software to clear the DATAEND flag.
            using DHOLDC = Field<9, 1>;    // DHOLD flag clear bit Set by software to clear the DHOLD flag.
            using DBCKENDC = Field<10, 1>;    // DBCKEND flag clear bit Set by software to clear the DBCKEND flag.
            using DABORTC = Field<11, 1>;    // DABORT flag clear bit Set by software to clear the DABORT flag.
            using BUSYD0ENDC = Field<21, 1>;    // BUSYD0END flag clear bit Set by software to clear the BUSYD0END flag.
            using SDIOITC = Field<22, 1>;    // SDIOIT flag clear bit Set by software to clear the SDIOIT flag.
            using ACKFAILC = Field<23, 1>;    // ACKFAIL flag clear bit Set by software to clear the ACKFAIL flag.
            using ACKTIMEOUTC = Field<24, 1>;    // ACKTIMEOUT flag clear bit Set by software to clear the ACKTIMEOUT flag.
            using VSWENDC = Field<25, 1>;    // VSWEND flag clear bit Set by software to clear the VSWEND flag.
            using CKSTOPC = Field<26, 1>;    // CKSTOP flag clear bit Set by software to clear the CKSTOP flag.
            using IDMATEC = Field<27, 1>;    // IDMA transfer error clear bit Set by software to clear the IDMATE flag.
            using IDMABTCC = Field<28, 1>;    // IDMA buffer transfer complete clear bit Set by software to clear the IDMABTC flag.
        };

        // The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1.
        struct MASKR : public Register<0x4802243c> {
            using CCRCFAILIE = Field<0, 1>;    // Command CRC fail interrupt enable Set and cleared by software to enable/disable interrupt caused by command CRC failure.
            using DCRCFAILIE = Field<1, 1>;    // Data CRC fail interrupt enable Set and cleared by software to enable/disable interrupt caused by data CRC failure.
            using CTIMEOUTIE = Field<2, 1>;    // Command timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by command timeout.
            using DTIMEOUTIE = Field<3, 1>;    // Data timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by data timeout.
            using TXUNDERRIE = Field<4, 1>;    // Tx FIFO underrun error interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO underrun error.
            using RXOVERRIE = Field<5, 1>;    // Rx FIFO overrun error interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO overrun error.
            using CMDRENDIE = Field<6, 1>;    // Command response received interrupt enable Set and cleared by software to enable/disable interrupt caused by receiving command response.
            using CMDSENTIE = Field<7, 1>;    // Command sent interrupt enable Set and cleared by software to enable/disable interrupt caused by sending command.
            using DATAENDIE = Field<8, 1>;    // Data end interrupt enable Set and cleared by software to enable/disable interrupt caused by data end.
            using DHOLDIE = Field<9, 1>;    // Data hold interrupt enable Set and cleared by software to enable/disable the interrupt generated when sending new data is hold in the DPSM Wait_S state.
            using DBCKENDIE = Field<10, 1>;    // Data block end interrupt enable Set and cleared by software to enable/disable interrupt caused by data block end.
            using DABORTIE = Field<11, 1>;    // Data transfer aborted interrupt enable Set and cleared by software to enable/disable interrupt caused by a data transfer being aborted.
            using TXFIFOHEIE = Field<14, 1>;    // Tx FIFO half empty interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO half empty.
            using RXFIFOHFIE = Field<15, 1>;    // Rx FIFO half full interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO half full.
            using RXFIFOFIE = Field<17, 1>;    // Rx FIFO full interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO full.
            using TXFIFOEIE = Field<18, 1>;    // Tx FIFO empty interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO empty.
            using BUSYD0ENDIE = Field<21, 1>;    // BUSYD0END interrupt enable Set and cleared by software to enable/disable the interrupt generated when SDMMC_D0 signal changes from busy to NOT busy following a CMD response.
            using SDIOITIE = Field<22, 1>;    // SDIO mode interrupt received interrupt enable Set and cleared by software to enable/disable the interrupt generated when receiving the SDIO mode interrupt.
            using ACKFAILIE = Field<23, 1>;    // Acknowledgment Fail interrupt enable Set and cleared by software to enable/disable interrupt caused by acknowledgment Fail.
            using ACKTIMEOUTIE = Field<24, 1>;    // Acknowledgment timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by acknowledgment timeout.
            using VSWENDIE = Field<25, 1>;    // Voltage switch critical timing section completion interrupt enable Set and cleared by software to enable/disable the interrupt generated when voltage switch critical timing section completion.
            using CKSTOPIE = Field<26, 1>;    // Voltage Switch clock stopped interrupt enable Set and cleared by software to enable/disable interrupt caused by Voltage Switch clock stopped.
            using IDMABTCIE = Field<28, 1>;    // IDMA buffer transfer complete interrupt enable Set and cleared by software to enable/disable the interrupt generated when the IDMA has transferred all data belonging to a memory buffer.
        };

        // The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_Ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set.
        struct ACKTIMER : public Register<0x48022440> {
            using ACKTIME = Field<0, 25>;    // Boot acknowledgment timeout period This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). Boot acknowledgment timeout period expressed in card bus clock periods.
        };

        // The receive and transmit FIFOs can be read or written as 32-bit wide registers. The FIFOs contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.
        struct IDMACTRLR : public Register<0x48022450> {
            using IDMAEN = Field<0, 1>;    // IDMA enable This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
            using IDMABMODE = Field<1, 1>;    // Buffer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
            using IDMABACT = Field<2, 1>;    // Double buffer mode active buffer indication This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). When IDMA is enabled this bit is toggled by hardware.
        };

        // The SDMMC_IDMABSIZER register contains the buffers size when in double buffer configuration.
        struct IDMABSIZER : public Register<0x48022454> {
            using IDMABNDT = Field<5, 8>;    // Number of transfers per buffer. This 8-bit value shall be multiplied by 8 to get the size of the buffer in 32-bit words and by 32 to get the size of the buffer in bytes. Example: IDMABNDT = 0x01: buffer size = 8 words = 32 bytes. These bits can only be written by firmware when DPSM is inactive (DPSMACT = 0).
        };

        // The SDMMC_IDMABASE0R register contains the memory buffer base address in single buffer configuration and the buffer 0 base address in double buffer configuration.
        struct IDMABASE0R : public Register<0x48022458> {
            using IDMABASE0 = Field<0, 32>;    // Buffer 0 memory base address bits [31:2], shall be word aligned (bit [1:0] are always 0 and read only). This register can be written by firmware when DPSM is inactive (DPSMACT = 0), and can dynamically be written by firmware when DPSM active (DPSMACT = 1) and memory buffer 0 is inactive (IDMABACT = 1).
        };

        // The SDMMC_IDMABASE1R register contains the double buffer configuration second buffer memory base address.
        struct IDMABASE1R : public Register<0x4802245c> {
            using IDMABASE1 = Field<0, 32>;    // Buffer 1 memory base address, shall be word aligned (bit [1:0] are always 0 and read only). This register can be written by firmware when DPSM is inactive (DPSMACT = 0), and can dynamically be written by firmware when DPSM active (DPSMACT = 1) and memory buffer 1 is inactive (IDMABACT = 0).
        };

        // The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
        struct FIFOR : public Register<0x48022480> {
            using FIFODATA = Field<0, 32>;    // Receive and transmit FIFO data This register can only be read or written by firmware when the DPSM is active (DPSMACT=1). The FIFO data occupies 16 entries of 32-bit words.
        };

        // SDMMC IP version register
        struct VER : public RegisterReadOnly<0x480227f4> {
            using MINREV = Field<0, 4>;    // IP minor revision number.
            using MAJREV = Field<4, 4>;    // IP major revision number.
        };

        // SDMMC IP identification register
        struct ID : public RegisterReadOnly<0x480227f8> {
            using IP_ID = Field<0, 32>;    // SDMMC IP identification.
        };

        // SDMMC command response register
        struct RESPCMDR : public RegisterReadOnly<0x48022410> {
            using RESPCMD = Field<0, 6>;    // Response command index
        };

    };

    // VREFBUF
    struct VREFBUF {
        // VREFBUF control and status register
        struct CSR : public Register<0x58003c00> {
            using ENVR = Field<0, 1>;    // Voltage reference buffer mode enable This bit is used to enable the voltage reference buffer mode.
            using HIZ = Field<1, 1>;    // High impedance mode This bit controls the analog switch to connect or not the VREF+ pin. Refer to Table196: VREF buffer modes for the mode descriptions depending on ENVR bit configuration.
            using VRR = Field<3, 1>;    // Voltage reference buffer ready
            using VRS = Field<4, 3>;    // Voltage reference scale These bits select the value generated by the voltage reference buffer. Other: Reserved
        };

        // VREFBUF calibration control register
        struct CCR : public Register<0x58003c04> {
            using TRIM = Field<0, 6>;    // Trimming code These bits are automatically initialized after reset with the trimming value stored in the Flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage.
        };

    };

    // IWDG
    struct IWDG {
        // Key register
        struct KR : public RegisterWriteOnly<0x58004800> {
            using KEY = Field<0, 16>;    // Key value (write only, read 0x0000) These bits must be written by software at regular intervals with the key value 0xAAAA, otherwise the watchdog generates a reset when the counter reaches 0. Writing the key value 0x5555 to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR registers (see Section23.3.6: Register access protection) Writing the key value CCCCh starts the watchdog (except if the hardware watchdog option is selected)
        };

        // Prescaler register
        struct PR : public Register<0x58004804> {
            using Field = Field<0, 3>;    // Prescaler divider These bits are write access protected see Section23.3.6: Register access protection. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of IWDG_SR must be reset in order to be able to change the prescaler divider. Note: Reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the IWDG_SR register is reset.
        };

        // Reload register
        struct RLR : public Register<0x58004808> {
            using RL = Field<0, 12>;    // Watchdog counter reload value These bits are write access protected see Section23.3.6. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xAAAA is written in the IWDG_KR register. The watchdog counter counts down from this value. The timeout period is a function of this value and the clock prescaler. Refer to the datasheet for the timeout information. The RVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: Reading this register returns the reload value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing on this register. For this reason the value read from this register is valid only when the RVU bit in the IWDG_SR register is reset.
        };

        // Status register
        struct SR : public RegisterReadOnly<0x5800480c> {
            using PVU = Field<0, 1>;    // Watchdog prescaler value update This bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to 5 RC 40 kHz cycles). Prescaler value can be updated only when PVU bit is reset.
            using RVU = Field<1, 1>;    // Watchdog counter reload value update This bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 kHz cycles). Reload value can be updated only when RVU bit is reset.
            using WVU = Field<2, 1>;    // Watchdog counter window value update This bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 kHz cycles). Window value can be updated only when WVU bit is reset. This bit is generated only if generic window = 1
        };

        // Window register
        struct WINR : public Register<0x58004810> {
            using WIN = Field<0, 12>;    // Watchdog counter window value These bits are write access protected see Section23.3.6. These bits contain the high limit of the window value to be compared to the downcounter. To prevent a reset, the downcounter must be reloaded when its value is lower than the window register value and greater than 0x0 The WVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: Reading this register returns the reload value from the VDD voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the IWDG_SR register is reset.
        };

    };

    // WWDG
    struct WWDG {
        // Control register
        struct CR : public Register<0x50003000> {
            using T = Field<0, 7>;    // 7-bit counter (MSB to LSB) These bits contain the value of the watchdog counter. It is decremented every (4096 x 2WDGTB[1:0]) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3F (T6 becomes cleared).
            using WDGA = Field<7, 1>;    // Activation bit This bit is set by software and only cleared by hardware after a reset. When WDGA=1, the watchdog can generate a reset.
        };

        // Configuration register
        struct CFR : public Register<0x50003004> {
            using W = Field<0, 7>;    // 7-bit window value These bits contain the window value to be compared to the downcounter.
            using WDGTB = Field<11, 2>;    // Timer base The time base of the prescaler can be modified as follows:
            using EWI = Field<9, 1>;    // Early wakeup interrupt When set, an interrupt occurs whenever the counter reaches the value 0x40. This interrupt is only cleared by hardware after a reset.
        };

        // Status register
        struct SR : public Register<0x50003008> {
            using EWIF = Field<0, 1>;    // Early wakeup interrupt flag This bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing 0. A write of 1 has no effect. This bit is also set if the interrupt is not enabled.
        };

    };

    // PWR
    struct PWR {
        // PWR control register 1
        struct CR1 : public Register<0x58024800> {
            using LPDS = Field<0, 1>;    // Low-power Deepsleep with SVOS3 (SVOS4 and SVOS5 always use low-power, regardless of the setting of this bit)
            using PVDE = Field<4, 1>;    // Programmable voltage detector enable
            using PLS = Field<5, 3>;    // Programmable voltage detector level selection These bits select the voltage threshold detected by the PVD. Note: Refer to Section Electrical characteristics of the product datasheet for more details.
            using DBP = Field<8, 1>;    // Disable backup domain write protection In reset state, the RCC_BDCR register, the RTC registers (including the backup registers), BREN and MOEN bits in PWR_CR2 register, are protected against parasitic write access. This bit must be set to enable write access to these registers.
            using FLPS = Field<9, 1>;    // Flash low-power mode in DStop mode This bit allows to obtain the best trade-off between low-power consumption and restart time when exiting from DStop mode. When it is set, the Flash memory enters low-power mode when D1 domain is in DStop mode.
            using SVOS = Field<14, 2>;    // System Stop mode voltage scaling selection These bits control the VCORE voltage level in system Stop mode, to obtain the best trade-off between power consumption and performance.
            using AVDEN = Field<16, 1>;    // Peripheral voltage monitor on VDDA enable
            using ALS = Field<17, 2>;    // Analog voltage detector level selection These bits select the voltage threshold detected by the AVD.
        };

        // PWR control status register 1
        struct CSR1 : public RegisterReadOnly<0x58024804> {
            using PVDO = Field<4, 1>;    // Programmable voltage detect output This bit is set and cleared by hardware. It is valid only if the PVD has been enabled by the PVDE bit. Note: since the PVD is disabled in Standby mode, this bit is equal to 0 after Standby or reset until the PVDE bit is set.
            using ACTVOSRDY = Field<13, 1>;    // Voltage levels ready bit for currently used VOS and SDLEVEL This bit is set to 1 by hardware when the voltage regulator and the SD converter are both disabled and Bypass mode is selected in PWR control register 3 (PWR_CR3).
            using ACTVOS = Field<14, 2>;    // VOS currently applied for VCORE voltage scaling selection. These bits reflect the last VOS value applied to the PMU.
            using AVDO = Field<16, 1>;    // Analog voltage detector output on VDDA This bit is set and cleared by hardware. It is valid only if AVD on VDDA is enabled by the AVDEN bit. Note: Since the AVD is disabled in Standby mode, this bit is equal to 0 after Standby or reset until the AVDEN bit is set.
        };

        // This register is not reset by wakeup from Standby mode, RESET signal and VDD POR. It is only reset by VSW POR and VSWRST reset. This register shall not be accessed when VSWRST bit in RCC_BDCR register resets the VSW domain.After reset, PWR_CR2 register is write-protected. Prior to modifying its content, the DBP bit in PWR_CR1 register must be set to disable the write protection.
        struct CR2 : public Register<0x58024808> {
            using BREN = Field<0, 1>;    // Backup regulator enable When set, the Backup regulator (used to maintain the backup RAM content in Standby and VBAT modes) is enabled. If BREN is reset, the backup regulator is switched off. The backup RAM can still be used in Run and Stop modes. However, its content will be lost in Standby and VBAT modes. If BREN is set, the application must wait till the Backup Regulator Ready flag (BRRDY) is set to indicate that the data written into the SRAM will be maintained in Standby and VBAT modes.
            using MONEN = Field<4, 1>;    // VBAT and temperature monitoring enable When set, the VBAT supply and temperature monitoring is enabled.
            using BRRDY = Field<16, 1>;    // Backup regulator ready This bit is set by hardware to indicate that the Backup regulator is ready.
            using VBATL = Field<20, 1>;    // VBAT level monitoring versus low threshold
            using VBATH = Field<21, 1>;    // VBAT level monitoring versus high threshold
            using TEMPL = Field<22, 1>;    // Temperature level monitoring versus low threshold
            using TEMPH = Field<23, 1>;    // Temperature level monitoring versus high threshold
        };

        // Reset only by POR only, not reset by wakeup from Standby mode and RESET pad. The lower byte of this register is written once after POR and shall be written before changing VOS level or ck_sys clock frequency. No limitation applies to the upper bytes.Programming data corresponding to an invalid combination of SDLEVEL, SDEXTHP, SDEN, LDOEN and BYPASS bits (see Table9) will be ignored: data will not be written, the written-once mechanism will lock the register and any further write access will be ignored. The default supply configuration will be kept and the ACTVOSRDY bit in PWR control status register 1 (PWR_CSR1) will go on indicating invalid voltage levels. The system shall be power cycled before writing a new value.
        struct CR3 : public Register<0x5802480c> {
            using BYPASS = Field<0, 1>;    // Power management unit bypass
            using LDOEN = Field<1, 1>;    // Low drop-out regulator enable
            using SCUEN = Field<2, 1>;    // SD converter Enable
            using VBE = Field<8, 1>;    // VBAT charging enable
            using VBRS = Field<9, 1>;    // VBAT charging resistor selection
            using USB33DEN = Field<24, 1>;    // VDD33USB voltage level detector enable.
            using USBREGEN = Field<25, 1>;    // USB regulator enable.
            using USB33RDY = Field<26, 1>;    // USB supply ready.
        };

        // This register allows controlling CPU1 power.
        struct CPUCR : public Register<0x58024810> {
            using PDDS_D1 = Field<0, 1>;    // D1 domain Power Down Deepsleep selection. This bit allows CPU1 to define the Deepsleep mode for D1 domain.
            using PDDS_D2 = Field<1, 1>;    // D2 domain Power Down Deepsleep. This bit allows CPU1 to define the Deepsleep mode for D2 domain.
            using PDDS_D3 = Field<2, 1>;    // System D3 domain Power Down Deepsleep. This bit allows CPU1 to define the Deepsleep mode for System D3 domain.
            using STOPF = Field<5, 1>;    // STOP flag This bit is set by hardware and cleared only by any reset or by setting the CPU1 CSSF bit.
            using SBF = Field<6, 1>;    // System Standby flag This bit is set by hardware and cleared only by a POR (Power-on Reset) or by setting the CPU1 CSSF bit
            using SBF_D1 = Field<7, 1>;    // D1 domain DStandby flag This bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D1 domain is no longer in DStandby mode.
            using SBF_D2 = Field<8, 1>;    // D2 domain DStandby flag This bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D2 domain is no longer in DStandby mode.
            using CSSF = Field<9, 1>;    // Clear D1 domain CPU1 Standby, Stop and HOLD flags (always read as 0) This bit is cleared to 0 by hardware.
            using RUN_D3 = Field<11, 1>;    // Keep system D3 domain in Run mode regardless of the CPU sub-systems modes
        };

        // This register allows controlling D3 domain power.Following reset VOSRDY will be read 1 by software
        struct D3CR : public Register<0x58024818> {
            using VOSRDY = Field<13, 1>;    // VOS Ready bit for VCORE voltage scaling output selection. This bit is set to 1 by hardware when Bypass mode is selected in PWR control register 3 (PWR_CR3).
            using VOS = Field<14, 2>;    // Voltage scaling selection according to performance These bits control the VCORE voltage level and allow to obtains the best trade-off between power consumption and performance: When increasing the performance, the voltage scaling shall be changed before increasing the system frequency. When decreasing performance, the system frequency shall first be decreased before changing the voltage scaling.
        };

        // reset only by system reset, not reset by wakeup from Standby mode5 wait states are required when writing this register (when clearing a WKUPF bit in PWR_WKUPFR, the AHB write access will complete after the WKUPF has been cleared).
        struct WKUPCR : public Register<0x58024820> {
            using WKUPC = Field<0, 6>;    // Clear Wakeup pin flag for WKUP. These bits are always read as 0.
        };

        // reset only by system reset, not reset by wakeup from Standby mode
        struct WKUPFR : public Register<0x58024824> {
            using WKUPF1 = Field<0, 1>;    // Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
            using WKUPF2 = Field<1, 1>;    // Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
            using WKUPF3 = Field<2, 1>;    // Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
            using WKUPF4 = Field<3, 1>;    // Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
            using WKUPF5 = Field<4, 1>;    // Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
            using WKUPF6 = Field<5, 1>;    // Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
        };

        // Reset only by system reset, not reset by wakeup from Standby mode
        struct WKUPEPR : public Register<0x58024828> {
            using WKUPEN1 = Field<0, 1>;    // Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
            using WKUPEN2 = Field<1, 1>;    // Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
            using WKUPEN3 = Field<2, 1>;    // Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
            using WKUPEN4 = Field<3, 1>;    // Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
            using WKUPEN5 = Field<4, 1>;    // Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
            using WKUPEN6 = Field<5, 1>;    // Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
            using WKUPP1 = Field<8, 1>;    // Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
            using WKUPP2 = Field<9, 1>;    // Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
            using WKUPP3 = Field<10, 1>;    // Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
            using WKUPP4 = Field<11, 1>;    // Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
            using WKUPP5 = Field<12, 1>;    // Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
            using WKUPP6 = Field<13, 1>;    // Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
            using WKUPPUPD1 = Field<16, 2>;    // Wakeup pin pull configuration
            using WKUPPUPD2 = Field<18, 2>;    // Wakeup pin pull configuration
            using WKUPPUPD3 = Field<20, 2>;    // Wakeup pin pull configuration
            using WKUPPUPD4 = Field<22, 2>;    // Wakeup pin pull configuration
            using WKUPPUPD5 = Field<24, 2>;    // Wakeup pin pull configuration
            using WKUPPUPD6 = Field<26, 2>;    // Wakeup pin pull configuration for WKUP(truncate(n/2)-7) These bits define the I/O pad pull configuration used when WKUPEN(truncate(n/2)-7) = 1. The associated GPIO port pull configuration shall be set to the same value or to 00. The Wakeup pin pull configuration is kept in Standby mode.
        };

    };

    // Serial peripheral interface
    struct SPI1 {
        // control register 1
        struct CR1 : public Register<0x40013000> {
            using IOLOCK = Field<16, 1>;    // Locking the AF configuration of associated IOs
            using TCRCI = Field<15, 1>;    // CRC calculation initialization pattern control for transmitter
            using RCRCI = Field<14, 1>;    // CRC calculation initialization pattern control for receiver
            using CRC33_17 = Field<13, 1>;    // 32-bit CRC polynomial configuration
            using SSI = Field<12, 1>;    // Internal SS signal input level
            using HDDIR = Field<11, 1>;    // Rx/Tx direction at Half-duplex mode
            using CSUSP = Field<10, 1>;    // Master SUSPend request
            using CSTART = Field<9, 1>;    // Master transfer start
            using MASRX = Field<8, 1>;    // Master automatic SUSP in Receive mode
            using SPE = Field<0, 1>;    // Serial Peripheral Enable
        };

        // control register 2
        struct CR2 : public Register<0x40013004> {
            using TSER = Field<16, 16>;    // Number of data transfer extension to be reload into TSIZE just when a previous
            using TSIZE = Field<0, 16>;    // Number of data at current transfer
        };

        // configuration register 1
        struct CFG1 : public Register<0x40013008> {
            using MBR = Field<28, 3>;    // Master baud rate
            using CRCEN = Field<22, 1>;    // Hardware CRC computation enable
            using CRCSIZE = Field<16, 5>;    // Length of CRC frame to be transacted and compared
            using TXDMAEN = Field<15, 1>;    // Tx DMA stream enable
            using RXDMAEN = Field<14, 1>;    // Rx DMA stream enable
            using UDRDET = Field<11, 2>;    // Detection of underrun condition at slave transmitter
            using UDRCFG = Field<9, 2>;    // Behavior of slave transmitter at underrun condition
            using FTHVL = Field<5, 4>;    // threshold level
            using DSIZE = Field<0, 5>;    // Number of bits in at single SPI data frame
        };

        // configuration register 2
        struct CFG2 : public Register<0x4001300c> {
            using AFCNTR = Field<31, 1>;    // Alternate function GPIOs control
            using SSOM = Field<30, 1>;    // SS output management in master mode
            using SSOE = Field<29, 1>;    // SS output enable
            using SSIOP = Field<28, 1>;    // SS input/output polarity
            using SSM = Field<26, 1>;    // Software management of SS signal input
            using CPOL = Field<25, 1>;    // Clock polarity
            using CPHA = Field<24, 1>;    // Clock phase
            using LSBFRST = Field<23, 1>;    // Data frame format
            using MASTER = Field<22, 1>;    // SPI Master
            using SP = Field<19, 3>;    // Serial Protocol
            using COMM = Field<17, 2>;    // SPI Communication Mode
            using IOSWP = Field<15, 1>;    // Swap functionality of MISO and MOSI pins
            using MIDI = Field<4, 4>;    // Master Inter-Data Idleness
            using MSSI = Field<0, 4>;    // Master SS Idleness
        };

        // Interrupt Enable Register
        struct IER : public Register<0x40013010> {
            using TSERFIE = Field<10, 1>;    // Additional number of transactions reload interrupt enable
            using MODFIE = Field<9, 1>;    // Mode Fault interrupt enable
            using TIFREIE = Field<8, 1>;    // TIFRE interrupt enable
            using CRCEIE = Field<7, 1>;    // CRC Interrupt enable
            using OVRIE = Field<6, 1>;    // OVR interrupt enable
            using UDRIE = Field<5, 1>;    // UDR interrupt enable
            using TXTFIE = Field<4, 1>;    // TXTFIE interrupt enable
            using EOTIE = Field<3, 1>;    // EOT, SUSP and TXC interrupt enable
            using DPXPIE = Field<2, 1>;    // DXP interrupt enabled
            using TXPIE = Field<1, 1>;    // TXP interrupt enable
            using RXPIE = Field<0, 1>;    // RXP Interrupt Enable
        };

        // Status Register
        struct SR : public RegisterReadOnly<0x40013014> {
            using CTSIZE = Field<16, 16>;    // Number of data frames remaining in current TSIZE session
            using RXWNE = Field<15, 1>;    // RxFIFO Word Not Empty
            using RXPLVL = Field<13, 2>;    // RxFIFO Packing LeVeL
            using TXC = Field<12, 1>;    // TxFIFO transmission complete
            using SUSP = Field<11, 1>;    // SUSPend
            using TSERF = Field<10, 1>;    // Additional number of SPI data to be transacted was reload
            using MODF = Field<9, 1>;    // Mode Fault
            using TIFRE = Field<8, 1>;    // TI frame format error
            using CRCE = Field<7, 1>;    // CRC Error
            using OVR = Field<6, 1>;    // Overrun
            using UDR = Field<5, 1>;    // Underrun at slave transmission mode
            using TXTF = Field<4, 1>;    // Transmission Transfer Filled
            using EOT = Field<3, 1>;    // End Of Transfer
            using DXP = Field<2, 1>;    // Duplex Packet
            using TXP = Field<1, 1>;    // Tx-Packet space available
            using RXP = Field<0, 1>;    // Rx-Packet available
        };

        // Interrupt/Status Flags Clear Register
        struct IFCR : public RegisterWriteOnly<0x40013018> {
            using SUSPC = Field<11, 1>;    // SUSPend flag clear
            using TSERFC = Field<10, 1>;    // TSERFC flag clear
            using MODFC = Field<9, 1>;    // Mode Fault flag clear
            using TIFREC = Field<8, 1>;    // TI frame format error flag clear
            using CRCEC = Field<7, 1>;    // CRC Error flag clear
            using OVRC = Field<6, 1>;    // Overrun flag clear
            using UDRC = Field<5, 1>;    // Underrun flag clear
            using TXTFC = Field<4, 1>;    // Transmission Transfer Filled flag clear
            using EOTC = Field<3, 1>;    // End Of Transfer flag clear
        };

        // Transmit Data Register
        struct TXDR : public RegisterWriteOnly<0x40013020> {
            using Field = Field<0, 32>;    // Transmit data register
        };

        // Receive Data Register
        struct RXDR : public RegisterReadOnly<0x40013030> {
            using Field = Field<0, 32>;    // Receive data register
        };

        // Polynomial Register
        struct CRCPOLY : public Register<0x40013040> {
            using Field = Field<0, 32>;    // CRC polynomial register
        };

        // Transmitter CRC Register
        struct TXCRC : public Register<0x40013044> {
            using Field = Field<0, 32>;    // CRC register for transmitter
        };

        // Receiver CRC Register
        struct RXCRC : public Register<0x40013048> {
            using Field = Field<0, 32>;    // CRC register for receiver
        };

        // Underrun Data Register
        struct UDRDR : public Register<0x4001304c> {
            using Field = Field<0, 32>;    // Data at slave underrun condition
        };

        // configuration register
        struct CGFR : public Register<0x40013050> {
            using MCKOE = Field<25, 1>;    // Master clock output enable
            using ODD = Field<24, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<16, 8>;    // I2S linear prescaler
            using DATFMT = Field<14, 1>;    // Data format
            using WSINV = Field<13, 1>;    // Fixed channel length in SLAVE
            using FIXCH = Field<12, 1>;    // Word select inversion
            using CKPOL = Field<11, 1>;    // Serial audio clock polarity
            using CHLEN = Field<10, 1>;    // Channel length (number of bits per audio channel)
            using DATLEN = Field<8, 2>;    // Data length to be transferred
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using I2SCFG = Field<1, 3>;    // I2S configuration mode
            using I2SMOD = Field<0, 1>;    // I2S mode selection
        };

    };

    // Serial peripheral interface
    struct SPI2 {
        // control register 1
        struct CR1 : public Register<0x40003800> {
            using IOLOCK = Field<16, 1>;    // Locking the AF configuration of associated IOs
            using TCRCI = Field<15, 1>;    // CRC calculation initialization pattern control for transmitter
            using RCRCI = Field<14, 1>;    // CRC calculation initialization pattern control for receiver
            using CRC33_17 = Field<13, 1>;    // 32-bit CRC polynomial configuration
            using SSI = Field<12, 1>;    // Internal SS signal input level
            using HDDIR = Field<11, 1>;    // Rx/Tx direction at Half-duplex mode
            using CSUSP = Field<10, 1>;    // Master SUSPend request
            using CSTART = Field<9, 1>;    // Master transfer start
            using MASRX = Field<8, 1>;    // Master automatic SUSP in Receive mode
            using SPE = Field<0, 1>;    // Serial Peripheral Enable
        };

        // control register 2
        struct CR2 : public Register<0x40003804> {
            using TSER = Field<16, 16>;    // Number of data transfer extension to be reload into TSIZE just when a previous
            using TSIZE = Field<0, 16>;    // Number of data at current transfer
        };

        // configuration register 1
        struct CFG1 : public Register<0x40003808> {
            using MBR = Field<28, 3>;    // Master baud rate
            using CRCEN = Field<22, 1>;    // Hardware CRC computation enable
            using CRCSIZE = Field<16, 5>;    // Length of CRC frame to be transacted and compared
            using TXDMAEN = Field<15, 1>;    // Tx DMA stream enable
            using RXDMAEN = Field<14, 1>;    // Rx DMA stream enable
            using UDRDET = Field<11, 2>;    // Detection of underrun condition at slave transmitter
            using UDRCFG = Field<9, 2>;    // Behavior of slave transmitter at underrun condition
            using FTHVL = Field<5, 4>;    // threshold level
            using DSIZE = Field<0, 5>;    // Number of bits in at single SPI data frame
        };

        // configuration register 2
        struct CFG2 : public Register<0x4000380c> {
            using AFCNTR = Field<31, 1>;    // Alternate function GPIOs control
            using SSOM = Field<30, 1>;    // SS output management in master mode
            using SSOE = Field<29, 1>;    // SS output enable
            using SSIOP = Field<28, 1>;    // SS input/output polarity
            using SSM = Field<26, 1>;    // Software management of SS signal input
            using CPOL = Field<25, 1>;    // Clock polarity
            using CPHA = Field<24, 1>;    // Clock phase
            using LSBFRST = Field<23, 1>;    // Data frame format
            using MASTER = Field<22, 1>;    // SPI Master
            using SP = Field<19, 3>;    // Serial Protocol
            using COMM = Field<17, 2>;    // SPI Communication Mode
            using IOSWP = Field<15, 1>;    // Swap functionality of MISO and MOSI pins
            using MIDI = Field<4, 4>;    // Master Inter-Data Idleness
            using MSSI = Field<0, 4>;    // Master SS Idleness
        };

        // Interrupt Enable Register
        struct IER : public Register<0x40003810> {
            using TSERFIE = Field<10, 1>;    // Additional number of transactions reload interrupt enable
            using MODFIE = Field<9, 1>;    // Mode Fault interrupt enable
            using TIFREIE = Field<8, 1>;    // TIFRE interrupt enable
            using CRCEIE = Field<7, 1>;    // CRC Interrupt enable
            using OVRIE = Field<6, 1>;    // OVR interrupt enable
            using UDRIE = Field<5, 1>;    // UDR interrupt enable
            using TXTFIE = Field<4, 1>;    // TXTFIE interrupt enable
            using EOTIE = Field<3, 1>;    // EOT, SUSP and TXC interrupt enable
            using DPXPIE = Field<2, 1>;    // DXP interrupt enabled
            using TXPIE = Field<1, 1>;    // TXP interrupt enable
            using RXPIE = Field<0, 1>;    // RXP Interrupt Enable
        };

        // Status Register
        struct SR : public RegisterReadOnly<0x40003814> {
            using CTSIZE = Field<16, 16>;    // Number of data frames remaining in current TSIZE session
            using RXWNE = Field<15, 1>;    // RxFIFO Word Not Empty
            using RXPLVL = Field<13, 2>;    // RxFIFO Packing LeVeL
            using TXC = Field<12, 1>;    // TxFIFO transmission complete
            using SUSP = Field<11, 1>;    // SUSPend
            using TSERF = Field<10, 1>;    // Additional number of SPI data to be transacted was reload
            using MODF = Field<9, 1>;    // Mode Fault
            using TIFRE = Field<8, 1>;    // TI frame format error
            using CRCE = Field<7, 1>;    // CRC Error
            using OVR = Field<6, 1>;    // Overrun
            using UDR = Field<5, 1>;    // Underrun at slave transmission mode
            using TXTF = Field<4, 1>;    // Transmission Transfer Filled
            using EOT = Field<3, 1>;    // End Of Transfer
            using DXP = Field<2, 1>;    // Duplex Packet
            using TXP = Field<1, 1>;    // Tx-Packet space available
            using RXP = Field<0, 1>;    // Rx-Packet available
        };

        // Interrupt/Status Flags Clear Register
        struct IFCR : public RegisterWriteOnly<0x40003818> {
            using SUSPC = Field<11, 1>;    // SUSPend flag clear
            using TSERFC = Field<10, 1>;    // TSERFC flag clear
            using MODFC = Field<9, 1>;    // Mode Fault flag clear
            using TIFREC = Field<8, 1>;    // TI frame format error flag clear
            using CRCEC = Field<7, 1>;    // CRC Error flag clear
            using OVRC = Field<6, 1>;    // Overrun flag clear
            using UDRC = Field<5, 1>;    // Underrun flag clear
            using TXTFC = Field<4, 1>;    // Transmission Transfer Filled flag clear
            using EOTC = Field<3, 1>;    // End Of Transfer flag clear
        };

        // Transmit Data Register
        struct TXDR : public RegisterWriteOnly<0x40003820> {
            using Field = Field<0, 32>;    // Transmit data register
        };

        // Receive Data Register
        struct RXDR : public RegisterReadOnly<0x40003830> {
            using Field = Field<0, 32>;    // Receive data register
        };

        // Polynomial Register
        struct CRCPOLY : public Register<0x40003840> {
            using Field = Field<0, 32>;    // CRC polynomial register
        };

        // Transmitter CRC Register
        struct TXCRC : public Register<0x40003844> {
            using Field = Field<0, 32>;    // CRC register for transmitter
        };

        // Receiver CRC Register
        struct RXCRC : public Register<0x40003848> {
            using Field = Field<0, 32>;    // CRC register for receiver
        };

        // Underrun Data Register
        struct UDRDR : public Register<0x4000384c> {
            using Field = Field<0, 32>;    // Data at slave underrun condition
        };

        // configuration register
        struct CGFR : public Register<0x40003850> {
            using MCKOE = Field<25, 1>;    // Master clock output enable
            using ODD = Field<24, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<16, 8>;    // I2S linear prescaler
            using DATFMT = Field<14, 1>;    // Data format
            using WSINV = Field<13, 1>;    // Fixed channel length in SLAVE
            using FIXCH = Field<12, 1>;    // Word select inversion
            using CKPOL = Field<11, 1>;    // Serial audio clock polarity
            using CHLEN = Field<10, 1>;    // Channel length (number of bits per audio channel)
            using DATLEN = Field<8, 2>;    // Data length to be transferred
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using I2SCFG = Field<1, 3>;    // I2S configuration mode
            using I2SMOD = Field<0, 1>;    // I2S mode selection
        };

    };

    // Serial peripheral interface
    struct SPI3 {
        // control register 1
        struct CR1 : public Register<0x40003c00> {
            using IOLOCK = Field<16, 1>;    // Locking the AF configuration of associated IOs
            using TCRCI = Field<15, 1>;    // CRC calculation initialization pattern control for transmitter
            using RCRCI = Field<14, 1>;    // CRC calculation initialization pattern control for receiver
            using CRC33_17 = Field<13, 1>;    // 32-bit CRC polynomial configuration
            using SSI = Field<12, 1>;    // Internal SS signal input level
            using HDDIR = Field<11, 1>;    // Rx/Tx direction at Half-duplex mode
            using CSUSP = Field<10, 1>;    // Master SUSPend request
            using CSTART = Field<9, 1>;    // Master transfer start
            using MASRX = Field<8, 1>;    // Master automatic SUSP in Receive mode
            using SPE = Field<0, 1>;    // Serial Peripheral Enable
        };

        // control register 2
        struct CR2 : public Register<0x40003c04> {
            using TSER = Field<16, 16>;    // Number of data transfer extension to be reload into TSIZE just when a previous
            using TSIZE = Field<0, 16>;    // Number of data at current transfer
        };

        // configuration register 1
        struct CFG1 : public Register<0x40003c08> {
            using MBR = Field<28, 3>;    // Master baud rate
            using CRCEN = Field<22, 1>;    // Hardware CRC computation enable
            using CRCSIZE = Field<16, 5>;    // Length of CRC frame to be transacted and compared
            using TXDMAEN = Field<15, 1>;    // Tx DMA stream enable
            using RXDMAEN = Field<14, 1>;    // Rx DMA stream enable
            using UDRDET = Field<11, 2>;    // Detection of underrun condition at slave transmitter
            using UDRCFG = Field<9, 2>;    // Behavior of slave transmitter at underrun condition
            using FTHVL = Field<5, 4>;    // threshold level
            using DSIZE = Field<0, 5>;    // Number of bits in at single SPI data frame
        };

        // configuration register 2
        struct CFG2 : public Register<0x40003c0c> {
            using AFCNTR = Field<31, 1>;    // Alternate function GPIOs control
            using SSOM = Field<30, 1>;    // SS output management in master mode
            using SSOE = Field<29, 1>;    // SS output enable
            using SSIOP = Field<28, 1>;    // SS input/output polarity
            using SSM = Field<26, 1>;    // Software management of SS signal input
            using CPOL = Field<25, 1>;    // Clock polarity
            using CPHA = Field<24, 1>;    // Clock phase
            using LSBFRST = Field<23, 1>;    // Data frame format
            using MASTER = Field<22, 1>;    // SPI Master
            using SP = Field<19, 3>;    // Serial Protocol
            using COMM = Field<17, 2>;    // SPI Communication Mode
            using IOSWP = Field<15, 1>;    // Swap functionality of MISO and MOSI pins
            using MIDI = Field<4, 4>;    // Master Inter-Data Idleness
            using MSSI = Field<0, 4>;    // Master SS Idleness
        };

        // Interrupt Enable Register
        struct IER : public Register<0x40003c10> {
            using TSERFIE = Field<10, 1>;    // Additional number of transactions reload interrupt enable
            using MODFIE = Field<9, 1>;    // Mode Fault interrupt enable
            using TIFREIE = Field<8, 1>;    // TIFRE interrupt enable
            using CRCEIE = Field<7, 1>;    // CRC Interrupt enable
            using OVRIE = Field<6, 1>;    // OVR interrupt enable
            using UDRIE = Field<5, 1>;    // UDR interrupt enable
            using TXTFIE = Field<4, 1>;    // TXTFIE interrupt enable
            using EOTIE = Field<3, 1>;    // EOT, SUSP and TXC interrupt enable
            using DPXPIE = Field<2, 1>;    // DXP interrupt enabled
            using TXPIE = Field<1, 1>;    // TXP interrupt enable
            using RXPIE = Field<0, 1>;    // RXP Interrupt Enable
        };

        // Status Register
        struct SR : public RegisterReadOnly<0x40003c14> {
            using CTSIZE = Field<16, 16>;    // Number of data frames remaining in current TSIZE session
            using RXWNE = Field<15, 1>;    // RxFIFO Word Not Empty
            using RXPLVL = Field<13, 2>;    // RxFIFO Packing LeVeL
            using TXC = Field<12, 1>;    // TxFIFO transmission complete
            using SUSP = Field<11, 1>;    // SUSPend
            using TSERF = Field<10, 1>;    // Additional number of SPI data to be transacted was reload
            using MODF = Field<9, 1>;    // Mode Fault
            using TIFRE = Field<8, 1>;    // TI frame format error
            using CRCE = Field<7, 1>;    // CRC Error
            using OVR = Field<6, 1>;    // Overrun
            using UDR = Field<5, 1>;    // Underrun at slave transmission mode
            using TXTF = Field<4, 1>;    // Transmission Transfer Filled
            using EOT = Field<3, 1>;    // End Of Transfer
            using DXP = Field<2, 1>;    // Duplex Packet
            using TXP = Field<1, 1>;    // Tx-Packet space available
            using RXP = Field<0, 1>;    // Rx-Packet available
        };

        // Interrupt/Status Flags Clear Register
        struct IFCR : public RegisterWriteOnly<0x40003c18> {
            using SUSPC = Field<11, 1>;    // SUSPend flag clear
            using TSERFC = Field<10, 1>;    // TSERFC flag clear
            using MODFC = Field<9, 1>;    // Mode Fault flag clear
            using TIFREC = Field<8, 1>;    // TI frame format error flag clear
            using CRCEC = Field<7, 1>;    // CRC Error flag clear
            using OVRC = Field<6, 1>;    // Overrun flag clear
            using UDRC = Field<5, 1>;    // Underrun flag clear
            using TXTFC = Field<4, 1>;    // Transmission Transfer Filled flag clear
            using EOTC = Field<3, 1>;    // End Of Transfer flag clear
        };

        // Transmit Data Register
        struct TXDR : public RegisterWriteOnly<0x40003c20> {
            using Field = Field<0, 32>;    // Transmit data register
        };

        // Receive Data Register
        struct RXDR : public RegisterReadOnly<0x40003c30> {
            using Field = Field<0, 32>;    // Receive data register
        };

        // Polynomial Register
        struct CRCPOLY : public Register<0x40003c40> {
            using Field = Field<0, 32>;    // CRC polynomial register
        };

        // Transmitter CRC Register
        struct TXCRC : public Register<0x40003c44> {
            using Field = Field<0, 32>;    // CRC register for transmitter
        };

        // Receiver CRC Register
        struct RXCRC : public Register<0x40003c48> {
            using Field = Field<0, 32>;    // CRC register for receiver
        };

        // Underrun Data Register
        struct UDRDR : public Register<0x40003c4c> {
            using Field = Field<0, 32>;    // Data at slave underrun condition
        };

        // configuration register
        struct CGFR : public Register<0x40003c50> {
            using MCKOE = Field<25, 1>;    // Master clock output enable
            using ODD = Field<24, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<16, 8>;    // I2S linear prescaler
            using DATFMT = Field<14, 1>;    // Data format
            using WSINV = Field<13, 1>;    // Fixed channel length in SLAVE
            using FIXCH = Field<12, 1>;    // Word select inversion
            using CKPOL = Field<11, 1>;    // Serial audio clock polarity
            using CHLEN = Field<10, 1>;    // Channel length (number of bits per audio channel)
            using DATLEN = Field<8, 2>;    // Data length to be transferred
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using I2SCFG = Field<1, 3>;    // I2S configuration mode
            using I2SMOD = Field<0, 1>;    // I2S mode selection
        };

    };

    // Serial peripheral interface
    struct SPI4 {
        // control register 1
        struct CR1 : public Register<0x40013400> {
            using IOLOCK = Field<16, 1>;    // Locking the AF configuration of associated IOs
            using TCRCI = Field<15, 1>;    // CRC calculation initialization pattern control for transmitter
            using RCRCI = Field<14, 1>;    // CRC calculation initialization pattern control for receiver
            using CRC33_17 = Field<13, 1>;    // 32-bit CRC polynomial configuration
            using SSI = Field<12, 1>;    // Internal SS signal input level
            using HDDIR = Field<11, 1>;    // Rx/Tx direction at Half-duplex mode
            using CSUSP = Field<10, 1>;    // Master SUSPend request
            using CSTART = Field<9, 1>;    // Master transfer start
            using MASRX = Field<8, 1>;    // Master automatic SUSP in Receive mode
            using SPE = Field<0, 1>;    // Serial Peripheral Enable
        };

        // control register 2
        struct CR2 : public Register<0x40013404> {
            using TSER = Field<16, 16>;    // Number of data transfer extension to be reload into TSIZE just when a previous
            using TSIZE = Field<0, 16>;    // Number of data at current transfer
        };

        // configuration register 1
        struct CFG1 : public Register<0x40013408> {
            using MBR = Field<28, 3>;    // Master baud rate
            using CRCEN = Field<22, 1>;    // Hardware CRC computation enable
            using CRCSIZE = Field<16, 5>;    // Length of CRC frame to be transacted and compared
            using TXDMAEN = Field<15, 1>;    // Tx DMA stream enable
            using RXDMAEN = Field<14, 1>;    // Rx DMA stream enable
            using UDRDET = Field<11, 2>;    // Detection of underrun condition at slave transmitter
            using UDRCFG = Field<9, 2>;    // Behavior of slave transmitter at underrun condition
            using FTHVL = Field<5, 4>;    // threshold level
            using DSIZE = Field<0, 5>;    // Number of bits in at single SPI data frame
        };

        // configuration register 2
        struct CFG2 : public Register<0x4001340c> {
            using AFCNTR = Field<31, 1>;    // Alternate function GPIOs control
            using SSOM = Field<30, 1>;    // SS output management in master mode
            using SSOE = Field<29, 1>;    // SS output enable
            using SSIOP = Field<28, 1>;    // SS input/output polarity
            using SSM = Field<26, 1>;    // Software management of SS signal input
            using CPOL = Field<25, 1>;    // Clock polarity
            using CPHA = Field<24, 1>;    // Clock phase
            using LSBFRST = Field<23, 1>;    // Data frame format
            using MASTER = Field<22, 1>;    // SPI Master
            using SP = Field<19, 3>;    // Serial Protocol
            using COMM = Field<17, 2>;    // SPI Communication Mode
            using IOSWP = Field<15, 1>;    // Swap functionality of MISO and MOSI pins
            using MIDI = Field<4, 4>;    // Master Inter-Data Idleness
            using MSSI = Field<0, 4>;    // Master SS Idleness
        };

        // Interrupt Enable Register
        struct IER : public Register<0x40013410> {
            using TSERFIE = Field<10, 1>;    // Additional number of transactions reload interrupt enable
            using MODFIE = Field<9, 1>;    // Mode Fault interrupt enable
            using TIFREIE = Field<8, 1>;    // TIFRE interrupt enable
            using CRCEIE = Field<7, 1>;    // CRC Interrupt enable
            using OVRIE = Field<6, 1>;    // OVR interrupt enable
            using UDRIE = Field<5, 1>;    // UDR interrupt enable
            using TXTFIE = Field<4, 1>;    // TXTFIE interrupt enable
            using EOTIE = Field<3, 1>;    // EOT, SUSP and TXC interrupt enable
            using DPXPIE = Field<2, 1>;    // DXP interrupt enabled
            using TXPIE = Field<1, 1>;    // TXP interrupt enable
            using RXPIE = Field<0, 1>;    // RXP Interrupt Enable
        };

        // Status Register
        struct SR : public RegisterReadOnly<0x40013414> {
            using CTSIZE = Field<16, 16>;    // Number of data frames remaining in current TSIZE session
            using RXWNE = Field<15, 1>;    // RxFIFO Word Not Empty
            using RXPLVL = Field<13, 2>;    // RxFIFO Packing LeVeL
            using TXC = Field<12, 1>;    // TxFIFO transmission complete
            using SUSP = Field<11, 1>;    // SUSPend
            using TSERF = Field<10, 1>;    // Additional number of SPI data to be transacted was reload
            using MODF = Field<9, 1>;    // Mode Fault
            using TIFRE = Field<8, 1>;    // TI frame format error
            using CRCE = Field<7, 1>;    // CRC Error
            using OVR = Field<6, 1>;    // Overrun
            using UDR = Field<5, 1>;    // Underrun at slave transmission mode
            using TXTF = Field<4, 1>;    // Transmission Transfer Filled
            using EOT = Field<3, 1>;    // End Of Transfer
            using DXP = Field<2, 1>;    // Duplex Packet
            using TXP = Field<1, 1>;    // Tx-Packet space available
            using RXP = Field<0, 1>;    // Rx-Packet available
        };

        // Interrupt/Status Flags Clear Register
        struct IFCR : public RegisterWriteOnly<0x40013418> {
            using SUSPC = Field<11, 1>;    // SUSPend flag clear
            using TSERFC = Field<10, 1>;    // TSERFC flag clear
            using MODFC = Field<9, 1>;    // Mode Fault flag clear
            using TIFREC = Field<8, 1>;    // TI frame format error flag clear
            using CRCEC = Field<7, 1>;    // CRC Error flag clear
            using OVRC = Field<6, 1>;    // Overrun flag clear
            using UDRC = Field<5, 1>;    // Underrun flag clear
            using TXTFC = Field<4, 1>;    // Transmission Transfer Filled flag clear
            using EOTC = Field<3, 1>;    // End Of Transfer flag clear
        };

        // Transmit Data Register
        struct TXDR : public RegisterWriteOnly<0x40013420> {
            using Field = Field<0, 32>;    // Transmit data register
        };

        // Receive Data Register
        struct RXDR : public RegisterReadOnly<0x40013430> {
            using Field = Field<0, 32>;    // Receive data register
        };

        // Polynomial Register
        struct CRCPOLY : public Register<0x40013440> {
            using Field = Field<0, 32>;    // CRC polynomial register
        };

        // Transmitter CRC Register
        struct TXCRC : public Register<0x40013444> {
            using Field = Field<0, 32>;    // CRC register for transmitter
        };

        // Receiver CRC Register
        struct RXCRC : public Register<0x40013448> {
            using Field = Field<0, 32>;    // CRC register for receiver
        };

        // Underrun Data Register
        struct UDRDR : public Register<0x4001344c> {
            using Field = Field<0, 32>;    // Data at slave underrun condition
        };

        // configuration register
        struct CGFR : public Register<0x40013450> {
            using MCKOE = Field<25, 1>;    // Master clock output enable
            using ODD = Field<24, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<16, 8>;    // I2S linear prescaler
            using DATFMT = Field<14, 1>;    // Data format
            using WSINV = Field<13, 1>;    // Fixed channel length in SLAVE
            using FIXCH = Field<12, 1>;    // Word select inversion
            using CKPOL = Field<11, 1>;    // Serial audio clock polarity
            using CHLEN = Field<10, 1>;    // Channel length (number of bits per audio channel)
            using DATLEN = Field<8, 2>;    // Data length to be transferred
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using I2SCFG = Field<1, 3>;    // I2S configuration mode
            using I2SMOD = Field<0, 1>;    // I2S mode selection
        };

    };

    // Serial peripheral interface
    struct SPI5 {
        // control register 1
        struct CR1 : public Register<0x40015000> {
            using IOLOCK = Field<16, 1>;    // Locking the AF configuration of associated IOs
            using TCRCI = Field<15, 1>;    // CRC calculation initialization pattern control for transmitter
            using RCRCI = Field<14, 1>;    // CRC calculation initialization pattern control for receiver
            using CRC33_17 = Field<13, 1>;    // 32-bit CRC polynomial configuration
            using SSI = Field<12, 1>;    // Internal SS signal input level
            using HDDIR = Field<11, 1>;    // Rx/Tx direction at Half-duplex mode
            using CSUSP = Field<10, 1>;    // Master SUSPend request
            using CSTART = Field<9, 1>;    // Master transfer start
            using MASRX = Field<8, 1>;    // Master automatic SUSP in Receive mode
            using SPE = Field<0, 1>;    // Serial Peripheral Enable
        };

        // control register 2
        struct CR2 : public Register<0x40015004> {
            using TSER = Field<16, 16>;    // Number of data transfer extension to be reload into TSIZE just when a previous
            using TSIZE = Field<0, 16>;    // Number of data at current transfer
        };

        // configuration register 1
        struct CFG1 : public Register<0x40015008> {
            using MBR = Field<28, 3>;    // Master baud rate
            using CRCEN = Field<22, 1>;    // Hardware CRC computation enable
            using CRCSIZE = Field<16, 5>;    // Length of CRC frame to be transacted and compared
            using TXDMAEN = Field<15, 1>;    // Tx DMA stream enable
            using RXDMAEN = Field<14, 1>;    // Rx DMA stream enable
            using UDRDET = Field<11, 2>;    // Detection of underrun condition at slave transmitter
            using UDRCFG = Field<9, 2>;    // Behavior of slave transmitter at underrun condition
            using FTHVL = Field<5, 4>;    // threshold level
            using DSIZE = Field<0, 5>;    // Number of bits in at single SPI data frame
        };

        // configuration register 2
        struct CFG2 : public Register<0x4001500c> {
            using AFCNTR = Field<31, 1>;    // Alternate function GPIOs control
            using SSOM = Field<30, 1>;    // SS output management in master mode
            using SSOE = Field<29, 1>;    // SS output enable
            using SSIOP = Field<28, 1>;    // SS input/output polarity
            using SSM = Field<26, 1>;    // Software management of SS signal input
            using CPOL = Field<25, 1>;    // Clock polarity
            using CPHA = Field<24, 1>;    // Clock phase
            using LSBFRST = Field<23, 1>;    // Data frame format
            using MASTER = Field<22, 1>;    // SPI Master
            using SP = Field<19, 3>;    // Serial Protocol
            using COMM = Field<17, 2>;    // SPI Communication Mode
            using IOSWP = Field<15, 1>;    // Swap functionality of MISO and MOSI pins
            using MIDI = Field<4, 4>;    // Master Inter-Data Idleness
            using MSSI = Field<0, 4>;    // Master SS Idleness
        };

        // Interrupt Enable Register
        struct IER : public Register<0x40015010> {
            using TSERFIE = Field<10, 1>;    // Additional number of transactions reload interrupt enable
            using MODFIE = Field<9, 1>;    // Mode Fault interrupt enable
            using TIFREIE = Field<8, 1>;    // TIFRE interrupt enable
            using CRCEIE = Field<7, 1>;    // CRC Interrupt enable
            using OVRIE = Field<6, 1>;    // OVR interrupt enable
            using UDRIE = Field<5, 1>;    // UDR interrupt enable
            using TXTFIE = Field<4, 1>;    // TXTFIE interrupt enable
            using EOTIE = Field<3, 1>;    // EOT, SUSP and TXC interrupt enable
            using DPXPIE = Field<2, 1>;    // DXP interrupt enabled
            using TXPIE = Field<1, 1>;    // TXP interrupt enable
            using RXPIE = Field<0, 1>;    // RXP Interrupt Enable
        };

        // Status Register
        struct SR : public RegisterReadOnly<0x40015014> {
            using CTSIZE = Field<16, 16>;    // Number of data frames remaining in current TSIZE session
            using RXWNE = Field<15, 1>;    // RxFIFO Word Not Empty
            using RXPLVL = Field<13, 2>;    // RxFIFO Packing LeVeL
            using TXC = Field<12, 1>;    // TxFIFO transmission complete
            using SUSP = Field<11, 1>;    // SUSPend
            using TSERF = Field<10, 1>;    // Additional number of SPI data to be transacted was reload
            using MODF = Field<9, 1>;    // Mode Fault
            using TIFRE = Field<8, 1>;    // TI frame format error
            using CRCE = Field<7, 1>;    // CRC Error
            using OVR = Field<6, 1>;    // Overrun
            using UDR = Field<5, 1>;    // Underrun at slave transmission mode
            using TXTF = Field<4, 1>;    // Transmission Transfer Filled
            using EOT = Field<3, 1>;    // End Of Transfer
            using DXP = Field<2, 1>;    // Duplex Packet
            using TXP = Field<1, 1>;    // Tx-Packet space available
            using RXP = Field<0, 1>;    // Rx-Packet available
        };

        // Interrupt/Status Flags Clear Register
        struct IFCR : public RegisterWriteOnly<0x40015018> {
            using SUSPC = Field<11, 1>;    // SUSPend flag clear
            using TSERFC = Field<10, 1>;    // TSERFC flag clear
            using MODFC = Field<9, 1>;    // Mode Fault flag clear
            using TIFREC = Field<8, 1>;    // TI frame format error flag clear
            using CRCEC = Field<7, 1>;    // CRC Error flag clear
            using OVRC = Field<6, 1>;    // Overrun flag clear
            using UDRC = Field<5, 1>;    // Underrun flag clear
            using TXTFC = Field<4, 1>;    // Transmission Transfer Filled flag clear
            using EOTC = Field<3, 1>;    // End Of Transfer flag clear
        };

        // Transmit Data Register
        struct TXDR : public RegisterWriteOnly<0x40015020> {
            using Field = Field<0, 32>;    // Transmit data register
        };

        // Receive Data Register
        struct RXDR : public RegisterReadOnly<0x40015030> {
            using Field = Field<0, 32>;    // Receive data register
        };

        // Polynomial Register
        struct CRCPOLY : public Register<0x40015040> {
            using Field = Field<0, 32>;    // CRC polynomial register
        };

        // Transmitter CRC Register
        struct TXCRC : public Register<0x40015044> {
            using Field = Field<0, 32>;    // CRC register for transmitter
        };

        // Receiver CRC Register
        struct RXCRC : public Register<0x40015048> {
            using Field = Field<0, 32>;    // CRC register for receiver
        };

        // Underrun Data Register
        struct UDRDR : public Register<0x4001504c> {
            using Field = Field<0, 32>;    // Data at slave underrun condition
        };

        // configuration register
        struct CGFR : public Register<0x40015050> {
            using MCKOE = Field<25, 1>;    // Master clock output enable
            using ODD = Field<24, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<16, 8>;    // I2S linear prescaler
            using DATFMT = Field<14, 1>;    // Data format
            using WSINV = Field<13, 1>;    // Fixed channel length in SLAVE
            using FIXCH = Field<12, 1>;    // Word select inversion
            using CKPOL = Field<11, 1>;    // Serial audio clock polarity
            using CHLEN = Field<10, 1>;    // Channel length (number of bits per audio channel)
            using DATLEN = Field<8, 2>;    // Data length to be transferred
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using I2SCFG = Field<1, 3>;    // I2S configuration mode
            using I2SMOD = Field<0, 1>;    // I2S mode selection
        };

    };

    // Serial peripheral interface
    struct SPI6 {
        // control register 1
        struct CR1 : public Register<0x58001400> {
            using IOLOCK = Field<16, 1>;    // Locking the AF configuration of associated IOs
            using TCRCI = Field<15, 1>;    // CRC calculation initialization pattern control for transmitter
            using RCRCI = Field<14, 1>;    // CRC calculation initialization pattern control for receiver
            using CRC33_17 = Field<13, 1>;    // 32-bit CRC polynomial configuration
            using SSI = Field<12, 1>;    // Internal SS signal input level
            using HDDIR = Field<11, 1>;    // Rx/Tx direction at Half-duplex mode
            using CSUSP = Field<10, 1>;    // Master SUSPend request
            using CSTART = Field<9, 1>;    // Master transfer start
            using MASRX = Field<8, 1>;    // Master automatic SUSP in Receive mode
            using SPE = Field<0, 1>;    // Serial Peripheral Enable
        };

        // control register 2
        struct CR2 : public Register<0x58001404> {
            using TSER = Field<16, 16>;    // Number of data transfer extension to be reload into TSIZE just when a previous
            using TSIZE = Field<0, 16>;    // Number of data at current transfer
        };

        // configuration register 1
        struct CFG1 : public Register<0x58001408> {
            using MBR = Field<28, 3>;    // Master baud rate
            using CRCEN = Field<22, 1>;    // Hardware CRC computation enable
            using CRCSIZE = Field<16, 5>;    // Length of CRC frame to be transacted and compared
            using TXDMAEN = Field<15, 1>;    // Tx DMA stream enable
            using RXDMAEN = Field<14, 1>;    // Rx DMA stream enable
            using UDRDET = Field<11, 2>;    // Detection of underrun condition at slave transmitter
            using UDRCFG = Field<9, 2>;    // Behavior of slave transmitter at underrun condition
            using FTHVL = Field<5, 4>;    // threshold level
            using DSIZE = Field<0, 5>;    // Number of bits in at single SPI data frame
        };

        // configuration register 2
        struct CFG2 : public Register<0x5800140c> {
            using AFCNTR = Field<31, 1>;    // Alternate function GPIOs control
            using SSOM = Field<30, 1>;    // SS output management in master mode
            using SSOE = Field<29, 1>;    // SS output enable
            using SSIOP = Field<28, 1>;    // SS input/output polarity
            using SSM = Field<26, 1>;    // Software management of SS signal input
            using CPOL = Field<25, 1>;    // Clock polarity
            using CPHA = Field<24, 1>;    // Clock phase
            using LSBFRST = Field<23, 1>;    // Data frame format
            using MASTER = Field<22, 1>;    // SPI Master
            using SP = Field<19, 3>;    // Serial Protocol
            using COMM = Field<17, 2>;    // SPI Communication Mode
            using IOSWP = Field<15, 1>;    // Swap functionality of MISO and MOSI pins
            using MIDI = Field<4, 4>;    // Master Inter-Data Idleness
            using MSSI = Field<0, 4>;    // Master SS Idleness
        };

        // Interrupt Enable Register
        struct IER : public Register<0x58001410> {
            using TSERFIE = Field<10, 1>;    // Additional number of transactions reload interrupt enable
            using MODFIE = Field<9, 1>;    // Mode Fault interrupt enable
            using TIFREIE = Field<8, 1>;    // TIFRE interrupt enable
            using CRCEIE = Field<7, 1>;    // CRC Interrupt enable
            using OVRIE = Field<6, 1>;    // OVR interrupt enable
            using UDRIE = Field<5, 1>;    // UDR interrupt enable
            using TXTFIE = Field<4, 1>;    // TXTFIE interrupt enable
            using EOTIE = Field<3, 1>;    // EOT, SUSP and TXC interrupt enable
            using DPXPIE = Field<2, 1>;    // DXP interrupt enabled
            using TXPIE = Field<1, 1>;    // TXP interrupt enable
            using RXPIE = Field<0, 1>;    // RXP Interrupt Enable
        };

        // Status Register
        struct SR : public RegisterReadOnly<0x58001414> {
            using CTSIZE = Field<16, 16>;    // Number of data frames remaining in current TSIZE session
            using RXWNE = Field<15, 1>;    // RxFIFO Word Not Empty
            using RXPLVL = Field<13, 2>;    // RxFIFO Packing LeVeL
            using TXC = Field<12, 1>;    // TxFIFO transmission complete
            using SUSP = Field<11, 1>;    // SUSPend
            using TSERF = Field<10, 1>;    // Additional number of SPI data to be transacted was reload
            using MODF = Field<9, 1>;    // Mode Fault
            using TIFRE = Field<8, 1>;    // TI frame format error
            using CRCE = Field<7, 1>;    // CRC Error
            using OVR = Field<6, 1>;    // Overrun
            using UDR = Field<5, 1>;    // Underrun at slave transmission mode
            using TXTF = Field<4, 1>;    // Transmission Transfer Filled
            using EOT = Field<3, 1>;    // End Of Transfer
            using DXP = Field<2, 1>;    // Duplex Packet
            using TXP = Field<1, 1>;    // Tx-Packet space available
            using RXP = Field<0, 1>;    // Rx-Packet available
        };

        // Interrupt/Status Flags Clear Register
        struct IFCR : public RegisterWriteOnly<0x58001418> {
            using SUSPC = Field<11, 1>;    // SUSPend flag clear
            using TSERFC = Field<10, 1>;    // TSERFC flag clear
            using MODFC = Field<9, 1>;    // Mode Fault flag clear
            using TIFREC = Field<8, 1>;    // TI frame format error flag clear
            using CRCEC = Field<7, 1>;    // CRC Error flag clear
            using OVRC = Field<6, 1>;    // Overrun flag clear
            using UDRC = Field<5, 1>;    // Underrun flag clear
            using TXTFC = Field<4, 1>;    // Transmission Transfer Filled flag clear
            using EOTC = Field<3, 1>;    // End Of Transfer flag clear
        };

        // Transmit Data Register
        struct TXDR : public RegisterWriteOnly<0x58001420> {
            using Field = Field<0, 32>;    // Transmit data register
        };

        // Receive Data Register
        struct RXDR : public RegisterReadOnly<0x58001430> {
            using Field = Field<0, 32>;    // Receive data register
        };

        // Polynomial Register
        struct CRCPOLY : public Register<0x58001440> {
            using Field = Field<0, 32>;    // CRC polynomial register
        };

        // Transmitter CRC Register
        struct TXCRC : public Register<0x58001444> {
            using Field = Field<0, 32>;    // CRC register for transmitter
        };

        // Receiver CRC Register
        struct RXCRC : public Register<0x58001448> {
            using Field = Field<0, 32>;    // CRC register for receiver
        };

        // Underrun Data Register
        struct UDRDR : public Register<0x5800144c> {
            using Field = Field<0, 32>;    // Data at slave underrun condition
        };

        // configuration register
        struct CGFR : public Register<0x58001450> {
            using MCKOE = Field<25, 1>;    // Master clock output enable
            using ODD = Field<24, 1>;    // Odd factor for the prescaler
            using I2SDIV = Field<16, 8>;    // I2S linear prescaler
            using DATFMT = Field<14, 1>;    // Data format
            using WSINV = Field<13, 1>;    // Fixed channel length in SLAVE
            using FIXCH = Field<12, 1>;    // Word select inversion
            using CKPOL = Field<11, 1>;    // Serial audio clock polarity
            using CHLEN = Field<10, 1>;    // Channel length (number of bits per audio channel)
            using DATLEN = Field<8, 2>;    // Data length to be transferred
            using PCMSYNC = Field<7, 1>;    // PCM frame synchronization
            using I2SSTD = Field<4, 2>;    // I2S standard selection
            using I2SCFG = Field<1, 3>;    // I2S configuration mode
            using I2SMOD = Field<0, 1>;    // I2S mode selection
        };

    };

    // LCD-TFT Controller
    struct LTDC {
        // Synchronization Size Configuration Register
        struct SSCR : public Register<0x50001008> {
            using HSW = Field<16, 10>;    // Horizontal Synchronization Width (in units of pixel clock period)
            using VSH = Field<0, 11>;    // Vertical Synchronization Height (in units of horizontal scan line)
        };

        // Back Porch Configuration Register
        struct BPCR : public Register<0x5000100c> {
            using AHBP = Field<16, 12>;    // Accumulated Horizontal back porch (in units of pixel clock period)
            using AVBP = Field<0, 11>;    // Accumulated Vertical back porch (in units of horizontal scan line)
        };

        // Active Width Configuration Register
        struct AWCR : public Register<0x50001010> {
            using AAV = Field<16, 12>;    // AAV
            using AAH = Field<0, 11>;    // Accumulated Active Height (in units of horizontal scan line)
        };

        // Total Width Configuration Register
        struct TWCR : public Register<0x50001014> {
            using TOTALW = Field<16, 12>;    // Total Width (in units of pixel clock period)
            using TOTALH = Field<0, 11>;    // Total Height (in units of horizontal scan line)
        };

        // Global Control Register
        struct GCR : public Register<0x50001018> {
            using HSPOL = Field<31, 1>;    // Horizontal Synchronization Polarity
            using VSPOL = Field<30, 1>;    // Vertical Synchronization Polarity
            using DEPOL = Field<29, 1>;    // Data Enable Polarity
            using PCPOL = Field<28, 1>;    // Pixel Clock Polarity
            using DEN = Field<16, 1>;    // Dither Enable
            using DRW = Field<12, 3>;    // Dither Red Width
            using DGW = Field<8, 3>;    // Dither Green Width
            using DBW = Field<4, 3>;    // Dither Blue Width
            using LTDCEN = Field<0, 1>;    // LCD-TFT controller enable bit
        };

        // Shadow Reload Configuration Register
        struct SRCR : public Register<0x50001024> {
            using VBR = Field<1, 1>;    // Vertical Blanking Reload
            using IMR = Field<0, 1>;    // Immediate Reload
        };

        // Background Color Configuration Register
        struct BCCR : public Register<0x5000102c> {
            using BCBLUE = Field<0, 8>;    // Background Color Blue value
            using BCGREEN = Field<8, 8>;    // Background Color Green value
            using BCRED = Field<16, 8>;    // Background Color Red value
        };

        // Interrupt Enable Register
        struct IER : public Register<0x50001034> {
            using RRIE = Field<3, 1>;    // Register Reload interrupt enable
            using TERRIE = Field<2, 1>;    // Transfer Error Interrupt Enable
            using FUIE = Field<1, 1>;    // FIFO Underrun Interrupt Enable
            using LIE = Field<0, 1>;    // Line Interrupt Enable
        };

        // Interrupt Status Register
        struct ISR : public RegisterReadOnly<0x50001038> {
            using RRIF = Field<3, 1>;    // Register Reload Interrupt Flag
            using TERRIF = Field<2, 1>;    // Transfer Error interrupt flag
            using FUIF = Field<1, 1>;    // FIFO Underrun Interrupt flag
            using LIF = Field<0, 1>;    // Line Interrupt flag
        };

        // Interrupt Clear Register
        struct ICR : public RegisterWriteOnly<0x5000103c> {
            using CRRIF = Field<3, 1>;    // Clears Register Reload Interrupt Flag
            using CTERRIF = Field<2, 1>;    // Clears the Transfer Error Interrupt Flag
            using CFUIF = Field<1, 1>;    // Clears the FIFO Underrun Interrupt flag
            using CLIF = Field<0, 1>;    // Clears the Line Interrupt Flag
        };

        // Line Interrupt Position Configuration Register
        struct LIPCR : public Register<0x50001040> {
            using LIPOS = Field<0, 11>;    // Line Interrupt Position
        };

        // Current Position Status Register
        struct CPSR : public RegisterReadOnly<0x50001044> {
            using CXPOS = Field<16, 16>;    // Current X Position
            using CYPOS = Field<0, 16>;    // Current Y Position
        };

        // Current Display Status Register
        struct CDSR : public RegisterReadOnly<0x50001048> {
            using HSYNCS = Field<3, 1>;    // Horizontal Synchronization display Status
            using VSYNCS = Field<2, 1>;    // Vertical Synchronization display Status
            using HDES = Field<1, 1>;    // Horizontal Data Enable display Status
            using VDES = Field<0, 1>;    // Vertical Data Enable display Status
        };

        // Layerx Control Register
        struct L1CR : public Register<0x50001084> {
            using CLUTEN = Field<4, 1>;    // Color Look-Up Table Enable
            using COLKEN = Field<1, 1>;    // Color Keying Enable
            using LEN = Field<0, 1>;    // Layer Enable
        };

        // Layerx Window Horizontal Position Configuration Register
        struct L1WHPCR : public Register<0x50001088> {
            using WHSPPOS = Field<16, 12>;    // Window Horizontal Stop Position
            using WHSTPOS = Field<0, 12>;    // Window Horizontal Start Position
        };

        // Layerx Window Vertical Position Configuration Register
        struct L1WVPCR : public Register<0x5000108c> {
            using WVSPPOS = Field<16, 11>;    // Window Vertical Stop Position
            using WVSTPOS = Field<0, 11>;    // Window Vertical Start Position
        };

        // Layerx Color Keying Configuration Register
        struct L1CKCR : public Register<0x50001090> {
            using CKRED = Field<16, 8>;    // Color Key Red value
            using CKGREEN = Field<8, 8>;    // Color Key Green value
            using CKBLUE = Field<0, 8>;    // Color Key Blue value
        };

        // Layerx Pixel Format Configuration Register
        struct L1PFCR : public Register<0x50001094> {
            using PF = Field<0, 3>;    // Pixel Format
        };

        // Layerx Constant Alpha Configuration Register
        struct L1CACR : public Register<0x50001098> {
            using CONSTA = Field<0, 8>;    // Constant Alpha
        };

        // Layerx Default Color Configuration Register
        struct L1DCCR : public Register<0x5000109c> {
            using DCALPHA = Field<24, 8>;    // Default Color Alpha
            using DCRED = Field<16, 8>;    // Default Color Red
            using DCGREEN = Field<8, 8>;    // Default Color Green
            using DCBLUE = Field<0, 8>;    // Default Color Blue
        };

        // Layerx Blending Factors Configuration Register
        struct L1BFCR : public Register<0x500010a0> {
            using BF1 = Field<8, 3>;    // Blending Factor 1
            using BF2 = Field<0, 3>;    // Blending Factor 2
        };

        // Layerx Color Frame Buffer Address Register
        struct L1CFBAR : public Register<0x500010ac> {
            using CFBADD = Field<0, 32>;    // Color Frame Buffer Start Address
        };

        // Layerx Color Frame Buffer Length Register
        struct L1CFBLR : public Register<0x500010b0> {
            using CFBP = Field<16, 13>;    // Color Frame Buffer Pitch in bytes
            using CFBLL = Field<0, 13>;    // Color Frame Buffer Line Length
        };

        // Layerx ColorFrame Buffer Line Number Register
        struct L1CFBLNR : public Register<0x500010b4> {
            using CFBLNBR = Field<0, 11>;    // Frame Buffer Line Number
        };

        // Layerx CLUT Write Register
        struct L1CLUTWR : public RegisterWriteOnly<0x500010c4> {
            using CLUTADD = Field<24, 8>;    // CLUT Address
            using RED = Field<16, 8>;    // Red value
            using GREEN = Field<8, 8>;    // Green value
            using BLUE = Field<0, 8>;    // Blue value
        };

        // Layerx Control Register
        struct L2CR : public Register<0x50001104> {
            using CLUTEN = Field<4, 1>;    // Color Look-Up Table Enable
            using COLKEN = Field<1, 1>;    // Color Keying Enable
            using LEN = Field<0, 1>;    // Layer Enable
        };

        // Layerx Window Horizontal Position Configuration Register
        struct L2WHPCR : public Register<0x50001108> {
            using WHSPPOS = Field<16, 12>;    // Window Horizontal Stop Position
            using WHSTPOS = Field<0, 12>;    // Window Horizontal Start Position
        };

        // Layerx Window Vertical Position Configuration Register
        struct L2WVPCR : public Register<0x5000110c> {
            using WVSPPOS = Field<16, 11>;    // Window Vertical Stop Position
            using WVSTPOS = Field<0, 11>;    // Window Vertical Start Position
        };

        // Layerx Color Keying Configuration Register
        struct L2CKCR : public Register<0x50001110> {
            using CKRED = Field<16, 8>;    // Color Key Red value
            using CKGREEN = Field<8, 8>;    // Color Key Green value
            using CKBLUE = Field<0, 8>;    // Color Key Blue value
        };

        // Layerx Pixel Format Configuration Register
        struct L2PFCR : public Register<0x50001114> {
            using PF = Field<0, 3>;    // Pixel Format
        };

        // Layerx Constant Alpha Configuration Register
        struct L2CACR : public Register<0x50001118> {
            using CONSTA = Field<0, 8>;    // Constant Alpha
        };

        // Layerx Default Color Configuration Register
        struct L2DCCR : public Register<0x5000111c> {
            using DCALPHA = Field<24, 8>;    // Default Color Alpha
            using DCRED = Field<16, 8>;    // Default Color Red
            using DCGREEN = Field<8, 8>;    // Default Color Green
            using DCBLUE = Field<0, 8>;    // Default Color Blue
        };

        // Layerx Blending Factors Configuration Register
        struct L2BFCR : public Register<0x50001120> {
            using BF1 = Field<8, 3>;    // Blending Factor 1
            using BF2 = Field<0, 3>;    // Blending Factor 2
        };

        // Layerx Color Frame Buffer Address Register
        struct L2CFBAR : public Register<0x5000112c> {
            using CFBADD = Field<0, 32>;    // Color Frame Buffer Start Address
        };

        // Layerx Color Frame Buffer Length Register
        struct L2CFBLR : public Register<0x50001130> {
            using CFBP = Field<16, 13>;    // Color Frame Buffer Pitch in bytes
            using CFBLL = Field<0, 13>;    // Color Frame Buffer Line Length
        };

        // Layerx ColorFrame Buffer Line Number Register
        struct L2CFBLNR : public Register<0x50001134> {
            using CFBLNBR = Field<0, 11>;    // Frame Buffer Line Number
        };

        // Layerx CLUT Write Register
        struct L2CLUTWR : public RegisterWriteOnly<0x50001144> {
            using CLUTADD = Field<24, 8>;    // CLUT Address
            using RED = Field<16, 8>;    // Red value
            using GREEN = Field<8, 8>;    // Green value
            using BLUE = Field<0, 8>;    // Blue value
        };

    };

    // Receiver Interface
    struct SPDIFRX {
        // Control register
        struct CR : public Register<0x40004000> {
            using SPDIFRXEN = Field<0, 2>;    // Peripheral Block Enable
            using RXDMAEN = Field<2, 1>;    // Receiver DMA ENable for data flow
            using RXSTEO = Field<3, 1>;    // STerEO Mode
            using DRFMT = Field<4, 2>;    // RX Data format
            using PMSK = Field<6, 1>;    // Mask Parity error bit
            using VMSK = Field<7, 1>;    // Mask of Validity bit
            using CUMSK = Field<8, 1>;    // Mask of channel status and user bits
            using PTMSK = Field<9, 1>;    // Mask of Preamble Type bits
            using CBDMAEN = Field<10, 1>;    // Control Buffer DMA ENable for control flow
            using CHSEL = Field<11, 1>;    // Channel Selection
            using NBTR = Field<12, 2>;    // Maximum allowed re-tries during synchronization phase
            using WFA = Field<14, 1>;    // Wait For Activity
            using INSEL = Field<16, 3>;    // input selection
            using CKSEN = Field<20, 1>;    // Symbol Clock Enable
            using CKSBKPEN = Field<21, 1>;    // Backup Symbol Clock Enable
        };

        // Interrupt mask register
        struct IMR : public Register<0x40004004> {
            using RXNEIE = Field<0, 1>;    // RXNE interrupt enable
            using CSRNEIE = Field<1, 1>;    // Control Buffer Ready Interrupt Enable
            using PERRIE = Field<2, 1>;    // Parity error interrupt enable
            using OVRIE = Field<3, 1>;    // Overrun error Interrupt Enable
            using SBLKIE = Field<4, 1>;    // Synchronization Block Detected Interrupt Enable
            using SYNCDIE = Field<5, 1>;    // Synchronization Done
            using IFEIE = Field<6, 1>;    // Serial Interface Error Interrupt Enable
        };

        // Status register
        struct SR : public RegisterReadOnly<0x40004008> {
            using RXNE = Field<0, 1>;    // Read data register not empty
            using CSRNE = Field<1, 1>;    // Control Buffer register is not empty
            using PERR = Field<2, 1>;    // Parity error
            using OVR = Field<3, 1>;    // Overrun error
            using SBD = Field<4, 1>;    // Synchronization Block Detected
            using SYNCD = Field<5, 1>;    // Synchronization Done
            using FERR = Field<6, 1>;    // Framing error
            using SERR = Field<7, 1>;    // Synchronization error
            using TERR = Field<8, 1>;    // Time-out error
            using WIDTH5 = Field<16, 15>;    // Duration of 5 symbols counted with SPDIF_CLK
        };

        // Interrupt Flag Clear register
        struct IFCR : public RegisterWriteOnly<0x4000400c> {
            using PERRCF = Field<2, 1>;    // Clears the Parity error flag
            using OVRCF = Field<3, 1>;    // Clears the Overrun error flag
            using SBDCF = Field<4, 1>;    // Clears the Synchronization Block Detected flag
            using SYNCDCF = Field<5, 1>;    // Clears the Synchronization Done flag
        };

        // Data input register
        struct DR_00 : public RegisterReadOnly<0x40004010> {
            using DR = Field<0, 24>;    // Parity Error bit
            using PE = Field<24, 1>;    // Parity Error bit
            using V = Field<25, 1>;    // Validity bit
            using U = Field<26, 1>;    // User bit
            using C = Field<27, 1>;    // Channel Status bit
            using PT = Field<28, 2>;    // Preamble Type
        };

        // Channel Status register
        struct CSR : public RegisterReadOnly<0x40004014> {
            using USR = Field<0, 16>;    // User data information
            using CS = Field<16, 8>;    // Channel A status information
            using SOB = Field<24, 1>;    // Start Of Block
        };

        // Debug Information register
        struct DIR : public RegisterReadOnly<0x40004018> {
            using THI = Field<0, 13>;    // Threshold HIGH
            using TLO = Field<16, 13>;    // Threshold LOW
        };

        // SPDIFRX version register
        struct VERR : public RegisterReadOnly<0x400043f4> {
            using MINREV = Field<0, 4>;    // Minor revision
            using MAJREV = Field<4, 4>;    // Major revision
        };

        // SPDIFRX identification register
        struct IDR : public RegisterReadOnly<0x400043f8> {
            using ID = Field<0, 32>;    // SPDIFRX identifier
        };

        // SPDIFRX size identification register
        struct SIDR : public RegisterReadOnly<0x400043fc> {
            using SID = Field<0, 32>;    // Size identification
        };

        // Data input register
        struct DR_01 : public RegisterReadOnly<0x40004010> {
            using PE = Field<0, 1>;    // Parity Error bit
            using V = Field<1, 1>;    // Validity bit
            using U = Field<2, 1>;    // User bit
            using C = Field<3, 1>;    // Channel Status bit
            using PT = Field<4, 2>;    // Preamble Type
            using DR = Field<8, 24>;    // Data value
        };

        // Data input register
        struct DR_10 : public RegisterReadOnly<0x40004010> {
            using DRNL1 = Field<0, 16>;    // Data value
            using DRNL2 = Field<16, 16>;    // Data value
        };

    };

    // Analog to Digital Converter
    struct ADC3 {
        // ADC interrupt and status register
        struct ISR : public Register<0x58026000> {
            using JQOVF = Field<10, 1>;    // ADC group injected contexts queue overflow flag
            using AWD3 = Field<9, 1>;    // ADC analog watchdog 3 flag
            using AWD2 = Field<8, 1>;    // ADC analog watchdog 2 flag
            using AWD1 = Field<7, 1>;    // ADC analog watchdog 1 flag
            using JEOS = Field<6, 1>;    // ADC group injected end of sequence conversions flag
            using JEOC = Field<5, 1>;    // ADC group injected end of unitary conversion flag
            using OVR = Field<4, 1>;    // ADC group regular overrun flag
            using EOS = Field<3, 1>;    // ADC group regular end of sequence conversions flag
            using EOC = Field<2, 1>;    // ADC group regular end of unitary conversion flag
            using EOSMP = Field<1, 1>;    // ADC group regular end of sampling flag
            using ADRDY = Field<0, 1>;    // ADC ready flag
        };

        // ADC interrupt enable register
        struct IER : public Register<0x58026004> {
            using JQOVFIE = Field<10, 1>;    // ADC group injected contexts queue overflow interrupt
            using AWD3IE = Field<9, 1>;    // ADC analog watchdog 3 interrupt
            using AWD2IE = Field<8, 1>;    // ADC analog watchdog 2 interrupt
            using AWD1IE = Field<7, 1>;    // ADC analog watchdog 1 interrupt
            using JEOSIE = Field<6, 1>;    // ADC group injected end of sequence conversions interrupt
            using JEOCIE = Field<5, 1>;    // ADC group injected end of unitary conversion interrupt
            using OVRIE = Field<4, 1>;    // ADC group regular overrun interrupt
            using EOSIE = Field<3, 1>;    // ADC group regular end of sequence conversions interrupt
            using EOCIE = Field<2, 1>;    // ADC group regular end of unitary conversion interrupt
            using EOSMPIE = Field<1, 1>;    // ADC group regular end of sampling interrupt
            using ADRDYIE = Field<0, 1>;    // ADC ready interrupt
        };

        // ADC control register
        struct CR : public Register<0x58026008> {
            using ADCAL = Field<31, 1>;    // ADC calibration
            using ADCALDIF = Field<30, 1>;    // ADC differential mode for calibration
            using DEEPPWD = Field<29, 1>;    // ADC deep power down enable
            using ADVREGEN = Field<28, 1>;    // ADC voltage regulator enable
            using LINCALRDYW6 = Field<27, 1>;    // Linearity calibration ready Word 6
            using LINCALRDYW5 = Field<26, 1>;    // Linearity calibration ready Word 5
            using LINCALRDYW4 = Field<25, 1>;    // Linearity calibration ready Word 4
            using LINCALRDYW3 = Field<24, 1>;    // Linearity calibration ready Word 3
            using LINCALRDYW2 = Field<23, 1>;    // Linearity calibration ready Word 2
            using LINCALRDYW1 = Field<22, 1>;    // Linearity calibration ready Word 1
            using ADCALLIN = Field<16, 1>;    // Linearity calibration
            using BOOST = Field<8, 1>;    // Boost mode control
            using JADSTP = Field<5, 1>;    // ADC group injected conversion stop
            using ADSTP = Field<4, 1>;    // ADC group regular conversion stop
            using JADSTART = Field<3, 1>;    // ADC group injected conversion start
            using ADSTART = Field<2, 1>;    // ADC group regular conversion start
            using ADDIS = Field<1, 1>;    // ADC disable
            using ADEN = Field<0, 1>;    // ADC enable
        };

        // ADC configuration register 1
        struct CFGR : public Register<0x5802600c> {
            using JQDIS = Field<31, 1>;    // ADC group injected contexts queue disable
            using AWDCH1CH = Field<26, 5>;    // ADC analog watchdog 1 monitored channel selection
            using JAUTO = Field<25, 1>;    // ADC group injected automatic trigger mode
            using JAWD1EN = Field<24, 1>;    // ADC analog watchdog 1 enable on scope ADC group injected
            using AWD1EN = Field<23, 1>;    // ADC analog watchdog 1 enable on scope ADC group regular
            using AWD1SGL = Field<22, 1>;    // ADC analog watchdog 1 monitoring a single channel or all channels
            using JQM = Field<21, 1>;    // ADC group injected contexts queue mode
            using JDISCEN = Field<20, 1>;    // ADC group injected sequencer discontinuous mode
            using DISCNUM = Field<17, 3>;    // ADC group regular sequencer discontinuous number of ranks
            using DISCEN = Field<16, 1>;    // ADC group regular sequencer discontinuous mode
            using AUTDLY = Field<14, 1>;    // ADC low power auto wait
            using CONT = Field<13, 1>;    // ADC group regular continuous conversion mode
            using OVRMOD = Field<12, 1>;    // ADC group regular overrun configuration
            using EXTEN = Field<10, 2>;    // ADC group regular external trigger polarity
            using EXTSEL = Field<5, 5>;    // ADC group regular external trigger source
            using RES = Field<2, 3>;    // ADC data resolution
            using DMNGT = Field<0, 2>;    // ADC DMA transfer enable
        };

        // ADC configuration register 2
        struct CFGR2 : public Register<0x58026010> {
            using ROVSE = Field<0, 1>;    // ADC oversampler enable on scope ADC group regular
            using JOVSE = Field<1, 1>;    // ADC oversampler enable on scope ADC group injected
            using OVSS = Field<5, 4>;    // ADC oversampling shift
            using TROVS = Field<9, 1>;    // ADC oversampling discontinuous mode (triggered mode) for ADC group regular
            using ROVSM = Field<10, 1>;    // Regular Oversampling mode
            using RSHIFT1 = Field<11, 1>;    // Right-shift data after Offset 1 correction
            using RSHIFT2 = Field<12, 1>;    // Right-shift data after Offset 2 correction
            using RSHIFT3 = Field<13, 1>;    // Right-shift data after Offset 3 correction
            using RSHIFT4 = Field<14, 1>;    // Right-shift data after Offset 4 correction
            using OSR = Field<16, 10>;    // Oversampling ratio
            using LSHIFT = Field<28, 4>;    // Left shift factor
        };

        // ADC sampling time register 1
        struct SMPR1 : public Register<0x58026014> {
            using SMP9 = Field<27, 3>;    // ADC channel 9 sampling time selection
            using SMP8 = Field<24, 3>;    // ADC channel 8 sampling time selection
            using SMP7 = Field<21, 3>;    // ADC channel 7 sampling time selection
            using SMP6 = Field<18, 3>;    // ADC channel 6 sampling time selection
            using SMP5 = Field<15, 3>;    // ADC channel 5 sampling time selection
            using SMP4 = Field<12, 3>;    // ADC channel 4 sampling time selection
            using SMP3 = Field<9, 3>;    // ADC channel 3 sampling time selection
            using SMP2 = Field<6, 3>;    // ADC channel 2 sampling time selection
            using SMP1 = Field<3, 3>;    // ADC channel 1 sampling time selection
        };

        // ADC sampling time register 2
        struct SMPR2 : public Register<0x58026018> {
            using SMP19 = Field<27, 3>;    // ADC channel 18 sampling time selection
            using SMP18 = Field<24, 3>;    // ADC channel 18 sampling time selection
            using SMP17 = Field<21, 3>;    // ADC channel 17 sampling time selection
            using SMP16 = Field<18, 3>;    // ADC channel 16 sampling time selection
            using SMP15 = Field<15, 3>;    // ADC channel 15 sampling time selection
            using SMP14 = Field<12, 3>;    // ADC channel 14 sampling time selection
            using SMP13 = Field<9, 3>;    // ADC channel 13 sampling time selection
            using SMP12 = Field<6, 3>;    // ADC channel 12 sampling time selection
            using SMP11 = Field<3, 3>;    // ADC channel 11 sampling time selection
            using SMP10 = Field<0, 3>;    // ADC channel 10 sampling time selection
        };

        // ADC analog watchdog 1 threshold register
        struct LTR1 : public Register<0x58026020> {
            using Field = Field<0, 26>;    // ADC analog watchdog 1 threshold low
        };

        // ADC analog watchdog 2 threshold register
        struct LHTR1 : public Register<0x58026024> {
            using Field = Field<0, 26>;    // ADC analog watchdog 2 threshold low
        };

        // ADC group regular sequencer ranks register 1
        struct SQR1 : public Register<0x58026030> {
            using SQ4 = Field<24, 5>;    // ADC group regular sequencer rank 4
            using SQ3 = Field<18, 5>;    // ADC group regular sequencer rank 3
            using SQ2 = Field<12, 5>;    // ADC group regular sequencer rank 2
            using SQ1 = Field<6, 5>;    // ADC group regular sequencer rank 1
            using L3 = Field<0, 4>;    // L3
        };

        // ADC group regular sequencer ranks register 2
        struct SQR2 : public Register<0x58026034> {
            using SQ9 = Field<24, 5>;    // ADC group regular sequencer rank 9
            using SQ8 = Field<18, 5>;    // ADC group regular sequencer rank 8
            using SQ7 = Field<12, 5>;    // ADC group regular sequencer rank 7
            using SQ6 = Field<6, 5>;    // ADC group regular sequencer rank 6
            using SQ5 = Field<0, 5>;    // ADC group regular sequencer rank 5
        };

        // ADC group regular sequencer ranks register 3
        struct SQR3 : public Register<0x58026038> {
            using SQ14 = Field<24, 5>;    // ADC group regular sequencer rank 14
            using SQ13 = Field<18, 5>;    // ADC group regular sequencer rank 13
            using SQ12 = Field<12, 5>;    // ADC group regular sequencer rank 12
            using SQ11 = Field<6, 5>;    // ADC group regular sequencer rank 11
            using SQ10 = Field<0, 5>;    // ADC group regular sequencer rank 10
        };

        // ADC group regular sequencer ranks register 4
        struct SQR4 : public Register<0x5802603c> {
            using SQ16 = Field<6, 5>;    // ADC group regular sequencer rank 16
            using SQ15 = Field<0, 5>;    // ADC group regular sequencer rank 15
        };

        // ADC group regular conversion data register
        struct DR : public RegisterReadOnly<0x58026040> {
            using RDATA = Field<0, 16>;    // ADC group regular conversion data
        };

        // ADC group injected sequencer register
        struct JSQR : public Register<0x5802604c> {
            using JSQ4 = Field<27, 5>;    // ADC group injected sequencer rank 4
            using JSQ3 = Field<21, 5>;    // ADC group injected sequencer rank 3
            using JSQ2 = Field<15, 5>;    // ADC group injected sequencer rank 2
            using JSQ1 = Field<9, 5>;    // ADC group injected sequencer rank 1
            using JEXTEN = Field<7, 2>;    // ADC group injected external trigger polarity
            using JEXTSEL = Field<2, 5>;    // ADC group injected external trigger source
            using JL = Field<0, 2>;    // ADC group injected sequencer scan length
        };

        // ADC offset number 1 register
        struct OFR1 : public Register<0x58026060> {
            using SSATE = Field<31, 1>;    // ADC offset number 1 enable
            using OFFSET1_CH = Field<26, 5>;    // ADC offset number 1 channel selection
            using OFFSET1 = Field<0, 26>;    // ADC offset number 1 offset level
        };

        // ADC offset number 2 register
        struct OFR2 : public Register<0x58026064> {
            using SSATE = Field<31, 1>;    // ADC offset number 1 enable
            using OFFSET1_CH = Field<26, 5>;    // ADC offset number 1 channel selection
            using OFFSET1 = Field<0, 26>;    // ADC offset number 1 offset level
        };

        // ADC offset number 3 register
        struct OFR3 : public Register<0x58026068> {
            using SSATE = Field<31, 1>;    // ADC offset number 1 enable
            using OFFSET1_CH = Field<26, 5>;    // ADC offset number 1 channel selection
            using OFFSET1 = Field<0, 26>;    // ADC offset number 1 offset level
        };

        // ADC offset number 4 register
        struct OFR4 : public Register<0x5802606c> {
            using SSATE = Field<31, 1>;    // ADC offset number 1 enable
            using OFFSET1_CH = Field<26, 5>;    // ADC offset number 1 channel selection
            using OFFSET1 = Field<0, 26>;    // ADC offset number 1 offset level
        };

        // ADC group injected sequencer rank 1 register
        struct JDR1 : public RegisterReadOnly<0x58026080> {
            using JDATA1 = Field<0, 32>;    // ADC group injected sequencer rank 1 conversion data
        };

        // ADC group injected sequencer rank 2 register
        struct JDR2 : public RegisterReadOnly<0x58026084> {
            using JDATA2 = Field<0, 32>;    // ADC group injected sequencer rank 2 conversion data
        };

        // ADC group injected sequencer rank 3 register
        struct JDR3 : public RegisterReadOnly<0x58026088> {
            using JDATA3 = Field<0, 32>;    // ADC group injected sequencer rank 3 conversion data
        };

        // ADC group injected sequencer rank 4 register
        struct JDR4 : public RegisterReadOnly<0x5802608c> {
            using JDATA4 = Field<0, 32>;    // ADC group injected sequencer rank 4 conversion data
        };

        // ADC analog watchdog 2 configuration register
        struct AWD2CR : public Register<0x580260a0> {
            using AWD2CH = Field<0, 20>;    // ADC analog watchdog 2 monitored channel selection
        };

        // ADC analog watchdog 3 configuration register
        struct AWD3CR : public Register<0x580260a4> {
            using AWD3CH = Field<1, 20>;    // ADC analog watchdog 3 monitored channel selection
        };

        // ADC channel differential or single-ended mode selection register
        struct DIFSEL : public Register<0x580260c0> {
            using Field = Field<0, 20>;    // ADC channel differential or single-ended mode for channel
        };

        // ADC calibration factors register
        struct CALFACT : public Register<0x580260c4> {
            using CALFACT_D = Field<16, 11>;    // ADC calibration factor in differential mode
            using CALFACT_S = Field<0, 11>;    // ADC calibration factor in single-ended mode
        };

        // ADC pre channel selection register
        struct PCSEL : public Register<0x5802601c> {
            using Field = Field<0, 20>;    // Channel x (VINP[i]) pre selection
        };

        // ADC watchdog lower threshold register 2
        struct LTR2 : public Register<0x580260b0> {
            using Field = Field<0, 26>;    // Analog watchdog 2 lower threshold
        };

        // ADC watchdog higher threshold register 2
        struct HTR2 : public Register<0x580260b4> {
            using Field = Field<0, 26>;    // Analog watchdog 2 higher threshold
        };

        // ADC watchdog lower threshold register 3
        struct LTR3 : public Register<0x580260b8> {
            using Field = Field<0, 26>;    // Analog watchdog 3 lower threshold
        };

        // ADC watchdog higher threshold register 3
        struct HTR3 : public Register<0x580260bc> {
            using Field = Field<0, 26>;    // Analog watchdog 3 higher threshold
        };

        // ADC Calibration Factor register 2
        struct CALFACT2 : public Register<0x580260c8> {
            using LINCALFACT = Field<0, 30>;    // Linearity Calibration Factor
        };

    };

    // Analog to Digital Converter
    struct ADC1 {
        // ADC interrupt and status register
        struct ISR : public Register<0x40022000> {
            using JQOVF = Field<10, 1>;    // ADC group injected contexts queue overflow flag
            using AWD3 = Field<9, 1>;    // ADC analog watchdog 3 flag
            using AWD2 = Field<8, 1>;    // ADC analog watchdog 2 flag
            using AWD1 = Field<7, 1>;    // ADC analog watchdog 1 flag
            using JEOS = Field<6, 1>;    // ADC group injected end of sequence conversions flag
            using JEOC = Field<5, 1>;    // ADC group injected end of unitary conversion flag
            using OVR = Field<4, 1>;    // ADC group regular overrun flag
            using EOS = Field<3, 1>;    // ADC group regular end of sequence conversions flag
            using EOC = Field<2, 1>;    // ADC group regular end of unitary conversion flag
            using EOSMP = Field<1, 1>;    // ADC group regular end of sampling flag
            using ADRDY = Field<0, 1>;    // ADC ready flag
        };

        // ADC interrupt enable register
        struct IER : public Register<0x40022004> {
            using JQOVFIE = Field<10, 1>;    // ADC group injected contexts queue overflow interrupt
            using AWD3IE = Field<9, 1>;    // ADC analog watchdog 3 interrupt
            using AWD2IE = Field<8, 1>;    // ADC analog watchdog 2 interrupt
            using AWD1IE = Field<7, 1>;    // ADC analog watchdog 1 interrupt
            using JEOSIE = Field<6, 1>;    // ADC group injected end of sequence conversions interrupt
            using JEOCIE = Field<5, 1>;    // ADC group injected end of unitary conversion interrupt
            using OVRIE = Field<4, 1>;    // ADC group regular overrun interrupt
            using EOSIE = Field<3, 1>;    // ADC group regular end of sequence conversions interrupt
            using EOCIE = Field<2, 1>;    // ADC group regular end of unitary conversion interrupt
            using EOSMPIE = Field<1, 1>;    // ADC group regular end of sampling interrupt
            using ADRDYIE = Field<0, 1>;    // ADC ready interrupt
        };

        // ADC control register
        struct CR : public Register<0x40022008> {
            using ADCAL = Field<31, 1>;    // ADC calibration
            using ADCALDIF = Field<30, 1>;    // ADC differential mode for calibration
            using DEEPPWD = Field<29, 1>;    // ADC deep power down enable
            using ADVREGEN = Field<28, 1>;    // ADC voltage regulator enable
            using LINCALRDYW6 = Field<27, 1>;    // Linearity calibration ready Word 6
            using LINCALRDYW5 = Field<26, 1>;    // Linearity calibration ready Word 5
            using LINCALRDYW4 = Field<25, 1>;    // Linearity calibration ready Word 4
            using LINCALRDYW3 = Field<24, 1>;    // Linearity calibration ready Word 3
            using LINCALRDYW2 = Field<23, 1>;    // Linearity calibration ready Word 2
            using LINCALRDYW1 = Field<22, 1>;    // Linearity calibration ready Word 1
            using ADCALLIN = Field<16, 1>;    // Linearity calibration
            using BOOST = Field<8, 1>;    // Boost mode control
            using JADSTP = Field<5, 1>;    // ADC group injected conversion stop
            using ADSTP = Field<4, 1>;    // ADC group regular conversion stop
            using JADSTART = Field<3, 1>;    // ADC group injected conversion start
            using ADSTART = Field<2, 1>;    // ADC group regular conversion start
            using ADDIS = Field<1, 1>;    // ADC disable
            using ADEN = Field<0, 1>;    // ADC enable
        };

        // ADC configuration register 1
        struct CFGR : public Register<0x4002200c> {
            using JQDIS = Field<31, 1>;    // ADC group injected contexts queue disable
            using AWDCH1CH = Field<26, 5>;    // ADC analog watchdog 1 monitored channel selection
            using JAUTO = Field<25, 1>;    // ADC group injected automatic trigger mode
            using JAWD1EN = Field<24, 1>;    // ADC analog watchdog 1 enable on scope ADC group injected
            using AWD1EN = Field<23, 1>;    // ADC analog watchdog 1 enable on scope ADC group regular
            using AWD1SGL = Field<22, 1>;    // ADC analog watchdog 1 monitoring a single channel or all channels
            using JQM = Field<21, 1>;    // ADC group injected contexts queue mode
            using JDISCEN = Field<20, 1>;    // ADC group injected sequencer discontinuous mode
            using DISCNUM = Field<17, 3>;    // ADC group regular sequencer discontinuous number of ranks
            using DISCEN = Field<16, 1>;    // ADC group regular sequencer discontinuous mode
            using AUTDLY = Field<14, 1>;    // ADC low power auto wait
            using CONT = Field<13, 1>;    // ADC group regular continuous conversion mode
            using OVRMOD = Field<12, 1>;    // ADC group regular overrun configuration
            using EXTEN = Field<10, 2>;    // ADC group regular external trigger polarity
            using EXTSEL = Field<5, 5>;    // ADC group regular external trigger source
            using RES = Field<2, 3>;    // ADC data resolution
            using DMNGT = Field<0, 2>;    // ADC DMA transfer enable
        };

        // ADC configuration register 2
        struct CFGR2 : public Register<0x40022010> {
            using ROVSE = Field<0, 1>;    // ADC oversampler enable on scope ADC group regular
            using JOVSE = Field<1, 1>;    // ADC oversampler enable on scope ADC group injected
            using OVSS = Field<5, 4>;    // ADC oversampling shift
            using TROVS = Field<9, 1>;    // ADC oversampling discontinuous mode (triggered mode) for ADC group regular
            using ROVSM = Field<10, 1>;    // Regular Oversampling mode
            using RSHIFT1 = Field<11, 1>;    // Right-shift data after Offset 1 correction
            using RSHIFT2 = Field<12, 1>;    // Right-shift data after Offset 2 correction
            using RSHIFT3 = Field<13, 1>;    // Right-shift data after Offset 3 correction
            using RSHIFT4 = Field<14, 1>;    // Right-shift data after Offset 4 correction
            using OSR = Field<16, 10>;    // Oversampling ratio
            using LSHIFT = Field<28, 4>;    // Left shift factor
        };

        // ADC sampling time register 1
        struct SMPR1 : public Register<0x40022014> {
            using SMP9 = Field<27, 3>;    // ADC channel 9 sampling time selection
            using SMP8 = Field<24, 3>;    // ADC channel 8 sampling time selection
            using SMP7 = Field<21, 3>;    // ADC channel 7 sampling time selection
            using SMP6 = Field<18, 3>;    // ADC channel 6 sampling time selection
            using SMP5 = Field<15, 3>;    // ADC channel 5 sampling time selection
            using SMP4 = Field<12, 3>;    // ADC channel 4 sampling time selection
            using SMP3 = Field<9, 3>;    // ADC channel 3 sampling time selection
            using SMP2 = Field<6, 3>;    // ADC channel 2 sampling time selection
            using SMP1 = Field<3, 3>;    // ADC channel 1 sampling time selection
        };

        // ADC sampling time register 2
        struct SMPR2 : public Register<0x40022018> {
            using SMP19 = Field<27, 3>;    // ADC channel 18 sampling time selection
            using SMP18 = Field<24, 3>;    // ADC channel 18 sampling time selection
            using SMP17 = Field<21, 3>;    // ADC channel 17 sampling time selection
            using SMP16 = Field<18, 3>;    // ADC channel 16 sampling time selection
            using SMP15 = Field<15, 3>;    // ADC channel 15 sampling time selection
            using SMP14 = Field<12, 3>;    // ADC channel 14 sampling time selection
            using SMP13 = Field<9, 3>;    // ADC channel 13 sampling time selection
            using SMP12 = Field<6, 3>;    // ADC channel 12 sampling time selection
            using SMP11 = Field<3, 3>;    // ADC channel 11 sampling time selection
            using SMP10 = Field<0, 3>;    // ADC channel 10 sampling time selection
        };

        // ADC analog watchdog 1 threshold register
        struct LTR1 : public Register<0x40022020> {
            using Field = Field<0, 26>;    // ADC analog watchdog 1 threshold low
        };

        // ADC analog watchdog 2 threshold register
        struct LHTR1 : public Register<0x40022024> {
            using Field = Field<0, 26>;    // ADC analog watchdog 2 threshold low
        };

        // ADC group regular sequencer ranks register 1
        struct SQR1 : public Register<0x40022030> {
            using SQ4 = Field<24, 5>;    // ADC group regular sequencer rank 4
            using SQ3 = Field<18, 5>;    // ADC group regular sequencer rank 3
            using SQ2 = Field<12, 5>;    // ADC group regular sequencer rank 2
            using SQ1 = Field<6, 5>;    // ADC group regular sequencer rank 1
            using L3 = Field<0, 4>;    // L3
        };

        // ADC group regular sequencer ranks register 2
        struct SQR2 : public Register<0x40022034> {
            using SQ9 = Field<24, 5>;    // ADC group regular sequencer rank 9
            using SQ8 = Field<18, 5>;    // ADC group regular sequencer rank 8
            using SQ7 = Field<12, 5>;    // ADC group regular sequencer rank 7
            using SQ6 = Field<6, 5>;    // ADC group regular sequencer rank 6
            using SQ5 = Field<0, 5>;    // ADC group regular sequencer rank 5
        };

        // ADC group regular sequencer ranks register 3
        struct SQR3 : public Register<0x40022038> {
            using SQ14 = Field<24, 5>;    // ADC group regular sequencer rank 14
            using SQ13 = Field<18, 5>;    // ADC group regular sequencer rank 13
            using SQ12 = Field<12, 5>;    // ADC group regular sequencer rank 12
            using SQ11 = Field<6, 5>;    // ADC group regular sequencer rank 11
            using SQ10 = Field<0, 5>;    // ADC group regular sequencer rank 10
        };

        // ADC group regular sequencer ranks register 4
        struct SQR4 : public Register<0x4002203c> {
            using SQ16 = Field<6, 5>;    // ADC group regular sequencer rank 16
            using SQ15 = Field<0, 5>;    // ADC group regular sequencer rank 15
        };

        // ADC group regular conversion data register
        struct DR : public RegisterReadOnly<0x40022040> {
            using RDATA = Field<0, 16>;    // ADC group regular conversion data
        };

        // ADC group injected sequencer register
        struct JSQR : public Register<0x4002204c> {
            using JSQ4 = Field<27, 5>;    // ADC group injected sequencer rank 4
            using JSQ3 = Field<21, 5>;    // ADC group injected sequencer rank 3
            using JSQ2 = Field<15, 5>;    // ADC group injected sequencer rank 2
            using JSQ1 = Field<9, 5>;    // ADC group injected sequencer rank 1
            using JEXTEN = Field<7, 2>;    // ADC group injected external trigger polarity
            using JEXTSEL = Field<2, 5>;    // ADC group injected external trigger source
            using JL = Field<0, 2>;    // ADC group injected sequencer scan length
        };

        // ADC offset number 1 register
        struct OFR1 : public Register<0x40022060> {
            using SSATE = Field<31, 1>;    // ADC offset number 1 enable
            using OFFSET1_CH = Field<26, 5>;    // ADC offset number 1 channel selection
            using OFFSET1 = Field<0, 26>;    // ADC offset number 1 offset level
        };

        // ADC offset number 2 register
        struct OFR2 : public Register<0x40022064> {
            using SSATE = Field<31, 1>;    // ADC offset number 1 enable
            using OFFSET1_CH = Field<26, 5>;    // ADC offset number 1 channel selection
            using OFFSET1 = Field<0, 26>;    // ADC offset number 1 offset level
        };

        // ADC offset number 3 register
        struct OFR3 : public Register<0x40022068> {
            using SSATE = Field<31, 1>;    // ADC offset number 1 enable
            using OFFSET1_CH = Field<26, 5>;    // ADC offset number 1 channel selection
            using OFFSET1 = Field<0, 26>;    // ADC offset number 1 offset level
        };

        // ADC offset number 4 register
        struct OFR4 : public Register<0x4002206c> {
            using SSATE = Field<31, 1>;    // ADC offset number 1 enable
            using OFFSET1_CH = Field<26, 5>;    // ADC offset number 1 channel selection
            using OFFSET1 = Field<0, 26>;    // ADC offset number 1 offset level
        };

        // ADC group injected sequencer rank 1 register
        struct JDR1 : public RegisterReadOnly<0x40022080> {
            using JDATA1 = Field<0, 32>;    // ADC group injected sequencer rank 1 conversion data
        };

        // ADC group injected sequencer rank 2 register
        struct JDR2 : public RegisterReadOnly<0x40022084> {
            using JDATA2 = Field<0, 32>;    // ADC group injected sequencer rank 2 conversion data
        };

        // ADC group injected sequencer rank 3 register
        struct JDR3 : public RegisterReadOnly<0x40022088> {
            using JDATA3 = Field<0, 32>;    // ADC group injected sequencer rank 3 conversion data
        };

        // ADC group injected sequencer rank 4 register
        struct JDR4 : public RegisterReadOnly<0x4002208c> {
            using JDATA4 = Field<0, 32>;    // ADC group injected sequencer rank 4 conversion data
        };

        // ADC analog watchdog 2 configuration register
        struct AWD2CR : public Register<0x400220a0> {
            using AWD2CH = Field<0, 20>;    // ADC analog watchdog 2 monitored channel selection
        };

        // ADC analog watchdog 3 configuration register
        struct AWD3CR : public Register<0x400220a4> {
            using AWD3CH = Field<1, 20>;    // ADC analog watchdog 3 monitored channel selection
        };

        // ADC channel differential or single-ended mode selection register
        struct DIFSEL : public Register<0x400220c0> {
            using Field = Field<0, 20>;    // ADC channel differential or single-ended mode for channel
        };

        // ADC calibration factors register
        struct CALFACT : public Register<0x400220c4> {
            using CALFACT_D = Field<16, 11>;    // ADC calibration factor in differential mode
            using CALFACT_S = Field<0, 11>;    // ADC calibration factor in single-ended mode
        };

        // ADC pre channel selection register
        struct PCSEL : public Register<0x4002201c> {
            using Field = Field<0, 20>;    // Channel x (VINP[i]) pre selection
        };

        // ADC watchdog lower threshold register 2
        struct LTR2 : public Register<0x400220b0> {
            using Field = Field<0, 26>;    // Analog watchdog 2 lower threshold
        };

        // ADC watchdog higher threshold register 2
        struct HTR2 : public Register<0x400220b4> {
            using Field = Field<0, 26>;    // Analog watchdog 2 higher threshold
        };

        // ADC watchdog lower threshold register 3
        struct LTR3 : public Register<0x400220b8> {
            using Field = Field<0, 26>;    // Analog watchdog 3 lower threshold
        };

        // ADC watchdog higher threshold register 3
        struct HTR3 : public Register<0x400220bc> {
            using Field = Field<0, 26>;    // Analog watchdog 3 higher threshold
        };

        // ADC Calibration Factor register 2
        struct CALFACT2 : public Register<0x400220c8> {
            using LINCALFACT = Field<0, 30>;    // Linearity Calibration Factor
        };

    };

    // Analog to Digital Converter
    struct ADC2 {
        // ADC interrupt and status register
        struct ISR : public Register<0x40022100> {
            using JQOVF = Field<10, 1>;    // ADC group injected contexts queue overflow flag
            using AWD3 = Field<9, 1>;    // ADC analog watchdog 3 flag
            using AWD2 = Field<8, 1>;    // ADC analog watchdog 2 flag
            using AWD1 = Field<7, 1>;    // ADC analog watchdog 1 flag
            using JEOS = Field<6, 1>;    // ADC group injected end of sequence conversions flag
            using JEOC = Field<5, 1>;    // ADC group injected end of unitary conversion flag
            using OVR = Field<4, 1>;    // ADC group regular overrun flag
            using EOS = Field<3, 1>;    // ADC group regular end of sequence conversions flag
            using EOC = Field<2, 1>;    // ADC group regular end of unitary conversion flag
            using EOSMP = Field<1, 1>;    // ADC group regular end of sampling flag
            using ADRDY = Field<0, 1>;    // ADC ready flag
        };

        // ADC interrupt enable register
        struct IER : public Register<0x40022104> {
            using JQOVFIE = Field<10, 1>;    // ADC group injected contexts queue overflow interrupt
            using AWD3IE = Field<9, 1>;    // ADC analog watchdog 3 interrupt
            using AWD2IE = Field<8, 1>;    // ADC analog watchdog 2 interrupt
            using AWD1IE = Field<7, 1>;    // ADC analog watchdog 1 interrupt
            using JEOSIE = Field<6, 1>;    // ADC group injected end of sequence conversions interrupt
            using JEOCIE = Field<5, 1>;    // ADC group injected end of unitary conversion interrupt
            using OVRIE = Field<4, 1>;    // ADC group regular overrun interrupt
            using EOSIE = Field<3, 1>;    // ADC group regular end of sequence conversions interrupt
            using EOCIE = Field<2, 1>;    // ADC group regular end of unitary conversion interrupt
            using EOSMPIE = Field<1, 1>;    // ADC group regular end of sampling interrupt
            using ADRDYIE = Field<0, 1>;    // ADC ready interrupt
        };

        // ADC control register
        struct CR : public Register<0x40022108> {
            using ADCAL = Field<31, 1>;    // ADC calibration
            using ADCALDIF = Field<30, 1>;    // ADC differential mode for calibration
            using DEEPPWD = Field<29, 1>;    // ADC deep power down enable
            using ADVREGEN = Field<28, 1>;    // ADC voltage regulator enable
            using LINCALRDYW6 = Field<27, 1>;    // Linearity calibration ready Word 6
            using LINCALRDYW5 = Field<26, 1>;    // Linearity calibration ready Word 5
            using LINCALRDYW4 = Field<25, 1>;    // Linearity calibration ready Word 4
            using LINCALRDYW3 = Field<24, 1>;    // Linearity calibration ready Word 3
            using LINCALRDYW2 = Field<23, 1>;    // Linearity calibration ready Word 2
            using LINCALRDYW1 = Field<22, 1>;    // Linearity calibration ready Word 1
            using ADCALLIN = Field<16, 1>;    // Linearity calibration
            using BOOST = Field<8, 1>;    // Boost mode control
            using JADSTP = Field<5, 1>;    // ADC group injected conversion stop
            using ADSTP = Field<4, 1>;    // ADC group regular conversion stop
            using JADSTART = Field<3, 1>;    // ADC group injected conversion start
            using ADSTART = Field<2, 1>;    // ADC group regular conversion start
            using ADDIS = Field<1, 1>;    // ADC disable
            using ADEN = Field<0, 1>;    // ADC enable
        };

        // ADC configuration register 1
        struct CFGR : public Register<0x4002210c> {
            using JQDIS = Field<31, 1>;    // ADC group injected contexts queue disable
            using AWDCH1CH = Field<26, 5>;    // ADC analog watchdog 1 monitored channel selection
            using JAUTO = Field<25, 1>;    // ADC group injected automatic trigger mode
            using JAWD1EN = Field<24, 1>;    // ADC analog watchdog 1 enable on scope ADC group injected
            using AWD1EN = Field<23, 1>;    // ADC analog watchdog 1 enable on scope ADC group regular
            using AWD1SGL = Field<22, 1>;    // ADC analog watchdog 1 monitoring a single channel or all channels
            using JQM = Field<21, 1>;    // ADC group injected contexts queue mode
            using JDISCEN = Field<20, 1>;    // ADC group injected sequencer discontinuous mode
            using DISCNUM = Field<17, 3>;    // ADC group regular sequencer discontinuous number of ranks
            using DISCEN = Field<16, 1>;    // ADC group regular sequencer discontinuous mode
            using AUTDLY = Field<14, 1>;    // ADC low power auto wait
            using CONT = Field<13, 1>;    // ADC group regular continuous conversion mode
            using OVRMOD = Field<12, 1>;    // ADC group regular overrun configuration
            using EXTEN = Field<10, 2>;    // ADC group regular external trigger polarity
            using EXTSEL = Field<5, 5>;    // ADC group regular external trigger source
            using RES = Field<2, 3>;    // ADC data resolution
            using DMNGT = Field<0, 2>;    // ADC DMA transfer enable
        };

        // ADC configuration register 2
        struct CFGR2 : public Register<0x40022110> {
            using ROVSE = Field<0, 1>;    // ADC oversampler enable on scope ADC group regular
            using JOVSE = Field<1, 1>;    // ADC oversampler enable on scope ADC group injected
            using OVSS = Field<5, 4>;    // ADC oversampling shift
            using TROVS = Field<9, 1>;    // ADC oversampling discontinuous mode (triggered mode) for ADC group regular
            using ROVSM = Field<10, 1>;    // Regular Oversampling mode
            using RSHIFT1 = Field<11, 1>;    // Right-shift data after Offset 1 correction
            using RSHIFT2 = Field<12, 1>;    // Right-shift data after Offset 2 correction
            using RSHIFT3 = Field<13, 1>;    // Right-shift data after Offset 3 correction
            using RSHIFT4 = Field<14, 1>;    // Right-shift data after Offset 4 correction
            using OSR = Field<16, 10>;    // Oversampling ratio
            using LSHIFT = Field<28, 4>;    // Left shift factor
        };

        // ADC sampling time register 1
        struct SMPR1 : public Register<0x40022114> {
            using SMP9 = Field<27, 3>;    // ADC channel 9 sampling time selection
            using SMP8 = Field<24, 3>;    // ADC channel 8 sampling time selection
            using SMP7 = Field<21, 3>;    // ADC channel 7 sampling time selection
            using SMP6 = Field<18, 3>;    // ADC channel 6 sampling time selection
            using SMP5 = Field<15, 3>;    // ADC channel 5 sampling time selection
            using SMP4 = Field<12, 3>;    // ADC channel 4 sampling time selection
            using SMP3 = Field<9, 3>;    // ADC channel 3 sampling time selection
            using SMP2 = Field<6, 3>;    // ADC channel 2 sampling time selection
            using SMP1 = Field<3, 3>;    // ADC channel 1 sampling time selection
        };

        // ADC sampling time register 2
        struct SMPR2 : public Register<0x40022118> {
            using SMP19 = Field<27, 3>;    // ADC channel 18 sampling time selection
            using SMP18 = Field<24, 3>;    // ADC channel 18 sampling time selection
            using SMP17 = Field<21, 3>;    // ADC channel 17 sampling time selection
            using SMP16 = Field<18, 3>;    // ADC channel 16 sampling time selection
            using SMP15 = Field<15, 3>;    // ADC channel 15 sampling time selection
            using SMP14 = Field<12, 3>;    // ADC channel 14 sampling time selection
            using SMP13 = Field<9, 3>;    // ADC channel 13 sampling time selection
            using SMP12 = Field<6, 3>;    // ADC channel 12 sampling time selection
            using SMP11 = Field<3, 3>;    // ADC channel 11 sampling time selection
            using SMP10 = Field<0, 3>;    // ADC channel 10 sampling time selection
        };

        // ADC analog watchdog 1 threshold register
        struct LTR1 : public Register<0x40022120> {
            using Field = Field<0, 26>;    // ADC analog watchdog 1 threshold low
        };

        // ADC analog watchdog 2 threshold register
        struct LHTR1 : public Register<0x40022124> {
            using Field = Field<0, 26>;    // ADC analog watchdog 2 threshold low
        };

        // ADC group regular sequencer ranks register 1
        struct SQR1 : public Register<0x40022130> {
            using SQ4 = Field<24, 5>;    // ADC group regular sequencer rank 4
            using SQ3 = Field<18, 5>;    // ADC group regular sequencer rank 3
            using SQ2 = Field<12, 5>;    // ADC group regular sequencer rank 2
            using SQ1 = Field<6, 5>;    // ADC group regular sequencer rank 1
            using L3 = Field<0, 4>;    // L3
        };

        // ADC group regular sequencer ranks register 2
        struct SQR2 : public Register<0x40022134> {
            using SQ9 = Field<24, 5>;    // ADC group regular sequencer rank 9
            using SQ8 = Field<18, 5>;    // ADC group regular sequencer rank 8
            using SQ7 = Field<12, 5>;    // ADC group regular sequencer rank 7
            using SQ6 = Field<6, 5>;    // ADC group regular sequencer rank 6
            using SQ5 = Field<0, 5>;    // ADC group regular sequencer rank 5
        };

        // ADC group regular sequencer ranks register 3
        struct SQR3 : public Register<0x40022138> {
            using SQ14 = Field<24, 5>;    // ADC group regular sequencer rank 14
            using SQ13 = Field<18, 5>;    // ADC group regular sequencer rank 13
            using SQ12 = Field<12, 5>;    // ADC group regular sequencer rank 12
            using SQ11 = Field<6, 5>;    // ADC group regular sequencer rank 11
            using SQ10 = Field<0, 5>;    // ADC group regular sequencer rank 10
        };

        // ADC group regular sequencer ranks register 4
        struct SQR4 : public Register<0x4002213c> {
            using SQ16 = Field<6, 5>;    // ADC group regular sequencer rank 16
            using SQ15 = Field<0, 5>;    // ADC group regular sequencer rank 15
        };

        // ADC group regular conversion data register
        struct DR : public RegisterReadOnly<0x40022140> {
            using RDATA = Field<0, 16>;    // ADC group regular conversion data
        };

        // ADC group injected sequencer register
        struct JSQR : public Register<0x4002214c> {
            using JSQ4 = Field<27, 5>;    // ADC group injected sequencer rank 4
            using JSQ3 = Field<21, 5>;    // ADC group injected sequencer rank 3
            using JSQ2 = Field<15, 5>;    // ADC group injected sequencer rank 2
            using JSQ1 = Field<9, 5>;    // ADC group injected sequencer rank 1
            using JEXTEN = Field<7, 2>;    // ADC group injected external trigger polarity
            using JEXTSEL = Field<2, 5>;    // ADC group injected external trigger source
            using JL = Field<0, 2>;    // ADC group injected sequencer scan length
        };

        // ADC offset number 1 register
        struct OFR1 : public Register<0x40022160> {
            using SSATE = Field<31, 1>;    // ADC offset number 1 enable
            using OFFSET1_CH = Field<26, 5>;    // ADC offset number 1 channel selection
            using OFFSET1 = Field<0, 26>;    // ADC offset number 1 offset level
        };

        // ADC offset number 2 register
        struct OFR2 : public Register<0x40022164> {
            using SSATE = Field<31, 1>;    // ADC offset number 1 enable
            using OFFSET1_CH = Field<26, 5>;    // ADC offset number 1 channel selection
            using OFFSET1 = Field<0, 26>;    // ADC offset number 1 offset level
        };

        // ADC offset number 3 register
        struct OFR3 : public Register<0x40022168> {
            using SSATE = Field<31, 1>;    // ADC offset number 1 enable
            using OFFSET1_CH = Field<26, 5>;    // ADC offset number 1 channel selection
            using OFFSET1 = Field<0, 26>;    // ADC offset number 1 offset level
        };

        // ADC offset number 4 register
        struct OFR4 : public Register<0x4002216c> {
            using SSATE = Field<31, 1>;    // ADC offset number 1 enable
            using OFFSET1_CH = Field<26, 5>;    // ADC offset number 1 channel selection
            using OFFSET1 = Field<0, 26>;    // ADC offset number 1 offset level
        };

        // ADC group injected sequencer rank 1 register
        struct JDR1 : public RegisterReadOnly<0x40022180> {
            using JDATA1 = Field<0, 32>;    // ADC group injected sequencer rank 1 conversion data
        };

        // ADC group injected sequencer rank 2 register
        struct JDR2 : public RegisterReadOnly<0x40022184> {
            using JDATA2 = Field<0, 32>;    // ADC group injected sequencer rank 2 conversion data
        };

        // ADC group injected sequencer rank 3 register
        struct JDR3 : public RegisterReadOnly<0x40022188> {
            using JDATA3 = Field<0, 32>;    // ADC group injected sequencer rank 3 conversion data
        };

        // ADC group injected sequencer rank 4 register
        struct JDR4 : public RegisterReadOnly<0x4002218c> {
            using JDATA4 = Field<0, 32>;    // ADC group injected sequencer rank 4 conversion data
        };

        // ADC analog watchdog 2 configuration register
        struct AWD2CR : public Register<0x400221a0> {
            using AWD2CH = Field<0, 20>;    // ADC analog watchdog 2 monitored channel selection
        };

        // ADC analog watchdog 3 configuration register
        struct AWD3CR : public Register<0x400221a4> {
            using AWD3CH = Field<1, 20>;    // ADC analog watchdog 3 monitored channel selection
        };

        // ADC channel differential or single-ended mode selection register
        struct DIFSEL : public Register<0x400221c0> {
            using Field = Field<0, 20>;    // ADC channel differential or single-ended mode for channel
        };

        // ADC calibration factors register
        struct CALFACT : public Register<0x400221c4> {
            using CALFACT_D = Field<16, 11>;    // ADC calibration factor in differential mode
            using CALFACT_S = Field<0, 11>;    // ADC calibration factor in single-ended mode
        };

        // ADC pre channel selection register
        struct PCSEL : public Register<0x4002211c> {
            using Field = Field<0, 20>;    // Channel x (VINP[i]) pre selection
        };

        // ADC watchdog lower threshold register 2
        struct LTR2 : public Register<0x400221b0> {
            using Field = Field<0, 26>;    // Analog watchdog 2 lower threshold
        };

        // ADC watchdog higher threshold register 2
        struct HTR2 : public Register<0x400221b4> {
            using Field = Field<0, 26>;    // Analog watchdog 2 higher threshold
        };

        // ADC watchdog lower threshold register 3
        struct LTR3 : public Register<0x400221b8> {
            using Field = Field<0, 26>;    // Analog watchdog 3 lower threshold
        };

        // ADC watchdog higher threshold register 3
        struct HTR3 : public Register<0x400221bc> {
            using Field = Field<0, 26>;    // Analog watchdog 3 higher threshold
        };

        // ADC Calibration Factor register 2
        struct CALFACT2 : public Register<0x400221c8> {
            using LINCALFACT = Field<0, 30>;    // Linearity Calibration Factor
        };

    };

    // Analog-to-Digital Converter
    struct ADC3_Common {
        // ADC Common status register
        struct CSR : public RegisterReadOnly<0x58026300> {
            using ADRDY_MST = Field<0, 1>;    // Master ADC ready
            using EOSMP_MST = Field<1, 1>;    // End of Sampling phase flag of the master ADC
            using EOC_MST = Field<2, 1>;    // End of regular conversion of the master ADC
            using EOS_MST = Field<3, 1>;    // End of regular sequence flag of the master ADC
            using OVR_MST = Field<4, 1>;    // Overrun flag of the master ADC
            using JEOC_MST = Field<5, 1>;    // End of injected conversion flag of the master ADC
            using JEOS_MST = Field<6, 1>;    // End of injected sequence flag of the master ADC
            using AWD1_MST = Field<7, 1>;    // Analog watchdog 1 flag of the master ADC
            using AWD2_MST = Field<8, 1>;    // Analog watchdog 2 flag of the master ADC
            using AWD3_MST = Field<9, 1>;    // Analog watchdog 3 flag of the master ADC
            using JQOVF_MST = Field<10, 1>;    // Injected Context Queue Overflow flag of the master ADC
            using ADRDY_SLV = Field<16, 1>;    // Slave ADC ready
            using EOSMP_SLV = Field<17, 1>;    // End of Sampling phase flag of the slave ADC
            using EOC_SLV = Field<18, 1>;    // End of regular conversion of the slave ADC
            using EOS_SLV = Field<19, 1>;    // End of regular sequence flag of the slave ADC
            using OVR_SLV = Field<20, 1>;    // Overrun flag of the slave ADC
            using JEOC_SLV = Field<21, 1>;    // End of injected conversion flag of the slave ADC
            using JEOS_SLV = Field<22, 1>;    // End of injected sequence flag of the slave ADC
            using AWD1_SLV = Field<23, 1>;    // Analog watchdog 1 flag of the slave ADC
            using AWD2_SLV = Field<24, 1>;    // Analog watchdog 2 flag of the slave ADC
            using AWD3_SLV = Field<25, 1>;    // Analog watchdog 3 flag of the slave ADC
            using JQOVF_SLV = Field<26, 1>;    // Injected Context Queue Overflow flag of the slave ADC
        };

        // ADC common control register
        struct CCR : public Register<0x58026308> {
            using DUAL = Field<0, 5>;    // Dual ADC mode selection
            using DELAY = Field<8, 4>;    // Delay between 2 sampling phases
            using DAMDF = Field<14, 2>;    // Dual ADC Mode Data Format
            using CKMODE = Field<16, 2>;    // ADC clock mode
            using PRESC = Field<18, 4>;    // ADC prescaler
            using VREFEN = Field<22, 1>;    // VREFINT enable
            using TSEN = Field<23, 1>;    // Temperature sensor enable
            using VBATEN = Field<24, 1>;    // VBAT enable
        };

        // ADC common regular data register for dual and triple modes
        struct CDR : public RegisterReadOnly<0x5802630c> {
            using RDATA_SLV = Field<16, 16>;    // Regular data of the slave ADC
            using RDATA_MST = Field<0, 16>;    // Regular data of the master ADC
        };

        // ADC x common regular data register for 32-bit dual mode
        struct CDR2 : public RegisterReadOnly<0x58026310> {
            using RDATA_ALT = Field<0, 32>;    // Regular data of the master/slave alternated ADCs
        };

    };

    // Analog-to-Digital Converter
    struct ADC12_Common {
        // ADC Common status register
        struct CSR : public RegisterReadOnly<0x40022300> {
            using ADRDY_MST = Field<0, 1>;    // Master ADC ready
            using EOSMP_MST = Field<1, 1>;    // End of Sampling phase flag of the master ADC
            using EOC_MST = Field<2, 1>;    // End of regular conversion of the master ADC
            using EOS_MST = Field<3, 1>;    // End of regular sequence flag of the master ADC
            using OVR_MST = Field<4, 1>;    // Overrun flag of the master ADC
            using JEOC_MST = Field<5, 1>;    // End of injected conversion flag of the master ADC
            using JEOS_MST = Field<6, 1>;    // End of injected sequence flag of the master ADC
            using AWD1_MST = Field<7, 1>;    // Analog watchdog 1 flag of the master ADC
            using AWD2_MST = Field<8, 1>;    // Analog watchdog 2 flag of the master ADC
            using AWD3_MST = Field<9, 1>;    // Analog watchdog 3 flag of the master ADC
            using JQOVF_MST = Field<10, 1>;    // Injected Context Queue Overflow flag of the master ADC
            using ADRDY_SLV = Field<16, 1>;    // Slave ADC ready
            using EOSMP_SLV = Field<17, 1>;    // End of Sampling phase flag of the slave ADC
            using EOC_SLV = Field<18, 1>;    // End of regular conversion of the slave ADC
            using EOS_SLV = Field<19, 1>;    // End of regular sequence flag of the slave ADC
            using OVR_SLV = Field<20, 1>;    // Overrun flag of the slave ADC
            using JEOC_SLV = Field<21, 1>;    // End of injected conversion flag of the slave ADC
            using JEOS_SLV = Field<22, 1>;    // End of injected sequence flag of the slave ADC
            using AWD1_SLV = Field<23, 1>;    // Analog watchdog 1 flag of the slave ADC
            using AWD2_SLV = Field<24, 1>;    // Analog watchdog 2 flag of the slave ADC
            using AWD3_SLV = Field<25, 1>;    // Analog watchdog 3 flag of the slave ADC
            using JQOVF_SLV = Field<26, 1>;    // Injected Context Queue Overflow flag of the slave ADC
        };

        // ADC common control register
        struct CCR : public Register<0x40022308> {
            using DUAL = Field<0, 5>;    // Dual ADC mode selection
            using DELAY = Field<8, 4>;    // Delay between 2 sampling phases
            using DAMDF = Field<14, 2>;    // Dual ADC Mode Data Format
            using CKMODE = Field<16, 2>;    // ADC clock mode
            using PRESC = Field<18, 4>;    // ADC prescaler
            using VREFEN = Field<22, 1>;    // VREFINT enable
            using TSEN = Field<23, 1>;    // Temperature sensor enable
            using VBATEN = Field<24, 1>;    // VBAT enable
        };

        // ADC common regular data register for dual and triple modes
        struct CDR : public RegisterReadOnly<0x4002230c> {
            using RDATA_SLV = Field<16, 16>;    // Regular data of the slave ADC
            using RDATA_MST = Field<0, 16>;    // Regular data of the master ADC
        };

        // ADC x common regular data register for 32-bit dual mode
        struct CDR2 : public RegisterReadOnly<0x40022310> {
            using RDATA_ALT = Field<0, 32>;    // Regular data of the master/slave alternated ADCs
        };

    };

    // DMAMUX
    struct DMAMUX1 {
        // DMAMux - DMA request line multiplexer channel x control register
        struct C0CR : public Register<0x40020800> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C1CR : public Register<0x40020804> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C2CR : public Register<0x40020808> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C3CR : public Register<0x4002080c> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C4CR : public Register<0x40020810> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C5CR : public Register<0x40020814> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C6CR : public Register<0x40020818> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C7CR : public Register<0x4002081c> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C8CR : public Register<0x40020820> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C9CR : public Register<0x40020824> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C10CR : public Register<0x40020828> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C11CR : public Register<0x4002082c> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C12CR : public Register<0x40020830> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C13CR : public Register<0x40020834> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C14CR : public Register<0x40020838> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C15CR : public Register<0x4002083c> {
            using DMAREQ_ID = Field<0, 8>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request generator channel x control register
        struct RG0CR : public Register<0x40020900> {
            using SIG_ID = Field<0, 5>;    // DMA request trigger input selected
            using OIE = Field<8, 1>;    // Interrupt enable at trigger event overrun
            using GE = Field<16, 1>;    // DMA request generator channel enable/disable
            using GPOL = Field<17, 2>;    // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
            using GNBREQ = Field<19, 5>;    // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
        };

        // DMAMux - DMA request generator channel x control register
        struct RG1CR : public Register<0x40020904> {
            using SIG_ID = Field<0, 5>;    // DMA request trigger input selected
            using OIE = Field<8, 1>;    // Interrupt enable at trigger event overrun
            using GE = Field<16, 1>;    // DMA request generator channel enable/disable
            using GPOL = Field<17, 2>;    // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
            using GNBREQ = Field<19, 5>;    // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
        };

        // DMAMux - DMA request generator channel x control register
        struct RG2CR : public Register<0x40020908> {
            using SIG_ID = Field<0, 5>;    // DMA request trigger input selected
            using OIE = Field<8, 1>;    // Interrupt enable at trigger event overrun
            using GE = Field<16, 1>;    // DMA request generator channel enable/disable
            using GPOL = Field<17, 2>;    // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
            using GNBREQ = Field<19, 5>;    // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
        };

        // DMAMux - DMA request generator channel x control register
        struct RG3CR : public Register<0x4002090c> {
            using SIG_ID = Field<0, 5>;    // DMA request trigger input selected
            using OIE = Field<8, 1>;    // Interrupt enable at trigger event overrun
            using GE = Field<16, 1>;    // DMA request generator channel enable/disable
            using GPOL = Field<17, 2>;    // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
            using GNBREQ = Field<19, 5>;    // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
        };

        // DMAMux - DMA request generator channel x control register
        struct RG4CR : public Register<0x40020910> {
            using SIG_ID = Field<0, 5>;    // DMA request trigger input selected
            using OIE = Field<8, 1>;    // Interrupt enable at trigger event overrun
            using GE = Field<16, 1>;    // DMA request generator channel enable/disable
            using GPOL = Field<17, 2>;    // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
            using GNBREQ = Field<19, 5>;    // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
        };

        // DMAMux - DMA request generator channel x control register
        struct RG5CR : public Register<0x40020914> {
            using SIG_ID = Field<0, 5>;    // DMA request trigger input selected
            using OIE = Field<8, 1>;    // Interrupt enable at trigger event overrun
            using GE = Field<16, 1>;    // DMA request generator channel enable/disable
            using GPOL = Field<17, 2>;    // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
            using GNBREQ = Field<19, 5>;    // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
        };

        // DMAMux - DMA request generator channel x control register
        struct RG6CR : public Register<0x40020918> {
            using SIG_ID = Field<0, 5>;    // DMA request trigger input selected
            using OIE = Field<8, 1>;    // Interrupt enable at trigger event overrun
            using GE = Field<16, 1>;    // DMA request generator channel enable/disable
            using GPOL = Field<17, 2>;    // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
            using GNBREQ = Field<19, 5>;    // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
        };

        // DMAMux - DMA request generator channel x control register
        struct RG7CR : public Register<0x4002091c> {
            using SIG_ID = Field<0, 5>;    // DMA request trigger input selected
            using OIE = Field<8, 1>;    // Interrupt enable at trigger event overrun
            using GE = Field<16, 1>;    // DMA request generator channel enable/disable
            using GPOL = Field<17, 2>;    // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
            using GNBREQ = Field<19, 5>;    // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
        };

        // DMAMux - DMA request generator status register
        struct RGSR : public RegisterReadOnly<0x40020940> {
            using OF = Field<0, 8>;    // Trigger event overrun flag The flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding COFx bit in DMAMUX_RGCFR register.
        };

        // DMAMux - DMA request generator clear flag register
        struct RGCFR : public RegisterWriteOnly<0x40020944> {
            using COF = Field<0, 8>;    // Clear trigger event overrun flag Upon setting, this bit clears the corresponding overrun flag OFx in the DMAMUX_RGCSR register.
        };

        // DMAMUX request line multiplexer interrupt channel status register
        struct CSR : public RegisterReadOnly<0x40020880> {
            using SOF = Field<0, 16>;    // Synchronization overrun event flag
        };

        // DMAMUX request line multiplexer interrupt clear flag register
        struct CFR : public RegisterWriteOnly<0x40020884> {
            using CSOF = Field<0, 16>;    // Clear synchronization overrun event flag
        };

    };

    // Cryptographic processor
    struct CRC {
        // Data register
        struct DR : public Register<0x58024c00> {
            using Field = Field<0, 32>;    // Data Register
        };

        // Independent Data register
        struct IDR : public Register<0x58024c04> {
            using Field = Field<0, 32>;    // Independent Data register
        };

        // Control register
        struct CR : public Register<0x58024c08> {
            using RESET = Field<0, 1>;    // RESET bit
            using POLYSIZE = Field<3, 2>;    // Polynomial size
            using REV_IN = Field<5, 2>;    // Reverse input data
            using REV_OUT = Field<7, 1>;    // Reverse output data
        };

        // Initial CRC value
        struct INIT : public Register<0x58024c0c> {
            using CRC_INIT = Field<0, 32>;    // Programmable initial CRC value
        };

        // CRC polynomial
        struct POL : public Register<0x58024c10> {
            using Field = Field<0, 32>;    // Programmable polynomial
        };

    };

    // Reset and clock control
    struct RCC {
        // clock control register
        struct CR : public Register<0x58024400> {
            using HSION = Field<0, 1>;    // Internal high-speed clock enable
            using HSIKERON = Field<1, 1>;    // High Speed Internal clock enable in Stop mode
            using HSIRDY = Field<2, 1>;    // HSI clock ready flag
            using HSIDIV = Field<3, 2>;    // HSI clock divider
            using HSIDIVF = Field<5, 1>;    // HSI divider flag
            using CSION = Field<7, 1>;    // CSI clock enable
            using CSIRDY = Field<8, 1>;    // CSI clock ready flag
            using CSIKERON = Field<9, 1>;    // CSI clock enable in Stop mode
            using RC48ON = Field<12, 1>;    // RC48 clock enable
            using RC48RDY = Field<13, 1>;    // RC48 clock ready flag
            using D1CKRDY = Field<14, 1>;    // D1 domain clocks ready flag
            using D2CKRDY = Field<15, 1>;    // D2 domain clocks ready flag
            using HSEON = Field<16, 1>;    // HSE clock enable
            using HSERDY = Field<17, 1>;    // HSE clock ready flag
            using HSEBYP = Field<18, 1>;    // HSE clock bypass
            using HSECSSON = Field<19, 1>;    // HSE Clock Security System enable
            using PLL1ON = Field<24, 1>;    // PLL1 enable
            using PLL1RDY = Field<25, 1>;    // PLL1 clock ready flag
            using PLL2ON = Field<26, 1>;    // PLL2 enable
            using PLL2RDY = Field<27, 1>;    // PLL2 clock ready flag
            using PLL3ON = Field<28, 1>;    // PLL3 enable
            using PLL3RDY = Field<29, 1>;    // PLL3 clock ready flag
        };

        // RCC Internal Clock Source Calibration Register
        struct ICSCR : public Register<0x58024404> {
            using HSICAL = Field<0, 12>;    // HSI clock calibration
            using HSITRIM = Field<12, 6>;    // HSI clock trimming
            using CSICAL = Field<18, 8>;    // CSI clock calibration
            using CSITRIM = Field<26, 5>;    // CSI clock trimming
        };

        // RCC Clock Recovery RC Register
        struct CRRCR : public RegisterReadOnly<0x58024408> {
            using RC48CAL = Field<0, 10>;    // Internal RC 48 MHz clock calibration
        };

        // RCC Clock Configuration Register
        struct CFGR : public Register<0x58024410> {
            using SW = Field<0, 3>;    // System clock switch
            using SWS = Field<3, 3>;    // System clock switch status
            using STOPWUCK = Field<6, 1>;    // System clock selection after a wake up from system Stop
            using STOPKERWUCK = Field<7, 1>;    // Kernel clock selection after a wake up from system Stop
            using RTCPRE = Field<8, 6>;    // HSE division factor for RTC clock
            using HRTIMSEL = Field<14, 1>;    // High Resolution Timer clock prescaler selection
            using TIMPRE = Field<15, 1>;    // Timers clocks prescaler selection
            using MCO1PRE = Field<18, 4>;    // MCO1 prescaler
            using MCO1SEL = Field<22, 3>;    // Micro-controller clock output 1
            using MCO2PRE = Field<25, 4>;    // MCO2 prescaler
            using MCO2SEL = Field<29, 3>;    // Micro-controller clock output 2
        };

        // RCC Domain 1 Clock Configuration Register
        struct D1CFGR : public Register<0x58024418> {
            using HPRE = Field<0, 4>;    // D1 domain AHB prescaler
            using D1PPRE = Field<4, 3>;    // D1 domain APB3 prescaler
            using D1CPRE = Field<8, 4>;    // D1 domain Core prescaler
        };

        // RCC Domain 2 Clock Configuration Register
        struct D2CFGR : public Register<0x5802441c> {
            using D2PPRE1 = Field<4, 3>;    // D2 domain APB1 prescaler
            using D2PPRE2 = Field<8, 3>;    // D2 domain APB2 prescaler
        };

        // RCC Domain 3 Clock Configuration Register
        struct D3CFGR : public Register<0x58024420> {
            using D3PPRE = Field<4, 3>;    // D3 domain APB4 prescaler
        };

        // RCC PLLs Clock Source Selection Register
        struct PLLCKSELR : public Register<0x58024428> {
            using PLLSRC = Field<0, 2>;    // DIVMx and PLLs clock source selection
            using DIVM1 = Field<4, 6>;    // Prescaler for PLL1
            using DIVM2 = Field<12, 6>;    // Prescaler for PLL2
            using DIVM3 = Field<20, 6>;    // Prescaler for PLL3
        };

        // RCC PLLs Configuration Register
        struct PLLCFGR : public Register<0x5802442c> {
            using PLL1FRACEN = Field<0, 1>;    // PLL1 fractional latch enable
            using PLL1VCOSEL = Field<1, 1>;    // PLL1 VCO selection
            using PLL1RGE = Field<2, 2>;    // PLL1 input frequency range
            using PLL2FRACEN = Field<4, 1>;    // PLL2 fractional latch enable
            using PLL2VCOSEL = Field<5, 1>;    // PLL2 VCO selection
            using PLL2RGE = Field<6, 2>;    // PLL2 input frequency range
            using PLL3FRACEN = Field<8, 1>;    // PLL3 fractional latch enable
            using PLL3VCOSEL = Field<9, 1>;    // PLL3 VCO selection
            using PLL3RGE = Field<10, 2>;    // PLL3 input frequency range
            using DIVP1EN = Field<16, 1>;    // PLL1 DIVP divider output enable
            using DIVQ1EN = Field<17, 1>;    // PLL1 DIVQ divider output enable
            using DIVR1EN = Field<18, 1>;    // PLL1 DIVR divider output enable
            using DIVP2EN = Field<19, 1>;    // PLL2 DIVP divider output enable
            using DIVQ2EN = Field<20, 1>;    // PLL2 DIVQ divider output enable
            using DIVR2EN = Field<21, 1>;    // PLL2 DIVR divider output enable
            using DIVP3EN = Field<22, 1>;    // PLL3 DIVP divider output enable
            using DIVQ3EN = Field<23, 1>;    // PLL3 DIVQ divider output enable
            using DIVR3EN = Field<24, 1>;    // PLL3 DIVR divider output enable
        };

        // RCC PLL1 Dividers Configuration Register
        struct PLL1DIVR : public Register<0x58024430> {
            using DIVN1 = Field<0, 9>;    // Multiplication factor for PLL1 VCO
            using DIVP1 = Field<9, 7>;    // PLL1 DIVP division factor
            using DIVQ1 = Field<16, 7>;    // PLL1 DIVQ division factor
            using DIVR1 = Field<24, 7>;    // PLL1 DIVR division factor
        };

        // RCC PLL1 Fractional Divider Register
        struct PLL1FRACR : public Register<0x58024434> {
            using FRACN1 = Field<3, 13>;    // Fractional part of the multiplication factor for PLL1 VCO
        };

        // RCC PLL2 Dividers Configuration Register
        struct PLL2DIVR : public Register<0x58024438> {
            using DIVN1 = Field<0, 9>;    // Multiplication factor for PLL1 VCO
            using DIVP1 = Field<9, 7>;    // PLL1 DIVP division factor
            using DIVQ1 = Field<16, 7>;    // PLL1 DIVQ division factor
            using DIVR1 = Field<24, 7>;    // PLL1 DIVR division factor
        };

        // RCC PLL2 Fractional Divider Register
        struct PLL2FRACR : public Register<0x5802443c> {
            using FRACN2 = Field<3, 13>;    // Fractional part of the multiplication factor for PLL VCO
        };

        // RCC PLL3 Dividers Configuration Register
        struct PLL3DIVR : public Register<0x58024440> {
            using DIVN3 = Field<0, 9>;    // Multiplication factor for PLL1 VCO
            using DIVP3 = Field<9, 7>;    // PLL DIVP division factor
            using DIVQ3 = Field<16, 7>;    // PLL DIVQ division factor
            using DIVR3 = Field<24, 7>;    // PLL DIVR division factor
        };

        // RCC PLL3 Fractional Divider Register
        struct PLL3FRACR : public Register<0x58024444> {
            using FRACN3 = Field<3, 13>;    // Fractional part of the multiplication factor for PLL3 VCO
        };

        // RCC Domain 1 Kernel Clock Configuration Register
        struct D1CCIPR : public Register<0x5802444c> {
            using FMCSRC = Field<0, 2>;    // FMC kernel clock source selection
            using QSPISRC = Field<4, 2>;    // QUADSPI kernel clock source selection
            using SDMMCSRC = Field<16, 1>;    // SDMMC kernel clock source selection
            using CKPERSRC = Field<28, 2>;    // per_ck clock source selection
        };

        // RCC Domain 2 Kernel Clock Configuration Register
        struct D2CCIP1R : public Register<0x58024450> {
            using SAI1SRC = Field<0, 3>;    // SAI1 and DFSDM1 kernel Aclk clock source selection
            using SAI23SRC = Field<6, 3>;    // SAI2 and SAI3 kernel clock source selection
            using SPI123SRC = Field<12, 3>;    // SPI/I2S1,2 and 3 kernel clock source selection
            using SPI45SRC = Field<16, 3>;    // SPI4 and 5 kernel clock source selection
            using SPDIFSRC = Field<20, 2>;    // SPDIFRX kernel clock source selection
            using DFSDM1SRC = Field<24, 1>;    // DFSDM1 kernel Clk clock source selection
            using FDCANSRC = Field<28, 2>;    // FDCAN kernel clock source selection
            using SWPSRC = Field<31, 1>;    // SWPMI kernel clock source selection
        };

        // RCC Domain 2 Kernel Clock Configuration Register
        struct D2CCIP2R : public Register<0x58024454> {
            using USART234578SRC = Field<0, 3>;    // USART2/3, UART4,5, 7/8 (APB1) kernel clock source selection
            using USART16SRC = Field<3, 3>;    // USART1 and 6 kernel clock source selection
            using RNGSRC = Field<8, 2>;    // RNG kernel clock source selection
            using I2C123SRC = Field<12, 2>;    // I2C1,2,3 kernel clock source selection
            using USBSRC = Field<20, 2>;    // USBOTG 1 and 2 kernel clock source selection
            using CECSRC = Field<22, 2>;    // HDMI-CEC kernel clock source selection
            using LPTIM1SRC = Field<28, 3>;    // LPTIM1 kernel clock source selection
        };

        // RCC Domain 3 Kernel Clock Configuration Register
        struct D3CCIPR : public Register<0x58024458> {
            using LPUART1SRC = Field<0, 3>;    // LPUART1 kernel clock source selection
            using I2C4SRC = Field<8, 2>;    // I2C4 kernel clock source selection
            using LPTIM2SRC = Field<10, 3>;    // LPTIM2 kernel clock source selection
            using LPTIM345SRC = Field<13, 3>;    // LPTIM3,4,5 kernel clock source selection
            using ADCSRC = Field<16, 2>;    // SAR ADC kernel clock source selection
            using SAI4ASRC = Field<21, 3>;    // Sub-Block A of SAI4 kernel clock source selection
            using SAI4BSRC = Field<24, 3>;    // Sub-Block B of SAI4 kernel clock source selection
            using SPI6SRC = Field<28, 3>;    // SPI6 kernel clock source selection
        };

        // RCC Clock Source Interrupt Enable Register
        struct CIER : public Register<0x58024460> {
            using LSIRDYIE = Field<0, 1>;    // LSI ready Interrupt Enable
            using LSERDYIE = Field<1, 1>;    // LSE ready Interrupt Enable
            using HSIRDYIE = Field<2, 1>;    // HSI ready Interrupt Enable
            using HSERDYIE = Field<3, 1>;    // HSE ready Interrupt Enable
            using CSIRDYIE = Field<4, 1>;    // CSI ready Interrupt Enable
            using RC48RDYIE = Field<5, 1>;    // RC48 ready Interrupt Enable
            using PLL1RDYIE = Field<6, 1>;    // PLL1 ready Interrupt Enable
            using PLL2RDYIE = Field<7, 1>;    // PLL2 ready Interrupt Enable
            using PLL3RDYIE = Field<8, 1>;    // PLL3 ready Interrupt Enable
            using LSECSSIE = Field<9, 1>;    // LSE clock security system Interrupt Enable
        };

        // RCC Clock Source Interrupt Flag Register
        struct CIFR : public Register<0x58024464> {
            using LSIRDYF = Field<0, 1>;    // LSI ready Interrupt Flag
            using LSERDYF = Field<1, 1>;    // LSE ready Interrupt Flag
            using HSIRDYF = Field<2, 1>;    // HSI ready Interrupt Flag
            using HSERDYF = Field<3, 1>;    // HSE ready Interrupt Flag
            using CSIRDY = Field<4, 1>;    // CSI ready Interrupt Flag
            using RC48RDYF = Field<5, 1>;    // RC48 ready Interrupt Flag
            using PLL1RDYF = Field<6, 1>;    // PLL1 ready Interrupt Flag
            using PLL2RDYF = Field<7, 1>;    // PLL2 ready Interrupt Flag
            using PLL3RDYF = Field<8, 1>;    // PLL3 ready Interrupt Flag
            using LSECSSF = Field<9, 1>;    // LSE clock security system Interrupt Flag
            using HSECSSF = Field<10, 1>;    // HSE clock security system Interrupt Flag
        };

        // RCC Clock Source Interrupt Clear Register
        struct CICR : public Register<0x58024468> {
            using LSIRDYC = Field<0, 1>;    // LSI ready Interrupt Clear
            using LSERDYC = Field<1, 1>;    // LSE ready Interrupt Clear
            using HSIRDYC = Field<2, 1>;    // HSI ready Interrupt Clear
            using HSERDYC = Field<3, 1>;    // HSE ready Interrupt Clear
            using HSE_ready_Interrupt_Clear = Field<4, 1>;    // CSI ready Interrupt Clear
            using RC48RDYC = Field<5, 1>;    // RC48 ready Interrupt Clear
            using PLL1RDYC = Field<6, 1>;    // PLL1 ready Interrupt Clear
            using PLL2RDYC = Field<7, 1>;    // PLL2 ready Interrupt Clear
            using PLL3RDYC = Field<8, 1>;    // PLL3 ready Interrupt Clear
            using LSECSSC = Field<9, 1>;    // LSE clock security system Interrupt Clear
            using HSECSSC = Field<10, 1>;    // HSE clock security system Interrupt Clear
        };

        // RCC Backup Domain Control Register
        struct BDCR : public Register<0x58024470> {
            using LSEON = Field<0, 1>;    // LSE oscillator enabled
            using LSERDY = Field<1, 1>;    // LSE oscillator ready
            using LSEBYP = Field<2, 1>;    // LSE oscillator bypass
            using LSEDRV = Field<3, 2>;    // LSE oscillator driving capability
            using LSECSSON = Field<5, 1>;    // LSE clock security system enable
            using LSECSSD = Field<6, 1>;    // LSE clock security system failure detection
            using RTCSRC = Field<8, 2>;    // RTC clock source selection
            using RTCEN = Field<15, 1>;    // RTC clock enable
            using VSWRST = Field<16, 1>;    // VSwitch domain software reset
        };

        // RCC Clock Control and Status Register
        struct CSR : public Register<0x58024474> {
            using LSION = Field<0, 1>;    // LSI oscillator enable
            using LSIRDY = Field<1, 1>;    // LSI oscillator ready
        };

        // RCC AHB3 Reset Register
        struct AHB3RSTR : public Register<0x5802447c> {
            using MDMARST = Field<0, 1>;    // MDMA block reset
            using DMA2DRST = Field<4, 1>;    // DMA2D block reset
            using JPGDECRST = Field<5, 1>;    // JPGDEC block reset
            using FMCRST = Field<12, 1>;    // FMC block reset
            using QSPIRST = Field<14, 1>;    // QUADSPI and QUADSPI delay block reset
            using SDMMC1RST = Field<16, 1>;    // SDMMC1 and SDMMC1 delay block reset
            using CPURST = Field<31, 1>;    // CPU reset
        };

        // RCC AHB1 Peripheral Reset Register
        struct AHB1RSTR : public Register<0x58024480> {
            using DMA1RST = Field<0, 1>;    // DMA1 block reset
            using DMA2RST = Field<1, 1>;    // DMA2 block reset
            using ADC12RST = Field<5, 1>;    // ADC1&2 block reset
            using ETH1MACRST = Field<15, 1>;    // ETH1MAC block reset
            using USB1OTGRST = Field<25, 1>;    // USB1OTG block reset
            using USB2OTGRST = Field<27, 1>;    // USB2OTG block reset
        };

        // RCC AHB2 Peripheral Reset Register
        struct AHB2RSTR : public Register<0x58024484> {
            using CAMITFRST = Field<0, 1>;    // CAMITF block reset
            using CRYPTRST = Field<4, 1>;    // Cryptography block reset
            using HASHRST = Field<5, 1>;    // Hash block reset
            using RNGRST = Field<6, 1>;    // Random Number Generator block reset
            using SDMMC2RST = Field<9, 1>;    // SDMMC2 and SDMMC2 Delay block reset
        };

        // RCC AHB4 Peripheral Reset Register
        struct AHB4RSTR : public Register<0x58024488> {
            using GPIOARST = Field<0, 1>;    // GPIO block reset
            using GPIOBRST = Field<1, 1>;    // GPIO block reset
            using GPIOCRST = Field<2, 1>;    // GPIO block reset
            using GPIODRST = Field<3, 1>;    // GPIO block reset
            using GPIOERST = Field<4, 1>;    // GPIO block reset
            using GPIOFRST = Field<5, 1>;    // GPIO block reset
            using GPIOGRST = Field<6, 1>;    // GPIO block reset
            using GPIOHRST = Field<7, 1>;    // GPIO block reset
            using GPIOIRST = Field<8, 1>;    // GPIO block reset
            using GPIOJRST = Field<9, 1>;    // GPIO block reset
            using GPIOKRST = Field<10, 1>;    // GPIO block reset
            using CRCRST = Field<19, 1>;    // CRC block reset
            using BDMARST = Field<21, 1>;    // BDMA block reset
            using ADC3RST = Field<24, 1>;    // ADC3 block reset
            using HSEMRST = Field<25, 1>;    // HSEM block reset
        };

        // RCC APB3 Peripheral Reset Register
        struct APB3RSTR : public Register<0x5802448c> {
            using LTDCRST = Field<3, 1>;    // LTDC block reset
        };

        // RCC APB1 Peripheral Reset Register
        struct APB1LRSTR : public Register<0x58024490> {
            using TIM2RST = Field<0, 1>;    // TIM block reset
            using TIM3RST = Field<1, 1>;    // TIM block reset
            using TIM4RST = Field<2, 1>;    // TIM block reset
            using TIM5RST = Field<3, 1>;    // TIM block reset
            using TIM6RST = Field<4, 1>;    // TIM block reset
            using TIM7RST = Field<5, 1>;    // TIM block reset
            using TIM12RST = Field<6, 1>;    // TIM block reset
            using TIM13RST = Field<7, 1>;    // TIM block reset
            using TIM14RST = Field<8, 1>;    // TIM block reset
            using LPTIM1RST = Field<9, 1>;    // TIM block reset
            using SPI2RST = Field<14, 1>;    // SPI2 block reset
            using SPI3RST = Field<15, 1>;    // SPI3 block reset
            using SPDIFRXRST = Field<16, 1>;    // SPDIFRX block reset
            using USART2RST = Field<17, 1>;    // USART2 block reset
            using USART3RST = Field<18, 1>;    // USART3 block reset
            using UART4RST = Field<19, 1>;    // UART4 block reset
            using UART5RST = Field<20, 1>;    // UART5 block reset
            using I2C1RST = Field<21, 1>;    // I2C1 block reset
            using I2C2RST = Field<22, 1>;    // I2C2 block reset
            using I2C3RST = Field<23, 1>;    // I2C3 block reset
            using CECRST = Field<27, 1>;    // HDMI-CEC block reset
            using DAC12RST = Field<29, 1>;    // DAC1 and 2 Blocks Reset
            using USART7RST = Field<30, 1>;    // USART7 block reset
            using USART8RST = Field<31, 1>;    // USART8 block reset
        };

        // RCC APB1 Peripheral Reset Register
        struct APB1HRSTR : public Register<0x58024494> {
            using CRSRST = Field<1, 1>;    // Clock Recovery System reset
            using SWPRST = Field<2, 1>;    // SWPMI block reset
            using OPAMPRST = Field<4, 1>;    // OPAMP block reset
            using MDIOSRST = Field<5, 1>;    // MDIOS block reset
            using FDCANRST = Field<8, 1>;    // FDCAN block reset
        };

        // RCC APB2 Peripheral Reset Register
        struct APB2RSTR : public Register<0x58024498> {
            using TIM1RST = Field<0, 1>;    // TIM1 block reset
            using TIM8RST = Field<1, 1>;    // TIM8 block reset
            using USART1RST = Field<4, 1>;    // USART1 block reset
            using USART6RST = Field<5, 1>;    // USART6 block reset
            using SPI1RST = Field<12, 1>;    // SPI1 block reset
            using SPI4RST = Field<13, 1>;    // SPI4 block reset
            using TIM15RST = Field<16, 1>;    // TIM15 block reset
            using TIM16RST = Field<17, 1>;    // TIM16 block reset
            using TIM17RST = Field<18, 1>;    // TIM17 block reset
            using SPI5RST = Field<20, 1>;    // SPI5 block reset
            using SAI1RST = Field<22, 1>;    // SAI1 block reset
            using SAI2RST = Field<23, 1>;    // SAI2 block reset
            using SAI3RST = Field<24, 1>;    // SAI3 block reset
            using DFSDM1RST = Field<28, 1>;    // DFSDM1 block reset
            using HRTIMRST = Field<29, 1>;    // HRTIM block reset
        };

        // RCC APB4 Peripheral Reset Register
        struct APB4RSTR : public Register<0x5802449c> {
            using SYSCFGRST = Field<1, 1>;    // SYSCFG block reset
            using LPUART1RST = Field<3, 1>;    // LPUART1 block reset
            using SPI6RST = Field<5, 1>;    // SPI6 block reset
            using I2C4RST = Field<7, 1>;    // I2C4 block reset
            using LPTIM2RST = Field<9, 1>;    // LPTIM2 block reset
            using LPTIM3RST = Field<10, 1>;    // LPTIM3 block reset
            using LPTIM4RST = Field<11, 1>;    // LPTIM4 block reset
            using LPTIM5RST = Field<12, 1>;    // LPTIM5 block reset
            using COMP12RST = Field<14, 1>;    // COMP12 Blocks Reset
            using VREFRST = Field<15, 1>;    // VREF block reset
            using SAI4RST = Field<21, 1>;    // SAI4 block reset
        };

        // RCC Global Control Register
        struct GCR : public Register<0x580244a0> {
            using WW1RSC = Field<0, 1>;    // WWDG1 reset scope control
        };

        // RCC D3 Autonomous mode Register
        struct D3AMR : public Register<0x580244a8> {
            using BDMAAMEN = Field<0, 1>;    // BDMA and DMAMUX Autonomous mode enable
            using LPUART1AMEN = Field<3, 1>;    // LPUART1 Autonomous mode enable
            using SPI6AMEN = Field<5, 1>;    // SPI6 Autonomous mode enable
            using I2C4AMEN = Field<7, 1>;    // I2C4 Autonomous mode enable
            using LPTIM2AMEN = Field<9, 1>;    // LPTIM2 Autonomous mode enable
            using LPTIM3AMEN = Field<10, 1>;    // LPTIM3 Autonomous mode enable
            using LPTIM4AMEN = Field<11, 1>;    // LPTIM4 Autonomous mode enable
            using LPTIM5AMEN = Field<12, 1>;    // LPTIM5 Autonomous mode enable
            using COMP12AMEN = Field<14, 1>;    // COMP12 Autonomous mode enable
            using VREFAMEN = Field<15, 1>;    // VREF Autonomous mode enable
            using RTCAMEN = Field<16, 1>;    // RTC Autonomous mode enable
            using CRCAMEN = Field<19, 1>;    // CRC Autonomous mode enable
            using SAI4AMEN = Field<21, 1>;    // SAI4 Autonomous mode enable
            using ADC3AMEN = Field<24, 1>;    // ADC3 Autonomous mode enable
            using BKPRAMAMEN = Field<28, 1>;    // Backup RAM Autonomous mode enable
            using SRAM4AMEN = Field<29, 1>;    // SRAM4 Autonomous mode enable
        };

        // RCC Reset Status Register
        struct RSR : public Register<0x580244d0> {
            using RMVF = Field<16, 1>;    // Remove reset flag
            using CPURSTF = Field<17, 1>;    // CPU reset flag
            using D1RSTF = Field<19, 1>;    // D1 domain power switch reset flag
            using D2RSTF = Field<20, 1>;    // D2 domain power switch reset flag
            using BORRSTF = Field<21, 1>;    // BOR reset flag
            using PINRSTF = Field<22, 1>;    // Pin reset flag (NRST)
            using PORRSTF = Field<23, 1>;    // POR/PDR reset flag
            using SFTRSTF = Field<24, 1>;    // System reset from CPU reset flag
            using IWDG1RSTF = Field<26, 1>;    // Independent Watchdog reset flag
            using WWDG1RSTF = Field<28, 1>;    // Window Watchdog reset flag
            using LPWRRSTF = Field<30, 1>;    // Reset due to illegal D1 DStandby or CPU CStop flag
        };

        // RCC Reset Status Register
        struct C1_RSR : public Register<0x58024530> {
            using RMVF = Field<16, 1>;    // Remove reset flag
            using CPURSTF = Field<17, 1>;    // CPU reset flag
            using D1RSTF = Field<19, 1>;    // D1 domain power switch reset flag
            using D2RSTF = Field<20, 1>;    // D2 domain power switch reset flag
            using BORRSTF = Field<21, 1>;    // BOR reset flag
            using PINRSTF = Field<22, 1>;    // Pin reset flag (NRST)
            using PORRSTF = Field<23, 1>;    // POR/PDR reset flag
            using SFTRSTF = Field<24, 1>;    // System reset from CPU reset flag
            using IWDG1RSTF = Field<26, 1>;    // Independent Watchdog reset flag
            using WWDG1RSTF = Field<28, 1>;    // Window Watchdog reset flag
            using LPWRRSTF = Field<30, 1>;    // Reset due to illegal D1 DStandby or CPU CStop flag
        };

        // RCC AHB3 Clock Register
        struct C1_AHB3ENR : public Register<0x58024534> {
            using MDMAEN = Field<0, 1>;    // MDMA Peripheral Clock Enable
            using DMA2DEN = Field<4, 1>;    // DMA2D Peripheral Clock Enable
            using JPGDECEN = Field<5, 1>;    // JPGDEC Peripheral Clock Enable
            using FMCEN = Field<12, 1>;    // FMC Peripheral Clocks Enable
            using QSPIEN = Field<14, 1>;    // QUADSPI and QUADSPI Delay Clock Enable
            using SDMMC1EN = Field<16, 1>;    // SDMMC1 and SDMMC1 Delay Clock Enable
        };

        // RCC AHB3 Clock Register
        struct AHB3ENR : public Register<0x580244d4> {
            using MDMAEN = Field<0, 1>;    // MDMA Peripheral Clock Enable
            using DMA2DEN = Field<4, 1>;    // DMA2D Peripheral Clock Enable
            using JPGDECEN = Field<5, 1>;    // JPGDEC Peripheral Clock Enable
            using FMCEN = Field<12, 1>;    // FMC Peripheral Clocks Enable
            using QSPIEN = Field<14, 1>;    // QUADSPI and QUADSPI Delay Clock Enable
            using SDMMC1EN = Field<16, 1>;    // SDMMC1 and SDMMC1 Delay Clock Enable
        };

        // RCC AHB1 Clock Register
        struct AHB1ENR : public Register<0x580244d8> {
            using DMA1EN = Field<0, 1>;    // DMA1 Clock Enable
            using DMA2EN = Field<1, 1>;    // DMA2 Clock Enable
            using ADC12EN = Field<5, 1>;    // ADC1/2 Peripheral Clocks Enable
            using ETH1MACEN = Field<15, 1>;    // Ethernet MAC bus interface Clock Enable
            using ETH1TXEN = Field<16, 1>;    // Ethernet Transmission Clock Enable
            using ETH1RXEN = Field<17, 1>;    // Ethernet Reception Clock Enable
            using USB2OTGHSULPIEN = Field<18, 1>;    // Enable USB_PHY2 clocks
            using USB1OTGEN = Field<25, 1>;    // USB1OTG Peripheral Clocks Enable
            using USB1ULPIEN = Field<26, 1>;    // USB_PHY1 Clocks Enable
            using USB2OTGEN = Field<27, 1>;    // USB2OTG Peripheral Clocks Enable
            using USB2ULPIEN = Field<28, 1>;    // USB_PHY2 Clocks Enable
        };

        // RCC AHB1 Clock Register
        struct C1_AHB1ENR : public Register<0x58024538> {
            using DMA1EN = Field<0, 1>;    // DMA1 Clock Enable
            using DMA2EN = Field<1, 1>;    // DMA2 Clock Enable
            using ADC12EN = Field<5, 1>;    // ADC1/2 Peripheral Clocks Enable
            using ETH1MACEN = Field<15, 1>;    // Ethernet MAC bus interface Clock Enable
            using ETH1TXEN = Field<16, 1>;    // Ethernet Transmission Clock Enable
            using ETH1RXEN = Field<17, 1>;    // Ethernet Reception Clock Enable
            using USB1OTGEN = Field<25, 1>;    // USB1OTG Peripheral Clocks Enable
            using USB1ULPIEN = Field<26, 1>;    // USB_PHY1 Clocks Enable
            using USB2OTGEN = Field<27, 1>;    // USB2OTG Peripheral Clocks Enable
            using USB2ULPIEN = Field<28, 1>;    // USB_PHY2 Clocks Enable
        };

        // RCC AHB2 Clock Register
        struct C1_AHB2ENR : public Register<0x5802453c> {
            using CAMITFEN = Field<0, 1>;    // CAMITF peripheral clock enable
            using CRYPTEN = Field<4, 1>;    // CRYPT peripheral clock enable
            using HASHEN = Field<5, 1>;    // HASH peripheral clock enable
            using RNGEN = Field<6, 1>;    // RNG peripheral clocks enable
            using SDMMC2EN = Field<9, 1>;    // SDMMC2 and SDMMC2 delay clock enable
            using SRAM1EN = Field<29, 1>;    // SRAM1 block enable
            using SRAM2EN = Field<30, 1>;    // SRAM2 block enable
            using SRAM3EN = Field<31, 1>;    // SRAM3 block enable
        };

        // RCC AHB2 Clock Register
        struct AHB2ENR : public Register<0x580244dc> {
            using CAMITFEN = Field<0, 1>;    // CAMITF peripheral clock enable
            using CRYPTEN = Field<4, 1>;    // CRYPT peripheral clock enable
            using HASHEN = Field<5, 1>;    // HASH peripheral clock enable
            using RNGEN = Field<6, 1>;    // RNG peripheral clocks enable
            using SDMMC2EN = Field<9, 1>;    // SDMMC2 and SDMMC2 delay clock enable
            using SRAM1EN = Field<29, 1>;    // SRAM1 block enable
            using SRAM2EN = Field<30, 1>;    // SRAM2 block enable
            using SRAM3EN = Field<31, 1>;    // SRAM3 block enable
        };

        // RCC AHB4 Clock Register
        struct AHB4ENR : public Register<0x580244e0> {
            using GPIOAEN = Field<0, 1>;    // 0GPIO peripheral clock enable
            using GPIOBEN = Field<1, 1>;    // 0GPIO peripheral clock enable
            using GPIOCEN = Field<2, 1>;    // 0GPIO peripheral clock enable
            using GPIODEN = Field<3, 1>;    // 0GPIO peripheral clock enable
            using GPIOEEN = Field<4, 1>;    // 0GPIO peripheral clock enable
            using GPIOFEN = Field<5, 1>;    // 0GPIO peripheral clock enable
            using GPIOGEN = Field<6, 1>;    // 0GPIO peripheral clock enable
            using GPIOHEN = Field<7, 1>;    // 0GPIO peripheral clock enable
            using GPIOIEN = Field<8, 1>;    // 0GPIO peripheral clock enable
            using GPIOJEN = Field<9, 1>;    // 0GPIO peripheral clock enable
            using GPIOKEN = Field<10, 1>;    // 0GPIO peripheral clock enable
            using CRCEN = Field<19, 1>;    // CRC peripheral clock enable
            using BDMAEN = Field<21, 1>;    // BDMA and DMAMUX2 Clock Enable
            using ADC3EN = Field<24, 1>;    // ADC3 Peripheral Clocks Enable
            using HSEMEN = Field<25, 1>;    // HSEM peripheral clock enable
            using BKPRAMEN = Field<28, 1>;    // Backup RAM Clock Enable
        };

        // RCC AHB4 Clock Register
        struct C1_AHB4ENR : public Register<0x58024540> {
            using GPIOAEN = Field<0, 1>;    // 0GPIO peripheral clock enable
            using GPIOBEN = Field<1, 1>;    // 0GPIO peripheral clock enable
            using GPIOCEN = Field<2, 1>;    // 0GPIO peripheral clock enable
            using GPIODEN = Field<3, 1>;    // 0GPIO peripheral clock enable
            using GPIOEEN = Field<4, 1>;    // 0GPIO peripheral clock enable
            using GPIOFEN = Field<5, 1>;    // 0GPIO peripheral clock enable
            using GPIOGEN = Field<6, 1>;    // 0GPIO peripheral clock enable
            using GPIOHEN = Field<7, 1>;    // 0GPIO peripheral clock enable
            using GPIOIEN = Field<8, 1>;    // 0GPIO peripheral clock enable
            using GPIOJEN = Field<9, 1>;    // 0GPIO peripheral clock enable
            using GPIOKEN = Field<10, 1>;    // 0GPIO peripheral clock enable
            using CRCEN = Field<19, 1>;    // CRC peripheral clock enable
            using BDMAEN = Field<21, 1>;    // BDMA and DMAMUX2 Clock Enable
            using ADC3EN = Field<24, 1>;    // ADC3 Peripheral Clocks Enable
            using HSEMEN = Field<25, 1>;    // HSEM peripheral clock enable
            using BKPRAMEN = Field<28, 1>;    // Backup RAM Clock Enable
        };

        // RCC APB3 Clock Register
        struct C1_APB3ENR : public Register<0x58024544> {
            using LTDCEN = Field<3, 1>;    // LTDC peripheral clock enable
            using WWDG1EN = Field<6, 1>;    // WWDG1 Clock Enable
        };

        // RCC APB3 Clock Register
        struct APB3ENR : public Register<0x580244e4> {
            using LTDCEN = Field<3, 1>;    // LTDC peripheral clock enable
            using WWDG1EN = Field<6, 1>;    // WWDG1 Clock Enable
        };

        // RCC APB1 Clock Register
        struct APB1LENR : public Register<0x580244e8> {
            using TIM2EN = Field<0, 1>;    // TIM peripheral clock enable
            using TIM3EN = Field<1, 1>;    // TIM peripheral clock enable
            using TIM4EN = Field<2, 1>;    // TIM peripheral clock enable
            using TIM5EN = Field<3, 1>;    // TIM peripheral clock enable
            using TIM6EN = Field<4, 1>;    // TIM peripheral clock enable
            using TIM7EN = Field<5, 1>;    // TIM peripheral clock enable
            using TIM12EN = Field<6, 1>;    // TIM peripheral clock enable
            using TIM13EN = Field<7, 1>;    // TIM peripheral clock enable
            using TIM14EN = Field<8, 1>;    // TIM peripheral clock enable
            using LPTIM1EN = Field<9, 1>;    // LPTIM1 Peripheral Clocks Enable
            using SPI2EN = Field<14, 1>;    // SPI2 Peripheral Clocks Enable
            using SPI3EN = Field<15, 1>;    // SPI3 Peripheral Clocks Enable
            using SPDIFRXEN = Field<16, 1>;    // SPDIFRX Peripheral Clocks Enable
            using USART2EN = Field<17, 1>;    // USART2 Peripheral Clocks Enable
            using USART3EN = Field<18, 1>;    // USART3 Peripheral Clocks Enable
            using UART4EN = Field<19, 1>;    // UART4 Peripheral Clocks Enable
            using UART5EN = Field<20, 1>;    // UART5 Peripheral Clocks Enable
            using I2C1EN = Field<21, 1>;    // I2C1 Peripheral Clocks Enable
            using I2C2EN = Field<22, 1>;    // I2C2 Peripheral Clocks Enable
            using I2C3EN = Field<23, 1>;    // I2C3 Peripheral Clocks Enable
            using CECEN = Field<27, 1>;    // HDMI-CEC peripheral clock enable
            using DAC12EN = Field<29, 1>;    // DAC1&2 peripheral clock enable
            using USART7EN = Field<30, 1>;    // USART7 Peripheral Clocks Enable
            using USART8EN = Field<31, 1>;    // USART8 Peripheral Clocks Enable
        };

        // RCC APB1 Clock Register
        struct C1_APB1LENR : public Register<0x58024548> {
            using TIM2EN = Field<0, 1>;    // TIM peripheral clock enable
            using TIM3EN = Field<1, 1>;    // TIM peripheral clock enable
            using TIM4EN = Field<2, 1>;    // TIM peripheral clock enable
            using TIM5EN = Field<3, 1>;    // TIM peripheral clock enable
            using TIM6EN = Field<4, 1>;    // TIM peripheral clock enable
            using TIM7EN = Field<5, 1>;    // TIM peripheral clock enable
            using TIM12EN = Field<6, 1>;    // TIM peripheral clock enable
            using TIM13EN = Field<7, 1>;    // TIM peripheral clock enable
            using TIM14EN = Field<8, 1>;    // TIM peripheral clock enable
            using LPTIM1EN = Field<9, 1>;    // LPTIM1 Peripheral Clocks Enable
            using SPI2EN = Field<14, 1>;    // SPI2 Peripheral Clocks Enable
            using SPI3EN = Field<15, 1>;    // SPI3 Peripheral Clocks Enable
            using SPDIFRXEN = Field<16, 1>;    // SPDIFRX Peripheral Clocks Enable
            using USART2EN = Field<17, 1>;    // USART2 Peripheral Clocks Enable
            using USART3EN = Field<18, 1>;    // USART3 Peripheral Clocks Enable
            using UART4EN = Field<19, 1>;    // UART4 Peripheral Clocks Enable
            using UART5EN = Field<20, 1>;    // UART5 Peripheral Clocks Enable
            using I2C1EN = Field<21, 1>;    // I2C1 Peripheral Clocks Enable
            using I2C2EN = Field<22, 1>;    // I2C2 Peripheral Clocks Enable
            using I2C3EN = Field<23, 1>;    // I2C3 Peripheral Clocks Enable
            using HDMICECEN = Field<27, 1>;    // HDMI-CEC peripheral clock enable
            using DAC12EN = Field<29, 1>;    // DAC1&2 peripheral clock enable
            using USART7EN = Field<30, 1>;    // USART7 Peripheral Clocks Enable
            using USART8EN = Field<31, 1>;    // USART8 Peripheral Clocks Enable
        };

        // RCC APB1 Clock Register
        struct APB1HENR : public Register<0x580244ec> {
            using CRSEN = Field<1, 1>;    // Clock Recovery System peripheral clock enable
            using SWPEN = Field<2, 1>;    // SWPMI Peripheral Clocks Enable
            using OPAMPEN = Field<4, 1>;    // OPAMP peripheral clock enable
            using MDIOSEN = Field<5, 1>;    // MDIOS peripheral clock enable
            using FDCANEN = Field<8, 1>;    // FDCAN Peripheral Clocks Enable
        };

        // RCC APB1 Clock Register
        struct C1_APB1HENR : public Register<0x5802454c> {
            using CRSEN = Field<1, 1>;    // Clock Recovery System peripheral clock enable
            using SWPEN = Field<2, 1>;    // SWPMI Peripheral Clocks Enable
            using OPAMPEN = Field<4, 1>;    // OPAMP peripheral clock enable
            using MDIOSEN = Field<5, 1>;    // MDIOS peripheral clock enable
            using FDCANEN = Field<8, 1>;    // FDCAN Peripheral Clocks Enable
        };

        // RCC APB2 Clock Register
        struct C1_APB2ENR : public Register<0x58024550> {
            using TIM1EN = Field<0, 1>;    // TIM1 peripheral clock enable
            using TIM8EN = Field<1, 1>;    // TIM8 peripheral clock enable
            using USART1EN = Field<4, 1>;    // USART1 Peripheral Clocks Enable
            using USART6EN = Field<5, 1>;    // USART6 Peripheral Clocks Enable
            using SPI1EN = Field<12, 1>;    // SPI1 Peripheral Clocks Enable
            using SPI4EN = Field<13, 1>;    // SPI4 Peripheral Clocks Enable
            using TIM16EN = Field<17, 1>;    // TIM16 peripheral clock enable
            using TIM15EN = Field<16, 1>;    // TIM15 peripheral clock enable
            using TIM17EN = Field<18, 1>;    // TIM17 peripheral clock enable
            using SPI5EN = Field<20, 1>;    // SPI5 Peripheral Clocks Enable
            using SAI1EN = Field<22, 1>;    // SAI1 Peripheral Clocks Enable
            using SAI2EN = Field<23, 1>;    // SAI2 Peripheral Clocks Enable
            using SAI3EN = Field<24, 1>;    // SAI3 Peripheral Clocks Enable
            using DFSDM1EN = Field<28, 1>;    // DFSDM1 Peripheral Clocks Enable
            using HRTIMEN = Field<29, 1>;    // HRTIM peripheral clock enable
        };

        // RCC APB2 Clock Register
        struct APB2ENR : public Register<0x580244f0> {
            using TIM1EN = Field<0, 1>;    // TIM1 peripheral clock enable
            using TIM8EN = Field<1, 1>;    // TIM8 peripheral clock enable
            using USART1EN = Field<4, 1>;    // USART1 Peripheral Clocks Enable
            using USART6EN = Field<5, 1>;    // USART6 Peripheral Clocks Enable
            using SPI1EN = Field<12, 1>;    // SPI1 Peripheral Clocks Enable
            using SPI4EN = Field<13, 1>;    // SPI4 Peripheral Clocks Enable
            using TIM16EN = Field<17, 1>;    // TIM16 peripheral clock enable
            using TIM15EN = Field<16, 1>;    // TIM15 peripheral clock enable
            using TIM17EN = Field<18, 1>;    // TIM17 peripheral clock enable
            using SPI5EN = Field<20, 1>;    // SPI5 Peripheral Clocks Enable
            using SAI1EN = Field<22, 1>;    // SAI1 Peripheral Clocks Enable
            using SAI2EN = Field<23, 1>;    // SAI2 Peripheral Clocks Enable
            using SAI3EN = Field<24, 1>;    // SAI3 Peripheral Clocks Enable
            using DFSDM1EN = Field<28, 1>;    // DFSDM1 Peripheral Clocks Enable
            using HRTIMEN = Field<29, 1>;    // HRTIM peripheral clock enable
        };

        // RCC APB4 Clock Register
        struct APB4ENR : public Register<0x580244f4> {
            using SYSCFGEN = Field<1, 1>;    // SYSCFG peripheral clock enable
            using LPUART1EN = Field<3, 1>;    // LPUART1 Peripheral Clocks Enable
            using SPI6EN = Field<5, 1>;    // SPI6 Peripheral Clocks Enable
            using I2C4EN = Field<7, 1>;    // I2C4 Peripheral Clocks Enable
            using LPTIM2EN = Field<9, 1>;    // LPTIM2 Peripheral Clocks Enable
            using LPTIM3EN = Field<10, 1>;    // LPTIM3 Peripheral Clocks Enable
            using LPTIM4EN = Field<11, 1>;    // LPTIM4 Peripheral Clocks Enable
            using LPTIM5EN = Field<12, 1>;    // LPTIM5 Peripheral Clocks Enable
            using COMP12EN = Field<14, 1>;    // COMP1/2 peripheral clock enable
            using VREFEN = Field<15, 1>;    // VREF peripheral clock enable
            using RTCAPBEN = Field<16, 1>;    // RTC APB Clock Enable
            using SAI4EN = Field<21, 1>;    // SAI4 Peripheral Clocks Enable
        };

        // RCC APB4 Clock Register
        struct C1_APB4ENR : public Register<0x58024554> {
            using SYSCFGEN = Field<1, 1>;    // SYSCFG peripheral clock enable
            using LPUART1EN = Field<3, 1>;    // LPUART1 Peripheral Clocks Enable
            using SPI6EN = Field<5, 1>;    // SPI6 Peripheral Clocks Enable
            using I2C4EN = Field<7, 1>;    // I2C4 Peripheral Clocks Enable
            using LPTIM2EN = Field<9, 1>;    // LPTIM2 Peripheral Clocks Enable
            using LPTIM3EN = Field<10, 1>;    // LPTIM3 Peripheral Clocks Enable
            using LPTIM4EN = Field<11, 1>;    // LPTIM4 Peripheral Clocks Enable
            using LPTIM5EN = Field<12, 1>;    // LPTIM5 Peripheral Clocks Enable
            using COMP12EN = Field<14, 1>;    // COMP1/2 peripheral clock enable
            using VREFEN = Field<15, 1>;    // VREF peripheral clock enable
            using RTCAPBEN = Field<16, 1>;    // RTC APB Clock Enable
            using SAI4EN = Field<21, 1>;    // SAI4 Peripheral Clocks Enable
        };

        // RCC AHB3 Sleep Clock Register
        struct C1_AHB3LPENR : public Register<0x5802455c> {
            using MDMALPEN = Field<0, 1>;    // MDMA Clock Enable During CSleep Mode
            using DMA2DLPEN = Field<4, 1>;    // DMA2D Clock Enable During CSleep Mode
            using JPGDECLPEN = Field<5, 1>;    // JPGDEC Clock Enable During CSleep Mode
            using FLITFLPEN = Field<8, 1>;    // FLITF Clock Enable During CSleep Mode
            using FMCLPEN = Field<12, 1>;    // FMC Peripheral Clocks Enable During CSleep Mode
            using QSPILPEN = Field<14, 1>;    // QUADSPI and QUADSPI Delay Clock Enable During CSleep Mode
            using SDMMC1LPEN = Field<16, 1>;    // SDMMC1 and SDMMC1 Delay Clock Enable During CSleep Mode
            using D1DTCM1LPEN = Field<28, 1>;    // D1DTCM1 Block Clock Enable During CSleep mode
            using DTCM2LPEN = Field<29, 1>;    // D1 DTCM2 Block Clock Enable During CSleep mode
            using ITCMLPEN = Field<30, 1>;    // D1ITCM Block Clock Enable During CSleep mode
            using AXISRAMLPEN = Field<31, 1>;    // AXISRAM Block Clock Enable During CSleep mode
        };

        // RCC AHB3 Sleep Clock Register
        struct AHB3LPENR : public Register<0x580244fc> {
            using MDMALPEN = Field<0, 1>;    // MDMA Clock Enable During CSleep Mode
            using DMA2DLPEN = Field<4, 1>;    // DMA2D Clock Enable During CSleep Mode
            using JPGDECLPEN = Field<5, 1>;    // JPGDEC Clock Enable During CSleep Mode
            using FLASHLPEN = Field<8, 1>;    // FLITF Clock Enable During CSleep Mode
            using FMCLPEN = Field<12, 1>;    // FMC Peripheral Clocks Enable During CSleep Mode
            using QSPILPEN = Field<14, 1>;    // QUADSPI and QUADSPI Delay Clock Enable During CSleep Mode
            using SDMMC1LPEN = Field<16, 1>;    // SDMMC1 and SDMMC1 Delay Clock Enable During CSleep Mode
            using D1DTCM1LPEN = Field<28, 1>;    // D1DTCM1 Block Clock Enable During CSleep mode
            using DTCM2LPEN = Field<29, 1>;    // D1 DTCM2 Block Clock Enable During CSleep mode
            using ITCMLPEN = Field<30, 1>;    // D1ITCM Block Clock Enable During CSleep mode
            using AXISRAMLPEN = Field<31, 1>;    // AXISRAM Block Clock Enable During CSleep mode
        };

        // RCC AHB1 Sleep Clock Register
        struct AHB1LPENR : public Register<0x58024500> {
            using DMA1LPEN = Field<0, 1>;    // DMA1 Clock Enable During CSleep Mode
            using DMA2LPEN = Field<1, 1>;    // DMA2 Clock Enable During CSleep Mode
            using ADC12LPEN = Field<5, 1>;    // ADC1/2 Peripheral Clocks Enable During CSleep Mode
            using ETH1MACLPEN = Field<15, 1>;    // Ethernet MAC bus interface Clock Enable During CSleep Mode
            using ETH1TXLPEN = Field<16, 1>;    // Ethernet Transmission Clock Enable During CSleep Mode
            using ETH1RXLPEN = Field<17, 1>;    // Ethernet Reception Clock Enable During CSleep Mode
            using USB1OTGHSLPEN = Field<25, 1>;    // USB1OTG peripheral clock enable during CSleep mode
            using USB1OTGHSULPILPEN = Field<26, 1>;    // USB_PHY1 clock enable during CSleep mode
            using USB2OTGHSLPEN = Field<27, 1>;    // USB2OTG peripheral clock enable during CSleep mode
            using USB2OTGHSULPILPEN = Field<28, 1>;    // USB_PHY2 clocks enable during CSleep mode
        };

        // RCC AHB1 Sleep Clock Register
        struct C1_AHB1LPENR : public Register<0x58024560> {
            using DMA1LPEN = Field<0, 1>;    // DMA1 Clock Enable During CSleep Mode
            using DMA2LPEN = Field<1, 1>;    // DMA2 Clock Enable During CSleep Mode
            using ADC12LPEN = Field<5, 1>;    // ADC1/2 Peripheral Clocks Enable During CSleep Mode
            using ETH1MACLPEN = Field<15, 1>;    // Ethernet MAC bus interface Clock Enable During CSleep Mode
            using ETH1TXLPEN = Field<16, 1>;    // Ethernet Transmission Clock Enable During CSleep Mode
            using ETH1RXLPEN = Field<17, 1>;    // Ethernet Reception Clock Enable During CSleep Mode
            using USB1OTGLPEN = Field<25, 1>;    // USB1OTG peripheral clock enable during CSleep mode
            using USB1ULPILPEN = Field<26, 1>;    // USB_PHY1 clock enable during CSleep mode
            using USB2OTGLPEN = Field<27, 1>;    // USB2OTG peripheral clock enable during CSleep mode
            using USB2ULPILPEN = Field<28, 1>;    // USB_PHY2 clocks enable during CSleep mode
        };

        // RCC AHB2 Sleep Clock Register
        struct C1_AHB2LPENR : public Register<0x58024564> {
            using CAMITFLPEN = Field<0, 1>;    // CAMITF peripheral clock enable during CSleep mode
            using CRYPTLPEN = Field<4, 1>;    // CRYPT peripheral clock enable during CSleep mode
            using HASHLPEN = Field<5, 1>;    // HASH peripheral clock enable during CSleep mode
            using SDMMC2LPEN = Field<9, 1>;    // SDMMC2 and SDMMC2 Delay Clock Enable During CSleep Mode
            using RNGLPEN = Field<6, 1>;    // RNG peripheral clock enable during CSleep mode
            using SRAM1LPEN = Field<29, 1>;    // SRAM1 Clock Enable During CSleep Mode
            using SRAM2LPEN = Field<30, 1>;    // SRAM2 Clock Enable During CSleep Mode
            using SRAM3LPEN = Field<31, 1>;    // SRAM3 Clock Enable During CSleep Mode
        };

        // RCC AHB2 Sleep Clock Register
        struct AHB2LPENR : public Register<0x58024504> {
            using CAMITFLPEN = Field<0, 1>;    // CAMITF peripheral clock enable during CSleep mode
            using CRYPTLPEN = Field<4, 1>;    // CRYPT peripheral clock enable during CSleep mode
            using HASHLPEN = Field<5, 1>;    // HASH peripheral clock enable during CSleep mode
            using SDMMC2LPEN = Field<9, 1>;    // SDMMC2 and SDMMC2 Delay Clock Enable During CSleep Mode
            using RNGLPEN = Field<6, 1>;    // RNG peripheral clock enable during CSleep mode
            using SRAM1LPEN = Field<29, 1>;    // SRAM1 Clock Enable During CSleep Mode
            using SRAM2LPEN = Field<30, 1>;    // SRAM2 Clock Enable During CSleep Mode
            using SRAM3LPEN = Field<31, 1>;    // SRAM3 Clock Enable During CSleep Mode
        };

        // RCC AHB4 Sleep Clock Register
        struct AHB4LPENR : public Register<0x58024508> {
            using GPIOALPEN = Field<0, 1>;    // GPIO peripheral clock enable during CSleep mode
            using GPIOBLPEN = Field<1, 1>;    // GPIO peripheral clock enable during CSleep mode
            using GPIOCLPEN = Field<2, 1>;    // GPIO peripheral clock enable during CSleep mode
            using GPIODLPEN = Field<3, 1>;    // GPIO peripheral clock enable during CSleep mode
            using GPIOELPEN = Field<4, 1>;    // GPIO peripheral clock enable during CSleep mode
            using GPIOFLPEN = Field<5, 1>;    // GPIO peripheral clock enable during CSleep mode
            using GPIOGLPEN = Field<6, 1>;    // GPIO peripheral clock enable during CSleep mode
            using GPIOHLPEN = Field<7, 1>;    // GPIO peripheral clock enable during CSleep mode
            using GPIOILPEN = Field<8, 1>;    // GPIO peripheral clock enable during CSleep mode
            using GPIOJLPEN = Field<9, 1>;    // GPIO peripheral clock enable during CSleep mode
            using GPIOKLPEN = Field<10, 1>;    // GPIO peripheral clock enable during CSleep mode
            using CRCLPEN = Field<19, 1>;    // CRC peripheral clock enable during CSleep mode
            using BDMALPEN = Field<21, 1>;    // BDMA Clock Enable During CSleep Mode
            using ADC3LPEN = Field<24, 1>;    // ADC3 Peripheral Clocks Enable During CSleep Mode
            using BKPRAMLPEN = Field<28, 1>;    // Backup RAM Clock Enable During CSleep Mode
            using SRAM4LPEN = Field<29, 1>;    // SRAM4 Clock Enable During CSleep Mode
        };

        // RCC AHB4 Sleep Clock Register
        struct C1_AHB4LPENR : public Register<0x58024568> {
            using GPIOALPEN = Field<0, 1>;    // GPIO peripheral clock enable during CSleep mode
            using GPIOBLPEN = Field<1, 1>;    // GPIO peripheral clock enable during CSleep mode
            using GPIOCLPEN = Field<2, 1>;    // GPIO peripheral clock enable during CSleep mode
            using GPIODLPEN = Field<3, 1>;    // GPIO peripheral clock enable during CSleep mode
            using GPIOELPEN = Field<4, 1>;    // GPIO peripheral clock enable during CSleep mode
            using GPIOFLPEN = Field<5, 1>;    // GPIO peripheral clock enable during CSleep mode
            using GPIOGLPEN = Field<6, 1>;    // GPIO peripheral clock enable during CSleep mode
            using GPIOHLPEN = Field<7, 1>;    // GPIO peripheral clock enable during CSleep mode
            using GPIOILPEN = Field<8, 1>;    // GPIO peripheral clock enable during CSleep mode
            using GPIOJLPEN = Field<9, 1>;    // GPIO peripheral clock enable during CSleep mode
            using GPIOKLPEN = Field<10, 1>;    // GPIO peripheral clock enable during CSleep mode
            using CRCLPEN = Field<19, 1>;    // CRC peripheral clock enable during CSleep mode
            using BDMALPEN = Field<21, 1>;    // BDMA Clock Enable During CSleep Mode
            using ADC3LPEN = Field<24, 1>;    // ADC3 Peripheral Clocks Enable During CSleep Mode
            using BKPRAMLPEN = Field<28, 1>;    // Backup RAM Clock Enable During CSleep Mode
            using SRAM4LPEN = Field<29, 1>;    // SRAM4 Clock Enable During CSleep Mode
        };

        // RCC APB3 Sleep Clock Register
        struct C1_APB3LPENR : public Register<0x5802456c> {
            using LTDCLPEN = Field<3, 1>;    // LTDC peripheral clock enable during CSleep mode
            using WWDG1LPEN = Field<6, 1>;    // WWDG1 Clock Enable During CSleep Mode
        };

        // RCC APB3 Sleep Clock Register
        struct APB3LPENR : public Register<0x5802450c> {
            using LTDCLPEN = Field<3, 1>;    // LTDC peripheral clock enable during CSleep mode
            using WWDG1LPEN = Field<6, 1>;    // WWDG1 Clock Enable During CSleep Mode
        };

        // RCC APB1 Low Sleep Clock Register
        struct APB1LLPENR : public Register<0x58024510> {
            using TIM2LPEN = Field<0, 1>;    // TIM2 peripheral clock enable during CSleep mode
            using TIM3LPEN = Field<1, 1>;    // TIM3 peripheral clock enable during CSleep mode
            using TIM4LPEN = Field<2, 1>;    // TIM4 peripheral clock enable during CSleep mode
            using TIM5LPEN = Field<3, 1>;    // TIM5 peripheral clock enable during CSleep mode
            using TIM6LPEN = Field<4, 1>;    // TIM6 peripheral clock enable during CSleep mode
            using TIM7LPEN = Field<5, 1>;    // TIM7 peripheral clock enable during CSleep mode
            using TIM12LPEN = Field<6, 1>;    // TIM12 peripheral clock enable during CSleep mode
            using TIM13LPEN = Field<7, 1>;    // TIM13 peripheral clock enable during CSleep mode
            using TIM14LPEN = Field<8, 1>;    // TIM14 peripheral clock enable during CSleep mode
            using LPTIM1LPEN = Field<9, 1>;    // LPTIM1 Peripheral Clocks Enable During CSleep Mode
            using SPI2LPEN = Field<14, 1>;    // SPI2 Peripheral Clocks Enable During CSleep Mode
            using SPI3LPEN = Field<15, 1>;    // SPI3 Peripheral Clocks Enable During CSleep Mode
            using SPDIFRXLPEN = Field<16, 1>;    // SPDIFRX Peripheral Clocks Enable During CSleep Mode
            using USART2LPEN = Field<17, 1>;    // USART2 Peripheral Clocks Enable During CSleep Mode
            using USART3LPEN = Field<18, 1>;    // USART3 Peripheral Clocks Enable During CSleep Mode
            using UART4LPEN = Field<19, 1>;    // UART4 Peripheral Clocks Enable During CSleep Mode
            using UART5LPEN = Field<20, 1>;    // UART5 Peripheral Clocks Enable During CSleep Mode
            using I2C1LPEN = Field<21, 1>;    // I2C1 Peripheral Clocks Enable During CSleep Mode
            using I2C2LPEN = Field<22, 1>;    // I2C2 Peripheral Clocks Enable During CSleep Mode
            using I2C3LPEN = Field<23, 1>;    // I2C3 Peripheral Clocks Enable During CSleep Mode
            using HDMICECLPEN = Field<27, 1>;    // HDMI-CEC Peripheral Clocks Enable During CSleep Mode
            using DAC12LPEN = Field<29, 1>;    // DAC1/2 peripheral clock enable during CSleep mode
            using USART7LPEN = Field<30, 1>;    // USART7 Peripheral Clocks Enable During CSleep Mode
            using USART8LPEN = Field<31, 1>;    // USART8 Peripheral Clocks Enable During CSleep Mode
        };

        // RCC APB1 Low Sleep Clock Register
        struct C1_APB1LLPENR : public Register<0x58024570> {
            using TIM2LPEN = Field<0, 1>;    // TIM2 peripheral clock enable during CSleep mode
            using TIM3LPEN = Field<1, 1>;    // TIM3 peripheral clock enable during CSleep mode
            using TIM4LPEN = Field<2, 1>;    // TIM4 peripheral clock enable during CSleep mode
            using TIM5LPEN = Field<3, 1>;    // TIM5 peripheral clock enable during CSleep mode
            using TIM6LPEN = Field<4, 1>;    // TIM6 peripheral clock enable during CSleep mode
            using TIM7LPEN = Field<5, 1>;    // TIM7 peripheral clock enable during CSleep mode
            using TIM12LPEN = Field<6, 1>;    // TIM12 peripheral clock enable during CSleep mode
            using TIM13LPEN = Field<7, 1>;    // TIM13 peripheral clock enable during CSleep mode
            using TIM14LPEN = Field<8, 1>;    // TIM14 peripheral clock enable during CSleep mode
            using LPTIM1LPEN = Field<9, 1>;    // LPTIM1 Peripheral Clocks Enable During CSleep Mode
            using SPI2LPEN = Field<14, 1>;    // SPI2 Peripheral Clocks Enable During CSleep Mode
            using SPI3LPEN = Field<15, 1>;    // SPI3 Peripheral Clocks Enable During CSleep Mode
            using SPDIFRXLPEN = Field<16, 1>;    // SPDIFRX Peripheral Clocks Enable During CSleep Mode
            using USART2LPEN = Field<17, 1>;    // USART2 Peripheral Clocks Enable During CSleep Mode
            using USART3LPEN = Field<18, 1>;    // USART3 Peripheral Clocks Enable During CSleep Mode
            using UART4LPEN = Field<19, 1>;    // UART4 Peripheral Clocks Enable During CSleep Mode
            using UART5LPEN = Field<20, 1>;    // UART5 Peripheral Clocks Enable During CSleep Mode
            using I2C1LPEN = Field<21, 1>;    // I2C1 Peripheral Clocks Enable During CSleep Mode
            using I2C2LPEN = Field<22, 1>;    // I2C2 Peripheral Clocks Enable During CSleep Mode
            using I2C3LPEN = Field<23, 1>;    // I2C3 Peripheral Clocks Enable During CSleep Mode
            using HDMICECLPEN = Field<27, 1>;    // HDMI-CEC Peripheral Clocks Enable During CSleep Mode
            using DAC12LPEN = Field<29, 1>;    // DAC1/2 peripheral clock enable during CSleep mode
            using USART7LPEN = Field<30, 1>;    // USART7 Peripheral Clocks Enable During CSleep Mode
            using USART8LPEN = Field<31, 1>;    // USART8 Peripheral Clocks Enable During CSleep Mode
        };

        // RCC APB1 High Sleep Clock Register
        struct C1_APB1HLPENR : public Register<0x58024574> {
            using CRSLPEN = Field<1, 1>;    // Clock Recovery System peripheral clock enable during CSleep mode
            using SWPLPEN = Field<2, 1>;    // SWPMI Peripheral Clocks Enable During CSleep Mode
            using OPAMPLPEN = Field<4, 1>;    // OPAMP peripheral clock enable during CSleep mode
            using MDIOSLPEN = Field<5, 1>;    // MDIOS peripheral clock enable during CSleep mode
            using FDCANLPEN = Field<8, 1>;    // FDCAN Peripheral Clocks Enable During CSleep Mode
        };

        // RCC APB1 High Sleep Clock Register
        struct APB1HLPENR : public Register<0x58024514> {
            using CRSLPEN = Field<1, 1>;    // Clock Recovery System peripheral clock enable during CSleep mode
            using SWPLPEN = Field<2, 1>;    // SWPMI Peripheral Clocks Enable During CSleep Mode
            using OPAMPLPEN = Field<4, 1>;    // OPAMP peripheral clock enable during CSleep mode
            using MDIOSLPEN = Field<5, 1>;    // MDIOS peripheral clock enable during CSleep mode
            using FDCANLPEN = Field<8, 1>;    // FDCAN Peripheral Clocks Enable During CSleep Mode
        };

        // RCC APB2 Sleep Clock Register
        struct APB2LPENR : public Register<0x58024518> {
            using TIM1LPEN = Field<0, 1>;    // TIM1 peripheral clock enable during CSleep mode
            using TIM8LPEN = Field<1, 1>;    // TIM8 peripheral clock enable during CSleep mode
            using USART1LPEN = Field<4, 1>;    // USART1 Peripheral Clocks Enable During CSleep Mode
            using USART6LPEN = Field<5, 1>;    // USART6 Peripheral Clocks Enable During CSleep Mode
            using SPI1LPEN = Field<12, 1>;    // SPI1 Peripheral Clocks Enable During CSleep Mode
            using SPI4LPEN = Field<13, 1>;    // SPI4 Peripheral Clocks Enable During CSleep Mode
            using TIM15LPEN = Field<16, 1>;    // TIM15 peripheral clock enable during CSleep mode
            using TIM16LPEN = Field<17, 1>;    // TIM16 peripheral clock enable during CSleep mode
            using TIM17LPEN = Field<18, 1>;    // TIM17 peripheral clock enable during CSleep mode
            using SPI5LPEN = Field<20, 1>;    // SPI5 Peripheral Clocks Enable During CSleep Mode
            using SAI1LPEN = Field<22, 1>;    // SAI1 Peripheral Clocks Enable During CSleep Mode
            using SAI2LPEN = Field<23, 1>;    // SAI2 Peripheral Clocks Enable During CSleep Mode
            using SAI3LPEN = Field<24, 1>;    // SAI3 Peripheral Clocks Enable During CSleep Mode
            using DFSDM1LPEN = Field<28, 1>;    // DFSDM1 Peripheral Clocks Enable During CSleep Mode
            using HRTIMLPEN = Field<29, 1>;    // HRTIM peripheral clock enable during CSleep mode
        };

        // RCC APB2 Sleep Clock Register
        struct C1_APB2LPENR : public Register<0x58024578> {
            using TIM1LPEN = Field<0, 1>;    // TIM1 peripheral clock enable during CSleep mode
            using TIM8LPEN = Field<1, 1>;    // TIM8 peripheral clock enable during CSleep mode
            using USART1LPEN = Field<4, 1>;    // USART1 Peripheral Clocks Enable During CSleep Mode
            using USART6LPEN = Field<5, 1>;    // USART6 Peripheral Clocks Enable During CSleep Mode
            using SPI1LPEN = Field<12, 1>;    // SPI1 Peripheral Clocks Enable During CSleep Mode
            using SPI4LPEN = Field<13, 1>;    // SPI4 Peripheral Clocks Enable During CSleep Mode
            using TIM15LPEN = Field<16, 1>;    // TIM15 peripheral clock enable during CSleep mode
            using TIM16LPEN = Field<17, 1>;    // TIM16 peripheral clock enable during CSleep mode
            using TIM17LPEN = Field<18, 1>;    // TIM17 peripheral clock enable during CSleep mode
            using SPI5LPEN = Field<20, 1>;    // SPI5 Peripheral Clocks Enable During CSleep Mode
            using SAI1LPEN = Field<22, 1>;    // SAI1 Peripheral Clocks Enable During CSleep Mode
            using SAI2LPEN = Field<23, 1>;    // SAI2 Peripheral Clocks Enable During CSleep Mode
            using SAI3LPEN = Field<24, 1>;    // SAI3 Peripheral Clocks Enable During CSleep Mode
            using DFSDM1LPEN = Field<28, 1>;    // DFSDM1 Peripheral Clocks Enable During CSleep Mode
            using HRTIMLPEN = Field<29, 1>;    // HRTIM peripheral clock enable during CSleep mode
        };

        // RCC APB4 Sleep Clock Register
        struct C1_APB4LPENR : public Register<0x5802457c> {
            using SYSCFGLPEN = Field<1, 1>;    // SYSCFG peripheral clock enable during CSleep mode
            using LPUART1LPEN = Field<3, 1>;    // LPUART1 Peripheral Clocks Enable During CSleep Mode
            using SPI6LPEN = Field<5, 1>;    // SPI6 Peripheral Clocks Enable During CSleep Mode
            using I2C4LPEN = Field<7, 1>;    // I2C4 Peripheral Clocks Enable During CSleep Mode
            using LPTIM2LPEN = Field<9, 1>;    // LPTIM2 Peripheral Clocks Enable During CSleep Mode
            using LPTIM3LPEN = Field<10, 1>;    // LPTIM3 Peripheral Clocks Enable During CSleep Mode
            using LPTIM4LPEN = Field<11, 1>;    // LPTIM4 Peripheral Clocks Enable During CSleep Mode
            using LPTIM5LPEN = Field<12, 1>;    // LPTIM5 Peripheral Clocks Enable During CSleep Mode
            using COMP12LPEN = Field<14, 1>;    // COMP1/2 peripheral clock enable during CSleep mode
            using VREFLPEN = Field<15, 1>;    // VREF peripheral clock enable during CSleep mode
            using RTCAPBLPEN = Field<16, 1>;    // RTC APB Clock Enable During CSleep Mode
            using SAI4LPEN = Field<21, 1>;    // SAI4 Peripheral Clocks Enable During CSleep Mode
        };

        // RCC APB4 Sleep Clock Register
        struct APB4LPENR : public Register<0x5802451c> {
            using SYSCFGLPEN = Field<1, 1>;    // SYSCFG peripheral clock enable during CSleep mode
            using LPUART1LPEN = Field<3, 1>;    // LPUART1 Peripheral Clocks Enable During CSleep Mode
            using SPI6LPEN = Field<5, 1>;    // SPI6 Peripheral Clocks Enable During CSleep Mode
            using I2C4LPEN = Field<7, 1>;    // I2C4 Peripheral Clocks Enable During CSleep Mode
            using LPTIM2LPEN = Field<9, 1>;    // LPTIM2 Peripheral Clocks Enable During CSleep Mode
            using LPTIM3LPEN = Field<10, 1>;    // LPTIM3 Peripheral Clocks Enable During CSleep Mode
            using LPTIM4LPEN = Field<11, 1>;    // LPTIM4 Peripheral Clocks Enable During CSleep Mode
            using LPTIM5LPEN = Field<12, 1>;    // LPTIM5 Peripheral Clocks Enable During CSleep Mode
            using COMP12LPEN = Field<14, 1>;    // COMP1/2 peripheral clock enable during CSleep mode
            using VREFLPEN = Field<15, 1>;    // VREF peripheral clock enable during CSleep mode
            using RTCAPBLPEN = Field<16, 1>;    // RTC APB Clock Enable During CSleep Mode
            using SAI4LPEN = Field<21, 1>;    // SAI4 Peripheral Clocks Enable During CSleep Mode
        };

    };

    // Low power timer
    struct LPTIM1 {
        // Interrupt and Status Register
        struct ISR : public RegisterReadOnly<0x40002400> {
            using DOWN = Field<6, 1>;    // Counter direction change up to down
            using UP = Field<5, 1>;    // Counter direction change down to up
            using ARROK = Field<4, 1>;    // Autoreload register update OK
            using CMPOK = Field<3, 1>;    // Compare register update OK
            using EXTTRIG = Field<2, 1>;    // External trigger edge event
            using ARRM = Field<1, 1>;    // Autoreload match
            using CMPM = Field<0, 1>;    // Compare match
        };

        // Interrupt Clear Register
        struct ICR : public RegisterWriteOnly<0x40002404> {
            using DOWNCF = Field<6, 1>;    // Direction change to down Clear Flag
            using UPCF = Field<5, 1>;    // Direction change to UP Clear Flag
            using ARROKCF = Field<4, 1>;    // Autoreload register update OK Clear Flag
            using CMPOKCF = Field<3, 1>;    // Compare register update OK Clear Flag
            using EXTTRIGCF = Field<2, 1>;    // External trigger valid edge Clear Flag
            using ARRMCF = Field<1, 1>;    // Autoreload match Clear Flag
            using CMPMCF = Field<0, 1>;    // compare match Clear Flag
        };

        // Interrupt Enable Register
        struct IER : public Register<0x40002408> {
            using DOWNIE = Field<6, 1>;    // Direction change to down Interrupt Enable
            using UPIE = Field<5, 1>;    // Direction change to UP Interrupt Enable
            using ARROKIE = Field<4, 1>;    // Autoreload register update OK Interrupt Enable
            using CMPOKIE = Field<3, 1>;    // Compare register update OK Interrupt Enable
            using EXTTRIGIE = Field<2, 1>;    // External trigger valid edge Interrupt Enable
            using ARRMIE = Field<1, 1>;    // Autoreload match Interrupt Enable
            using CMPMIE = Field<0, 1>;    // Compare match Interrupt Enable
        };

        // Configuration Register
        struct CFGR : public Register<0x4000240c> {
            using ENC = Field<24, 1>;    // Encoder mode enable
            using COUNTMODE = Field<23, 1>;    // counter mode enabled
            using PRELOAD = Field<22, 1>;    // Registers update mode
            using WAVPOL = Field<21, 1>;    // Waveform shape polarity
            using WAVE = Field<20, 1>;    // Waveform shape
            using TIMOUT = Field<19, 1>;    // Timeout enable
            using TRIGEN = Field<17, 2>;    // Trigger enable and polarity
            using TRIGSEL = Field<13, 3>;    // Trigger selector
            using PRESC = Field<9, 3>;    // Clock prescaler
            using TRGFLT = Field<6, 2>;    // Configurable digital filter for trigger
            using CKFLT = Field<3, 2>;    // Configurable digital filter for external clock
            using CKPOL = Field<1, 2>;    // Clock Polarity
            using CKSEL = Field<0, 1>;    // Clock selector
        };

        // Control Register
        struct CR : public Register<0x40002410> {
            using ENABLE = Field<0, 1>;    // LPTIM Enable
            using SNGSTRT = Field<1, 1>;    // LPTIM start in single mode
            using CNTSTRT = Field<2, 1>;    // Timer start in continuous mode
            using COUNTRST = Field<3, 1>;    // Counter reset
            using RSTARE = Field<4, 1>;    // Reset after read enable
        };

        // Compare Register
        struct CMP : public Register<0x40002414> {
            using Field = Field<0, 16>;    // Compare value
        };

        // Autoreload Register
        struct ARR : public Register<0x40002418> {
            using Field = Field<0, 16>;    // Auto reload value
        };

        // Counter Register
        struct CNT : public RegisterReadOnly<0x4000241c> {
            using Field = Field<0, 16>;    // Counter value
        };

        // LPTIM configuration register 2
        struct CFGR2 : public Register<0x40002424> {
            using IN1SEL = Field<0, 2>;    // LPTIM Input 1 selection
            using IN2SEL = Field<4, 2>;    // LPTIM Input 2 selection
        };

    };

    // Low power timer
    struct LPTIM2 {
        // Interrupt and Status Register
        struct ISR : public RegisterReadOnly<0x58002400> {
            using DOWN = Field<6, 1>;    // Counter direction change up to down
            using UP = Field<5, 1>;    // Counter direction change down to up
            using ARROK = Field<4, 1>;    // Autoreload register update OK
            using CMPOK = Field<3, 1>;    // Compare register update OK
            using EXTTRIG = Field<2, 1>;    // External trigger edge event
            using ARRM = Field<1, 1>;    // Autoreload match
            using CMPM = Field<0, 1>;    // Compare match
        };

        // Interrupt Clear Register
        struct ICR : public RegisterWriteOnly<0x58002404> {
            using DOWNCF = Field<6, 1>;    // Direction change to down Clear Flag
            using UPCF = Field<5, 1>;    // Direction change to UP Clear Flag
            using ARROKCF = Field<4, 1>;    // Autoreload register update OK Clear Flag
            using CMPOKCF = Field<3, 1>;    // Compare register update OK Clear Flag
            using EXTTRIGCF = Field<2, 1>;    // External trigger valid edge Clear Flag
            using ARRMCF = Field<1, 1>;    // Autoreload match Clear Flag
            using CMPMCF = Field<0, 1>;    // compare match Clear Flag
        };

        // Interrupt Enable Register
        struct IER : public Register<0x58002408> {
            using DOWNIE = Field<6, 1>;    // Direction change to down Interrupt Enable
            using UPIE = Field<5, 1>;    // Direction change to UP Interrupt Enable
            using ARROKIE = Field<4, 1>;    // Autoreload register update OK Interrupt Enable
            using CMPOKIE = Field<3, 1>;    // Compare register update OK Interrupt Enable
            using EXTTRIGIE = Field<2, 1>;    // External trigger valid edge Interrupt Enable
            using ARRMIE = Field<1, 1>;    // Autoreload match Interrupt Enable
            using CMPMIE = Field<0, 1>;    // Compare match Interrupt Enable
        };

        // Configuration Register
        struct CFGR : public Register<0x5800240c> {
            using ENC = Field<24, 1>;    // Encoder mode enable
            using COUNTMODE = Field<23, 1>;    // counter mode enabled
            using PRELOAD = Field<22, 1>;    // Registers update mode
            using WAVPOL = Field<21, 1>;    // Waveform shape polarity
            using WAVE = Field<20, 1>;    // Waveform shape
            using TIMOUT = Field<19, 1>;    // Timeout enable
            using TRIGEN = Field<17, 2>;    // Trigger enable and polarity
            using TRIGSEL = Field<13, 3>;    // Trigger selector
            using PRESC = Field<9, 3>;    // Clock prescaler
            using TRGFLT = Field<6, 2>;    // Configurable digital filter for trigger
            using CKFLT = Field<3, 2>;    // Configurable digital filter for external clock
            using CKPOL = Field<1, 2>;    // Clock Polarity
            using CKSEL = Field<0, 1>;    // Clock selector
        };

        // Control Register
        struct CR : public Register<0x58002410> {
            using ENABLE = Field<0, 1>;    // LPTIM Enable
            using SNGSTRT = Field<1, 1>;    // LPTIM start in single mode
            using CNTSTRT = Field<2, 1>;    // Timer start in continuous mode
            using COUNTRST = Field<3, 1>;    // Counter reset
            using RSTARE = Field<4, 1>;    // Reset after read enable
        };

        // Compare Register
        struct CMP : public Register<0x58002414> {
            using Field = Field<0, 16>;    // Compare value
        };

        // Autoreload Register
        struct ARR : public Register<0x58002418> {
            using Field = Field<0, 16>;    // Auto reload value
        };

        // Counter Register
        struct CNT : public RegisterReadOnly<0x5800241c> {
            using Field = Field<0, 16>;    // Counter value
        };

        // LPTIM configuration register 2
        struct CFGR2 : public Register<0x58002424> {
            using IN1SEL = Field<0, 2>;    // LPTIM Input 1 selection
            using IN2SEL = Field<4, 2>;    // LPTIM Input 2 selection
        };

    };

    // Low power timer
    struct LPTIM3 {
        // Interrupt and Status Register
        struct ISR : public RegisterReadOnly<0x58002800> {
            using DOWN = Field<6, 1>;    // Counter direction change up to down
            using UP = Field<5, 1>;    // Counter direction change down to up
            using ARROK = Field<4, 1>;    // Autoreload register update OK
            using CMPOK = Field<3, 1>;    // Compare register update OK
            using EXTTRIG = Field<2, 1>;    // External trigger edge event
            using ARRM = Field<1, 1>;    // Autoreload match
            using CMPM = Field<0, 1>;    // Compare match
        };

        // Interrupt Clear Register
        struct ICR : public RegisterWriteOnly<0x58002804> {
            using DOWNCF = Field<6, 1>;    // Direction change to down Clear Flag
            using UPCF = Field<5, 1>;    // Direction change to UP Clear Flag
            using ARROKCF = Field<4, 1>;    // Autoreload register update OK Clear Flag
            using CMPOKCF = Field<3, 1>;    // Compare register update OK Clear Flag
            using EXTTRIGCF = Field<2, 1>;    // External trigger valid edge Clear Flag
            using ARRMCF = Field<1, 1>;    // Autoreload match Clear Flag
            using CMPMCF = Field<0, 1>;    // compare match Clear Flag
        };

        // Interrupt Enable Register
        struct IER : public Register<0x58002808> {
            using DOWNIE = Field<6, 1>;    // Direction change to down Interrupt Enable
            using UPIE = Field<5, 1>;    // Direction change to UP Interrupt Enable
            using ARROKIE = Field<4, 1>;    // Autoreload register update OK Interrupt Enable
            using CMPOKIE = Field<3, 1>;    // Compare register update OK Interrupt Enable
            using EXTTRIGIE = Field<2, 1>;    // External trigger valid edge Interrupt Enable
            using ARRMIE = Field<1, 1>;    // Autoreload match Interrupt Enable
            using CMPMIE = Field<0, 1>;    // Compare match Interrupt Enable
        };

        // Configuration Register
        struct CFGR : public Register<0x5800280c> {
            using ENC = Field<24, 1>;    // Encoder mode enable
            using COUNTMODE = Field<23, 1>;    // counter mode enabled
            using PRELOAD = Field<22, 1>;    // Registers update mode
            using WAVPOL = Field<21, 1>;    // Waveform shape polarity
            using WAVE = Field<20, 1>;    // Waveform shape
            using TIMOUT = Field<19, 1>;    // Timeout enable
            using TRIGEN = Field<17, 2>;    // Trigger enable and polarity
            using TRIGSEL = Field<13, 3>;    // Trigger selector
            using PRESC = Field<9, 3>;    // Clock prescaler
            using TRGFLT = Field<6, 2>;    // Configurable digital filter for trigger
            using CKFLT = Field<3, 2>;    // Configurable digital filter for external clock
            using CKPOL = Field<1, 2>;    // Clock Polarity
            using CKSEL = Field<0, 1>;    // Clock selector
        };

        // Control Register
        struct CR : public Register<0x58002810> {
            using ENABLE = Field<0, 1>;    // LPTIM Enable
            using SNGSTRT = Field<1, 1>;    // LPTIM start in single mode
            using CNTSTRT = Field<2, 1>;    // Timer start in continuous mode
            using COUNTRST = Field<3, 1>;    // Counter reset
            using RSTARE = Field<4, 1>;    // Reset after read enable
        };

        // Compare Register
        struct CMP : public Register<0x58002814> {
            using Field = Field<0, 16>;    // Compare value
        };

        // Autoreload Register
        struct ARR : public Register<0x58002818> {
            using Field = Field<0, 16>;    // Auto reload value
        };

        // Counter Register
        struct CNT : public RegisterReadOnly<0x5800281c> {
            using Field = Field<0, 16>;    // Counter value
        };

        // LPTIM configuration register 2
        struct CFGR2 : public Register<0x58002824> {
            using IN1SEL = Field<0, 2>;    // LPTIM Input 1 selection
        };

    };

    // Low power timer
    struct LPTIM4 {
        // Interrupt and Status Register
        struct ISR : public RegisterReadOnly<0x58002c00> {
            using DOWN = Field<6, 1>;    // Counter direction change up to down
            using UP = Field<5, 1>;    // Counter direction change down to up
            using ARROK = Field<4, 1>;    // Autoreload register update OK
            using CMPOK = Field<3, 1>;    // Compare register update OK
            using EXTTRIG = Field<2, 1>;    // External trigger edge event
            using ARRM = Field<1, 1>;    // Autoreload match
            using CMPM = Field<0, 1>;    // Compare match
        };

        // Interrupt Clear Register
        struct ICR : public RegisterWriteOnly<0x58002c04> {
            using DOWNCF = Field<6, 1>;    // Direction change to down Clear Flag
            using UPCF = Field<5, 1>;    // Direction change to UP Clear Flag
            using ARROKCF = Field<4, 1>;    // Autoreload register update OK Clear Flag
            using CMPOKCF = Field<3, 1>;    // Compare register update OK Clear Flag
            using EXTTRIGCF = Field<2, 1>;    // External trigger valid edge Clear Flag
            using ARRMCF = Field<1, 1>;    // Autoreload match Clear Flag
            using CMPMCF = Field<0, 1>;    // compare match Clear Flag
        };

        // Interrupt Enable Register
        struct IER : public Register<0x58002c08> {
            using DOWNIE = Field<6, 1>;    // Direction change to down Interrupt Enable
            using UPIE = Field<5, 1>;    // Direction change to UP Interrupt Enable
            using ARROKIE = Field<4, 1>;    // Autoreload register update OK Interrupt Enable
            using CMPOKIE = Field<3, 1>;    // Compare register update OK Interrupt Enable
            using EXTTRIGIE = Field<2, 1>;    // External trigger valid edge Interrupt Enable
            using ARRMIE = Field<1, 1>;    // Autoreload match Interrupt Enable
            using CMPMIE = Field<0, 1>;    // Compare match Interrupt Enable
        };

        // Configuration Register
        struct CFGR : public Register<0x58002c0c> {
            using ENC = Field<24, 1>;    // Encoder mode enable
            using COUNTMODE = Field<23, 1>;    // counter mode enabled
            using PRELOAD = Field<22, 1>;    // Registers update mode
            using WAVPOL = Field<21, 1>;    // Waveform shape polarity
            using WAVE = Field<20, 1>;    // Waveform shape
            using TIMOUT = Field<19, 1>;    // Timeout enable
            using TRIGEN = Field<17, 2>;    // Trigger enable and polarity
            using TRIGSEL = Field<13, 3>;    // Trigger selector
            using PRESC = Field<9, 3>;    // Clock prescaler
            using TRGFLT = Field<6, 2>;    // Configurable digital filter for trigger
            using CKFLT = Field<3, 2>;    // Configurable digital filter for external clock
            using CKPOL = Field<1, 2>;    // Clock Polarity
            using CKSEL = Field<0, 1>;    // Clock selector
        };

        // Control Register
        struct CR : public Register<0x58002c10> {
            using ENABLE = Field<0, 1>;    // LPTIM Enable
            using SNGSTRT = Field<1, 1>;    // LPTIM start in single mode
            using CNTSTRT = Field<2, 1>;    // Timer start in continuous mode
            using COUNTRST = Field<3, 1>;    // Counter reset
            using RSTARE = Field<4, 1>;    // Reset after read enable
        };

        // Compare Register
        struct CMP : public Register<0x58002c14> {
            using Field = Field<0, 16>;    // Compare value
        };

        // Autoreload Register
        struct ARR : public Register<0x58002c18> {
            using Field = Field<0, 16>;    // Auto reload value
        };

        // Counter Register
        struct CNT : public RegisterReadOnly<0x58002c1c> {
            using Field = Field<0, 16>;    // Counter value
        };

        // LPTIM configuration register 2
        struct CFGR2 : public Register<0x58002c24> {
            using IN1SEL = Field<0, 2>;    // LPTIM Input 1 selection
        };

    };

    // Low power timer
    struct LPTIM5 {
        // Interrupt and Status Register
        struct ISR : public RegisterReadOnly<0x58003000> {
            using DOWN = Field<6, 1>;    // Counter direction change up to down
            using UP = Field<5, 1>;    // Counter direction change down to up
            using ARROK = Field<4, 1>;    // Autoreload register update OK
            using CMPOK = Field<3, 1>;    // Compare register update OK
            using EXTTRIG = Field<2, 1>;    // External trigger edge event
            using ARRM = Field<1, 1>;    // Autoreload match
            using CMPM = Field<0, 1>;    // Compare match
        };

        // Interrupt Clear Register
        struct ICR : public RegisterWriteOnly<0x58003004> {
            using DOWNCF = Field<6, 1>;    // Direction change to down Clear Flag
            using UPCF = Field<5, 1>;    // Direction change to UP Clear Flag
            using ARROKCF = Field<4, 1>;    // Autoreload register update OK Clear Flag
            using CMPOKCF = Field<3, 1>;    // Compare register update OK Clear Flag
            using EXTTRIGCF = Field<2, 1>;    // External trigger valid edge Clear Flag
            using ARRMCF = Field<1, 1>;    // Autoreload match Clear Flag
            using CMPMCF = Field<0, 1>;    // compare match Clear Flag
        };

        // Interrupt Enable Register
        struct IER : public Register<0x58003008> {
            using DOWNIE = Field<6, 1>;    // Direction change to down Interrupt Enable
            using UPIE = Field<5, 1>;    // Direction change to UP Interrupt Enable
            using ARROKIE = Field<4, 1>;    // Autoreload register update OK Interrupt Enable
            using CMPOKIE = Field<3, 1>;    // Compare register update OK Interrupt Enable
            using EXTTRIGIE = Field<2, 1>;    // External trigger valid edge Interrupt Enable
            using ARRMIE = Field<1, 1>;    // Autoreload match Interrupt Enable
            using CMPMIE = Field<0, 1>;    // Compare match Interrupt Enable
        };

        // Configuration Register
        struct CFGR : public Register<0x5800300c> {
            using ENC = Field<24, 1>;    // Encoder mode enable
            using COUNTMODE = Field<23, 1>;    // counter mode enabled
            using PRELOAD = Field<22, 1>;    // Registers update mode
            using WAVPOL = Field<21, 1>;    // Waveform shape polarity
            using WAVE = Field<20, 1>;    // Waveform shape
            using TIMOUT = Field<19, 1>;    // Timeout enable
            using TRIGEN = Field<17, 2>;    // Trigger enable and polarity
            using TRIGSEL = Field<13, 3>;    // Trigger selector
            using PRESC = Field<9, 3>;    // Clock prescaler
            using TRGFLT = Field<6, 2>;    // Configurable digital filter for trigger
            using CKFLT = Field<3, 2>;    // Configurable digital filter for external clock
            using CKPOL = Field<1, 2>;    // Clock Polarity
            using CKSEL = Field<0, 1>;    // Clock selector
        };

        // Control Register
        struct CR : public Register<0x58003010> {
            using ENABLE = Field<0, 1>;    // LPTIM Enable
            using SNGSTRT = Field<1, 1>;    // LPTIM start in single mode
            using CNTSTRT = Field<2, 1>;    // Timer start in continuous mode
            using COUNTRST = Field<3, 1>;    // Counter reset
            using RSTARE = Field<4, 1>;    // Reset after read enable
        };

        // Compare Register
        struct CMP : public Register<0x58003014> {
            using Field = Field<0, 16>;    // Compare value
        };

        // Autoreload Register
        struct ARR : public Register<0x58003018> {
            using Field = Field<0, 16>;    // Auto reload value
        };

        // Counter Register
        struct CNT : public RegisterReadOnly<0x5800301c> {
            using Field = Field<0, 16>;    // Counter value
        };

        // LPTIM configuration register 2
        struct CFGR2 : public Register<0x58003024> {
            using IN1SEL = Field<0, 2>;    // LPTIM Input 1 selection
        };

    };

    // LPUART1
    struct LPUART1 {
        // Control register 1
        struct CR1 : public Register<0x58000c00> {
            using RXFFIE = Field<31, 1>;    // RXFIFO Full interrupt enable
            using TXFEIE = Field<30, 1>;    // TXFIFO empty interrupt enable
            using FIFOEN = Field<29, 1>;    // FIFO mode enable
            using M1 = Field<28, 1>;    // Word length
            using DEAT = Field<21, 5>;    // Driver Enable assertion time
            using DEDT = Field<16, 5>;    // Driver Enable deassertion time
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x58000c04> {
            using ADD = Field<24, 8>;    // Address of the USART node
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using DATAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using STOP = Field<12, 2>;    // STOP bits
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x58000c08> {
            using TXFTCFG = Field<29, 3>;    // TXFIFO threshold configuration
            using RXFTIE = Field<28, 1>;    // RXFIFO threshold interrupt enable
            using RXFTCFG = Field<25, 3>;    // Receive FIFO threshold configuration
            using TXFTIE = Field<23, 1>;    // TXFIFO threshold interrupt enable
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x58000c0c> {
            using Field = Field<0, 20>;    // BRR
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x58000c10> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x58000c14> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x58000c18> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x58000c1c> {
            using TXFT = Field<27, 1>;    // TXFIFO threshold flag
            using RXFT = Field<26, 1>;    // RXFIFO threshold flag
            using RXFF = Field<24, 1>;    // RXFIFO Full
            using TXFE = Field<23, 1>;    // TXFIFO Empty
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NE = Field<2, 1>;    // NE
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x58000c20> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x58000c24> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x58000c28> {
            using Field = Field<0, 9>;    // Transmit data value
        };

        // Prescaler register
        struct PRESC : public Register<0x58000c2c> {
            using PRESCALER = Field<0, 4>;    // Clock prescaler
        };

    };

    // System configuration controller
    struct SYSCFG {
        // peripheral mode configuration register
        struct PMCR : public Register<0x58000404> {
            using I2C1FMP = Field<0, 1>;    // I2C1 Fm+
            using I2C2FMP = Field<1, 1>;    // I2C2 Fm+
            using I2C3FMP = Field<2, 1>;    // I2C3 Fm+
            using I2C4FMP = Field<3, 1>;    // I2C4 Fm+
            using PB6FMP = Field<4, 1>;    // PB(6) Fm+
            using PB7FMP = Field<5, 1>;    // PB(7) Fast Mode Plus
            using PB8FMP = Field<6, 1>;    // PB(8) Fast Mode Plus
            using PB9FMP = Field<7, 1>;    // PB(9) Fm+
            using BOOSTE = Field<8, 1>;    // Booster Enable
            using BOOSTVDDSEL = Field<9, 1>;    // Analog switch supply voltage selection
            using EPIS = Field<21, 3>;    // Ethernet PHY Interface Selection
            using PA0SO = Field<24, 1>;    // PA0 Switch Open
            using PA1SO = Field<25, 1>;    // PA1 Switch Open
            using PC2SO = Field<26, 1>;    // PC2 Switch Open
            using PC3SO = Field<27, 1>;    // PC3 Switch Open
        };

        // external interrupt configuration register 1
        struct EXTICR1 : public Register<0x58000408> {
            using EXTI3 = Field<12, 4>;    // EXTI x configuration (x = 0 to 3)
            using EXTI2 = Field<8, 4>;    // EXTI x configuration (x = 0 to 3)
            using EXTI1 = Field<4, 4>;    // EXTI x configuration (x = 0 to 3)
            using EXTI0 = Field<0, 4>;    // EXTI x configuration (x = 0 to 3)
        };

        // external interrupt configuration register 2
        struct EXTICR2 : public Register<0x5800040c> {
            using EXTI7 = Field<12, 4>;    // EXTI x configuration (x = 4 to 7)
            using EXTI6 = Field<8, 4>;    // EXTI x configuration (x = 4 to 7)
            using EXTI5 = Field<4, 4>;    // EXTI x configuration (x = 4 to 7)
            using EXTI4 = Field<0, 4>;    // EXTI x configuration (x = 4 to 7)
        };

        // external interrupt configuration register 3
        struct EXTICR3 : public Register<0x58000410> {
            using EXTI11 = Field<12, 4>;    // EXTI x configuration (x = 8 to 11)
            using EXTI10 = Field<8, 4>;    // EXTI10
            using EXTI9 = Field<4, 4>;    // EXTI x configuration (x = 8 to 11)
            using EXTI8 = Field<0, 4>;    // EXTI x configuration (x = 8 to 11)
        };

        // external interrupt configuration register 4
        struct EXTICR4 : public Register<0x58000414> {
            using EXTI15 = Field<12, 4>;    // EXTI x configuration (x = 12 to 15)
            using EXTI14 = Field<8, 4>;    // EXTI x configuration (x = 12 to 15)
            using EXTI13 = Field<4, 4>;    // EXTI x configuration (x = 12 to 15)
            using EXTI12 = Field<0, 4>;    // EXTI x configuration (x = 12 to 15)
        };

        // compensation cell control/status register
        struct CCCSR : public Register<0x58000420> {
            using EN = Field<0, 1>;    // enable
            using CS = Field<1, 1>;    // Code selection
            using READY = Field<8, 1>;    // Compensation cell ready flag
            using HSLV = Field<16, 1>;    // High-speed at low-voltage
        };

        // SYSCFG compensation cell value register
        struct CCVR : public RegisterReadOnly<0x58000424> {
            using NCV = Field<0, 4>;    // NMOS compensation value
            using PCV = Field<4, 4>;    // PMOS compensation value
        };

        // SYSCFG compensation cell code register
        struct CCCR : public Register<0x58000428> {
            using NCC = Field<0, 4>;    // NMOS compensation code
            using PCC = Field<4, 4>;    // PMOS compensation code
        };

        // SYSCFG power control register
        struct PWRCR : public Register<0x5800042c> {
            using ODEN = Field<0, 4>;    // Overdrive enable
        };

        // SYSCFG package register
        struct PKGR : public RegisterReadOnly<0x58000524> {
            using PKG = Field<0, 4>;    // Package
        };

        // SYSCFG user register 0
        struct UR0 : public RegisterReadOnly<0x58000700> {
            using BKS = Field<0, 1>;    // Bank Swap
            using RDP = Field<16, 8>;    // Readout protection
        };

        // SYSCFG user register 2
        struct UR2 : public Register<0x58000708> {
            using BORH = Field<0, 2>;    // BOR_LVL Brownout Reset Threshold Level
            using BOOT_ADD0 = Field<16, 16>;    // Boot Address 0
        };

        // SYSCFG user register 3
        struct UR3 : public Register<0x5800070c> {
            using BOOT_ADD1 = Field<16, 16>;    // Boot Address 1
        };

        // SYSCFG user register 4
        struct UR4 : public RegisterReadOnly<0x58000710> {
            using MEPAD_1 = Field<16, 1>;    // Mass Erase Protected Area Disabled for bank 1
        };

        // SYSCFG user register 5
        struct UR5 : public RegisterReadOnly<0x58000714> {
            using MESAD_1 = Field<0, 1>;    // Mass erase secured area disabled for bank 1
            using WRPN_1 = Field<16, 8>;    // Write protection for flash bank 1
        };

        // SYSCFG user register 6
        struct UR6 : public RegisterReadOnly<0x58000718> {
            using PA_BEG_1 = Field<0, 12>;    // Protected area start address for bank 1
            using PA_END_1 = Field<16, 12>;    // Protected area end address for bank 1
        };

        // SYSCFG user register 7
        struct UR7 : public RegisterReadOnly<0x5800071c> {
            using SA_BEG_1 = Field<0, 12>;    // Secured area start address for bank 1
            using SA_END_1 = Field<16, 12>;    // Secured area end address for bank 1
        };

        // SYSCFG user register 8
        struct UR8 : public RegisterReadOnly<0x58000720> {
            using MEPAD_2 = Field<0, 1>;    // Mass erase protected area disabled for bank 2
            using MESAD_2 = Field<16, 1>;    // Mass erase secured area disabled for bank 2
        };

        // SYSCFG user register 9
        struct UR9 : public RegisterReadOnly<0x58000724> {
            using WRPN_2 = Field<0, 8>;    // Write protection for flash bank 2
            using PA_BEG_2 = Field<16, 12>;    // Protected area start address for bank 2
        };

        // SYSCFG user register 10
        struct UR10 : public RegisterReadOnly<0x58000728> {
            using PA_END_2 = Field<0, 12>;    // Protected area end address for bank 2
            using SA_BEG_2 = Field<16, 12>;    // Secured area start address for bank 2
        };

        // SYSCFG user register 11
        struct UR11 : public RegisterReadOnly<0x5800072c> {
            using SA_END_2 = Field<0, 12>;    // Secured area end address for bank 2
            using IWDG1M = Field<16, 1>;    // Independent Watchdog 1 mode
        };

        // SYSCFG user register 12
        struct UR12 : public RegisterReadOnly<0x58000730> {
            using SECURE = Field<16, 1>;    // Secure mode
        };

        // SYSCFG user register 13
        struct UR13 : public RegisterReadOnly<0x58000734> {
            using SDRS = Field<0, 2>;    // Secured DTCM RAM Size
            using D1SBRST = Field<16, 1>;    // D1 Standby reset
        };

        // SYSCFG user register 14
        struct UR14 : public Register<0x58000738> {
            using D1STPRST = Field<0, 1>;    // D1 Stop Reset
        };

        // SYSCFG user register 15
        struct UR15 : public RegisterReadOnly<0x5800073c> {
            using FZIWDGSTB = Field<16, 1>;    // Freeze independent watchdog in Standby mode
        };

        // SYSCFG user register 16
        struct UR16 : public RegisterReadOnly<0x58000740> {
            using FZIWDGSTP = Field<0, 1>;    // Freeze independent watchdog in Stop mode
            using PKP = Field<16, 1>;    // Private key programmed
        };

        // SYSCFG user register 17
        struct UR17 : public RegisterReadOnly<0x58000744> {
            using IO_HSLV = Field<0, 1>;    // I/O high speed / low voltage
        };

    };

    // External interrupt/event controller
    struct EXTI {
        // EXTI rising trigger selection register
        struct RTSR1 : public Register<0x58000000> {
            using TR0 = Field<0, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR1 = Field<1, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR2 = Field<2, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR3 = Field<3, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR4 = Field<4, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR5 = Field<5, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR6 = Field<6, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR7 = Field<7, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR8 = Field<8, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR9 = Field<9, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR10 = Field<10, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR11 = Field<11, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR12 = Field<12, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR13 = Field<13, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR14 = Field<14, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR15 = Field<15, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR16 = Field<16, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR17 = Field<17, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR18 = Field<18, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR19 = Field<19, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR20 = Field<20, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR21 = Field<21, 1>;    // Rising trigger event configuration bit of Configurable Event input
        };

        // EXTI falling trigger selection register
        struct FTSR1 : public Register<0x58000004> {
            using TR0 = Field<0, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR1 = Field<1, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR2 = Field<2, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR3 = Field<3, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR4 = Field<4, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR5 = Field<5, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR6 = Field<6, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR7 = Field<7, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR8 = Field<8, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR9 = Field<9, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR10 = Field<10, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR11 = Field<11, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR12 = Field<12, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR13 = Field<13, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR14 = Field<14, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR15 = Field<15, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR16 = Field<16, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR17 = Field<17, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR18 = Field<18, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR19 = Field<19, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR20 = Field<20, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using TR21 = Field<21, 1>;    // Rising trigger event configuration bit of Configurable Event input
        };

        // EXTI software interrupt event register
        struct SWIER1 : public Register<0x58000008> {
            using SWIER0 = Field<0, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using Field = Field<1, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using SWIER2 = Field<2, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using SWIER3 = Field<3, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using SWIER4 = Field<4, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using SWIER5 = Field<5, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using SWIER6 = Field<6, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using SWIER7 = Field<7, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using SWIER8 = Field<8, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using SWIER9 = Field<9, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using SWIER10 = Field<10, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using SWIER11 = Field<11, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using SWIER12 = Field<12, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using SWIER13 = Field<13, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using SWIER14 = Field<14, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using SWIER15 = Field<15, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using SWIER16 = Field<16, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using SWIER17 = Field<17, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using SWIER18 = Field<18, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using SWIER19 = Field<19, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using SWIER20 = Field<20, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using SWIER21 = Field<21, 1>;    // Rising trigger event configuration bit of Configurable Event input
        };

        // EXTI D3 pending mask register
        struct D3PMR1 : public Register<0x5800000c> {
            using MR0 = Field<0, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR1 = Field<1, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR2 = Field<2, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR3 = Field<3, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR4 = Field<4, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR5 = Field<5, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR6 = Field<6, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR7 = Field<7, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR8 = Field<8, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR9 = Field<9, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR10 = Field<10, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR11 = Field<11, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR12 = Field<12, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR13 = Field<13, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR14 = Field<14, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR15 = Field<15, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR19 = Field<19, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR20 = Field<20, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR21 = Field<21, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR25 = Field<25, 1>;    // Rising trigger event configuration bit of Configurable Event input
        };

        // EXTI D3 pending clear selection register low
        struct D3PCR1L : public Register<0x58000010> {
            using PCS0 = Field<0, 2>;    // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
            using PCS1 = Field<2, 2>;    // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
            using PCS2 = Field<4, 2>;    // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
            using PCS3 = Field<6, 2>;    // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
            using PCS4 = Field<8, 2>;    // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
            using PCS5 = Field<10, 2>;    // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
            using PCS6 = Field<12, 2>;    // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
            using PCS7 = Field<14, 2>;    // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
            using PCS8 = Field<16, 2>;    // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
            using PCS9 = Field<18, 2>;    // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
            using PCS10 = Field<20, 2>;    // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
            using PCS11 = Field<22, 2>;    // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
            using PCS12 = Field<24, 2>;    // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
            using PCS13 = Field<26, 2>;    // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
            using PCS14 = Field<28, 2>;    // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
            using PCS15 = Field<30, 2>;    // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
        };

        // EXTI D3 pending clear selection register high
        struct D3PCR1H : public Register<0x58000014> {
            using PCS19 = Field<6, 2>;    // D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2)
            using PCS20 = Field<8, 2>;    // D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2)
            using PCS21 = Field<10, 2>;    // D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2)
            using PCS25 = Field<18, 2>;    // D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2)
        };

        // EXTI rising trigger selection register
        struct RTSR2 : public Register<0x58000020> {
            using TR49 = Field<17, 1>;    // Rising trigger event configuration bit of Configurable Event input x+32
            using TR51 = Field<19, 1>;    // Rising trigger event configuration bit of Configurable Event input x+32
        };

        // EXTI falling trigger selection register
        struct FTSR2 : public Register<0x58000024> {
            using TR49 = Field<17, 1>;    // Falling trigger event configuration bit of Configurable Event input x+32
            using TR51 = Field<19, 1>;    // Falling trigger event configuration bit of Configurable Event input x+32
        };

        // EXTI software interrupt event register
        struct SWIER2 : public Register<0x58000028> {
            using SWIER49 = Field<17, 1>;    // Software interrupt on line x+32
            using SWIER51 = Field<19, 1>;    // Software interrupt on line x+32
        };

        // EXTI D3 pending mask register
        struct D3PMR2 : public Register<0x5800002c> {
            using MR34 = Field<2, 1>;    // D3 Pending Mask on Event input x+32
            using MR35 = Field<3, 1>;    // D3 Pending Mask on Event input x+32
            using MR41 = Field<9, 1>;    // D3 Pending Mask on Event input x+32
            using MR48 = Field<16, 1>;    // D3 Pending Mask on Event input x+32
            using MR49 = Field<17, 1>;    // D3 Pending Mask on Event input x+32
            using MR50 = Field<18, 1>;    // D3 Pending Mask on Event input x+32
            using MR51 = Field<19, 1>;    // D3 Pending Mask on Event input x+32
            using MR52 = Field<20, 1>;    // D3 Pending Mask on Event input x+32
            using MR53 = Field<21, 1>;    // D3 Pending Mask on Event input x+32
        };

        // EXTI D3 pending clear selection register low
        struct D3PCR2L : public Register<0x58000030> {
            using PCS35 = Field<6, 2>;    // D3 Pending request clear input signal selection on Event input x = truncate ((n+64)/2)
            using PCS34 = Field<4, 2>;    // D3 Pending request clear input signal selection on Event input x = truncate ((n+64)/2)
            using PCS41 = Field<18, 2>;    // D3 Pending request clear input signal selection on Event input x = truncate ((n+64)/2)
        };

        // EXTI D3 pending clear selection register high
        struct D3PCR2H : public Register<0x58000034> {
            using PCS48 = Field<0, 2>;    // Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
            using PCS49 = Field<2, 2>;    // Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
            using PCS50 = Field<4, 2>;    // Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
            using PCS51 = Field<6, 2>;    // Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
            using PCS52 = Field<8, 2>;    // Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
            using PCS53 = Field<10, 2>;    // Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
        };

        // EXTI rising trigger selection register
        struct RTSR3 : public Register<0x58000040> {
            using TR82 = Field<18, 1>;    // Rising trigger event configuration bit of Configurable Event input x+64
            using TR84 = Field<20, 1>;    // Rising trigger event configuration bit of Configurable Event input x+64
            using TR85 = Field<21, 1>;    // Rising trigger event configuration bit of Configurable Event input x+64
            using TR86 = Field<22, 1>;    // Rising trigger event configuration bit of Configurable Event input x+64
        };

        // EXTI falling trigger selection register
        struct FTSR3 : public Register<0x58000044> {
            using TR82 = Field<18, 1>;    // Falling trigger event configuration bit of Configurable Event input x+64
            using TR84 = Field<20, 1>;    // Falling trigger event configuration bit of Configurable Event input x+64
            using TR85 = Field<21, 1>;    // Falling trigger event configuration bit of Configurable Event input x+64
            using TR86 = Field<22, 1>;    // Falling trigger event configuration bit of Configurable Event input x+64
        };

        // EXTI software interrupt event register
        struct SWIER3 : public Register<0x58000048> {
            using SWIER82 = Field<18, 1>;    // Software interrupt on line x+64
            using SWIER84 = Field<20, 1>;    // Software interrupt on line x+64
            using SWIER85 = Field<21, 1>;    // Software interrupt on line x+64
            using SWIER86 = Field<22, 1>;    // Software interrupt on line x+64
        };

        // EXTI D3 pending mask register
        struct D3PMR3 : public Register<0x5800004c> {
            using MR88 = Field<24, 1>;    // D3 Pending Mask on Event input x+64
        };

        // EXTI D3 pending clear selection register high
        struct D3PCR3H : public Register<0x58000054> {
            using PCS88 = Field<18, 2>;    // D3 Pending request clear input signal selection on Event input x= truncate N+160/2
        };

        // EXTI interrupt mask register
        struct CPUIMR1 : public Register<0x58000080> {
            using MR0 = Field<0, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR1 = Field<1, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR2 = Field<2, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR3 = Field<3, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR4 = Field<4, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR5 = Field<5, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR6 = Field<6, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR7 = Field<7, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR8 = Field<8, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR9 = Field<9, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR10 = Field<10, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR11 = Field<11, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR12 = Field<12, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR13 = Field<13, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR14 = Field<14, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR15 = Field<15, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR16 = Field<16, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR17 = Field<17, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR18 = Field<18, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR19 = Field<19, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR20 = Field<20, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR21 = Field<21, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR22 = Field<22, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR23 = Field<23, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR24 = Field<24, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR25 = Field<25, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR26 = Field<26, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR27 = Field<27, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR28 = Field<28, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR29 = Field<29, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR30 = Field<30, 1>;    // Rising trigger event configuration bit of Configurable Event input
            using MR31 = Field<31, 1>;    // Rising trigger event configuration bit of Configurable Event input
        };

        // EXTI event mask register
        struct CPUEMR1 : public Register<0x58000084> {
            using MR0 = Field<0, 1>;    // CPU Event mask on Event input x
            using MR1 = Field<1, 1>;    // CPU Event mask on Event input x
            using MR2 = Field<2, 1>;    // CPU Event mask on Event input x
            using MR3 = Field<3, 1>;    // CPU Event mask on Event input x
            using MR4 = Field<4, 1>;    // CPU Event mask on Event input x
            using MR5 = Field<5, 1>;    // CPU Event mask on Event input x
            using MR6 = Field<6, 1>;    // CPU Event mask on Event input x
            using MR7 = Field<7, 1>;    // CPU Event mask on Event input x
            using MR8 = Field<8, 1>;    // CPU Event mask on Event input x
            using MR9 = Field<9, 1>;    // CPU Event mask on Event input x
            using MR10 = Field<10, 1>;    // CPU Event mask on Event input x
            using MR11 = Field<11, 1>;    // CPU Event mask on Event input x
            using MR12 = Field<12, 1>;    // CPU Event mask on Event input x
            using MR13 = Field<13, 1>;    // CPU Event mask on Event input x
            using MR14 = Field<14, 1>;    // CPU Event mask on Event input x
            using MR15 = Field<15, 1>;    // CPU Event mask on Event input x
            using MR16 = Field<16, 1>;    // CPU Event mask on Event input x
            using MR17 = Field<17, 1>;    // CPU Event mask on Event input x
            using MR18 = Field<18, 1>;    // CPU Event mask on Event input x
            using MR19 = Field<19, 1>;    // CPU Event mask on Event input x
            using MR20 = Field<20, 1>;    // CPU Event mask on Event input x
            using MR21 = Field<21, 1>;    // CPU Event mask on Event input x
            using MR22 = Field<22, 1>;    // CPU Event mask on Event input x
            using MR23 = Field<23, 1>;    // CPU Event mask on Event input x
            using MR24 = Field<24, 1>;    // CPU Event mask on Event input x
            using MR25 = Field<25, 1>;    // CPU Event mask on Event input x
            using MR26 = Field<26, 1>;    // CPU Event mask on Event input x
            using MR27 = Field<27, 1>;    // CPU Event mask on Event input x
            using MR28 = Field<28, 1>;    // CPU Event mask on Event input x
            using MR29 = Field<29, 1>;    // CPU Event mask on Event input x
            using MR30 = Field<30, 1>;    // CPU Event mask on Event input x
            using MR31 = Field<31, 1>;    // CPU Event mask on Event input x
        };

        // EXTI pending register
        struct CPUPR1 : public Register<0x58000088> {
            using PR0 = Field<0, 1>;    // CPU Event mask on Event input x
            using PR1 = Field<1, 1>;    // CPU Event mask on Event input x
            using PR2 = Field<2, 1>;    // CPU Event mask on Event input x
            using PR3 = Field<3, 1>;    // CPU Event mask on Event input x
            using PR4 = Field<4, 1>;    // CPU Event mask on Event input x
            using PR5 = Field<5, 1>;    // CPU Event mask on Event input x
            using PR6 = Field<6, 1>;    // CPU Event mask on Event input x
            using PR7 = Field<7, 1>;    // CPU Event mask on Event input x
            using PR8 = Field<8, 1>;    // CPU Event mask on Event input x
            using PR9 = Field<9, 1>;    // CPU Event mask on Event input x
            using PR10 = Field<10, 1>;    // CPU Event mask on Event input x
            using PR11 = Field<11, 1>;    // CPU Event mask on Event input x
            using PR12 = Field<12, 1>;    // CPU Event mask on Event input x
            using PR13 = Field<13, 1>;    // CPU Event mask on Event input x
            using PR14 = Field<14, 1>;    // CPU Event mask on Event input x
            using PR15 = Field<15, 1>;    // CPU Event mask on Event input x
            using PR16 = Field<16, 1>;    // CPU Event mask on Event input x
            using PR17 = Field<17, 1>;    // CPU Event mask on Event input x
            using PR18 = Field<18, 1>;    // CPU Event mask on Event input x
            using PR19 = Field<19, 1>;    // CPU Event mask on Event input x
            using PR20 = Field<20, 1>;    // CPU Event mask on Event input x
            using PR21 = Field<21, 1>;    // CPU Event mask on Event input x
        };

        // EXTI interrupt mask register
        struct CPUIMR2 : public Register<0x58000090> {
            using MR0 = Field<0, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR1 = Field<1, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR2 = Field<2, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR3 = Field<3, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR4 = Field<4, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR5 = Field<5, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR6 = Field<6, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR7 = Field<7, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR8 = Field<8, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR9 = Field<9, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR10 = Field<10, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR11 = Field<11, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR12 = Field<12, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR14 = Field<14, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR15 = Field<15, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR16 = Field<16, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR17 = Field<17, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR18 = Field<18, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR19 = Field<19, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR20 = Field<20, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR21 = Field<21, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR22 = Field<22, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR23 = Field<23, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR24 = Field<24, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR25 = Field<25, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR26 = Field<26, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR27 = Field<27, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR28 = Field<28, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR29 = Field<29, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR30 = Field<30, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR31 = Field<31, 1>;    // CPU Interrupt Mask on Direct Event input x+32
        };

        // EXTI event mask register
        struct CPUEMR2 : public Register<0x58000094> {
            using MR32 = Field<0, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR33 = Field<1, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR34 = Field<2, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR35 = Field<3, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR36 = Field<4, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR37 = Field<5, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR38 = Field<6, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR39 = Field<7, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR40 = Field<8, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR41 = Field<9, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR42 = Field<10, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR43 = Field<11, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR44 = Field<12, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR46 = Field<14, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR47 = Field<15, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR48 = Field<16, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR49 = Field<17, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR50 = Field<18, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR51 = Field<19, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR52 = Field<20, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR53 = Field<21, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR54 = Field<22, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR55 = Field<23, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR56 = Field<24, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR57 = Field<25, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR58 = Field<26, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR59 = Field<27, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR60 = Field<28, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR61 = Field<29, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR62 = Field<30, 1>;    // CPU Interrupt Mask on Direct Event input x+32
            using MR63 = Field<31, 1>;    // CPU Interrupt Mask on Direct Event input x+32
        };

        // EXTI pending register
        struct CPUPR2 : public RegisterReadOnly<0x58000098> {
            using PR49 = Field<17, 1>;    // Configurable event inputs x+32 Pending bit
            using PR51 = Field<19, 1>;    // Configurable event inputs x+32 Pending bit
        };

        // EXTI interrupt mask register
        struct CPUIMR3 : public RegisterReadOnly<0x580000a0> {
            using MR64 = Field<0, 1>;    // CPU Interrupt Mask on Direct Event input x+64
            using MR65 = Field<1, 1>;    // CPU Interrupt Mask on Direct Event input x+64
            using MR66 = Field<2, 1>;    // CPU Interrupt Mask on Direct Event input x+64
            using MR67 = Field<3, 1>;    // CPU Interrupt Mask on Direct Event input x+64
            using MR68 = Field<4, 1>;    // CPU Interrupt Mask on Direct Event input x+64
            using MR69 = Field<5, 1>;    // CPU Interrupt Mask on Direct Event input x+64
            using MR70 = Field<6, 1>;    // CPU Interrupt Mask on Direct Event input x+64
            using MR71 = Field<7, 1>;    // CPU Interrupt Mask on Direct Event input x+64
            using MR72 = Field<8, 1>;    // CPU Interrupt Mask on Direct Event input x+64
            using MR73 = Field<9, 1>;    // CPU Interrupt Mask on Direct Event input x+64
            using MR74 = Field<10, 1>;    // CPU Interrupt Mask on Direct Event input x+64
            using MR75 = Field<11, 1>;    // CPU Interrupt Mask on Direct Event input x+64
            using MR76 = Field<12, 1>;    // CPU Interrupt Mask on Direct Event input x+64
            using MR77 = Field<13, 1>;    // CPU Interrupt Mask on Direct Event input x+64
            using MR78 = Field<14, 1>;    // CPU Interrupt Mask on Direct Event input x+64
            using MR79 = Field<15, 1>;    // CPU Interrupt Mask on Direct Event input x+64
            using MR80 = Field<16, 1>;    // CPU Interrupt Mask on Direct Event input x+64
            using MR82 = Field<18, 1>;    // CPU Interrupt Mask on Direct Event input x+64
            using MR84 = Field<20, 1>;    // CPU Interrupt Mask on Direct Event input x+64
            using MR85 = Field<21, 1>;    // CPU Interrupt Mask on Direct Event input x+64
            using MR86 = Field<22, 1>;    // CPU Interrupt Mask on Direct Event input x+64
            using MR87 = Field<23, 1>;    // CPU Interrupt Mask on Direct Event input x+64
            using MR88 = Field<24, 1>;    // CPU Interrupt Mask on Direct Event input x+64
        };

        // EXTI event mask register
        struct CPUEMR3 : public RegisterReadOnly<0x580000a4> {
            using MR64 = Field<0, 1>;    // CPU Event mask on Event input x+64
            using MR65 = Field<1, 1>;    // CPU Event mask on Event input x+64
            using MR66 = Field<2, 1>;    // CPU Event mask on Event input x+64
            using MR67 = Field<3, 1>;    // CPU Event mask on Event input x+64
            using MR68 = Field<4, 1>;    // CPU Event mask on Event input x+64
            using MR69 = Field<5, 1>;    // CPU Event mask on Event input x+64
            using MR70 = Field<6, 1>;    // CPU Event mask on Event input x+64
            using MR71 = Field<7, 1>;    // CPU Event mask on Event input x+64
            using MR72 = Field<8, 1>;    // CPU Event mask on Event input x+64
            using MR73 = Field<9, 1>;    // CPU Event mask on Event input x+64
            using MR74 = Field<10, 1>;    // CPU Event mask on Event input x+64
            using MR75 = Field<11, 1>;    // CPU Event mask on Event input x+64
            using MR76 = Field<12, 1>;    // CPU Event mask on Event input x+64
            using MR77 = Field<13, 1>;    // CPU Event mask on Event input x+64
            using MR78 = Field<14, 1>;    // CPU Event mask on Event input x+64
            using MR79 = Field<15, 1>;    // CPU Event mask on Event input x+64
            using MR80 = Field<16, 1>;    // CPU Event mask on Event input x+64
            using MR82 = Field<18, 1>;    // CPU Event mask on Event input x+64
            using MR84 = Field<20, 1>;    // CPU Event mask on Event input x+64
            using MR85 = Field<21, 1>;    // CPU Event mask on Event input x+64
            using MR86 = Field<22, 1>;    // CPU Event mask on Event input x+64
            using MR87 = Field<23, 1>;    // CPU Event mask on Event input x+64
            using MR88 = Field<24, 1>;    // CPU Event mask on Event input x+64
        };

        // EXTI pending register
        struct CPUPR3 : public RegisterReadOnly<0x580000a8> {
            using PR82 = Field<18, 1>;    // Configurable event inputs x+64 Pending bit
            using PR84 = Field<20, 1>;    // Configurable event inputs x+64 Pending bit
            using PR85 = Field<21, 1>;    // Configurable event inputs x+64 Pending bit
            using PR86 = Field<22, 1>;    // Configurable event inputs x+64 Pending bit
        };

    };

    // DELAY_Block_SDMMC1
    struct DELAY_Block_SDMMC1 {
        // DLYB control register
        struct CR : public Register<0x52008000> {
            using DEN = Field<0, 1>;    // Delay block enable bit
            using SEN = Field<1, 1>;    // Sampler length enable bit
        };

        // DLYB configuration register
        struct CFGR : public Register<0x52008004> {
            using SEL = Field<0, 4>;    // Select the phase for the Output clock
            using UNIT = Field<8, 7>;    // Delay Defines the delay of a Unit delay cell
            using LNG = Field<16, 12>;    // Delay line length value
            using LNGF = Field<31, 1>;    // Length valid flag
        };

    };

    // DELAY_Block_SDMMC1
    struct DELAY_Block_QUADSPI {
        // DLYB control register
        struct CR : public Register<0x52006000> {
            using DEN = Field<0, 1>;    // Delay block enable bit
            using SEN = Field<1, 1>;    // Sampler length enable bit
        };

        // DLYB configuration register
        struct CFGR : public Register<0x52006004> {
            using SEL = Field<0, 4>;    // Select the phase for the Output clock
            using UNIT = Field<8, 7>;    // Delay Defines the delay of a Unit delay cell
            using LNG = Field<16, 12>;    // Delay line length value
            using LNGF = Field<31, 1>;    // Length valid flag
        };

    };

    // DELAY_Block_SDMMC1
    struct DELAY_Block_SDMMC2 {
        // DLYB control register
        struct CR : public Register<0x48022800> {
            using DEN = Field<0, 1>;    // Delay block enable bit
            using SEN = Field<1, 1>;    // Sampler length enable bit
        };

        // DLYB configuration register
        struct CFGR : public Register<0x48022804> {
            using SEL = Field<0, 4>;    // Select the phase for the Output clock
            using UNIT = Field<8, 7>;    // Delay Defines the delay of a Unit delay cell
            using LNG = Field<16, 12>;    // Delay line length value
            using LNGF = Field<31, 1>;    // Length valid flag
        };

    };

    // Flash
    struct Flash {
        // Access control register
        struct ACR : public Register<0x52002000> {
            using LATENCY = Field<0, 3>;    // Read latency
            using WRHIGHFREQ = Field<4, 2>;    // Flash signal delay
        };

        // Access control register
        struct ACR_ : public Register<0x52002100> {
            using LATENCY = Field<0, 3>;    // Read latency
            using WRHIGHFREQ = Field<4, 2>;    // Flash signal delay
        };

        // FLASH key register for bank 1
        struct KEYR1 : public Register<0x52002004> {
            using Field = Field<0, 32>;    // Bank 1 access configuration unlock key
        };

        // FLASH option key register
        struct OPTKEYR : public Register<0x52002008> {
            using Field = Field<0, 32>;    // Unlock key option bytes
        };

        // FLASH option key register
        struct OPTKEYR_ : public Register<0x52002108> {
            using OPTKEYR = Field<0, 32>;    // Unlock key option bytes
        };

        // FLASH control register for bank 1
        struct CR1 : public Register<0x5200200c> {
            using LOCK1 = Field<0, 1>;    // Bank 1 configuration lock bit
            using PG1 = Field<1, 1>;    // Bank 1 program enable bit
            using SER1 = Field<2, 1>;    // Bank 1 sector erase request
            using BER1 = Field<3, 1>;    // Bank 1 erase request
            using PSIZE1 = Field<4, 2>;    // Bank 1 program size
            using FW1 = Field<6, 1>;    // Bank 1 write forcing control bit
            using START1 = Field<7, 1>;    // Bank 1 bank or sector erase start control bit
            using SNB1 = Field<8, 3>;    // Bank 1 sector erase selection number
            using CRC_EN = Field<15, 1>;    // Bank 1 CRC control bit
            using EOPIE1 = Field<16, 1>;    // Bank 1 end-of-program interrupt control bit
            using WRPERRIE1 = Field<17, 1>;    // Bank 1 write protection error interrupt enable bit
            using PGSERRIE1 = Field<18, 1>;    // Bank 1 programming sequence error interrupt enable bit
            using STRBERRIE1 = Field<19, 1>;    // Bank 1 strobe error interrupt enable bit
            using INCERRIE1 = Field<21, 1>;    // Bank 1 inconsistency error interrupt enable bit
            using OPERRIE1 = Field<22, 1>;    // Bank 1 write/erase error interrupt enable bit
            using RDPERRIE1 = Field<23, 1>;    // Bank 1 read protection error interrupt enable bit
            using RDSERRIE1 = Field<24, 1>;    // Bank 1 secure error interrupt enable bit
            using SNECCERRIE1 = Field<25, 1>;    // Bank 1 ECC single correction error interrupt enable bit
            using DBECCERRIE1 = Field<26, 1>;    // Bank 1 ECC double detection error interrupt enable bit
            using CRCENDIE1 = Field<27, 1>;    // Bank 1 end of CRC calculation interrupt enable bit
        };

        // FLASH status register for bank 1
        struct SR1 : public Register<0x52002010> {
            using BSY1 = Field<0, 1>;    // Bank 1 ongoing program flag
            using WBNE1 = Field<1, 1>;    // Bank 1 write buffer not empty flag
            using QW1 = Field<2, 1>;    // Bank 1 wait queue flag
            using CRC_BUSY1 = Field<3, 1>;    // Bank 1 CRC busy flag
            using EOP1 = Field<16, 1>;    // Bank 1 end-of-program flag
            using WRPERR1 = Field<17, 1>;    // Bank 1 write protection error flag
            using PGSERR1 = Field<18, 1>;    // Bank 1 programming sequence error flag
            using STRBERR1 = Field<19, 1>;    // Bank 1 strobe error flag
            using INCERR1 = Field<21, 1>;    // Bank 1 inconsistency error flag
            using OPERR1 = Field<22, 1>;    // Bank 1 write/erase error flag
            using RDPERR1 = Field<23, 1>;    // Bank 1 read protection error flag
            using RDSERR1 = Field<24, 1>;    // Bank 1 secure error flag
            using SNECCERR11 = Field<25, 1>;    // Bank 1 single correction error flag
            using DBECCERR1 = Field<26, 1>;    // Bank 1 ECC double detection error flag
            using CRCEND1 = Field<27, 1>;    // Bank 1 CRC-complete flag
        };

        // FLASH clear control register for bank 1
        struct CCR1 : public Register<0x52002014> {
            using CLR_EOP1 = Field<16, 1>;    // Bank 1 EOP1 flag clear bit
            using CLR_WRPERR1 = Field<17, 1>;    // Bank 1 WRPERR1 flag clear bit
            using CLR_PGSERR1 = Field<18, 1>;    // Bank 1 PGSERR1 flag clear bi
            using CLR_STRBERR1 = Field<19, 1>;    // Bank 1 STRBERR1 flag clear bit
            using CLR_INCERR1 = Field<21, 1>;    // Bank 1 INCERR1 flag clear bit
            using CLR_OPERR1 = Field<22, 1>;    // Bank 1 OPERR1 flag clear bit
            using CLR_RDPERR1 = Field<23, 1>;    // Bank 1 RDPERR1 flag clear bit
            using CLR_RDSERR1 = Field<24, 1>;    // Bank 1 RDSERR1 flag clear bit
            using CLR_SNECCERR1 = Field<25, 1>;    // Bank 1 SNECCERR1 flag clear bit
            using CLR_DBECCERR1 = Field<26, 1>;    // Bank 1 DBECCERR1 flag clear bit
            using CLR_CRCEND1 = Field<27, 1>;    // Bank 1 CRCEND1 flag clear bit
        };

        // FLASH option control register
        struct OPTCR : public Register<0x52002018> {
            using OPTLOCK = Field<0, 1>;    // FLASH_OPTCR lock option configuration bit
            using OPTSTART = Field<1, 1>;    // Option byte start change option configuration bit
            using MER = Field<4, 1>;    // Flash mass erase enable bit
            using OPTCHANGEERRIE = Field<30, 1>;    // Option byte change error interrupt enable bit
            using SWAP_BANK = Field<31, 1>;    // Bank swapping configuration bit
        };

        // FLASH option control register
        struct OPTCR_ : public Register<0x52002118> {
            using OPTLOCK = Field<0, 1>;    // FLASH_OPTCR lock option configuration bit
            using OPTSTART = Field<1, 1>;    // Option byte start change option configuration bit
            using MER = Field<4, 1>;    // Flash mass erase enable bit
            using OPTCHANGEERRIE = Field<30, 1>;    // Option byte change error interrupt enable bit
            using SWAP_BANK = Field<31, 1>;    // Bank swapping configuration bit
        };

        // FLASH option status register
        struct OPTSR_CUR_ : public Register<0x5200211c> {
            using OPT_BUSY = Field<0, 1>;    // Option byte change ongoing flag
            using BOR_LEV = Field<2, 2>;    // Brownout level option status bit
            using IWDG1_HW = Field<4, 1>;    // IWDG1 control option status bit
            using nRST_STOP_D1 = Field<6, 1>;    // D1 DStop entry reset option status bit
            using nRST_STBY_D1 = Field<7, 1>;    // D1 DStandby entry reset option status bit
            using RDP = Field<8, 8>;    // Readout protection level option status byte
            using FZ_IWDG_STOP = Field<17, 1>;    // IWDG Stop mode freeze option status bit
            using FZ_IWDG_SDBY = Field<18, 1>;    // IWDG Standby mode freeze option status bit
            using ST_RAM_SIZE = Field<19, 2>;    // DTCM RAM size option status
            using SECURITY = Field<21, 1>;    // Security enable option status bit
            using RSS1 = Field<26, 1>;    // User option bit 1
            using PERSO_OK = Field<28, 1>;    // Device personalization status bit
            using IO_HSLV = Field<29, 1>;    // I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V)
            using OPTCHANGEERR = Field<30, 1>;    // Option byte change error flag
            using SWAP_BANK_OPT = Field<31, 1>;    // Bank swapping option status bit
        };

        // FLASH option status register
        struct OPTSR_CUR : public Register<0x5200201c> {
            using OPT_BUSY = Field<0, 1>;    // Option byte change ongoing flag
            using BOR_LEV = Field<2, 2>;    // Brownout level option status bit
            using IWDG1_HW = Field<4, 1>;    // IWDG1 control option status bit
            using nRST_STOP_D1 = Field<6, 1>;    // D1 DStop entry reset option status bit
            using nRST_STBY_D1 = Field<7, 1>;    // D1 DStandby entry reset option status bit
            using RDP = Field<8, 8>;    // Readout protection level option status byte
            using FZ_IWDG_STOP = Field<17, 1>;    // IWDG Stop mode freeze option status bit
            using FZ_IWDG_SDBY = Field<18, 1>;    // IWDG Standby mode freeze option status bit
            using ST_RAM_SIZE = Field<19, 2>;    // DTCM RAM size option status
            using SECURITY = Field<21, 1>;    // Security enable option status bit
            using RSS1 = Field<26, 1>;    // User option bit 1
            using PERSO_OK = Field<28, 1>;    // Device personalization status bit
            using IO_HSLV = Field<29, 1>;    // I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V)
            using OPTCHANGEERR = Field<30, 1>;    // Option byte change error flag
            using SWAP_BANK_OPT = Field<31, 1>;    // Bank swapping option status bit
        };

        // FLASH option status register
        struct OPTSR_PRG : public Register<0x52002020> {
            using BOR_LEV = Field<2, 2>;    // BOR reset level option configuration bits
            using IWDG1_HW = Field<4, 1>;    // IWDG1 option configuration bit
            using nRST_STOP_D1 = Field<6, 1>;    // Option byte erase after D1 DStop option configuration bit
            using nRST_STBY_D1 = Field<7, 1>;    // Option byte erase after D1 DStandby option configuration bit
            using RDP = Field<8, 8>;    // Readout protection level option configuration byte
            using FZ_IWDG_STOP = Field<17, 1>;    // IWDG Stop mode freeze option configuration bit
            using FZ_IWDG_SDBY = Field<18, 1>;    // IWDG Standby mode freeze option configuration bit
            using ST_RAM_SIZE = Field<19, 2>;    // DTCM size select option configuration bits
            using SECURITY = Field<21, 1>;    // Security option configuration bit
            using RSS1 = Field<26, 1>;    // User option configuration bit 1
            using RSS2 = Field<27, 1>;    // User option configuration bit 2
            using IO_HSLV = Field<29, 1>;    // I/O high-speed at low-voltage (PRODUCT_BELOW_25V)
            using SWAP_BANK_OPT = Field<31, 1>;    // Bank swapping option configuration bit
        };

        // FLASH option status register
        struct OPTSR_PRG_ : public Register<0x52002120> {
            using BOR_LEV = Field<2, 2>;    // BOR reset level option configuration bits
            using IWDG1_HW = Field<4, 1>;    // IWDG1 option configuration bit
            using nRST_STOP_D1 = Field<6, 1>;    // Option byte erase after D1 DStop option configuration bit
            using nRST_STBY_D1 = Field<7, 1>;    // Option byte erase after D1 DStandby option configuration bit
            using RDP = Field<8, 8>;    // Readout protection level option configuration byte
            using FZ_IWDG_STOP = Field<17, 1>;    // IWDG Stop mode freeze option configuration bit
            using FZ_IWDG_SDBY = Field<18, 1>;    // IWDG Standby mode freeze option configuration bit
            using ST_RAM_SIZE = Field<19, 2>;    // DTCM size select option configuration bits
            using SECURITY = Field<21, 1>;    // Security option configuration bit
            using RSS1 = Field<26, 1>;    // User option configuration bit 1
            using RSS2 = Field<27, 1>;    // User option configuration bit 2
            using IO_HSLV = Field<29, 1>;    // I/O high-speed at low-voltage (PRODUCT_BELOW_25V)
            using SWAP_BANK_OPT = Field<31, 1>;    // Bank swapping option configuration bit
        };

        // FLASH option clear control register
        struct OPTCCR_ : public RegisterWriteOnly<0x52002124> {
            using CLR_OPTCHANGEERR = Field<30, 1>;    // OPTCHANGEERR reset bit
        };

        // FLASH option clear control register
        struct OPTCCR : public RegisterWriteOnly<0x52002024> {
            using CLR_OPTCHANGEERR = Field<30, 1>;    // OPTCHANGEERR reset bit
        };

        // FLASH protection address for bank 1
        struct PRAR_CUR1 : public RegisterReadOnly<0x52002028> {
            using PROT_AREA_START1 = Field<0, 12>;    // Bank 1 lowest PCROP protected address
            using PROT_AREA_END1 = Field<16, 12>;    // Bank 1 highest PCROP protected address
            using DMEP1 = Field<31, 1>;    // Bank 1 PCROP protected erase enable option status bit
        };

        // FLASH protection address for bank 1
        struct PRAR_PRG1 : public Register<0x5200202c> {
            using PROT_AREA_START1 = Field<0, 12>;    // Bank 1 lowest PCROP protected address configuration
            using PROT_AREA_END1 = Field<16, 12>;    // Bank 1 highest PCROP protected address configuration
            using DMEP1 = Field<31, 1>;    // Bank 1 PCROP protected erase enable option configuration bit
        };

        // FLASH secure address for bank 1
        struct SCAR_CUR1 : public Register<0x52002030> {
            using SEC_AREA_START1 = Field<0, 12>;    // Bank 1 lowest secure protected address
            using SEC_AREA_END1 = Field<16, 12>;    // Bank 1 highest secure protected address
            using DMES1 = Field<31, 1>;    // Bank 1 secure protected erase enable option status bit
        };

        // FLASH secure address for bank 1
        struct SCAR_PRG1 : public Register<0x52002034> {
            using SEC_AREA_START1 = Field<0, 12>;    // Bank 1 lowest secure protected address configuration
            using SEC_AREA_END1 = Field<16, 12>;    // Bank 1 highest secure protected address configuration
            using DMES1 = Field<31, 1>;    // Bank 1 secure protected erase enable option configuration bit
        };

        // FLASH write sector protection for bank 1
        struct WPSN_CUR1R : public RegisterReadOnly<0x52002038> {
            using WRPSn1 = Field<0, 8>;    // Bank 1 sector write protection option status byte
        };

        // FLASH write sector protection for bank 1
        struct WPSN_PRG1R : public Register<0x5200203c> {
            using WRPSn1 = Field<0, 8>;    // Bank 1 sector write protection configuration byte
        };

        // FLASH register with boot address
        struct BOOT_CURR : public RegisterReadOnly<0x52002040> {
            using BOOT_ADD0 = Field<0, 16>;    // Boot address 0
            using BOOT_ADD1 = Field<16, 16>;    // Boot address 1
        };

        // FLASH register with boot address
        struct BOOT_PRGR : public RegisterReadOnly<0x52002044> {
            using BOOT_ADD0 = Field<0, 16>;    // Boot address 0
            using BOOT_ADD1 = Field<16, 16>;    // Boot address 1
        };

        // FLASH CRC control register for bank 1
        struct CRCCR1 : public Register<0x52002050> {
            using CRC_SECT = Field<0, 3>;    // Bank 1 CRC sector number
            using ALL_BANK = Field<7, 1>;    // Bank 1 CRC select bit
            using CRC_BY_SECT = Field<8, 1>;    // Bank 1 CRC sector mode select bit
            using ADD_SECT = Field<9, 1>;    // Bank 1 CRC sector select bit
            using CLEAN_SECT = Field<10, 1>;    // Bank 1 CRC sector list clear bit
            using START_CRC = Field<16, 1>;    // Bank 1 CRC start bit
            using CLEAN_CRC = Field<17, 1>;    // Bank 1 CRC clear bit
            using CRC_BURST = Field<20, 2>;    // Bank 1 CRC burst size
        };

        // FLASH CRC start address register for bank 1
        struct CRCSADD1R : public Register<0x52002054> {
            using CRC_START_ADDR = Field<0, 32>;    // CRC start address on bank 1
        };

        // FLASH CRC end address register for bank 1
        struct CRCEADD1R : public Register<0x52002058> {
            using CRC_END_ADDR = Field<0, 32>;    // CRC end address on bank 1
        };

        // FLASH CRC data register
        struct CRCDATAR : public Register<0x5200205c> {
            using CRC_DATA = Field<0, 32>;    // CRC result
        };

        // FLASH ECC fail address for bank 1
        struct ECC_FA1R : public RegisterReadOnly<0x52002060> {
            using FAIL_ECC_ADDR1 = Field<0, 15>;    // Bank 1 ECC error address
        };

        // FLASH key register for bank 2
        struct KEYR2 : public RegisterReadOnly<0x52002104> {
            using Field = Field<0, 32>;    // Bank 2 access configuration unlock key
        };

        // FLASH control register for bank 2
        struct CR2 : public Register<0x5200210c> {
            using LOCK2 = Field<0, 1>;    // Bank 2 configuration lock bit
            using PG2 = Field<1, 1>;    // Bank 2 program enable bit
            using SER2 = Field<2, 1>;    // Bank 2 sector erase request
            using BER2 = Field<3, 1>;    // Bank 2 erase request
            using PSIZE2 = Field<4, 2>;    // Bank 2 program size
            using FW2 = Field<6, 1>;    // Bank 2 write forcing control bit
            using START2 = Field<7, 1>;    // Bank 2 bank or sector erase start control bit
            using SNB2 = Field<8, 3>;    // Bank 2 sector erase selection number
            using CRC_EN = Field<15, 1>;    // Bank 2 CRC control bit
            using EOPIE2 = Field<16, 1>;    // Bank 2 end-of-program interrupt control bit
            using WRPERRIE2 = Field<17, 1>;    // Bank 2 write protection error interrupt enable bit
            using PGSERRIE2 = Field<18, 1>;    // Bank 2 programming sequence error interrupt enable bit
            using STRBERRIE2 = Field<19, 1>;    // Bank 2 strobe error interrupt enable bit
            using INCERRIE2 = Field<21, 1>;    // Bank 2 inconsistency error interrupt enable bit
            using OPERRIE2 = Field<22, 1>;    // Bank 2 write/erase error interrupt enable bit
            using RDPERRIE2 = Field<23, 1>;    // Bank 2 read protection error interrupt enable bit
            using RDSERRIE2 = Field<24, 1>;    // Bank 2 secure error interrupt enable bit
            using SNECCERRIE2 = Field<25, 1>;    // Bank 2 ECC single correction error interrupt enable bit
            using DBECCERRIE2 = Field<26, 1>;    // Bank 2 ECC double detection error interrupt enable bit
            using CRCENDIE2 = Field<27, 1>;    // Bank 2 end of CRC calculation interrupt enable bit
        };

        // FLASH status register for bank 2
        struct SR2 : public Register<0x52002110> {
            using BSY2 = Field<0, 1>;    // Bank 2 ongoing program flag
            using WBNE2 = Field<1, 1>;    // Bank 2 write buffer not empty flag
            using QW2 = Field<2, 1>;    // Bank 2 wait queue flag
            using CRC_BUSY2 = Field<3, 1>;    // Bank 2 CRC busy flag
            using EOP2 = Field<16, 1>;    // Bank 2 end-of-program flag
            using WRPERR2 = Field<17, 1>;    // Bank 2 write protection error flag
            using PGSERR2 = Field<18, 1>;    // Bank 2 programming sequence error flag
            using STRBERR2 = Field<19, 1>;    // Bank 2 strobe error flag
            using INCERR2 = Field<21, 1>;    // Bank 2 inconsistency error flag
            using OPERR2 = Field<22, 1>;    // Bank 2 write/erase error flag
            using RDPERR2 = Field<23, 1>;    // Bank 2 read protection error flag
            using RDSERR2 = Field<24, 1>;    // Bank 2 secure error flag
            using SNECCERR2 = Field<25, 1>;    // Bank 2 single correction error flag
            using DBECCERR2 = Field<26, 1>;    // Bank 2 ECC double detection error flag
            using CRCEND2 = Field<27, 1>;    // Bank 2 CRC-complete flag
        };

        // FLASH clear control register for bank 2
        struct CCR2 : public Register<0x52002114> {
            using CLR_EOP2 = Field<16, 1>;    // Bank 1 EOP1 flag clear bit
            using CLR_WRPERR2 = Field<17, 1>;    // Bank 2 WRPERR1 flag clear bit
            using CLR_PGSERR2 = Field<18, 1>;    // Bank 2 PGSERR1 flag clear bi
            using CLR_STRBERR2 = Field<19, 1>;    // Bank 2 STRBERR1 flag clear bit
            using CLR_INCERR2 = Field<21, 1>;    // Bank 2 INCERR1 flag clear bit
            using CLR_OPERR2 = Field<22, 1>;    // Bank 2 OPERR1 flag clear bit
            using CLR_RDPERR2 = Field<23, 1>;    // Bank 2 RDPERR1 flag clear bit
            using CLR_RDSERR1 = Field<24, 1>;    // Bank 1 RDSERR1 flag clear bit
            using CLR_SNECCERR2 = Field<25, 1>;    // Bank 2 SNECCERR1 flag clear bit
            using CLR_DBECCERR1 = Field<26, 1>;    // Bank 1 DBECCERR1 flag clear bit
            using CLR_CRCEND2 = Field<27, 1>;    // Bank 2 CRCEND1 flag clear bit
        };

        // FLASH protection address for bank 1
        struct PRAR_CUR2 : public RegisterReadOnly<0x52002128> {
            using PROT_AREA_START2 = Field<0, 12>;    // Bank 2 lowest PCROP protected address
            using PROT_AREA_END2 = Field<16, 12>;    // Bank 2 highest PCROP protected address
            using DMEP2 = Field<31, 1>;    // Bank 2 PCROP protected erase enable option status bit
        };

        // FLASH protection address for bank 2
        struct PRAR_PRG2 : public Register<0x5200202c> {
            using PROT_AREA_START2 = Field<0, 12>;    // Bank 2 lowest PCROP protected address configuration
            using PROT_AREA_END2 = Field<16, 12>;    // Bank 2 highest PCROP protected address configuration
            using DMEP2 = Field<31, 1>;    // Bank 2 PCROP protected erase enable option configuration bit
        };

        // FLASH secure address for bank 2
        struct SCAR_CUR2 : public Register<0x52002130> {
            using SEC_AREA_START2 = Field<0, 12>;    // Bank 2 lowest secure protected address
            using SEC_AREA_END2 = Field<16, 12>;    // Bank 2 highest secure protected address
            using DMES2 = Field<31, 1>;    // Bank 2 secure protected erase enable option status bit
        };

        // FLASH secure address for bank 2
        struct SCAR_PRG2 : public Register<0x52002134> {
            using SEC_AREA_START2 = Field<0, 12>;    // Bank 2 lowest secure protected address configuration
            using SEC_AREA_END2 = Field<16, 12>;    // Bank 2 highest secure protected address configuration
            using DMES2 = Field<31, 1>;    // Bank 2 secure protected erase enable option configuration bit
        };

        // FLASH write sector protection for bank 2
        struct WPSN_CUR2R : public RegisterReadOnly<0x52002138> {
            using WRPSn2 = Field<0, 8>;    // Bank 2 sector write protection option status byte
        };

        // FLASH write sector protection for bank 2
        struct WPSN_PRG2R : public Register<0x5200213c> {
            using WRPSn2 = Field<0, 8>;    // Bank 2 sector write protection configuration byte
        };

        // FLASH CRC control register for bank 1
        struct CRCCR2 : public Register<0x52002150> {
            using CRC_SECT = Field<0, 3>;    // Bank 2 CRC sector number
            using ALL_BANK = Field<7, 1>;    // Bank 2 CRC select bit
            using CRC_BY_SECT = Field<8, 1>;    // Bank 2 CRC sector mode select bit
            using ADD_SECT = Field<9, 1>;    // Bank 2 CRC sector select bit
            using CLEAN_SECT = Field<10, 1>;    // Bank 2 CRC sector list clear bit
            using START_CRC = Field<16, 1>;    // Bank 2 CRC start bit
            using CLEAN_CRC = Field<17, 1>;    // Bank 2 CRC clear bit
            using CRC_BURST = Field<20, 2>;    // Bank 2 CRC burst size
        };

        // FLASH CRC start address register for bank 2
        struct CRCSADD2R : public Register<0x52002154> {
            using CRC_START_ADDR = Field<0, 32>;    // CRC start address on bank 2
        };

        // FLASH CRC end address register for bank 2
        struct CRCEADD2R : public Register<0x52002158> {
            using CRC_END_ADDR = Field<0, 32>;    // CRC end address on bank 2
        };

        // FLASH ECC fail address for bank 2
        struct ECC_FA2R : public RegisterReadOnly<0x52002160> {
            using FAIL_ECC_ADDR2 = Field<0, 15>;    // Bank 2 ECC error address
        };

    };

    // AXI interconnect registers
    struct AXI {
        // AXI interconnect - peripheral ID4 register
        struct AXI_PERIPH_ID_4 : public RegisterReadOnly<0x51001fd0> {
            using JEP106CON = Field<0, 4>;    // JEP106 continuation code
            using KCOUNT4 = Field<4, 4>;    // Register file size
        };

        // AXI interconnect - peripheral ID0 register
        struct AXI_PERIPH_ID_0 : public RegisterReadOnly<0x51001fe0> {
            using PARTNUM = Field<0, 8>;    // Peripheral part number bits 0 to 7
        };

        // AXI interconnect - peripheral ID1 register
        struct AXI_PERIPH_ID_1 : public RegisterReadOnly<0x51001fe4> {
            using PARTNUM = Field<0, 4>;    // Peripheral part number bits 8 to 11
            using JEP106I = Field<4, 4>;    // JEP106 identity bits 0 to 3
        };

        // AXI interconnect - peripheral ID2 register
        struct AXI_PERIPH_ID_2 : public RegisterReadOnly<0x51001fe8> {
            using JEP106ID = Field<0, 3>;    // JEP106 Identity bits 4 to 6
            using JEDEC = Field<3, 1>;    // JEP106 code flag
            using REVISION = Field<4, 4>;    // Peripheral revision number
        };

        // AXI interconnect - peripheral ID3 register
        struct AXI_PERIPH_ID_3 : public RegisterReadOnly<0x51001fec> {
            using CUST_MOD_NUM = Field<0, 4>;    // Customer modification
            using REV_AND = Field<4, 4>;    // Customer version
        };

        // AXI interconnect - component ID0 register
        struct AXI_COMP_ID_0 : public RegisterReadOnly<0x51001ff0> {
            using PREAMBLE = Field<0, 8>;    // Preamble bits 0 to 7
        };

        // AXI interconnect - component ID1 register
        struct AXI_COMP_ID_1 : public RegisterReadOnly<0x51001ff4> {
            using PREAMBLE = Field<0, 4>;    // Preamble bits 8 to 11
            using CLASS = Field<4, 4>;    // Component class
        };

        // AXI interconnect - component ID2 register
        struct AXI_COMP_ID_2 : public RegisterReadOnly<0x51001ff8> {
            using PREAMBLE = Field<0, 8>;    // Preamble bits 12 to 19
        };

        // AXI interconnect - component ID3 register
        struct AXI_COMP_ID_3 : public RegisterReadOnly<0x51001ffc> {
            using PREAMBLE = Field<0, 8>;    // Preamble bits 20 to 27
        };

        // AXI interconnect - TARG x bus matrix issuing functionality register
        struct AXI_TARG1_FN_MOD_ISS_BM : public Register<0x51002008> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // READ_ISS_OVERRIDE
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // Switch matrix write issuing override for target
        };

        // AXI interconnect - TARG x bus matrix issuing functionality register
        struct AXI_TARG2_FN_MOD_ISS_BM : public Register<0x51003008> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // READ_ISS_OVERRIDE
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // Switch matrix write issuing override for target
        };

        // AXI interconnect - TARG x bus matrix issuing functionality register
        struct AXI_TARG3_FN_MOD_ISS_BM : public Register<0x51004008> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // READ_ISS_OVERRIDE
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // Switch matrix write issuing override for target
        };

        // AXI interconnect - TARG x bus matrix issuing functionality register
        struct AXI_TARG4_FN_MOD_ISS_BM : public Register<0x51005008> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // READ_ISS_OVERRIDE
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // Switch matrix write issuing override for target
        };

        // AXI interconnect - TARG x bus matrix issuing functionality register
        struct AXI_TARG5_FN_MOD_ISS_BM : public Register<0x51006008> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // READ_ISS_OVERRIDE
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // Switch matrix write issuing override for target
        };

        // AXI interconnect - TARG x bus matrix issuing functionality register
        struct AXI_TARG6_FN_MOD_ISS_BM : public Register<0x51007008> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // READ_ISS_OVERRIDE
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // Switch matrix write issuing override for target
        };

        // AXI interconnect - TARG x bus matrix issuing functionality register
        struct AXI_TARG7_FN_MOD_ISS_BM : public Register<0x5100800c> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // READ_ISS_OVERRIDE
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // Switch matrix write issuing override for target
        };

        // AXI interconnect - TARG x bus matrix functionality 2 register
        struct AXI_TARG1_FN_MOD2 : public Register<0x51002024> {
            using BYPASS_MERGE = Field<0, 1>;    // Disable packing of beats to match the output data width
        };

        // AXI interconnect - TARG x bus matrix functionality 2 register
        struct AXI_TARG2_FN_MOD2 : public Register<0x51003024> {
            using BYPASS_MERGE = Field<0, 1>;    // Disable packing of beats to match the output data width
        };

        // AXI interconnect - TARG x bus matrix functionality 2 register
        struct AXI_TARG7_FN_MOD2 : public Register<0x51008024> {
            using BYPASS_MERGE = Field<0, 1>;    // Disable packing of beats to match the output data width
        };

        // AXI interconnect - TARG x long burst functionality modification
        struct AXI_TARG1_FN_MOD_LB : public Register<0x5100202c> {
            using FN_MOD_LB = Field<0, 1>;    // Controls burst breaking of long bursts
        };

        // AXI interconnect - TARG x long burst functionality modification
        struct AXI_TARG2_FN_MOD_LB : public Register<0x5100302c> {
            using FN_MOD_LB = Field<0, 1>;    // Controls burst breaking of long bursts
        };

        // AXI interconnect - TARG x long burst functionality modification
        struct AXI_TARG1_FN_MOD : public Register<0x51002108> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // Override AMIB read issuing capability
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // Override AMIB write issuing capability
        };

        // AXI interconnect - TARG x long burst functionality modification
        struct AXI_TARG2_FN_MOD : public Register<0x51003108> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // Override AMIB read issuing capability
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // Override AMIB write issuing capability
        };

        // AXI interconnect - TARG x long burst functionality modification
        struct AXI_TARG7_FN_MOD : public Register<0x51008108> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // Override AMIB read issuing capability
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // Override AMIB write issuing capability
        };

        // AXI interconnect - INI x functionality modification 2 register
        struct AXI_INI1_FN_MOD2 : public Register<0x51042024> {
            using BYPASS_MERGE = Field<0, 1>;    // Disables alteration of transactions by the up-sizer unless required by the protocol
        };

        // AXI interconnect - INI x functionality modification 2 register
        struct AXI_INI3_FN_MOD2 : public Register<0x51044024> {
            using BYPASS_MERGE = Field<0, 1>;    // Disables alteration of transactions by the up-sizer unless required by the protocol
        };

        // AXI interconnect - INI x AHB functionality modification register
        struct AXI_INI1_FN_MOD_AHB : public Register<0x51042028> {
            using RD_INC_OVERRIDE = Field<0, 1>;    // Converts all AHB-Lite write transactions to a series of single beat AXI
            using WR_INC_OVERRIDE = Field<1, 1>;    // Converts all AHB-Lite read transactions to a series of single beat AXI
        };

        // AXI interconnect - INI x AHB functionality modification register
        struct AXI_INI3_FN_MOD_AHB : public Register<0x51044028> {
            using RD_INC_OVERRIDE = Field<0, 1>;    // Converts all AHB-Lite write transactions to a series of single beat AXI
            using WR_INC_OVERRIDE = Field<1, 1>;    // Converts all AHB-Lite read transactions to a series of single beat AXI
        };

        // AXI interconnect - INI x read QoS register
        struct AXI_INI1_READ_QOS : public Register<0x51042100> {
            using AR_QOS = Field<0, 4>;    // Read channel QoS setting
        };

        // AXI interconnect - INI x read QoS register
        struct AXI_INI2_READ_QOS : public Register<0x51043100> {
            using AR_QOS = Field<0, 4>;    // Read channel QoS setting
        };

        // AXI interconnect - INI x read QoS register
        struct AXI_INI3_READ_QOS : public Register<0x51044100> {
            using AR_QOS = Field<0, 4>;    // Read channel QoS setting
        };

        // AXI interconnect - INI x read QoS register
        struct AXI_INI4_READ_QOS : public Register<0x51045100> {
            using AR_QOS = Field<0, 4>;    // Read channel QoS setting
        };

        // AXI interconnect - INI x read QoS register
        struct AXI_INI5_READ_QOS : public Register<0x51046100> {
            using AR_QOS = Field<0, 4>;    // Read channel QoS setting
        };

        // AXI interconnect - INI x read QoS register
        struct AXI_INI6_READ_QOS : public Register<0x51047100> {
            using AR_QOS = Field<0, 4>;    // Read channel QoS setting
        };

        // AXI interconnect - INI x write QoS register
        struct AXI_INI1_WRITE_QOS : public Register<0x51042104> {
            using AW_QOS = Field<0, 4>;    // Write channel QoS setting
        };

        // AXI interconnect - INI x write QoS register
        struct AXI_INI2_WRITE_QOS : public Register<0x51043104> {
            using AW_QOS = Field<0, 4>;    // Write channel QoS setting
        };

        // AXI interconnect - INI x write QoS register
        struct AXI_INI3_WRITE_QOS : public Register<0x51044104> {
            using AW_QOS = Field<0, 4>;    // Write channel QoS setting
        };

        // AXI interconnect - INI x write QoS register
        struct AXI_INI4_WRITE_QOS : public Register<0x51045104> {
            using AW_QOS = Field<0, 4>;    // Write channel QoS setting
        };

        // AXI interconnect - INI x write QoS register
        struct AXI_INI5_WRITE_QOS : public Register<0x51046104> {
            using AW_QOS = Field<0, 4>;    // Write channel QoS setting
        };

        // AXI interconnect - INI x write QoS register
        struct AXI_INI6_WRITE_QOS : public Register<0x51047104> {
            using AW_QOS = Field<0, 4>;    // Write channel QoS setting
        };

        // AXI interconnect - INI x issuing functionality modification register
        struct AXI_INI1_FN_MOD : public Register<0x51042108> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // Override ASIB read issuing capability
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // Override ASIB write issuing capability
        };

        // AXI interconnect - INI x issuing functionality modification register
        struct AXI_INI2_FN_MOD : public Register<0x51043108> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // Override ASIB read issuing capability
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // Override ASIB write issuing capability
        };

        // AXI interconnect - INI x issuing functionality modification register
        struct AXI_INI3_FN_MOD : public Register<0x51044108> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // Override ASIB read issuing capability
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // Override ASIB write issuing capability
        };

        // AXI interconnect - INI x issuing functionality modification register
        struct AXI_INI4_FN_MOD : public Register<0x51045108> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // Override ASIB read issuing capability
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // Override ASIB write issuing capability
        };

        // AXI interconnect - INI x issuing functionality modification register
        struct AXI_INI5_FN_MOD : public Register<0x51046108> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // Override ASIB read issuing capability
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // Override ASIB write issuing capability
        };

        // AXI interconnect - INI x issuing functionality modification register
        struct AXI_INI6_FN_MOD : public Register<0x51047108> {
            using READ_ISS_OVERRIDE = Field<0, 1>;    // Override ASIB read issuing capability
            using WRITE_ISS_OVERRIDE = Field<1, 1>;    // Override ASIB write issuing capability
        };

    };

    // Digital camera interface
    struct DCMI {
        // control register 1
        struct CR : public Register<0x48020000> {
            using OELS = Field<20, 1>;    // Odd/Even Line Select (Line Select Start)
            using LSM = Field<19, 1>;    // Line Select mode
            using OEBS = Field<18, 1>;    // Odd/Even Byte Select (Byte Select Start)
            using BSM = Field<16, 2>;    // Byte Select mode
            using ENABLE = Field<14, 1>;    // DCMI enable
            using EDM = Field<10, 2>;    // Extended data mode
            using FCRC = Field<8, 2>;    // Frame capture rate control
            using VSPOL = Field<7, 1>;    // Vertical synchronization polarity
            using HSPOL = Field<6, 1>;    // Horizontal synchronization polarity
            using PCKPOL = Field<5, 1>;    // Pixel clock polarity
            using ESS = Field<4, 1>;    // Embedded synchronization select
            using JPEG = Field<3, 1>;    // JPEG format
            using CROP = Field<2, 1>;    // Crop feature
            using CM = Field<1, 1>;    // Capture mode
            using CAPTURE = Field<0, 1>;    // Capture enable
        };

        // status register
        struct SR : public RegisterReadOnly<0x48020004> {
            using FNE = Field<2, 1>;    // FIFO not empty
            using VSYNC = Field<1, 1>;    // VSYNC
            using HSYNC = Field<0, 1>;    // HSYNC
        };

        // raw interrupt status register
        struct RIS : public RegisterReadOnly<0x48020008> {
            using LINE_RIS = Field<4, 1>;    // Line raw interrupt status
            using VSYNC_RIS = Field<3, 1>;    // VSYNC raw interrupt status
            using ERR_RIS = Field<2, 1>;    // Synchronization error raw interrupt status
            using OVR_RIS = Field<1, 1>;    // Overrun raw interrupt status
            using FRAME_RIS = Field<0, 1>;    // Capture complete raw interrupt status
        };

        // interrupt enable register
        struct IER : public Register<0x4802000c> {
            using LINE_IE = Field<4, 1>;    // Line interrupt enable
            using VSYNC_IE = Field<3, 1>;    // VSYNC interrupt enable
            using ERR_IE = Field<2, 1>;    // Synchronization error interrupt enable
            using OVR_IE = Field<1, 1>;    // Overrun interrupt enable
            using FRAME_IE = Field<0, 1>;    // Capture complete interrupt enable
        };

        // masked interrupt status register
        struct MIS : public RegisterReadOnly<0x48020010> {
            using LINE_MIS = Field<4, 1>;    // Line masked interrupt status
            using VSYNC_MIS = Field<3, 1>;    // VSYNC masked interrupt status
            using ERR_MIS = Field<2, 1>;    // Synchronization error masked interrupt status
            using OVR_MIS = Field<1, 1>;    // Overrun masked interrupt status
            using FRAME_MIS = Field<0, 1>;    // Capture complete masked interrupt status
        };

        // interrupt clear register
        struct ICR : public RegisterWriteOnly<0x48020014> {
            using LINE_ISC = Field<4, 1>;    // line interrupt status clear
            using VSYNC_ISC = Field<3, 1>;    // Vertical synch interrupt status clear
            using ERR_ISC = Field<2, 1>;    // Synchronization error interrupt status clear
            using OVR_ISC = Field<1, 1>;    // Overrun interrupt status clear
            using FRAME_ISC = Field<0, 1>;    // Capture complete interrupt status clear
        };

        // embedded synchronization code register
        struct ESCR : public Register<0x48020018> {
            using FEC = Field<24, 8>;    // Frame end delimiter code
            using LEC = Field<16, 8>;    // Line end delimiter code
            using LSC = Field<8, 8>;    // Line start delimiter code
            using FSC = Field<0, 8>;    // Frame start delimiter code
        };

        // embedded synchronization unmask register
        struct ESUR : public Register<0x4802001c> {
            using FEU = Field<24, 8>;    // Frame end delimiter unmask
            using LEU = Field<16, 8>;    // Line end delimiter unmask
            using LSU = Field<8, 8>;    // Line start delimiter unmask
            using FSU = Field<0, 8>;    // Frame start delimiter unmask
        };

        // crop window start
        struct CWSTRT : public Register<0x48020020> {
            using VST = Field<16, 13>;    // Vertical start line count
            using HOFFCNT = Field<0, 14>;    // Horizontal offset count
        };

        // crop window size
        struct CWSIZE : public Register<0x48020024> {
            using VLINE = Field<16, 14>;    // Vertical line count
            using CAPCNT = Field<0, 14>;    // Capture count
        };

        // data register
        struct DR : public RegisterReadOnly<0x48020028> {
            using Byte3 = Field<24, 8>;    // Data byte 3
            using Byte2 = Field<16, 8>;    // Data byte 2
            using Byte1 = Field<8, 8>;    // Data byte 1
            using Byte0 = Field<0, 8>;    // Data byte 0
        };

    };

    // USB 1 on the go high speed
    struct OTG1_HS_GLOBAL {
        // OTG_HS control and status register
        struct OTG_HS_GOTGCTL : public Register<0x40040000> {
            using SRQSCS = Field<0, 1>;    // Session request success
            using SRQ = Field<1, 1>;    // Session request
            using HNGSCS = Field<8, 1>;    // Host negotiation success
            using HNPRQ = Field<9, 1>;    // HNP request
            using HSHNPEN = Field<10, 1>;    // Host set HNP enable
            using DHNPEN = Field<11, 1>;    // Device HNP enabled
            using CIDSTS = Field<16, 1>;    // Connector ID status
            using DBCT = Field<17, 1>;    // Long/short debounce time
            using ASVLD = Field<18, 1>;    // A-session valid
            using BSVLD = Field<19, 1>;    // B-session valid
            using EHEN = Field<12, 1>;    // Embedded host enable
        };

        // OTG_HS interrupt register
        struct OTG_HS_GOTGINT : public Register<0x40040004> {
            using SEDET = Field<2, 1>;    // Session end detected
            using SRSSCHG = Field<8, 1>;    // Session request success status change
            using HNSSCHG = Field<9, 1>;    // Host negotiation success status change
            using HNGDET = Field<17, 1>;    // Host negotiation detected
            using ADTOCHG = Field<18, 1>;    // A-device timeout change
            using DBCDNE = Field<19, 1>;    // Debounce done
            using IDCHNG = Field<20, 1>;    // ID input pin changed
        };

        // OTG_HS AHB configuration register
        struct OTG_HS_GAHBCFG : public Register<0x40040008> {
            using GINT = Field<0, 1>;    // Global interrupt mask
            using HBSTLEN = Field<1, 4>;    // Burst length/type
            using DMAEN = Field<5, 1>;    // DMA enable
            using TXFELVL = Field<7, 1>;    // TxFIFO empty level
            using PTXFELVL = Field<8, 1>;    // Periodic TxFIFO empty level
        };

        // OTG_HS USB configuration register
        struct OTG_HS_GUSBCFG : public Register<0x4004000c> {
            using TOCAL = Field<0, 3>;    // FS timeout calibration
            using PHYSEL = Field<6, 1>;    // USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select
            using SRPCAP = Field<8, 1>;    // SRP-capable
            using HNPCAP = Field<9, 1>;    // HNP-capable
            using TRDT = Field<10, 4>;    // USB turnaround time
            using PHYLPCS = Field<15, 1>;    // PHY Low-power clock select
            using ULPIFSLS = Field<17, 1>;    // ULPI FS/LS select
            using ULPIAR = Field<18, 1>;    // ULPI Auto-resume
            using ULPICSM = Field<19, 1>;    // ULPI Clock SuspendM
            using ULPIEVBUSD = Field<20, 1>;    // ULPI External VBUS Drive
            using ULPIEVBUSI = Field<21, 1>;    // ULPI external VBUS indicator
            using TSDPS = Field<22, 1>;    // TermSel DLine pulsing selection
            using PCCI = Field<23, 1>;    // Indicator complement
            using PTCI = Field<24, 1>;    // Indicator pass through
            using ULPIIPD = Field<25, 1>;    // ULPI interface protect disable
            using FHMOD = Field<29, 1>;    // Forced host mode
            using FDMOD = Field<30, 1>;    // Forced peripheral mode
        };

        // OTG_HS reset register
        struct OTG_HS_GRSTCTL : public Register<0x40040010> {
            using CSRST = Field<0, 1>;    // Core soft reset
            using HSRST = Field<1, 1>;    // HCLK soft reset
            using FCRST = Field<2, 1>;    // Host frame counter reset
            using RXFFLSH = Field<4, 1>;    // RxFIFO flush
            using TXFFLSH = Field<5, 1>;    // TxFIFO flush
            using TXFNUM = Field<6, 5>;    // TxFIFO number
            using AHBIDL = Field<31, 1>;    // AHB master idle
            using DMAREQ = Field<30, 1>;    // DMA request signal enabled for USB OTG HS
        };

        // OTG_HS core interrupt register
        struct OTG_HS_GINTSTS : public Register<0x40040014> {
            using CMOD = Field<0, 1>;    // Current mode of operation
            using MMIS = Field<1, 1>;    // Mode mismatch interrupt
            using OTGINT = Field<2, 1>;    // OTG interrupt
            using SOF = Field<3, 1>;    // Start of frame
            using RXFLVL = Field<4, 1>;    // RxFIFO nonempty
            using NPTXFE = Field<5, 1>;    // Nonperiodic TxFIFO empty
            using GINAKEFF = Field<6, 1>;    // Global IN nonperiodic NAK effective
            using BOUTNAKEFF = Field<7, 1>;    // Global OUT NAK effective
            using ESUSP = Field<10, 1>;    // Early suspend
            using USBSUSP = Field<11, 1>;    // USB suspend
            using USBRST = Field<12, 1>;    // USB reset
            using ENUMDNE = Field<13, 1>;    // Enumeration done
            using ISOODRP = Field<14, 1>;    // Isochronous OUT packet dropped interrupt
            using EOPF = Field<15, 1>;    // End of periodic frame interrupt
            using IEPINT = Field<18, 1>;    // IN endpoint interrupt
            using OEPINT = Field<19, 1>;    // OUT endpoint interrupt
            using IISOIXFR = Field<20, 1>;    // Incomplete isochronous IN transfer
            using PXFR_INCOMPISOOUT = Field<21, 1>;    // Incomplete periodic transfer
            using DATAFSUSP = Field<22, 1>;    // Data fetch suspended
            using HPRTINT = Field<24, 1>;    // Host port interrupt
            using HCINT = Field<25, 1>;    // Host channels interrupt
            using PTXFE = Field<26, 1>;    // Periodic TxFIFO empty
            using CIDSCHG = Field<28, 1>;    // Connector ID status change
            using DISCINT = Field<29, 1>;    // Disconnect detected interrupt
            using SRQINT = Field<30, 1>;    // Session request/new session detected interrupt
            using WKUINT = Field<31, 1>;    // Resume/remote wakeup detected interrupt
        };

        // OTG_HS interrupt mask register
        struct OTG_HS_GINTMSK : public Register<0x40040018> {
            using MMISM = Field<1, 1>;    // Mode mismatch interrupt mask
            using OTGINT = Field<2, 1>;    // OTG interrupt mask
            using SOFM = Field<3, 1>;    // Start of frame mask
            using RXFLVLM = Field<4, 1>;    // Receive FIFO nonempty mask
            using NPTXFEM = Field<5, 1>;    // Nonperiodic TxFIFO empty mask
            using GINAKEFFM = Field<6, 1>;    // Global nonperiodic IN NAK effective mask
            using GONAKEFFM = Field<7, 1>;    // Global OUT NAK effective mask
            using ESUSPM = Field<10, 1>;    // Early suspend mask
            using USBSUSPM = Field<11, 1>;    // USB suspend mask
            using USBRST = Field<12, 1>;    // USB reset mask
            using ENUMDNEM = Field<13, 1>;    // Enumeration done mask
            using ISOODRPM = Field<14, 1>;    // Isochronous OUT packet dropped interrupt mask
            using EOPFM = Field<15, 1>;    // End of periodic frame interrupt mask
            using IEPINT = Field<18, 1>;    // IN endpoints interrupt mask
            using OEPINT = Field<19, 1>;    // OUT endpoints interrupt mask
            using IISOIXFRM = Field<20, 1>;    // Incomplete isochronous IN transfer mask
            using PXFRM_IISOOXFRM = Field<21, 1>;    // Incomplete periodic transfer mask
            using FSUSPM = Field<22, 1>;    // Data fetch suspended mask
            using PRTIM = Field<24, 1>;    // Host port interrupt mask
            using HCIM = Field<25, 1>;    // Host channels interrupt mask
            using PTXFEM = Field<26, 1>;    // Periodic TxFIFO empty mask
            using CIDSCHGM = Field<28, 1>;    // Connector ID status change mask
            using DISCINT = Field<29, 1>;    // Disconnect detected interrupt mask
            using SRQIM = Field<30, 1>;    // Session request/new session detected interrupt mask
            using WUIM = Field<31, 1>;    // Resume/remote wakeup detected interrupt mask
            using RSTDE = Field<23, 1>;    // Reset detected interrupt mask
            using LPMINTM = Field<27, 1>;    // LPM interrupt mask
        };

        // OTG_HS Receive status debug read register (host mode)
        struct OTG_HS_GRXSTSR_Host : public RegisterReadOnly<0x4004001c> {
            using CHNUM = Field<0, 4>;    // Channel number
            using BCNT = Field<4, 11>;    // Byte count
            using DPID = Field<15, 2>;    // Data PID
            using PKTSTS = Field<17, 4>;    // Packet status
        };

        // OTG_HS status read and pop register (host mode)
        struct OTG_HS_GRXSTSP_Host : public RegisterReadOnly<0x40040020> {
            using CHNUM = Field<0, 4>;    // Channel number
            using BCNT = Field<4, 11>;    // Byte count
            using DPID = Field<15, 2>;    // Data PID
            using PKTSTS = Field<17, 4>;    // Packet status
        };

        // OTG_HS Receive FIFO size register
        struct OTG_HS_GRXFSIZ : public Register<0x40040024> {
            using RXFD = Field<0, 16>;    // RxFIFO depth
        };

        // OTG_HS nonperiodic transmit FIFO size register (host mode)
        struct OTG_HS_HNPTXFSIZ_Host : public Register<0x40040028> {
            using NPTXFSA = Field<0, 16>;    // Nonperiodic transmit RAM start address
            using NPTXFD = Field<16, 16>;    // Nonperiodic TxFIFO depth
        };

        // Endpoint 0 transmit FIFO size (peripheral mode)
        struct OTG_HS_DIEPTXF0_Device : public Register<0x40040028> {
            using TX0FSA = Field<0, 16>;    // Endpoint 0 transmit RAM start address
            using TX0FD = Field<16, 16>;    // Endpoint 0 TxFIFO depth
        };

        // OTG_HS nonperiodic transmit FIFO/queue status register
        struct OTG_HS_GNPTXSTS : public RegisterReadOnly<0x4004002c> {
            using NPTXFSAV = Field<0, 16>;    // Nonperiodic TxFIFO space available
            using NPTQXSAV = Field<16, 8>;    // Nonperiodic transmit request queue space available
            using NPTXQTOP = Field<24, 7>;    // Top of the nonperiodic transmit request queue
        };

        // OTG_HS general core configuration register
        struct OTG_HS_GCCFG : public Register<0x40040038> {
            using PWRDWN = Field<16, 1>;    // Power down
            using BCDEN = Field<17, 1>;    // Battery charging detector (BCD) enable
            using DCDEN = Field<18, 1>;    // Data contact detection (DCD) mode enable
            using PDEN = Field<19, 1>;    // Primary detection (PD) mode enable
            using SDEN = Field<20, 1>;    // Secondary detection (SD) mode enable
            using VBDEN = Field<21, 1>;    // USB VBUS detection enable
            using DCDET = Field<0, 1>;    // Data contact detection (DCD) status
            using PDET = Field<1, 1>;    // Primary detection (PD) status
            using SDET = Field<2, 1>;    // Secondary detection (SD) status
            using PS2DET = Field<3, 1>;    // DM pull-up detection status
        };

        // OTG_HS core ID register
        struct OTG_HS_CID : public Register<0x4004003c> {
            using PRODUCT_ID = Field<0, 32>;    // Product ID field
        };

        // OTG_HS Host periodic transmit FIFO size register
        struct OTG_HS_HPTXFSIZ : public Register<0x40040100> {
            using PTXSA = Field<0, 16>;    // Host periodic TxFIFO start address
            using PTXFD = Field<16, 16>;    // Host periodic TxFIFO depth
        };

        // OTG_HS device IN endpoint transmit FIFO size register
        struct OTG_HS_DIEPTXF1 : public Register<0x40040104> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFOx transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_HS device IN endpoint transmit FIFO size register
        struct OTG_HS_DIEPTXF2 : public Register<0x40040108> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFOx transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_HS device IN endpoint transmit FIFO size register
        struct OTG_HS_DIEPTXF3 : public Register<0x4004011c> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFOx transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_HS device IN endpoint transmit FIFO size register
        struct OTG_HS_DIEPTXF4 : public Register<0x40040120> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFOx transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_HS device IN endpoint transmit FIFO size register
        struct OTG_HS_DIEPTXF5 : public Register<0x40040124> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFOx transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_HS device IN endpoint transmit FIFO size register
        struct OTG_HS_DIEPTXF6 : public Register<0x40040128> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFOx transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_HS device IN endpoint transmit FIFO size register
        struct OTG_HS_DIEPTXF7 : public Register<0x4004012c> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFOx transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_HS Receive status debug read register (peripheral mode mode)
        struct OTG_HS_GRXSTSR_Device : public RegisterReadOnly<0x4004001c> {
            using EPNUM = Field<0, 4>;    // Endpoint number
            using BCNT = Field<4, 11>;    // Byte count
            using DPID = Field<15, 2>;    // Data PID
            using PKTSTS = Field<17, 4>;    // Packet status
            using FRMNUM = Field<21, 4>;    // Frame number
        };

        // OTG_HS status read and pop register (peripheral mode)
        struct OTG_HS_GRXSTSP_Device : public RegisterReadOnly<0x40040020> {
            using EPNUM = Field<0, 4>;    // Endpoint number
            using BCNT = Field<4, 11>;    // Byte count
            using DPID = Field<15, 2>;    // Data PID
            using PKTSTS = Field<17, 4>;    // Packet status
            using FRMNUM = Field<21, 4>;    // Frame number
        };

        // OTG core LPM configuration register
        struct OTG_HS_GLPMCFG : public Register<0x40040054> {
            using LPMEN = Field<0, 1>;    // LPM support enable
            using LPMACK = Field<1, 1>;    // LPM token acknowledge enable
            using BESL = Field<2, 4>;    // Best effort service latency
            using REMWAKE = Field<6, 1>;    // bRemoteWake value
            using L1SSEN = Field<7, 1>;    // L1 Shallow Sleep enable
            using BESLTHRS = Field<8, 4>;    // BESL threshold
            using L1DSEN = Field<12, 1>;    // L1 deep sleep enable
            using LPMRST = Field<13, 2>;    // LPM response
            using SLPSTS = Field<15, 1>;    // Port sleep status
            using L1RSMOK = Field<16, 1>;    // Sleep State Resume OK
            using LPMCHIDX = Field<17, 4>;    // LPM Channel Index
            using LPMRCNT = Field<21, 3>;    // LPM retry count
            using SNDLPM = Field<24, 1>;    // Send LPM transaction
            using LPMRCNTSTS = Field<25, 3>;    // LPM retry count status
            using ENBESL = Field<28, 1>;    // Enable best effort service latency
        };

    };

    // USB 1 on the go high speed
    struct OTG2_HS_GLOBAL {
        // OTG_HS control and status register
        struct OTG_HS_GOTGCTL : public Register<0x40080000> {
            using SRQSCS = Field<0, 1>;    // Session request success
            using SRQ = Field<1, 1>;    // Session request
            using HNGSCS = Field<8, 1>;    // Host negotiation success
            using HNPRQ = Field<9, 1>;    // HNP request
            using HSHNPEN = Field<10, 1>;    // Host set HNP enable
            using DHNPEN = Field<11, 1>;    // Device HNP enabled
            using CIDSTS = Field<16, 1>;    // Connector ID status
            using DBCT = Field<17, 1>;    // Long/short debounce time
            using ASVLD = Field<18, 1>;    // A-session valid
            using BSVLD = Field<19, 1>;    // B-session valid
            using EHEN = Field<12, 1>;    // Embedded host enable
        };

        // OTG_HS interrupt register
        struct OTG_HS_GOTGINT : public Register<0x40080004> {
            using SEDET = Field<2, 1>;    // Session end detected
            using SRSSCHG = Field<8, 1>;    // Session request success status change
            using HNSSCHG = Field<9, 1>;    // Host negotiation success status change
            using HNGDET = Field<17, 1>;    // Host negotiation detected
            using ADTOCHG = Field<18, 1>;    // A-device timeout change
            using DBCDNE = Field<19, 1>;    // Debounce done
            using IDCHNG = Field<20, 1>;    // ID input pin changed
        };

        // OTG_HS AHB configuration register
        struct OTG_HS_GAHBCFG : public Register<0x40080008> {
            using GINT = Field<0, 1>;    // Global interrupt mask
            using HBSTLEN = Field<1, 4>;    // Burst length/type
            using DMAEN = Field<5, 1>;    // DMA enable
            using TXFELVL = Field<7, 1>;    // TxFIFO empty level
            using PTXFELVL = Field<8, 1>;    // Periodic TxFIFO empty level
        };

        // OTG_HS USB configuration register
        struct OTG_HS_GUSBCFG : public Register<0x4008000c> {
            using TOCAL = Field<0, 3>;    // FS timeout calibration
            using PHYSEL = Field<6, 1>;    // USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select
            using SRPCAP = Field<8, 1>;    // SRP-capable
            using HNPCAP = Field<9, 1>;    // HNP-capable
            using TRDT = Field<10, 4>;    // USB turnaround time
            using PHYLPCS = Field<15, 1>;    // PHY Low-power clock select
            using ULPIFSLS = Field<17, 1>;    // ULPI FS/LS select
            using ULPIAR = Field<18, 1>;    // ULPI Auto-resume
            using ULPICSM = Field<19, 1>;    // ULPI Clock SuspendM
            using ULPIEVBUSD = Field<20, 1>;    // ULPI External VBUS Drive
            using ULPIEVBUSI = Field<21, 1>;    // ULPI external VBUS indicator
            using TSDPS = Field<22, 1>;    // TermSel DLine pulsing selection
            using PCCI = Field<23, 1>;    // Indicator complement
            using PTCI = Field<24, 1>;    // Indicator pass through
            using ULPIIPD = Field<25, 1>;    // ULPI interface protect disable
            using FHMOD = Field<29, 1>;    // Forced host mode
            using FDMOD = Field<30, 1>;    // Forced peripheral mode
        };

        // OTG_HS reset register
        struct OTG_HS_GRSTCTL : public Register<0x40080010> {
            using CSRST = Field<0, 1>;    // Core soft reset
            using HSRST = Field<1, 1>;    // HCLK soft reset
            using FCRST = Field<2, 1>;    // Host frame counter reset
            using RXFFLSH = Field<4, 1>;    // RxFIFO flush
            using TXFFLSH = Field<5, 1>;    // TxFIFO flush
            using TXFNUM = Field<6, 5>;    // TxFIFO number
            using AHBIDL = Field<31, 1>;    // AHB master idle
            using DMAREQ = Field<30, 1>;    // DMA request signal enabled for USB OTG HS
        };

        // OTG_HS core interrupt register
        struct OTG_HS_GINTSTS : public Register<0x40080014> {
            using CMOD = Field<0, 1>;    // Current mode of operation
            using MMIS = Field<1, 1>;    // Mode mismatch interrupt
            using OTGINT = Field<2, 1>;    // OTG interrupt
            using SOF = Field<3, 1>;    // Start of frame
            using RXFLVL = Field<4, 1>;    // RxFIFO nonempty
            using NPTXFE = Field<5, 1>;    // Nonperiodic TxFIFO empty
            using GINAKEFF = Field<6, 1>;    // Global IN nonperiodic NAK effective
            using BOUTNAKEFF = Field<7, 1>;    // Global OUT NAK effective
            using ESUSP = Field<10, 1>;    // Early suspend
            using USBSUSP = Field<11, 1>;    // USB suspend
            using USBRST = Field<12, 1>;    // USB reset
            using ENUMDNE = Field<13, 1>;    // Enumeration done
            using ISOODRP = Field<14, 1>;    // Isochronous OUT packet dropped interrupt
            using EOPF = Field<15, 1>;    // End of periodic frame interrupt
            using IEPINT = Field<18, 1>;    // IN endpoint interrupt
            using OEPINT = Field<19, 1>;    // OUT endpoint interrupt
            using IISOIXFR = Field<20, 1>;    // Incomplete isochronous IN transfer
            using PXFR_INCOMPISOOUT = Field<21, 1>;    // Incomplete periodic transfer
            using DATAFSUSP = Field<22, 1>;    // Data fetch suspended
            using HPRTINT = Field<24, 1>;    // Host port interrupt
            using HCINT = Field<25, 1>;    // Host channels interrupt
            using PTXFE = Field<26, 1>;    // Periodic TxFIFO empty
            using CIDSCHG = Field<28, 1>;    // Connector ID status change
            using DISCINT = Field<29, 1>;    // Disconnect detected interrupt
            using SRQINT = Field<30, 1>;    // Session request/new session detected interrupt
            using WKUINT = Field<31, 1>;    // Resume/remote wakeup detected interrupt
        };

        // OTG_HS interrupt mask register
        struct OTG_HS_GINTMSK : public Register<0x40080018> {
            using MMISM = Field<1, 1>;    // Mode mismatch interrupt mask
            using OTGINT = Field<2, 1>;    // OTG interrupt mask
            using SOFM = Field<3, 1>;    // Start of frame mask
            using RXFLVLM = Field<4, 1>;    // Receive FIFO nonempty mask
            using NPTXFEM = Field<5, 1>;    // Nonperiodic TxFIFO empty mask
            using GINAKEFFM = Field<6, 1>;    // Global nonperiodic IN NAK effective mask
            using GONAKEFFM = Field<7, 1>;    // Global OUT NAK effective mask
            using ESUSPM = Field<10, 1>;    // Early suspend mask
            using USBSUSPM = Field<11, 1>;    // USB suspend mask
            using USBRST = Field<12, 1>;    // USB reset mask
            using ENUMDNEM = Field<13, 1>;    // Enumeration done mask
            using ISOODRPM = Field<14, 1>;    // Isochronous OUT packet dropped interrupt mask
            using EOPFM = Field<15, 1>;    // End of periodic frame interrupt mask
            using IEPINT = Field<18, 1>;    // IN endpoints interrupt mask
            using OEPINT = Field<19, 1>;    // OUT endpoints interrupt mask
            using IISOIXFRM = Field<20, 1>;    // Incomplete isochronous IN transfer mask
            using PXFRM_IISOOXFRM = Field<21, 1>;    // Incomplete periodic transfer mask
            using FSUSPM = Field<22, 1>;    // Data fetch suspended mask
            using PRTIM = Field<24, 1>;    // Host port interrupt mask
            using HCIM = Field<25, 1>;    // Host channels interrupt mask
            using PTXFEM = Field<26, 1>;    // Periodic TxFIFO empty mask
            using CIDSCHGM = Field<28, 1>;    // Connector ID status change mask
            using DISCINT = Field<29, 1>;    // Disconnect detected interrupt mask
            using SRQIM = Field<30, 1>;    // Session request/new session detected interrupt mask
            using WUIM = Field<31, 1>;    // Resume/remote wakeup detected interrupt mask
            using RSTDE = Field<23, 1>;    // Reset detected interrupt mask
            using LPMINTM = Field<27, 1>;    // LPM interrupt mask
        };

        // OTG_HS Receive status debug read register (host mode)
        struct OTG_HS_GRXSTSR_Host : public RegisterReadOnly<0x4008001c> {
            using CHNUM = Field<0, 4>;    // Channel number
            using BCNT = Field<4, 11>;    // Byte count
            using DPID = Field<15, 2>;    // Data PID
            using PKTSTS = Field<17, 4>;    // Packet status
        };

        // OTG_HS status read and pop register (host mode)
        struct OTG_HS_GRXSTSP_Host : public RegisterReadOnly<0x40080020> {
            using CHNUM = Field<0, 4>;    // Channel number
            using BCNT = Field<4, 11>;    // Byte count
            using DPID = Field<15, 2>;    // Data PID
            using PKTSTS = Field<17, 4>;    // Packet status
        };

        // OTG_HS Receive FIFO size register
        struct OTG_HS_GRXFSIZ : public Register<0x40080024> {
            using RXFD = Field<0, 16>;    // RxFIFO depth
        };

        // OTG_HS nonperiodic transmit FIFO size register (host mode)
        struct OTG_HS_HNPTXFSIZ_Host : public Register<0x40080028> {
            using NPTXFSA = Field<0, 16>;    // Nonperiodic transmit RAM start address
            using NPTXFD = Field<16, 16>;    // Nonperiodic TxFIFO depth
        };

        // Endpoint 0 transmit FIFO size (peripheral mode)
        struct OTG_HS_DIEPTXF0_Device : public Register<0x40080028> {
            using TX0FSA = Field<0, 16>;    // Endpoint 0 transmit RAM start address
            using TX0FD = Field<16, 16>;    // Endpoint 0 TxFIFO depth
        };

        // OTG_HS nonperiodic transmit FIFO/queue status register
        struct OTG_HS_GNPTXSTS : public RegisterReadOnly<0x4008002c> {
            using NPTXFSAV = Field<0, 16>;    // Nonperiodic TxFIFO space available
            using NPTQXSAV = Field<16, 8>;    // Nonperiodic transmit request queue space available
            using NPTXQTOP = Field<24, 7>;    // Top of the nonperiodic transmit request queue
        };

        // OTG_HS general core configuration register
        struct OTG_HS_GCCFG : public Register<0x40080038> {
            using PWRDWN = Field<16, 1>;    // Power down
            using BCDEN = Field<17, 1>;    // Battery charging detector (BCD) enable
            using DCDEN = Field<18, 1>;    // Data contact detection (DCD) mode enable
            using PDEN = Field<19, 1>;    // Primary detection (PD) mode enable
            using SDEN = Field<20, 1>;    // Secondary detection (SD) mode enable
            using VBDEN = Field<21, 1>;    // USB VBUS detection enable
            using DCDET = Field<0, 1>;    // Data contact detection (DCD) status
            using PDET = Field<1, 1>;    // Primary detection (PD) status
            using SDET = Field<2, 1>;    // Secondary detection (SD) status
            using PS2DET = Field<3, 1>;    // DM pull-up detection status
        };

        // OTG_HS core ID register
        struct OTG_HS_CID : public Register<0x4008003c> {
            using PRODUCT_ID = Field<0, 32>;    // Product ID field
        };

        // OTG_HS Host periodic transmit FIFO size register
        struct OTG_HS_HPTXFSIZ : public Register<0x40080100> {
            using PTXSA = Field<0, 16>;    // Host periodic TxFIFO start address
            using PTXFD = Field<16, 16>;    // Host periodic TxFIFO depth
        };

        // OTG_HS device IN endpoint transmit FIFO size register
        struct OTG_HS_DIEPTXF1 : public Register<0x40080104> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFOx transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_HS device IN endpoint transmit FIFO size register
        struct OTG_HS_DIEPTXF2 : public Register<0x40080108> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFOx transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_HS device IN endpoint transmit FIFO size register
        struct OTG_HS_DIEPTXF3 : public Register<0x4008011c> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFOx transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_HS device IN endpoint transmit FIFO size register
        struct OTG_HS_DIEPTXF4 : public Register<0x40080120> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFOx transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_HS device IN endpoint transmit FIFO size register
        struct OTG_HS_DIEPTXF5 : public Register<0x40080124> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFOx transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_HS device IN endpoint transmit FIFO size register
        struct OTG_HS_DIEPTXF6 : public Register<0x40080128> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFOx transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_HS device IN endpoint transmit FIFO size register
        struct OTG_HS_DIEPTXF7 : public Register<0x4008012c> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFOx transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_HS Receive status debug read register (peripheral mode mode)
        struct OTG_HS_GRXSTSR_Device : public RegisterReadOnly<0x4008001c> {
            using EPNUM = Field<0, 4>;    // Endpoint number
            using BCNT = Field<4, 11>;    // Byte count
            using DPID = Field<15, 2>;    // Data PID
            using PKTSTS = Field<17, 4>;    // Packet status
            using FRMNUM = Field<21, 4>;    // Frame number
        };

        // OTG_HS status read and pop register (peripheral mode)
        struct OTG_HS_GRXSTSP_Device : public RegisterReadOnly<0x40080020> {
            using EPNUM = Field<0, 4>;    // Endpoint number
            using BCNT = Field<4, 11>;    // Byte count
            using DPID = Field<15, 2>;    // Data PID
            using PKTSTS = Field<17, 4>;    // Packet status
            using FRMNUM = Field<21, 4>;    // Frame number
        };

        // OTG core LPM configuration register
        struct OTG_HS_GLPMCFG : public Register<0x40080054> {
            using LPMEN = Field<0, 1>;    // LPM support enable
            using LPMACK = Field<1, 1>;    // LPM token acknowledge enable
            using BESL = Field<2, 4>;    // Best effort service latency
            using REMWAKE = Field<6, 1>;    // bRemoteWake value
            using L1SSEN = Field<7, 1>;    // L1 Shallow Sleep enable
            using BESLTHRS = Field<8, 4>;    // BESL threshold
            using L1DSEN = Field<12, 1>;    // L1 deep sleep enable
            using LPMRST = Field<13, 2>;    // LPM response
            using SLPSTS = Field<15, 1>;    // Port sleep status
            using L1RSMOK = Field<16, 1>;    // Sleep State Resume OK
            using LPMCHIDX = Field<17, 4>;    // LPM Channel Index
            using LPMRCNT = Field<21, 3>;    // LPM retry count
            using SNDLPM = Field<24, 1>;    // Send LPM transaction
            using LPMRCNTSTS = Field<25, 3>;    // LPM retry count status
            using ENBESL = Field<28, 1>;    // Enable best effort service latency
        };

    };

    // USB 1 on the go high speed
    struct OTG1_HS_HOST {
        // OTG_HS host configuration register
        struct OTG_HS_HCFG : public Register<0x40040400> {
            using FSLSPCS = Field<0, 2>;    // FS/LS PHY clock select
            using FSLSS = Field<2, 1>;    // FS- and LS-only support
        };

        // OTG_HS Host frame interval register
        struct OTG_HS_HFIR : public Register<0x40040404> {
            using FRIVL = Field<0, 16>;    // Frame interval
        };

        // OTG_HS host frame number/frame time remaining register
        struct OTG_HS_HFNUM : public RegisterReadOnly<0x40040408> {
            using FRNUM = Field<0, 16>;    // Frame number
            using FTREM = Field<16, 16>;    // Frame time remaining
        };

        // OTG_HS_Host periodic transmit FIFO/queue status register
        struct OTG_HS_HPTXSTS : public Register<0x40040410> {
            using PTXFSAVL = Field<0, 16>;    // Periodic transmit data FIFO space available
            using PTXQSAV = Field<16, 8>;    // Periodic transmit request queue space available
            using PTXQTOP = Field<24, 8>;    // Top of the periodic transmit request queue
        };

        // OTG_HS Host all channels interrupt register
        struct OTG_HS_HAINT : public RegisterReadOnly<0x40040414> {
            using HAINT = Field<0, 16>;    // Channel interrupts
        };

        // OTG_HS host all channels interrupt mask register
        struct OTG_HS_HAINTMSK : public Register<0x40040418> {
            using HAINTM = Field<0, 16>;    // Channel interrupt mask
        };

        // OTG_HS host port control and status register
        struct OTG_HS_HPRT : public Register<0x40040440> {
            using PCSTS = Field<0, 1>;    // Port connect status
            using PCDET = Field<1, 1>;    // Port connect detected
            using PENA = Field<2, 1>;    // Port enable
            using PENCHNG = Field<3, 1>;    // Port enable/disable change
            using POCA = Field<4, 1>;    // Port overcurrent active
            using POCCHNG = Field<5, 1>;    // Port overcurrent change
            using PRES = Field<6, 1>;    // Port resume
            using PSUSP = Field<7, 1>;    // Port suspend
            using PRST = Field<8, 1>;    // Port reset
            using PLSTS = Field<10, 2>;    // Port line status
            using PPWR = Field<12, 1>;    // Port power
            using PTCTL = Field<13, 4>;    // Port test control
            using PSPD = Field<17, 2>;    // Port speed
        };

        // OTG_HS host channel-0 characteristics register
        struct OTG_HS_HCCHAR0 : public Register<0x40040500> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-1 characteristics register
        struct OTG_HS_HCCHAR1 : public Register<0x40040520> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-2 characteristics register
        struct OTG_HS_HCCHAR2 : public Register<0x40040540> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-3 characteristics register
        struct OTG_HS_HCCHAR3 : public Register<0x40040560> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-4 characteristics register
        struct OTG_HS_HCCHAR4 : public Register<0x40040580> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-5 characteristics register
        struct OTG_HS_HCCHAR5 : public Register<0x400405a0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-6 characteristics register
        struct OTG_HS_HCCHAR6 : public Register<0x400405c0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-7 characteristics register
        struct OTG_HS_HCCHAR7 : public Register<0x400405e0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-8 characteristics register
        struct OTG_HS_HCCHAR8 : public Register<0x40040600> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-9 characteristics register
        struct OTG_HS_HCCHAR9 : public Register<0x40040620> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-10 characteristics register
        struct OTG_HS_HCCHAR10 : public Register<0x40040640> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-11 characteristics register
        struct OTG_HS_HCCHAR11 : public Register<0x40040660> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-0 split control register
        struct OTG_HS_HCSPLT0 : public Register<0x40040504> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-1 split control register
        struct OTG_HS_HCSPLT1 : public Register<0x40040524> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-2 split control register
        struct OTG_HS_HCSPLT2 : public Register<0x40040544> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-3 split control register
        struct OTG_HS_HCSPLT3 : public Register<0x40040564> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-4 split control register
        struct OTG_HS_HCSPLT4 : public Register<0x40040584> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-5 split control register
        struct OTG_HS_HCSPLT5 : public Register<0x400405a4> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-6 split control register
        struct OTG_HS_HCSPLT6 : public Register<0x400405c4> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-7 split control register
        struct OTG_HS_HCSPLT7 : public Register<0x400405e4> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-8 split control register
        struct OTG_HS_HCSPLT8 : public Register<0x40040604> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-9 split control register
        struct OTG_HS_HCSPLT9 : public Register<0x40040624> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-10 split control register
        struct OTG_HS_HCSPLT10 : public Register<0x40040644> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-11 split control register
        struct OTG_HS_HCSPLT11 : public Register<0x40040664> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-11 interrupt register
        struct OTG_HS_HCINT0 : public Register<0x40040508> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-1 interrupt register
        struct OTG_HS_HCINT1 : public Register<0x40040528> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-2 interrupt register
        struct OTG_HS_HCINT2 : public Register<0x40040548> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-3 interrupt register
        struct OTG_HS_HCINT3 : public Register<0x40040568> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-4 interrupt register
        struct OTG_HS_HCINT4 : public Register<0x40040588> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-5 interrupt register
        struct OTG_HS_HCINT5 : public Register<0x400405a8> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-6 interrupt register
        struct OTG_HS_HCINT6 : public Register<0x400405c8> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-7 interrupt register
        struct OTG_HS_HCINT7 : public Register<0x400405e8> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-8 interrupt register
        struct OTG_HS_HCINT8 : public Register<0x40040608> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-9 interrupt register
        struct OTG_HS_HCINT9 : public Register<0x40040628> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-10 interrupt register
        struct OTG_HS_HCINT10 : public Register<0x40040648> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-11 interrupt register
        struct OTG_HS_HCINT11 : public Register<0x40040668> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-11 interrupt mask register
        struct OTG_HS_HCINTMSK0 : public Register<0x4004050c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-1 interrupt mask register
        struct OTG_HS_HCINTMSK1 : public Register<0x4004052c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-2 interrupt mask register
        struct OTG_HS_HCINTMSK2 : public Register<0x4004054c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-3 interrupt mask register
        struct OTG_HS_HCINTMSK3 : public Register<0x4004056c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-4 interrupt mask register
        struct OTG_HS_HCINTMSK4 : public Register<0x4004058c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-5 interrupt mask register
        struct OTG_HS_HCINTMSK5 : public Register<0x400405ac> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-6 interrupt mask register
        struct OTG_HS_HCINTMSK6 : public Register<0x400405cc> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-7 interrupt mask register
        struct OTG_HS_HCINTMSK7 : public Register<0x400405ec> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-8 interrupt mask register
        struct OTG_HS_HCINTMSK8 : public Register<0x4004060c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-9 interrupt mask register
        struct OTG_HS_HCINTMSK9 : public Register<0x4004062c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-10 interrupt mask register
        struct OTG_HS_HCINTMSK10 : public Register<0x4004064c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-11 interrupt mask register
        struct OTG_HS_HCINTMSK11 : public Register<0x4004066c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-11 transfer size register
        struct OTG_HS_HCTSIZ0 : public Register<0x40040510> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-1 transfer size register
        struct OTG_HS_HCTSIZ1 : public Register<0x40040530> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-2 transfer size register
        struct OTG_HS_HCTSIZ2 : public Register<0x40040550> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-3 transfer size register
        struct OTG_HS_HCTSIZ3 : public Register<0x40040570> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-4 transfer size register
        struct OTG_HS_HCTSIZ4 : public Register<0x40040590> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-5 transfer size register
        struct OTG_HS_HCTSIZ5 : public Register<0x400405b0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-6 transfer size register
        struct OTG_HS_HCTSIZ6 : public Register<0x400405d0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-7 transfer size register
        struct OTG_HS_HCTSIZ7 : public Register<0x400405f0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-8 transfer size register
        struct OTG_HS_HCTSIZ8 : public Register<0x40040610> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-9 transfer size register
        struct OTG_HS_HCTSIZ9 : public Register<0x40040630> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-10 transfer size register
        struct OTG_HS_HCTSIZ10 : public Register<0x40040650> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-11 transfer size register
        struct OTG_HS_HCTSIZ11 : public Register<0x40040670> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-0 DMA address register
        struct OTG_HS_HCDMA0 : public Register<0x40040514> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-1 DMA address register
        struct OTG_HS_HCDMA1 : public Register<0x40040534> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-2 DMA address register
        struct OTG_HS_HCDMA2 : public Register<0x40040554> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-3 DMA address register
        struct OTG_HS_HCDMA3 : public Register<0x40040574> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-4 DMA address register
        struct OTG_HS_HCDMA4 : public Register<0x40040594> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-5 DMA address register
        struct OTG_HS_HCDMA5 : public Register<0x400405b4> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-6 DMA address register
        struct OTG_HS_HCDMA6 : public Register<0x400405d4> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-7 DMA address register
        struct OTG_HS_HCDMA7 : public Register<0x400405f4> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-8 DMA address register
        struct OTG_HS_HCDMA8 : public Register<0x40040614> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-9 DMA address register
        struct OTG_HS_HCDMA9 : public Register<0x40040634> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-10 DMA address register
        struct OTG_HS_HCDMA10 : public Register<0x40040654> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-11 DMA address register
        struct OTG_HS_HCDMA11 : public Register<0x40040674> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-12 characteristics register
        struct OTG_HS_HCCHAR12 : public Register<0x40040678> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-12 split control register
        struct OTG_HS_HCSPLT12 : public Register<0x4004067c> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-12 interrupt register
        struct OTG_HS_HCINT12 : public Register<0x40040680> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-12 interrupt mask register
        struct OTG_HS_HCINTMSK12 : public Register<0x40040684> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERRM = Field<7, 1>;    // Transaction error
            using BBERRM = Field<8, 1>;    // Babble error
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-12 transfer size register
        struct OTG_HS_HCTSIZ12 : public Register<0x40040688> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-12 DMA address register
        struct OTG_HS_HCDMA12 : public Register<0x4004068c> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-13 characteristics register
        struct OTG_HS_HCCHAR13 : public Register<0x40040690> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-13 split control register
        struct OTG_HS_HCSPLT13 : public Register<0x40040694> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-13 interrupt register
        struct OTG_HS_HCINT13 : public Register<0x40040698> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-13 interrupt mask register
        struct OTG_HS_HCINTMSK13 : public Register<0x4004069c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALLM response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERRM = Field<7, 1>;    // Transaction error
            using BBERRM = Field<8, 1>;    // Babble error
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-13 transfer size register
        struct OTG_HS_HCTSIZ13 : public Register<0x400406a0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-13 DMA address register
        struct OTG_HS_HCDMA13 : public Register<0x400406a4> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-14 characteristics register
        struct OTG_HS_HCCHAR14 : public Register<0x400406a8> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-14 split control register
        struct OTG_HS_HCSPLT14 : public Register<0x400406ac> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-14 interrupt register
        struct OTG_HS_HCINT14 : public Register<0x400406b0> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-14 interrupt mask register
        struct OTG_HS_HCINTMSK14 : public Register<0x400406b4> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAKM response received interrupt mask
            using ACKM = Field<5, 1>;    // ACKM response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERRM = Field<7, 1>;    // Transaction error
            using BBERRM = Field<8, 1>;    // Babble error
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-14 transfer size register
        struct OTG_HS_HCTSIZ14 : public Register<0x400406b8> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-14 DMA address register
        struct OTG_HS_HCDMA14 : public Register<0x400406bc> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-15 characteristics register
        struct OTG_HS_HCCHAR15 : public Register<0x400406c0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-15 split control register
        struct OTG_HS_HCSPLT15 : public Register<0x400406c4> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-15 interrupt register
        struct OTG_HS_HCINT15 : public Register<0x400406c8> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-15 interrupt mask register
        struct OTG_HS_HCINTMSK15 : public Register<0x400406cc> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERRM = Field<7, 1>;    // Transaction error
            using BBERRM = Field<8, 1>;    // Babble error
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-15 transfer size register
        struct OTG_HS_HCTSIZ15 : public Register<0x400406d0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-15 DMA address register
        struct OTG_HS_HCDMA15 : public Register<0x400406d4> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

    };

    // USB 1 on the go high speed
    struct OTG2_HS_HOST {
        // OTG_HS host configuration register
        struct OTG_HS_HCFG : public Register<0x40080400> {
            using FSLSPCS = Field<0, 2>;    // FS/LS PHY clock select
            using FSLSS = Field<2, 1>;    // FS- and LS-only support
        };

        // OTG_HS Host frame interval register
        struct OTG_HS_HFIR : public Register<0x40080404> {
            using FRIVL = Field<0, 16>;    // Frame interval
        };

        // OTG_HS host frame number/frame time remaining register
        struct OTG_HS_HFNUM : public RegisterReadOnly<0x40080408> {
            using FRNUM = Field<0, 16>;    // Frame number
            using FTREM = Field<16, 16>;    // Frame time remaining
        };

        // OTG_HS_Host periodic transmit FIFO/queue status register
        struct OTG_HS_HPTXSTS : public Register<0x40080410> {
            using PTXFSAVL = Field<0, 16>;    // Periodic transmit data FIFO space available
            using PTXQSAV = Field<16, 8>;    // Periodic transmit request queue space available
            using PTXQTOP = Field<24, 8>;    // Top of the periodic transmit request queue
        };

        // OTG_HS Host all channels interrupt register
        struct OTG_HS_HAINT : public RegisterReadOnly<0x40080414> {
            using HAINT = Field<0, 16>;    // Channel interrupts
        };

        // OTG_HS host all channels interrupt mask register
        struct OTG_HS_HAINTMSK : public Register<0x40080418> {
            using HAINTM = Field<0, 16>;    // Channel interrupt mask
        };

        // OTG_HS host port control and status register
        struct OTG_HS_HPRT : public Register<0x40080440> {
            using PCSTS = Field<0, 1>;    // Port connect status
            using PCDET = Field<1, 1>;    // Port connect detected
            using PENA = Field<2, 1>;    // Port enable
            using PENCHNG = Field<3, 1>;    // Port enable/disable change
            using POCA = Field<4, 1>;    // Port overcurrent active
            using POCCHNG = Field<5, 1>;    // Port overcurrent change
            using PRES = Field<6, 1>;    // Port resume
            using PSUSP = Field<7, 1>;    // Port suspend
            using PRST = Field<8, 1>;    // Port reset
            using PLSTS = Field<10, 2>;    // Port line status
            using PPWR = Field<12, 1>;    // Port power
            using PTCTL = Field<13, 4>;    // Port test control
            using PSPD = Field<17, 2>;    // Port speed
        };

        // OTG_HS host channel-0 characteristics register
        struct OTG_HS_HCCHAR0 : public Register<0x40080500> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-1 characteristics register
        struct OTG_HS_HCCHAR1 : public Register<0x40080520> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-2 characteristics register
        struct OTG_HS_HCCHAR2 : public Register<0x40080540> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-3 characteristics register
        struct OTG_HS_HCCHAR3 : public Register<0x40080560> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-4 characteristics register
        struct OTG_HS_HCCHAR4 : public Register<0x40080580> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-5 characteristics register
        struct OTG_HS_HCCHAR5 : public Register<0x400805a0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-6 characteristics register
        struct OTG_HS_HCCHAR6 : public Register<0x400805c0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-7 characteristics register
        struct OTG_HS_HCCHAR7 : public Register<0x400805e0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-8 characteristics register
        struct OTG_HS_HCCHAR8 : public Register<0x40080600> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-9 characteristics register
        struct OTG_HS_HCCHAR9 : public Register<0x40080620> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-10 characteristics register
        struct OTG_HS_HCCHAR10 : public Register<0x40080640> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-11 characteristics register
        struct OTG_HS_HCCHAR11 : public Register<0x40080660> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-0 split control register
        struct OTG_HS_HCSPLT0 : public Register<0x40080504> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-1 split control register
        struct OTG_HS_HCSPLT1 : public Register<0x40080524> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-2 split control register
        struct OTG_HS_HCSPLT2 : public Register<0x40080544> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-3 split control register
        struct OTG_HS_HCSPLT3 : public Register<0x40080564> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-4 split control register
        struct OTG_HS_HCSPLT4 : public Register<0x40080584> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-5 split control register
        struct OTG_HS_HCSPLT5 : public Register<0x400805a4> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-6 split control register
        struct OTG_HS_HCSPLT6 : public Register<0x400805c4> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-7 split control register
        struct OTG_HS_HCSPLT7 : public Register<0x400805e4> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-8 split control register
        struct OTG_HS_HCSPLT8 : public Register<0x40080604> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-9 split control register
        struct OTG_HS_HCSPLT9 : public Register<0x40080624> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-10 split control register
        struct OTG_HS_HCSPLT10 : public Register<0x40080644> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-11 split control register
        struct OTG_HS_HCSPLT11 : public Register<0x40080664> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-11 interrupt register
        struct OTG_HS_HCINT0 : public Register<0x40080508> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-1 interrupt register
        struct OTG_HS_HCINT1 : public Register<0x40080528> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-2 interrupt register
        struct OTG_HS_HCINT2 : public Register<0x40080548> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-3 interrupt register
        struct OTG_HS_HCINT3 : public Register<0x40080568> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-4 interrupt register
        struct OTG_HS_HCINT4 : public Register<0x40080588> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-5 interrupt register
        struct OTG_HS_HCINT5 : public Register<0x400805a8> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-6 interrupt register
        struct OTG_HS_HCINT6 : public Register<0x400805c8> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-7 interrupt register
        struct OTG_HS_HCINT7 : public Register<0x400805e8> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-8 interrupt register
        struct OTG_HS_HCINT8 : public Register<0x40080608> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-9 interrupt register
        struct OTG_HS_HCINT9 : public Register<0x40080628> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-10 interrupt register
        struct OTG_HS_HCINT10 : public Register<0x40080648> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-11 interrupt register
        struct OTG_HS_HCINT11 : public Register<0x40080668> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-11 interrupt mask register
        struct OTG_HS_HCINTMSK0 : public Register<0x4008050c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-1 interrupt mask register
        struct OTG_HS_HCINTMSK1 : public Register<0x4008052c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-2 interrupt mask register
        struct OTG_HS_HCINTMSK2 : public Register<0x4008054c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-3 interrupt mask register
        struct OTG_HS_HCINTMSK3 : public Register<0x4008056c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-4 interrupt mask register
        struct OTG_HS_HCINTMSK4 : public Register<0x4008058c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-5 interrupt mask register
        struct OTG_HS_HCINTMSK5 : public Register<0x400805ac> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-6 interrupt mask register
        struct OTG_HS_HCINTMSK6 : public Register<0x400805cc> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-7 interrupt mask register
        struct OTG_HS_HCINTMSK7 : public Register<0x400805ec> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-8 interrupt mask register
        struct OTG_HS_HCINTMSK8 : public Register<0x4008060c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-9 interrupt mask register
        struct OTG_HS_HCINTMSK9 : public Register<0x4008062c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-10 interrupt mask register
        struct OTG_HS_HCINTMSK10 : public Register<0x4008064c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-11 interrupt mask register
        struct OTG_HS_HCINTMSK11 : public Register<0x4008066c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-11 transfer size register
        struct OTG_HS_HCTSIZ0 : public Register<0x40080510> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-1 transfer size register
        struct OTG_HS_HCTSIZ1 : public Register<0x40080530> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-2 transfer size register
        struct OTG_HS_HCTSIZ2 : public Register<0x40080550> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-3 transfer size register
        struct OTG_HS_HCTSIZ3 : public Register<0x40080570> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-4 transfer size register
        struct OTG_HS_HCTSIZ4 : public Register<0x40080590> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-5 transfer size register
        struct OTG_HS_HCTSIZ5 : public Register<0x400805b0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-6 transfer size register
        struct OTG_HS_HCTSIZ6 : public Register<0x400805d0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-7 transfer size register
        struct OTG_HS_HCTSIZ7 : public Register<0x400805f0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-8 transfer size register
        struct OTG_HS_HCTSIZ8 : public Register<0x40080610> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-9 transfer size register
        struct OTG_HS_HCTSIZ9 : public Register<0x40080630> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-10 transfer size register
        struct OTG_HS_HCTSIZ10 : public Register<0x40080650> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-11 transfer size register
        struct OTG_HS_HCTSIZ11 : public Register<0x40080670> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-0 DMA address register
        struct OTG_HS_HCDMA0 : public Register<0x40080514> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-1 DMA address register
        struct OTG_HS_HCDMA1 : public Register<0x40080534> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-2 DMA address register
        struct OTG_HS_HCDMA2 : public Register<0x40080554> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-3 DMA address register
        struct OTG_HS_HCDMA3 : public Register<0x40080574> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-4 DMA address register
        struct OTG_HS_HCDMA4 : public Register<0x40080594> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-5 DMA address register
        struct OTG_HS_HCDMA5 : public Register<0x400805b4> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-6 DMA address register
        struct OTG_HS_HCDMA6 : public Register<0x400805d4> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-7 DMA address register
        struct OTG_HS_HCDMA7 : public Register<0x400805f4> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-8 DMA address register
        struct OTG_HS_HCDMA8 : public Register<0x40080614> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-9 DMA address register
        struct OTG_HS_HCDMA9 : public Register<0x40080634> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-10 DMA address register
        struct OTG_HS_HCDMA10 : public Register<0x40080654> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-11 DMA address register
        struct OTG_HS_HCDMA11 : public Register<0x40080674> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-12 characteristics register
        struct OTG_HS_HCCHAR12 : public Register<0x40080678> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-12 split control register
        struct OTG_HS_HCSPLT12 : public Register<0x4008067c> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-12 interrupt register
        struct OTG_HS_HCINT12 : public Register<0x40080680> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-12 interrupt mask register
        struct OTG_HS_HCINTMSK12 : public Register<0x40080684> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERRM = Field<7, 1>;    // Transaction error
            using BBERRM = Field<8, 1>;    // Babble error
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-12 transfer size register
        struct OTG_HS_HCTSIZ12 : public Register<0x40080688> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-12 DMA address register
        struct OTG_HS_HCDMA12 : public Register<0x4008068c> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-13 characteristics register
        struct OTG_HS_HCCHAR13 : public Register<0x40080690> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-13 split control register
        struct OTG_HS_HCSPLT13 : public Register<0x40080694> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-13 interrupt register
        struct OTG_HS_HCINT13 : public Register<0x40080698> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-13 interrupt mask register
        struct OTG_HS_HCINTMSK13 : public Register<0x4008069c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALLM response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERRM = Field<7, 1>;    // Transaction error
            using BBERRM = Field<8, 1>;    // Babble error
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-13 transfer size register
        struct OTG_HS_HCTSIZ13 : public Register<0x400806a0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-13 DMA address register
        struct OTG_HS_HCDMA13 : public Register<0x400806a4> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-14 characteristics register
        struct OTG_HS_HCCHAR14 : public Register<0x400806a8> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-14 split control register
        struct OTG_HS_HCSPLT14 : public Register<0x400806ac> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-14 interrupt register
        struct OTG_HS_HCINT14 : public Register<0x400806b0> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-14 interrupt mask register
        struct OTG_HS_HCINTMSK14 : public Register<0x400806b4> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAKM response received interrupt mask
            using ACKM = Field<5, 1>;    // ACKM response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERRM = Field<7, 1>;    // Transaction error
            using BBERRM = Field<8, 1>;    // Babble error
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-14 transfer size register
        struct OTG_HS_HCTSIZ14 : public Register<0x400806b8> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-14 DMA address register
        struct OTG_HS_HCDMA14 : public Register<0x400806bc> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS host channel-15 characteristics register
        struct OTG_HS_HCCHAR15 : public Register<0x400806c0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MC = Field<20, 2>;    // Multi Count (MC) / Error Count (EC)
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_HS host channel-15 split control register
        struct OTG_HS_HCSPLT15 : public Register<0x400806c4> {
            using PRTADDR = Field<0, 7>;    // Port address
            using HUBADDR = Field<7, 7>;    // Hub address
            using XACTPOS = Field<14, 2>;    // XACTPOS
            using COMPLSPLT = Field<16, 1>;    // Do complete split
            using SPLITEN = Field<31, 1>;    // Split enable
        };

        // OTG_HS host channel-15 interrupt register
        struct OTG_HS_HCINT15 : public Register<0x400806c8> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_HS host channel-15 interrupt mask register
        struct OTG_HS_HCINTMSK15 : public Register<0x400806cc> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using AHBERR = Field<2, 1>;    // AHB error
            using STALL = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // Response received interrupt
            using TXERRM = Field<7, 1>;    // Transaction error
            using BBERRM = Field<8, 1>;    // Babble error
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_HS host channel-15 transfer size register
        struct OTG_HS_HCTSIZ15 : public Register<0x400806d0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_HS host channel-15 DMA address register
        struct OTG_HS_HCDMA15 : public Register<0x400806d4> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

    };

    // USB 1 on the go high speed
    struct OTG1_HS_DEVICE {
        // OTG_HS device configuration register
        struct OTG_HS_DCFG : public Register<0x40040800> {
            using DSPD = Field<0, 2>;    // Device speed
            using NZLSOHSK = Field<2, 1>;    // Nonzero-length status OUT handshake
            using DAD = Field<4, 7>;    // Device address
            using PFIVL = Field<11, 2>;    // Periodic (micro)frame interval
            using PERSCHIVL = Field<24, 2>;    // Periodic scheduling interval
        };

        // OTG_HS device control register
        struct OTG_HS_DCTL : public Register<0x40040804> {
            using RWUSIG = Field<0, 1>;    // Remote wakeup signaling
            using SDIS = Field<1, 1>;    // Soft disconnect
            using GINSTS = Field<2, 1>;    // Global IN NAK status
            using GONSTS = Field<3, 1>;    // Global OUT NAK status
            using TCTL = Field<4, 3>;    // Test control
            using SGINAK = Field<7, 1>;    // Set global IN NAK
            using CGINAK = Field<8, 1>;    // Clear global IN NAK
            using SGONAK = Field<9, 1>;    // Set global OUT NAK
            using CGONAK = Field<10, 1>;    // Clear global OUT NAK
            using POPRGDNE = Field<11, 1>;    // Power-on programming done
        };

        // OTG_HS device status register
        struct OTG_HS_DSTS : public RegisterReadOnly<0x40040808> {
            using SUSPSTS = Field<0, 1>;    // Suspend status
            using ENUMSPD = Field<1, 2>;    // Enumerated speed
            using EERR = Field<3, 1>;    // Erratic error
            using FNSOF = Field<8, 14>;    // Frame number of the received SOF
        };

        // OTG_HS device IN endpoint common interrupt mask register
        struct OTG_HS_DIEPMSK : public Register<0x40040810> {
            using XFRCM = Field<0, 1>;    // Transfer completed interrupt mask
            using EPDM = Field<1, 1>;    // Endpoint disabled interrupt mask
            using TOM = Field<3, 1>;    // Timeout condition mask (nonisochronous endpoints)
            using ITTXFEMSK = Field<4, 1>;    // IN token received when TxFIFO empty mask
            using INEPNMM = Field<5, 1>;    // IN token received with EP mismatch mask
            using INEPNEM = Field<6, 1>;    // IN endpoint NAK effective mask
            using TXFURM = Field<8, 1>;    // FIFO underrun mask
            using BIM = Field<9, 1>;    // BNA interrupt mask
        };

        // OTG_HS device OUT endpoint common interrupt mask register
        struct OTG_HS_DOEPMSK : public Register<0x40040814> {
            using XFRCM = Field<0, 1>;    // Transfer completed interrupt mask
            using EPDM = Field<1, 1>;    // Endpoint disabled interrupt mask
            using STUPM = Field<3, 1>;    // SETUP phase done mask
            using OTEPDM = Field<4, 1>;    // OUT token received when endpoint disabled mask
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received mask
            using OPEM = Field<8, 1>;    // OUT packet error mask
            using BOIM = Field<9, 1>;    // BNA interrupt mask
        };

        // OTG_HS device all endpoints interrupt register
        struct OTG_HS_DAINT : public RegisterReadOnly<0x40040818> {
            using IEPINT = Field<0, 16>;    // IN endpoint interrupt bits
            using OEPINT = Field<16, 16>;    // OUT endpoint interrupt bits
        };

        // OTG_HS all endpoints interrupt mask register
        struct OTG_HS_DAINTMSK : public Register<0x4004081c> {
            using IEPM = Field<0, 16>;    // IN EP interrupt mask bits
            using OEPM = Field<16, 16>;    // OUT EP interrupt mask bits
        };

        // OTG_HS device VBUS discharge time register
        struct OTG_HS_DVBUSDIS : public Register<0x40040828> {
            using VBUSDT = Field<0, 16>;    // Device VBUS discharge time
        };

        // OTG_HS device VBUS pulsing time register
        struct OTG_HS_DVBUSPULSE : public Register<0x4004082c> {
            using DVBUSP = Field<0, 12>;    // Device VBUS pulsing time
        };

        // OTG_HS Device threshold control register
        struct OTG_HS_DTHRCTL : public Register<0x40040830> {
            using NONISOTHREN = Field<0, 1>;    // Nonisochronous IN endpoints threshold enable
            using ISOTHREN = Field<1, 1>;    // ISO IN endpoint threshold enable
            using TXTHRLEN = Field<2, 9>;    // Transmit threshold length
            using RXTHREN = Field<16, 1>;    // Receive threshold enable
            using RXTHRLEN = Field<17, 9>;    // Receive threshold length
            using ARPEN = Field<27, 1>;    // Arbiter parking enable
        };

        // OTG_HS device IN endpoint FIFO empty interrupt mask register
        struct OTG_HS_DIEPEMPMSK : public Register<0x40040834> {
            using INEPTXFEM = Field<0, 16>;    // IN EP Tx FIFO empty interrupt mask bits
        };

        // OTG_HS device each endpoint interrupt register
        struct OTG_HS_DEACHINT : public Register<0x40040838> {
            using IEP1INT = Field<1, 1>;    // IN endpoint 1interrupt bit
            using OEP1INT = Field<17, 1>;    // OUT endpoint 1 interrupt bit
        };

        // OTG_HS device each endpoint interrupt register mask
        struct OTG_HS_DEACHINTMSK : public Register<0x4004083c> {
            using IEP1INTM = Field<1, 1>;    // IN Endpoint 1 interrupt mask bit
            using OEP1INTM = Field<17, 1>;    // OUT Endpoint 1 interrupt mask bit
        };

        // OTG device endpoint-0 control register
        struct OTG_HS_DIEPCTL0 : public Register<0x40040900> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-1 control register
        struct OTG_HS_DIEPCTL1 : public Register<0x40040920> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-2 control register
        struct OTG_HS_DIEPCTL2 : public Register<0x40040940> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-3 control register
        struct OTG_HS_DIEPCTL3 : public Register<0x40040960> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-4 control register
        struct OTG_HS_DIEPCTL4 : public Register<0x40040980> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-5 control register
        struct OTG_HS_DIEPCTL5 : public Register<0x400409a0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-6 control register
        struct OTG_HS_DIEPCTL6 : public Register<0x400409c0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-7 control register
        struct OTG_HS_DIEPCTL7 : public Register<0x400409e0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-0 interrupt register
        struct OTG_HS_DIEPINT0 : public Register<0x40040908> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG device endpoint-1 interrupt register
        struct OTG_HS_DIEPINT1 : public Register<0x40040928> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG device endpoint-2 interrupt register
        struct OTG_HS_DIEPINT2 : public Register<0x40040948> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG device endpoint-3 interrupt register
        struct OTG_HS_DIEPINT3 : public Register<0x40040968> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG device endpoint-4 interrupt register
        struct OTG_HS_DIEPINT4 : public Register<0x40040988> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG device endpoint-5 interrupt register
        struct OTG_HS_DIEPINT5 : public Register<0x400409a8> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG device endpoint-6 interrupt register
        struct OTG_HS_DIEPINT6 : public Register<0x400409c8> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG device endpoint-7 interrupt register
        struct OTG_HS_DIEPINT7 : public Register<0x400409e8> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG_HS device IN endpoint 0 transfer size register
        struct OTG_HS_DIEPTSIZ0 : public Register<0x40040910> {
            using XFRSIZ = Field<0, 7>;    // Transfer size
            using PKTCNT = Field<19, 2>;    // Packet count
        };

        // OTG_HS device endpoint-1 DMA address register
        struct OTG_HS_DIEPDMA1 : public Register<0x40040914> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS device endpoint-2 DMA address register
        struct OTG_HS_DIEPDMA2 : public Register<0x40040934> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS device endpoint-3 DMA address register
        struct OTG_HS_DIEPDMA3 : public Register<0x40040954> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS device endpoint-4 DMA address register
        struct OTG_HS_DIEPDMA4 : public Register<0x40040974> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS device endpoint-5 DMA address register
        struct OTG_HS_DIEPDMA5 : public Register<0x40040994> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS0 : public RegisterReadOnly<0x40040918> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS1 : public RegisterReadOnly<0x40040938> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS2 : public RegisterReadOnly<0x40040958> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS3 : public RegisterReadOnly<0x40040978> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS4 : public RegisterReadOnly<0x40040998> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS5 : public RegisterReadOnly<0x400409b8> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG_HS device endpoint transfer size register
        struct OTG_HS_DIEPTSIZ1 : public Register<0x40040930> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using MCNT = Field<29, 2>;    // Multi count
        };

        // OTG_HS device endpoint transfer size register
        struct OTG_HS_DIEPTSIZ2 : public Register<0x40040950> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using MCNT = Field<29, 2>;    // Multi count
        };

        // OTG_HS device endpoint transfer size register
        struct OTG_HS_DIEPTSIZ3 : public Register<0x40040970> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using MCNT = Field<29, 2>;    // Multi count
        };

        // OTG_HS device endpoint transfer size register
        struct OTG_HS_DIEPTSIZ4 : public Register<0x40040990> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using MCNT = Field<29, 2>;    // Multi count
        };

        // OTG_HS device endpoint transfer size register
        struct OTG_HS_DIEPTSIZ5 : public Register<0x400409b0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using MCNT = Field<29, 2>;    // Multi count
        };

        // OTG_HS device control OUT endpoint 0 control register
        struct OTG_HS_DOEPCTL0 : public Register<0x40040b00> {
            using MPSIZ = Field<0, 2>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-1 control register
        struct OTG_HS_DOEPCTL1 : public Register<0x40040b20> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even odd frame/Endpoint data PID
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID/Set even frame
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-2 control register
        struct OTG_HS_DOEPCTL2 : public Register<0x40040b40> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even odd frame/Endpoint data PID
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID/Set even frame
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-3 control register
        struct OTG_HS_DOEPCTL3 : public Register<0x40040b60> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even odd frame/Endpoint data PID
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID/Set even frame
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG_HS device endpoint-0 interrupt register
        struct OTG_HS_DOEPINT0 : public Register<0x40040b08> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-1 interrupt register
        struct OTG_HS_DOEPINT1 : public Register<0x40040b28> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-2 interrupt register
        struct OTG_HS_DOEPINT2 : public Register<0x40040b48> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-3 interrupt register
        struct OTG_HS_DOEPINT3 : public Register<0x40040b68> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-4 interrupt register
        struct OTG_HS_DOEPINT4 : public Register<0x40040b88> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-5 interrupt register
        struct OTG_HS_DOEPINT5 : public Register<0x40040ba8> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-6 interrupt register
        struct OTG_HS_DOEPINT6 : public Register<0x40040bc8> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-7 interrupt register
        struct OTG_HS_DOEPINT7 : public Register<0x40040be8> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-0 transfer size register
        struct OTG_HS_DOEPTSIZ0 : public Register<0x40040b10> {
            using XFRSIZ = Field<0, 7>;    // Transfer size
            using PKTCNT = Field<19, 1>;    // Packet count
            using STUPCNT = Field<29, 2>;    // SETUP packet count
        };

        // OTG_HS device endpoint-1 transfer size register
        struct OTG_HS_DOEPTSIZ1 : public Register<0x40040b30> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
        };

        // OTG_HS device endpoint-2 transfer size register
        struct OTG_HS_DOEPTSIZ2 : public Register<0x40040b50> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
        };

        // OTG_HS device endpoint-3 transfer size register
        struct OTG_HS_DOEPTSIZ3 : public Register<0x40040b70> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
        };

        // OTG_HS device endpoint-4 transfer size register
        struct OTG_HS_DOEPTSIZ4 : public Register<0x40040b90> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
        };

        // OTG_HS device endpoint transfer size register
        struct OTG_HS_DIEPTSIZ6 : public Register<0x400409a0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using MCNT = Field<29, 2>;    // Multi count
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS6 : public Register<0x400409a4> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG_HS device endpoint transfer size register
        struct OTG_HS_DIEPTSIZ7 : public Register<0x400409a8> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using MCNT = Field<29, 2>;    // Multi count
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS7 : public Register<0x400409ac> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG device endpoint-4 control register
        struct OTG_HS_DOEPCTL4 : public Register<0x40040b80> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even odd frame/Endpoint data PID
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID/Set even frame
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-5 control register
        struct OTG_HS_DOEPCTL5 : public Register<0x40040ba0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even odd frame/Endpoint data PID
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID/Set even frame
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-6 control register
        struct OTG_HS_DOEPCTL6 : public Register<0x40040bc0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even odd frame/Endpoint data PID
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID/Set even frame
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-7 control register
        struct OTG_HS_DOEPCTL7 : public Register<0x40040be0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even odd frame/Endpoint data PID
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID/Set even frame
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG_HS device endpoint-5 transfer size register
        struct OTG_HS_DOEPTSIZ5 : public Register<0x40040bb0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
        };

        // OTG_HS device endpoint-6 transfer size register
        struct OTG_HS_DOEPTSIZ6 : public Register<0x40040bd0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
        };

        // OTG_HS device endpoint-7 transfer size register
        struct OTG_HS_DOEPTSIZ7 : public Register<0x40040bf0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
        };

    };

    // USB 1 on the go high speed
    struct OTG2_HS_DEVICE {
        // OTG_HS device configuration register
        struct OTG_HS_DCFG : public Register<0x40080800> {
            using DSPD = Field<0, 2>;    // Device speed
            using NZLSOHSK = Field<2, 1>;    // Nonzero-length status OUT handshake
            using DAD = Field<4, 7>;    // Device address
            using PFIVL = Field<11, 2>;    // Periodic (micro)frame interval
            using PERSCHIVL = Field<24, 2>;    // Periodic scheduling interval
        };

        // OTG_HS device control register
        struct OTG_HS_DCTL : public Register<0x40080804> {
            using RWUSIG = Field<0, 1>;    // Remote wakeup signaling
            using SDIS = Field<1, 1>;    // Soft disconnect
            using GINSTS = Field<2, 1>;    // Global IN NAK status
            using GONSTS = Field<3, 1>;    // Global OUT NAK status
            using TCTL = Field<4, 3>;    // Test control
            using SGINAK = Field<7, 1>;    // Set global IN NAK
            using CGINAK = Field<8, 1>;    // Clear global IN NAK
            using SGONAK = Field<9, 1>;    // Set global OUT NAK
            using CGONAK = Field<10, 1>;    // Clear global OUT NAK
            using POPRGDNE = Field<11, 1>;    // Power-on programming done
        };

        // OTG_HS device status register
        struct OTG_HS_DSTS : public RegisterReadOnly<0x40080808> {
            using SUSPSTS = Field<0, 1>;    // Suspend status
            using ENUMSPD = Field<1, 2>;    // Enumerated speed
            using EERR = Field<3, 1>;    // Erratic error
            using FNSOF = Field<8, 14>;    // Frame number of the received SOF
        };

        // OTG_HS device IN endpoint common interrupt mask register
        struct OTG_HS_DIEPMSK : public Register<0x40080810> {
            using XFRCM = Field<0, 1>;    // Transfer completed interrupt mask
            using EPDM = Field<1, 1>;    // Endpoint disabled interrupt mask
            using TOM = Field<3, 1>;    // Timeout condition mask (nonisochronous endpoints)
            using ITTXFEMSK = Field<4, 1>;    // IN token received when TxFIFO empty mask
            using INEPNMM = Field<5, 1>;    // IN token received with EP mismatch mask
            using INEPNEM = Field<6, 1>;    // IN endpoint NAK effective mask
            using TXFURM = Field<8, 1>;    // FIFO underrun mask
            using BIM = Field<9, 1>;    // BNA interrupt mask
        };

        // OTG_HS device OUT endpoint common interrupt mask register
        struct OTG_HS_DOEPMSK : public Register<0x40080814> {
            using XFRCM = Field<0, 1>;    // Transfer completed interrupt mask
            using EPDM = Field<1, 1>;    // Endpoint disabled interrupt mask
            using STUPM = Field<3, 1>;    // SETUP phase done mask
            using OTEPDM = Field<4, 1>;    // OUT token received when endpoint disabled mask
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received mask
            using OPEM = Field<8, 1>;    // OUT packet error mask
            using BOIM = Field<9, 1>;    // BNA interrupt mask
        };

        // OTG_HS device all endpoints interrupt register
        struct OTG_HS_DAINT : public RegisterReadOnly<0x40080818> {
            using IEPINT = Field<0, 16>;    // IN endpoint interrupt bits
            using OEPINT = Field<16, 16>;    // OUT endpoint interrupt bits
        };

        // OTG_HS all endpoints interrupt mask register
        struct OTG_HS_DAINTMSK : public Register<0x4008081c> {
            using IEPM = Field<0, 16>;    // IN EP interrupt mask bits
            using OEPM = Field<16, 16>;    // OUT EP interrupt mask bits
        };

        // OTG_HS device VBUS discharge time register
        struct OTG_HS_DVBUSDIS : public Register<0x40080828> {
            using VBUSDT = Field<0, 16>;    // Device VBUS discharge time
        };

        // OTG_HS device VBUS pulsing time register
        struct OTG_HS_DVBUSPULSE : public Register<0x4008082c> {
            using DVBUSP = Field<0, 12>;    // Device VBUS pulsing time
        };

        // OTG_HS Device threshold control register
        struct OTG_HS_DTHRCTL : public Register<0x40080830> {
            using NONISOTHREN = Field<0, 1>;    // Nonisochronous IN endpoints threshold enable
            using ISOTHREN = Field<1, 1>;    // ISO IN endpoint threshold enable
            using TXTHRLEN = Field<2, 9>;    // Transmit threshold length
            using RXTHREN = Field<16, 1>;    // Receive threshold enable
            using RXTHRLEN = Field<17, 9>;    // Receive threshold length
            using ARPEN = Field<27, 1>;    // Arbiter parking enable
        };

        // OTG_HS device IN endpoint FIFO empty interrupt mask register
        struct OTG_HS_DIEPEMPMSK : public Register<0x40080834> {
            using INEPTXFEM = Field<0, 16>;    // IN EP Tx FIFO empty interrupt mask bits
        };

        // OTG_HS device each endpoint interrupt register
        struct OTG_HS_DEACHINT : public Register<0x40080838> {
            using IEP1INT = Field<1, 1>;    // IN endpoint 1interrupt bit
            using OEP1INT = Field<17, 1>;    // OUT endpoint 1 interrupt bit
        };

        // OTG_HS device each endpoint interrupt register mask
        struct OTG_HS_DEACHINTMSK : public Register<0x4008083c> {
            using IEP1INTM = Field<1, 1>;    // IN Endpoint 1 interrupt mask bit
            using OEP1INTM = Field<17, 1>;    // OUT Endpoint 1 interrupt mask bit
        };

        // OTG device endpoint-0 control register
        struct OTG_HS_DIEPCTL0 : public Register<0x40080900> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-1 control register
        struct OTG_HS_DIEPCTL1 : public Register<0x40080920> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-2 control register
        struct OTG_HS_DIEPCTL2 : public Register<0x40080940> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-3 control register
        struct OTG_HS_DIEPCTL3 : public Register<0x40080960> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-4 control register
        struct OTG_HS_DIEPCTL4 : public Register<0x40080980> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-5 control register
        struct OTG_HS_DIEPCTL5 : public Register<0x400809a0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-6 control register
        struct OTG_HS_DIEPCTL6 : public Register<0x400809c0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-7 control register
        struct OTG_HS_DIEPCTL7 : public Register<0x400809e0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even/odd frame
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using Stall = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-0 interrupt register
        struct OTG_HS_DIEPINT0 : public Register<0x40080908> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG device endpoint-1 interrupt register
        struct OTG_HS_DIEPINT1 : public Register<0x40080928> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG device endpoint-2 interrupt register
        struct OTG_HS_DIEPINT2 : public Register<0x40080948> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG device endpoint-3 interrupt register
        struct OTG_HS_DIEPINT3 : public Register<0x40080968> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG device endpoint-4 interrupt register
        struct OTG_HS_DIEPINT4 : public Register<0x40080988> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG device endpoint-5 interrupt register
        struct OTG_HS_DIEPINT5 : public Register<0x400809a8> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG device endpoint-6 interrupt register
        struct OTG_HS_DIEPINT6 : public Register<0x400809c8> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG device endpoint-7 interrupt register
        struct OTG_HS_DIEPINT7 : public Register<0x400809e8> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using TOC = Field<3, 1>;    // Timeout condition
            using ITTXFE = Field<4, 1>;    // IN token received when TxFIFO is empty
            using INEPNE = Field<6, 1>;    // IN endpoint NAK effective
            using TXFE = Field<7, 1>;    // Transmit FIFO empty
            using TXFIFOUDRN = Field<8, 1>;    // Transmit Fifo Underrun
            using BNA = Field<9, 1>;    // Buffer not available interrupt
            using PKTDRPSTS = Field<11, 1>;    // Packet dropped status
            using BERR = Field<12, 1>;    // Babble error interrupt
            using NAK = Field<13, 1>;    // NAK interrupt
        };

        // OTG_HS device IN endpoint 0 transfer size register
        struct OTG_HS_DIEPTSIZ0 : public Register<0x40080910> {
            using XFRSIZ = Field<0, 7>;    // Transfer size
            using PKTCNT = Field<19, 2>;    // Packet count
        };

        // OTG_HS device endpoint-1 DMA address register
        struct OTG_HS_DIEPDMA1 : public Register<0x40080914> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS device endpoint-2 DMA address register
        struct OTG_HS_DIEPDMA2 : public Register<0x40080934> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS device endpoint-3 DMA address register
        struct OTG_HS_DIEPDMA3 : public Register<0x40080954> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS device endpoint-4 DMA address register
        struct OTG_HS_DIEPDMA4 : public Register<0x40080974> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS device endpoint-5 DMA address register
        struct OTG_HS_DIEPDMA5 : public Register<0x40080994> {
            using DMAADDR = Field<0, 32>;    // DMA address
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS0 : public RegisterReadOnly<0x40080918> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS1 : public RegisterReadOnly<0x40080938> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS2 : public RegisterReadOnly<0x40080958> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS3 : public RegisterReadOnly<0x40080978> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS4 : public RegisterReadOnly<0x40080998> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS5 : public RegisterReadOnly<0x400809b8> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG_HS device endpoint transfer size register
        struct OTG_HS_DIEPTSIZ1 : public Register<0x40080930> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using MCNT = Field<29, 2>;    // Multi count
        };

        // OTG_HS device endpoint transfer size register
        struct OTG_HS_DIEPTSIZ2 : public Register<0x40080950> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using MCNT = Field<29, 2>;    // Multi count
        };

        // OTG_HS device endpoint transfer size register
        struct OTG_HS_DIEPTSIZ3 : public Register<0x40080970> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using MCNT = Field<29, 2>;    // Multi count
        };

        // OTG_HS device endpoint transfer size register
        struct OTG_HS_DIEPTSIZ4 : public Register<0x40080990> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using MCNT = Field<29, 2>;    // Multi count
        };

        // OTG_HS device endpoint transfer size register
        struct OTG_HS_DIEPTSIZ5 : public Register<0x400809b0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using MCNT = Field<29, 2>;    // Multi count
        };

        // OTG_HS device control OUT endpoint 0 control register
        struct OTG_HS_DOEPCTL0 : public Register<0x40080b00> {
            using MPSIZ = Field<0, 2>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-1 control register
        struct OTG_HS_DOEPCTL1 : public Register<0x40080b20> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even odd frame/Endpoint data PID
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID/Set even frame
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-2 control register
        struct OTG_HS_DOEPCTL2 : public Register<0x40080b40> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even odd frame/Endpoint data PID
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID/Set even frame
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-3 control register
        struct OTG_HS_DOEPCTL3 : public Register<0x40080b60> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even odd frame/Endpoint data PID
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID/Set even frame
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG_HS device endpoint-0 interrupt register
        struct OTG_HS_DOEPINT0 : public Register<0x40080b08> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-1 interrupt register
        struct OTG_HS_DOEPINT1 : public Register<0x40080b28> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-2 interrupt register
        struct OTG_HS_DOEPINT2 : public Register<0x40080b48> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-3 interrupt register
        struct OTG_HS_DOEPINT3 : public Register<0x40080b68> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-4 interrupt register
        struct OTG_HS_DOEPINT4 : public Register<0x40080b88> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-5 interrupt register
        struct OTG_HS_DOEPINT5 : public Register<0x40080ba8> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-6 interrupt register
        struct OTG_HS_DOEPINT6 : public Register<0x40080bc8> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-7 interrupt register
        struct OTG_HS_DOEPINT7 : public Register<0x40080be8> {
            using XFRC = Field<0, 1>;    // Transfer completed interrupt
            using EPDISD = Field<1, 1>;    // Endpoint disabled interrupt
            using STUP = Field<3, 1>;    // SETUP phase done
            using OTEPDIS = Field<4, 1>;    // OUT token received when endpoint disabled
            using B2BSTUP = Field<6, 1>;    // Back-to-back SETUP packets received
            using NYET = Field<14, 1>;    // NYET interrupt
        };

        // OTG_HS device endpoint-0 transfer size register
        struct OTG_HS_DOEPTSIZ0 : public Register<0x40080b10> {
            using XFRSIZ = Field<0, 7>;    // Transfer size
            using PKTCNT = Field<19, 1>;    // Packet count
            using STUPCNT = Field<29, 2>;    // SETUP packet count
        };

        // OTG_HS device endpoint-1 transfer size register
        struct OTG_HS_DOEPTSIZ1 : public Register<0x40080b30> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
        };

        // OTG_HS device endpoint-2 transfer size register
        struct OTG_HS_DOEPTSIZ2 : public Register<0x40080b50> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
        };

        // OTG_HS device endpoint-3 transfer size register
        struct OTG_HS_DOEPTSIZ3 : public Register<0x40080b70> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
        };

        // OTG_HS device endpoint-4 transfer size register
        struct OTG_HS_DOEPTSIZ4 : public Register<0x40080b90> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
        };

        // OTG_HS device endpoint transfer size register
        struct OTG_HS_DIEPTSIZ6 : public Register<0x400809a0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using MCNT = Field<29, 2>;    // Multi count
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS6 : public Register<0x400809a4> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG_HS device endpoint transfer size register
        struct OTG_HS_DIEPTSIZ7 : public Register<0x400809a8> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using MCNT = Field<29, 2>;    // Multi count
        };

        // OTG_HS device IN endpoint transmit FIFO status register
        struct OTG_HS_DTXFSTS7 : public Register<0x400809ac> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space avail
        };

        // OTG device endpoint-4 control register
        struct OTG_HS_DOEPCTL4 : public Register<0x40080b80> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even odd frame/Endpoint data PID
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID/Set even frame
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-5 control register
        struct OTG_HS_DOEPCTL5 : public Register<0x40080ba0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even odd frame/Endpoint data PID
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID/Set even frame
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-6 control register
        struct OTG_HS_DOEPCTL6 : public Register<0x40080bc0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even odd frame/Endpoint data PID
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID/Set even frame
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-7 control register
        struct OTG_HS_DOEPCTL7 : public Register<0x40080be0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using EONUM_DPID = Field<16, 1>;    // Even odd frame/Endpoint data PID
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using SNPM = Field<20, 1>;    // Snoop mode
            using Stall = Field<21, 1>;    // STALL handshake
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using SD0PID_SEVNFRM = Field<28, 1>;    // Set DATA0 PID/Set even frame
            using SODDFRM = Field<29, 1>;    // Set odd frame
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG_HS device endpoint-5 transfer size register
        struct OTG_HS_DOEPTSIZ5 : public Register<0x40080bb0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
        };

        // OTG_HS device endpoint-6 transfer size register
        struct OTG_HS_DOEPTSIZ6 : public Register<0x40080bd0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
        };

        // OTG_HS device endpoint-7 transfer size register
        struct OTG_HS_DOEPTSIZ7 : public Register<0x40080bf0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
        };

    };

    // USB 1 on the go high speed
    struct OTG1_HS_PWRCLK {
        // Power and clock gating control register
        struct OTG_HS_PCGCR : public Register<0x40040e00> {
            using STPPCLK = Field<0, 1>;    // Stop PHY clock
            using GATEHCLK = Field<1, 1>;    // Gate HCLK
            using PHYSUSP = Field<4, 1>;    // PHY suspended
        };

    };

    // USB 1 on the go high speed
    struct OTG2_HS_PWRCLK {
        // Power and clock gating control register
        struct OTG_HS_PCGCR : public Register<0x40080e00> {
            using STPPCLK = Field<0, 1>;    // Stop PHY clock
            using GATEHCLK = Field<1, 1>;    // Gate HCLK
            using PHYSUSP = Field<4, 1>;    // PHY suspended
        };

    };

    // Ethernet: DMA mode register (DMA)
    struct Ethernet_DMA {
        // DMA mode register
        struct DMAMR : public Register<0x40029000> {
            using SWR = Field<0, 1>;    // Software Reset
            using DA = Field<1, 1>;    // DMA Tx or Rx Arbitration Scheme
            using TXPR = Field<11, 1>;    // Transmit priority
            using PR = Field<12, 3>;    // Priority ratio
            using INTM = Field<16, 1>;    // Interrupt Mode
        };

        // System bus mode register
        struct DMASBMR : public Register<0x40029004> {
            using FB = Field<0, 1>;    // Fixed Burst Length
            using AAL = Field<12, 1>;    // Address-Aligned Beats
            using MB = Field<14, 1>;    // Mixed Burst
            using RB = Field<15, 1>;    // Rebuild INCRx Burst
        };

        // Interrupt status register
        struct DMAISR : public RegisterReadOnly<0x40029008> {
            using DC0IS = Field<0, 1>;    // DMA Channel Interrupt Status
            using MTLIS = Field<16, 1>;    // MTL Interrupt Status
            using MACIS = Field<17, 1>;    // MAC Interrupt Status
        };

        // Debug status register
        struct DMADSR : public RegisterReadOnly<0x4002900c> {
            using AXWHSTS = Field<0, 1>;    // AHB Master Write Channel
            using RPS0 = Field<8, 4>;    // DMA Channel Receive Process State
            using TPS0 = Field<12, 4>;    // DMA Channel Transmit Process State
        };

        // Channel control register
        struct DMACCR : public Register<0x40029100> {
            using MSS = Field<0, 14>;    // Maximum Segment Size
            using PBLX8 = Field<16, 1>;    // 8xPBL mode
            using DSL = Field<18, 3>;    // Descriptor Skip Length
        };

        // Channel transmit control register
        struct DMACTxCR : public Register<0x40029104> {
            using ST = Field<0, 1>;    // Start or Stop Transmission Command
            using OSF = Field<4, 1>;    // Operate on Second Packet
            using TSE = Field<12, 1>;    // TCP Segmentation Enabled
            using TXPBL = Field<16, 6>;    // Transmit Programmable Burst Length
        };

        // Channel receive control register
        struct DMACRxCR : public Register<0x40029108> {
            using SR = Field<0, 1>;    // Start or Stop Receive Command
            using RBSZ = Field<1, 14>;    // Receive Buffer size
            using RXPBL = Field<16, 6>;    // RXPBL
            using RPF = Field<31, 1>;    // DMA Rx Channel Packet Flush
        };

        // Channel Tx descriptor list address register
        struct DMACTxDLAR : public Register<0x40029114> {
            using TDESLA = Field<2, 30>;    // Start of Transmit List
        };

        // Channel Rx descriptor list address register
        struct DMACRxDLAR : public Register<0x4002911c> {
            using RDESLA = Field<2, 30>;    // Start of Receive List
        };

        // Channel Tx descriptor tail pointer register
        struct DMACTxDTPR : public Register<0x40029120> {
            using TDT = Field<2, 30>;    // Transmit Descriptor Tail Pointer
        };

        // Channel Rx descriptor tail pointer register
        struct DMACRxDTPR : public Register<0x40029128> {
            using RDT = Field<2, 30>;    // Receive Descriptor Tail Pointer
        };

        // Channel Tx descriptor ring length register
        struct DMACTxRLR : public Register<0x4002912c> {
            using TDRL = Field<0, 10>;    // Transmit Descriptor Ring Length
        };

        // Channel Rx descriptor ring length register
        struct DMACRxRLR : public Register<0x40029130> {
            using RDRL = Field<0, 10>;    // Receive Descriptor Ring Length
        };

        // Channel interrupt enable register
        struct DMACIER : public Register<0x40029134> {
            using TIE = Field<0, 1>;    // Transmit Interrupt Enable
            using TXSE = Field<1, 1>;    // Transmit Stopped Enable
            using TBUE = Field<2, 1>;    // Transmit Buffer Unavailable Enable
            using RIE = Field<6, 1>;    // Receive Interrupt Enable
            using RBUE = Field<7, 1>;    // Receive Buffer Unavailable Enable
            using RSE = Field<8, 1>;    // Receive Stopped Enable
            using RWTE = Field<9, 1>;    // Receive Watchdog Timeout Enable
            using ETIE = Field<10, 1>;    // Early Transmit Interrupt Enable
            using ERIE = Field<11, 1>;    // Early Receive Interrupt Enable
            using FBEE = Field<12, 1>;    // Fatal Bus Error Enable
            using CDEE = Field<13, 1>;    // Context Descriptor Error Enable
            using AIE = Field<14, 1>;    // Abnormal Interrupt Summary Enable
            using NIE = Field<15, 1>;    // Normal Interrupt Summary Enable
        };

        // Channel Rx interrupt watchdog timer register
        struct DMACRxIWTR : public Register<0x40029138> {
            using RWT = Field<0, 8>;    // Receive Interrupt Watchdog Timer Count
        };

        // Channel current application transmit descriptor register
        struct DMACCATxDR : public RegisterReadOnly<0x40029144> {
            using CURTDESAPTR = Field<0, 32>;    // Application Transmit Descriptor Address Pointer
        };

        // Channel current application receive descriptor register
        struct DMACCARxDR : public RegisterReadOnly<0x4002914c> {
            using CURRDESAPTR = Field<0, 32>;    // Application Receive Descriptor Address Pointer
        };

        // Channel current application transmit buffer register
        struct DMACCATxBR : public RegisterReadOnly<0x40029154> {
            using CURTBUFAPTR = Field<0, 32>;    // Application Transmit Buffer Address Pointer
        };

        // Channel current application receive buffer register
        struct DMACCARxBR : public RegisterReadOnly<0x4002915c> {
            using CURRBUFAPTR = Field<0, 32>;    // Application Receive Buffer Address Pointer
        };

        // Channel status register
        struct DMACSR : public Register<0x40029160> {
            using TI = Field<0, 1>;    // Transmit Interrupt
            using TPS = Field<1, 1>;    // Transmit Process Stopped
            using TBU = Field<2, 1>;    // Transmit Buffer Unavailable
            using RI = Field<6, 1>;    // Receive Interrupt
            using RBU = Field<7, 1>;    // Receive Buffer Unavailable
            using RPS = Field<8, 1>;    // Receive Process Stopped
            using RWT = Field<9, 1>;    // Receive Watchdog Timeout
            using ET = Field<10, 1>;    // Early Transmit Interrupt
            using ER = Field<11, 1>;    // Early Receive Interrupt
            using FBE = Field<12, 1>;    // Fatal Bus Error
            using CDE = Field<13, 1>;    // Context Descriptor Error
            using AIS = Field<14, 1>;    // Abnormal Interrupt Summary
            using NIS = Field<15, 1>;    // Normal Interrupt Summary
            using TEB = Field<16, 3>;    // Tx DMA Error Bits
            using REB = Field<19, 3>;    // Rx DMA Error Bits
        };

        // Channel missed frame count register
        struct DMACMFCR : public RegisterReadOnly<0x4002916c> {
            using MFC = Field<0, 11>;    // Dropped Packet Counters
            using MFCO = Field<15, 1>;    // Overflow status of the MFC Counter
        };

    };

    // Ethernet: MTL mode register (MTL)
    struct Ethernet_MTL {
        // Operating mode Register
        struct MTLOMR : public Register<0x40028c00> {
            using DTXSTS = Field<1, 1>;    // DTXSTS
            using CNTPRST = Field<8, 1>;    // CNTPRST
            using CNTCLR = Field<9, 1>;    // CNTCLR
        };

        // Interrupt status Register
        struct MTLISR : public RegisterReadOnly<0x40028c20> {
            using Q0IS = Field<0, 1>;    // Queue interrupt status
        };

        // Tx queue operating mode Register
        struct MTLTxQOMR : public Register<0x40028d00> {
            using FTQ = Field<0, 1>;    // Flush Transmit Queue
            using TSF = Field<1, 1>;    // Transmit Store and Forward
            using TXQEN = Field<2, 2>;    // Transmit Queue Enable
            using TTC = Field<4, 3>;    // Transmit Threshold Control
            using TQS = Field<16, 3>;    // Transmit Queue Size
        };

        // Tx queue underflow register
        struct MTLTxQUR : public RegisterReadOnly<0x40028d04> {
            using UFFRMCNT = Field<0, 11>;    // Underflow Packet Counter
            using UFCNTOVF = Field<11, 1>;    // UFCNTOVF
        };

        // Tx queue debug Register
        struct MTLTxQDR : public RegisterReadOnly<0x40028d08> {
            using TXQPAUSED = Field<0, 1>;    // TXQPAUSED
            using TRCSTS = Field<1, 2>;    // TRCSTS
            using TWCSTS = Field<3, 1>;    // TWCSTS
            using TXQSTS = Field<4, 1>;    // TXQSTS
            using TXSTSFSTS = Field<5, 1>;    // TXSTSFSTS
            using PTXQ = Field<16, 3>;    // PTXQ
            using STXSTSF = Field<20, 3>;    // STXSTSF
        };

        // Queue interrupt control status Register
        struct MTLQICSR : public Register<0x40028d2c> {
            using TXUNFIS = Field<0, 1>;    // TXUNFIS
            using TXUIE = Field<8, 1>;    // TXUIE
            using RXOVFIS = Field<16, 1>;    // RXOVFIS
            using RXOIE = Field<24, 1>;    // RXOIE
        };

        // Rx queue operating mode register
        struct MTLRxQOMR : public Register<0x40028d30> {
            using RTC = Field<0, 2>;    // RTC
            using FUP = Field<3, 1>;    // FUP
            using FEP = Field<4, 1>;    // FEP
            using RSF = Field<5, 1>;    // RSF
            using DIS_TCP_EF = Field<6, 1>;    // DIS_TCP_EF
            using EHFC = Field<7, 1>;    // EHFC
            using RFA = Field<8, 3>;    // RFA
            using RFD = Field<14, 3>;    // RFD
            using RQS = Field<20, 3>;    // RQS
        };

        // Rx queue missed packet and overflow counter register
        struct MTLRxQMPOCR : public RegisterReadOnly<0x40028d34> {
            using OVFPKTCNT = Field<0, 11>;    // OVFPKTCNT
            using OVFCNTOVF = Field<11, 1>;    // OVFCNTOVF
            using MISPKTCNT = Field<16, 11>;    // MISPKTCNT
            using MISCNTOVF = Field<27, 1>;    // MISCNTOVF
        };

        // Rx queue debug register
        struct MTLRxQDR : public RegisterReadOnly<0x40028d38> {
            using RWCSTS = Field<0, 1>;    // RWCSTS
            using RRCSTS = Field<1, 2>;    // RRCSTS
            using RXQSTS = Field<4, 2>;    // RXQSTS
            using PRXQ = Field<16, 14>;    // PRXQ
        };

    };

    // Ethernet: media access control (MAC)
    struct Ethernet_MAC {
        // Operating mode configuration register
        struct MACCR : public Register<0x40028000> {
            using RE = Field<0, 1>;    // Receiver Enable
            using TE = Field<1, 1>;    // TE
            using PRELEN = Field<2, 2>;    // PRELEN
            using DC = Field<4, 1>;    // DC
            using BL = Field<5, 2>;    // BL
            using DR = Field<8, 1>;    // DR
            using DCRS = Field<9, 1>;    // DCRS
            using DO = Field<10, 1>;    // DO
            using ECRSFD = Field<11, 1>;    // ECRSFD
            using LM = Field<12, 1>;    // LM
            using DM = Field<13, 1>;    // DM
            using FES = Field<14, 1>;    // FES
            using JE = Field<16, 1>;    // JE
            using JD = Field<17, 1>;    // JD
            using WD = Field<19, 1>;    // WD
            using ACS = Field<20, 1>;    // ACS
            using CST = Field<21, 1>;    // CST
            using S2KP = Field<22, 1>;    // S2KP
            using GPSLCE = Field<23, 1>;    // GPSLCE
            using IPG = Field<24, 3>;    // IPG
            using IPC = Field<27, 1>;    // IPC
            using SARC = Field<28, 3>;    // SARC
            using ARPEN = Field<31, 1>;    // ARPEN
        };

        // Extended operating mode configuration register
        struct MACECR : public Register<0x40028004> {
            using GPSL = Field<0, 14>;    // GPSL
            using DCRCC = Field<16, 1>;    // DCRCC
            using SPEN = Field<17, 1>;    // SPEN
            using USP = Field<18, 1>;    // USP
            using EIPGEN = Field<24, 1>;    // EIPGEN
            using EIPG = Field<25, 5>;    // EIPG
        };

        // Packet filtering control register
        struct MACPFR : public Register<0x40028008> {
            using PR = Field<0, 1>;    // PR
            using HUC = Field<1, 1>;    // HUC
            using HMC = Field<2, 1>;    // HMC
            using DAIF = Field<3, 1>;    // DAIF
            using PM = Field<4, 1>;    // PM
            using DBF = Field<5, 1>;    // DBF
            using PCF = Field<6, 2>;    // PCF
            using SAIF = Field<8, 1>;    // SAIF
            using SAF = Field<9, 1>;    // SAF
            using HPF = Field<10, 1>;    // HPF
            using VTFE = Field<16, 1>;    // VTFE
            using IPFE = Field<20, 1>;    // IPFE
            using DNTU = Field<21, 1>;    // DNTU
            using RA = Field<31, 1>;    // RA
        };

        // Watchdog timeout register
        struct MACWTR : public Register<0x4002800c> {
            using WTO = Field<0, 4>;    // WTO
            using PWE = Field<8, 1>;    // PWE
        };

        // Hash Table 0 register
        struct MACHT0R : public Register<0x40028010> {
            using HT31T0 = Field<0, 32>;    // HT31T0
        };

        // Hash Table 1 register
        struct MACHT1R : public Register<0x40028014> {
            using HT63T32 = Field<0, 32>;    // HT63T32
        };

        // VLAN tag register
        struct MACVTR : public Register<0x40028050> {
            using VL = Field<0, 16>;    // VL
            using ETV = Field<16, 1>;    // ETV
            using VTIM = Field<17, 1>;    // VTIM
            using ESVL = Field<18, 1>;    // ESVL
            using ERSVLM = Field<19, 1>;    // ERSVLM
            using DOVLTC = Field<20, 1>;    // DOVLTC
            using EVLS = Field<21, 2>;    // EVLS
            using EVLRXS = Field<24, 1>;    // EVLRXS
            using VTHM = Field<25, 1>;    // VTHM
            using EDVLP = Field<26, 1>;    // EDVLP
            using ERIVLT = Field<27, 1>;    // ERIVLT
            using EIVLS = Field<28, 2>;    // EIVLS
            using EIVLRXS = Field<31, 1>;    // EIVLRXS
        };

        // VLAN Hash table register
        struct MACVHTR : public Register<0x40028058> {
            using VLHT = Field<0, 16>;    // VLHT
        };

        // VLAN inclusion register
        struct MACVIR : public Register<0x40028060> {
            using VLT = Field<0, 16>;    // VLT
            using VLC = Field<16, 2>;    // VLC
            using VLP = Field<18, 1>;    // VLP
            using CSVL = Field<19, 1>;    // CSVL
            using VLTI = Field<20, 1>;    // VLTI
        };

        // Inner VLAN inclusion register
        struct MACIVIR : public Register<0x40028064> {
            using VLT = Field<0, 16>;    // VLT
            using VLC = Field<16, 2>;    // VLC
            using VLP = Field<18, 1>;    // VLP
            using CSVL = Field<19, 1>;    // CSVL
            using VLTI = Field<20, 1>;    // VLTI
        };

        // Tx Queue flow control register
        struct MACQTxFCR : public Register<0x40028070> {
            using FCB_BPA = Field<0, 1>;    // FCB_BPA
            using TFE = Field<1, 1>;    // TFE
            using PLT = Field<4, 3>;    // PLT
            using DZPQ = Field<7, 1>;    // DZPQ
            using PT = Field<16, 16>;    // PT
        };

        // Rx flow control register
        struct MACRxFCR : public Register<0x40028090> {
            using RFE = Field<0, 1>;    // RFE
            using UP = Field<1, 1>;    // UP
        };

        // Interrupt status register
        struct MACISR : public RegisterReadOnly<0x400280b0> {
            using PHYIS = Field<3, 1>;    // PHYIS
            using PMTIS = Field<4, 1>;    // PMTIS
            using LPIIS = Field<5, 1>;    // LPIIS
            using MMCIS = Field<8, 1>;    // MMCIS
            using MMCRXIS = Field<9, 1>;    // MMCRXIS
            using MMCTXIS = Field<10, 1>;    // MMCTXIS
            using TSIS = Field<12, 1>;    // TSIS
            using TXSTSIS = Field<13, 1>;    // TXSTSIS
            using RXSTSIS = Field<14, 1>;    // RXSTSIS
        };

        // Interrupt enable register
        struct MACIER : public Register<0x400280b4> {
            using PHYIE = Field<3, 1>;    // PHYIE
            using PMTIE = Field<4, 1>;    // PMTIE
            using LPIIE = Field<5, 1>;    // LPIIE
            using TSIE = Field<12, 1>;    // TSIE
            using TXSTSIE = Field<13, 1>;    // TXSTSIE
            using RXSTSIE = Field<14, 1>;    // RXSTSIE
        };

        // Rx Tx status register
        struct MACRxTxSR : public RegisterReadOnly<0x400280b8> {
            using TJT = Field<0, 1>;    // TJT
            using NCARR = Field<1, 1>;    // NCARR
            using LCARR = Field<2, 1>;    // LCARR
            using EXDEF = Field<3, 1>;    // EXDEF
            using LCOL = Field<4, 1>;    // LCOL
            using EXCOL = Field<5, 1>;    // LCOL
            using RWT = Field<8, 1>;    // RWT
        };

        // PMT control status register
        struct MACPCSR : public Register<0x400280c0> {
            using PWRDWN = Field<0, 1>;    // PWRDWN
            using MGKPKTEN = Field<1, 1>;    // MGKPKTEN
            using RWKPKTEN = Field<2, 1>;    // RWKPKTEN
            using MGKPRCVD = Field<5, 1>;    // MGKPRCVD
            using RWKPRCVD = Field<6, 1>;    // RWKPRCVD
            using GLBLUCAST = Field<9, 1>;    // GLBLUCAST
            using RWKPFE = Field<10, 1>;    // RWKPFE
            using RWKPTR = Field<24, 5>;    // RWKPTR
            using RWKFILTRST = Field<31, 1>;    // RWKFILTRST
        };

        // Remove wakeup packet filter register
        struct MACRWKPFR : public Register<0x400280c4> {
            using Field = Field<0, 32>;    // MACRWKPFR
        };

        // LPI control status register
        struct MACLCSR : public Register<0x400280d0> {
            using TLPIEN = Field<0, 1>;    // TLPIEN
            using TLPIEX = Field<1, 1>;    // TLPIEX
            using RLPIEN = Field<2, 1>;    // RLPIEN
            using RLPIEX = Field<3, 1>;    // RLPIEX
            using TLPIST = Field<8, 1>;    // TLPIST
            using RLPIST = Field<9, 1>;    // RLPIST
            using LPIEN = Field<16, 1>;    // LPIEN
            using PLS = Field<17, 1>;    // PLS
            using PLSEN = Field<18, 1>;    // PLSEN
            using LPITXA = Field<19, 1>;    // LPITXA
            using LPITE = Field<20, 1>;    // LPITE
        };

        // LPI timers control register
        struct MACLTCR : public Register<0x400280d4> {
            using TWT = Field<0, 16>;    // TWT
            using LST = Field<16, 10>;    // LST
        };

        // LPI entry timer register
        struct MACLETR : public Register<0x400280d8> {
            using LPIET = Field<0, 17>;    // LPIET
        };

        // 1-microsecond-tick counter register
        struct MAC1USTCR : public Register<0x400280dc> {
            using TIC_1US_CNTR = Field<0, 12>;    // TIC_1US_CNTR
        };

        // Version register
        struct MACVR : public RegisterReadOnly<0x40028110> {
            using SNPSVER = Field<0, 8>;    // SNPSVER
            using USERVER = Field<8, 8>;    // USERVER
        };

        // Debug register
        struct MACDR : public RegisterReadOnly<0x40028114> {
            using RPESTS = Field<0, 1>;    // RPESTS
            using RFCFCSTS = Field<1, 2>;    // RFCFCSTS
            using TPESTS = Field<16, 1>;    // TPESTS
            using TFCSTS = Field<17, 2>;    // TFCSTS
        };

        // HW feature 1 register
        struct MACHWF1R : public RegisterReadOnly<0x40028120> {
            using RXFIFOSIZE = Field<0, 5>;    // RXFIFOSIZE
            using TXFIFOSIZE = Field<6, 5>;    // TXFIFOSIZE
            using OSTEN = Field<11, 1>;    // OSTEN
            using PTOEN = Field<12, 1>;    // PTOEN
            using ADVTHWORD = Field<13, 1>;    // ADVTHWORD
            using ADDR64 = Field<14, 2>;    // ADDR64
            using DCBEN = Field<16, 1>;    // DCBEN
            using SPHEN = Field<17, 1>;    // SPHEN
            using TSOEN = Field<18, 1>;    // TSOEN
            using DBGMEMA = Field<19, 1>;    // DBGMEMA
            using AVSEL = Field<20, 1>;    // AVSEL
            using HASHTBLSZ = Field<24, 2>;    // HASHTBLSZ
            using L3L4FNUM = Field<27, 4>;    // L3L4FNUM
        };

        // HW feature 2 register
        struct MACHWF2R : public RegisterReadOnly<0x40028124> {
            using RXQCNT = Field<0, 4>;    // RXQCNT
            using TXQCNT = Field<6, 4>;    // TXQCNT
            using RXCHCNT = Field<12, 4>;    // RXCHCNT
            using TXCHCNT = Field<18, 4>;    // TXCHCNT
            using PPSOUTNUM = Field<24, 3>;    // PPSOUTNUM
            using AUXSNAPNUM = Field<28, 3>;    // AUXSNAPNUM
        };

        // MDIO address register
        struct MACMDIOAR : public Register<0x40028200> {
            using MB = Field<0, 1>;    // MB
            using C45E = Field<1, 1>;    // C45E
            using GOC = Field<2, 2>;    // GOC
            using SKAP = Field<4, 1>;    // SKAP
            using CR = Field<8, 4>;    // CR
            using NTC = Field<12, 3>;    // NTC
            using RDA = Field<16, 5>;    // RDA
            using PA = Field<21, 5>;    // PA
            using BTB = Field<26, 1>;    // BTB
            using PSE = Field<27, 1>;    // PSE
        };

        // MDIO data register
        struct MACMDIODR : public Register<0x40028204> {
            using MD = Field<0, 16>;    // MD
            using RA = Field<16, 16>;    // RA
        };

        // ARP address register
        struct MACARPAR : public Register<0x40028ae0> {
            using ARPPA = Field<0, 32>;    // ARPPA
        };

        // Address 0 high register
        struct MACA0HR : public Register<0x40028300> {
            using ADDRHI = Field<0, 16>;    // ADDRHI
            using AE = Field<31, 1>;    // AE
        };

        // Address 0 low register
        struct MACA0LR : public Register<0x40028304> {
            using ADDRLO = Field<0, 32>;    // ADDRLO
        };

        // Address 1 low register
        struct MACA1LR : public Register<0x4002830c> {
            using ADDRLO = Field<0, 32>;    // ADDRLO
        };

        // Address 2 low register
        struct MACA2LR : public Register<0x40028314> {
            using ADDRLO = Field<0, 32>;    // ADDRLO
        };

        // Address 1 high register
        struct MACA1HR : public Register<0x40028308> {
            using ADDRHI = Field<0, 16>;    // ADDRHI
            using MBC = Field<24, 6>;    // MBC
            using SA = Field<30, 1>;    // SA
            using AE = Field<31, 1>;    // AE
        };

        // Address 2 high register
        struct MACA2HR : public Register<0x40028310> {
            using ADDRHI = Field<0, 16>;    // ADDRHI
            using MBC = Field<24, 6>;    // MBC
            using SA = Field<30, 1>;    // SA
            using AE = Field<31, 1>;    // AE
        };

        // Address 3 high register
        struct MACA3HR : public Register<0x40028318> {
            using ADDRHI = Field<0, 16>;    // ADDRHI
            using MBC = Field<24, 6>;    // MBC
            using SA = Field<30, 1>;    // SA
            using AE = Field<31, 1>;    // AE
        };

        // Address 3 low register
        struct MACA3LR : public Register<0x4002831c> {
            using ADDRLO = Field<0, 32>;    // ADDRLO
        };

        // MMC control register
        struct MMC_CONTROL : public Register<0x40028700> {
            using CNTRST = Field<0, 1>;    // CNTRST
            using CNTSTOPRO = Field<1, 1>;    // CNTSTOPRO
            using RSTONRD = Field<2, 1>;    // RSTONRD
            using CNTFREEZ = Field<3, 1>;    // CNTFREEZ
            using CNTPRST = Field<4, 1>;    // CNTPRST
            using CNTPRSTLVL = Field<5, 1>;    // CNTPRSTLVL
            using UCDBC = Field<8, 1>;    // UCDBC
        };

        // MMC Rx interrupt register
        struct MMC_RX_INTERRUPT : public RegisterReadOnly<0x40028704> {
            using RXCRCERPIS = Field<5, 1>;    // RXCRCERPIS
            using RXALGNERPIS = Field<6, 1>;    // RXALGNERPIS
            using RXUCGPIS = Field<17, 1>;    // RXUCGPIS
            using RXLPIUSCIS = Field<26, 1>;    // RXLPIUSCIS
            using RXLPITRCIS = Field<27, 1>;    // RXLPITRCIS
        };

        // MMC Tx interrupt register
        struct MMC_TX_INTERRUPT : public RegisterReadOnly<0x40028708> {
            using TXSCOLGPIS = Field<14, 1>;    // TXSCOLGPIS
            using TXMCOLGPIS = Field<15, 1>;    // TXMCOLGPIS
            using TXGPKTIS = Field<21, 1>;    // TXGPKTIS
            using TXLPIUSCIS = Field<26, 1>;    // TXLPIUSCIS
            using TXLPITRCIS = Field<27, 1>;    // TXLPITRCIS
        };

        // MMC Rx interrupt mask register
        struct MMC_RX_INTERRUPT_MASK : public Register<0x4002870c> {
            using RXCRCERPIM = Field<5, 1>;    // RXCRCERPIM
            using RXALGNERPIM = Field<6, 1>;    // RXALGNERPIM
            using RXUCGPIM = Field<17, 1>;    // RXUCGPIM
            using RXLPIUSCIM = Field<26, 1>;    // RXLPIUSCIM
            using RXLPITRCIM = Field<27, 1>;    // RXLPITRCIM
        };

        // MMC Tx interrupt mask register
        struct MMC_TX_INTERRUPT_MASK : public Register<0x40028710> {
            using TXSCOLGPIM = Field<14, 1>;    // TXSCOLGPIM
            using TXMCOLGPIM = Field<15, 1>;    // TXMCOLGPIM
            using TXGPKTIM = Field<21, 1>;    // TXGPKTIM
            using TXLPIUSCIM = Field<26, 1>;    // TXLPIUSCIM
            using TXLPITRCIM = Field<27, 1>;    // TXLPITRCIM
        };

        // Tx single collision good packets register
        struct TX_SINGLE_COLLISION_GOOD_PACKETS : public RegisterReadOnly<0x4002874c> {
            using TXSNGLCOLG = Field<0, 32>;    // TXSNGLCOLG
        };

        // Tx multiple collision good packets register
        struct TX_MULTIPLE_COLLISION_GOOD_PACKETS : public RegisterReadOnly<0x40028750> {
            using TXMULTCOLG = Field<0, 32>;    // TXMULTCOLG
        };

        // Tx packet count good register
        struct TX_PACKET_COUNT_GOOD : public RegisterReadOnly<0x40028768> {
            using TXPKTG = Field<0, 32>;    // TXPKTG
        };

        // Rx CRC error packets register
        struct RX_CRC_ERROR_PACKETS : public RegisterReadOnly<0x40028794> {
            using RXCRCERR = Field<0, 32>;    // RXCRCERR
        };

        // Rx alignment error packets register
        struct RX_ALIGNMENT_ERROR_PACKETS : public RegisterReadOnly<0x40028798> {
            using RXALGNERR = Field<0, 32>;    // RXALGNERR
        };

        // Rx unicast packets good register
        struct RX_UNICAST_PACKETS_GOOD : public RegisterReadOnly<0x400287c4> {
            using RXUCASTG = Field<0, 32>;    // RXUCASTG
        };

        // Tx LPI microsecond timer register
        struct TX_LPI_USEC_CNTR : public RegisterReadOnly<0x400287ec> {
            using TXLPIUSC = Field<0, 32>;    // TXLPIUSC
        };

        // Tx LPI transition counter register
        struct TX_LPI_TRAN_CNTR : public RegisterReadOnly<0x400287f0> {
            using TXLPITRC = Field<0, 32>;    // TXLPITRC
        };

        // Rx LPI microsecond counter register
        struct RX_LPI_USEC_CNTR : public RegisterReadOnly<0x400287f4> {
            using RXLPIUSC = Field<0, 32>;    // RXLPIUSC
        };

        // Rx LPI transition counter register
        struct RX_LPI_TRAN_CNTR : public RegisterReadOnly<0x400287f8> {
            using RXLPITRC = Field<0, 32>;    // RXLPITRC
        };

        // L3 and L4 control 0 register
        struct MACL3L4C0R : public Register<0x40028900> {
            using L3PEN0 = Field<0, 1>;    // L3PEN0
            using L3SAM0 = Field<2, 1>;    // L3SAM0
            using L3SAIM0 = Field<3, 1>;    // L3SAIM0
            using L3DAM0 = Field<4, 1>;    // L3DAM0
            using L3DAIM0 = Field<5, 1>;    // L3DAIM0
            using L3HSBM0 = Field<6, 5>;    // L3HSBM0
            using L3HDBM0 = Field<11, 5>;    // L3HDBM0
            using L4PEN0 = Field<16, 1>;    // L4PEN0
            using L4SPM0 = Field<18, 1>;    // L4SPM0
            using L4SPIM0 = Field<19, 1>;    // L4SPIM0
            using L4DPM0 = Field<20, 1>;    // L4DPM0
            using L4DPIM0 = Field<21, 1>;    // L4DPIM0
        };

        // Layer4 address filter 0 register
        struct MACL4A0R : public Register<0x40028904> {
            using L4SP0 = Field<0, 16>;    // L4SP0
            using L4DP0 = Field<16, 16>;    // L4DP0
        };

        // MACL3A00R
        struct MACL3A00R : public Register<0x40028910> {
            using L3A00 = Field<0, 32>;    // L3A00
        };

        // Layer3 address 1 filter 0 register
        struct MACL3A10R : public Register<0x40028914> {
            using L3A10 = Field<0, 32>;    // L3A10
        };

        // Layer3 Address 2 filter 0 register
        struct MACL3A20 : public Register<0x40028918> {
            using L3A20 = Field<0, 32>;    // L3A20
        };

        // Layer3 Address 3 filter 0 register
        struct MACL3A30 : public Register<0x4002891c> {
            using L3A30 = Field<0, 32>;    // L3A30
        };

        // L3 and L4 control 1 register
        struct MACL3L4C1R : public Register<0x40028930> {
            using L3PEN1 = Field<0, 1>;    // L3PEN1
            using L3SAM1 = Field<2, 1>;    // L3SAM1
            using L3SAIM1 = Field<3, 1>;    // L3SAIM1
            using L3DAM1 = Field<4, 1>;    // L3DAM1
            using L3DAIM1 = Field<5, 1>;    // L3DAIM1
            using L3HSBM1 = Field<6, 5>;    // L3HSBM1
            using L3HDBM1 = Field<11, 5>;    // L3HDBM1
            using L4PEN1 = Field<16, 1>;    // L4PEN1
            using L4SPM1 = Field<18, 1>;    // L4SPM1
            using L4SPIM1 = Field<19, 1>;    // L4SPIM1
            using L4DPM1 = Field<20, 1>;    // L4DPM1
            using L4DPIM1 = Field<21, 1>;    // L4DPIM1
        };

        // Layer 4 address filter 1 register
        struct MACL4A1R : public Register<0x40028934> {
            using L4SP1 = Field<0, 16>;    // L4SP1
            using L4DP1 = Field<16, 16>;    // L4DP1
        };

        // Layer3 address 0 filter 1 Register
        struct MACL3A01R : public Register<0x40028940> {
            using L3A01 = Field<0, 32>;    // L3A01
        };

        // Layer3 address 1 filter 1 register
        struct MACL3A11R : public Register<0x40028944> {
            using L3A11 = Field<0, 32>;    // L3A11
        };

        // Layer3 address 2 filter 1 Register
        struct MACL3A21R : public Register<0x40028948> {
            using L3A21 = Field<0, 32>;    // L3A21
        };

        // Layer3 address 3 filter 1 register
        struct MACL3A31R : public Register<0x4002894c> {
            using L3A31 = Field<0, 32>;    // L3A31
        };

        // Timestamp control Register
        struct MACTSCR : public Register<0x40028b00> {
            using TSENA = Field<0, 1>;    // TSENA
            using TSCFUPDT = Field<1, 1>;    // TSCFUPDT
            using TSINIT = Field<2, 1>;    // TSINIT
            using TSUPDT = Field<3, 1>;    // TSUPDT
            using TSADDREG = Field<5, 1>;    // TSADDREG
            using TSENALL = Field<8, 1>;    // TSENALL
            using TSCTRLSSR = Field<9, 1>;    // TSCTRLSSR
            using TSVER2ENA = Field<10, 1>;    // TSVER2ENA
            using TSIPENA = Field<11, 1>;    // TSIPENA
            using TSIPV6ENA = Field<12, 1>;    // TSIPV6ENA
            using TSIPV4ENA = Field<13, 1>;    // TSIPV4ENA
            using TSEVNTENA = Field<14, 1>;    // TSEVNTENA
            using TSMSTRENA = Field<15, 1>;    // TSMSTRENA
            using SNAPTYPSEL = Field<16, 2>;    // SNAPTYPSEL
            using TSENMACADDR = Field<18, 1>;    // TSENMACADDR
            using CSC = Field<19, 1>;    // CSC
            using TXTSSTSM = Field<24, 1>;    // TXTSSTSM
        };

        // Sub-second increment register
        struct MACSSIR : public Register<0x40028b04> {
            using SNSINC = Field<8, 8>;    // SNSINC
            using SSINC = Field<16, 8>;    // SSINC
        };

        // System time seconds register
        struct MACSTSR : public RegisterReadOnly<0x40028b08> {
            using TSS = Field<0, 32>;    // TSS
        };

        // System time nanoseconds register
        struct MACSTNR : public RegisterReadOnly<0x40028b0c> {
            using TSSS = Field<0, 31>;    // TSSS
        };

        // System time seconds update register
        struct MACSTSUR : public Register<0x40028b10> {
            using TSS = Field<0, 32>;    // TSS
        };

        // System time nanoseconds update register
        struct MACSTNUR : public Register<0x40028b14> {
            using TSSS = Field<0, 31>;    // TSSS
            using ADDSUB = Field<31, 1>;    // ADDSUB
        };

        // Timestamp addend register
        struct MACTSAR : public Register<0x40028b18> {
            using TSAR = Field<0, 32>;    // TSAR
        };

        // Timestamp status register
        struct MACTSSR : public RegisterReadOnly<0x40028b20> {
            using TSSOVF = Field<0, 1>;    // TSSOVF
            using TSTARGT0 = Field<1, 1>;    // TSTARGT0
            using AUXTSTRIG = Field<2, 1>;    // AUXTSTRIG
            using TSTRGTERR0 = Field<3, 1>;    // TSTRGTERR0
            using TXTSSIS = Field<15, 1>;    // TXTSSIS
            using ATSSTN = Field<16, 4>;    // ATSSTN
            using ATSSTM = Field<24, 1>;    // ATSSTM
            using ATSNS = Field<25, 5>;    // ATSNS
        };

        // Tx timestamp status nanoseconds register
        struct MACTxTSSNR : public RegisterReadOnly<0x40028b30> {
            using TXTSSLO = Field<0, 31>;    // TXTSSLO
            using TXTSSMIS = Field<31, 1>;    // TXTSSMIS
        };

        // Tx timestamp status seconds register
        struct MACTxTSSSR : public RegisterReadOnly<0x40028b34> {
            using TXTSSHI = Field<0, 32>;    // TXTSSHI
        };

        // Auxiliary control register
        struct MACACR : public Register<0x40028b40> {
            using ATSFC = Field<0, 1>;    // ATSFC
            using ATSEN0 = Field<4, 1>;    // ATSEN0
            using ATSEN1 = Field<5, 1>;    // ATSEN1
            using ATSEN2 = Field<6, 1>;    // ATSEN2
            using ATSEN3 = Field<7, 1>;    // ATSEN3
        };

        // Auxiliary timestamp nanoseconds register
        struct MACATSNR : public RegisterReadOnly<0x40028b48> {
            using AUXTSLO = Field<0, 31>;    // AUXTSLO
        };

        // Auxiliary timestamp seconds register
        struct MACATSSR : public RegisterReadOnly<0x40028b4c> {
            using AUXTSHI = Field<0, 32>;    // AUXTSHI
        };

        // Timestamp Ingress asymmetric correction register
        struct MACTSIACR : public Register<0x40028b50> {
            using OSTIAC = Field<0, 32>;    // OSTIAC
        };

        // Timestamp Egress asymmetric correction register
        struct MACTSEACR : public Register<0x40028b54> {
            using OSTEAC = Field<0, 32>;    // OSTEAC
        };

        // Timestamp Ingress correction nanosecond register
        struct MACTSICNR : public Register<0x40028b58> {
            using TSIC = Field<0, 32>;    // TSIC
        };

        // Timestamp Egress correction nanosecond register
        struct MACTSECNR : public Register<0x40028b5c> {
            using TSEC = Field<0, 32>;    // TSEC
        };

        // PPS control register
        struct MACPPSCR : public Register<0x40028b70> {
            using PPSCTRL = Field<0, 4>;    // PPSCTRL
            using PPSEN0 = Field<4, 1>;    // PPSEN0
            using TRGTMODSEL0 = Field<5, 2>;    // TRGTMODSEL0
        };

        // PPS target time seconds register
        struct MACPPSTTSR : public Register<0x40028b80> {
            using TSTRH0 = Field<0, 31>;    // TSTRH0
        };

        // PPS target time nanoseconds register
        struct MACPPSTTNR : public Register<0x40028b84> {
            using TTSL0 = Field<0, 31>;    // TTSL0
            using TRGTBUSY0 = Field<31, 1>;    // TRGTBUSY0
        };

        // PPS interval register
        struct MACPPSIR : public Register<0x40028b88> {
            using PPSINT0 = Field<0, 32>;    // PPSINT0
        };

        // PPS width register
        struct MACPPSWR : public Register<0x40028b8c> {
            using PPSWIDTH0 = Field<0, 32>;    // PPSWIDTH0
        };

        // PTP Offload control register
        struct MACPOCR : public Register<0x40028bc0> {
            using PTOEN = Field<0, 1>;    // PTOEN
            using ASYNCEN = Field<1, 1>;    // ASYNCEN
            using APDREQEN = Field<2, 1>;    // APDREQEN
            using ASYNCTRIG = Field<4, 1>;    // ASYNCTRIG
            using APDREQTRIG = Field<5, 1>;    // APDREQTRIG
            using DRRDIS = Field<6, 1>;    // DRRDIS
            using DN = Field<8, 8>;    // DN
        };

        // PTP Source Port Identity 0 Register
        struct MACSPI0R : public Register<0x40028bc4> {
            using SPI0 = Field<0, 32>;    // SPI0
        };

        // PTP Source port identity 1 register
        struct MACSPI1R : public Register<0x40028bc8> {
            using SPI1 = Field<0, 32>;    // SPI1
        };

        // PTP Source port identity 2 register
        struct MACSPI2R : public Register<0x40028bcc> {
            using SPI2 = Field<0, 16>;    // SPI2
        };

        // Log message interval register
        struct MACLMIR : public Register<0x40028bd0> {
            using LSI = Field<0, 8>;    // LSI
            using DRSYNCR = Field<8, 3>;    // DRSYNCR
            using LMPDRI = Field<24, 8>;    // LMPDRI
        };

    };

    // DMA controller
    struct DMA1 {
        // low interrupt status register
        struct LISR : public RegisterReadOnly<0x40020000> {
            using TCIF3 = Field<27, 1>;    // Stream x transfer complete interrupt flag (x = 3..0)
            using HTIF3 = Field<26, 1>;    // Stream x half transfer interrupt flag (x=3..0)
            using TEIF3 = Field<25, 1>;    // Stream x transfer error interrupt flag (x=3..0)
            using DMEIF3 = Field<24, 1>;    // Stream x direct mode error interrupt flag (x=3..0)
            using FEIF3 = Field<22, 1>;    // Stream x FIFO error interrupt flag (x=3..0)
            using TCIF2 = Field<21, 1>;    // Stream x transfer complete interrupt flag (x = 3..0)
            using HTIF2 = Field<20, 1>;    // Stream x half transfer interrupt flag (x=3..0)
            using TEIF2 = Field<19, 1>;    // Stream x transfer error interrupt flag (x=3..0)
            using DMEIF2 = Field<18, 1>;    // Stream x direct mode error interrupt flag (x=3..0)
            using FEIF2 = Field<16, 1>;    // Stream x FIFO error interrupt flag (x=3..0)
            using TCIF1 = Field<11, 1>;    // Stream x transfer complete interrupt flag (x = 3..0)
            using HTIF1 = Field<10, 1>;    // Stream x half transfer interrupt flag (x=3..0)
            using TEIF1 = Field<9, 1>;    // Stream x transfer error interrupt flag (x=3..0)
            using DMEIF1 = Field<8, 1>;    // Stream x direct mode error interrupt flag (x=3..0)
            using FEIF1 = Field<6, 1>;    // Stream x FIFO error interrupt flag (x=3..0)
            using TCIF0 = Field<5, 1>;    // Stream x transfer complete interrupt flag (x = 3..0)
            using HTIF0 = Field<4, 1>;    // Stream x half transfer interrupt flag (x=3..0)
            using TEIF0 = Field<3, 1>;    // Stream x transfer error interrupt flag (x=3..0)
            using DMEIF0 = Field<2, 1>;    // Stream x direct mode error interrupt flag (x=3..0)
            using FEIF0 = Field<0, 1>;    // Stream x FIFO error interrupt flag (x=3..0)
        };

        // high interrupt status register
        struct HISR : public RegisterReadOnly<0x40020004> {
            using TCIF7 = Field<27, 1>;    // Stream x transfer complete interrupt flag (x=7..4)
            using HTIF7 = Field<26, 1>;    // Stream x half transfer interrupt flag (x=7..4)
            using TEIF7 = Field<25, 1>;    // Stream x transfer error interrupt flag (x=7..4)
            using DMEIF7 = Field<24, 1>;    // Stream x direct mode error interrupt flag (x=7..4)
            using FEIF7 = Field<22, 1>;    // Stream x FIFO error interrupt flag (x=7..4)
            using TCIF6 = Field<21, 1>;    // Stream x transfer complete interrupt flag (x=7..4)
            using HTIF6 = Field<20, 1>;    // Stream x half transfer interrupt flag (x=7..4)
            using TEIF6 = Field<19, 1>;    // Stream x transfer error interrupt flag (x=7..4)
            using DMEIF6 = Field<18, 1>;    // Stream x direct mode error interrupt flag (x=7..4)
            using FEIF6 = Field<16, 1>;    // Stream x FIFO error interrupt flag (x=7..4)
            using TCIF5 = Field<11, 1>;    // Stream x transfer complete interrupt flag (x=7..4)
            using HTIF5 = Field<10, 1>;    // Stream x half transfer interrupt flag (x=7..4)
            using TEIF5 = Field<9, 1>;    // Stream x transfer error interrupt flag (x=7..4)
            using DMEIF5 = Field<8, 1>;    // Stream x direct mode error interrupt flag (x=7..4)
            using FEIF5 = Field<6, 1>;    // Stream x FIFO error interrupt flag (x=7..4)
            using TCIF4 = Field<5, 1>;    // Stream x transfer complete interrupt flag (x=7..4)
            using HTIF4 = Field<4, 1>;    // Stream x half transfer interrupt flag (x=7..4)
            using TEIF4 = Field<3, 1>;    // Stream x transfer error interrupt flag (x=7..4)
            using DMEIF4 = Field<2, 1>;    // Stream x direct mode error interrupt flag (x=7..4)
            using FEIF4 = Field<0, 1>;    // Stream x FIFO error interrupt flag (x=7..4)
        };

        // low interrupt flag clear register
        struct LIFCR : public Register<0x40020008> {
            using CTCIF3 = Field<27, 1>;    // Stream x clear transfer complete interrupt flag (x = 3..0)
            using CHTIF3 = Field<26, 1>;    // Stream x clear half transfer interrupt flag (x = 3..0)
            using CTEIF3 = Field<25, 1>;    // Stream x clear transfer error interrupt flag (x = 3..0)
            using CDMEIF3 = Field<24, 1>;    // Stream x clear direct mode error interrupt flag (x = 3..0)
            using CFEIF3 = Field<22, 1>;    // Stream x clear FIFO error interrupt flag (x = 3..0)
            using CTCIF2 = Field<21, 1>;    // Stream x clear transfer complete interrupt flag (x = 3..0)
            using CHTIF2 = Field<20, 1>;    // Stream x clear half transfer interrupt flag (x = 3..0)
            using CTEIF2 = Field<19, 1>;    // Stream x clear transfer error interrupt flag (x = 3..0)
            using CDMEIF2 = Field<18, 1>;    // Stream x clear direct mode error interrupt flag (x = 3..0)
            using CFEIF2 = Field<16, 1>;    // Stream x clear FIFO error interrupt flag (x = 3..0)
            using CTCIF1 = Field<11, 1>;    // Stream x clear transfer complete interrupt flag (x = 3..0)
            using CHTIF1 = Field<10, 1>;    // Stream x clear half transfer interrupt flag (x = 3..0)
            using CTEIF1 = Field<9, 1>;    // Stream x clear transfer error interrupt flag (x = 3..0)
            using CDMEIF1 = Field<8, 1>;    // Stream x clear direct mode error interrupt flag (x = 3..0)
            using CFEIF1 = Field<6, 1>;    // Stream x clear FIFO error interrupt flag (x = 3..0)
            using CTCIF0 = Field<5, 1>;    // Stream x clear transfer complete interrupt flag (x = 3..0)
            using CHTIF0 = Field<4, 1>;    // Stream x clear half transfer interrupt flag (x = 3..0)
            using CTEIF0 = Field<3, 1>;    // Stream x clear transfer error interrupt flag (x = 3..0)
            using CDMEIF0 = Field<2, 1>;    // Stream x clear direct mode error interrupt flag (x = 3..0)
            using CFEIF0 = Field<0, 1>;    // Stream x clear FIFO error interrupt flag (x = 3..0)
        };

        // high interrupt flag clear register
        struct HIFCR : public Register<0x4002000c> {
            using CTCIF7 = Field<27, 1>;    // Stream x clear transfer complete interrupt flag (x = 7..4)
            using CHTIF7 = Field<26, 1>;    // Stream x clear half transfer interrupt flag (x = 7..4)
            using CTEIF7 = Field<25, 1>;    // Stream x clear transfer error interrupt flag (x = 7..4)
            using CDMEIF7 = Field<24, 1>;    // Stream x clear direct mode error interrupt flag (x = 7..4)
            using CFEIF7 = Field<22, 1>;    // Stream x clear FIFO error interrupt flag (x = 7..4)
            using CTCIF6 = Field<21, 1>;    // Stream x clear transfer complete interrupt flag (x = 7..4)
            using CHTIF6 = Field<20, 1>;    // Stream x clear half transfer interrupt flag (x = 7..4)
            using CTEIF6 = Field<19, 1>;    // Stream x clear transfer error interrupt flag (x = 7..4)
            using CDMEIF6 = Field<18, 1>;    // Stream x clear direct mode error interrupt flag (x = 7..4)
            using CFEIF6 = Field<16, 1>;    // Stream x clear FIFO error interrupt flag (x = 7..4)
            using CTCIF5 = Field<11, 1>;    // Stream x clear transfer complete interrupt flag (x = 7..4)
            using CHTIF5 = Field<10, 1>;    // Stream x clear half transfer interrupt flag (x = 7..4)
            using CTEIF5 = Field<9, 1>;    // Stream x clear transfer error interrupt flag (x = 7..4)
            using CDMEIF5 = Field<8, 1>;    // Stream x clear direct mode error interrupt flag (x = 7..4)
            using CFEIF5 = Field<6, 1>;    // Stream x clear FIFO error interrupt flag (x = 7..4)
            using CTCIF4 = Field<5, 1>;    // Stream x clear transfer complete interrupt flag (x = 7..4)
            using CHTIF4 = Field<4, 1>;    // Stream x clear half transfer interrupt flag (x = 7..4)
            using CTEIF4 = Field<3, 1>;    // Stream x clear transfer error interrupt flag (x = 7..4)
            using CDMEIF4 = Field<2, 1>;    // Stream x clear direct mode error interrupt flag (x = 7..4)
            using CFEIF4 = Field<0, 1>;    // Stream x clear FIFO error interrupt flag (x = 7..4)
        };

        // stream x configuration register
        struct S0CR : public Register<0x40020010> {
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S0NDTR : public Register<0x40020014> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S0PAR : public Register<0x40020018> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S0M0AR : public Register<0x4002001c> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S0M1AR : public Register<0x40020020> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S0FCR : public Register<0x40020024> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S1CR : public Register<0x40020028> {
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S1NDTR : public Register<0x4002002c> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S1PAR : public Register<0x40020030> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S1M0AR : public Register<0x40020034> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S1M1AR : public Register<0x40020038> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S1FCR : public Register<0x4002003c> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S2CR : public Register<0x40020040> {
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S2NDTR : public Register<0x40020044> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S2PAR : public Register<0x40020048> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S2M0AR : public Register<0x4002004c> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S2M1AR : public Register<0x40020050> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S2FCR : public Register<0x40020054> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S3CR : public Register<0x40020058> {
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S3NDTR : public Register<0x4002005c> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S3PAR : public Register<0x40020060> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S3M0AR : public Register<0x40020064> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S3M1AR : public Register<0x40020068> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S3FCR : public Register<0x4002006c> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S4CR : public Register<0x40020070> {
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S4NDTR : public Register<0x40020074> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S4PAR : public Register<0x40020078> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S4M0AR : public Register<0x4002007c> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S4M1AR : public Register<0x40020080> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S4FCR : public Register<0x40020084> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S5CR : public Register<0x40020088> {
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S5NDTR : public Register<0x4002008c> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S5PAR : public Register<0x40020090> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S5M0AR : public Register<0x40020094> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S5M1AR : public Register<0x40020098> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S5FCR : public Register<0x4002009c> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S6CR : public Register<0x400200a0> {
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S6NDTR : public Register<0x400200a4> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S6PAR : public Register<0x400200a8> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S6M0AR : public Register<0x400200ac> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S6M1AR : public Register<0x400200b0> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S6FCR : public Register<0x400200b4> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S7CR : public Register<0x400200b8> {
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S7NDTR : public Register<0x400200bc> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S7PAR : public Register<0x400200c0> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S7M0AR : public Register<0x400200c4> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S7M1AR : public Register<0x400200c8> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S7FCR : public Register<0x400200cc> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

    };

    // DMA controller
    struct DMA2 {
        // low interrupt status register
        struct LISR : public RegisterReadOnly<0x40020400> {
            using TCIF3 = Field<27, 1>;    // Stream x transfer complete interrupt flag (x = 3..0)
            using HTIF3 = Field<26, 1>;    // Stream x half transfer interrupt flag (x=3..0)
            using TEIF3 = Field<25, 1>;    // Stream x transfer error interrupt flag (x=3..0)
            using DMEIF3 = Field<24, 1>;    // Stream x direct mode error interrupt flag (x=3..0)
            using FEIF3 = Field<22, 1>;    // Stream x FIFO error interrupt flag (x=3..0)
            using TCIF2 = Field<21, 1>;    // Stream x transfer complete interrupt flag (x = 3..0)
            using HTIF2 = Field<20, 1>;    // Stream x half transfer interrupt flag (x=3..0)
            using TEIF2 = Field<19, 1>;    // Stream x transfer error interrupt flag (x=3..0)
            using DMEIF2 = Field<18, 1>;    // Stream x direct mode error interrupt flag (x=3..0)
            using FEIF2 = Field<16, 1>;    // Stream x FIFO error interrupt flag (x=3..0)
            using TCIF1 = Field<11, 1>;    // Stream x transfer complete interrupt flag (x = 3..0)
            using HTIF1 = Field<10, 1>;    // Stream x half transfer interrupt flag (x=3..0)
            using TEIF1 = Field<9, 1>;    // Stream x transfer error interrupt flag (x=3..0)
            using DMEIF1 = Field<8, 1>;    // Stream x direct mode error interrupt flag (x=3..0)
            using FEIF1 = Field<6, 1>;    // Stream x FIFO error interrupt flag (x=3..0)
            using TCIF0 = Field<5, 1>;    // Stream x transfer complete interrupt flag (x = 3..0)
            using HTIF0 = Field<4, 1>;    // Stream x half transfer interrupt flag (x=3..0)
            using TEIF0 = Field<3, 1>;    // Stream x transfer error interrupt flag (x=3..0)
            using DMEIF0 = Field<2, 1>;    // Stream x direct mode error interrupt flag (x=3..0)
            using FEIF0 = Field<0, 1>;    // Stream x FIFO error interrupt flag (x=3..0)
        };

        // high interrupt status register
        struct HISR : public RegisterReadOnly<0x40020404> {
            using TCIF7 = Field<27, 1>;    // Stream x transfer complete interrupt flag (x=7..4)
            using HTIF7 = Field<26, 1>;    // Stream x half transfer interrupt flag (x=7..4)
            using TEIF7 = Field<25, 1>;    // Stream x transfer error interrupt flag (x=7..4)
            using DMEIF7 = Field<24, 1>;    // Stream x direct mode error interrupt flag (x=7..4)
            using FEIF7 = Field<22, 1>;    // Stream x FIFO error interrupt flag (x=7..4)
            using TCIF6 = Field<21, 1>;    // Stream x transfer complete interrupt flag (x=7..4)
            using HTIF6 = Field<20, 1>;    // Stream x half transfer interrupt flag (x=7..4)
            using TEIF6 = Field<19, 1>;    // Stream x transfer error interrupt flag (x=7..4)
            using DMEIF6 = Field<18, 1>;    // Stream x direct mode error interrupt flag (x=7..4)
            using FEIF6 = Field<16, 1>;    // Stream x FIFO error interrupt flag (x=7..4)
            using TCIF5 = Field<11, 1>;    // Stream x transfer complete interrupt flag (x=7..4)
            using HTIF5 = Field<10, 1>;    // Stream x half transfer interrupt flag (x=7..4)
            using TEIF5 = Field<9, 1>;    // Stream x transfer error interrupt flag (x=7..4)
            using DMEIF5 = Field<8, 1>;    // Stream x direct mode error interrupt flag (x=7..4)
            using FEIF5 = Field<6, 1>;    // Stream x FIFO error interrupt flag (x=7..4)
            using TCIF4 = Field<5, 1>;    // Stream x transfer complete interrupt flag (x=7..4)
            using HTIF4 = Field<4, 1>;    // Stream x half transfer interrupt flag (x=7..4)
            using TEIF4 = Field<3, 1>;    // Stream x transfer error interrupt flag (x=7..4)
            using DMEIF4 = Field<2, 1>;    // Stream x direct mode error interrupt flag (x=7..4)
            using FEIF4 = Field<0, 1>;    // Stream x FIFO error interrupt flag (x=7..4)
        };

        // low interrupt flag clear register
        struct LIFCR : public Register<0x40020408> {
            using CTCIF3 = Field<27, 1>;    // Stream x clear transfer complete interrupt flag (x = 3..0)
            using CHTIF3 = Field<26, 1>;    // Stream x clear half transfer interrupt flag (x = 3..0)
            using CTEIF3 = Field<25, 1>;    // Stream x clear transfer error interrupt flag (x = 3..0)
            using CDMEIF3 = Field<24, 1>;    // Stream x clear direct mode error interrupt flag (x = 3..0)
            using CFEIF3 = Field<22, 1>;    // Stream x clear FIFO error interrupt flag (x = 3..0)
            using CTCIF2 = Field<21, 1>;    // Stream x clear transfer complete interrupt flag (x = 3..0)
            using CHTIF2 = Field<20, 1>;    // Stream x clear half transfer interrupt flag (x = 3..0)
            using CTEIF2 = Field<19, 1>;    // Stream x clear transfer error interrupt flag (x = 3..0)
            using CDMEIF2 = Field<18, 1>;    // Stream x clear direct mode error interrupt flag (x = 3..0)
            using CFEIF2 = Field<16, 1>;    // Stream x clear FIFO error interrupt flag (x = 3..0)
            using CTCIF1 = Field<11, 1>;    // Stream x clear transfer complete interrupt flag (x = 3..0)
            using CHTIF1 = Field<10, 1>;    // Stream x clear half transfer interrupt flag (x = 3..0)
            using CTEIF1 = Field<9, 1>;    // Stream x clear transfer error interrupt flag (x = 3..0)
            using CDMEIF1 = Field<8, 1>;    // Stream x clear direct mode error interrupt flag (x = 3..0)
            using CFEIF1 = Field<6, 1>;    // Stream x clear FIFO error interrupt flag (x = 3..0)
            using CTCIF0 = Field<5, 1>;    // Stream x clear transfer complete interrupt flag (x = 3..0)
            using CHTIF0 = Field<4, 1>;    // Stream x clear half transfer interrupt flag (x = 3..0)
            using CTEIF0 = Field<3, 1>;    // Stream x clear transfer error interrupt flag (x = 3..0)
            using CDMEIF0 = Field<2, 1>;    // Stream x clear direct mode error interrupt flag (x = 3..0)
            using CFEIF0 = Field<0, 1>;    // Stream x clear FIFO error interrupt flag (x = 3..0)
        };

        // high interrupt flag clear register
        struct HIFCR : public Register<0x4002040c> {
            using CTCIF7 = Field<27, 1>;    // Stream x clear transfer complete interrupt flag (x = 7..4)
            using CHTIF7 = Field<26, 1>;    // Stream x clear half transfer interrupt flag (x = 7..4)
            using CTEIF7 = Field<25, 1>;    // Stream x clear transfer error interrupt flag (x = 7..4)
            using CDMEIF7 = Field<24, 1>;    // Stream x clear direct mode error interrupt flag (x = 7..4)
            using CFEIF7 = Field<22, 1>;    // Stream x clear FIFO error interrupt flag (x = 7..4)
            using CTCIF6 = Field<21, 1>;    // Stream x clear transfer complete interrupt flag (x = 7..4)
            using CHTIF6 = Field<20, 1>;    // Stream x clear half transfer interrupt flag (x = 7..4)
            using CTEIF6 = Field<19, 1>;    // Stream x clear transfer error interrupt flag (x = 7..4)
            using CDMEIF6 = Field<18, 1>;    // Stream x clear direct mode error interrupt flag (x = 7..4)
            using CFEIF6 = Field<16, 1>;    // Stream x clear FIFO error interrupt flag (x = 7..4)
            using CTCIF5 = Field<11, 1>;    // Stream x clear transfer complete interrupt flag (x = 7..4)
            using CHTIF5 = Field<10, 1>;    // Stream x clear half transfer interrupt flag (x = 7..4)
            using CTEIF5 = Field<9, 1>;    // Stream x clear transfer error interrupt flag (x = 7..4)
            using CDMEIF5 = Field<8, 1>;    // Stream x clear direct mode error interrupt flag (x = 7..4)
            using CFEIF5 = Field<6, 1>;    // Stream x clear FIFO error interrupt flag (x = 7..4)
            using CTCIF4 = Field<5, 1>;    // Stream x clear transfer complete interrupt flag (x = 7..4)
            using CHTIF4 = Field<4, 1>;    // Stream x clear half transfer interrupt flag (x = 7..4)
            using CTEIF4 = Field<3, 1>;    // Stream x clear transfer error interrupt flag (x = 7..4)
            using CDMEIF4 = Field<2, 1>;    // Stream x clear direct mode error interrupt flag (x = 7..4)
            using CFEIF4 = Field<0, 1>;    // Stream x clear FIFO error interrupt flag (x = 7..4)
        };

        // stream x configuration register
        struct S0CR : public Register<0x40020410> {
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S0NDTR : public Register<0x40020414> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S0PAR : public Register<0x40020418> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S0M0AR : public Register<0x4002041c> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S0M1AR : public Register<0x40020420> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S0FCR : public Register<0x40020424> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S1CR : public Register<0x40020428> {
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S1NDTR : public Register<0x4002042c> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S1PAR : public Register<0x40020430> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S1M0AR : public Register<0x40020434> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S1M1AR : public Register<0x40020438> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S1FCR : public Register<0x4002043c> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S2CR : public Register<0x40020440> {
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S2NDTR : public Register<0x40020444> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S2PAR : public Register<0x40020448> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S2M0AR : public Register<0x4002044c> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S2M1AR : public Register<0x40020450> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S2FCR : public Register<0x40020454> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S3CR : public Register<0x40020458> {
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S3NDTR : public Register<0x4002045c> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S3PAR : public Register<0x40020460> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S3M0AR : public Register<0x40020464> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S3M1AR : public Register<0x40020468> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S3FCR : public Register<0x4002046c> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S4CR : public Register<0x40020470> {
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S4NDTR : public Register<0x40020474> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S4PAR : public Register<0x40020478> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S4M0AR : public Register<0x4002047c> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S4M1AR : public Register<0x40020480> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S4FCR : public Register<0x40020484> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S5CR : public Register<0x40020488> {
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S5NDTR : public Register<0x4002048c> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S5PAR : public Register<0x40020490> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S5M0AR : public Register<0x40020494> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S5M1AR : public Register<0x40020498> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S5FCR : public Register<0x4002049c> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S6CR : public Register<0x400204a0> {
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S6NDTR : public Register<0x400204a4> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S6PAR : public Register<0x400204a8> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S6M0AR : public Register<0x400204ac> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S6M1AR : public Register<0x400204b0> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S6FCR : public Register<0x400204b4> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

        // stream x configuration register
        struct S7CR : public Register<0x400204b8> {
            using MBURST = Field<23, 2>;    // Memory burst transfer configuration
            using PBURST = Field<21, 2>;    // Peripheral burst transfer configuration
            using ACK = Field<20, 1>;    // ACK
            using CT = Field<19, 1>;    // Current target (only in double buffer mode)
            using DBM = Field<18, 1>;    // Double buffer mode
            using PL = Field<16, 2>;    // Priority level
            using PINCOS = Field<15, 1>;    // Peripheral increment offset size
            using MSIZE = Field<13, 2>;    // Memory data size
            using PSIZE = Field<11, 2>;    // Peripheral data size
            using MINC = Field<10, 1>;    // Memory increment mode
            using PINC = Field<9, 1>;    // Peripheral increment mode
            using CIRC = Field<8, 1>;    // Circular mode
            using DIR = Field<6, 2>;    // Data transfer direction
            using PFCTRL = Field<5, 1>;    // Peripheral flow controller
            using TCIE = Field<4, 1>;    // Transfer complete interrupt enable
            using HTIE = Field<3, 1>;    // Half transfer interrupt enable
            using TEIE = Field<2, 1>;    // Transfer error interrupt enable
            using DMEIE = Field<1, 1>;    // Direct mode error interrupt enable
            using EN = Field<0, 1>;    // Stream enable / flag stream ready when read low
        };

        // stream x number of data register
        struct S7NDTR : public Register<0x400204bc> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // stream x peripheral address register
        struct S7PAR : public Register<0x400204c0> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // stream x memory 0 address register
        struct S7M0AR : public Register<0x400204c4> {
            using M0A = Field<0, 32>;    // Memory 0 address
        };

        // stream x memory 1 address register
        struct S7M1AR : public Register<0x400204c8> {
            using M1A = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // stream x FIFO control register
        struct S7FCR : public Register<0x400204cc> {
            using FEIE = Field<7, 1>;    // FIFO error interrupt enable
            using FS = Field<3, 3>;    // FIFO status
            using DMDIS = Field<2, 1>;    // Direct mode disable
            using FTH = Field<0, 2>;    // FIFO threshold selection
        };

    };

    // High Resolution Timer: Master Timers
    struct HRTIM_Master {
        // Master Timer Control Register
        struct MCR : public Register<0x40017400> {
            using BRSTDMA = Field<30, 2>;    // Burst DMA Update
            using MREPU = Field<29, 1>;    // Master Timer Repetition update
            using PREEN = Field<27, 1>;    // Preload enable
            using DACSYNC = Field<25, 2>;    // AC Synchronization
            using TECEN = Field<21, 1>;    // Timer E counter enable
            using TDCEN = Field<20, 1>;    // Timer D counter enable
            using TCCEN = Field<19, 1>;    // Timer C counter enable
            using TBCEN = Field<18, 1>;    // Timer B counter enable
            using TACEN = Field<17, 1>;    // Timer A counter enable
            using MCEN = Field<16, 1>;    // Master Counter enable
            using SYNC_SRC = Field<14, 2>;    // Synchronization source
            using SYNC_OUT = Field<12, 2>;    // Synchronization output
            using SYNCSTRTM = Field<11, 1>;    // Synchronization Starts Master
            using SYNCRSTM = Field<10, 1>;    // Synchronization Resets Master
            using SYNC_IN = Field<8, 2>;    // ynchronization input
            using HALF = Field<5, 1>;    // Half mode enable
            using RETRIG = Field<4, 1>;    // Master Re-triggerable mode
            using CONT = Field<3, 1>;    // Master Continuous mode
            using CK_PSC = Field<0, 3>;    // HRTIM Master Clock prescaler
        };

        // Master Timer Interrupt Status Register
        struct MISR : public RegisterReadOnly<0x40017404> {
            using MUPD = Field<6, 1>;    // Master Update Interrupt Flag
            using SYNC = Field<5, 1>;    // Sync Input Interrupt Flag
            using MREP = Field<4, 1>;    // Master Repetition Interrupt Flag
            using MCMP4 = Field<3, 1>;    // Master Compare 4 Interrupt Flag
            using MCMP3 = Field<2, 1>;    // Master Compare 3 Interrupt Flag
            using MCMP2 = Field<1, 1>;    // Master Compare 2 Interrupt Flag
            using MCMP1 = Field<0, 1>;    // Master Compare 1 Interrupt Flag
        };

        // Master Timer Interrupt Clear Register
        struct MICR : public RegisterWriteOnly<0x40017408> {
            using MUPDC = Field<6, 1>;    // Master update Interrupt flag clear
            using SYNCC = Field<5, 1>;    // Sync Input Interrupt flag clear
            using MREPC = Field<4, 1>;    // Repetition Interrupt flag clear
            using MCMP4C = Field<3, 1>;    // Master Compare 4 Interrupt flag clear
            using MCMP3C = Field<2, 1>;    // Master Compare 3 Interrupt flag clear
            using MCMP2C = Field<1, 1>;    // Master Compare 2 Interrupt flag clear
            using MCMP1C = Field<0, 1>;    // Master Compare 1 Interrupt flag clear
        };

        // MDIER4
        struct MDIER4 : public Register<0x4001740c> {
            using MUPDDE = Field<22, 1>;    // MUPDDE
            using SYNCDE = Field<21, 1>;    // SYNCDE
            using MREPDE = Field<20, 1>;    // MREPDE
            using MCMP4DE = Field<19, 1>;    // MCMP4DE
            using MCMP3DE = Field<18, 1>;    // MCMP3DE
            using MCMP2DE = Field<17, 1>;    // MCMP2DE
            using MCMP1DE = Field<16, 1>;    // MCMP1DE
            using MUPDIE = Field<6, 1>;    // MUPDIE
            using SYNCIE = Field<5, 1>;    // SYNCIE
            using MREPIE = Field<4, 1>;    // MREPIE
            using MCMP4IE = Field<3, 1>;    // MCMP4IE
            using MCMP3IE = Field<2, 1>;    // MCMP3IE
            using MCMP2IE = Field<1, 1>;    // MCMP2IE
            using MCMP1IE = Field<0, 1>;    // MCMP1IE
        };

        // Master Timer Counter Register
        struct MCNTR : public Register<0x40017410> {
            using MCNT = Field<0, 16>;    // Counter value
        };

        // Master Timer Period Register
        struct MPER : public Register<0x40017414> {
            using Field = Field<0, 16>;    // Master Timer Period value
        };

        // Master Timer Repetition Register
        struct MREP : public Register<0x40017418> {
            using Field = Field<0, 8>;    // Master Timer Repetition counter value
        };

        // Master Timer Compare 1 Register
        struct MCMP1R : public Register<0x4001741c> {
            using MCMP1 = Field<0, 16>;    // Master Timer Compare 1 value
        };

        // Master Timer Compare 2 Register
        struct MCMP2R : public Register<0x40017424> {
            using MCMP2 = Field<0, 16>;    // Master Timer Compare 2 value
        };

        // Master Timer Compare 3 Register
        struct MCMP3R : public Register<0x40017428> {
            using MCMP3 = Field<0, 16>;    // Master Timer Compare 3 value
        };

        // Master Timer Compare 4 Register
        struct MCMP4R : public Register<0x4001742c> {
            using MCMP4 = Field<0, 16>;    // Master Timer Compare 4 value
        };

    };

    // High Resolution Timer: TIMA
    struct HRTIM_TIMA {
        // Timerx Control Register
        struct TIMACR : public Register<0x40017480> {
            using UPDGAT = Field<28, 4>;    // Update Gating
            using PREEN = Field<27, 1>;    // Preload enable
            using DACSYNC = Field<25, 2>;    // AC Synchronization
            using MSTU = Field<24, 1>;    // Master Timer update
            using TEU = Field<23, 1>;    // TEU
            using TDU = Field<22, 1>;    // TDU
            using TCU = Field<21, 1>;    // TCU
            using TBU = Field<20, 1>;    // TBU
            using TxRSTU = Field<18, 1>;    // Timerx reset update
            using TxREPU = Field<17, 1>;    // Timer x Repetition update
            using DELCMP4 = Field<14, 2>;    // Delayed CMP4 mode
            using DELCMP2 = Field<12, 2>;    // Delayed CMP2 mode
            using SYNCSTRTx = Field<11, 1>;    // Synchronization Starts Timer x
            using SYNCRSTx = Field<10, 1>;    // Synchronization Resets Timer x
            using PSHPLL = Field<6, 1>;    // Push-Pull mode enable
            using HALF = Field<5, 1>;    // Half mode enable
            using RETRIG = Field<4, 1>;    // Re-triggerable mode
            using CONT = Field<3, 1>;    // Continuous mode
            using CK_PSCx = Field<0, 3>;    // HRTIM Timer x Clock prescaler
        };

        // Timerx Interrupt Status Register
        struct TIMAISR : public RegisterReadOnly<0x40017484> {
            using O2STAT = Field<19, 1>;    // Output 2 State
            using O1STAT = Field<18, 1>;    // Output 1 State
            using IPPSTAT = Field<17, 1>;    // Idle Push Pull Status
            using CPPSTAT = Field<16, 1>;    // Current Push Pull Status
            using DLYPRT = Field<14, 1>;    // Delayed Protection Flag
            using RST = Field<13, 1>;    // Reset Interrupt Flag
            using RSTx2 = Field<12, 1>;    // Output 2 Reset Interrupt Flag
            using SETx2 = Field<11, 1>;    // Output 2 Set Interrupt Flag
            using RSTx1 = Field<10, 1>;    // Output 1 Reset Interrupt Flag
            using SETx1 = Field<9, 1>;    // Output 1 Set Interrupt Flag
            using CPT2 = Field<8, 1>;    // Capture2 Interrupt Flag
            using CPT1 = Field<7, 1>;    // Capture1 Interrupt Flag
            using UPD = Field<6, 1>;    // Update Interrupt Flag
            using REP = Field<4, 1>;    // Repetition Interrupt Flag
            using CMP4 = Field<3, 1>;    // Compare 4 Interrupt Flag
            using CMP3 = Field<2, 1>;    // Compare 3 Interrupt Flag
            using CMP2 = Field<1, 1>;    // Compare 2 Interrupt Flag
            using CMP1 = Field<0, 1>;    // Compare 1 Interrupt Flag
        };

        // Timerx Interrupt Clear Register
        struct TIMAICR : public RegisterWriteOnly<0x40017488> {
            using DLYPRTC = Field<14, 1>;    // Delayed Protection Flag Clear
            using RSTC = Field<13, 1>;    // Reset Interrupt flag Clear
            using RSTx2C = Field<12, 1>;    // Output 2 Reset flag Clear
            using SET2xC = Field<11, 1>;    // Output 2 Set flag Clear
            using RSTx1C = Field<10, 1>;    // Output 1 Reset flag Clear
            using SET1xC = Field<9, 1>;    // Output 1 Set flag Clear
            using CPT2C = Field<8, 1>;    // Capture2 Interrupt flag Clear
            using CPT1C = Field<7, 1>;    // Capture1 Interrupt flag Clear
            using UPDC = Field<6, 1>;    // Update Interrupt flag Clear
            using REPC = Field<4, 1>;    // Repetition Interrupt flag Clear
            using CMP4C = Field<3, 1>;    // Compare 4 Interrupt flag Clear
            using CMP3C = Field<2, 1>;    // Compare 3 Interrupt flag Clear
            using CMP2C = Field<1, 1>;    // Compare 2 Interrupt flag Clear
            using CMP1C = Field<0, 1>;    // Compare 1 Interrupt flag Clear
        };

        // TIMxDIER5
        struct TIMADIER5 : public Register<0x4001748c> {
            using DLYPRTDE = Field<30, 1>;    // DLYPRTDE
            using RSTDE = Field<29, 1>;    // RSTDE
            using RSTx2DE = Field<28, 1>;    // RSTx2DE
            using SETx2DE = Field<27, 1>;    // SETx2DE
            using RSTx1DE = Field<26, 1>;    // RSTx1DE
            using SET1xDE = Field<25, 1>;    // SET1xDE
            using CPT2DE = Field<24, 1>;    // CPT2DE
            using CPT1DE = Field<23, 1>;    // CPT1DE
            using UPDDE = Field<22, 1>;    // UPDDE
            using REPDE = Field<20, 1>;    // REPDE
            using CMP4DE = Field<19, 1>;    // CMP4DE
            using CMP3DE = Field<18, 1>;    // CMP3DE
            using CMP2DE = Field<17, 1>;    // CMP2DE
            using CMP1DE = Field<16, 1>;    // CMP1DE
            using DLYPRTIE = Field<14, 1>;    // DLYPRTIE
            using RSTIE = Field<13, 1>;    // RSTIE
            using RSTx2IE = Field<12, 1>;    // RSTx2IE
            using SETx2IE = Field<11, 1>;    // SETx2IE
            using RSTx1IE = Field<10, 1>;    // RSTx1IE
            using SET1xIE = Field<9, 1>;    // SET1xIE
            using CPT2IE = Field<8, 1>;    // CPT2IE
            using CPT1IE = Field<7, 1>;    // CPT1IE
            using UPDIE = Field<6, 1>;    // UPDIE
            using REPIE = Field<4, 1>;    // REPIE
            using CMP4IE = Field<3, 1>;    // CMP4IE
            using CMP3IE = Field<2, 1>;    // CMP3IE
            using CMP2IE = Field<1, 1>;    // CMP2IE
            using CMP1IE = Field<0, 1>;    // CMP1IE
        };

        // Timerx Counter Register
        struct CNTAR : public Register<0x40017490> {
            using CNTx = Field<0, 16>;    // Timerx Counter value
        };

        // Timerx Period Register
        struct PERAR : public Register<0x40017494> {
            using PERx = Field<0, 16>;    // Timerx Period value
        };

        // Timerx Repetition Register
        struct REPAR : public Register<0x40017498> {
            using REPx = Field<0, 8>;    // Timerx Repetition counter value
        };

        // Timerx Compare 1 Register
        struct CMP1AR : public Register<0x4001749c> {
            using CMP1x = Field<0, 16>;    // Timerx Compare 1 value
        };

        // Timerx Compare 1 Compound Register
        struct CMP1CAR : public Register<0x400174a0> {
            using REPx = Field<16, 8>;    // Timerx Repetition value (aliased from HRTIM_REPx register)
            using CMP1x = Field<0, 16>;    // Timerx Compare 1 value
        };

        // Timerx Compare 2 Register
        struct CMP2AR : public Register<0x400174a4> {
            using CMP2x = Field<0, 16>;    // Timerx Compare 2 value
        };

        // Timerx Compare 3 Register
        struct CMP3AR : public Register<0x400174a8> {
            using CMP3x = Field<0, 16>;    // Timerx Compare 3 value
        };

        // Timerx Compare 4 Register
        struct CMP4AR : public Register<0x400174ac> {
            using CMP4x = Field<0, 16>;    // Timerx Compare 4 value
        };

        // Timerx Capture 1 Register
        struct CPT1AR : public RegisterReadOnly<0x400174b0> {
            using CPT1x = Field<0, 16>;    // Timerx Capture 1 value
        };

        // Timerx Capture 2 Register
        struct CPT2AR : public RegisterReadOnly<0x400174b4> {
            using CPT2x = Field<0, 16>;    // Timerx Capture 2 value
        };

        // Timerx Deadtime Register
        struct DTAR : public Register<0x400174b8> {
            using DTFLKx = Field<31, 1>;    // Deadtime Falling Lock
            using DTFSLKx = Field<30, 1>;    // Deadtime Falling Sign Lock
            using SDTFx = Field<25, 1>;    // Sign Deadtime Falling value
            using DTFx = Field<16, 9>;    // Deadtime Falling value
            using DTRLKx = Field<15, 1>;    // Deadtime Rising Lock
            using DTRSLKx = Field<14, 1>;    // Deadtime Rising Sign Lock
            using DTPRSC = Field<10, 3>;    // Deadtime Prescaler
            using SDTRx = Field<9, 1>;    // Sign Deadtime Rising value
            using DTRx = Field<0, 9>;    // Deadtime Rising value
        };

        // Timerx Output1 Set Register
        struct SETA1R : public Register<0x400174bc> {
            using UPDATE = Field<31, 1>;    // Registers update (transfer preload to active)
            using EXTEVNT10 = Field<30, 1>;    // External Event 10
            using EXTEVNT9 = Field<29, 1>;    // External Event 9
            using EXTEVNT8 = Field<28, 1>;    // External Event 8
            using EXTEVNT7 = Field<27, 1>;    // External Event 7
            using EXTEVNT6 = Field<26, 1>;    // External Event 6
            using EXTEVNT5 = Field<25, 1>;    // External Event 5
            using EXTEVNT4 = Field<24, 1>;    // External Event 4
            using EXTEVNT3 = Field<23, 1>;    // External Event 3
            using EXTEVNT2 = Field<22, 1>;    // External Event 2
            using EXTEVNT1 = Field<21, 1>;    // External Event 1
            using TIMEVNT9 = Field<20, 1>;    // Timer Event 9
            using TIMEVNT8 = Field<19, 1>;    // Timer Event 8
            using TIMEVNT7 = Field<18, 1>;    // Timer Event 7
            using TIMEVNT6 = Field<17, 1>;    // Timer Event 6
            using TIMEVNT5 = Field<16, 1>;    // Timer Event 5
            using TIMEVNT4 = Field<15, 1>;    // Timer Event 4
            using TIMEVNT3 = Field<14, 1>;    // Timer Event 3
            using TIMEVNT2 = Field<13, 1>;    // Timer Event 2
            using TIMEVNT1 = Field<12, 1>;    // Timer Event 1
            using MSTCMP4 = Field<11, 1>;    // Master Compare 4
            using MSTCMP3 = Field<10, 1>;    // Master Compare 3
            using MSTCMP2 = Field<9, 1>;    // Master Compare 2
            using MSTCMP1 = Field<8, 1>;    // Master Compare 1
            using MSTPER = Field<7, 1>;    // Master Period
            using CMP4 = Field<6, 1>;    // Timer A compare 4
            using CMP3 = Field<5, 1>;    // Timer A compare 3
            using CMP2 = Field<4, 1>;    // Timer A compare 2
            using CMP1 = Field<3, 1>;    // Timer A compare 1
            using PER = Field<2, 1>;    // Timer A Period
            using RESYNC = Field<1, 1>;    // Timer A resynchronizaton
            using SST = Field<0, 1>;    // Software Set trigger
        };

        // Timerx Output1 Reset Register
        struct RSTA1R : public Register<0x400174c0> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SRT = Field<0, 1>;    // SRT
        };

        // Timerx Output2 Set Register
        struct SETA2R : public Register<0x400174c4> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SST = Field<0, 1>;    // SST
        };

        // Timerx Output2 Reset Register
        struct RSTA2R : public Register<0x400174c8> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SRT = Field<0, 1>;    // SRT
        };

        // Timerx External Event Filtering Register 1
        struct EEFAR1 : public Register<0x400174cc> {
            using EE5FLTR = Field<25, 4>;    // External Event 5 filter
            using EE5LTCH = Field<24, 1>;    // External Event 5 latch
            using EE4FLTR = Field<19, 4>;    // External Event 4 filter
            using EE4LTCH = Field<18, 1>;    // External Event 4 latch
            using EE3FLTR = Field<13, 4>;    // External Event 3 filter
            using EE3LTCH = Field<12, 1>;    // External Event 3 latch
            using EE2FLTR = Field<7, 4>;    // External Event 2 filter
            using EE2LTCH = Field<6, 1>;    // External Event 2 latch
            using EE1FLTR = Field<1, 4>;    // External Event 1 filter
            using EE1LTCH = Field<0, 1>;    // External Event 1 latch
        };

        // Timerx External Event Filtering Register 2
        struct EEFAR2 : public Register<0x400174d0> {
            using EE10FLTR = Field<25, 4>;    // External Event 10 filter
            using EE10LTCH = Field<24, 1>;    // External Event 10 latch
            using EE9FLTR = Field<19, 4>;    // External Event 9 filter
            using EE9LTCH = Field<18, 1>;    // External Event 9 latch
            using EE8FLTR = Field<13, 4>;    // External Event 8 filter
            using EE8LTCH = Field<12, 1>;    // External Event 8 latch
            using EE7FLTR = Field<7, 4>;    // External Event 7 filter
            using EE7LTCH = Field<6, 1>;    // External Event 7 latch
            using EE6FLTR = Field<1, 4>;    // External Event 6 filter
            using EE6LTCH = Field<0, 1>;    // External Event 6 latch
        };

        // TimerA Reset Register
        struct RSTAR : public Register<0x400174d4> {
            using TIMECMP4 = Field<30, 1>;    // Timer E Compare 4
            using TIMECMP2 = Field<29, 1>;    // Timer E Compare 2
            using TIMECMP1 = Field<28, 1>;    // Timer E Compare 1
            using TIMDCMP4 = Field<27, 1>;    // Timer D Compare 4
            using TIMDCMP2 = Field<26, 1>;    // Timer D Compare 2
            using TIMDCMP1 = Field<25, 1>;    // Timer D Compare 1
            using TIMCCMP4 = Field<24, 1>;    // Timer C Compare 4
            using TIMCCMP2 = Field<23, 1>;    // Timer C Compare 2
            using TIMCCMP1 = Field<22, 1>;    // Timer C Compare 1
            using TIMBCMP4 = Field<21, 1>;    // Timer B Compare 4
            using TIMBCMP2 = Field<20, 1>;    // Timer B Compare 2
            using TIMBCMP1 = Field<19, 1>;    // Timer B Compare 1
            using EXTEVNT10 = Field<18, 1>;    // External Event 10
            using EXTEVNT9 = Field<17, 1>;    // External Event 9
            using EXTEVNT8 = Field<16, 1>;    // External Event 8
            using EXTEVNT7 = Field<15, 1>;    // External Event 7
            using EXTEVNT6 = Field<14, 1>;    // External Event 6
            using EXTEVNT5 = Field<13, 1>;    // External Event 5
            using EXTEVNT4 = Field<12, 1>;    // External Event 4
            using EXTEVNT3 = Field<11, 1>;    // External Event 3
            using EXTEVNT2 = Field<10, 1>;    // External Event 2
            using EXTEVNT1 = Field<9, 1>;    // External Event 1
            using MSTCMP4 = Field<8, 1>;    // Master compare 4
            using MSTCMP3 = Field<7, 1>;    // Master compare 3
            using MSTCMP2 = Field<6, 1>;    // Master compare 2
            using MSTCMP1 = Field<5, 1>;    // Master compare 1
            using MSTPER = Field<4, 1>;    // Master timer Period
            using CMP4 = Field<3, 1>;    // Timer A compare 4 reset
            using CMP2 = Field<2, 1>;    // Timer A compare 2 reset
            using UPDT = Field<1, 1>;    // Timer A Update reset
        };

        // Timerx Chopper Register
        struct CHPAR : public Register<0x400174d8> {
            using STRTPW = Field<7, 4>;    // STRTPW
            using CHPDTY = Field<4, 3>;    // Timerx chopper duty cycle value
            using CHPFRQ = Field<0, 4>;    // Timerx carrier frequency value
        };

        // Timerx Capture 2 Control Register
        struct CPT1ACR : public Register<0x400174dc> {
            using TECMP2 = Field<31, 1>;    // Timer E Compare 2
            using TECMP1 = Field<30, 1>;    // Timer E Compare 1
            using TE1RST = Field<29, 1>;    // Timer E output 1 Reset
            using TE1SET = Field<28, 1>;    // Timer E output 1 Set
            using TDCMP2 = Field<27, 1>;    // Timer D Compare 2
            using TDCMP1 = Field<26, 1>;    // Timer D Compare 1
            using TD1RST = Field<25, 1>;    // Timer D output 1 Reset
            using TD1SET = Field<24, 1>;    // Timer D output 1 Set
            using TCCMP2 = Field<23, 1>;    // Timer C Compare 2
            using TCCMP1 = Field<22, 1>;    // Timer C Compare 1
            using TC1RST = Field<21, 1>;    // Timer C output 1 Reset
            using TC1SET = Field<20, 1>;    // Timer C output 1 Set
            using TBCMP2 = Field<19, 1>;    // Timer B Compare 2
            using TBCMP1 = Field<18, 1>;    // Timer B Compare 1
            using TB1RST = Field<17, 1>;    // Timer B output 1 Reset
            using TB1SET = Field<16, 1>;    // Timer B output 1 Set
            using EXEV10CPT = Field<11, 1>;    // External Event 10 Capture
            using EXEV9CPT = Field<10, 1>;    // External Event 9 Capture
            using EXEV8CPT = Field<9, 1>;    // External Event 8 Capture
            using EXEV7CPT = Field<8, 1>;    // External Event 7 Capture
            using EXEV6CPT = Field<7, 1>;    // External Event 6 Capture
            using EXEV5CPT = Field<6, 1>;    // External Event 5 Capture
            using EXEV4CPT = Field<5, 1>;    // External Event 4 Capture
            using EXEV3CPT = Field<4, 1>;    // External Event 3 Capture
            using EXEV2CPT = Field<3, 1>;    // External Event 2 Capture
            using EXEV1CPT = Field<2, 1>;    // External Event 1 Capture
            using UDPCPT = Field<1, 1>;    // Update Capture
            using SWCPT = Field<0, 1>;    // Software Capture
        };

        // CPT2xCR
        struct CPT2ACR : public Register<0x400174e0> {
            using TECMP2 = Field<31, 1>;    // Timer E Compare 2
            using TECMP1 = Field<30, 1>;    // Timer E Compare 1
            using TE1RST = Field<29, 1>;    // Timer E output 1 Reset
            using TE1SET = Field<28, 1>;    // Timer E output 1 Set
            using TDCMP2 = Field<27, 1>;    // Timer D Compare 2
            using TDCMP1 = Field<26, 1>;    // Timer D Compare 1
            using TD1RST = Field<25, 1>;    // Timer D output 1 Reset
            using TD1SET = Field<24, 1>;    // Timer D output 1 Set
            using TCCMP2 = Field<23, 1>;    // Timer C Compare 2
            using TCCMP1 = Field<22, 1>;    // Timer C Compare 1
            using TC1RST = Field<21, 1>;    // Timer C output 1 Reset
            using TC1SET = Field<20, 1>;    // Timer C output 1 Set
            using TBCMP2 = Field<19, 1>;    // Timer B Compare 2
            using TBCMP1 = Field<18, 1>;    // Timer B Compare 1
            using TB1RST = Field<17, 1>;    // Timer B output 1 Reset
            using TB1SET = Field<16, 1>;    // Timer B output 1 Set
            using EXEV10CPT = Field<11, 1>;    // External Event 10 Capture
            using EXEV9CPT = Field<10, 1>;    // External Event 9 Capture
            using EXEV8CPT = Field<9, 1>;    // External Event 8 Capture
            using EXEV7CPT = Field<8, 1>;    // External Event 7 Capture
            using EXEV6CPT = Field<7, 1>;    // External Event 6 Capture
            using EXEV5CPT = Field<6, 1>;    // External Event 5 Capture
            using EXEV4CPT = Field<5, 1>;    // External Event 4 Capture
            using EXEV3CPT = Field<4, 1>;    // External Event 3 Capture
            using EXEV2CPT = Field<3, 1>;    // External Event 2 Capture
            using EXEV1CPT = Field<2, 1>;    // External Event 1 Capture
            using UDPCPT = Field<1, 1>;    // Update Capture
            using SWCPT = Field<0, 1>;    // Software Capture
        };

        // Timerx Output Register
        struct OUTAR : public Register<0x400174e4> {
            using DIDL2 = Field<23, 1>;    // Output 2 Deadtime upon burst mode Idle entry
            using CHP2 = Field<22, 1>;    // Output 2 Chopper enable
            using FAULT2 = Field<20, 2>;    // Output 2 Fault state
            using IDLES2 = Field<19, 1>;    // Output 2 Idle State
            using IDLEM2 = Field<18, 1>;    // Output 2 Idle mode
            using POL2 = Field<17, 1>;    // Output 2 polarity
            using DLYPRT = Field<10, 3>;    // Delayed Protection
            using DLYPRTEN = Field<9, 1>;    // Delayed Protection Enable
            using DTEN = Field<8, 1>;    // Deadtime enable
            using DIDL1 = Field<7, 1>;    // Output 1 Deadtime upon burst mode Idle entry
            using CHP1 = Field<6, 1>;    // Output 1 Chopper enable
            using FAULT1 = Field<4, 2>;    // Output 1 Fault state
            using IDLES1 = Field<3, 1>;    // Output 1 Idle State
            using IDLEM1 = Field<2, 1>;    // Output 1 Idle mode
            using POL1 = Field<1, 1>;    // Output 1 polarity
        };

        // Timerx Fault Register
        struct FLTAR : public Register<0x400174e8> {
            using FLTLCK = Field<31, 1>;    // Fault sources Lock
            using FLT5EN = Field<4, 1>;    // Fault 5 enable
            using FLT4EN = Field<3, 1>;    // Fault 4 enable
            using FLT3EN = Field<2, 1>;    // Fault 3 enable
            using FLT2EN = Field<1, 1>;    // Fault 2 enable
            using FLT1EN = Field<0, 1>;    // Fault 1 enable
        };

    };

    // High Resolution Timer: TIMB
    struct HRTIM_TIMB {
        // Timerx Control Register
        struct TIMBCR : public Register<0x40017500> {
            using UPDGAT = Field<28, 4>;    // Update Gating
            using PREEN = Field<27, 1>;    // Preload enable
            using DACSYNC = Field<25, 2>;    // AC Synchronization
            using MSTU = Field<24, 1>;    // Master Timer update
            using TEU = Field<23, 1>;    // TEU
            using TDU = Field<22, 1>;    // TDU
            using TCU = Field<21, 1>;    // TCU
            using TBU = Field<20, 1>;    // TBU
            using TxRSTU = Field<18, 1>;    // Timerx reset update
            using TxREPU = Field<17, 1>;    // Timer x Repetition update
            using DELCMP4 = Field<14, 2>;    // Delayed CMP4 mode
            using DELCMP2 = Field<12, 2>;    // Delayed CMP2 mode
            using SYNCSTRTx = Field<11, 1>;    // Synchronization Starts Timer x
            using SYNCRSTx = Field<10, 1>;    // Synchronization Resets Timer x
            using PSHPLL = Field<6, 1>;    // Push-Pull mode enable
            using HALF = Field<5, 1>;    // Half mode enable
            using RETRIG = Field<4, 1>;    // Re-triggerable mode
            using CONT = Field<3, 1>;    // Continuous mode
            using CK_PSCx = Field<0, 3>;    // HRTIM Timer x Clock prescaler
        };

        // Timerx Interrupt Status Register
        struct TIMBISR : public RegisterReadOnly<0x40017504> {
            using O2STAT = Field<19, 1>;    // Output 2 State
            using O1STAT = Field<18, 1>;    // Output 1 State
            using IPPSTAT = Field<17, 1>;    // Idle Push Pull Status
            using CPPSTAT = Field<16, 1>;    // Current Push Pull Status
            using DLYPRT = Field<14, 1>;    // Delayed Protection Flag
            using RST = Field<13, 1>;    // Reset Interrupt Flag
            using RSTx2 = Field<12, 1>;    // Output 2 Reset Interrupt Flag
            using SETx2 = Field<11, 1>;    // Output 2 Set Interrupt Flag
            using RSTx1 = Field<10, 1>;    // Output 1 Reset Interrupt Flag
            using SETx1 = Field<9, 1>;    // Output 1 Set Interrupt Flag
            using CPT2 = Field<8, 1>;    // Capture2 Interrupt Flag
            using CPT1 = Field<7, 1>;    // Capture1 Interrupt Flag
            using UPD = Field<6, 1>;    // Update Interrupt Flag
            using REP = Field<4, 1>;    // Repetition Interrupt Flag
            using CMP4 = Field<3, 1>;    // Compare 4 Interrupt Flag
            using CMP3 = Field<2, 1>;    // Compare 3 Interrupt Flag
            using CMP2 = Field<1, 1>;    // Compare 2 Interrupt Flag
            using CMP1 = Field<0, 1>;    // Compare 1 Interrupt Flag
        };

        // Timerx Interrupt Clear Register
        struct TIMBICR : public RegisterWriteOnly<0x40017508> {
            using DLYPRTC = Field<14, 1>;    // Delayed Protection Flag Clear
            using RSTC = Field<13, 1>;    // Reset Interrupt flag Clear
            using RSTx2C = Field<12, 1>;    // Output 2 Reset flag Clear
            using SET2xC = Field<11, 1>;    // Output 2 Set flag Clear
            using RSTx1C = Field<10, 1>;    // Output 1 Reset flag Clear
            using SET1xC = Field<9, 1>;    // Output 1 Set flag Clear
            using CPT2C = Field<8, 1>;    // Capture2 Interrupt flag Clear
            using CPT1C = Field<7, 1>;    // Capture1 Interrupt flag Clear
            using UPDC = Field<6, 1>;    // Update Interrupt flag Clear
            using REPC = Field<4, 1>;    // Repetition Interrupt flag Clear
            using CMP4C = Field<3, 1>;    // Compare 4 Interrupt flag Clear
            using CMP3C = Field<2, 1>;    // Compare 3 Interrupt flag Clear
            using CMP2C = Field<1, 1>;    // Compare 2 Interrupt flag Clear
            using CMP1C = Field<0, 1>;    // Compare 1 Interrupt flag Clear
        };

        // TIMxDIER5
        struct TIMBDIER5 : public Register<0x4001750c> {
            using DLYPRTDE = Field<30, 1>;    // DLYPRTDE
            using RSTDE = Field<29, 1>;    // RSTDE
            using RSTx2DE = Field<28, 1>;    // RSTx2DE
            using SETx2DE = Field<27, 1>;    // SETx2DE
            using RSTx1DE = Field<26, 1>;    // RSTx1DE
            using SET1xDE = Field<25, 1>;    // SET1xDE
            using CPT2DE = Field<24, 1>;    // CPT2DE
            using CPT1DE = Field<23, 1>;    // CPT1DE
            using UPDDE = Field<22, 1>;    // UPDDE
            using REPDE = Field<20, 1>;    // REPDE
            using CMP4DE = Field<19, 1>;    // CMP4DE
            using CMP3DE = Field<18, 1>;    // CMP3DE
            using CMP2DE = Field<17, 1>;    // CMP2DE
            using CMP1DE = Field<16, 1>;    // CMP1DE
            using DLYPRTIE = Field<14, 1>;    // DLYPRTIE
            using RSTIE = Field<13, 1>;    // RSTIE
            using RSTx2IE = Field<12, 1>;    // RSTx2IE
            using SETx2IE = Field<11, 1>;    // SETx2IE
            using RSTx1IE = Field<10, 1>;    // RSTx1IE
            using SET1xIE = Field<9, 1>;    // SET1xIE
            using CPT2IE = Field<8, 1>;    // CPT2IE
            using CPT1IE = Field<7, 1>;    // CPT1IE
            using UPDIE = Field<6, 1>;    // UPDIE
            using REPIE = Field<4, 1>;    // REPIE
            using CMP4IE = Field<3, 1>;    // CMP4IE
            using CMP3IE = Field<2, 1>;    // CMP3IE
            using CMP2IE = Field<1, 1>;    // CMP2IE
            using CMP1IE = Field<0, 1>;    // CMP1IE
        };

        // Timerx Counter Register
        struct CNTR : public Register<0x40017510> {
            using CNTx = Field<0, 16>;    // Timerx Counter value
        };

        // Timerx Period Register
        struct PERBR : public Register<0x40017514> {
            using PERx = Field<0, 16>;    // Timerx Period value
        };

        // Timerx Repetition Register
        struct REPBR : public Register<0x40017518> {
            using REPx = Field<0, 8>;    // Timerx Repetition counter value
        };

        // Timerx Compare 1 Register
        struct CMP1BR : public Register<0x4001751c> {
            using CMP1x = Field<0, 16>;    // Timerx Compare 1 value
        };

        // Timerx Compare 1 Compound Register
        struct CMP1CBR : public Register<0x40017520> {
            using REPx = Field<16, 8>;    // Timerx Repetition value (aliased from HRTIM_REPx register)
            using CMP1x = Field<0, 16>;    // Timerx Compare 1 value
        };

        // Timerx Compare 2 Register
        struct CMP2BR : public Register<0x40017524> {
            using CMP2x = Field<0, 16>;    // Timerx Compare 2 value
        };

        // Timerx Compare 3 Register
        struct CMP3BR : public Register<0x40017528> {
            using CMP3x = Field<0, 16>;    // Timerx Compare 3 value
        };

        // Timerx Compare 4 Register
        struct CMP4BR : public Register<0x4001752c> {
            using CMP4x = Field<0, 16>;    // Timerx Compare 4 value
        };

        // Timerx Capture 1 Register
        struct CPT1BR : public RegisterReadOnly<0x40017530> {
            using CPT1x = Field<0, 16>;    // Timerx Capture 1 value
        };

        // Timerx Capture 2 Register
        struct CPT2BR : public RegisterReadOnly<0x40017534> {
            using CPT2x = Field<0, 16>;    // Timerx Capture 2 value
        };

        // Timerx Deadtime Register
        struct DTBR : public Register<0x40017538> {
            using DTFLKx = Field<31, 1>;    // Deadtime Falling Lock
            using DTFSLKx = Field<30, 1>;    // Deadtime Falling Sign Lock
            using SDTFx = Field<25, 1>;    // Sign Deadtime Falling value
            using DTFx = Field<16, 9>;    // Deadtime Falling value
            using DTRLKx = Field<15, 1>;    // Deadtime Rising Lock
            using DTRSLKx = Field<14, 1>;    // Deadtime Rising Sign Lock
            using DTPRSC = Field<10, 3>;    // Deadtime Prescaler
            using SDTRx = Field<9, 1>;    // Sign Deadtime Rising value
            using DTRx = Field<0, 9>;    // Deadtime Rising value
        };

        // Timerx Output1 Set Register
        struct SETB1R : public Register<0x4001753c> {
            using UPDATE = Field<31, 1>;    // Registers update (transfer preload to active)
            using EXTEVNT10 = Field<30, 1>;    // External Event 10
            using EXTEVNT9 = Field<29, 1>;    // External Event 9
            using EXTEVNT8 = Field<28, 1>;    // External Event 8
            using EXTEVNT7 = Field<27, 1>;    // External Event 7
            using EXTEVNT6 = Field<26, 1>;    // External Event 6
            using EXTEVNT5 = Field<25, 1>;    // External Event 5
            using EXTEVNT4 = Field<24, 1>;    // External Event 4
            using EXTEVNT3 = Field<23, 1>;    // External Event 3
            using EXTEVNT2 = Field<22, 1>;    // External Event 2
            using EXTEVNT1 = Field<21, 1>;    // External Event 1
            using TIMEVNT9 = Field<20, 1>;    // Timer Event 9
            using TIMEVNT8 = Field<19, 1>;    // Timer Event 8
            using TIMEVNT7 = Field<18, 1>;    // Timer Event 7
            using TIMEVNT6 = Field<17, 1>;    // Timer Event 6
            using TIMEVNT5 = Field<16, 1>;    // Timer Event 5
            using TIMEVNT4 = Field<15, 1>;    // Timer Event 4
            using TIMEVNT3 = Field<14, 1>;    // Timer Event 3
            using TIMEVNT2 = Field<13, 1>;    // Timer Event 2
            using TIMEVNT1 = Field<12, 1>;    // Timer Event 1
            using MSTCMP4 = Field<11, 1>;    // Master Compare 4
            using MSTCMP3 = Field<10, 1>;    // Master Compare 3
            using MSTCMP2 = Field<9, 1>;    // Master Compare 2
            using MSTCMP1 = Field<8, 1>;    // Master Compare 1
            using MSTPER = Field<7, 1>;    // Master Period
            using CMP4 = Field<6, 1>;    // Timer A compare 4
            using CMP3 = Field<5, 1>;    // Timer A compare 3
            using CMP2 = Field<4, 1>;    // Timer A compare 2
            using CMP1 = Field<3, 1>;    // Timer A compare 1
            using PER = Field<2, 1>;    // Timer A Period
            using RESYNC = Field<1, 1>;    // Timer A resynchronizaton
            using SST = Field<0, 1>;    // Software Set trigger
        };

        // Timerx Output1 Reset Register
        struct RSTB1R : public Register<0x40017540> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SRT = Field<0, 1>;    // SRT
        };

        // Timerx Output2 Set Register
        struct SETB2R : public Register<0x40017544> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SST = Field<0, 1>;    // SST
        };

        // Timerx Output2 Reset Register
        struct RSTB2R : public Register<0x40017548> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SRT = Field<0, 1>;    // SRT
        };

        // Timerx External Event Filtering Register 1
        struct EEFBR1 : public Register<0x4001754c> {
            using EE5FLTR = Field<25, 4>;    // External Event 5 filter
            using EE5LTCH = Field<24, 1>;    // External Event 5 latch
            using EE4FLTR = Field<19, 4>;    // External Event 4 filter
            using EE4LTCH = Field<18, 1>;    // External Event 4 latch
            using EE3FLTR = Field<13, 4>;    // External Event 3 filter
            using EE3LTCH = Field<12, 1>;    // External Event 3 latch
            using EE2FLTR = Field<7, 4>;    // External Event 2 filter
            using EE2LTCH = Field<6, 1>;    // External Event 2 latch
            using EE1FLTR = Field<1, 4>;    // External Event 1 filter
            using EE1LTCH = Field<0, 1>;    // External Event 1 latch
        };

        // Timerx External Event Filtering Register 2
        struct EEFBR2 : public Register<0x40017550> {
            using EE10FLTR = Field<25, 4>;    // External Event 10 filter
            using EE10LTCH = Field<24, 1>;    // External Event 10 latch
            using EE9FLTR = Field<19, 4>;    // External Event 9 filter
            using EE9LTCH = Field<18, 1>;    // External Event 9 latch
            using EE8FLTR = Field<13, 4>;    // External Event 8 filter
            using EE8LTCH = Field<12, 1>;    // External Event 8 latch
            using EE7FLTR = Field<7, 4>;    // External Event 7 filter
            using EE7LTCH = Field<6, 1>;    // External Event 7 latch
            using EE6FLTR = Field<1, 4>;    // External Event 6 filter
            using EE6LTCH = Field<0, 1>;    // External Event 6 latch
        };

        // TimerA Reset Register
        struct RSTBR : public Register<0x40017554> {
            using TIMECMP4 = Field<30, 1>;    // Timer E Compare 4
            using TIMECMP2 = Field<29, 1>;    // Timer E Compare 2
            using TIMECMP1 = Field<28, 1>;    // Timer E Compare 1
            using TIMDCMP4 = Field<27, 1>;    // Timer D Compare 4
            using TIMDCMP2 = Field<26, 1>;    // Timer D Compare 2
            using TIMDCMP1 = Field<25, 1>;    // Timer D Compare 1
            using TIMCCMP4 = Field<24, 1>;    // Timer C Compare 4
            using TIMCCMP2 = Field<23, 1>;    // Timer C Compare 2
            using TIMCCMP1 = Field<22, 1>;    // Timer C Compare 1
            using TIMACMP4 = Field<21, 1>;    // Timer A Compare 4
            using TIMACMP2 = Field<20, 1>;    // Timer A Compare 2
            using TIMACMP1 = Field<19, 1>;    // Timer A Compare 1
            using EXTEVNT10 = Field<18, 1>;    // External Event 10
            using EXTEVNT9 = Field<17, 1>;    // External Event 9
            using EXTEVNT8 = Field<16, 1>;    // External Event 8
            using EXTEVNT7 = Field<15, 1>;    // External Event 7
            using EXTEVNT6 = Field<14, 1>;    // External Event 6
            using EXTEVNT5 = Field<13, 1>;    // External Event 5
            using EXTEVNT4 = Field<12, 1>;    // External Event 4
            using EXTEVNT3 = Field<11, 1>;    // External Event 3
            using EXTEVNT2 = Field<10, 1>;    // External Event 2
            using EXTEVNT1 = Field<9, 1>;    // External Event 1
            using MSTCMP4 = Field<8, 1>;    // Master compare 4
            using MSTCMP3 = Field<7, 1>;    // Master compare 3
            using MSTCMP2 = Field<6, 1>;    // Master compare 2
            using MSTCMP1 = Field<5, 1>;    // Master compare 1
            using MSTPER = Field<4, 1>;    // Master timer Period
            using CMP4 = Field<3, 1>;    // Timer A compare 4 reset
            using CMP2 = Field<2, 1>;    // Timer A compare 2 reset
            using UPDT = Field<1, 1>;    // Timer A Update reset
        };

        // Timerx Chopper Register
        struct CHPBR : public Register<0x40017558> {
            using STRTPW = Field<7, 4>;    // STRTPW
            using CHPDTY = Field<4, 3>;    // Timerx chopper duty cycle value
            using CHPFRQ = Field<0, 4>;    // Timerx carrier frequency value
        };

        // Timerx Capture 2 Control Register
        struct CPT1BCR : public Register<0x4001755c> {
            using TECMP2 = Field<31, 1>;    // Timer E Compare 2
            using TECMP1 = Field<30, 1>;    // Timer E Compare 1
            using TE1RST = Field<29, 1>;    // Timer E output 1 Reset
            using TE1SET = Field<28, 1>;    // Timer E output 1 Set
            using TDCMP2 = Field<27, 1>;    // Timer D Compare 2
            using TDCMP1 = Field<26, 1>;    // Timer D Compare 1
            using TD1RST = Field<25, 1>;    // Timer D output 1 Reset
            using TD1SET = Field<24, 1>;    // Timer D output 1 Set
            using TCCMP2 = Field<23, 1>;    // Timer C Compare 2
            using TCCMP1 = Field<22, 1>;    // Timer C Compare 1
            using TC1RST = Field<21, 1>;    // Timer C output 1 Reset
            using TC1SET = Field<20, 1>;    // Timer C output 1 Set
            using TACMP2 = Field<15, 1>;    // Timer A Compare 2
            using TACMP1 = Field<14, 1>;    // Timer A Compare 1
            using TA1RST = Field<13, 1>;    // Timer A output 1 Reset
            using TA1SET = Field<12, 1>;    // Timer A output 1 Set
            using EXEV10CPT = Field<11, 1>;    // External Event 10 Capture
            using EXEV9CPT = Field<10, 1>;    // External Event 9 Capture
            using EXEV8CPT = Field<9, 1>;    // External Event 8 Capture
            using EXEV7CPT = Field<8, 1>;    // External Event 7 Capture
            using EXEV6CPT = Field<7, 1>;    // External Event 6 Capture
            using EXEV5CPT = Field<6, 1>;    // External Event 5 Capture
            using EXEV4CPT = Field<5, 1>;    // External Event 4 Capture
            using EXEV3CPT = Field<4, 1>;    // External Event 3 Capture
            using EXEV2CPT = Field<3, 1>;    // External Event 2 Capture
            using EXEV1CPT = Field<2, 1>;    // External Event 1 Capture
            using UDPCPT = Field<1, 1>;    // Update Capture
            using SWCPT = Field<0, 1>;    // Software Capture
        };

        // CPT2xCR
        struct CPT2BCR : public Register<0x40017560> {
            using TECMP2 = Field<31, 1>;    // Timer E Compare 2
            using TECMP1 = Field<30, 1>;    // Timer E Compare 1
            using TE1RST = Field<29, 1>;    // Timer E output 1 Reset
            using TE1SET = Field<28, 1>;    // Timer E output 1 Set
            using TDCMP2 = Field<27, 1>;    // Timer D Compare 2
            using TDCMP1 = Field<26, 1>;    // Timer D Compare 1
            using TD1RST = Field<25, 1>;    // Timer D output 1 Reset
            using TD1SET = Field<24, 1>;    // Timer D output 1 Set
            using TCCMP2 = Field<23, 1>;    // Timer C Compare 2
            using TCCMP1 = Field<22, 1>;    // Timer C Compare 1
            using TC1RST = Field<21, 1>;    // Timer C output 1 Reset
            using TC1SET = Field<20, 1>;    // Timer C output 1 Set
            using TACMP2 = Field<15, 1>;    // Timer A Compare 2
            using TACMP1 = Field<14, 1>;    // Timer A Compare 1
            using TA1RST = Field<13, 1>;    // Timer A output 1 Reset
            using TA1SET = Field<12, 1>;    // Timer A output 1 Set
            using EXEV10CPT = Field<11, 1>;    // External Event 10 Capture
            using EXEV9CPT = Field<10, 1>;    // External Event 9 Capture
            using EXEV8CPT = Field<9, 1>;    // External Event 8 Capture
            using EXEV7CPT = Field<8, 1>;    // External Event 7 Capture
            using EXEV6CPT = Field<7, 1>;    // External Event 6 Capture
            using EXEV5CPT = Field<6, 1>;    // External Event 5 Capture
            using EXEV4CPT = Field<5, 1>;    // External Event 4 Capture
            using EXEV3CPT = Field<4, 1>;    // External Event 3 Capture
            using EXEV2CPT = Field<3, 1>;    // External Event 2 Capture
            using EXEV1CPT = Field<2, 1>;    // External Event 1 Capture
            using UDPCPT = Field<1, 1>;    // Update Capture
            using SWCPT = Field<0, 1>;    // Software Capture
        };

        // Timerx Output Register
        struct OUTBR : public Register<0x40017564> {
            using DIDL2 = Field<23, 1>;    // Output 2 Deadtime upon burst mode Idle entry
            using CHP2 = Field<22, 1>;    // Output 2 Chopper enable
            using FAULT2 = Field<20, 2>;    // Output 2 Fault state
            using IDLES2 = Field<19, 1>;    // Output 2 Idle State
            using IDLEM2 = Field<18, 1>;    // Output 2 Idle mode
            using POL2 = Field<17, 1>;    // Output 2 polarity
            using DLYPRT = Field<10, 3>;    // Delayed Protection
            using DLYPRTEN = Field<9, 1>;    // Delayed Protection Enable
            using DTEN = Field<8, 1>;    // Deadtime enable
            using DIDL1 = Field<7, 1>;    // Output 1 Deadtime upon burst mode Idle entry
            using CHP1 = Field<6, 1>;    // Output 1 Chopper enable
            using FAULT1 = Field<4, 2>;    // Output 1 Fault state
            using IDLES1 = Field<3, 1>;    // Output 1 Idle State
            using IDLEM1 = Field<2, 1>;    // Output 1 Idle mode
            using POL1 = Field<1, 1>;    // Output 1 polarity
        };

        // Timerx Fault Register
        struct FLTBR : public Register<0x40017568> {
            using FLTLCK = Field<31, 1>;    // Fault sources Lock
            using FLT5EN = Field<4, 1>;    // Fault 5 enable
            using FLT4EN = Field<3, 1>;    // Fault 4 enable
            using FLT3EN = Field<2, 1>;    // Fault 3 enable
            using FLT2EN = Field<1, 1>;    // Fault 2 enable
            using FLT1EN = Field<0, 1>;    // Fault 1 enable
        };

    };

    // High Resolution Timer: TIMC
    struct HRTIM_TIMC {
        // Timerx Control Register
        struct TIMCCR : public Register<0x40017580> {
            using UPDGAT = Field<28, 4>;    // Update Gating
            using PREEN = Field<27, 1>;    // Preload enable
            using DACSYNC = Field<25, 2>;    // AC Synchronization
            using MSTU = Field<24, 1>;    // Master Timer update
            using TEU = Field<23, 1>;    // TEU
            using TDU = Field<22, 1>;    // TDU
            using TCU = Field<21, 1>;    // TCU
            using TBU = Field<20, 1>;    // TBU
            using TxRSTU = Field<18, 1>;    // Timerx reset update
            using TxREPU = Field<17, 1>;    // Timer x Repetition update
            using DELCMP4 = Field<14, 2>;    // Delayed CMP4 mode
            using DELCMP2 = Field<12, 2>;    // Delayed CMP2 mode
            using SYNCSTRTx = Field<11, 1>;    // Synchronization Starts Timer x
            using SYNCRSTx = Field<10, 1>;    // Synchronization Resets Timer x
            using PSHPLL = Field<6, 1>;    // Push-Pull mode enable
            using HALF = Field<5, 1>;    // Half mode enable
            using RETRIG = Field<4, 1>;    // Re-triggerable mode
            using CONT = Field<3, 1>;    // Continuous mode
            using CK_PSCx = Field<0, 3>;    // HRTIM Timer x Clock prescaler
        };

        // Timerx Interrupt Status Register
        struct TIMCISR : public RegisterReadOnly<0x40017584> {
            using O2STAT = Field<19, 1>;    // Output 2 State
            using O1STAT = Field<18, 1>;    // Output 1 State
            using IPPSTAT = Field<17, 1>;    // Idle Push Pull Status
            using CPPSTAT = Field<16, 1>;    // Current Push Pull Status
            using DLYPRT = Field<14, 1>;    // Delayed Protection Flag
            using RST = Field<13, 1>;    // Reset Interrupt Flag
            using RSTx2 = Field<12, 1>;    // Output 2 Reset Interrupt Flag
            using SETx2 = Field<11, 1>;    // Output 2 Set Interrupt Flag
            using RSTx1 = Field<10, 1>;    // Output 1 Reset Interrupt Flag
            using SETx1 = Field<9, 1>;    // Output 1 Set Interrupt Flag
            using CPT2 = Field<8, 1>;    // Capture2 Interrupt Flag
            using CPT1 = Field<7, 1>;    // Capture1 Interrupt Flag
            using UPD = Field<6, 1>;    // Update Interrupt Flag
            using REP = Field<4, 1>;    // Repetition Interrupt Flag
            using CMP4 = Field<3, 1>;    // Compare 4 Interrupt Flag
            using CMP3 = Field<2, 1>;    // Compare 3 Interrupt Flag
            using CMP2 = Field<1, 1>;    // Compare 2 Interrupt Flag
            using CMP1 = Field<0, 1>;    // Compare 1 Interrupt Flag
        };

        // Timerx Interrupt Clear Register
        struct TIMCICR : public RegisterWriteOnly<0x40017588> {
            using DLYPRTC = Field<14, 1>;    // Delayed Protection Flag Clear
            using RSTC = Field<13, 1>;    // Reset Interrupt flag Clear
            using RSTx2C = Field<12, 1>;    // Output 2 Reset flag Clear
            using SET2xC = Field<11, 1>;    // Output 2 Set flag Clear
            using RSTx1C = Field<10, 1>;    // Output 1 Reset flag Clear
            using SET1xC = Field<9, 1>;    // Output 1 Set flag Clear
            using CPT2C = Field<8, 1>;    // Capture2 Interrupt flag Clear
            using CPT1C = Field<7, 1>;    // Capture1 Interrupt flag Clear
            using UPDC = Field<6, 1>;    // Update Interrupt flag Clear
            using REPC = Field<4, 1>;    // Repetition Interrupt flag Clear
            using CMP4C = Field<3, 1>;    // Compare 4 Interrupt flag Clear
            using CMP3C = Field<2, 1>;    // Compare 3 Interrupt flag Clear
            using CMP2C = Field<1, 1>;    // Compare 2 Interrupt flag Clear
            using CMP1C = Field<0, 1>;    // Compare 1 Interrupt flag Clear
        };

        // TIMxDIER5
        struct TIMCDIER5 : public Register<0x4001758c> {
            using DLYPRTDE = Field<30, 1>;    // DLYPRTDE
            using RSTDE = Field<29, 1>;    // RSTDE
            using RSTx2DE = Field<28, 1>;    // RSTx2DE
            using SETx2DE = Field<27, 1>;    // SETx2DE
            using RSTx1DE = Field<26, 1>;    // RSTx1DE
            using SET1xDE = Field<25, 1>;    // SET1xDE
            using CPT2DE = Field<24, 1>;    // CPT2DE
            using CPT1DE = Field<23, 1>;    // CPT1DE
            using UPDDE = Field<22, 1>;    // UPDDE
            using REPDE = Field<20, 1>;    // REPDE
            using CMP4DE = Field<19, 1>;    // CMP4DE
            using CMP3DE = Field<18, 1>;    // CMP3DE
            using CMP2DE = Field<17, 1>;    // CMP2DE
            using CMP1DE = Field<16, 1>;    // CMP1DE
            using DLYPRTIE = Field<14, 1>;    // DLYPRTIE
            using RSTIE = Field<13, 1>;    // RSTIE
            using RSTx2IE = Field<12, 1>;    // RSTx2IE
            using SETx2IE = Field<11, 1>;    // SETx2IE
            using RSTx1IE = Field<10, 1>;    // RSTx1IE
            using SET1xIE = Field<9, 1>;    // SET1xIE
            using CPT2IE = Field<8, 1>;    // CPT2IE
            using CPT1IE = Field<7, 1>;    // CPT1IE
            using UPDIE = Field<6, 1>;    // UPDIE
            using REPIE = Field<4, 1>;    // REPIE
            using CMP4IE = Field<3, 1>;    // CMP4IE
            using CMP3IE = Field<2, 1>;    // CMP3IE
            using CMP2IE = Field<1, 1>;    // CMP2IE
            using CMP1IE = Field<0, 1>;    // CMP1IE
        };

        // Timerx Counter Register
        struct CNTCR : public Register<0x40017590> {
            using CNTx = Field<0, 16>;    // Timerx Counter value
        };

        // Timerx Period Register
        struct PERCR : public Register<0x40017594> {
            using PERx = Field<0, 16>;    // Timerx Period value
        };

        // Timerx Repetition Register
        struct REPCR : public Register<0x40017598> {
            using REPx = Field<0, 8>;    // Timerx Repetition counter value
        };

        // Timerx Compare 1 Register
        struct CMP1CR : public Register<0x4001759c> {
            using CMP1x = Field<0, 16>;    // Timerx Compare 1 value
        };

        // Timerx Compare 1 Compound Register
        struct CMP1CCR : public Register<0x400175a0> {
            using REPx = Field<16, 8>;    // Timerx Repetition value (aliased from HRTIM_REPx register)
            using CMP1x = Field<0, 16>;    // Timerx Compare 1 value
        };

        // Timerx Compare 2 Register
        struct CMP2CR : public Register<0x400175a4> {
            using CMP2x = Field<0, 16>;    // Timerx Compare 2 value
        };

        // Timerx Compare 3 Register
        struct CMP3CR : public Register<0x400175a8> {
            using CMP3x = Field<0, 16>;    // Timerx Compare 3 value
        };

        // Timerx Compare 4 Register
        struct CMP4CR : public Register<0x400175ac> {
            using CMP4x = Field<0, 16>;    // Timerx Compare 4 value
        };

        // Timerx Capture 1 Register
        struct CPT1CR : public RegisterReadOnly<0x400175b0> {
            using CPT1x = Field<0, 16>;    // Timerx Capture 1 value
        };

        // Timerx Capture 2 Register
        struct CPT2CR : public RegisterReadOnly<0x400175b4> {
            using CPT2x = Field<0, 16>;    // Timerx Capture 2 value
        };

        // Timerx Deadtime Register
        struct DTCR : public Register<0x400175b8> {
            using DTFLKx = Field<31, 1>;    // Deadtime Falling Lock
            using DTFSLKx = Field<30, 1>;    // Deadtime Falling Sign Lock
            using SDTFx = Field<25, 1>;    // Sign Deadtime Falling value
            using DTFx = Field<16, 9>;    // Deadtime Falling value
            using DTRLKx = Field<15, 1>;    // Deadtime Rising Lock
            using DTRSLKx = Field<14, 1>;    // Deadtime Rising Sign Lock
            using DTPRSC = Field<10, 3>;    // Deadtime Prescaler
            using SDTRx = Field<9, 1>;    // Sign Deadtime Rising value
            using DTRx = Field<0, 9>;    // Deadtime Rising value
        };

        // Timerx Output1 Set Register
        struct SETC1R : public Register<0x400175bc> {
            using UPDATE = Field<31, 1>;    // Registers update (transfer preload to active)
            using EXTEVNT10 = Field<30, 1>;    // External Event 10
            using EXTEVNT9 = Field<29, 1>;    // External Event 9
            using EXTEVNT8 = Field<28, 1>;    // External Event 8
            using EXTEVNT7 = Field<27, 1>;    // External Event 7
            using EXTEVNT6 = Field<26, 1>;    // External Event 6
            using EXTEVNT5 = Field<25, 1>;    // External Event 5
            using EXTEVNT4 = Field<24, 1>;    // External Event 4
            using EXTEVNT3 = Field<23, 1>;    // External Event 3
            using EXTEVNT2 = Field<22, 1>;    // External Event 2
            using EXTEVNT1 = Field<21, 1>;    // External Event 1
            using TIMEVNT9 = Field<20, 1>;    // Timer Event 9
            using TIMEVNT8 = Field<19, 1>;    // Timer Event 8
            using TIMEVNT7 = Field<18, 1>;    // Timer Event 7
            using TIMEVNT6 = Field<17, 1>;    // Timer Event 6
            using TIMEVNT5 = Field<16, 1>;    // Timer Event 5
            using TIMEVNT4 = Field<15, 1>;    // Timer Event 4
            using TIMEVNT3 = Field<14, 1>;    // Timer Event 3
            using TIMEVNT2 = Field<13, 1>;    // Timer Event 2
            using TIMEVNT1 = Field<12, 1>;    // Timer Event 1
            using MSTCMP4 = Field<11, 1>;    // Master Compare 4
            using MSTCMP3 = Field<10, 1>;    // Master Compare 3
            using MSTCMP2 = Field<9, 1>;    // Master Compare 2
            using MSTCMP1 = Field<8, 1>;    // Master Compare 1
            using MSTPER = Field<7, 1>;    // Master Period
            using CMP4 = Field<6, 1>;    // Timer A compare 4
            using CMP3 = Field<5, 1>;    // Timer A compare 3
            using CMP2 = Field<4, 1>;    // Timer A compare 2
            using CMP1 = Field<3, 1>;    // Timer A compare 1
            using PER = Field<2, 1>;    // Timer A Period
            using RESYNC = Field<1, 1>;    // Timer A resynchronizaton
            using SST = Field<0, 1>;    // Software Set trigger
        };

        // Timerx Output1 Reset Register
        struct RSTC1R : public Register<0x400175c0> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SRT = Field<0, 1>;    // SRT
        };

        // Timerx Output2 Set Register
        struct SETC2R : public Register<0x400175c4> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SST = Field<0, 1>;    // SST
        };

        // Timerx Output2 Reset Register
        struct RSTC2R : public Register<0x400175c8> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SRT = Field<0, 1>;    // SRT
        };

        // Timerx External Event Filtering Register 1
        struct EEFCR1 : public Register<0x400175cc> {
            using EE5FLTR = Field<25, 4>;    // External Event 5 filter
            using EE5LTCH = Field<24, 1>;    // External Event 5 latch
            using EE4FLTR = Field<19, 4>;    // External Event 4 filter
            using EE4LTCH = Field<18, 1>;    // External Event 4 latch
            using EE3FLTR = Field<13, 4>;    // External Event 3 filter
            using EE3LTCH = Field<12, 1>;    // External Event 3 latch
            using EE2FLTR = Field<7, 4>;    // External Event 2 filter
            using EE2LTCH = Field<6, 1>;    // External Event 2 latch
            using EE1FLTR = Field<1, 4>;    // External Event 1 filter
            using EE1LTCH = Field<0, 1>;    // External Event 1 latch
        };

        // Timerx External Event Filtering Register 2
        struct EEFCR2 : public Register<0x400175d0> {
            using EE10FLTR = Field<25, 4>;    // External Event 10 filter
            using EE10LTCH = Field<24, 1>;    // External Event 10 latch
            using EE9FLTR = Field<19, 4>;    // External Event 9 filter
            using EE9LTCH = Field<18, 1>;    // External Event 9 latch
            using EE8FLTR = Field<13, 4>;    // External Event 8 filter
            using EE8LTCH = Field<12, 1>;    // External Event 8 latch
            using EE7FLTR = Field<7, 4>;    // External Event 7 filter
            using EE7LTCH = Field<6, 1>;    // External Event 7 latch
            using EE6FLTR = Field<1, 4>;    // External Event 6 filter
            using EE6LTCH = Field<0, 1>;    // External Event 6 latch
        };

        // TimerA Reset Register
        struct RSTCR : public Register<0x400175d4> {
            using TIMECMP4 = Field<30, 1>;    // Timer E Compare 4
            using TIMECMP2 = Field<29, 1>;    // Timer E Compare 2
            using TIMECMP1 = Field<28, 1>;    // Timer E Compare 1
            using TIMDCMP4 = Field<27, 1>;    // Timer D Compare 4
            using TIMDCMP2 = Field<26, 1>;    // Timer D Compare 2
            using TIMDCMP1 = Field<25, 1>;    // Timer D Compare 1
            using TIMBCMP4 = Field<24, 1>;    // Timer B Compare 4
            using TIMBCMP2 = Field<23, 1>;    // Timer B Compare 2
            using TIMBCMP1 = Field<22, 1>;    // Timer B Compare 1
            using TIMACMP4 = Field<21, 1>;    // Timer A Compare 4
            using TIMACMP2 = Field<20, 1>;    // Timer A Compare 2
            using TIMACMP1 = Field<19, 1>;    // Timer A Compare 1
            using EXTEVNT10 = Field<18, 1>;    // External Event 10
            using EXTEVNT9 = Field<17, 1>;    // External Event 9
            using EXTEVNT8 = Field<16, 1>;    // External Event 8
            using EXTEVNT7 = Field<15, 1>;    // External Event 7
            using EXTEVNT6 = Field<14, 1>;    // External Event 6
            using EXTEVNT5 = Field<13, 1>;    // External Event 5
            using EXTEVNT4 = Field<12, 1>;    // External Event 4
            using EXTEVNT3 = Field<11, 1>;    // External Event 3
            using EXTEVNT2 = Field<10, 1>;    // External Event 2
            using EXTEVNT1 = Field<9, 1>;    // External Event 1
            using MSTCMP4 = Field<8, 1>;    // Master compare 4
            using MSTCMP3 = Field<7, 1>;    // Master compare 3
            using MSTCMP2 = Field<6, 1>;    // Master compare 2
            using MSTCMP1 = Field<5, 1>;    // Master compare 1
            using MSTPER = Field<4, 1>;    // Master timer Period
            using CMP4 = Field<3, 1>;    // Timer A compare 4 reset
            using CMP2 = Field<2, 1>;    // Timer A compare 2 reset
            using UPDT = Field<1, 1>;    // Timer A Update reset
        };

        // Timerx Chopper Register
        struct CHPCR : public Register<0x400175d8> {
            using STRTPW = Field<7, 4>;    // STRTPW
            using CHPDTY = Field<4, 3>;    // Timerx chopper duty cycle value
            using CHPFRQ = Field<0, 4>;    // Timerx carrier frequency value
        };

        // Timerx Capture 2 Control Register
        struct CPT1CCR : public Register<0x400175dc> {
            using TECMP2 = Field<31, 1>;    // Timer E Compare 2
            using TECMP1 = Field<30, 1>;    // Timer E Compare 1
            using TE1RST = Field<29, 1>;    // Timer E output 1 Reset
            using TE1SET = Field<28, 1>;    // Timer E output 1 Set
            using TDCMP2 = Field<27, 1>;    // Timer D Compare 2
            using TDCMP1 = Field<26, 1>;    // Timer D Compare 1
            using TD1RST = Field<25, 1>;    // Timer D output 1 Reset
            using TD1SET = Field<24, 1>;    // Timer D output 1 Set
            using TBCMP2 = Field<19, 1>;    // Timer B Compare 2
            using TBCMP1 = Field<18, 1>;    // Timer B Compare 1
            using TB1RST = Field<17, 1>;    // Timer B output 1 Reset
            using TB1SET = Field<16, 1>;    // Timer B output 1 Set
            using TACMP2 = Field<15, 1>;    // Timer A Compare 2
            using TACMP1 = Field<14, 1>;    // Timer A Compare 1
            using TA1RST = Field<13, 1>;    // Timer A output 1 Reset
            using TA1SET = Field<12, 1>;    // Timer A output 1 Set
            using EXEV10CPT = Field<11, 1>;    // External Event 10 Capture
            using EXEV9CPT = Field<10, 1>;    // External Event 9 Capture
            using EXEV8CPT = Field<9, 1>;    // External Event 8 Capture
            using EXEV7CPT = Field<8, 1>;    // External Event 7 Capture
            using EXEV6CPT = Field<7, 1>;    // External Event 6 Capture
            using EXEV5CPT = Field<6, 1>;    // External Event 5 Capture
            using EXEV4CPT = Field<5, 1>;    // External Event 4 Capture
            using EXEV3CPT = Field<4, 1>;    // External Event 3 Capture
            using EXEV2CPT = Field<3, 1>;    // External Event 2 Capture
            using EXEV1CPT = Field<2, 1>;    // External Event 1 Capture
            using UDPCPT = Field<1, 1>;    // Update Capture
            using SWCPT = Field<0, 1>;    // Software Capture
        };

        // CPT2xCR
        struct CPT2CCR : public Register<0x400175e0> {
            using TECMP2 = Field<31, 1>;    // Timer E Compare 2
            using TECMP1 = Field<30, 1>;    // Timer E Compare 1
            using TE1RST = Field<29, 1>;    // Timer E output 1 Reset
            using TE1SET = Field<28, 1>;    // Timer E output 1 Set
            using TDCMP2 = Field<27, 1>;    // Timer D Compare 2
            using TDCMP1 = Field<26, 1>;    // Timer D Compare 1
            using TD1RST = Field<25, 1>;    // Timer D output 1 Reset
            using TD1SET = Field<24, 1>;    // Timer D output 1 Set
            using TBCMP2 = Field<19, 1>;    // Timer B Compare 2
            using TBCMP1 = Field<18, 1>;    // Timer B Compare 1
            using TB1RST = Field<17, 1>;    // Timer B output 1 Reset
            using TB1SET = Field<16, 1>;    // Timer B output 1 Set
            using TACMP2 = Field<15, 1>;    // Timer A Compare 2
            using TACMP1 = Field<14, 1>;    // Timer A Compare 1
            using TA1RST = Field<13, 1>;    // Timer A output 1 Reset
            using TA1SET = Field<12, 1>;    // Timer A output 1 Set
            using EXEV10CPT = Field<11, 1>;    // External Event 10 Capture
            using EXEV9CPT = Field<10, 1>;    // External Event 9 Capture
            using EXEV8CPT = Field<9, 1>;    // External Event 8 Capture
            using EXEV7CPT = Field<8, 1>;    // External Event 7 Capture
            using EXEV6CPT = Field<7, 1>;    // External Event 6 Capture
            using EXEV5CPT = Field<6, 1>;    // External Event 5 Capture
            using EXEV4CPT = Field<5, 1>;    // External Event 4 Capture
            using EXEV3CPT = Field<4, 1>;    // External Event 3 Capture
            using EXEV2CPT = Field<3, 1>;    // External Event 2 Capture
            using EXEV1CPT = Field<2, 1>;    // External Event 1 Capture
            using UDPCPT = Field<1, 1>;    // Update Capture
            using SWCPT = Field<0, 1>;    // Software Capture
        };

        // Timerx Output Register
        struct OUTCR : public Register<0x400175e4> {
            using DIDL2 = Field<23, 1>;    // Output 2 Deadtime upon burst mode Idle entry
            using CHP2 = Field<22, 1>;    // Output 2 Chopper enable
            using FAULT2 = Field<20, 2>;    // Output 2 Fault state
            using IDLES2 = Field<19, 1>;    // Output 2 Idle State
            using IDLEM2 = Field<18, 1>;    // Output 2 Idle mode
            using POL2 = Field<17, 1>;    // Output 2 polarity
            using DLYPRT = Field<10, 3>;    // Delayed Protection
            using DLYPRTEN = Field<9, 1>;    // Delayed Protection Enable
            using DTEN = Field<8, 1>;    // Deadtime enable
            using DIDL1 = Field<7, 1>;    // Output 1 Deadtime upon burst mode Idle entry
            using CHP1 = Field<6, 1>;    // Output 1 Chopper enable
            using FAULT1 = Field<4, 2>;    // Output 1 Fault state
            using IDLES1 = Field<3, 1>;    // Output 1 Idle State
            using IDLEM1 = Field<2, 1>;    // Output 1 Idle mode
            using POL1 = Field<1, 1>;    // Output 1 polarity
        };

        // Timerx Fault Register
        struct FLTCR : public Register<0x400175e8> {
            using FLTLCK = Field<31, 1>;    // Fault sources Lock
            using FLT5EN = Field<4, 1>;    // Fault 5 enable
            using FLT4EN = Field<3, 1>;    // Fault 4 enable
            using FLT3EN = Field<2, 1>;    // Fault 3 enable
            using FLT2EN = Field<1, 1>;    // Fault 2 enable
            using FLT1EN = Field<0, 1>;    // Fault 1 enable
        };

    };

    // High Resolution Timer: TIMD
    struct HRTIM_TIMD {
        // Timerx Control Register
        struct TIMDCR : public Register<0x40017600> {
            using UPDGAT = Field<28, 4>;    // Update Gating
            using PREEN = Field<27, 1>;    // Preload enable
            using DACSYNC = Field<25, 2>;    // AC Synchronization
            using MSTU = Field<24, 1>;    // Master Timer update
            using TEU = Field<23, 1>;    // TEU
            using TDU = Field<22, 1>;    // TDU
            using TCU = Field<21, 1>;    // TCU
            using TBU = Field<20, 1>;    // TBU
            using TxRSTU = Field<18, 1>;    // Timerx reset update
            using TxREPU = Field<17, 1>;    // Timer x Repetition update
            using DELCMP4 = Field<14, 2>;    // Delayed CMP4 mode
            using DELCMP2 = Field<12, 2>;    // Delayed CMP2 mode
            using SYNCSTRTx = Field<11, 1>;    // Synchronization Starts Timer x
            using SYNCRSTx = Field<10, 1>;    // Synchronization Resets Timer x
            using PSHPLL = Field<6, 1>;    // Push-Pull mode enable
            using HALF = Field<5, 1>;    // Half mode enable
            using RETRIG = Field<4, 1>;    // Re-triggerable mode
            using CONT = Field<3, 1>;    // Continuous mode
            using CK_PSCx = Field<0, 3>;    // HRTIM Timer x Clock prescaler
        };

        // Timerx Interrupt Status Register
        struct TIMDISR : public RegisterReadOnly<0x40017604> {
            using O2STAT = Field<19, 1>;    // Output 2 State
            using O1STAT = Field<18, 1>;    // Output 1 State
            using IPPSTAT = Field<17, 1>;    // Idle Push Pull Status
            using CPPSTAT = Field<16, 1>;    // Current Push Pull Status
            using DLYPRT = Field<14, 1>;    // Delayed Protection Flag
            using RST = Field<13, 1>;    // Reset Interrupt Flag
            using RSTx2 = Field<12, 1>;    // Output 2 Reset Interrupt Flag
            using SETx2 = Field<11, 1>;    // Output 2 Set Interrupt Flag
            using RSTx1 = Field<10, 1>;    // Output 1 Reset Interrupt Flag
            using SETx1 = Field<9, 1>;    // Output 1 Set Interrupt Flag
            using CPT2 = Field<8, 1>;    // Capture2 Interrupt Flag
            using CPT1 = Field<7, 1>;    // Capture1 Interrupt Flag
            using UPD = Field<6, 1>;    // Update Interrupt Flag
            using REP = Field<4, 1>;    // Repetition Interrupt Flag
            using CMP4 = Field<3, 1>;    // Compare 4 Interrupt Flag
            using CMP3 = Field<2, 1>;    // Compare 3 Interrupt Flag
            using CMP2 = Field<1, 1>;    // Compare 2 Interrupt Flag
            using CMP1 = Field<0, 1>;    // Compare 1 Interrupt Flag
        };

        // Timerx Interrupt Clear Register
        struct TIMDICR : public RegisterWriteOnly<0x40017608> {
            using DLYPRTC = Field<14, 1>;    // Delayed Protection Flag Clear
            using RSTC = Field<13, 1>;    // Reset Interrupt flag Clear
            using RSTx2C = Field<12, 1>;    // Output 2 Reset flag Clear
            using SET2xC = Field<11, 1>;    // Output 2 Set flag Clear
            using RSTx1C = Field<10, 1>;    // Output 1 Reset flag Clear
            using SET1xC = Field<9, 1>;    // Output 1 Set flag Clear
            using CPT2C = Field<8, 1>;    // Capture2 Interrupt flag Clear
            using CPT1C = Field<7, 1>;    // Capture1 Interrupt flag Clear
            using UPDC = Field<6, 1>;    // Update Interrupt flag Clear
            using REPC = Field<4, 1>;    // Repetition Interrupt flag Clear
            using CMP4C = Field<3, 1>;    // Compare 4 Interrupt flag Clear
            using CMP3C = Field<2, 1>;    // Compare 3 Interrupt flag Clear
            using CMP2C = Field<1, 1>;    // Compare 2 Interrupt flag Clear
            using CMP1C = Field<0, 1>;    // Compare 1 Interrupt flag Clear
        };

        // TIMxDIER5
        struct TIMDDIER5 : public Register<0x4001760c> {
            using DLYPRTDE = Field<30, 1>;    // DLYPRTDE
            using RSTDE = Field<29, 1>;    // RSTDE
            using RSTx2DE = Field<28, 1>;    // RSTx2DE
            using SETx2DE = Field<27, 1>;    // SETx2DE
            using RSTx1DE = Field<26, 1>;    // RSTx1DE
            using SET1xDE = Field<25, 1>;    // SET1xDE
            using CPT2DE = Field<24, 1>;    // CPT2DE
            using CPT1DE = Field<23, 1>;    // CPT1DE
            using UPDDE = Field<22, 1>;    // UPDDE
            using REPDE = Field<20, 1>;    // REPDE
            using CMP4DE = Field<19, 1>;    // CMP4DE
            using CMP3DE = Field<18, 1>;    // CMP3DE
            using CMP2DE = Field<17, 1>;    // CMP2DE
            using CMP1DE = Field<16, 1>;    // CMP1DE
            using DLYPRTIE = Field<14, 1>;    // DLYPRTIE
            using RSTIE = Field<13, 1>;    // RSTIE
            using RSTx2IE = Field<12, 1>;    // RSTx2IE
            using SETx2IE = Field<11, 1>;    // SETx2IE
            using RSTx1IE = Field<10, 1>;    // RSTx1IE
            using SET1xIE = Field<9, 1>;    // SET1xIE
            using CPT2IE = Field<8, 1>;    // CPT2IE
            using CPT1IE = Field<7, 1>;    // CPT1IE
            using UPDIE = Field<6, 1>;    // UPDIE
            using REPIE = Field<4, 1>;    // REPIE
            using CMP4IE = Field<3, 1>;    // CMP4IE
            using CMP3IE = Field<2, 1>;    // CMP3IE
            using CMP2IE = Field<1, 1>;    // CMP2IE
            using CMP1IE = Field<0, 1>;    // CMP1IE
        };

        // Timerx Counter Register
        struct CNTDR : public Register<0x40017610> {
            using CNTx = Field<0, 16>;    // Timerx Counter value
        };

        // Timerx Period Register
        struct PERDR : public Register<0x40017614> {
            using PERx = Field<0, 16>;    // Timerx Period value
        };

        // Timerx Repetition Register
        struct REPDR : public Register<0x40017618> {
            using REPx = Field<0, 8>;    // Timerx Repetition counter value
        };

        // Timerx Compare 1 Register
        struct CMP1DR : public Register<0x4001761c> {
            using CMP1x = Field<0, 16>;    // Timerx Compare 1 value
        };

        // Timerx Compare 1 Compound Register
        struct CMP1CDR : public Register<0x40017620> {
            using REPx = Field<16, 8>;    // Timerx Repetition value (aliased from HRTIM_REPx register)
            using CMP1x = Field<0, 16>;    // Timerx Compare 1 value
        };

        // Timerx Compare 2 Register
        struct CMP2DR : public Register<0x40017624> {
            using CMP2x = Field<0, 16>;    // Timerx Compare 2 value
        };

        // Timerx Compare 3 Register
        struct CMP3DR : public Register<0x40017628> {
            using CMP3x = Field<0, 16>;    // Timerx Compare 3 value
        };

        // Timerx Compare 4 Register
        struct CMP4DR : public Register<0x4001762c> {
            using CMP4x = Field<0, 16>;    // Timerx Compare 4 value
        };

        // Timerx Capture 1 Register
        struct CPT1DR : public RegisterReadOnly<0x40017630> {
            using CPT1x = Field<0, 16>;    // Timerx Capture 1 value
        };

        // Timerx Capture 2 Register
        struct CPT2DR : public RegisterReadOnly<0x40017634> {
            using CPT2x = Field<0, 16>;    // Timerx Capture 2 value
        };

        // Timerx Deadtime Register
        struct DTDR : public Register<0x40017638> {
            using DTFLKx = Field<31, 1>;    // Deadtime Falling Lock
            using DTFSLKx = Field<30, 1>;    // Deadtime Falling Sign Lock
            using SDTFx = Field<25, 1>;    // Sign Deadtime Falling value
            using DTFx = Field<16, 9>;    // Deadtime Falling value
            using DTRLKx = Field<15, 1>;    // Deadtime Rising Lock
            using DTRSLKx = Field<14, 1>;    // Deadtime Rising Sign Lock
            using DTPRSC = Field<10, 3>;    // Deadtime Prescaler
            using SDTRx = Field<9, 1>;    // Sign Deadtime Rising value
            using DTRx = Field<0, 9>;    // Deadtime Rising value
        };

        // Timerx Output1 Set Register
        struct SETD1R : public Register<0x4001763c> {
            using UPDATE = Field<31, 1>;    // Registers update (transfer preload to active)
            using EXTEVNT10 = Field<30, 1>;    // External Event 10
            using EXTEVNT9 = Field<29, 1>;    // External Event 9
            using EXTEVNT8 = Field<28, 1>;    // External Event 8
            using EXTEVNT7 = Field<27, 1>;    // External Event 7
            using EXTEVNT6 = Field<26, 1>;    // External Event 6
            using EXTEVNT5 = Field<25, 1>;    // External Event 5
            using EXTEVNT4 = Field<24, 1>;    // External Event 4
            using EXTEVNT3 = Field<23, 1>;    // External Event 3
            using EXTEVNT2 = Field<22, 1>;    // External Event 2
            using EXTEVNT1 = Field<21, 1>;    // External Event 1
            using TIMEVNT9 = Field<20, 1>;    // Timer Event 9
            using TIMEVNT8 = Field<19, 1>;    // Timer Event 8
            using TIMEVNT7 = Field<18, 1>;    // Timer Event 7
            using TIMEVNT6 = Field<17, 1>;    // Timer Event 6
            using TIMEVNT5 = Field<16, 1>;    // Timer Event 5
            using TIMEVNT4 = Field<15, 1>;    // Timer Event 4
            using TIMEVNT3 = Field<14, 1>;    // Timer Event 3
            using TIMEVNT2 = Field<13, 1>;    // Timer Event 2
            using TIMEVNT1 = Field<12, 1>;    // Timer Event 1
            using MSTCMP4 = Field<11, 1>;    // Master Compare 4
            using MSTCMP3 = Field<10, 1>;    // Master Compare 3
            using MSTCMP2 = Field<9, 1>;    // Master Compare 2
            using MSTCMP1 = Field<8, 1>;    // Master Compare 1
            using MSTPER = Field<7, 1>;    // Master Period
            using CMP4 = Field<6, 1>;    // Timer A compare 4
            using CMP3 = Field<5, 1>;    // Timer A compare 3
            using CMP2 = Field<4, 1>;    // Timer A compare 2
            using CMP1 = Field<3, 1>;    // Timer A compare 1
            using PER = Field<2, 1>;    // Timer A Period
            using RESYNC = Field<1, 1>;    // Timer A resynchronizaton
            using SST = Field<0, 1>;    // Software Set trigger
        };

        // Timerx Output1 Reset Register
        struct RSTD1R : public Register<0x40017640> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SRT = Field<0, 1>;    // SRT
        };

        // Timerx Output2 Set Register
        struct SETD2R : public Register<0x40017644> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SST = Field<0, 1>;    // SST
        };

        // Timerx Output2 Reset Register
        struct RSTD2R : public Register<0x40017648> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SRT = Field<0, 1>;    // SRT
        };

        // Timerx External Event Filtering Register 1
        struct EEFDR1 : public Register<0x4001764c> {
            using EE5FLTR = Field<25, 4>;    // External Event 5 filter
            using EE5LTCH = Field<24, 1>;    // External Event 5 latch
            using EE4FLTR = Field<19, 4>;    // External Event 4 filter
            using EE4LTCH = Field<18, 1>;    // External Event 4 latch
            using EE3FLTR = Field<13, 4>;    // External Event 3 filter
            using EE3LTCH = Field<12, 1>;    // External Event 3 latch
            using EE2FLTR = Field<7, 4>;    // External Event 2 filter
            using EE2LTCH = Field<6, 1>;    // External Event 2 latch
            using EE1FLTR = Field<1, 4>;    // External Event 1 filter
            using EE1LTCH = Field<0, 1>;    // External Event 1 latch
        };

        // Timerx External Event Filtering Register 2
        struct EEFDR2 : public Register<0x40017650> {
            using EE10FLTR = Field<25, 4>;    // External Event 10 filter
            using EE10LTCH = Field<24, 1>;    // External Event 10 latch
            using EE9FLTR = Field<19, 4>;    // External Event 9 filter
            using EE9LTCH = Field<18, 1>;    // External Event 9 latch
            using EE8FLTR = Field<13, 4>;    // External Event 8 filter
            using EE8LTCH = Field<12, 1>;    // External Event 8 latch
            using EE7FLTR = Field<7, 4>;    // External Event 7 filter
            using EE7LTCH = Field<6, 1>;    // External Event 7 latch
            using EE6FLTR = Field<1, 4>;    // External Event 6 filter
            using EE6LTCH = Field<0, 1>;    // External Event 6 latch
        };

        // TimerA Reset Register
        struct RSTDR : public Register<0x40017654> {
            using TIMECMP4 = Field<30, 1>;    // Timer E Compare 4
            using TIMECMP2 = Field<29, 1>;    // Timer E Compare 2
            using TIMECMP1 = Field<28, 1>;    // Timer E Compare 1
            using TIMCCMP4 = Field<27, 1>;    // Timer C Compare 4
            using TIMCCMP2 = Field<26, 1>;    // Timer C Compare 2
            using TIMCCMP1 = Field<25, 1>;    // Timer C Compare 1
            using TIMBCMP4 = Field<24, 1>;    // Timer B Compare 4
            using TIMBCMP2 = Field<23, 1>;    // Timer B Compare 2
            using TIMBCMP1 = Field<22, 1>;    // Timer B Compare 1
            using TIMACMP4 = Field<21, 1>;    // Timer A Compare 4
            using TIMACMP2 = Field<20, 1>;    // Timer A Compare 2
            using TIMACMP1 = Field<19, 1>;    // Timer A Compare 1
            using EXTEVNT10 = Field<18, 1>;    // External Event 10
            using EXTEVNT9 = Field<17, 1>;    // External Event 9
            using EXTEVNT8 = Field<16, 1>;    // External Event 8
            using EXTEVNT7 = Field<15, 1>;    // External Event 7
            using EXTEVNT6 = Field<14, 1>;    // External Event 6
            using EXTEVNT5 = Field<13, 1>;    // External Event 5
            using EXTEVNT4 = Field<12, 1>;    // External Event 4
            using EXTEVNT3 = Field<11, 1>;    // External Event 3
            using EXTEVNT2 = Field<10, 1>;    // External Event 2
            using EXTEVNT1 = Field<9, 1>;    // External Event 1
            using MSTCMP4 = Field<8, 1>;    // Master compare 4
            using MSTCMP3 = Field<7, 1>;    // Master compare 3
            using MSTCMP2 = Field<6, 1>;    // Master compare 2
            using MSTCMP1 = Field<5, 1>;    // Master compare 1
            using MSTPER = Field<4, 1>;    // Master timer Period
            using CMP4 = Field<3, 1>;    // Timer A compare 4 reset
            using CMP2 = Field<2, 1>;    // Timer A compare 2 reset
            using UPDT = Field<1, 1>;    // Timer A Update reset
        };

        // Timerx Chopper Register
        struct CHPDR : public Register<0x40017658> {
            using STRTPW = Field<7, 4>;    // STRTPW
            using CHPDTY = Field<4, 3>;    // Timerx chopper duty cycle value
            using CHPFRQ = Field<0, 4>;    // Timerx carrier frequency value
        };

        // Timerx Capture 2 Control Register
        struct CPT1DCR : public Register<0x4001765c> {
            using TECMP2 = Field<31, 1>;    // Timer E Compare 2
            using TECMP1 = Field<30, 1>;    // Timer E Compare 1
            using TE1RST = Field<29, 1>;    // Timer E output 1 Reset
            using TE1SET = Field<28, 1>;    // Timer E output 1 Set
            using TCCMP2 = Field<23, 1>;    // Timer C Compare 2
            using TCCMP1 = Field<22, 1>;    // Timer C Compare 1
            using TC1RST = Field<21, 1>;    // Timer C output 1 Reset
            using TC1SET = Field<20, 1>;    // Timer C output 1 Set
            using TBCMP2 = Field<19, 1>;    // Timer B Compare 2
            using TBCMP1 = Field<18, 1>;    // Timer B Compare 1
            using TB1RST = Field<17, 1>;    // Timer B output 1 Reset
            using TB1SET = Field<16, 1>;    // Timer B output 1 Set
            using TACMP2 = Field<15, 1>;    // Timer A Compare 2
            using TACMP1 = Field<14, 1>;    // Timer A Compare 1
            using TA1RST = Field<13, 1>;    // Timer A output 1 Reset
            using TA1SET = Field<12, 1>;    // Timer A output 1 Set
            using EXEV10CPT = Field<11, 1>;    // External Event 10 Capture
            using EXEV9CPT = Field<10, 1>;    // External Event 9 Capture
            using EXEV8CPT = Field<9, 1>;    // External Event 8 Capture
            using EXEV7CPT = Field<8, 1>;    // External Event 7 Capture
            using EXEV6CPT = Field<7, 1>;    // External Event 6 Capture
            using EXEV5CPT = Field<6, 1>;    // External Event 5 Capture
            using EXEV4CPT = Field<5, 1>;    // External Event 4 Capture
            using EXEV3CPT = Field<4, 1>;    // External Event 3 Capture
            using EXEV2CPT = Field<3, 1>;    // External Event 2 Capture
            using EXEV1CPT = Field<2, 1>;    // External Event 1 Capture
            using UDPCPT = Field<1, 1>;    // Update Capture
            using SWCPT = Field<0, 1>;    // Software Capture
        };

        // CPT2xCR
        struct CPT2DCR : public Register<0x40017660> {
            using TECMP2 = Field<31, 1>;    // Timer E Compare 2
            using TECMP1 = Field<30, 1>;    // Timer E Compare 1
            using TE1RST = Field<29, 1>;    // Timer E output 1 Reset
            using TE1SET = Field<28, 1>;    // Timer E output 1 Set
            using TCCMP2 = Field<23, 1>;    // Timer C Compare 2
            using TCCMP1 = Field<22, 1>;    // Timer C Compare 1
            using TC1RST = Field<21, 1>;    // Timer C output 1 Reset
            using TC1SET = Field<20, 1>;    // Timer C output 1 Set
            using TBCMP2 = Field<19, 1>;    // Timer B Compare 2
            using TBCMP1 = Field<18, 1>;    // Timer B Compare 1
            using TB1RST = Field<17, 1>;    // Timer B output 1 Reset
            using TB1SET = Field<16, 1>;    // Timer B output 1 Set
            using TACMP2 = Field<15, 1>;    // Timer A Compare 2
            using TACMP1 = Field<14, 1>;    // Timer A Compare 1
            using TA1RST = Field<13, 1>;    // Timer A output 1 Reset
            using TA1SET = Field<12, 1>;    // Timer A output 1 Set
            using EXEV10CPT = Field<11, 1>;    // External Event 10 Capture
            using EXEV9CPT = Field<10, 1>;    // External Event 9 Capture
            using EXEV8CPT = Field<9, 1>;    // External Event 8 Capture
            using EXEV7CPT = Field<8, 1>;    // External Event 7 Capture
            using EXEV6CPT = Field<7, 1>;    // External Event 6 Capture
            using EXEV5CPT = Field<6, 1>;    // External Event 5 Capture
            using EXEV4CPT = Field<5, 1>;    // External Event 4 Capture
            using EXEV3CPT = Field<4, 1>;    // External Event 3 Capture
            using EXEV2CPT = Field<3, 1>;    // External Event 2 Capture
            using EXEV1CPT = Field<2, 1>;    // External Event 1 Capture
            using UDPCPT = Field<1, 1>;    // Update Capture
            using SWCPT = Field<0, 1>;    // Software Capture
        };

        // Timerx Output Register
        struct OUTDR : public Register<0x40017664> {
            using DIDL2 = Field<23, 1>;    // Output 2 Deadtime upon burst mode Idle entry
            using CHP2 = Field<22, 1>;    // Output 2 Chopper enable
            using FAULT2 = Field<20, 2>;    // Output 2 Fault state
            using IDLES2 = Field<19, 1>;    // Output 2 Idle State
            using IDLEM2 = Field<18, 1>;    // Output 2 Idle mode
            using POL2 = Field<17, 1>;    // Output 2 polarity
            using DLYPRT = Field<10, 3>;    // Delayed Protection
            using DLYPRTEN = Field<9, 1>;    // Delayed Protection Enable
            using DTEN = Field<8, 1>;    // Deadtime enable
            using DIDL1 = Field<7, 1>;    // Output 1 Deadtime upon burst mode Idle entry
            using CHP1 = Field<6, 1>;    // Output 1 Chopper enable
            using FAULT1 = Field<4, 2>;    // Output 1 Fault state
            using IDLES1 = Field<3, 1>;    // Output 1 Idle State
            using IDLEM1 = Field<2, 1>;    // Output 1 Idle mode
            using POL1 = Field<1, 1>;    // Output 1 polarity
        };

        // Timerx Fault Register
        struct FLTDR : public Register<0x40017668> {
            using FLTLCK = Field<31, 1>;    // Fault sources Lock
            using FLT5EN = Field<4, 1>;    // Fault 5 enable
            using FLT4EN = Field<3, 1>;    // Fault 4 enable
            using FLT3EN = Field<2, 1>;    // Fault 3 enable
            using FLT2EN = Field<1, 1>;    // Fault 2 enable
            using FLT1EN = Field<0, 1>;    // Fault 1 enable
        };

    };

    // High Resolution Timer: TIME
    struct HRTIM_TIME {
        // Timerx Control Register
        struct TIMECR : public Register<0x40017680> {
            using UPDGAT = Field<28, 4>;    // Update Gating
            using PREEN = Field<27, 1>;    // Preload enable
            using DACSYNC = Field<25, 2>;    // AC Synchronization
            using MSTU = Field<24, 1>;    // Master Timer update
            using TEU = Field<23, 1>;    // TEU
            using TDU = Field<22, 1>;    // TDU
            using TCU = Field<21, 1>;    // TCU
            using TBU = Field<20, 1>;    // TBU
            using TxRSTU = Field<18, 1>;    // Timerx reset update
            using TxREPU = Field<17, 1>;    // Timer x Repetition update
            using DELCMP4 = Field<14, 2>;    // Delayed CMP4 mode
            using DELCMP2 = Field<12, 2>;    // Delayed CMP2 mode
            using SYNCSTRTx = Field<11, 1>;    // Synchronization Starts Timer x
            using SYNCRSTx = Field<10, 1>;    // Synchronization Resets Timer x
            using PSHPLL = Field<6, 1>;    // Push-Pull mode enable
            using HALF = Field<5, 1>;    // Half mode enable
            using RETRIG = Field<4, 1>;    // Re-triggerable mode
            using CONT = Field<3, 1>;    // Continuous mode
            using CK_PSCx = Field<0, 3>;    // HRTIM Timer x Clock prescaler
        };

        // Timerx Interrupt Status Register
        struct TIMEISR : public RegisterReadOnly<0x40017684> {
            using O2STAT = Field<19, 1>;    // Output 2 State
            using O1STAT = Field<18, 1>;    // Output 1 State
            using IPPSTAT = Field<17, 1>;    // Idle Push Pull Status
            using CPPSTAT = Field<16, 1>;    // Current Push Pull Status
            using DLYPRT = Field<14, 1>;    // Delayed Protection Flag
            using RST = Field<13, 1>;    // Reset Interrupt Flag
            using RSTx2 = Field<12, 1>;    // Output 2 Reset Interrupt Flag
            using SETx2 = Field<11, 1>;    // Output 2 Set Interrupt Flag
            using RSTx1 = Field<10, 1>;    // Output 1 Reset Interrupt Flag
            using SETx1 = Field<9, 1>;    // Output 1 Set Interrupt Flag
            using CPT2 = Field<8, 1>;    // Capture2 Interrupt Flag
            using CPT1 = Field<7, 1>;    // Capture1 Interrupt Flag
            using UPD = Field<6, 1>;    // Update Interrupt Flag
            using REP = Field<4, 1>;    // Repetition Interrupt Flag
            using CMP4 = Field<3, 1>;    // Compare 4 Interrupt Flag
            using CMP3 = Field<2, 1>;    // Compare 3 Interrupt Flag
            using CMP2 = Field<1, 1>;    // Compare 2 Interrupt Flag
            using CMP1 = Field<0, 1>;    // Compare 1 Interrupt Flag
        };

        // Timerx Interrupt Clear Register
        struct TIMEICR : public RegisterWriteOnly<0x40017688> {
            using DLYPRTC = Field<14, 1>;    // Delayed Protection Flag Clear
            using RSTC = Field<13, 1>;    // Reset Interrupt flag Clear
            using RSTx2C = Field<12, 1>;    // Output 2 Reset flag Clear
            using SET2xC = Field<11, 1>;    // Output 2 Set flag Clear
            using RSTx1C = Field<10, 1>;    // Output 1 Reset flag Clear
            using SET1xC = Field<9, 1>;    // Output 1 Set flag Clear
            using CPT2C = Field<8, 1>;    // Capture2 Interrupt flag Clear
            using CPT1C = Field<7, 1>;    // Capture1 Interrupt flag Clear
            using UPDC = Field<6, 1>;    // Update Interrupt flag Clear
            using REPC = Field<4, 1>;    // Repetition Interrupt flag Clear
            using CMP4C = Field<3, 1>;    // Compare 4 Interrupt flag Clear
            using CMP3C = Field<2, 1>;    // Compare 3 Interrupt flag Clear
            using CMP2C = Field<1, 1>;    // Compare 2 Interrupt flag Clear
            using CMP1C = Field<0, 1>;    // Compare 1 Interrupt flag Clear
        };

        // TIMxDIER5
        struct TIMEDIER5 : public Register<0x4001768c> {
            using DLYPRTDE = Field<30, 1>;    // DLYPRTDE
            using RSTDE = Field<29, 1>;    // RSTDE
            using RSTx2DE = Field<28, 1>;    // RSTx2DE
            using SETx2DE = Field<27, 1>;    // SETx2DE
            using RSTx1DE = Field<26, 1>;    // RSTx1DE
            using SET1xDE = Field<25, 1>;    // SET1xDE
            using CPT2DE = Field<24, 1>;    // CPT2DE
            using CPT1DE = Field<23, 1>;    // CPT1DE
            using UPDDE = Field<22, 1>;    // UPDDE
            using REPDE = Field<20, 1>;    // REPDE
            using CMP4DE = Field<19, 1>;    // CMP4DE
            using CMP3DE = Field<18, 1>;    // CMP3DE
            using CMP2DE = Field<17, 1>;    // CMP2DE
            using CMP1DE = Field<16, 1>;    // CMP1DE
            using DLYPRTIE = Field<14, 1>;    // DLYPRTIE
            using RSTIE = Field<13, 1>;    // RSTIE
            using RSTx2IE = Field<12, 1>;    // RSTx2IE
            using SETx2IE = Field<11, 1>;    // SETx2IE
            using RSTx1IE = Field<10, 1>;    // RSTx1IE
            using SET1xIE = Field<9, 1>;    // SET1xIE
            using CPT2IE = Field<8, 1>;    // CPT2IE
            using CPT1IE = Field<7, 1>;    // CPT1IE
            using UPDIE = Field<6, 1>;    // UPDIE
            using REPIE = Field<4, 1>;    // REPIE
            using CMP4IE = Field<3, 1>;    // CMP4IE
            using CMP3IE = Field<2, 1>;    // CMP3IE
            using CMP2IE = Field<1, 1>;    // CMP2IE
            using CMP1IE = Field<0, 1>;    // CMP1IE
        };

        // Timerx Counter Register
        struct CNTER : public Register<0x40017690> {
            using CNTx = Field<0, 16>;    // Timerx Counter value
        };

        // Timerx Period Register
        struct PERER : public Register<0x40017694> {
            using PERx = Field<0, 16>;    // Timerx Period value
        };

        // Timerx Repetition Register
        struct REPER : public Register<0x40017698> {
            using REPx = Field<0, 8>;    // Timerx Repetition counter value
        };

        // Timerx Compare 1 Register
        struct CMP1ER : public Register<0x4001769c> {
            using CMP1x = Field<0, 16>;    // Timerx Compare 1 value
        };

        // Timerx Compare 1 Compound Register
        struct CMP1CER : public Register<0x400176a0> {
            using REPx = Field<16, 8>;    // Timerx Repetition value (aliased from HRTIM_REPx register)
            using CMP1x = Field<0, 16>;    // Timerx Compare 1 value
        };

        // Timerx Compare 2 Register
        struct CMP2ER : public Register<0x400176a4> {
            using CMP2x = Field<0, 16>;    // Timerx Compare 2 value
        };

        // Timerx Compare 3 Register
        struct CMP3ER : public Register<0x400176a8> {
            using CMP3x = Field<0, 16>;    // Timerx Compare 3 value
        };

        // Timerx Compare 4 Register
        struct CMP4ER : public Register<0x400176ac> {
            using CMP4x = Field<0, 16>;    // Timerx Compare 4 value
        };

        // Timerx Capture 1 Register
        struct CPT1ER : public RegisterReadOnly<0x400176b0> {
            using CPT1x = Field<0, 16>;    // Timerx Capture 1 value
        };

        // Timerx Capture 2 Register
        struct CPT2ER : public RegisterReadOnly<0x400176b4> {
            using CPT2x = Field<0, 16>;    // Timerx Capture 2 value
        };

        // Timerx Deadtime Register
        struct DTER : public Register<0x400176b8> {
            using DTFLKx = Field<31, 1>;    // Deadtime Falling Lock
            using DTFSLKx = Field<30, 1>;    // Deadtime Falling Sign Lock
            using SDTFx = Field<25, 1>;    // Sign Deadtime Falling value
            using DTFx = Field<16, 9>;    // Deadtime Falling value
            using DTRLKx = Field<15, 1>;    // Deadtime Rising Lock
            using DTRSLKx = Field<14, 1>;    // Deadtime Rising Sign Lock
            using DTPRSC = Field<10, 3>;    // Deadtime Prescaler
            using SDTRx = Field<9, 1>;    // Sign Deadtime Rising value
            using DTRx = Field<0, 9>;    // Deadtime Rising value
        };

        // Timerx Output1 Set Register
        struct SETE1R : public Register<0x400176bc> {
            using UPDATE = Field<31, 1>;    // Registers update (transfer preload to active)
            using EXTEVNT10 = Field<30, 1>;    // External Event 10
            using EXTEVNT9 = Field<29, 1>;    // External Event 9
            using EXTEVNT8 = Field<28, 1>;    // External Event 8
            using EXTEVNT7 = Field<27, 1>;    // External Event 7
            using EXTEVNT6 = Field<26, 1>;    // External Event 6
            using EXTEVNT5 = Field<25, 1>;    // External Event 5
            using EXTEVNT4 = Field<24, 1>;    // External Event 4
            using EXTEVNT3 = Field<23, 1>;    // External Event 3
            using EXTEVNT2 = Field<22, 1>;    // External Event 2
            using EXTEVNT1 = Field<21, 1>;    // External Event 1
            using TIMEVNT9 = Field<20, 1>;    // Timer Event 9
            using TIMEVNT8 = Field<19, 1>;    // Timer Event 8
            using TIMEVNT7 = Field<18, 1>;    // Timer Event 7
            using TIMEVNT6 = Field<17, 1>;    // Timer Event 6
            using TIMEVNT5 = Field<16, 1>;    // Timer Event 5
            using TIMEVNT4 = Field<15, 1>;    // Timer Event 4
            using TIMEVNT3 = Field<14, 1>;    // Timer Event 3
            using TIMEVNT2 = Field<13, 1>;    // Timer Event 2
            using TIMEVNT1 = Field<12, 1>;    // Timer Event 1
            using MSTCMP4 = Field<11, 1>;    // Master Compare 4
            using MSTCMP3 = Field<10, 1>;    // Master Compare 3
            using MSTCMP2 = Field<9, 1>;    // Master Compare 2
            using MSTCMP1 = Field<8, 1>;    // Master Compare 1
            using MSTPER = Field<7, 1>;    // Master Period
            using CMP4 = Field<6, 1>;    // Timer A compare 4
            using CMP3 = Field<5, 1>;    // Timer A compare 3
            using CMP2 = Field<4, 1>;    // Timer A compare 2
            using CMP1 = Field<3, 1>;    // Timer A compare 1
            using PER = Field<2, 1>;    // Timer A Period
            using RESYNC = Field<1, 1>;    // Timer A resynchronizaton
            using SST = Field<0, 1>;    // Software Set trigger
        };

        // Timerx Output1 Reset Register
        struct RSTE1R : public Register<0x400176c0> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SRT = Field<0, 1>;    // SRT
        };

        // Timerx Output2 Set Register
        struct SETE2R : public Register<0x400176c4> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SST = Field<0, 1>;    // SST
        };

        // Timerx Output2 Reset Register
        struct RSTE2R : public Register<0x400176c8> {
            using UPDATE = Field<31, 1>;    // UPDATE
            using EXTEVNT10 = Field<30, 1>;    // EXTEVNT10
            using EXTEVNT9 = Field<29, 1>;    // EXTEVNT9
            using EXTEVNT8 = Field<28, 1>;    // EXTEVNT8
            using EXTEVNT7 = Field<27, 1>;    // EXTEVNT7
            using EXTEVNT6 = Field<26, 1>;    // EXTEVNT6
            using EXTEVNT5 = Field<25, 1>;    // EXTEVNT5
            using EXTEVNT4 = Field<24, 1>;    // EXTEVNT4
            using EXTEVNT3 = Field<23, 1>;    // EXTEVNT3
            using EXTEVNT2 = Field<22, 1>;    // EXTEVNT2
            using EXTEVNT1 = Field<21, 1>;    // EXTEVNT1
            using TIMEVNT9 = Field<20, 1>;    // TIMEVNT9
            using TIMEVNT8 = Field<19, 1>;    // TIMEVNT8
            using TIMEVNT7 = Field<18, 1>;    // TIMEVNT7
            using TIMEVNT6 = Field<17, 1>;    // TIMEVNT6
            using TIMEVNT5 = Field<16, 1>;    // TIMEVNT5
            using TIMEVNT4 = Field<15, 1>;    // TIMEVNT4
            using TIMEVNT3 = Field<14, 1>;    // TIMEVNT3
            using TIMEVNT2 = Field<13, 1>;    // TIMEVNT2
            using TIMEVNT1 = Field<12, 1>;    // TIMEVNT1
            using MSTCMP4 = Field<11, 1>;    // MSTCMP4
            using MSTCMP3 = Field<10, 1>;    // MSTCMP3
            using MSTCMP2 = Field<9, 1>;    // MSTCMP2
            using MSTCMP1 = Field<8, 1>;    // MSTCMP1
            using MSTPER = Field<7, 1>;    // MSTPER
            using CMP4 = Field<6, 1>;    // CMP4
            using CMP3 = Field<5, 1>;    // CMP3
            using CMP2 = Field<4, 1>;    // CMP2
            using CMP1 = Field<3, 1>;    // CMP1
            using PER = Field<2, 1>;    // PER
            using RESYNC = Field<1, 1>;    // RESYNC
            using SRT = Field<0, 1>;    // SRT
        };

        // Timerx External Event Filtering Register 1
        struct EEFER1 : public Register<0x400176cc> {
            using EE5FLTR = Field<25, 4>;    // External Event 5 filter
            using EE5LTCH = Field<24, 1>;    // External Event 5 latch
            using EE4FLTR = Field<19, 4>;    // External Event 4 filter
            using EE4LTCH = Field<18, 1>;    // External Event 4 latch
            using EE3FLTR = Field<13, 4>;    // External Event 3 filter
            using EE3LTCH = Field<12, 1>;    // External Event 3 latch
            using EE2FLTR = Field<7, 4>;    // External Event 2 filter
            using EE2LTCH = Field<6, 1>;    // External Event 2 latch
            using EE1FLTR = Field<1, 4>;    // External Event 1 filter
            using EE1LTCH = Field<0, 1>;    // External Event 1 latch
        };

        // Timerx External Event Filtering Register 2
        struct EEFER2 : public Register<0x400176d0> {
            using EE10FLTR = Field<25, 4>;    // External Event 10 filter
            using EE10LTCH = Field<24, 1>;    // External Event 10 latch
            using EE9FLTR = Field<19, 4>;    // External Event 9 filter
            using EE9LTCH = Field<18, 1>;    // External Event 9 latch
            using EE8FLTR = Field<13, 4>;    // External Event 8 filter
            using EE8LTCH = Field<12, 1>;    // External Event 8 latch
            using EE7FLTR = Field<7, 4>;    // External Event 7 filter
            using EE7LTCH = Field<6, 1>;    // External Event 7 latch
            using EE6FLTR = Field<1, 4>;    // External Event 6 filter
            using EE6LTCH = Field<0, 1>;    // External Event 6 latch
        };

        // TimerA Reset Register
        struct RSTER : public Register<0x400176d4> {
            using TIMDCMP4 = Field<30, 1>;    // Timer D Compare 4
            using TIMDCMP2 = Field<29, 1>;    // Timer D Compare 2
            using TIMDCMP1 = Field<28, 1>;    // Timer D Compare 1
            using TIMCCMP4 = Field<27, 1>;    // Timer C Compare 4
            using TIMCCMP2 = Field<26, 1>;    // Timer C Compare 2
            using TIMCCMP1 = Field<25, 1>;    // Timer C Compare 1
            using TIMBCMP4 = Field<24, 1>;    // Timer B Compare 4
            using TIMBCMP2 = Field<23, 1>;    // Timer B Compare 2
            using TIMBCMP1 = Field<22, 1>;    // Timer B Compare 1
            using TIMACMP4 = Field<21, 1>;    // Timer A Compare 4
            using TIMACMP2 = Field<20, 1>;    // Timer A Compare 2
            using TIMACMP1 = Field<19, 1>;    // Timer A Compare 1
            using EXTEVNT10 = Field<18, 1>;    // External Event 10
            using EXTEVNT9 = Field<17, 1>;    // External Event 9
            using EXTEVNT8 = Field<16, 1>;    // External Event 8
            using EXTEVNT7 = Field<15, 1>;    // External Event 7
            using EXTEVNT6 = Field<14, 1>;    // External Event 6
            using EXTEVNT5 = Field<13, 1>;    // External Event 5
            using EXTEVNT4 = Field<12, 1>;    // External Event 4
            using EXTEVNT3 = Field<11, 1>;    // External Event 3
            using EXTEVNT2 = Field<10, 1>;    // External Event 2
            using EXTEVNT1 = Field<9, 1>;    // External Event 1
            using MSTCMP4 = Field<8, 1>;    // Master compare 4
            using MSTCMP3 = Field<7, 1>;    // Master compare 3
            using MSTCMP2 = Field<6, 1>;    // Master compare 2
            using MSTCMP1 = Field<5, 1>;    // Master compare 1
            using MSTPER = Field<4, 1>;    // Master timer Period
            using CMP4 = Field<3, 1>;    // Timer A compare 4 reset
            using CMP2 = Field<2, 1>;    // Timer A compare 2 reset
            using UPDT = Field<1, 1>;    // Timer A Update reset
        };

        // Timerx Chopper Register
        struct CHPER : public Register<0x400176d8> {
            using STRTPW = Field<7, 4>;    // STRTPW
            using CHPDTY = Field<4, 3>;    // Timerx chopper duty cycle value
            using CHPFRQ = Field<0, 4>;    // Timerx carrier frequency value
        };

        // Timerx Capture 2 Control Register
        struct CPT1ECR : public Register<0x400176dc> {
            using TDCMP2 = Field<27, 1>;    // Timer D Compare 2
            using TDCMP1 = Field<26, 1>;    // Timer D Compare 1
            using TD1RST = Field<25, 1>;    // Timer D output 1 Reset
            using TD1SET = Field<24, 1>;    // Timer D output 1 Set
            using TCCMP2 = Field<23, 1>;    // Timer C Compare 2
            using TCCMP1 = Field<22, 1>;    // Timer C Compare 1
            using TC1RST = Field<21, 1>;    // Timer C output 1 Reset
            using TC1SET = Field<20, 1>;    // Timer C output 1 Set
            using TBCMP2 = Field<19, 1>;    // Timer B Compare 2
            using TBCMP1 = Field<18, 1>;    // Timer B Compare 1
            using TB1RST = Field<17, 1>;    // Timer B output 1 Reset
            using TB1SET = Field<16, 1>;    // Timer B output 1 Set
            using TACMP2 = Field<15, 1>;    // Timer A Compare 2
            using TACMP1 = Field<14, 1>;    // Timer A Compare 1
            using TA1RST = Field<13, 1>;    // Timer A output 1 Reset
            using TA1SET = Field<12, 1>;    // Timer A output 1 Set
            using EXEV10CPT = Field<11, 1>;    // External Event 10 Capture
            using EXEV9CPT = Field<10, 1>;    // External Event 9 Capture
            using EXEV8CPT = Field<9, 1>;    // External Event 8 Capture
            using EXEV7CPT = Field<8, 1>;    // External Event 7 Capture
            using EXEV6CPT = Field<7, 1>;    // External Event 6 Capture
            using EXEV5CPT = Field<6, 1>;    // External Event 5 Capture
            using EXEV4CPT = Field<5, 1>;    // External Event 4 Capture
            using EXEV3CPT = Field<4, 1>;    // External Event 3 Capture
            using EXEV2CPT = Field<3, 1>;    // External Event 2 Capture
            using EXEV1CPT = Field<2, 1>;    // External Event 1 Capture
            using UDPCPT = Field<1, 1>;    // Update Capture
            using SWCPT = Field<0, 1>;    // Software Capture
        };

        // CPT2xCR
        struct CPT2ECR : public Register<0x400176e0> {
            using TDCMP2 = Field<27, 1>;    // Timer D Compare 2
            using TDCMP1 = Field<26, 1>;    // Timer D Compare 1
            using TD1RST = Field<25, 1>;    // Timer D output 1 Reset
            using TD1SET = Field<24, 1>;    // Timer D output 1 Set
            using TCCMP2 = Field<23, 1>;    // Timer C Compare 2
            using TCCMP1 = Field<22, 1>;    // Timer C Compare 1
            using TC1RST = Field<21, 1>;    // Timer C output 1 Reset
            using TC1SET = Field<20, 1>;    // Timer C output 1 Set
            using TBCMP2 = Field<19, 1>;    // Timer B Compare 2
            using TBCMP1 = Field<18, 1>;    // Timer B Compare 1
            using TB1RST = Field<17, 1>;    // Timer B output 1 Reset
            using TB1SET = Field<16, 1>;    // Timer B output 1 Set
            using TACMP2 = Field<15, 1>;    // Timer A Compare 2
            using TACMP1 = Field<14, 1>;    // Timer A Compare 1
            using TA1RST = Field<13, 1>;    // Timer A output 1 Reset
            using TA1SET = Field<12, 1>;    // Timer A output 1 Set
            using EXEV10CPT = Field<11, 1>;    // External Event 10 Capture
            using EXEV9CPT = Field<10, 1>;    // External Event 9 Capture
            using EXEV8CPT = Field<9, 1>;    // External Event 8 Capture
            using EXEV7CPT = Field<8, 1>;    // External Event 7 Capture
            using EXEV6CPT = Field<7, 1>;    // External Event 6 Capture
            using EXEV5CPT = Field<6, 1>;    // External Event 5 Capture
            using EXEV4CPT = Field<5, 1>;    // External Event 4 Capture
            using EXEV3CPT = Field<4, 1>;    // External Event 3 Capture
            using EXEV2CPT = Field<3, 1>;    // External Event 2 Capture
            using EXEV1CPT = Field<2, 1>;    // External Event 1 Capture
            using UDPCPT = Field<1, 1>;    // Update Capture
            using SWCPT = Field<0, 1>;    // Software Capture
        };

        // Timerx Output Register
        struct OUTER : public Register<0x400176e4> {
            using DIDL2 = Field<23, 1>;    // Output 2 Deadtime upon burst mode Idle entry
            using CHP2 = Field<22, 1>;    // Output 2 Chopper enable
            using FAULT2 = Field<20, 2>;    // Output 2 Fault state
            using IDLES2 = Field<19, 1>;    // Output 2 Idle State
            using IDLEM2 = Field<18, 1>;    // Output 2 Idle mode
            using POL2 = Field<17, 1>;    // Output 2 polarity
            using DLYPRT = Field<10, 3>;    // Delayed Protection
            using DLYPRTEN = Field<9, 1>;    // Delayed Protection Enable
            using DTEN = Field<8, 1>;    // Deadtime enable
            using DIDL1 = Field<7, 1>;    // Output 1 Deadtime upon burst mode Idle entry
            using CHP1 = Field<6, 1>;    // Output 1 Chopper enable
            using FAULT1 = Field<4, 2>;    // Output 1 Fault state
            using IDLES1 = Field<3, 1>;    // Output 1 Idle State
            using IDLEM1 = Field<2, 1>;    // Output 1 Idle mode
            using POL1 = Field<1, 1>;    // Output 1 polarity
        };

        // Timerx Fault Register
        struct FLTER : public Register<0x400176e8> {
            using FLTLCK = Field<31, 1>;    // Fault sources Lock
            using FLT5EN = Field<4, 1>;    // Fault 5 enable
            using FLT4EN = Field<3, 1>;    // Fault 4 enable
            using FLT3EN = Field<2, 1>;    // Fault 3 enable
            using FLT2EN = Field<1, 1>;    // Fault 2 enable
            using FLT1EN = Field<0, 1>;    // Fault 1 enable
        };

    };

    // High Resolution Timer: Common functions
    struct HRTIM_Common {
        // Control Register 1
        struct CR1 : public Register<0x40017780> {
            using AD4USRC = Field<25, 3>;    // ADC Trigger 4 Update Source
            using AD3USRC = Field<22, 3>;    // ADC Trigger 3 Update Source
            using AD2USRC = Field<19, 3>;    // ADC Trigger 2 Update Source
            using AD1USRC = Field<16, 3>;    // ADC Trigger 1 Update Source
            using TEUDIS = Field<5, 1>;    // Timer E Update Disable
            using TDUDIS = Field<4, 1>;    // Timer D Update Disable
            using TCUDIS = Field<3, 1>;    // Timer C Update Disable
            using TBUDIS = Field<2, 1>;    // Timer B Update Disable
            using TAUDIS = Field<1, 1>;    // Timer A Update Disable
            using MUDIS = Field<0, 1>;    // Master Update Disable
        };

        // Control Register 2
        struct CR2 : public Register<0x40017784> {
            using TERST = Field<13, 1>;    // Timer E counter software reset
            using TDRST = Field<12, 1>;    // Timer D counter software reset
            using TCRST = Field<11, 1>;    // Timer C counter software reset
            using TBRST = Field<10, 1>;    // Timer B counter software reset
            using TARST = Field<9, 1>;    // Timer A counter software reset
            using MRST = Field<8, 1>;    // Master Counter software reset
            using TESWU = Field<5, 1>;    // Timer E Software Update
            using TDSWU = Field<4, 1>;    // Timer D Software Update
            using TCSWU = Field<3, 1>;    // Timer C Software Update
            using TBSWU = Field<2, 1>;    // Timer B Software Update
            using TASWU = Field<1, 1>;    // Timer A Software update
            using MSWU = Field<0, 1>;    // Master Timer Software update
        };

        // Interrupt Status Register
        struct ISR : public Register<0x40017788> {
            using BMPER = Field<17, 1>;    // Burst mode Period Interrupt Flag
            using DLLRDY = Field<16, 1>;    // DLL Ready Interrupt Flag
            using SYSFLT = Field<5, 1>;    // System Fault Interrupt Flag
            using FLT5 = Field<4, 1>;    // Fault 5 Interrupt Flag
            using FLT4 = Field<3, 1>;    // Fault 4 Interrupt Flag
            using FLT3 = Field<2, 1>;    // Fault 3 Interrupt Flag
            using FLT2 = Field<1, 1>;    // Fault 2 Interrupt Flag
            using FLT1 = Field<0, 1>;    // Fault 1 Interrupt Flag
        };

        // Interrupt Clear Register
        struct ICR : public Register<0x4001778c> {
            using BMPERC = Field<17, 1>;    // Burst mode period flag Clear
            using DLLRDYC = Field<16, 1>;    // DLL Ready Interrupt flag Clear
            using SYSFLTC = Field<5, 1>;    // System Fault Interrupt Flag Clear
            using FLT5C = Field<4, 1>;    // Fault 5 Interrupt Flag Clear
            using FLT4C = Field<3, 1>;    // Fault 4 Interrupt Flag Clear
            using FLT3C = Field<2, 1>;    // Fault 3 Interrupt Flag Clear
            using FLT2C = Field<1, 1>;    // Fault 2 Interrupt Flag Clear
            using FLT1C = Field<0, 1>;    // Fault 1 Interrupt Flag Clear
        };

        // Interrupt Enable Register
        struct IER : public Register<0x40017790> {
            using BMPERIE = Field<17, 1>;    // Burst mode period Interrupt Enable
            using DLLRDYIE = Field<16, 1>;    // DLL Ready Interrupt Enable
            using SYSFLTE = Field<5, 1>;    // System Fault Interrupt Enable
            using FLT5IE = Field<4, 1>;    // Fault 5 Interrupt Enable
            using FLT4IE = Field<3, 1>;    // Fault 4 Interrupt Enable
            using FLT3IE = Field<2, 1>;    // Fault 3 Interrupt Enable
            using FLT2IE = Field<1, 1>;    // Fault 2 Interrupt Enable
            using FLT1IE = Field<0, 1>;    // Fault 1 Interrupt Enable
        };

        // Output Enable Register
        struct OENR : public RegisterWriteOnly<0x40017794> {
            using TE2OEN = Field<9, 1>;    // Timer E Output 2 Enable
            using TE1OEN = Field<8, 1>;    // Timer E Output 1 Enable
            using TD2OEN = Field<7, 1>;    // Timer D Output 2 Enable
            using TD1OEN = Field<6, 1>;    // Timer D Output 1 Enable
            using TC2OEN = Field<5, 1>;    // Timer C Output 2 Enable
            using TC1OEN = Field<4, 1>;    // Timer C Output 1 Enable
            using TB2OEN = Field<3, 1>;    // Timer B Output 2 Enable
            using TB1OEN = Field<2, 1>;    // Timer B Output 1 Enable
            using TA2OEN = Field<1, 1>;    // Timer A Output 2 Enable
            using TA1OEN = Field<0, 1>;    // Timer A Output 1 Enable
        };

        // DISR
        struct DISR : public Register<0x40017798> {
            using TE2ODIS = Field<9, 1>;    // TE2ODIS
            using TE1ODIS = Field<8, 1>;    // TE1ODIS
            using TD2ODIS = Field<7, 1>;    // TD2ODIS
            using TD1ODIS = Field<6, 1>;    // TD1ODIS
            using TC2ODIS = Field<5, 1>;    // TC2ODIS
            using TC1ODIS = Field<4, 1>;    // TC1ODIS
            using TB2ODIS = Field<3, 1>;    // TB2ODIS
            using TB1ODIS = Field<2, 1>;    // TB1ODIS
            using TA2ODIS = Field<1, 1>;    // TA2ODIS
            using TA1ODIS = Field<0, 1>;    // TA1ODIS
        };

        // Output Disable Status Register
        struct ODSR : public RegisterReadOnly<0x4001779c> {
            using TE2ODS = Field<9, 1>;    // Timer E Output 2 disable status
            using TE1ODS = Field<8, 1>;    // Timer E Output 1 disable status
            using TD2ODS = Field<7, 1>;    // Timer D Output 2 disable status
            using TD1ODS = Field<6, 1>;    // Timer D Output 1 disable status
            using TC2ODS = Field<5, 1>;    // Timer C Output 2 disable status
            using TC1ODS = Field<4, 1>;    // Timer C Output 1 disable status
            using TB2ODS = Field<3, 1>;    // Timer B Output 2 disable status
            using TB1ODS = Field<2, 1>;    // Timer B Output 1 disable status
            using TA2ODS = Field<1, 1>;    // Timer A Output 2 disable status
            using TA1ODS = Field<0, 1>;    // Timer A Output 1 disable status
        };

        // Burst Mode Control Register
        struct BMCR : public Register<0x400177a0> {
            using BMSTAT = Field<31, 1>;    // Burst Mode Status
            using TEBM = Field<21, 1>;    // Timer E Burst Mode
            using TDBM = Field<20, 1>;    // Timer D Burst Mode
            using TCBM = Field<19, 1>;    // Timer C Burst Mode
            using TBBM = Field<18, 1>;    // Timer B Burst Mode
            using TABM = Field<17, 1>;    // Timer A Burst Mode
            using MTBM = Field<16, 1>;    // Master Timer Burst Mode
            using BMPREN = Field<10, 1>;    // Burst Mode Preload Enable
            using BMPRSC = Field<6, 4>;    // Burst Mode Prescaler
            using BMCLK = Field<2, 4>;    // Burst Mode Clock source
            using BMOM = Field<1, 1>;    // Burst Mode operating mode
            using BME = Field<0, 1>;    // Burst Mode enable
        };

        // BMTRG
        struct BMTRG : public Register<0x400177a4> {
            using OCHPEV = Field<31, 1>;    // OCHPEV
            using TECMP2 = Field<26, 1>;    // TECMP2
            using TECMP1 = Field<25, 1>;    // TECMP1
            using TEREP = Field<24, 1>;    // TEREP
            using TERST = Field<23, 1>;    // TERST
            using TDCMP2 = Field<22, 1>;    // TDCMP2
            using TDCMP1 = Field<21, 1>;    // TDCMP1
            using TDREP = Field<20, 1>;    // TDREP
            using TDRST = Field<19, 1>;    // TDRST
            using TCCMP2 = Field<18, 1>;    // TCCMP2
            using TCCMP1 = Field<17, 1>;    // TCCMP1
            using TCREP = Field<16, 1>;    // TCREP
            using TCRST = Field<15, 1>;    // TCRST
            using TBCMP2 = Field<14, 1>;    // TBCMP2
            using TBCMP1 = Field<13, 1>;    // TBCMP1
            using TBREP = Field<12, 1>;    // TBREP
            using TBRST = Field<11, 1>;    // TBRST
            using TACMP2 = Field<10, 1>;    // TACMP2
            using TACMP1 = Field<9, 1>;    // TACMP1
            using TAREP = Field<8, 1>;    // TAREP
            using TARST = Field<7, 1>;    // TARST
            using MSTCMP4 = Field<6, 1>;    // MSTCMP4
            using MSTCMP3 = Field<5, 1>;    // MSTCMP3
            using MSTCMP2 = Field<4, 1>;    // MSTCMP2
            using MSTCMP1 = Field<3, 1>;    // MSTCMP1
            using MSTREP = Field<2, 1>;    // MSTREP
            using MSTRST = Field<1, 1>;    // MSTRST
            using SW = Field<0, 1>;    // SW
        };

        // BMCMPR6
        struct BMCMPR6 : public Register<0x400177a8> {
            using BMCMP = Field<0, 16>;    // BMCMP
        };

        // Burst Mode Period Register
        struct BMPER : public Register<0x400177ac> {
            using Field = Field<0, 16>;    // Burst mode Period
        };

        // Timer External Event Control Register 1
        struct EECR1 : public Register<0x400177b0> {
            using EE5FAST = Field<29, 1>;    // External Event 5 Fast mode
            using EE5SNS = Field<27, 2>;    // External Event 5 Sensitivity
            using EE5POL = Field<26, 1>;    // External Event 5 Polarity
            using EE5SRC = Field<24, 2>;    // External Event 5 Source
            using EE4FAST = Field<23, 1>;    // External Event 4 Fast mode
            using EE4SNS = Field<21, 2>;    // External Event 4 Sensitivity
            using EE4POL = Field<20, 1>;    // External Event 4 Polarity
            using EE4SRC = Field<18, 2>;    // External Event 4 Source
            using EE3FAST = Field<17, 1>;    // External Event 3 Fast mode
            using EE3SNS = Field<15, 2>;    // External Event 3 Sensitivity
            using EE3POL = Field<14, 1>;    // External Event 3 Polarity
            using EE3SRC = Field<12, 2>;    // External Event 3 Source
            using EE2FAST = Field<11, 1>;    // External Event 2 Fast mode
            using EE2SNS = Field<9, 2>;    // External Event 2 Sensitivity
            using EE2POL = Field<8, 1>;    // External Event 2 Polarity
            using EE2SRC = Field<6, 2>;    // External Event 2 Source
            using EE1FAST = Field<5, 1>;    // External Event 1 Fast mode
            using EE1SNS = Field<3, 2>;    // External Event 1 Sensitivity
            using EE1POL = Field<2, 1>;    // External Event 1 Polarity
            using EE1SRC = Field<0, 2>;    // External Event 1 Source
        };

        // Timer External Event Control Register 2
        struct EECR2 : public Register<0x400177b4> {
            using EE10SNS = Field<27, 2>;    // External Event 10 Sensitivity
            using EE10POL = Field<26, 1>;    // External Event 10 Polarity
            using EE10SRC = Field<24, 2>;    // External Event 10 Source
            using EE9SNS = Field<21, 2>;    // External Event 9 Sensitivity
            using EE9POL = Field<20, 1>;    // External Event 9 Polarity
            using EE9SRC = Field<18, 2>;    // External Event 9 Source
            using EE8SNS = Field<15, 2>;    // External Event 8 Sensitivity
            using EE8POL = Field<14, 1>;    // External Event 8 Polarity
            using EE8SRC = Field<12, 2>;    // External Event 8 Source
            using EE7SNS = Field<9, 2>;    // External Event 7 Sensitivity
            using EE7POL = Field<8, 1>;    // External Event 7 Polarity
            using EE7SRC = Field<6, 2>;    // External Event 7 Source
            using EE6SNS = Field<3, 2>;    // External Event 6 Sensitivity
            using EE6POL = Field<2, 1>;    // External Event 6 Polarity
            using EE6SRC = Field<0, 2>;    // External Event 6 Source
        };

        // Timer External Event Control Register 3
        struct EECR3 : public Register<0x400177b8> {
            using EE10SNS = Field<27, 2>;    // EE10SNS
            using EE10POL = Field<26, 1>;    // EE10POL
            using EE10SRC = Field<24, 2>;    // EE10SRC
            using EE9SNS = Field<21, 2>;    // EE9SNS
            using EE9POL = Field<20, 1>;    // EE9POL
            using EE9SRC = Field<18, 2>;    // EE9SRC
            using EE8SNS = Field<15, 2>;    // EE8SNS
            using EE8POL = Field<14, 1>;    // EE8POL
            using EE8SRC = Field<12, 2>;    // EE8SRC
            using EE7SNS = Field<9, 2>;    // EE7SNS
            using EE7POL = Field<8, 1>;    // EE7POL
            using EE7SRC = Field<6, 2>;    // EE7SRC
            using EE6SNS = Field<3, 2>;    // EE6SNS
            using EE6POL = Field<2, 1>;    // EE6POL
            using EE6SRC = Field<0, 2>;    // EE6SRC
        };

        // ADC Trigger 1 Register
        struct ADC1R : public Register<0x400177bc> {
            using AD1TEPER = Field<31, 1>;    // ADC trigger 1 on Timer E Period
            using AD1TEC4 = Field<30, 1>;    // ADC trigger 1 on Timer E compare 4
            using AD1TEC3 = Field<29, 1>;    // ADC trigger 1 on Timer E compare 3
            using AD1TEC2 = Field<28, 1>;    // ADC trigger 1 on Timer E compare 2
            using AD1TDPER = Field<27, 1>;    // ADC trigger 1 on Timer D Period
            using AD1TDC4 = Field<26, 1>;    // ADC trigger 1 on Timer D compare 4
            using AD1TDC3 = Field<25, 1>;    // ADC trigger 1 on Timer D compare 3
            using AD1TDC2 = Field<24, 1>;    // ADC trigger 1 on Timer D compare 2
            using AD1TCPER = Field<23, 1>;    // ADC trigger 1 on Timer C Period
            using AD1TCC4 = Field<22, 1>;    // ADC trigger 1 on Timer C compare 4
            using AD1TCC3 = Field<21, 1>;    // ADC trigger 1 on Timer C compare 3
            using AD1TCC2 = Field<20, 1>;    // ADC trigger 1 on Timer C compare 2
            using AD1TBRST = Field<19, 1>;    // ADC trigger 1 on Timer B Reset
            using AD1TBPER = Field<18, 1>;    // ADC trigger 1 on Timer B Period
            using AD1TBC4 = Field<17, 1>;    // ADC trigger 1 on Timer B compare 4
            using AD1TBC3 = Field<16, 1>;    // ADC trigger 1 on Timer B compare 3
            using AD1TBC2 = Field<15, 1>;    // ADC trigger 1 on Timer B compare 2
            using AD1TARST = Field<14, 1>;    // ADC trigger 1 on Timer A Reset
            using AD1TAPER = Field<13, 1>;    // ADC trigger 1 on Timer A Period
            using AD1TAC4 = Field<12, 1>;    // ADC trigger 1 on Timer A compare 4
            using AD1TAC3 = Field<11, 1>;    // ADC trigger 1 on Timer A compare 3
            using AD1TAC2 = Field<10, 1>;    // ADC trigger 1 on Timer A compare 2
            using AD1EEV5 = Field<9, 1>;    // ADC trigger 1 on External Event 5
            using AD1EEV4 = Field<8, 1>;    // ADC trigger 1 on External Event 4
            using AD1EEV3 = Field<7, 1>;    // ADC trigger 1 on External Event 3
            using AD1EEV2 = Field<6, 1>;    // ADC trigger 1 on External Event 2
            using AD1EEV1 = Field<5, 1>;    // ADC trigger 1 on External Event 1
            using AD1MPER = Field<4, 1>;    // ADC trigger 1 on Master Period
            using AD1MC4 = Field<3, 1>;    // ADC trigger 1 on Master Compare 4
            using AD1MC3 = Field<2, 1>;    // ADC trigger 1 on Master Compare 3
            using AD1MC2 = Field<1, 1>;    // ADC trigger 1 on Master Compare 2
            using AD1MC1 = Field<0, 1>;    // ADC trigger 1 on Master Compare 1
        };

        // ADC Trigger 2 Register
        struct ADC2R : public Register<0x400177c0> {
            using AD2TERST = Field<31, 1>;    // ADC trigger 2 on Timer E Reset
            using AD2TEC4 = Field<30, 1>;    // ADC trigger 2 on Timer E compare 4
            using AD2TEC3 = Field<29, 1>;    // ADC trigger 2 on Timer E compare 3
            using AD2TEC2 = Field<28, 1>;    // ADC trigger 2 on Timer E compare 2
            using AD2TDRST = Field<27, 1>;    // ADC trigger 2 on Timer D Reset
            using AD2TDPER = Field<26, 1>;    // ADC trigger 2 on Timer D Period
            using AD2TDC4 = Field<25, 1>;    // ADC trigger 2 on Timer D compare 4
            using AD2TDC3 = Field<24, 1>;    // ADC trigger 2 on Timer D compare 3
            using AD2TDC2 = Field<23, 1>;    // ADC trigger 2 on Timer D compare 2
            using AD2TCRST = Field<22, 1>;    // ADC trigger 2 on Timer C Reset
            using AD2TCPER = Field<21, 1>;    // ADC trigger 2 on Timer C Period
            using AD2TCC4 = Field<20, 1>;    // ADC trigger 2 on Timer C compare 4
            using AD2TCC3 = Field<19, 1>;    // ADC trigger 2 on Timer C compare 3
            using AD2TCC2 = Field<18, 1>;    // ADC trigger 2 on Timer C compare 2
            using AD2TBPER = Field<17, 1>;    // ADC trigger 2 on Timer B Period
            using AD2TBC4 = Field<16, 1>;    // ADC trigger 2 on Timer B compare 4
            using AD2TBC3 = Field<15, 1>;    // ADC trigger 2 on Timer B compare 3
            using AD2TBC2 = Field<14, 1>;    // ADC trigger 2 on Timer B compare 2
            using AD2TAPER = Field<13, 1>;    // ADC trigger 2 on Timer A Period
            using AD2TAC4 = Field<12, 1>;    // ADC trigger 2 on Timer A compare 4
            using AD2TAC3 = Field<11, 1>;    // ADC trigger 2 on Timer A compare 3
            using AD2TAC2 = Field<10, 1>;    // ADC trigger 2 on Timer A compare 2
            using AD2EEV10 = Field<9, 1>;    // ADC trigger 2 on External Event 10
            using AD2EEV9 = Field<8, 1>;    // ADC trigger 2 on External Event 9
            using AD2EEV8 = Field<7, 1>;    // ADC trigger 2 on External Event 8
            using AD2EEV7 = Field<6, 1>;    // ADC trigger 2 on External Event 7
            using AD2EEV6 = Field<5, 1>;    // ADC trigger 2 on External Event 6
            using AD2MPER = Field<4, 1>;    // ADC trigger 2 on Master Period
            using AD2MC4 = Field<3, 1>;    // ADC trigger 2 on Master Compare 4
            using AD2MC3 = Field<2, 1>;    // ADC trigger 2 on Master Compare 3
            using AD2MC2 = Field<1, 1>;    // ADC trigger 2 on Master Compare 2
            using AD2MC1 = Field<0, 1>;    // ADC trigger 2 on Master Compare 1
        };

        // ADC Trigger 3 Register
        struct ADC3R : public Register<0x400177c4> {
            using AD1TEPER = Field<31, 1>;    // AD1TEPER
            using AD1TEC4 = Field<30, 1>;    // AD1TEC4
            using AD1TEC3 = Field<29, 1>;    // AD1TEC3
            using AD1TEC2 = Field<28, 1>;    // AD1TEC2
            using AD1TDPER = Field<27, 1>;    // AD1TDPER
            using AD1TDC4 = Field<26, 1>;    // AD1TDC4
            using AD1TDC3 = Field<25, 1>;    // AD1TDC3
            using AD1TDC2 = Field<24, 1>;    // AD1TDC2
            using AD1TCPER = Field<23, 1>;    // AD1TCPER
            using AD1TCC4 = Field<22, 1>;    // AD1TCC4
            using AD1TCC3 = Field<21, 1>;    // AD1TCC3
            using AD1TCC2 = Field<20, 1>;    // AD1TCC2
            using AD1TBRST = Field<19, 1>;    // AD1TBRST
            using AD1TBPER = Field<18, 1>;    // AD1TBPER
            using AD1TBC4 = Field<17, 1>;    // AD1TBC4
            using AD1TBC3 = Field<16, 1>;    // AD1TBC3
            using AD1TBC2 = Field<15, 1>;    // AD1TBC2
            using AD1TARST = Field<14, 1>;    // AD1TARST
            using AD1TAPER = Field<13, 1>;    // AD1TAPER
            using AD1TAC4 = Field<12, 1>;    // AD1TAC4
            using AD1TAC3 = Field<11, 1>;    // AD1TAC3
            using AD1TAC2 = Field<10, 1>;    // AD1TAC2
            using AD1EEV5 = Field<9, 1>;    // AD1EEV5
            using AD1EEV4 = Field<8, 1>;    // AD1EEV4
            using AD1EEV3 = Field<7, 1>;    // AD1EEV3
            using AD1EEV2 = Field<6, 1>;    // AD1EEV2
            using AD1EEV1 = Field<5, 1>;    // AD1EEV1
            using AD1MPER = Field<4, 1>;    // AD1MPER
            using AD1MC4 = Field<3, 1>;    // AD1MC4
            using AD1MC3 = Field<2, 1>;    // AD1MC3
            using AD1MC2 = Field<1, 1>;    // AD1MC2
            using AD1MC1 = Field<0, 1>;    // AD1MC1
        };

        // ADC Trigger 4 Register
        struct ADC4R : public Register<0x400177c8> {
            using AD2TERST = Field<31, 1>;    // AD2TERST
            using AD2TEC4 = Field<30, 1>;    // AD2TEC4
            using AD2TEC3 = Field<29, 1>;    // AD2TEC3
            using AD2TEC2 = Field<28, 1>;    // AD2TEC2
            using AD2TDRST = Field<27, 1>;    // AD2TDRST
            using AD2TDPER = Field<26, 1>;    // AD2TDPER
            using AD2TDC4 = Field<25, 1>;    // AD2TDC4
            using AD2TDC3 = Field<24, 1>;    // AD2TDC3
            using AD2TDC2 = Field<23, 1>;    // AD2TDC2
            using AD2TCRST = Field<22, 1>;    // AD2TCRST
            using AD2TCPER = Field<21, 1>;    // AD2TCPER
            using AD2TCC4 = Field<20, 1>;    // AD2TCC4
            using AD2TCC3 = Field<19, 1>;    // AD2TCC3
            using AD2TCC2 = Field<18, 1>;    // AD2TCC2
            using AD2TBPER = Field<17, 1>;    // AD2TBPER
            using AD2TBC4 = Field<16, 1>;    // AD2TBC4
            using AD2TBC3 = Field<15, 1>;    // AD2TBC3
            using AD2TBC2 = Field<14, 1>;    // AD2TBC2
            using AD2TAPER = Field<13, 1>;    // AD2TAPER
            using AD2TAC4 = Field<12, 1>;    // AD2TAC4
            using AD2TAC3 = Field<11, 1>;    // AD2TAC3
            using AD2TAC2 = Field<10, 1>;    // AD2TAC2
            using AD2EEV10 = Field<9, 1>;    // AD2EEV10
            using AD2EEV9 = Field<8, 1>;    // AD2EEV9
            using AD2EEV8 = Field<7, 1>;    // AD2EEV8
            using AD2EEV7 = Field<6, 1>;    // AD2EEV7
            using AD2EEV6 = Field<5, 1>;    // AD2EEV6
            using AD2MPER = Field<4, 1>;    // AD2MPER
            using AD2MC4 = Field<3, 1>;    // AD2MC4
            using AD2MC3 = Field<2, 1>;    // AD2MC3
            using AD2MC2 = Field<1, 1>;    // AD2MC2
            using AD2MC1 = Field<0, 1>;    // AD2MC1
        };

        // DLL Control Register
        struct DLLCR : public Register<0x400177cc> {
            using CALRTE = Field<2, 2>;    // DLL Calibration rate
            using CALEN = Field<1, 1>;    // DLL Calibration Enable
            using CAL = Field<0, 1>;    // DLL Calibration Start
        };

        // HRTIM Fault Input Register 1
        struct FLTINR1 : public Register<0x400177d0> {
            using FLT4LCK = Field<31, 1>;    // FLT4LCK
            using FLT4F = Field<27, 4>;    // FLT4F
            using FLT4SRC = Field<26, 1>;    // FLT4SRC
            using FLT4P = Field<25, 1>;    // FLT4P
            using FLT4E = Field<24, 1>;    // FLT4E
            using FLT3LCK = Field<23, 1>;    // FLT3LCK
            using FLT3F = Field<19, 4>;    // FLT3F
            using FLT3SRC = Field<18, 1>;    // FLT3SRC
            using FLT3P = Field<17, 1>;    // FLT3P
            using FLT3E = Field<16, 1>;    // FLT3E
            using FLT2LCK = Field<15, 1>;    // FLT2LCK
            using FLT2F = Field<11, 4>;    // FLT2F
            using FLT2SRC = Field<10, 1>;    // FLT2SRC
            using FLT2P = Field<9, 1>;    // FLT2P
            using FLT2E = Field<8, 1>;    // FLT2E
            using FLT1LCK = Field<7, 1>;    // FLT1LCK
            using FLT1F = Field<3, 4>;    // FLT1F
            using FLT1SRC = Field<2, 1>;    // FLT1SRC
            using FLT1P = Field<1, 1>;    // FLT1P
            using FLT1E = Field<0, 1>;    // FLT1E
        };

        // HRTIM Fault Input Register 2
        struct FLTINR2 : public Register<0x400177d4> {
            using FLTSD = Field<24, 2>;    // FLTSD
            using FLT5LCK = Field<7, 1>;    // FLT5LCK
            using FLT5F = Field<3, 4>;    // FLT5F
            using FLT5SRC = Field<2, 1>;    // FLT5SRC
            using FLT5P = Field<1, 1>;    // FLT5P
            using FLT5E = Field<0, 1>;    // FLT5E
        };

        // BDMUPDR
        struct BDMUPDR : public Register<0x400177d8> {
            using MCMP4 = Field<9, 1>;    // MCMP4
            using MCMP3 = Field<8, 1>;    // MCMP3
            using MCMP2 = Field<7, 1>;    // MCMP2
            using MCMP1 = Field<6, 1>;    // MCMP1
            using MREP = Field<5, 1>;    // MREP
            using MPER = Field<4, 1>;    // MPER
            using MCNT = Field<3, 1>;    // MCNT
            using MDIER = Field<2, 1>;    // MDIER
            using MICR = Field<1, 1>;    // MICR
            using MCR = Field<0, 1>;    // MCR
        };

        // Burst DMA Timerx update Register
        struct BDTxUPR : public Register<0x400177dc> {
            using TIMxFLTR = Field<20, 1>;    // HRTIM_FLTxR register update enable
            using TIMxOUTR = Field<19, 1>;    // HRTIM_OUTxR register update enable
            using TIMxCHPR = Field<18, 1>;    // HRTIM_CHPxR register update enable
            using TIMxRSTR = Field<17, 1>;    // HRTIM_RSTxR register update enable
            using TIMxEEFR2 = Field<16, 1>;    // HRTIM_EEFxR2 register update enable
            using TIMxEEFR1 = Field<15, 1>;    // HRTIM_EEFxR1 register update enable
            using TIMxRST2R = Field<14, 1>;    // HRTIM_RST2xR register update enable
            using TIMxSET2R = Field<13, 1>;    // HRTIM_SET2xR register update enable
            using TIMxRST1R = Field<12, 1>;    // HRTIM_RST1xR register update enable
            using TIMxSET1R = Field<11, 1>;    // HRTIM_SET1xR register update enable
            using TIMx_DTxR = Field<10, 1>;    // HRTIM_DTxR register update enable
            using TIMxCMP4 = Field<9, 1>;    // HRTIM_CMP4xR register update enable
            using TIMxCMP3 = Field<8, 1>;    // HRTIM_CMP3xR register update enable
            using TIMxCMP2 = Field<7, 1>;    // HRTIM_CMP2xR register update enable
            using TIMxCMP1 = Field<6, 1>;    // HRTIM_CMP1xR register update enable
            using TIMxREP = Field<5, 1>;    // HRTIM_REPxR register update enable
            using TIMxPER = Field<4, 1>;    // HRTIM_PERxR register update enable
            using TIMxCNT = Field<3, 1>;    // HRTIM_CNTxR register update enable
            using TIMxDIER = Field<2, 1>;    // HRTIM_TIMxDIER register update enable
            using TIMxICR = Field<1, 1>;    // HRTIM_TIMxICR register update enable
            using TIMxCR = Field<0, 1>;    // HRTIM_TIMxCR register update enable
        };

        // Burst DMA Data Register
        struct BDMADR : public Register<0x400177e0> {
            using Field = Field<0, 32>;    // Burst DMA Data register
        };

    };

    // Digital filter for sigma delta modulators
    struct DFSDM {
        // DFSDM channel configuration 0 register 1
        struct DFSDM_CHCFG0R1 : public Register<0x40017000> {
            using SITP = Field<0, 2>;    // Serial interface type for channel 0
            using SPICKSEL = Field<2, 2>;    // SPI clock select for channel 0
            using SCDEN = Field<5, 1>;    // Short-circuit detector enable on channel 0
            using CKABEN = Field<6, 1>;    // Clock absence detector enable on channel 0
            using CHEN = Field<7, 1>;    // Channel 0 enable
            using CHINSEL = Field<8, 1>;    // Channel inputs selection
            using DATMPX = Field<12, 2>;    // Input data multiplexer for channel 0
            using DATPACK = Field<14, 2>;    // Data packing mode in DFSDM_CHDATINyR register
            using CKOUTDIV = Field<16, 8>;    // Output serial clock divider
            using CKOUTSRC = Field<30, 1>;    // Output serial clock source selection
            using DFSDMEN = Field<31, 1>;    // Global enable for DFSDM interface
        };

        // DFSDM channel configuration 1 register 1
        struct DFSDM_CHCFG1R1 : public Register<0x40017004> {
            using SITP = Field<0, 2>;    // Serial interface type for channel 1
            using SPICKSEL = Field<2, 2>;    // SPI clock select for channel 1
            using SCDEN = Field<5, 1>;    // Short-circuit detector enable on channel 1
            using CKABEN = Field<6, 1>;    // Clock absence detector enable on channel 1
            using CHEN = Field<7, 1>;    // Channel 1 enable
            using CHINSEL = Field<8, 1>;    // Channel inputs selection
            using DATMPX = Field<12, 2>;    // Input data multiplexer for channel 1
            using DATPACK = Field<14, 2>;    // Data packing mode in DFSDM_CHDATINyR register
            using CKOUTDIV = Field<16, 8>;    // Output serial clock divider
            using CKOUTSRC = Field<30, 1>;    // Output serial clock source selection
            using DFSDMEN = Field<31, 1>;    // Global enable for DFSDM interface
        };

        // DFSDM channel configuration 2 register 1
        struct DFSDM_CHCFG2R1 : public Register<0x40017008> {
            using SITP = Field<0, 2>;    // Serial interface type for channel 2
            using SPICKSEL = Field<2, 2>;    // SPI clock select for channel 2
            using SCDEN = Field<5, 1>;    // Short-circuit detector enable on channel 2
            using CKABEN = Field<6, 1>;    // Clock absence detector enable on channel 2
            using CHEN = Field<7, 1>;    // Channel 2 enable
            using CHINSEL = Field<8, 1>;    // Channel inputs selection
            using DATMPX = Field<12, 2>;    // Input data multiplexer for channel 2
            using DATPACK = Field<14, 2>;    // Data packing mode in DFSDM_CHDATINyR register
            using CKOUTDIV = Field<16, 8>;    // Output serial clock divider
            using CKOUTSRC = Field<30, 1>;    // Output serial clock source selection
            using DFSDMEN = Field<31, 1>;    // Global enable for DFSDM interface
        };

        // DFSDM channel configuration 3 register 1
        struct DFSDM_CHCFG3R1 : public Register<0x4001700c> {
            using SITP = Field<0, 2>;    // Serial interface type for channel 3
            using SPICKSEL = Field<2, 2>;    // SPI clock select for channel 3
            using SCDEN = Field<5, 1>;    // Short-circuit detector enable on channel 3
            using CKABEN = Field<6, 1>;    // Clock absence detector enable on channel 3
            using CHEN = Field<7, 1>;    // Channel 3 enable
            using CHINSEL = Field<8, 1>;    // Channel inputs selection
            using DATMPX = Field<12, 2>;    // Input data multiplexer for channel 3
            using DATPACK = Field<14, 2>;    // Data packing mode in DFSDM_CHDATINyR register
            using CKOUTDIV = Field<16, 8>;    // Output serial clock divider
            using CKOUTSRC = Field<30, 1>;    // Output serial clock source selection
            using DFSDMEN = Field<31, 1>;    // Global enable for DFSDM interface
        };

        // DFSDM channel configuration 4 register 1
        struct DFSDM_CHCFG4R1 : public Register<0x40017010> {
            using SITP = Field<0, 2>;    // Serial interface type for channel 4
            using SPICKSEL = Field<2, 2>;    // SPI clock select for channel 4
            using SCDEN = Field<5, 1>;    // Short-circuit detector enable on channel 4
            using CKABEN = Field<6, 1>;    // Clock absence detector enable on channel 4
            using CHEN = Field<7, 1>;    // Channel 4 enable
            using CHINSEL = Field<8, 1>;    // Channel inputs selection
            using DATMPX = Field<12, 2>;    // Input data multiplexer for channel 4
            using DATPACK = Field<14, 2>;    // Data packing mode in DFSDM_CHDATINyR register
            using CKOUTDIV = Field<16, 8>;    // Output serial clock divider
            using CKOUTSRC = Field<30, 1>;    // Output serial clock source selection
            using DFSDMEN = Field<31, 1>;    // Global enable for DFSDM interface
        };

        // DFSDM channel configuration 5 register 1
        struct DFSDM_CHCFG5R1 : public Register<0x40017014> {
            using SITP = Field<0, 2>;    // Serial interface type for channel 5
            using SPICKSEL = Field<2, 2>;    // SPI clock select for channel 5
            using SCDEN = Field<5, 1>;    // Short-circuit detector enable on channel 5
            using CKABEN = Field<6, 1>;    // Clock absence detector enable on channel 5
            using CHEN = Field<7, 1>;    // Channel 5 enable
            using CHINSEL = Field<8, 1>;    // Channel inputs selection
            using DATMPX = Field<12, 2>;    // Input data multiplexer for channel 5
            using DATPACK = Field<14, 2>;    // Data packing mode in DFSDM_CHDATINyR register
            using CKOUTDIV = Field<16, 8>;    // Output serial clock divider
            using CKOUTSRC = Field<30, 1>;    // Output serial clock source selection
            using DFSDMEN = Field<31, 1>;    // Global enable for DFSDM interface
        };

        // DFSDM channel configuration 6 register 1
        struct DFSDM_CHCFG6R1 : public Register<0x40017018> {
            using SITP = Field<0, 2>;    // Serial interface type for channel 6
            using SPICKSEL = Field<2, 2>;    // SPI clock select for channel 6
            using SCDEN = Field<5, 1>;    // Short-circuit detector enable on channel 6
            using CKABEN = Field<6, 1>;    // Clock absence detector enable on channel 6
            using CHEN = Field<7, 1>;    // Channel 6 enable
            using CHINSEL = Field<8, 1>;    // Channel inputs selection
            using DATMPX = Field<12, 2>;    // Input data multiplexer for channel 6
            using DATPACK = Field<14, 2>;    // Data packing mode in DFSDM_CHDATINyR register
            using CKOUTDIV = Field<16, 8>;    // Output serial clock divider
            using CKOUTSRC = Field<30, 1>;    // Output serial clock source selection
            using DFSDMEN = Field<31, 1>;    // Global enable for DFSDM interface
        };

        // DFSDM channel configuration 7 register 1
        struct DFSDM_CHCFG7R1 : public Register<0x4001701c> {
            using SITP = Field<0, 2>;    // Serial interface type for channel 7
            using SPICKSEL = Field<2, 2>;    // SPI clock select for channel 7
            using SCDEN = Field<5, 1>;    // Short-circuit detector enable on channel 7
            using CKABEN = Field<6, 1>;    // Clock absence detector enable on channel 7
            using CHEN = Field<7, 1>;    // Channel 7 enable
            using CHINSEL = Field<8, 1>;    // Channel inputs selection
            using DATMPX = Field<12, 2>;    // Input data multiplexer for channel 7
            using DATPACK = Field<14, 2>;    // Data packing mode in DFSDM_CHDATINyR register
            using CKOUTDIV = Field<16, 8>;    // Output serial clock divider
            using CKOUTSRC = Field<30, 1>;    // Output serial clock source selection
            using DFSDMEN = Field<31, 1>;    // Global enable for DFSDM interface
        };

        // DFSDM channel configuration 0 register 2
        struct DFSDM_CHCFG0R2 : public Register<0x40017020> {
            using DTRBS = Field<3, 5>;    // Data right bit-shift for channel 0
            using OFFSET = Field<8, 24>;    // 24-bit calibration offset for channel 0
        };

        // DFSDM channel configuration 1 register 2
        struct DFSDM_CHCFG1R2 : public Register<0x40017024> {
            using DTRBS = Field<3, 5>;    // Data right bit-shift for channel 1
            using OFFSET = Field<8, 24>;    // 24-bit calibration offset for channel 1
        };

        // DFSDM channel configuration 2 register 2
        struct DFSDM_CHCFG2R2 : public Register<0x40017028> {
            using DTRBS = Field<3, 5>;    // Data right bit-shift for channel 2
            using OFFSET = Field<8, 24>;    // 24-bit calibration offset for channel 2
        };

        // DFSDM channel configuration 3 register 2
        struct DFSDM_CHCFG3R2 : public Register<0x4001702c> {
            using DTRBS = Field<3, 5>;    // Data right bit-shift for channel 3
            using OFFSET = Field<8, 24>;    // 24-bit calibration offset for channel 3
        };

        // DFSDM channel configuration 4 register 2
        struct DFSDM_CHCFG4R2 : public Register<0x40017030> {
            using DTRBS = Field<3, 5>;    // Data right bit-shift for channel 4
            using OFFSET = Field<8, 24>;    // 24-bit calibration offset for channel 4
        };

        // DFSDM channel configuration 5 register 2
        struct DFSDM_CHCFG5R2 : public Register<0x40017034> {
            using DTRBS = Field<3, 5>;    // Data right bit-shift for channel 5
            using OFFSET = Field<8, 24>;    // 24-bit calibration offset for channel 5
        };

        // DFSDM channel configuration 6 register 2
        struct DFSDM_CHCFG6R2 : public Register<0x40017038> {
            using DTRBS = Field<3, 5>;    // Data right bit-shift for channel 6
            using OFFSET = Field<8, 24>;    // 24-bit calibration offset for channel 6
        };

        // DFSDM channel configuration 7 register 2
        struct DFSDM_CHCFG7R2 : public Register<0x4001703c> {
            using DTRBS = Field<3, 5>;    // Data right bit-shift for channel 7
            using OFFSET = Field<8, 24>;    // 24-bit calibration offset for channel 7
        };

        // DFSDM analog watchdog and short-circuit detector register
        struct DFSDM_AWSCD0R : public Register<0x40017040> {
            using SCDT = Field<0, 8>;    // short-circuit detector threshold for channel 0
            using BKSCD = Field<12, 4>;    // Break signal assignment for short-circuit detector on channel 0
            using AWFOSR = Field<16, 5>;    // Analog watchdog filter oversampling ratio (decimation rate) on channel 0
            using AWFORD = Field<22, 2>;    // Analog watchdog Sinc filter order on channel 0
        };

        // DFSDM analog watchdog and short-circuit detector register
        struct DFSDM_AWSCD1R : public Register<0x40017044> {
            using SCDT = Field<0, 8>;    // short-circuit detector threshold for channel 1
            using BKSCD = Field<12, 4>;    // Break signal assignment for short-circuit detector on channel 1
            using AWFOSR = Field<16, 5>;    // Analog watchdog filter oversampling ratio (decimation rate) on channel 1
            using AWFORD = Field<22, 2>;    // Analog watchdog Sinc filter order on channel 1
        };

        // DFSDM analog watchdog and short-circuit detector register
        struct DFSDM_AWSCD2R : public Register<0x40017048> {
            using SCDT = Field<0, 8>;    // short-circuit detector threshold for channel 2
            using BKSCD = Field<12, 4>;    // Break signal assignment for short-circuit detector on channel 2
            using AWFOSR = Field<16, 5>;    // Analog watchdog filter oversampling ratio (decimation rate) on channel 2
            using AWFORD = Field<22, 2>;    // Analog watchdog Sinc filter order on channel 2
        };

        // DFSDM analog watchdog and short-circuit detector register
        struct DFSDM_AWSCD3R : public Register<0x4001704c> {
            using SCDT = Field<0, 8>;    // short-circuit detector threshold for channel 3
            using BKSCD = Field<12, 4>;    // Break signal assignment for short-circuit detector on channel 3
            using AWFOSR = Field<16, 5>;    // Analog watchdog filter oversampling ratio (decimation rate) on channel 3
            using AWFORD = Field<22, 2>;    // Analog watchdog Sinc filter order on channel 3
        };

        // DFSDM analog watchdog and short-circuit detector register
        struct DFSDM_AWSCD4R : public Register<0x40017050> {
            using SCDT = Field<0, 8>;    // short-circuit detector threshold for channel 4
            using BKSCD = Field<12, 4>;    // Break signal assignment for short-circuit detector on channel 4
            using AWFOSR = Field<16, 5>;    // Analog watchdog filter oversampling ratio (decimation rate) on channel 4
            using AWFORD = Field<22, 2>;    // Analog watchdog Sinc filter order on channel 4
        };

        // DFSDM analog watchdog and short-circuit detector register
        struct DFSDM_AWSCD5R : public Register<0x40017054> {
            using SCDT = Field<0, 8>;    // short-circuit detector threshold for channel 5
            using BKSCD = Field<12, 4>;    // Break signal assignment for short-circuit detector on channel 5
            using AWFOSR = Field<16, 5>;    // Analog watchdog filter oversampling ratio (decimation rate) on channel 5
            using AWFORD = Field<22, 2>;    // Analog watchdog Sinc filter order on channel 5
        };

        // DFSDM analog watchdog and short-circuit detector register
        struct DFSDM_AWSCD6R : public Register<0x40017058> {
            using SCDT = Field<0, 8>;    // short-circuit detector threshold for channel 6
            using BKSCD = Field<12, 4>;    // Break signal assignment for short-circuit detector on channel 6
            using AWFOSR = Field<16, 5>;    // Analog watchdog filter oversampling ratio (decimation rate) on channel 6
            using AWFORD = Field<22, 2>;    // Analog watchdog Sinc filter order on channel 6
        };

        // DFSDM analog watchdog and short-circuit detector register
        struct DFSDM_AWSCD7R : public Register<0x4001705c> {
            using SCDT = Field<0, 8>;    // short-circuit detector threshold for channel 7
            using BKSCD = Field<12, 4>;    // Break signal assignment for short-circuit detector on channel 7
            using AWFOSR = Field<16, 5>;    // Analog watchdog filter oversampling ratio (decimation rate) on channel 7
            using AWFORD = Field<22, 2>;    // Analog watchdog Sinc filter order on channel 7
        };

        // DFSDM channel watchdog filter data register
        struct DFSDM_CHWDAT0R : public RegisterReadOnly<0x40017060> {
            using WDATA = Field<0, 16>;    // Input channel y watchdog data
        };

        // DFSDM channel watchdog filter data register
        struct DFSDM_CHWDAT1R : public RegisterReadOnly<0x40017064> {
            using WDATA = Field<0, 16>;    // Input channel y watchdog data
        };

        // DFSDM channel watchdog filter data register
        struct DFSDM_CHWDAT2R : public RegisterReadOnly<0x40017068> {
            using WDATA = Field<0, 16>;    // Input channel y watchdog data
        };

        // DFSDM channel watchdog filter data register
        struct DFSDM_CHWDAT3R : public RegisterReadOnly<0x4001706c> {
            using WDATA = Field<0, 16>;    // Input channel y watchdog data
        };

        // DFSDM channel watchdog filter data register
        struct DFSDM_CHWDAT4R : public RegisterReadOnly<0x40017070> {
            using WDATA = Field<0, 16>;    // Input channel y watchdog data
        };

        // DFSDM channel watchdog filter data register
        struct DFSDM_CHWDAT5R : public RegisterReadOnly<0x40017074> {
            using WDATA = Field<0, 16>;    // Input channel y watchdog data
        };

        // DFSDM channel watchdog filter data register
        struct DFSDM_CHWDAT6R : public RegisterReadOnly<0x40017078> {
            using WDATA = Field<0, 16>;    // Input channel y watchdog data
        };

        // DFSDM channel watchdog filter data register
        struct DFSDM_CHWDAT7R : public RegisterReadOnly<0x4001707c> {
            using WDATA = Field<0, 16>;    // Input channel y watchdog data
        };

        // DFSDM channel data input register
        struct DFSDM_CHDATIN0R : public Register<0x40017080> {
            using INDAT0 = Field<0, 16>;    // Input data for channel 0
            using INDAT1 = Field<16, 16>;    // Input data for channel 1
        };

        // DFSDM channel data input register
        struct DFSDM_CHDATIN1R : public Register<0x40017084> {
            using INDAT0 = Field<0, 16>;    // Input data for channel 1
            using INDAT1 = Field<16, 16>;    // Input data for channel 2
        };

        // DFSDM channel data input register
        struct DFSDM_CHDATIN2R : public Register<0x40017088> {
            using INDAT0 = Field<0, 16>;    // Input data for channel 2
            using INDAT1 = Field<16, 16>;    // Input data for channel 3
        };

        // DFSDM channel data input register
        struct DFSDM_CHDATIN3R : public Register<0x4001708c> {
            using INDAT0 = Field<0, 16>;    // Input data for channel 3
            using INDAT1 = Field<16, 16>;    // Input data for channel 4
        };

        // DFSDM channel data input register
        struct DFSDM_CHDATIN4R : public Register<0x40017090> {
            using INDAT0 = Field<0, 16>;    // Input data for channel 4
            using INDAT1 = Field<16, 16>;    // Input data for channel 5
        };

        // DFSDM channel data input register
        struct DFSDM_CHDATIN5R : public Register<0x40017094> {
            using INDAT0 = Field<0, 16>;    // Input data for channel 5
            using INDAT1 = Field<16, 16>;    // Input data for channel 6
        };

        // DFSDM channel data input register
        struct DFSDM_CHDATIN6R : public Register<0x40017098> {
            using INDAT0 = Field<0, 16>;    // Input data for channel 6
            using INDAT1 = Field<16, 16>;    // Input data for channel 7
        };

        // DFSDM channel data input register
        struct DFSDM_CHDATIN7R : public Register<0x4001709c> {
            using INDAT0 = Field<0, 16>;    // Input data for channel 7
            using INDAT1 = Field<16, 16>;    // Input data for channel 8
        };

        // DFSDM control register 1
        struct DFSDM0_CR1 : public Register<0x400170a0> {
            using DFEN = Field<0, 1>;    // DFSDM enable
            using JSWSTART = Field<1, 1>;    // Start a conversion of the injected group of channels
            using JSYNC = Field<3, 1>;    // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
            using JSCAN = Field<4, 1>;    // Scanning conversion mode for injected conversions
            using JDMAEN = Field<5, 1>;    // DMA channel enabled to read data for the injected channel group
            using JEXTSEL = Field<8, 5>;    // Trigger signal selection for launching injected conversions
            using JEXTEN = Field<13, 2>;    // Trigger enable and trigger edge selection for injected conversions
            using RSWSTART = Field<17, 1>;    // Software start of a conversion on the regular channel
            using RCONT = Field<18, 1>;    // Continuous mode selection for regular conversions
            using RSYNC = Field<19, 1>;    // Launch regular conversion synchronously with DFSDM0
            using RDMAEN = Field<21, 1>;    // DMA channel enabled to read data for the regular conversion
            using RCH = Field<24, 3>;    // Regular channel selection
            using FAST = Field<29, 1>;    // Fast conversion mode selection for regular conversions
            using AWFSEL = Field<30, 1>;    // Analog watchdog fast mode select
        };

        // DFSDM control register 1
        struct DFSDM1_CR1 : public Register<0x400170a4> {
            using DFEN = Field<0, 1>;    // DFSDM enable
            using JSWSTART = Field<1, 1>;    // Start a conversion of the injected group of channels
            using JSYNC = Field<3, 1>;    // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
            using JSCAN = Field<4, 1>;    // Scanning conversion mode for injected conversions
            using JDMAEN = Field<5, 1>;    // DMA channel enabled to read data for the injected channel group
            using JEXTSEL = Field<8, 5>;    // Trigger signal selection for launching injected conversions
            using JEXTEN = Field<13, 2>;    // Trigger enable and trigger edge selection for injected conversions
            using RSWSTART = Field<17, 1>;    // Software start of a conversion on the regular channel
            using RCONT = Field<18, 1>;    // Continuous mode selection for regular conversions
            using RSYNC = Field<19, 1>;    // Launch regular conversion synchronously with DFSDM0
            using RDMAEN = Field<21, 1>;    // DMA channel enabled to read data for the regular conversion
            using RCH = Field<24, 3>;    // Regular channel selection
            using FAST = Field<29, 1>;    // Fast conversion mode selection for regular conversions
            using AWFSEL = Field<30, 1>;    // Analog watchdog fast mode select
        };

        // DFSDM control register 1
        struct DFSDM2_CR1 : public Register<0x400170a8> {
            using DFEN = Field<0, 1>;    // DFSDM enable
            using JSWSTART = Field<1, 1>;    // Start a conversion of the injected group of channels
            using JSYNC = Field<3, 1>;    // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
            using JSCAN = Field<4, 1>;    // Scanning conversion mode for injected conversions
            using JDMAEN = Field<5, 1>;    // DMA channel enabled to read data for the injected channel group
            using JEXTSEL = Field<8, 5>;    // Trigger signal selection for launching injected conversions
            using JEXTEN = Field<13, 2>;    // Trigger enable and trigger edge selection for injected conversions
            using RSWSTART = Field<17, 1>;    // Software start of a conversion on the regular channel
            using RCONT = Field<18, 1>;    // Continuous mode selection for regular conversions
            using RSYNC = Field<19, 1>;    // Launch regular conversion synchronously with DFSDM0
            using RDMAEN = Field<21, 1>;    // DMA channel enabled to read data for the regular conversion
            using RCH = Field<24, 3>;    // Regular channel selection
            using FAST = Field<29, 1>;    // Fast conversion mode selection for regular conversions
            using AWFSEL = Field<30, 1>;    // Analog watchdog fast mode select
        };

        // DFSDM control register 1
        struct DFSDM3_CR1 : public Register<0x400170ac> {
            using DFEN = Field<0, 1>;    // DFSDM enable
            using JSWSTART = Field<1, 1>;    // Start a conversion of the injected group of channels
            using JSYNC = Field<3, 1>;    // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
            using JSCAN = Field<4, 1>;    // Scanning conversion mode for injected conversions
            using JDMAEN = Field<5, 1>;    // DMA channel enabled to read data for the injected channel group
            using JEXTSEL = Field<8, 5>;    // Trigger signal selection for launching injected conversions
            using JEXTEN = Field<13, 2>;    // Trigger enable and trigger edge selection for injected conversions
            using RSWSTART = Field<17, 1>;    // Software start of a conversion on the regular channel
            using RCONT = Field<18, 1>;    // Continuous mode selection for regular conversions
            using RSYNC = Field<19, 1>;    // Launch regular conversion synchronously with DFSDM0
            using RDMAEN = Field<21, 1>;    // DMA channel enabled to read data for the regular conversion
            using RCH = Field<24, 3>;    // Regular channel selection
            using FAST = Field<29, 1>;    // Fast conversion mode selection for regular conversions
            using AWFSEL = Field<30, 1>;    // Analog watchdog fast mode select
        };

        // DFSDM control register 2
        struct DFSDM0_CR2 : public Register<0x400170b0> {
            using JEOCIE = Field<0, 1>;    // Injected end of conversion interrupt enable
            using REOCIE = Field<1, 1>;    // Regular end of conversion interrupt enable
            using JOVRIE = Field<2, 1>;    // Injected data overrun interrupt enable
            using ROVRIE = Field<3, 1>;    // Regular data overrun interrupt enable
            using AWDIE = Field<4, 1>;    // Analog watchdog interrupt enable
            using SCDIE = Field<5, 1>;    // Short-circuit detector interrupt enable
            using CKABIE = Field<6, 1>;    // Clock absence interrupt enable
            using EXCH = Field<8, 8>;    // Extremes detector channel selection
            using AWDCH = Field<16, 8>;    // Analog watchdog channel selection
        };

        // DFSDM control register 2
        struct DFSDM1_CR2 : public Register<0x400170b4> {
            using JEOCIE = Field<0, 1>;    // Injected end of conversion interrupt enable
            using REOCIE = Field<1, 1>;    // Regular end of conversion interrupt enable
            using JOVRIE = Field<2, 1>;    // Injected data overrun interrupt enable
            using ROVRIE = Field<3, 1>;    // Regular data overrun interrupt enable
            using AWDIE = Field<4, 1>;    // Analog watchdog interrupt enable
            using SCDIE = Field<5, 1>;    // Short-circuit detector interrupt enable
            using CKABIE = Field<6, 1>;    // Clock absence interrupt enable
            using EXCH = Field<8, 8>;    // Extremes detector channel selection
            using AWDCH = Field<16, 8>;    // Analog watchdog channel selection
        };

        // DFSDM control register 2
        struct DFSDM2_CR2 : public Register<0x400170b8> {
            using JEOCIE = Field<0, 1>;    // Injected end of conversion interrupt enable
            using REOCIE = Field<1, 1>;    // Regular end of conversion interrupt enable
            using JOVRIE = Field<2, 1>;    // Injected data overrun interrupt enable
            using ROVRIE = Field<3, 1>;    // Regular data overrun interrupt enable
            using AWDIE = Field<4, 1>;    // Analog watchdog interrupt enable
            using SCDIE = Field<5, 1>;    // Short-circuit detector interrupt enable
            using CKABIE = Field<6, 1>;    // Clock absence interrupt enable
            using EXCH = Field<8, 8>;    // Extremes detector channel selection
            using AWDCH = Field<16, 8>;    // Analog watchdog channel selection
        };

        // DFSDM control register 2
        struct DFSDM3_CR2 : public Register<0x400170bc> {
            using JEOCIE = Field<0, 1>;    // Injected end of conversion interrupt enable
            using REOCIE = Field<1, 1>;    // Regular end of conversion interrupt enable
            using JOVRIE = Field<2, 1>;    // Injected data overrun interrupt enable
            using ROVRIE = Field<3, 1>;    // Regular data overrun interrupt enable
            using AWDIE = Field<4, 1>;    // Analog watchdog interrupt enable
            using SCDIE = Field<5, 1>;    // Short-circuit detector interrupt enable
            using CKABIE = Field<6, 1>;    // Clock absence interrupt enable
            using EXCH = Field<8, 8>;    // Extremes detector channel selection
            using AWDCH = Field<16, 8>;    // Analog watchdog channel selection
        };

        // DFSDM interrupt and status register
        struct DFSDM0_ISR : public RegisterReadOnly<0x400170c0> {
            using JEOCF = Field<0, 1>;    // End of injected conversion flag
            using REOCF = Field<1, 1>;    // End of regular conversion flag
            using JOVRF = Field<2, 1>;    // Injected conversion overrun flag
            using ROVRF = Field<3, 1>;    // Regular conversion overrun flag
            using AWDF = Field<4, 1>;    // Analog watchdog
            using JCIP = Field<13, 1>;    // Injected conversion in progress status
            using RCIP = Field<14, 1>;    // Regular conversion in progress status
            using CKABF = Field<16, 8>;    // Clock absence flag
            using SCDF = Field<24, 8>;    // short-circuit detector flag
        };

        // DFSDM interrupt and status register
        struct DFSDM1_ISR : public RegisterReadOnly<0x400170c4> {
            using JEOCF = Field<0, 1>;    // End of injected conversion flag
            using REOCF = Field<1, 1>;    // End of regular conversion flag
            using JOVRF = Field<2, 1>;    // Injected conversion overrun flag
            using ROVRF = Field<3, 1>;    // Regular conversion overrun flag
            using AWDF = Field<4, 1>;    // Analog watchdog
            using JCIP = Field<13, 1>;    // Injected conversion in progress status
            using RCIP = Field<14, 1>;    // Regular conversion in progress status
            using CKABF = Field<16, 8>;    // Clock absence flag
            using SCDF = Field<24, 8>;    // short-circuit detector flag
        };

        // DFSDM interrupt and status register
        struct DFSDM2_ISR : public RegisterReadOnly<0x400170c8> {
            using JEOCF = Field<0, 1>;    // End of injected conversion flag
            using REOCF = Field<1, 1>;    // End of regular conversion flag
            using JOVRF = Field<2, 1>;    // Injected conversion overrun flag
            using ROVRF = Field<3, 1>;    // Regular conversion overrun flag
            using AWDF = Field<4, 1>;    // Analog watchdog
            using JCIP = Field<13, 1>;    // Injected conversion in progress status
            using RCIP = Field<14, 1>;    // Regular conversion in progress status
            using CKABF = Field<16, 8>;    // Clock absence flag
            using SCDF = Field<24, 8>;    // short-circuit detector flag
        };

        // DFSDM interrupt and status register
        struct DFSDM3_ISR : public RegisterReadOnly<0x400170cc> {
            using JEOCF = Field<0, 1>;    // End of injected conversion flag
            using REOCF = Field<1, 1>;    // End of regular conversion flag
            using JOVRF = Field<2, 1>;    // Injected conversion overrun flag
            using ROVRF = Field<3, 1>;    // Regular conversion overrun flag
            using AWDF = Field<4, 1>;    // Analog watchdog
            using JCIP = Field<13, 1>;    // Injected conversion in progress status
            using RCIP = Field<14, 1>;    // Regular conversion in progress status
            using CKABF = Field<16, 8>;    // Clock absence flag
            using SCDF = Field<24, 8>;    // short-circuit detector flag
        };

        // DFSDM interrupt flag clear register
        struct DFSDM0_ICR : public Register<0x400170d0> {
            using CLRJOVRF = Field<2, 1>;    // Clear the injected conversion overrun flag
            using CLRROVRF = Field<3, 1>;    // Clear the regular conversion overrun flag
            using CLRCKABF = Field<16, 8>;    // Clear the clock absence flag
            using CLRSCDF = Field<24, 8>;    // Clear the short-circuit detector flag
        };

        // DFSDM interrupt flag clear register
        struct DFSDM1_ICR : public Register<0x400170d4> {
            using CLRJOVRF = Field<2, 1>;    // Clear the injected conversion overrun flag
            using CLRROVRF = Field<3, 1>;    // Clear the regular conversion overrun flag
            using CLRCKABF = Field<16, 8>;    // Clear the clock absence flag
            using CLRSCDF = Field<24, 8>;    // Clear the short-circuit detector flag
        };

        // DFSDM interrupt flag clear register
        struct DFSDM2_ICR : public Register<0x400170d8> {
            using CLRJOVRF = Field<2, 1>;    // Clear the injected conversion overrun flag
            using CLRROVRF = Field<3, 1>;    // Clear the regular conversion overrun flag
            using CLRCKABF = Field<16, 8>;    // Clear the clock absence flag
            using CLRSCDF = Field<24, 8>;    // Clear the short-circuit detector flag
        };

        // DFSDM interrupt flag clear register
        struct DFSDM3_ICR : public Register<0x400170dc> {
            using CLRJOVRF = Field<2, 1>;    // Clear the injected conversion overrun flag
            using CLRROVRF = Field<3, 1>;    // Clear the regular conversion overrun flag
            using CLRCKABF = Field<16, 8>;    // Clear the clock absence flag
            using CLRSCDF = Field<24, 8>;    // Clear the short-circuit detector flag
        };

        // DFSDM injected channel group selection register
        struct DFSDM0_JCHGR : public Register<0x400170e0> {
            using JCHG = Field<0, 8>;    // Injected channel group selection
        };

        // DFSDM injected channel group selection register
        struct DFSDM1_JCHGR : public Register<0x400170e4> {
            using JCHG = Field<0, 8>;    // Injected channel group selection
        };

        // DFSDM injected channel group selection register
        struct DFSDM2_JCHGR : public Register<0x400170e8> {
            using JCHG = Field<0, 8>;    // Injected channel group selection
        };

        // DFSDM injected channel group selection register
        struct DFSDM3_JCHGR : public Register<0x400170ec> {
            using JCHG = Field<0, 8>;    // Injected channel group selection
        };

        // DFSDM filter control register
        struct DFSDM0_FCR : public Register<0x400170f0> {
            using IOSR = Field<0, 8>;    // Integrator oversampling ratio (averaging length)
            using FOSR = Field<16, 10>;    // Sinc filter oversampling ratio (decimation rate)
            using FORD = Field<29, 3>;    // Sinc filter order
        };

        // DFSDM filter control register
        struct DFSDM1_FCR : public Register<0x400170f4> {
            using IOSR = Field<0, 8>;    // Integrator oversampling ratio (averaging length)
            using FOSR = Field<16, 10>;    // Sinc filter oversampling ratio (decimation rate)
            using FORD = Field<29, 3>;    // Sinc filter order
        };

        // DFSDM filter control register
        struct DFSDM2_FCR : public Register<0x400170f8> {
            using IOSR = Field<0, 8>;    // Integrator oversampling ratio (averaging length)
            using FOSR = Field<16, 10>;    // Sinc filter oversampling ratio (decimation rate)
            using FORD = Field<29, 3>;    // Sinc filter order
        };

        // DFSDM filter control register
        struct DFSDM3_FCR : public Register<0x400170fc> {
            using IOSR = Field<0, 8>;    // Integrator oversampling ratio (averaging length)
            using FOSR = Field<16, 10>;    // Sinc filter oversampling ratio (decimation rate)
            using FORD = Field<29, 3>;    // Sinc filter order
        };

        // DFSDM data register for injected group
        struct DFSDM0_JDATAR : public RegisterReadOnly<0x40017100> {
            using JDATACH = Field<0, 3>;    // Injected channel most recently converted
            using JDATA = Field<8, 24>;    // Injected group conversion data
        };

        // DFSDM data register for injected group
        struct DFSDM1_JDATAR : public RegisterReadOnly<0x40017104> {
            using JDATACH = Field<0, 3>;    // Injected channel most recently converted
            using JDATA = Field<8, 24>;    // Injected group conversion data
        };

        // DFSDM data register for injected group
        struct DFSDM2_JDATAR : public RegisterReadOnly<0x40017108> {
            using JDATACH = Field<0, 3>;    // Injected channel most recently converted
            using JDATA = Field<8, 24>;    // Injected group conversion data
        };

        // DFSDM data register for injected group
        struct DFSDM3_JDATAR : public RegisterReadOnly<0x4001710c> {
            using JDATACH = Field<0, 3>;    // Injected channel most recently converted
            using JDATA = Field<8, 24>;    // Injected group conversion data
        };

        // DFSDM data register for the regular channel
        struct DFSDM0_RDATAR : public RegisterReadOnly<0x40017110> {
            using RDATACH = Field<0, 3>;    // Regular channel most recently converted
            using RPEND = Field<4, 1>;    // Regular channel pending data
            using RDATA = Field<8, 24>;    // Regular channel conversion data
        };

        // DFSDM data register for the regular channel
        struct DFSDM1_RDATAR : public RegisterReadOnly<0x40017114> {
            using RDATACH = Field<0, 3>;    // Regular channel most recently converted
            using RPEND = Field<4, 1>;    // Regular channel pending data
            using RDATA = Field<8, 24>;    // Regular channel conversion data
        };

        // DFSDM data register for the regular channel
        struct DFSDM2_RDATAR : public RegisterReadOnly<0x40017118> {
            using RDATACH = Field<0, 3>;    // Regular channel most recently converted
            using RPEND = Field<4, 1>;    // Regular channel pending data
            using RDATA = Field<8, 24>;    // Regular channel conversion data
        };

        // DFSDM data register for the regular channel
        struct DFSDM3_RDATAR : public RegisterReadOnly<0x4001711c> {
            using RDATACH = Field<0, 3>;    // Regular channel most recently converted
            using RPEND = Field<4, 1>;    // Regular channel pending data
            using RDATA = Field<8, 24>;    // Regular channel conversion data
        };

        // DFSDM analog watchdog high threshold register
        struct DFSDM0_AWHTR : public Register<0x40017120> {
            using BKAWH = Field<0, 4>;    // Break signal assignment to analog watchdog high threshold event
            using AWHT = Field<8, 24>;    // Analog watchdog high threshold
        };

        // DFSDM analog watchdog high threshold register
        struct DFSDM1_AWHTR : public Register<0x40017124> {
            using BKAWH = Field<0, 4>;    // Break signal assignment to analog watchdog high threshold event
            using AWHT = Field<8, 24>;    // Analog watchdog high threshold
        };

        // DFSDM analog watchdog high threshold register
        struct DFSDM2_AWHTR : public Register<0x40017128> {
            using BKAWH = Field<0, 4>;    // Break signal assignment to analog watchdog high threshold event
            using AWHT = Field<8, 24>;    // Analog watchdog high threshold
        };

        // DFSDM analog watchdog high threshold register
        struct DFSDM3_AWHTR : public Register<0x4001712c> {
            using BKAWH = Field<0, 4>;    // Break signal assignment to analog watchdog high threshold event
            using AWHT = Field<8, 24>;    // Analog watchdog high threshold
        };

        // DFSDM analog watchdog low threshold register
        struct DFSDM0_AWLTR : public Register<0x40017130> {
            using BKAWL = Field<0, 4>;    // Break signal assignment to analog watchdog low threshold event
            using AWLT = Field<8, 24>;    // Analog watchdog low threshold
        };

        // DFSDM analog watchdog low threshold register
        struct DFSDM1_AWLTR : public Register<0x40017134> {
            using BKAWL = Field<0, 4>;    // Break signal assignment to analog watchdog low threshold event
            using AWLT = Field<8, 24>;    // Analog watchdog low threshold
        };

        // DFSDM analog watchdog low threshold register
        struct DFSDM2_AWLTR : public Register<0x40017138> {
            using BKAWL = Field<0, 4>;    // Break signal assignment to analog watchdog low threshold event
            using AWLT = Field<8, 24>;    // Analog watchdog low threshold
        };

        // DFSDM analog watchdog low threshold register
        struct DFSDM3_AWLTR : public Register<0x4001713c> {
            using BKAWL = Field<0, 4>;    // Break signal assignment to analog watchdog low threshold event
            using AWLT = Field<8, 24>;    // Analog watchdog low threshold
        };

        // DFSDM analog watchdog status register
        struct DFSDM0_AWSR : public RegisterReadOnly<0x40017140> {
            using AWLTF = Field<0, 8>;    // Analog watchdog low threshold flag
            using AWHTF = Field<8, 8>;    // Analog watchdog high threshold flag
        };

        // DFSDM analog watchdog status register
        struct DFSDM1_AWSR : public RegisterReadOnly<0x40017144> {
            using AWLTF = Field<0, 8>;    // Analog watchdog low threshold flag
            using AWHTF = Field<8, 8>;    // Analog watchdog high threshold flag
        };

        // DFSDM analog watchdog status register
        struct DFSDM2_AWSR : public RegisterReadOnly<0x40017148> {
            using AWLTF = Field<0, 8>;    // Analog watchdog low threshold flag
            using AWHTF = Field<8, 8>;    // Analog watchdog high threshold flag
        };

        // DFSDM analog watchdog status register
        struct DFSDM3_AWSR : public RegisterReadOnly<0x4001714c> {
            using AWLTF = Field<0, 8>;    // Analog watchdog low threshold flag
            using AWHTF = Field<8, 8>;    // Analog watchdog high threshold flag
        };

        // DFSDM analog watchdog clear flag register
        struct DFSDM0_AWCFR : public Register<0x40017150> {
            using CLRAWLTF = Field<0, 8>;    // Clear the analog watchdog low threshold flag
            using CLRAWHTF = Field<8, 8>;    // Clear the analog watchdog high threshold flag
        };

        // DFSDM analog watchdog clear flag register
        struct DFSDM1_AWCFR : public Register<0x40017154> {
            using CLRAWLTF = Field<0, 8>;    // Clear the analog watchdog low threshold flag
            using CLRAWHTF = Field<8, 8>;    // Clear the analog watchdog high threshold flag
        };

        // DFSDM analog watchdog clear flag register
        struct DFSDM2_AWCFR : public Register<0x40017158> {
            using CLRAWLTF = Field<0, 8>;    // Clear the analog watchdog low threshold flag
            using CLRAWHTF = Field<8, 8>;    // Clear the analog watchdog high threshold flag
        };

        // DFSDM analog watchdog clear flag register
        struct DFSDM3_AWCFR : public Register<0x4001715c> {
            using CLRAWLTF = Field<0, 8>;    // Clear the analog watchdog low threshold flag
            using CLRAWHTF = Field<8, 8>;    // Clear the analog watchdog high threshold flag
        };

        // DFSDM Extremes detector maximum register
        struct DFSDM0_EXMAX : public RegisterReadOnly<0x40017160> {
            using EXMAXCH = Field<0, 3>;    // Extremes detector maximum data channel
            using EXMAX = Field<8, 24>;    // Extremes detector maximum value
        };

        // DFSDM Extremes detector maximum register
        struct DFSDM1_EXMAX : public RegisterReadOnly<0x40017164> {
            using EXMAXCH = Field<0, 3>;    // Extremes detector maximum data channel
            using EXMAX = Field<8, 24>;    // Extremes detector maximum value
        };

        // DFSDM Extremes detector maximum register
        struct DFSDM2_EXMAX : public RegisterReadOnly<0x40017168> {
            using EXMAXCH = Field<0, 3>;    // Extremes detector maximum data channel
            using EXMAX = Field<8, 24>;    // Extremes detector maximum value
        };

        // DFSDM Extremes detector maximum register
        struct DFSDM3_EXMAX : public RegisterReadOnly<0x4001716c> {
            using EXMAXCH = Field<0, 3>;    // Extremes detector maximum data channel
            using EXMAX = Field<8, 24>;    // Extremes detector maximum value
        };

        // DFSDM Extremes detector minimum register
        struct DFSDM0_EXMIN : public RegisterReadOnly<0x40017170> {
            using EXMINCH = Field<0, 3>;    // Extremes detector minimum data channel
            using EXMIN = Field<8, 24>;    // Extremes detector minimum value
        };

        // DFSDM Extremes detector minimum register
        struct DFSDM1_EXMIN : public RegisterReadOnly<0x40017174> {
            using EXMINCH = Field<0, 3>;    // Extremes detector minimum data channel
            using EXMIN = Field<8, 24>;    // Extremes detector minimum value
        };

        // DFSDM Extremes detector minimum register
        struct DFSDM2_EXMIN : public RegisterReadOnly<0x40017178> {
            using EXMINCH = Field<0, 3>;    // Extremes detector minimum data channel
            using EXMIN = Field<8, 24>;    // Extremes detector minimum value
        };

        // DFSDM Extremes detector minimum register
        struct DFSDM3_EXMIN : public RegisterReadOnly<0x4001717c> {
            using EXMINCH = Field<0, 3>;    // Extremes detector minimum data channel
            using EXMIN = Field<8, 24>;    // Extremes detector minimum value
        };

        // DFSDM conversion timer register
        struct DFSDM0_CNVTIMR : public RegisterReadOnly<0x40017180> {
            using CNVCNT = Field<4, 28>;    // 28-bit timer counting conversion time
        };

        // DFSDM conversion timer register
        struct DFSDM1_CNVTIMR : public RegisterReadOnly<0x40017184> {
            using CNVCNT = Field<4, 28>;    // 28-bit timer counting conversion time
        };

        // DFSDM conversion timer register
        struct DFSDM2_CNVTIMR : public RegisterReadOnly<0x40017188> {
            using CNVCNT = Field<4, 28>;    // 28-bit timer counting conversion time
        };

        // DFSDM conversion timer register
        struct DFSDM3_CNVTIMR : public RegisterReadOnly<0x4001718c> {
            using CNVCNT = Field<4, 28>;    // 28-bit timer counting conversion time
        };

    };

    // General-purpose-timers
    struct TIM16 {
        // control register 1
        struct CR1 : public Register<0x40014400> {
            using CEN = Field<0, 1>;    // Counter enable
            using UDIS = Field<1, 1>;    // Update disable
            using URS = Field<2, 1>;    // Update request source
            using OPM = Field<3, 1>;    // One-pulse mode
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CKD = Field<8, 2>;    // Clock division
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
        };

        // control register 2
        struct CR2 : public Register<0x40014404> {
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001440c> {
            using UIE = Field<0, 1>;    // Update interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
        };

        // status register
        struct SR : public Register<0x40014410> {
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40014414> {
            using BG = Field<7, 1>;    // Break generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register (output mode)
        struct CCMR1_Output : public Register<0x40014418> {
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40014418> {
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40014420> {
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40014424> {
            using Field = Field<0, 16>;    // counter value
            using UIFCPY = Field<31, 1>;    // UIF Copy
        };

        // prescaler
        struct PSC : public Register<0x40014428> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001442c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // repetition counter register
        struct RCR : public Register<0x40014430> {
            using REP = Field<0, 8>;    // Repetition counter value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40014434> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40014444> {
            using DTG = Field<0, 8>;    // Dead-time generator setup
            using LOCK = Field<8, 2>;    // Lock configuration
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using BKE = Field<12, 1>;    // Break enable
            using BKP = Field<13, 1>;    // Break polarity
            using AOE = Field<14, 1>;    // Automatic output enable
            using MOE = Field<15, 1>;    // Main output enable
            using BKF = Field<16, 4>;    // Break filter
        };

        // DMA control register
        struct DCR : public Register<0x40014448> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4001444c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // TIM16 alternate function register 1
        struct TIM16_AF1 : public Register<0x40014460> {
            using BKINE = Field<0, 1>;    // BRK BKIN input enable
            using BKCMP1E = Field<1, 1>;    // BRK COMP1 enable
            using BKCMP2E = Field<2, 1>;    // BRK COMP2 enable
            using BKDFBK1E = Field<8, 1>;    // BRK dfsdm1_break[1] enable
            using BKINP = Field<9, 1>;    // BRK BKIN input polarity
            using BKCMP1P = Field<10, 1>;    // BRK COMP1 input polarity
            using BKCMP2P = Field<11, 1>;    // BRK COMP2 input polarity
        };

        // TIM16 input selection register
        struct TIM16_TISEL : public Register<0x40014468> {
            using TI1SEL = Field<0, 4>;    // selects TI1[0] to TI1[15] input
        };

    };

    // General-purpose-timers
    struct TIM17 {
        // control register 1
        struct CR1 : public Register<0x40014800> {
            using CEN = Field<0, 1>;    // Counter enable
            using UDIS = Field<1, 1>;    // Update disable
            using URS = Field<2, 1>;    // Update request source
            using OPM = Field<3, 1>;    // One-pulse mode
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CKD = Field<8, 2>;    // Clock division
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
        };

        // control register 2
        struct CR2 : public Register<0x40014804> {
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001480c> {
            using UIE = Field<0, 1>;    // Update interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
        };

        // status register
        struct SR : public Register<0x40014810> {
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40014814> {
            using BG = Field<7, 1>;    // Break generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register (output mode)
        struct CCMR1_Output : public Register<0x40014818> {
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40014818> {
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40014820> {
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40014824> {
            using Field = Field<0, 16>;    // counter value
            using UIFCPY = Field<31, 1>;    // UIF Copy
        };

        // prescaler
        struct PSC : public Register<0x40014828> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001482c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // repetition counter register
        struct RCR : public Register<0x40014830> {
            using REP = Field<0, 8>;    // Repetition counter value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40014834> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40014844> {
            using DTG = Field<0, 8>;    // Dead-time generator setup
            using LOCK = Field<8, 2>;    // Lock configuration
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using BKE = Field<12, 1>;    // Break enable
            using BKP = Field<13, 1>;    // Break polarity
            using AOE = Field<14, 1>;    // Automatic output enable
            using MOE = Field<15, 1>;    // Main output enable
            using BKF = Field<16, 4>;    // Break filter
        };

        // DMA control register
        struct DCR : public Register<0x40014848> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4001484c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // TIM17 alternate function register 1
        struct TIM17_AF1 : public Register<0x40014860> {
            using BKINE = Field<0, 1>;    // BRK BKIN input enable
            using BKCMP1E = Field<1, 1>;    // BRK COMP1 enable
            using BKCMP2E = Field<2, 1>;    // BRK COMP2 enable
            using BKDFBK1E = Field<8, 1>;    // BRK dfsdm1_break[1] enable
            using BKINP = Field<9, 1>;    // BRK BKIN input polarity
            using BKCMP1P = Field<10, 1>;    // BRK COMP1 input polarity
            using BKCMP2P = Field<11, 1>;    // BRK COMP2 input polarity
        };

        // TIM17 input selection register
        struct TIM17_TISEL : public Register<0x40014868> {
            using TI1SEL = Field<0, 4>;    // selects TI1[0] to TI1[15] input
        };

    };

    // General purpose timers
    struct TIM15 {
        // control register 1
        struct CR1 : public Register<0x40014000> {
            using CEN = Field<0, 1>;    // Counter enable
            using UDIS = Field<1, 1>;    // Update disable
            using URS = Field<2, 1>;    // Update request source
            using OPM = Field<3, 1>;    // One-pulse mode
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CKD = Field<8, 2>;    // Clock division
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
        };

        // control register 2
        struct CR2 : public Register<0x40014004> {
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using MMS = Field<4, 3>;    // Master mode selection
            using TI1S = Field<7, 1>;    // TI1 selection
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS2 = Field<10, 1>;    // Output Idle state 2
        };

        // slave mode control register
        struct SMCR : public Register<0x40014008> {
            using SMS = Field<0, 3>;    // Slave mode selection
            using TS_2_0 = Field<4, 3>;    // Trigger selection
            using MSM = Field<7, 1>;    // Master/Slave mode
            using SMS_3 = Field<16, 1>;    // Slave mode selection bit 3
            using TS_4_3 = Field<20, 2>;    // Trigger selection - bit 4:3
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001400c> {
            using UIE = Field<0, 1>;    // Update interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using TDE = Field<14, 1>;    // Trigger DMA request enable
        };

        // status register
        struct SR : public Register<0x40014010> {
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40014014> {
            using BG = Field<7, 1>;    // Break generation
            using TG = Field<6, 1>;    // Trigger generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register (output mode)
        struct CCMR1_Output : public Register<0x40014018> {
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC2FE = Field<10, 1>;    // Output Compare 2 fast enable
            using OC2PE = Field<11, 1>;    // Output Compare 2 preload enable
            using OC2M = Field<12, 3>;    // Output Compare 2 mode
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode bit 3
            using OC2M_3 = Field<24, 1>;    // Output Compare 2 mode bit 3
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40014018> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40014020> {
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40014024> {
            using Field = Field<0, 16>;    // counter value
            using UIFCPY = Field<31, 1>;    // UIF copy
        };

        // prescaler
        struct PSC : public Register<0x40014028> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001402c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // repetition counter register
        struct RCR : public Register<0x40014030> {
            using REP = Field<0, 8>;    // Repetition counter value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40014034> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40014038> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40014044> {
            using MOE = Field<15, 1>;    // Main output enable
            using AOE = Field<14, 1>;    // Automatic output enable
            using BKP = Field<13, 1>;    // Break polarity
            using BKE = Field<12, 1>;    // Break enable
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using LOCK = Field<8, 2>;    // Lock configuration
            using DTG = Field<0, 8>;    // Dead-time generator setup
            using BKF = Field<16, 4>;    // Break filter
        };

        // DMA control register
        struct DCR : public Register<0x40014048> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4001404c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // TIM15 alternate fdfsdm1_breakon register 1
        struct AF1 : public Register<0x40014060> {
            using BKINE = Field<0, 1>;    // BRK BKIN input enable
            using BKCMP1E = Field<1, 1>;    // BRK COMP1 enable
            using BKCMP2E = Field<2, 1>;    // BRK COMP2 enable
            using BKDF1BK0E = Field<8, 1>;    // BRK dfsdm1_break[0] enable
            using BKINP = Field<9, 1>;    // BRK BKIN input polarity
            using BKCMP1P = Field<10, 1>;    // BRK COMP1 input polarity
            using BKCMP2P = Field<11, 1>;    // BRK COMP2 input polarity
        };

        // TIM15 input selection register
        struct TISEL : public Register<0x40014068> {
            using TI1SEL = Field<0, 4>;    // selects TI1[0] to TI1[15] input
            using TI2SEL = Field<8, 4>;    // selects TI2[0] to TI2[15] input
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART1 {
        // Control register 1
        struct CR1 : public Register<0x40011000> {
            using RXFFIE = Field<31, 1>;    // RXFIFO Full interrupt enable
            using TXFEIE = Field<30, 1>;    // TXFIFO empty interrupt enable
            using FIFOEN = Field<29, 1>;    // FIFO mode enable
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40011004> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
            using DIS_NSS = Field<3, 1>;    // When the DSI_NSS bit is set, the NSS pin input is ignored
            using SLVEN = Field<0, 1>;    // Synchronous Slave mode enable
        };

        // Control register 3
        struct CR3 : public Register<0x40011008> {
            using TXFTCFG = Field<29, 3>;    // TXFIFO threshold configuration
            using RXFTIE = Field<28, 1>;    // RXFIFO threshold interrupt enable
            using RXFTCFG = Field<25, 3>;    // Receive FIFO threshold configuration
            using TCBGTIE = Field<24, 1>;    // Transmission Complete before guard time, interrupt enable
            using TXFTIE = Field<23, 1>;    // TXFIFO threshold interrupt enable
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4001100c> {
            using BRR_4_15 = Field<4, 12>;    // DIV_Mantissa
            using BRR_0_3 = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40011010> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40011014> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x40011018> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x4001101c> {
            using TXFT = Field<27, 1>;    // TXFIFO threshold flag
            using RXFT = Field<26, 1>;    // RXFIFO threshold flag
            using TCBGT = Field<25, 1>;    // Transmission complete before guard time flag
            using RXFF = Field<24, 1>;    // RXFIFO Full
            using TXFE = Field<23, 1>;    // TXFIFO Empty
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using UDR = Field<13, 1>;    // SPI slave underrun error flag
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x40011020> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using UDRCF = Field<13, 1>;    // SPI slave underrun clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCBGTC = Field<7, 1>;    // Transmission complete before Guard time clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using TXFECF = Field<5, 1>;    // TXFIFO empty clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x40011024> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40011028> {
            using Field = Field<0, 9>;    // Transmit data value
        };

        // USART prescaler register
        struct PRESC : public Register<0x4001102c> {
            using PRESCALER = Field<0, 4>;    // Clock prescaler
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART2 {
        // Control register 1
        struct CR1 : public Register<0x40004400> {
            using RXFFIE = Field<31, 1>;    // RXFIFO Full interrupt enable
            using TXFEIE = Field<30, 1>;    // TXFIFO empty interrupt enable
            using FIFOEN = Field<29, 1>;    // FIFO mode enable
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40004404> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
            using DIS_NSS = Field<3, 1>;    // When the DSI_NSS bit is set, the NSS pin input is ignored
            using SLVEN = Field<0, 1>;    // Synchronous Slave mode enable
        };

        // Control register 3
        struct CR3 : public Register<0x40004408> {
            using TXFTCFG = Field<29, 3>;    // TXFIFO threshold configuration
            using RXFTIE = Field<28, 1>;    // RXFIFO threshold interrupt enable
            using RXFTCFG = Field<25, 3>;    // Receive FIFO threshold configuration
            using TCBGTIE = Field<24, 1>;    // Transmission Complete before guard time, interrupt enable
            using TXFTIE = Field<23, 1>;    // TXFIFO threshold interrupt enable
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4000440c> {
            using BRR_4_15 = Field<4, 12>;    // DIV_Mantissa
            using BRR_0_3 = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40004410> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40004414> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x40004418> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x4000441c> {
            using TXFT = Field<27, 1>;    // TXFIFO threshold flag
            using RXFT = Field<26, 1>;    // RXFIFO threshold flag
            using TCBGT = Field<25, 1>;    // Transmission complete before guard time flag
            using RXFF = Field<24, 1>;    // RXFIFO Full
            using TXFE = Field<23, 1>;    // TXFIFO Empty
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using UDR = Field<13, 1>;    // SPI slave underrun error flag
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x40004420> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using UDRCF = Field<13, 1>;    // SPI slave underrun clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCBGTC = Field<7, 1>;    // Transmission complete before Guard time clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using TXFECF = Field<5, 1>;    // TXFIFO empty clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x40004424> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40004428> {
            using Field = Field<0, 9>;    // Transmit data value
        };

        // USART prescaler register
        struct PRESC : public Register<0x4000442c> {
            using PRESCALER = Field<0, 4>;    // Clock prescaler
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART3 {
        // Control register 1
        struct CR1 : public Register<0x40004800> {
            using RXFFIE = Field<31, 1>;    // RXFIFO Full interrupt enable
            using TXFEIE = Field<30, 1>;    // TXFIFO empty interrupt enable
            using FIFOEN = Field<29, 1>;    // FIFO mode enable
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40004804> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
            using DIS_NSS = Field<3, 1>;    // When the DSI_NSS bit is set, the NSS pin input is ignored
            using SLVEN = Field<0, 1>;    // Synchronous Slave mode enable
        };

        // Control register 3
        struct CR3 : public Register<0x40004808> {
            using TXFTCFG = Field<29, 3>;    // TXFIFO threshold configuration
            using RXFTIE = Field<28, 1>;    // RXFIFO threshold interrupt enable
            using RXFTCFG = Field<25, 3>;    // Receive FIFO threshold configuration
            using TCBGTIE = Field<24, 1>;    // Transmission Complete before guard time, interrupt enable
            using TXFTIE = Field<23, 1>;    // TXFIFO threshold interrupt enable
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4000480c> {
            using BRR_4_15 = Field<4, 12>;    // DIV_Mantissa
            using BRR_0_3 = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40004810> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40004814> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x40004818> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x4000481c> {
            using TXFT = Field<27, 1>;    // TXFIFO threshold flag
            using RXFT = Field<26, 1>;    // RXFIFO threshold flag
            using TCBGT = Field<25, 1>;    // Transmission complete before guard time flag
            using RXFF = Field<24, 1>;    // RXFIFO Full
            using TXFE = Field<23, 1>;    // TXFIFO Empty
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using UDR = Field<13, 1>;    // SPI slave underrun error flag
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x40004820> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using UDRCF = Field<13, 1>;    // SPI slave underrun clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCBGTC = Field<7, 1>;    // Transmission complete before Guard time clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using TXFECF = Field<5, 1>;    // TXFIFO empty clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x40004824> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40004828> {
            using Field = Field<0, 9>;    // Transmit data value
        };

        // USART prescaler register
        struct PRESC : public Register<0x4000482c> {
            using PRESCALER = Field<0, 4>;    // Clock prescaler
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct UART4 {
        // Control register 1
        struct CR1 : public Register<0x40004c00> {
            using RXFFIE = Field<31, 1>;    // RXFIFO Full interrupt enable
            using TXFEIE = Field<30, 1>;    // TXFIFO empty interrupt enable
            using FIFOEN = Field<29, 1>;    // FIFO mode enable
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40004c04> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
            using DIS_NSS = Field<3, 1>;    // When the DSI_NSS bit is set, the NSS pin input is ignored
            using SLVEN = Field<0, 1>;    // Synchronous Slave mode enable
        };

        // Control register 3
        struct CR3 : public Register<0x40004c08> {
            using TXFTCFG = Field<29, 3>;    // TXFIFO threshold configuration
            using RXFTIE = Field<28, 1>;    // RXFIFO threshold interrupt enable
            using RXFTCFG = Field<25, 3>;    // Receive FIFO threshold configuration
            using TCBGTIE = Field<24, 1>;    // Transmission Complete before guard time, interrupt enable
            using TXFTIE = Field<23, 1>;    // TXFIFO threshold interrupt enable
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x40004c0c> {
            using BRR_4_15 = Field<4, 12>;    // DIV_Mantissa
            using BRR_0_3 = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40004c10> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40004c14> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x40004c18> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x40004c1c> {
            using TXFT = Field<27, 1>;    // TXFIFO threshold flag
            using RXFT = Field<26, 1>;    // RXFIFO threshold flag
            using TCBGT = Field<25, 1>;    // Transmission complete before guard time flag
            using RXFF = Field<24, 1>;    // RXFIFO Full
            using TXFE = Field<23, 1>;    // TXFIFO Empty
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using UDR = Field<13, 1>;    // SPI slave underrun error flag
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x40004c20> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using UDRCF = Field<13, 1>;    // SPI slave underrun clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCBGTC = Field<7, 1>;    // Transmission complete before Guard time clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using TXFECF = Field<5, 1>;    // TXFIFO empty clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x40004c24> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40004c28> {
            using Field = Field<0, 9>;    // Transmit data value
        };

        // USART prescaler register
        struct PRESC : public Register<0x40004c2c> {
            using PRESCALER = Field<0, 4>;    // Clock prescaler
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct UART5 {
        // Control register 1
        struct CR1 : public Register<0x40005000> {
            using RXFFIE = Field<31, 1>;    // RXFIFO Full interrupt enable
            using TXFEIE = Field<30, 1>;    // TXFIFO empty interrupt enable
            using FIFOEN = Field<29, 1>;    // FIFO mode enable
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40005004> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
            using DIS_NSS = Field<3, 1>;    // When the DSI_NSS bit is set, the NSS pin input is ignored
            using SLVEN = Field<0, 1>;    // Synchronous Slave mode enable
        };

        // Control register 3
        struct CR3 : public Register<0x40005008> {
            using TXFTCFG = Field<29, 3>;    // TXFIFO threshold configuration
            using RXFTIE = Field<28, 1>;    // RXFIFO threshold interrupt enable
            using RXFTCFG = Field<25, 3>;    // Receive FIFO threshold configuration
            using TCBGTIE = Field<24, 1>;    // Transmission Complete before guard time, interrupt enable
            using TXFTIE = Field<23, 1>;    // TXFIFO threshold interrupt enable
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4000500c> {
            using BRR_4_15 = Field<4, 12>;    // DIV_Mantissa
            using BRR_0_3 = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40005010> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40005014> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x40005018> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x4000501c> {
            using TXFT = Field<27, 1>;    // TXFIFO threshold flag
            using RXFT = Field<26, 1>;    // RXFIFO threshold flag
            using TCBGT = Field<25, 1>;    // Transmission complete before guard time flag
            using RXFF = Field<24, 1>;    // RXFIFO Full
            using TXFE = Field<23, 1>;    // TXFIFO Empty
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using UDR = Field<13, 1>;    // SPI slave underrun error flag
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x40005020> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using UDRCF = Field<13, 1>;    // SPI slave underrun clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCBGTC = Field<7, 1>;    // Transmission complete before Guard time clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using TXFECF = Field<5, 1>;    // TXFIFO empty clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x40005024> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40005028> {
            using Field = Field<0, 9>;    // Transmit data value
        };

        // USART prescaler register
        struct PRESC : public Register<0x4000502c> {
            using PRESCALER = Field<0, 4>;    // Clock prescaler
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART6 {
        // Control register 1
        struct CR1 : public Register<0x40011400> {
            using RXFFIE = Field<31, 1>;    // RXFIFO Full interrupt enable
            using TXFEIE = Field<30, 1>;    // TXFIFO empty interrupt enable
            using FIFOEN = Field<29, 1>;    // FIFO mode enable
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40011404> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
            using DIS_NSS = Field<3, 1>;    // When the DSI_NSS bit is set, the NSS pin input is ignored
            using SLVEN = Field<0, 1>;    // Synchronous Slave mode enable
        };

        // Control register 3
        struct CR3 : public Register<0x40011408> {
            using TXFTCFG = Field<29, 3>;    // TXFIFO threshold configuration
            using RXFTIE = Field<28, 1>;    // RXFIFO threshold interrupt enable
            using RXFTCFG = Field<25, 3>;    // Receive FIFO threshold configuration
            using TCBGTIE = Field<24, 1>;    // Transmission Complete before guard time, interrupt enable
            using TXFTIE = Field<23, 1>;    // TXFIFO threshold interrupt enable
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4001140c> {
            using BRR_4_15 = Field<4, 12>;    // DIV_Mantissa
            using BRR_0_3 = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40011410> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40011414> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x40011418> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x4001141c> {
            using TXFT = Field<27, 1>;    // TXFIFO threshold flag
            using RXFT = Field<26, 1>;    // RXFIFO threshold flag
            using TCBGT = Field<25, 1>;    // Transmission complete before guard time flag
            using RXFF = Field<24, 1>;    // RXFIFO Full
            using TXFE = Field<23, 1>;    // TXFIFO Empty
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using UDR = Field<13, 1>;    // SPI slave underrun error flag
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x40011420> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using UDRCF = Field<13, 1>;    // SPI slave underrun clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCBGTC = Field<7, 1>;    // Transmission complete before Guard time clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using TXFECF = Field<5, 1>;    // TXFIFO empty clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x40011424> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40011428> {
            using Field = Field<0, 9>;    // Transmit data value
        };

        // USART prescaler register
        struct PRESC : public Register<0x4001142c> {
            using PRESCALER = Field<0, 4>;    // Clock prescaler
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct UART7 {
        // Control register 1
        struct CR1 : public Register<0x40007800> {
            using RXFFIE = Field<31, 1>;    // RXFIFO Full interrupt enable
            using TXFEIE = Field<30, 1>;    // TXFIFO empty interrupt enable
            using FIFOEN = Field<29, 1>;    // FIFO mode enable
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40007804> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
            using DIS_NSS = Field<3, 1>;    // When the DSI_NSS bit is set, the NSS pin input is ignored
            using SLVEN = Field<0, 1>;    // Synchronous Slave mode enable
        };

        // Control register 3
        struct CR3 : public Register<0x40007808> {
            using TXFTCFG = Field<29, 3>;    // TXFIFO threshold configuration
            using RXFTIE = Field<28, 1>;    // RXFIFO threshold interrupt enable
            using RXFTCFG = Field<25, 3>;    // Receive FIFO threshold configuration
            using TCBGTIE = Field<24, 1>;    // Transmission Complete before guard time, interrupt enable
            using TXFTIE = Field<23, 1>;    // TXFIFO threshold interrupt enable
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4000780c> {
            using BRR_4_15 = Field<4, 12>;    // DIV_Mantissa
            using BRR_0_3 = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40007810> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40007814> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x40007818> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x4000781c> {
            using TXFT = Field<27, 1>;    // TXFIFO threshold flag
            using RXFT = Field<26, 1>;    // RXFIFO threshold flag
            using TCBGT = Field<25, 1>;    // Transmission complete before guard time flag
            using RXFF = Field<24, 1>;    // RXFIFO Full
            using TXFE = Field<23, 1>;    // TXFIFO Empty
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using UDR = Field<13, 1>;    // SPI slave underrun error flag
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x40007820> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using UDRCF = Field<13, 1>;    // SPI slave underrun clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCBGTC = Field<7, 1>;    // Transmission complete before Guard time clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using TXFECF = Field<5, 1>;    // TXFIFO empty clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x40007824> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40007828> {
            using Field = Field<0, 9>;    // Transmit data value
        };

        // USART prescaler register
        struct PRESC : public Register<0x4000782c> {
            using PRESCALER = Field<0, 4>;    // Clock prescaler
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct UART8 {
        // Control register 1
        struct CR1 : public Register<0x40007c00> {
            using RXFFIE = Field<31, 1>;    // RXFIFO Full interrupt enable
            using TXFEIE = Field<30, 1>;    // TXFIFO empty interrupt enable
            using FIFOEN = Field<29, 1>;    // FIFO mode enable
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40007c04> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
            using DIS_NSS = Field<3, 1>;    // When the DSI_NSS bit is set, the NSS pin input is ignored
            using SLVEN = Field<0, 1>;    // Synchronous Slave mode enable
        };

        // Control register 3
        struct CR3 : public Register<0x40007c08> {
            using TXFTCFG = Field<29, 3>;    // TXFIFO threshold configuration
            using RXFTIE = Field<28, 1>;    // RXFIFO threshold interrupt enable
            using RXFTCFG = Field<25, 3>;    // Receive FIFO threshold configuration
            using TCBGTIE = Field<24, 1>;    // Transmission Complete before guard time, interrupt enable
            using TXFTIE = Field<23, 1>;    // TXFIFO threshold interrupt enable
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x40007c0c> {
            using BRR_4_15 = Field<4, 12>;    // DIV_Mantissa
            using BRR_0_3 = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40007c10> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40007c14> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public RegisterWriteOnly<0x40007c18> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public RegisterReadOnly<0x40007c1c> {
            using TXFT = Field<27, 1>;    // TXFIFO threshold flag
            using RXFT = Field<26, 1>;    // RXFIFO threshold flag
            using TCBGT = Field<25, 1>;    // Transmission complete before guard time flag
            using RXFF = Field<24, 1>;    // RXFIFO Full
            using TXFE = Field<23, 1>;    // TXFIFO Empty
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using UDR = Field<13, 1>;    // SPI slave underrun error flag
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public RegisterWriteOnly<0x40007c20> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using UDRCF = Field<13, 1>;    // SPI slave underrun clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCBGTC = Field<7, 1>;    // Transmission complete before Guard time clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using TXFECF = Field<5, 1>;    // TXFIFO empty clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public RegisterReadOnly<0x40007c24> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40007c28> {
            using Field = Field<0, 9>;    // Transmit data value
        };

        // USART prescaler register
        struct PRESC : public Register<0x40007c2c> {
            using PRESCALER = Field<0, 4>;    // Clock prescaler
        };

    };

    // Advanced-timers
    struct TIM1 {
        // control register 1
        struct CR1 : public Register<0x40010000> {
            using CEN = Field<0, 1>;    // Counter enable
            using UDIS = Field<1, 1>;    // Update disable
            using URS = Field<2, 1>;    // Update request source
            using OPM = Field<3, 1>;    // One-pulse mode
            using DIR = Field<4, 1>;    // Direction
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CKD = Field<8, 2>;    // Clock division
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
        };

        // control register 2
        struct CR2 : public Register<0x40010004> {
            using MMS2 = Field<20, 4>;    // Master mode selection 2
            using OIS6 = Field<18, 1>;    // Output Idle state 6
            using OIS5 = Field<16, 1>;    // Output Idle state 5
            using OIS4 = Field<14, 1>;    // Output Idle state 4
            using OIS3N = Field<13, 1>;    // Output Idle state 3
            using OIS3 = Field<12, 1>;    // Output Idle state 3
            using OIS2N = Field<11, 1>;    // Output Idle state 2
            using OIS2 = Field<10, 1>;    // Output Idle state 2
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
        };

        // slave mode control register
        struct SMCR : public Register<0x40010008> {
            using SMS = Field<0, 3>;    // Slave mode selection
            using TS = Field<4, 3>;    // Trigger selection
            using MSM = Field<7, 1>;    // Master/Slave mode
            using ETF = Field<8, 4>;    // External trigger filter
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ECE = Field<14, 1>;    // External clock enable
            using ETP = Field<15, 1>;    // External trigger polarity
            using SMS_3 = Field<16, 1>;    // Slave mode selection - bit 3
            using TS_4_3 = Field<20, 2>;    // Trigger selection - bit 4:3
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001000c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
        };

        // status register
        struct SR : public Register<0x40010010> {
            using CC6IF = Field<17, 1>;    // Compare 6 interrupt flag
            using CC5IF = Field<16, 1>;    // Compare 5 interrupt flag
            using SBIF = Field<13, 1>;    // System Break interrupt flag
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using B2IF = Field<8, 1>;    // Break 2 interrupt flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40010014> {
            using UG = Field<0, 1>;    // Update generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using TG = Field<6, 1>;    // Trigger generation
            using BG = Field<7, 1>;    // Break generation
            using B2G = Field<8, 1>;    // Break 2 generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40010018> {
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1CE = Field<7, 1>;    // Output Compare 1 clear enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC2FE = Field<10, 1>;    // Output Compare 2 fast enable
            using OC2PE = Field<11, 1>;    // Output Compare 2 preload enable
            using OC2M = Field<12, 3>;    // Output Compare 2 mode
            using OC2CE = Field<15, 1>;    // Output Compare 2 clear enable
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode - bit 3
            using OC2M_3 = Field<24, 1>;    // Output Compare 2 mode - bit 3
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40010018> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4001001c> {
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC3M_3 = Field<16, 1>;    // Output Compare 3 mode - bit 3
            using OC4M_4 = Field<24, 1>;    // Output Compare 4 mode - bit 3
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4001001c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40010020> {
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2NE = Field<6, 1>;    // Capture/Compare 2 complementary output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3NE = Field<10, 1>;    // Capture/Compare 3 complementary output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 complementary output polarity
            using CC5E = Field<16, 1>;    // Capture/Compare 5 output enable
            using CC5P = Field<17, 1>;    // Capture/Compare 5 output polarity
            using CC6E = Field<20, 1>;    // Capture/Compare 6 output enable
            using CC6P = Field<21, 1>;    // Capture/Compare 6 output polarity
        };

        // counter
        struct CNT : public Register<0x40010024> {
            using Field = Field<0, 16>;    // counter value
            using UIFCPY = Field<31, 1>;    // UIF copy
        };

        // prescaler
        struct PSC : public Register<0x40010028> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001002c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40010034> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40010038> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4001003c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40010040> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40010048> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4001004c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // repetition counter register
        struct RCR : public Register<0x40010030> {
            using REP = Field<0, 8>;    // Repetition counter value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40010044> {
            using DTG = Field<0, 8>;    // Dead-time generator setup
            using LOCK = Field<8, 2>;    // Lock configuration
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using BKE = Field<12, 1>;    // Break enable
            using BKP = Field<13, 1>;    // Break polarity
            using AOE = Field<14, 1>;    // Automatic output enable
            using MOE = Field<15, 1>;    // Main output enable
            using BKF = Field<16, 4>;    // Break filter
            using BK2F = Field<20, 4>;    // Break 2 filter
            using BK2E = Field<24, 1>;    // Break 2 enable
            using BK2P = Field<25, 1>;    // Break 2 polarity
        };

        // capture/compare mode register 3 (output mode)
        struct CCMR3_Output : public Register<0x40010054> {
            using OC5FE = Field<2, 1>;    // Output compare 5 fast enable
            using OC5PE = Field<3, 1>;    // Output compare 5 preload enable
            using OC5M = Field<4, 3>;    // Output compare 5 mode
            using OC5CE = Field<7, 1>;    // Output compare 5 clear enable
            using OC6FE = Field<10, 1>;    // Output compare 6 fast enable
            using OC6PE = Field<11, 1>;    // Output compare 6 preload enable
            using OC6M = Field<12, 3>;    // Output compare 6 mode
            using OC6CE = Field<15, 1>;    // Output compare 6 clear enable
            using OC5M3 = Field<16, 1>;    // Output Compare 5 mode
            using OC6M3 = Field<24, 1>;    // Output Compare 6 mode
        };

        // capture/compare register 5
        struct CCR5 : public Register<0x40010058> {
            using Field = Field<0, 16>;    // Capture/Compare 5 value
            using GC5C1 = Field<29, 1>;    // Group Channel 5 and Channel 1
            using GC5C2 = Field<30, 1>;    // Group Channel 5 and Channel 2
            using GC5C3 = Field<31, 1>;    // Group Channel 5 and Channel 3
        };

        // capture/compare register 6
        struct CRR6 : public Register<0x4001005c> {
            using CCR6 = Field<0, 16>;    // Capture/Compare 6 value
        };

        // TIM1 alternate function option register 1
        struct AF1 : public Register<0x40010060> {
            using BKINE = Field<0, 1>;    // BRK BKIN input enable
            using BKCMP1E = Field<1, 1>;    // BRK COMP1 enable
            using BKCMP2E = Field<2, 1>;    // BRK COMP2 enable
            using BKDF1BK0E = Field<8, 1>;    // BRK dfsdm1_break[0] enable
            using BKINP = Field<9, 1>;    // BRK BKIN input polarity
            using BKCMP1P = Field<10, 1>;    // BRK COMP1 input polarity
            using BKCMP2P = Field<11, 1>;    // BRK COMP2 input polarity
            using ETRSEL = Field<14, 4>;    // ETR source selection
        };

        // TIM1 Alternate function odfsdm1_breakster 2
        struct AF2 : public Register<0x40010064> {
            using BK2INE = Field<0, 1>;    // BRK2 BKIN input enable
            using BK2CMP1E = Field<1, 1>;    // BRK2 COMP1 enable
            using BK2CMP2E = Field<2, 1>;    // BRK2 COMP2 enable
            using BK2DF1BK1E = Field<8, 1>;    // BRK2 dfsdm1_break[1] enable
            using BK2INP = Field<9, 1>;    // BRK2 BKIN2 input polarity
            using BK2CMP1P = Field<10, 1>;    // BRK2 COMP1 input polarit
            using BK2CMP2P = Field<11, 1>;    // BRK2 COMP2 input polarity
        };

        // TIM1 timer input selection register
        struct TISEL : public Register<0x40010068> {
            using TI1SEL = Field<0, 4>;    // selects TI1[0] to TI1[15] input
            using TI2SEL = Field<8, 4>;    // selects TI2[0] to TI2[15] input
            using TI3SEL = Field<16, 4>;    // selects TI3[0] to TI3[15] input
            using TI4SEL = Field<24, 4>;    // selects TI4[0] to TI4[15] input
        };

    };

    // Advanced-timers
    struct TIM8 {
        // control register 1
        struct CR1 : public Register<0x40010400> {
            using CEN = Field<0, 1>;    // Counter enable
            using UDIS = Field<1, 1>;    // Update disable
            using URS = Field<2, 1>;    // Update request source
            using OPM = Field<3, 1>;    // One-pulse mode
            using DIR = Field<4, 1>;    // Direction
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CKD = Field<8, 2>;    // Clock division
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
        };

        // control register 2
        struct CR2 : public Register<0x40010404> {
            using MMS2 = Field<20, 4>;    // Master mode selection 2
            using OIS6 = Field<18, 1>;    // Output Idle state 6
            using OIS5 = Field<16, 1>;    // Output Idle state 5
            using OIS4 = Field<14, 1>;    // Output Idle state 4
            using OIS3N = Field<13, 1>;    // Output Idle state 3
            using OIS3 = Field<12, 1>;    // Output Idle state 3
            using OIS2N = Field<11, 1>;    // Output Idle state 2
            using OIS2 = Field<10, 1>;    // Output Idle state 2
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
        };

        // slave mode control register
        struct SMCR : public Register<0x40010408> {
            using SMS = Field<0, 3>;    // Slave mode selection
            using TS = Field<4, 3>;    // Trigger selection
            using MSM = Field<7, 1>;    // Master/Slave mode
            using ETF = Field<8, 4>;    // External trigger filter
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ECE = Field<14, 1>;    // External clock enable
            using ETP = Field<15, 1>;    // External trigger polarity
            using SMS_3 = Field<16, 1>;    // Slave mode selection - bit 3
            using TS_4_3 = Field<20, 2>;    // Trigger selection - bit 4:3
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001040c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
        };

        // status register
        struct SR : public Register<0x40010410> {
            using CC6IF = Field<17, 1>;    // Compare 6 interrupt flag
            using CC5IF = Field<16, 1>;    // Compare 5 interrupt flag
            using SBIF = Field<13, 1>;    // System Break interrupt flag
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using B2IF = Field<8, 1>;    // Break 2 interrupt flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40010414> {
            using UG = Field<0, 1>;    // Update generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using TG = Field<6, 1>;    // Trigger generation
            using BG = Field<7, 1>;    // Break generation
            using B2G = Field<8, 1>;    // Break 2 generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40010418> {
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1CE = Field<7, 1>;    // Output Compare 1 clear enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC2FE = Field<10, 1>;    // Output Compare 2 fast enable
            using OC2PE = Field<11, 1>;    // Output Compare 2 preload enable
            using OC2M = Field<12, 3>;    // Output Compare 2 mode
            using OC2CE = Field<15, 1>;    // Output Compare 2 clear enable
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode - bit 3
            using OC2M_3 = Field<24, 1>;    // Output Compare 2 mode - bit 3
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40010418> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4001041c> {
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC3M_3 = Field<16, 1>;    // Output Compare 3 mode - bit 3
            using OC4M_4 = Field<24, 1>;    // Output Compare 4 mode - bit 3
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4001041c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40010420> {
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2NE = Field<6, 1>;    // Capture/Compare 2 complementary output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3NE = Field<10, 1>;    // Capture/Compare 3 complementary output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 complementary output polarity
            using CC5E = Field<16, 1>;    // Capture/Compare 5 output enable
            using CC5P = Field<17, 1>;    // Capture/Compare 5 output polarity
            using CC6E = Field<20, 1>;    // Capture/Compare 6 output enable
            using CC6P = Field<21, 1>;    // Capture/Compare 6 output polarity
        };

        // counter
        struct CNT : public Register<0x40010424> {
            using Field = Field<0, 16>;    // counter value
            using UIFCPY = Field<31, 1>;    // UIF copy
        };

        // prescaler
        struct PSC : public Register<0x40010428> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001042c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40010434> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40010438> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4001043c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40010440> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40010448> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4001044c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // repetition counter register
        struct RCR : public Register<0x40010430> {
            using REP = Field<0, 8>;    // Repetition counter value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40010444> {
            using DTG = Field<0, 8>;    // Dead-time generator setup
            using LOCK = Field<8, 2>;    // Lock configuration
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using BKE = Field<12, 1>;    // Break enable
            using BKP = Field<13, 1>;    // Break polarity
            using AOE = Field<14, 1>;    // Automatic output enable
            using MOE = Field<15, 1>;    // Main output enable
            using BKF = Field<16, 4>;    // Break filter
            using BK2F = Field<20, 4>;    // Break 2 filter
            using BK2E = Field<24, 1>;    // Break 2 enable
            using BK2P = Field<25, 1>;    // Break 2 polarity
        };

        // capture/compare mode register 3 (output mode)
        struct CCMR3_Output : public Register<0x40010454> {
            using OC5FE = Field<2, 1>;    // Output compare 5 fast enable
            using OC5PE = Field<3, 1>;    // Output compare 5 preload enable
            using OC5M = Field<4, 3>;    // Output compare 5 mode
            using OC5CE = Field<7, 1>;    // Output compare 5 clear enable
            using OC6FE = Field<10, 1>;    // Output compare 6 fast enable
            using OC6PE = Field<11, 1>;    // Output compare 6 preload enable
            using OC6M = Field<12, 3>;    // Output compare 6 mode
            using OC6CE = Field<15, 1>;    // Output compare 6 clear enable
            using OC5M3 = Field<16, 1>;    // Output Compare 5 mode
            using OC6M3 = Field<24, 1>;    // Output Compare 6 mode
        };

        // capture/compare register 5
        struct CCR5 : public Register<0x40010458> {
            using Field = Field<0, 16>;    // Capture/Compare 5 value
            using GC5C1 = Field<29, 1>;    // Group Channel 5 and Channel 1
            using GC5C2 = Field<30, 1>;    // Group Channel 5 and Channel 2
            using GC5C3 = Field<31, 1>;    // Group Channel 5 and Channel 3
        };

        // capture/compare register 6
        struct CRR6 : public Register<0x4001045c> {
            using CCR6 = Field<0, 16>;    // Capture/Compare 6 value
        };

        // TIM1 alternate function option register 1
        struct AF1 : public Register<0x40010460> {
            using BKINE = Field<0, 1>;    // BRK BKIN input enable
            using BKCMP1E = Field<1, 1>;    // BRK COMP1 enable
            using BKCMP2E = Field<2, 1>;    // BRK COMP2 enable
            using BKDF1BK0E = Field<8, 1>;    // BRK dfsdm1_break[0] enable
            using BKINP = Field<9, 1>;    // BRK BKIN input polarity
            using BKCMP1P = Field<10, 1>;    // BRK COMP1 input polarity
            using BKCMP2P = Field<11, 1>;    // BRK COMP2 input polarity
            using ETRSEL = Field<14, 4>;    // ETR source selection
        };

        // TIM1 Alternate function odfsdm1_breakster 2
        struct AF2 : public Register<0x40010464> {
            using BK2INE = Field<0, 1>;    // BRK2 BKIN input enable
            using BK2CMP1E = Field<1, 1>;    // BRK2 COMP1 enable
            using BK2CMP2E = Field<2, 1>;    // BRK2 COMP2 enable
            using BK2DF1BK1E = Field<8, 1>;    // BRK2 dfsdm1_break[1] enable
            using BK2INP = Field<9, 1>;    // BRK2 BKIN2 input polarity
            using BK2CMP1P = Field<10, 1>;    // BRK2 COMP1 input polarit
            using BK2CMP2P = Field<11, 1>;    // BRK2 COMP2 input polarity
        };

        // TIM1 timer input selection register
        struct TISEL : public Register<0x40010468> {
            using TI1SEL = Field<0, 4>;    // selects TI1[0] to TI1[15] input
            using TI2SEL = Field<8, 4>;    // selects TI2[0] to TI2[15] input
            using TI3SEL = Field<16, 4>;    // selects TI3[0] to TI3[15] input
            using TI4SEL = Field<24, 4>;    // selects TI4[0] to TI4[15] input
        };

    };

    // FDCAN1
    struct FDCAN1 {
        // FDCAN Core Release Register
        struct FDCAN_CREL : public RegisterReadOnly<0x4000a000> {
            using REL = Field<28, 4>;    // Core release
            using STEP = Field<24, 4>;    // Step of Core release
            using SUBSTEP = Field<20, 4>;    // Sub-step of Core release
            using YEAR = Field<16, 4>;    // Timestamp Year
            using MON = Field<8, 8>;    // Timestamp Month
            using DAY = Field<0, 8>;    // Timestamp Day
        };

        // FDCAN Core Release Register
        struct FDCAN_ENDN : public RegisterReadOnly<0x4000a004> {
            using ETV = Field<0, 32>;    // Endiannes Test Value
        };

        // FDCAN Data Bit Timing and Prescaler Register
        struct FDCAN_DBTP : public RegisterReadOnly<0x4000a00c> {
            using DSJW = Field<0, 4>;    // Synchronization Jump Width
            using DTSEG2 = Field<4, 4>;    // Data time segment after sample point
            using DTSEG1 = Field<8, 5>;    // Data time segment after sample point
            using DBRP = Field<16, 5>;    // Data BIt Rate Prescaler
            using TDC = Field<23, 1>;    // Transceiver Delay Compensation
        };

        // FDCAN Test Register
        struct FDCAN_TEST : public RegisterReadOnly<0x4000a010> {
            using LBCK = Field<4, 1>;    // Loop Back mode
            using TX = Field<5, 2>;    // Loop Back mode
            using RX = Field<7, 1>;    // Control of Transmit Pin
        };

        // FDCAN RAM Watchdog Register
        struct FDCAN_RWD : public RegisterReadOnly<0x4000a014> {
            using WDV = Field<8, 8>;    // Watchdog value
            using WDC = Field<0, 8>;    // Watchdog configuration
        };

        // FDCAN CC Control Register
        struct FDCAN_CCCR : public Register<0x4000a018> {
            using INIT = Field<0, 1>;    // Initialization
            using CCE = Field<1, 1>;    // Configuration Change Enable
            using ASM = Field<2, 1>;    // ASM Restricted Operation Mode
            using CSA = Field<3, 1>;    // Clock Stop Acknowledge
            using CSR = Field<4, 1>;    // Clock Stop Request
            using MON = Field<5, 1>;    // Bus Monitoring Mode
            using DAR = Field<6, 1>;    // Disable Automatic Retransmission
            using TEST = Field<7, 1>;    // Test Mode Enable
            using FDOE = Field<8, 1>;    // FD Operation Enable
            using BSE = Field<9, 1>;    // FDCAN Bit Rate Switching
            using PXHD = Field<12, 1>;    // Protocol Exception Handling Disable
            using EFBI = Field<13, 1>;    // Edge Filtering during Bus Integration
            using TXP = Field<14, 1>;    // TXP
            using NISO = Field<15, 1>;    // Non ISO Operation
        };

        // FDCAN Nominal Bit Timing and Prescaler Register
        struct FDCAN_NBTP : public Register<0x4000a01c> {
            using NSJW = Field<25, 7>;    // NSJW: Nominal (Re)Synchronization Jump Width
            using NBRP = Field<16, 9>;    // Bit Rate Prescaler
            using NTSEG1 = Field<8, 8>;    // Nominal Time segment before sample point
            using TSEG2 = Field<0, 7>;    // Nominal Time segment after sample point
        };

        // FDCAN Timestamp Counter Configuration Register
        struct FDCAN_TSCC : public Register<0x4000a020> {
            using TCP = Field<16, 4>;    // Timestamp Counter Prescaler
            using TSS = Field<0, 2>;    // Timestamp Select
        };

        // FDCAN Timestamp Counter Value Register
        struct FDCAN_TSCV : public Register<0x4000a024> {
            using TSC = Field<0, 16>;    // Timestamp Counter
        };

        // FDCAN Timeout Counter Configuration Register
        struct FDCAN_TOCC : public Register<0x4000a028> {
            using ETOC = Field<0, 1>;    // Enable Timeout Counter
            using TOS = Field<1, 2>;    // Timeout Select
            using TOP = Field<16, 16>;    // Timeout Period
        };

        // FDCAN Timeout Counter Value Register
        struct FDCAN_TOCV : public Register<0x4000a02c> {
            using TOC = Field<0, 16>;    // Timeout Counter
        };

        // FDCAN Error Counter Register
        struct FDCAN_ECR : public Register<0x4000a040> {
            using CEL = Field<16, 8>;    // AN Error Logging
            using RP = Field<15, 1>;    // Receive Error Passive
            using TREC = Field<8, 7>;    // Receive Error Counter
            using TEC = Field<0, 8>;    // Transmit Error Counter
        };

        // FDCAN Protocol Status Register
        struct FDCAN_PSR : public Register<0x4000a044> {
            using LEC = Field<0, 3>;    // Last Error Code
            using ACT = Field<3, 2>;    // Activity
            using EP = Field<5, 1>;    // Error Passive
            using EW = Field<6, 1>;    // Warning Status
            using BO = Field<7, 1>;    // Bus_Off Status
            using DLEC = Field<8, 3>;    // Data Last Error Code
            using RESI = Field<11, 1>;    // ESI flag of last received FDCAN Message
            using RBRS = Field<12, 1>;    // BRS flag of last received FDCAN Message
            using REDL = Field<13, 1>;    // Received FDCAN Message
            using PXE = Field<14, 1>;    // Protocol Exception Event
            using TDCV = Field<16, 7>;    // Transmitter Delay Compensation Value
        };

        // FDCAN Transmitter Delay Compensation Register
        struct FDCAN_TDCR : public RegisterReadOnly<0x4000a048> {
            using TDCF = Field<0, 7>;    // Transmitter Delay Compensation Filter Window Length
            using TDCO = Field<8, 7>;    // Transmitter Delay Compensation Offset
        };

        // FDCAN Interrupt Register
        struct FDCAN_IR : public RegisterReadOnly<0x4000a050> {
            using RF0N = Field<0, 1>;    // Rx FIFO 0 New Message
            using RF0W = Field<1, 1>;    // Rx FIFO 0 Full
            using RF0F = Field<2, 1>;    // Rx FIFO 0 Full
            using RF0L = Field<3, 1>;    // Rx FIFO 0 Message Lost
            using RF1N = Field<4, 1>;    // Rx FIFO 1 New Message
            using RF1W = Field<5, 1>;    // Rx FIFO 1 Watermark Reached
            using RF1F = Field<6, 1>;    // Rx FIFO 1 Watermark Reached
            using RF1L = Field<7, 1>;    // Rx FIFO 1 Message Lost
            using HPM = Field<8, 1>;    // High Priority Message
            using TC = Field<9, 1>;    // Transmission Completed
            using TCF = Field<10, 1>;    // Transmission Cancellation Finished
            using TEF = Field<11, 1>;    // Tx FIFO Empty
            using TEFN = Field<12, 1>;    // Tx Event FIFO New Entry
            using TEFW = Field<13, 1>;    // Tx Event FIFO Watermark Reached
            using TEFF = Field<14, 1>;    // Tx Event FIFO Full
            using TEFL = Field<15, 1>;    // Tx Event FIFO Element Lost
            using TSW = Field<16, 1>;    // Timestamp Wraparound
            using MRAF = Field<17, 1>;    // Message RAM Access Failure
            using TOO = Field<18, 1>;    // Timeout Occurred
            using DRX = Field<19, 1>;    // Message stored to Dedicated Rx Buffer
            using ELO = Field<22, 1>;    // Error Logging Overflow
            using EP = Field<23, 1>;    // Error Passive
            using EW = Field<24, 1>;    // Warning Status
            using BO = Field<25, 1>;    // Bus_Off Status
            using WDI = Field<26, 1>;    // Watchdog Interrupt
            using PEA = Field<27, 1>;    // Protocol Error in Arbitration Phase (Nominal Bit Time is used)
            using PED = Field<28, 1>;    // Protocol Error in Data Phase (Data Bit Time is used)
            using ARA = Field<29, 1>;    // Access to Reserved Address
        };

        // FDCAN Interrupt Enable Register
        struct FDCAN_IE : public RegisterReadOnly<0x4000a054> {
            using RF0NE = Field<0, 1>;    // Rx FIFO 0 New Message Enable
            using RF0WE = Field<1, 1>;    // Rx FIFO 0 Full Enable
            using RF0FE = Field<2, 1>;    // Rx FIFO 0 Full Enable
            using RF0LE = Field<3, 1>;    // Rx FIFO 0 Message Lost Enable
            using RF1NE = Field<4, 1>;    // Rx FIFO 1 New Message Enable
            using RF1WE = Field<5, 1>;    // Rx FIFO 1 Watermark Reached Enable
            using RF1FE = Field<6, 1>;    // Rx FIFO 1 Watermark Reached Enable
            using RF1LE = Field<7, 1>;    // Rx FIFO 1 Message Lost Enable
            using HPME = Field<8, 1>;    // High Priority Message Enable
            using TCE = Field<9, 1>;    // Transmission Completed Enable
            using TCFE = Field<10, 1>;    // Transmission Cancellation Finished Enable
            using TEFE = Field<11, 1>;    // Tx FIFO Empty Enable
            using TEFNE = Field<12, 1>;    // Tx Event FIFO New Entry Enable
            using TEFWE = Field<13, 1>;    // Tx Event FIFO Watermark Reached Enable
            using TEFFE = Field<14, 1>;    // Tx Event FIFO Full Enable
            using TEFLE = Field<15, 1>;    // Tx Event FIFO Element Lost Enable
            using TSWE = Field<16, 1>;    // Timestamp Wraparound Enable
            using MRAFE = Field<17, 1>;    // Message RAM Access Failure Enable
            using TOOE = Field<18, 1>;    // Timeout Occurred Enable
            using DRXE = Field<19, 1>;    // Message stored to Dedicated Rx Buffer Enable
            using BECE = Field<20, 1>;    // Bit Error Corrected Interrupt Enable
            using BEUE = Field<21, 1>;    // Bit Error Uncorrected Interrupt Enable
            using ELOE = Field<22, 1>;    // Error Logging Overflow Enable
            using EPE = Field<23, 1>;    // Error Passive Enable
            using EWE = Field<24, 1>;    // Warning Status Enable
            using BOE = Field<25, 1>;    // Bus_Off Status Enable
            using WDIE = Field<26, 1>;    // Watchdog Interrupt Enable
            using PEAE = Field<27, 1>;    // Protocol Error in Arbitration Phase Enable
            using PEDE = Field<28, 1>;    // Protocol Error in Data Phase Enable
            using ARAE = Field<29, 1>;    // Access to Reserved Address Enable
        };

        // FDCAN Interrupt Line Select Register
        struct FDCAN_ILS : public RegisterReadOnly<0x4000a058> {
            using RF0NL = Field<0, 1>;    // Rx FIFO 0 New Message Interrupt Line
            using RF0WL = Field<1, 1>;    // Rx FIFO 0 Watermark Reached Interrupt Line
            using RF0FL = Field<2, 1>;    // Rx FIFO 0 Full Interrupt Line
            using RF0LL = Field<3, 1>;    // Rx FIFO 0 Message Lost Interrupt Line
            using RF1NL = Field<4, 1>;    // Rx FIFO 1 New Message Interrupt Line
            using RF1WL = Field<5, 1>;    // Rx FIFO 1 Watermark Reached Interrupt Line
            using RF1FL = Field<6, 1>;    // Rx FIFO 1 Full Interrupt Line
            using RF1LL = Field<7, 1>;    // Rx FIFO 1 Message Lost Interrupt Line
            using HPML = Field<8, 1>;    // High Priority Message Interrupt Line
            using TCL = Field<9, 1>;    // Transmission Completed Interrupt Line
            using TCFL = Field<10, 1>;    // Transmission Cancellation Finished Interrupt Line
            using TEFL = Field<11, 1>;    // Tx FIFO Empty Interrupt Line
            using TEFNL = Field<12, 1>;    // Tx Event FIFO New Entry Interrupt Line
            using TEFWL = Field<13, 1>;    // Tx Event FIFO Watermark Reached Interrupt Line
            using TEFFL = Field<14, 1>;    // Tx Event FIFO Full Interrupt Line
            using TEFLL = Field<15, 1>;    // Tx Event FIFO Element Lost Interrupt Line
            using TSWL = Field<16, 1>;    // Timestamp Wraparound Interrupt Line
            using MRAFL = Field<17, 1>;    // Message RAM Access Failure Interrupt Line
            using TOOL = Field<18, 1>;    // Timeout Occurred Interrupt Line
            using DRXL = Field<19, 1>;    // Message stored to Dedicated Rx Buffer Interrupt Line
            using BECL = Field<20, 1>;    // Bit Error Corrected Interrupt Line
            using BEUL = Field<21, 1>;    // Bit Error Uncorrected Interrupt Line
            using ELOL = Field<22, 1>;    // Error Logging Overflow Interrupt Line
            using EPL = Field<23, 1>;    // Error Passive Interrupt Line
            using EWL = Field<24, 1>;    // Warning Status Interrupt Line
            using BOL = Field<25, 1>;    // Bus_Off Status
            using WDIL = Field<26, 1>;    // Watchdog Interrupt Line
            using PEAL = Field<27, 1>;    // Protocol Error in Arbitration Phase Line
            using PEDL = Field<28, 1>;    // Protocol Error in Data Phase Line
            using ARAL = Field<29, 1>;    // Access to Reserved Address Line
        };

        // FDCAN Interrupt Line Enable Register
        struct FDCAN_ILE : public Register<0x4000a05c> {
            using EINT0 = Field<0, 1>;    // Enable Interrupt Line 0
            using EINT1 = Field<1, 1>;    // Enable Interrupt Line 1
        };

        // FDCAN Global Filter Configuration Register
        struct FDCAN_GFC : public Register<0x4000a080> {
            using RRFE = Field<0, 1>;    // Reject Remote Frames Extended
            using RRFS = Field<1, 1>;    // Reject Remote Frames Standard
            using ANFE = Field<2, 2>;    // Accept Non-matching Frames Extended
            using ANFS = Field<4, 2>;    // Accept Non-matching Frames Standard
        };

        // FDCAN Standard ID Filter Configuration Register
        struct FDCAN_SIDFC : public Register<0x4000a084> {
            using FLSSA = Field<2, 14>;    // Filter List Standard Start Address
            using LSS = Field<16, 8>;    // List Size Standard
        };

        // FDCAN Extended ID Filter Configuration Register
        struct FDCAN_XIDFC : public Register<0x4000a088> {
            using FLESA = Field<2, 14>;    // Filter List Standard Start Address
            using LSE = Field<16, 8>;    // List Size Extended
        };

        // FDCAN Extended ID and Mask Register
        struct FDCAN_XIDAM : public Register<0x4000a090> {
            using EIDM = Field<0, 29>;    // Extended ID Mask
        };

        // FDCAN High Priority Message Status Register
        struct FDCAN_HPMS : public RegisterReadOnly<0x4000a094> {
            using BIDX = Field<0, 6>;    // Buffer Index
            using MSI = Field<6, 2>;    // Message Storage Indicator
            using FIDX = Field<8, 7>;    // Filter Index
            using FLST = Field<15, 1>;    // Filter List
        };

        // FDCAN New Data 1 Register
        struct FDCAN_NDAT1 : public RegisterReadOnly<0x4000a098> {
            using ND0 = Field<0, 1>;    // New data
            using ND1 = Field<1, 1>;    // New data
            using ND2 = Field<2, 1>;    // New data
            using ND3 = Field<3, 1>;    // New data
            using ND4 = Field<4, 1>;    // New data
            using ND5 = Field<5, 1>;    // New data
            using ND6 = Field<6, 1>;    // New data
            using ND7 = Field<7, 1>;    // New data
            using ND8 = Field<8, 1>;    // New data
            using ND9 = Field<9, 1>;    // New data
            using ND10 = Field<10, 1>;    // New data
            using ND11 = Field<11, 1>;    // New data
            using ND12 = Field<12, 1>;    // New data
            using ND13 = Field<13, 1>;    // New data
            using ND14 = Field<14, 1>;    // New data
            using ND15 = Field<15, 1>;    // New data
            using ND16 = Field<16, 1>;    // New data
            using ND17 = Field<17, 1>;    // New data
            using ND18 = Field<18, 1>;    // New data
            using ND19 = Field<19, 1>;    // New data
            using ND20 = Field<20, 1>;    // New data
            using ND21 = Field<21, 1>;    // New data
            using ND22 = Field<22, 1>;    // New data
            using ND23 = Field<23, 1>;    // New data
            using ND24 = Field<24, 1>;    // New data
            using ND25 = Field<25, 1>;    // New data
            using ND26 = Field<26, 1>;    // New data
            using ND27 = Field<27, 1>;    // New data
            using ND28 = Field<28, 1>;    // New data
            using ND29 = Field<29, 1>;    // New data
            using ND30 = Field<30, 1>;    // New data
            using ND31 = Field<31, 1>;    // New data
        };

        // FDCAN New Data 2 Register
        struct FDCAN_NDAT2 : public RegisterReadOnly<0x4000a09c> {
            using ND32 = Field<0, 1>;    // New data
            using ND33 = Field<1, 1>;    // New data
            using ND34 = Field<2, 1>;    // New data
            using ND35 = Field<3, 1>;    // New data
            using ND36 = Field<4, 1>;    // New data
            using ND37 = Field<5, 1>;    // New data
            using ND38 = Field<6, 1>;    // New data
            using ND39 = Field<7, 1>;    // New data
            using ND40 = Field<8, 1>;    // New data
            using ND41 = Field<9, 1>;    // New data
            using ND42 = Field<10, 1>;    // New data
            using ND43 = Field<11, 1>;    // New data
            using ND44 = Field<12, 1>;    // New data
            using ND45 = Field<13, 1>;    // New data
            using ND46 = Field<14, 1>;    // New data
            using ND47 = Field<15, 1>;    // New data
            using ND48 = Field<16, 1>;    // New data
            using ND49 = Field<17, 1>;    // New data
            using ND50 = Field<18, 1>;    // New data
            using ND51 = Field<19, 1>;    // New data
            using ND52 = Field<20, 1>;    // New data
            using ND53 = Field<21, 1>;    // New data
            using ND54 = Field<22, 1>;    // New data
            using ND55 = Field<23, 1>;    // New data
            using ND56 = Field<24, 1>;    // New data
            using ND57 = Field<25, 1>;    // New data
            using ND58 = Field<26, 1>;    // New data
            using ND59 = Field<27, 1>;    // New data
            using ND60 = Field<28, 1>;    // New data
            using ND61 = Field<29, 1>;    // New data
            using ND62 = Field<30, 1>;    // New data
            using ND63 = Field<31, 1>;    // New data
        };

        // FDCAN Rx FIFO 0 Configuration Register
        struct FDCAN_RXF0C : public Register<0x4000a0a0> {
            using F0SA = Field<2, 14>;    // Rx FIFO 0 Start Address
            using F0S = Field<16, 8>;    // Rx FIFO 0 Size
            using F0WM = Field<24, 8>;    // FIFO 0 Watermark
        };

        // FDCAN Rx FIFO 0 Status Register
        struct FDCAN_RXF0S : public Register<0x4000a0a4> {
            using F0FL = Field<0, 7>;    // Rx FIFO 0 Fill Level
            using F0G = Field<8, 6>;    // Rx FIFO 0 Get Index
            using F0P = Field<16, 6>;    // Rx FIFO 0 Put Index
            using F0F = Field<24, 1>;    // Rx FIFO 0 Full
            using RF0L = Field<25, 1>;    // Rx FIFO 0 Message Lost
        };

        // CAN Rx FIFO 0 Acknowledge Register
        struct FDCAN_RXF0A : public Register<0x4000a0a8> {
            using FA01 = Field<0, 6>;    // Rx FIFO 0 Acknowledge Index
        };

        // FDCAN Rx Buffer Configuration Register
        struct FDCAN_RXBC : public Register<0x4000a0ac> {
            using RBSA = Field<2, 14>;    // Rx Buffer Start Address
        };

        // FDCAN Rx FIFO 1 Configuration Register
        struct FDCAN_RXF1C : public Register<0x4000a0b0> {
            using F1SA = Field<2, 14>;    // Rx FIFO 1 Start Address
            using F1S = Field<16, 7>;    // Rx FIFO 1 Size
            using F1WM = Field<24, 7>;    // Rx FIFO 1 Watermark
        };

        // FDCAN Rx FIFO 1 Status Register
        struct FDCAN_RXF1S : public Register<0x4000a0b4> {
            using F1FL = Field<0, 7>;    // Rx FIFO 1 Fill Level
            using F1GI = Field<8, 7>;    // Rx FIFO 1 Get Index
            using F1PI = Field<16, 7>;    // Rx FIFO 1 Put Index
            using F1F = Field<24, 1>;    // Rx FIFO 1 Full
            using RF1L = Field<25, 1>;    // Rx FIFO 1 Message Lost
            using DMS = Field<30, 2>;    // Debug Message Status
        };

        // FDCAN Rx FIFO 1 Acknowledge Register
        struct FDCAN_RXF1A : public Register<0x4000a0b8> {
            using F1AI = Field<0, 6>;    // Rx FIFO 1 Acknowledge Index
        };

        // FDCAN Rx Buffer Element Size Configuration Register
        struct FDCAN_RXESC : public Register<0x4000a0bc> {
            using F0DS = Field<0, 3>;    // Rx FIFO 1 Data Field Size:
            using F1DS = Field<4, 3>;    // Rx FIFO 0 Data Field Size:
            using RBDS = Field<8, 3>;    // Rx Buffer Data Field Size:
        };

        // FDCAN Tx Buffer Configuration Register
        struct FDCAN_TXBC : public Register<0x4000a0c0> {
            using TBSA = Field<2, 14>;    // Tx Buffers Start Address
            using NDTB = Field<16, 6>;    // Number of Dedicated Transmit Buffers
            using TFQS = Field<24, 6>;    // Transmit FIFO/Queue Size
            using TFQM = Field<30, 1>;    // Tx FIFO/Queue Mode
        };

        // FDCAN Tx FIFO/Queue Status Register
        struct FDCAN_TXFQS : public RegisterReadOnly<0x4000a0c4> {
            using TFFL = Field<0, 6>;    // Tx FIFO Free Level
            using TFGI = Field<8, 5>;    // TFGI
            using TFQPI = Field<16, 5>;    // Tx FIFO/Queue Put Index
            using TFQF = Field<21, 1>;    // Tx FIFO/Queue Full
        };

        // FDCAN Tx Buffer Element Size Configuration Register
        struct FDCAN_TXESC : public Register<0x4000a0c8> {
            using TBDS = Field<0, 3>;    // Tx Buffer Data Field Size:
        };

        // FDCAN Tx Buffer Request Pending Register
        struct FDCAN_TXBRP : public RegisterReadOnly<0x4000a0cc> {
            using TRP = Field<0, 32>;    // Transmission Request Pending
        };

        // FDCAN Tx Buffer Add Request Register
        struct FDCAN_TXBAR : public Register<0x4000a0d0> {
            using AR = Field<0, 32>;    // Add Request
        };

        // FDCAN Tx Buffer Cancellation Request Register
        struct FDCAN_TXBCR : public Register<0x4000a0d4> {
            using CR = Field<0, 32>;    // Cancellation Request
        };

        // FDCAN Tx Buffer Transmission Occurred Register
        struct FDCAN_TXBTO : public Register<0x4000a0d8> {
            using TO = Field<0, 32>;    // Transmission Occurred.
        };

        // FDCAN Tx Buffer Cancellation Finished Register
        struct FDCAN_TXBCF : public RegisterReadOnly<0x4000a0dc> {
            using CF = Field<0, 32>;    // Cancellation Finished
        };

        // FDCAN Tx Buffer Transmission Interrupt Enable Register
        struct FDCAN_TXBTIE : public Register<0x4000a0e0> {
            using TIE = Field<0, 32>;    // Transmission Interrupt Enable
        };

        // FDCAN Tx Buffer Cancellation Finished Interrupt Enable Register
        struct FDCAN_TXBCIE : public Register<0x4000a0e4> {
            using CF = Field<0, 32>;    // Cancellation Finished Interrupt Enable
        };

        // FDCAN Tx Event FIFO Configuration Register
        struct FDCAN_TXEFC : public Register<0x4000a0f0> {
            using EFSA = Field<2, 14>;    // Event FIFO Start Address
            using EFS = Field<16, 6>;    // Event FIFO Size
            using EFWM = Field<24, 6>;    // Event FIFO Watermark
        };

        // FDCAN Tx Event FIFO Status Register
        struct FDCAN_TXEFS : public Register<0x4000a0f4> {
            using EFFL = Field<0, 6>;    // Event FIFO Fill Level
            using EFGI = Field<8, 5>;    // Event FIFO Get Index.
            using EFF = Field<24, 1>;    // Event FIFO Full.
            using TEFL = Field<25, 1>;    // Tx Event FIFO Element Lost.
        };

        // FDCAN Tx Event FIFO Acknowledge Register
        struct FDCAN_TXEFA : public Register<0x4000a0f8> {
            using EFAI = Field<0, 5>;    // Event FIFO Acknowledge Index
        };

        // FDCAN TT Trigger Memory Configuration Register
        struct FDCAN_TTTMC : public Register<0x4000a100> {
            using TMSA = Field<2, 14>;    // Trigger Memory Start Address
            using TME = Field<16, 7>;    // Trigger Memory Elements
        };

        // FDCAN TT Reference Message Configuration Register
        struct FDCAN_TTRMC : public Register<0x4000a104> {
            using RID = Field<0, 29>;    // Reference Identifier.
            using XTD = Field<30, 1>;    // Extended Identifier
            using RMPS = Field<31, 1>;    // Reference Message Payload Select
        };

        // FDCAN TT Operation Configuration Register
        struct FDCAN_TTOCF : public Register<0x4000a108> {
            using OM = Field<0, 2>;    // Operation Mode
            using GEN = Field<3, 1>;    // Gap Enable
            using TM = Field<4, 1>;    // Time Master
            using LDSDL = Field<5, 3>;    // LD of Synchronization Deviation Limit
            using IRTO = Field<8, 7>;    // Initial Reference Trigger Offset
            using EECS = Field<15, 1>;    // Enable External Clock Synchronization
            using AWL = Field<16, 8>;    // Application Watchdog Limit
            using EGTF = Field<24, 1>;    // Enable Global Time Filtering
            using ECC = Field<25, 1>;    // Enable Clock Calibration
            using EVTP = Field<26, 1>;    // Event Trigger Polarity
        };

        // FDCAN TT Matrix Limits Register
        struct FDCAN_TTMLM : public Register<0x4000a10c> {
            using CCM = Field<0, 6>;    // Cycle Count Max
            using CSS = Field<6, 2>;    // Cycle Start Synchronization
            using TXEW = Field<8, 4>;    // Tx Enable Window
            using ENTT = Field<16, 12>;    // Expected Number of Tx Triggers
        };

        // FDCAN TUR Configuration Register
        struct FDCAN_TURCF : public Register<0x4000a110> {
            using NCL = Field<0, 16>;    // Numerator Configuration Low.
            using DC = Field<16, 14>;    // Denominator Configuration.
            using ELT = Field<31, 1>;    // Enable Local Time
        };

        // FDCAN TT Operation Control Register
        struct FDCAN_TTOCN : public Register<0x4000a114> {
            using SGT = Field<0, 1>;    // Set Global time
            using ECS = Field<1, 1>;    // External Clock Synchronization
            using SWP = Field<2, 1>;    // Stop Watch Polarity
            using SWS = Field<3, 2>;    // Stop Watch Source.
            using RTIE = Field<5, 1>;    // Register Time Mark Interrupt Pulse Enable
            using TMC = Field<6, 2>;    // Register Time Mark Compare
            using TTIE = Field<8, 1>;    // Trigger Time Mark Interrupt Pulse Enable
            using GCS = Field<9, 1>;    // Gap Control Select
            using FGP = Field<10, 1>;    // Finish Gap.
            using TMG = Field<11, 1>;    // Time Mark Gap
            using NIG = Field<12, 1>;    // Next is Gap
            using ESCN = Field<13, 1>;    // External Synchronization Control
            using LCKC = Field<15, 1>;    // TT Operation Control Register Locked
        };

        // FDCAN TT Global Time Preset Register
        struct CAN_TTGTP : public Register<0x4000a118> {
            using NCL = Field<0, 16>;    // Time Preset
            using CTP = Field<16, 16>;    // Cycle Time Target Phase
        };

        // FDCAN TT Time Mark Register
        struct FDCAN_TTTMK : public Register<0x4000a11c> {
            using TM = Field<0, 16>;    // Time Mark
            using TICC = Field<16, 7>;    // Time Mark Cycle Code
            using LCKM = Field<31, 1>;    // TT Time Mark Register Locked
        };

        // FDCAN TT Interrupt Register
        struct FDCAN_TTIR : public Register<0x4000a120> {
            using SBC = Field<0, 1>;    // Start of Basic Cycle
            using SMC = Field<1, 1>;    // Start of Matrix Cycle
            using CSM = Field<2, 1>;    // Change of Synchronization Mode
            using SOG = Field<3, 1>;    // Start of Gap
            using RTMI = Field<4, 1>;    // Register Time Mark Interrupt.
            using TTMI = Field<5, 1>;    // Trigger Time Mark Event Internal
            using SWE = Field<6, 1>;    // Stop Watch Event
            using GTW = Field<7, 1>;    // Global Time Wrap
            using GTD = Field<8, 1>;    // Global Time Discontinuity
            using GTE = Field<9, 1>;    // Global Time Error
            using TXU = Field<10, 1>;    // Tx Count Underflow
            using TXO = Field<11, 1>;    // Tx Count Overflow
            using SE1 = Field<12, 1>;    // Scheduling Error 1
            using SE2 = Field<13, 1>;    // Scheduling Error 2
            using ELC = Field<14, 1>;    // Error Level Changed.
            using IWTG = Field<15, 1>;    // Initialization Watch Trigger
            using WT = Field<16, 1>;    // Watch Trigger
            using AW = Field<17, 1>;    // Application Watchdog
            using CER = Field<18, 1>;    // Configuration Error
        };

        // FDCAN TT Interrupt Enable Register
        struct FDCAN_TTIE : public Register<0x4000a124> {
            using SBCE = Field<0, 1>;    // Start of Basic Cycle Interrupt Enable
            using SMCE = Field<1, 1>;    // Start of Matrix Cycle Interrupt Enable
            using CSME = Field<2, 1>;    // Change of Synchronization Mode Interrupt Enable
            using SOGE = Field<3, 1>;    // Start of Gap Interrupt Enable
            using RTMIE = Field<4, 1>;    // Register Time Mark Interrupt Enable
            using TTMIE = Field<5, 1>;    // Trigger Time Mark Event Internal Interrupt Enable
            using SWEE = Field<6, 1>;    // Stop Watch Event Interrupt Enable
            using GTWE = Field<7, 1>;    // Global Time Wrap Interrupt Enable
            using GTDE = Field<8, 1>;    // Global Time Discontinuity Interrupt Enable
            using GTEE = Field<9, 1>;    // Global Time Error Interrupt Enable
            using TXUE = Field<10, 1>;    // Tx Count Underflow Interrupt Enable
            using TXOE = Field<11, 1>;    // Tx Count Overflow Interrupt Enable
            using SE1E = Field<12, 1>;    // Scheduling Error 1 Interrupt Enable
            using SE2E = Field<13, 1>;    // Scheduling Error 2 Interrupt Enable
            using ELCE = Field<14, 1>;    // Change Error Level Interrupt Enable
            using IWTGE = Field<15, 1>;    // Initialization Watch Trigger Interrupt Enable
            using WTE = Field<16, 1>;    // Watch Trigger Interrupt Enable
            using AWE = Field<17, 1>;    // Application Watchdog Interrupt Enable
            using CERE = Field<18, 1>;    // Configuration Error Interrupt Enable
        };

        // FDCAN TT Interrupt Line Select Register
        struct FDCAN_TTILS : public Register<0x4000a128> {
            using SBCL = Field<0, 1>;    // Start of Basic Cycle Interrupt Line
            using SMCL = Field<1, 1>;    // Start of Matrix Cycle Interrupt Line
            using CSML = Field<2, 1>;    // Change of Synchronization Mode Interrupt Line
            using SOGL = Field<3, 1>;    // Start of Gap Interrupt Line
            using RTMIL = Field<4, 1>;    // Register Time Mark Interrupt Line
            using TTMIL = Field<5, 1>;    // Trigger Time Mark Event Internal Interrupt Line
            using SWEL = Field<6, 1>;    // Stop Watch Event Interrupt Line
            using GTWL = Field<7, 1>;    // Global Time Wrap Interrupt Line
            using GTDL = Field<8, 1>;    // Global Time Discontinuity Interrupt Line
            using GTEL = Field<9, 1>;    // Global Time Error Interrupt Line
            using TXUL = Field<10, 1>;    // Tx Count Underflow Interrupt Line
            using TXOL = Field<11, 1>;    // Tx Count Overflow Interrupt Line
            using SE1L = Field<12, 1>;    // Scheduling Error 1 Interrupt Line
            using SE2L = Field<13, 1>;    // Scheduling Error 2 Interrupt Line
            using ELCL = Field<14, 1>;    // Change Error Level Interrupt Line
            using IWTGL = Field<15, 1>;    // Initialization Watch Trigger Interrupt Line
            using WTL = Field<16, 1>;    // Watch Trigger Interrupt Line
            using AWL = Field<17, 1>;    // Application Watchdog Interrupt Line
            using CERL = Field<18, 1>;    // Configuration Error Interrupt Line
        };

        // FDCAN TT Operation Status Register
        struct FDCAN_TTOST : public Register<0x4000a12c> {
            using EL = Field<0, 2>;    // Error Level
            using MS = Field<2, 2>;    // Master State.
            using SYS = Field<4, 2>;    // Synchronization State
            using GTP = Field<6, 1>;    // Quality of Global Time Phase
            using QCS = Field<7, 1>;    // Quality of Clock Speed
            using RTO = Field<8, 8>;    // Reference Trigger Offset
            using WGTD = Field<22, 1>;    // Wait for Global Time Discontinuity
            using GFI = Field<23, 1>;    // Gap Finished Indicator.
            using TMP = Field<24, 3>;    // Time Master Priority
            using GSI = Field<27, 1>;    // Gap Started Indicator.
            using WFE = Field<28, 1>;    // Wait for Event
            using AWE = Field<29, 1>;    // Application Watchdog Event
            using WECS = Field<30, 1>;    // Wait for External Clock Synchronization
            using SPL = Field<31, 1>;    // Schedule Phase Lock
        };

        // FDCAN TUR Numerator Actual Register
        struct FDCAN_TURNA : public RegisterReadOnly<0x4000a130> {
            using NAV = Field<0, 18>;    // Numerator Actual Value
        };

        // FDCAN TT Local and Global Time Register
        struct FDCAN_TTLGT : public RegisterReadOnly<0x4000a134> {
            using LT = Field<0, 16>;    // Local Time
            using GT = Field<16, 16>;    // Global Time
        };

        // FDCAN TT Cycle Time and Count Register
        struct FDCAN_TTCTC : public RegisterReadOnly<0x4000a138> {
            using CT = Field<0, 16>;    // Cycle Time
            using CC = Field<16, 6>;    // Cycle Count
        };

        // FDCAN TT Capture Time Register
        struct FDCAN_TTCPT : public RegisterReadOnly<0x4000a13c> {
            using CT = Field<0, 6>;    // Cycle Count Value
            using SWV = Field<16, 16>;    // Stop Watch Value
        };

        // FDCAN TT Cycle Sync Mark Register
        struct FDCAN_TTCSM : public RegisterReadOnly<0x4000a140> {
            using CSM = Field<0, 16>;    // Cycle Sync Mark
        };

        // FDCAN TT Trigger Select Register
        struct FDCAN_TTTS : public Register<0x4000a300> {
            using SWTDEL = Field<0, 2>;    // Stop watch trigger input selection
            using EVTSEL = Field<4, 2>;    // Event trigger input selection
        };

    };

    // FDCAN1
    struct FDCAN2 {
        // FDCAN Core Release Register
        struct FDCAN_CREL : public RegisterReadOnly<0x4000a400> {
            using REL = Field<28, 4>;    // Core release
            using STEP = Field<24, 4>;    // Step of Core release
            using SUBSTEP = Field<20, 4>;    // Sub-step of Core release
            using YEAR = Field<16, 4>;    // Timestamp Year
            using MON = Field<8, 8>;    // Timestamp Month
            using DAY = Field<0, 8>;    // Timestamp Day
        };

        // FDCAN Core Release Register
        struct FDCAN_ENDN : public RegisterReadOnly<0x4000a404> {
            using ETV = Field<0, 32>;    // Endiannes Test Value
        };

        // FDCAN Data Bit Timing and Prescaler Register
        struct FDCAN_DBTP : public RegisterReadOnly<0x4000a40c> {
            using DSJW = Field<0, 4>;    // Synchronization Jump Width
            using DTSEG2 = Field<4, 4>;    // Data time segment after sample point
            using DTSEG1 = Field<8, 5>;    // Data time segment after sample point
            using DBRP = Field<16, 5>;    // Data BIt Rate Prescaler
            using TDC = Field<23, 1>;    // Transceiver Delay Compensation
        };

        // FDCAN Test Register
        struct FDCAN_TEST : public RegisterReadOnly<0x4000a410> {
            using LBCK = Field<4, 1>;    // Loop Back mode
            using TX = Field<5, 2>;    // Loop Back mode
            using RX = Field<7, 1>;    // Control of Transmit Pin
        };

        // FDCAN RAM Watchdog Register
        struct FDCAN_RWD : public RegisterReadOnly<0x4000a414> {
            using WDV = Field<8, 8>;    // Watchdog value
            using WDC = Field<0, 8>;    // Watchdog configuration
        };

        // FDCAN CC Control Register
        struct FDCAN_CCCR : public Register<0x4000a418> {
            using INIT = Field<0, 1>;    // Initialization
            using CCE = Field<1, 1>;    // Configuration Change Enable
            using ASM = Field<2, 1>;    // ASM Restricted Operation Mode
            using CSA = Field<3, 1>;    // Clock Stop Acknowledge
            using CSR = Field<4, 1>;    // Clock Stop Request
            using MON = Field<5, 1>;    // Bus Monitoring Mode
            using DAR = Field<6, 1>;    // Disable Automatic Retransmission
            using TEST = Field<7, 1>;    // Test Mode Enable
            using FDOE = Field<8, 1>;    // FD Operation Enable
            using BSE = Field<9, 1>;    // FDCAN Bit Rate Switching
            using PXHD = Field<12, 1>;    // Protocol Exception Handling Disable
            using EFBI = Field<13, 1>;    // Edge Filtering during Bus Integration
            using TXP = Field<14, 1>;    // TXP
            using NISO = Field<15, 1>;    // Non ISO Operation
        };

        // FDCAN Nominal Bit Timing and Prescaler Register
        struct FDCAN_NBTP : public Register<0x4000a41c> {
            using NSJW = Field<25, 7>;    // NSJW: Nominal (Re)Synchronization Jump Width
            using NBRP = Field<16, 9>;    // Bit Rate Prescaler
            using NTSEG1 = Field<8, 8>;    // Nominal Time segment before sample point
            using TSEG2 = Field<0, 7>;    // Nominal Time segment after sample point
        };

        // FDCAN Timestamp Counter Configuration Register
        struct FDCAN_TSCC : public Register<0x4000a420> {
            using TCP = Field<16, 4>;    // Timestamp Counter Prescaler
            using TSS = Field<0, 2>;    // Timestamp Select
        };

        // FDCAN Timestamp Counter Value Register
        struct FDCAN_TSCV : public Register<0x4000a424> {
            using TSC = Field<0, 16>;    // Timestamp Counter
        };

        // FDCAN Timeout Counter Configuration Register
        struct FDCAN_TOCC : public Register<0x4000a428> {
            using ETOC = Field<0, 1>;    // Enable Timeout Counter
            using TOS = Field<1, 2>;    // Timeout Select
            using TOP = Field<16, 16>;    // Timeout Period
        };

        // FDCAN Timeout Counter Value Register
        struct FDCAN_TOCV : public Register<0x4000a42c> {
            using TOC = Field<0, 16>;    // Timeout Counter
        };

        // FDCAN Error Counter Register
        struct FDCAN_ECR : public Register<0x4000a440> {
            using CEL = Field<16, 8>;    // AN Error Logging
            using RP = Field<15, 1>;    // Receive Error Passive
            using TREC = Field<8, 7>;    // Receive Error Counter
            using TEC = Field<0, 8>;    // Transmit Error Counter
        };

        // FDCAN Protocol Status Register
        struct FDCAN_PSR : public Register<0x4000a444> {
            using LEC = Field<0, 3>;    // Last Error Code
            using ACT = Field<3, 2>;    // Activity
            using EP = Field<5, 1>;    // Error Passive
            using EW = Field<6, 1>;    // Warning Status
            using BO = Field<7, 1>;    // Bus_Off Status
            using DLEC = Field<8, 3>;    // Data Last Error Code
            using RESI = Field<11, 1>;    // ESI flag of last received FDCAN Message
            using RBRS = Field<12, 1>;    // BRS flag of last received FDCAN Message
            using REDL = Field<13, 1>;    // Received FDCAN Message
            using PXE = Field<14, 1>;    // Protocol Exception Event
            using TDCV = Field<16, 7>;    // Transmitter Delay Compensation Value
        };

        // FDCAN Transmitter Delay Compensation Register
        struct FDCAN_TDCR : public RegisterReadOnly<0x4000a448> {
            using TDCF = Field<0, 7>;    // Transmitter Delay Compensation Filter Window Length
            using TDCO = Field<8, 7>;    // Transmitter Delay Compensation Offset
        };

        // FDCAN Interrupt Register
        struct FDCAN_IR : public RegisterReadOnly<0x4000a450> {
            using RF0N = Field<0, 1>;    // Rx FIFO 0 New Message
            using RF0W = Field<1, 1>;    // Rx FIFO 0 Full
            using RF0F = Field<2, 1>;    // Rx FIFO 0 Full
            using RF0L = Field<3, 1>;    // Rx FIFO 0 Message Lost
            using RF1N = Field<4, 1>;    // Rx FIFO 1 New Message
            using RF1W = Field<5, 1>;    // Rx FIFO 1 Watermark Reached
            using RF1F = Field<6, 1>;    // Rx FIFO 1 Watermark Reached
            using RF1L = Field<7, 1>;    // Rx FIFO 1 Message Lost
            using HPM = Field<8, 1>;    // High Priority Message
            using TC = Field<9, 1>;    // Transmission Completed
            using TCF = Field<10, 1>;    // Transmission Cancellation Finished
            using TEF = Field<11, 1>;    // Tx FIFO Empty
            using TEFN = Field<12, 1>;    // Tx Event FIFO New Entry
            using TEFW = Field<13, 1>;    // Tx Event FIFO Watermark Reached
            using TEFF = Field<14, 1>;    // Tx Event FIFO Full
            using TEFL = Field<15, 1>;    // Tx Event FIFO Element Lost
            using TSW = Field<16, 1>;    // Timestamp Wraparound
            using MRAF = Field<17, 1>;    // Message RAM Access Failure
            using TOO = Field<18, 1>;    // Timeout Occurred
            using DRX = Field<19, 1>;    // Message stored to Dedicated Rx Buffer
            using ELO = Field<22, 1>;    // Error Logging Overflow
            using EP = Field<23, 1>;    // Error Passive
            using EW = Field<24, 1>;    // Warning Status
            using BO = Field<25, 1>;    // Bus_Off Status
            using WDI = Field<26, 1>;    // Watchdog Interrupt
            using PEA = Field<27, 1>;    // Protocol Error in Arbitration Phase (Nominal Bit Time is used)
            using PED = Field<28, 1>;    // Protocol Error in Data Phase (Data Bit Time is used)
            using ARA = Field<29, 1>;    // Access to Reserved Address
        };

        // FDCAN Interrupt Enable Register
        struct FDCAN_IE : public RegisterReadOnly<0x4000a454> {
            using RF0NE = Field<0, 1>;    // Rx FIFO 0 New Message Enable
            using RF0WE = Field<1, 1>;    // Rx FIFO 0 Full Enable
            using RF0FE = Field<2, 1>;    // Rx FIFO 0 Full Enable
            using RF0LE = Field<3, 1>;    // Rx FIFO 0 Message Lost Enable
            using RF1NE = Field<4, 1>;    // Rx FIFO 1 New Message Enable
            using RF1WE = Field<5, 1>;    // Rx FIFO 1 Watermark Reached Enable
            using RF1FE = Field<6, 1>;    // Rx FIFO 1 Watermark Reached Enable
            using RF1LE = Field<7, 1>;    // Rx FIFO 1 Message Lost Enable
            using HPME = Field<8, 1>;    // High Priority Message Enable
            using TCE = Field<9, 1>;    // Transmission Completed Enable
            using TCFE = Field<10, 1>;    // Transmission Cancellation Finished Enable
            using TEFE = Field<11, 1>;    // Tx FIFO Empty Enable
            using TEFNE = Field<12, 1>;    // Tx Event FIFO New Entry Enable
            using TEFWE = Field<13, 1>;    // Tx Event FIFO Watermark Reached Enable
            using TEFFE = Field<14, 1>;    // Tx Event FIFO Full Enable
            using TEFLE = Field<15, 1>;    // Tx Event FIFO Element Lost Enable
            using TSWE = Field<16, 1>;    // Timestamp Wraparound Enable
            using MRAFE = Field<17, 1>;    // Message RAM Access Failure Enable
            using TOOE = Field<18, 1>;    // Timeout Occurred Enable
            using DRXE = Field<19, 1>;    // Message stored to Dedicated Rx Buffer Enable
            using BECE = Field<20, 1>;    // Bit Error Corrected Interrupt Enable
            using BEUE = Field<21, 1>;    // Bit Error Uncorrected Interrupt Enable
            using ELOE = Field<22, 1>;    // Error Logging Overflow Enable
            using EPE = Field<23, 1>;    // Error Passive Enable
            using EWE = Field<24, 1>;    // Warning Status Enable
            using BOE = Field<25, 1>;    // Bus_Off Status Enable
            using WDIE = Field<26, 1>;    // Watchdog Interrupt Enable
            using PEAE = Field<27, 1>;    // Protocol Error in Arbitration Phase Enable
            using PEDE = Field<28, 1>;    // Protocol Error in Data Phase Enable
            using ARAE = Field<29, 1>;    // Access to Reserved Address Enable
        };

        // FDCAN Interrupt Line Select Register
        struct FDCAN_ILS : public RegisterReadOnly<0x4000a458> {
            using RF0NL = Field<0, 1>;    // Rx FIFO 0 New Message Interrupt Line
            using RF0WL = Field<1, 1>;    // Rx FIFO 0 Watermark Reached Interrupt Line
            using RF0FL = Field<2, 1>;    // Rx FIFO 0 Full Interrupt Line
            using RF0LL = Field<3, 1>;    // Rx FIFO 0 Message Lost Interrupt Line
            using RF1NL = Field<4, 1>;    // Rx FIFO 1 New Message Interrupt Line
            using RF1WL = Field<5, 1>;    // Rx FIFO 1 Watermark Reached Interrupt Line
            using RF1FL = Field<6, 1>;    // Rx FIFO 1 Full Interrupt Line
            using RF1LL = Field<7, 1>;    // Rx FIFO 1 Message Lost Interrupt Line
            using HPML = Field<8, 1>;    // High Priority Message Interrupt Line
            using TCL = Field<9, 1>;    // Transmission Completed Interrupt Line
            using TCFL = Field<10, 1>;    // Transmission Cancellation Finished Interrupt Line
            using TEFL = Field<11, 1>;    // Tx FIFO Empty Interrupt Line
            using TEFNL = Field<12, 1>;    // Tx Event FIFO New Entry Interrupt Line
            using TEFWL = Field<13, 1>;    // Tx Event FIFO Watermark Reached Interrupt Line
            using TEFFL = Field<14, 1>;    // Tx Event FIFO Full Interrupt Line
            using TEFLL = Field<15, 1>;    // Tx Event FIFO Element Lost Interrupt Line
            using TSWL = Field<16, 1>;    // Timestamp Wraparound Interrupt Line
            using MRAFL = Field<17, 1>;    // Message RAM Access Failure Interrupt Line
            using TOOL = Field<18, 1>;    // Timeout Occurred Interrupt Line
            using DRXL = Field<19, 1>;    // Message stored to Dedicated Rx Buffer Interrupt Line
            using BECL = Field<20, 1>;    // Bit Error Corrected Interrupt Line
            using BEUL = Field<21, 1>;    // Bit Error Uncorrected Interrupt Line
            using ELOL = Field<22, 1>;    // Error Logging Overflow Interrupt Line
            using EPL = Field<23, 1>;    // Error Passive Interrupt Line
            using EWL = Field<24, 1>;    // Warning Status Interrupt Line
            using BOL = Field<25, 1>;    // Bus_Off Status
            using WDIL = Field<26, 1>;    // Watchdog Interrupt Line
            using PEAL = Field<27, 1>;    // Protocol Error in Arbitration Phase Line
            using PEDL = Field<28, 1>;    // Protocol Error in Data Phase Line
            using ARAL = Field<29, 1>;    // Access to Reserved Address Line
        };

        // FDCAN Interrupt Line Enable Register
        struct FDCAN_ILE : public Register<0x4000a45c> {
            using EINT0 = Field<0, 1>;    // Enable Interrupt Line 0
            using EINT1 = Field<1, 1>;    // Enable Interrupt Line 1
        };

        // FDCAN Global Filter Configuration Register
        struct FDCAN_GFC : public Register<0x4000a480> {
            using RRFE = Field<0, 1>;    // Reject Remote Frames Extended
            using RRFS = Field<1, 1>;    // Reject Remote Frames Standard
            using ANFE = Field<2, 2>;    // Accept Non-matching Frames Extended
            using ANFS = Field<4, 2>;    // Accept Non-matching Frames Standard
        };

        // FDCAN Standard ID Filter Configuration Register
        struct FDCAN_SIDFC : public Register<0x4000a484> {
            using FLSSA = Field<2, 14>;    // Filter List Standard Start Address
            using LSS = Field<16, 8>;    // List Size Standard
        };

        // FDCAN Extended ID Filter Configuration Register
        struct FDCAN_XIDFC : public Register<0x4000a488> {
            using FLESA = Field<2, 14>;    // Filter List Standard Start Address
            using LSE = Field<16, 8>;    // List Size Extended
        };

        // FDCAN Extended ID and Mask Register
        struct FDCAN_XIDAM : public Register<0x4000a490> {
            using EIDM = Field<0, 29>;    // Extended ID Mask
        };

        // FDCAN High Priority Message Status Register
        struct FDCAN_HPMS : public RegisterReadOnly<0x4000a494> {
            using BIDX = Field<0, 6>;    // Buffer Index
            using MSI = Field<6, 2>;    // Message Storage Indicator
            using FIDX = Field<8, 7>;    // Filter Index
            using FLST = Field<15, 1>;    // Filter List
        };

        // FDCAN New Data 1 Register
        struct FDCAN_NDAT1 : public RegisterReadOnly<0x4000a498> {
            using ND0 = Field<0, 1>;    // New data
            using ND1 = Field<1, 1>;    // New data
            using ND2 = Field<2, 1>;    // New data
            using ND3 = Field<3, 1>;    // New data
            using ND4 = Field<4, 1>;    // New data
            using ND5 = Field<5, 1>;    // New data
            using ND6 = Field<6, 1>;    // New data
            using ND7 = Field<7, 1>;    // New data
            using ND8 = Field<8, 1>;    // New data
            using ND9 = Field<9, 1>;    // New data
            using ND10 = Field<10, 1>;    // New data
            using ND11 = Field<11, 1>;    // New data
            using ND12 = Field<12, 1>;    // New data
            using ND13 = Field<13, 1>;    // New data
            using ND14 = Field<14, 1>;    // New data
            using ND15 = Field<15, 1>;    // New data
            using ND16 = Field<16, 1>;    // New data
            using ND17 = Field<17, 1>;    // New data
            using ND18 = Field<18, 1>;    // New data
            using ND19 = Field<19, 1>;    // New data
            using ND20 = Field<20, 1>;    // New data
            using ND21 = Field<21, 1>;    // New data
            using ND22 = Field<22, 1>;    // New data
            using ND23 = Field<23, 1>;    // New data
            using ND24 = Field<24, 1>;    // New data
            using ND25 = Field<25, 1>;    // New data
            using ND26 = Field<26, 1>;    // New data
            using ND27 = Field<27, 1>;    // New data
            using ND28 = Field<28, 1>;    // New data
            using ND29 = Field<29, 1>;    // New data
            using ND30 = Field<30, 1>;    // New data
            using ND31 = Field<31, 1>;    // New data
        };

        // FDCAN New Data 2 Register
        struct FDCAN_NDAT2 : public RegisterReadOnly<0x4000a49c> {
            using ND32 = Field<0, 1>;    // New data
            using ND33 = Field<1, 1>;    // New data
            using ND34 = Field<2, 1>;    // New data
            using ND35 = Field<3, 1>;    // New data
            using ND36 = Field<4, 1>;    // New data
            using ND37 = Field<5, 1>;    // New data
            using ND38 = Field<6, 1>;    // New data
            using ND39 = Field<7, 1>;    // New data
            using ND40 = Field<8, 1>;    // New data
            using ND41 = Field<9, 1>;    // New data
            using ND42 = Field<10, 1>;    // New data
            using ND43 = Field<11, 1>;    // New data
            using ND44 = Field<12, 1>;    // New data
            using ND45 = Field<13, 1>;    // New data
            using ND46 = Field<14, 1>;    // New data
            using ND47 = Field<15, 1>;    // New data
            using ND48 = Field<16, 1>;    // New data
            using ND49 = Field<17, 1>;    // New data
            using ND50 = Field<18, 1>;    // New data
            using ND51 = Field<19, 1>;    // New data
            using ND52 = Field<20, 1>;    // New data
            using ND53 = Field<21, 1>;    // New data
            using ND54 = Field<22, 1>;    // New data
            using ND55 = Field<23, 1>;    // New data
            using ND56 = Field<24, 1>;    // New data
            using ND57 = Field<25, 1>;    // New data
            using ND58 = Field<26, 1>;    // New data
            using ND59 = Field<27, 1>;    // New data
            using ND60 = Field<28, 1>;    // New data
            using ND61 = Field<29, 1>;    // New data
            using ND62 = Field<30, 1>;    // New data
            using ND63 = Field<31, 1>;    // New data
        };

        // FDCAN Rx FIFO 0 Configuration Register
        struct FDCAN_RXF0C : public Register<0x4000a4a0> {
            using F0SA = Field<2, 14>;    // Rx FIFO 0 Start Address
            using F0S = Field<16, 8>;    // Rx FIFO 0 Size
            using F0WM = Field<24, 8>;    // FIFO 0 Watermark
        };

        // FDCAN Rx FIFO 0 Status Register
        struct FDCAN_RXF0S : public Register<0x4000a4a4> {
            using F0FL = Field<0, 7>;    // Rx FIFO 0 Fill Level
            using F0G = Field<8, 6>;    // Rx FIFO 0 Get Index
            using F0P = Field<16, 6>;    // Rx FIFO 0 Put Index
            using F0F = Field<24, 1>;    // Rx FIFO 0 Full
            using RF0L = Field<25, 1>;    // Rx FIFO 0 Message Lost
        };

        // CAN Rx FIFO 0 Acknowledge Register
        struct FDCAN_RXF0A : public Register<0x4000a4a8> {
            using FA01 = Field<0, 6>;    // Rx FIFO 0 Acknowledge Index
        };

        // FDCAN Rx Buffer Configuration Register
        struct FDCAN_RXBC : public Register<0x4000a4ac> {
            using RBSA = Field<2, 14>;    // Rx Buffer Start Address
        };

        // FDCAN Rx FIFO 1 Configuration Register
        struct FDCAN_RXF1C : public Register<0x4000a4b0> {
            using F1SA = Field<2, 14>;    // Rx FIFO 1 Start Address
            using F1S = Field<16, 7>;    // Rx FIFO 1 Size
            using F1WM = Field<24, 7>;    // Rx FIFO 1 Watermark
        };

        // FDCAN Rx FIFO 1 Status Register
        struct FDCAN_RXF1S : public Register<0x4000a4b4> {
            using F1FL = Field<0, 7>;    // Rx FIFO 1 Fill Level
            using F1GI = Field<8, 7>;    // Rx FIFO 1 Get Index
            using F1PI = Field<16, 7>;    // Rx FIFO 1 Put Index
            using F1F = Field<24, 1>;    // Rx FIFO 1 Full
            using RF1L = Field<25, 1>;    // Rx FIFO 1 Message Lost
            using DMS = Field<30, 2>;    // Debug Message Status
        };

        // FDCAN Rx FIFO 1 Acknowledge Register
        struct FDCAN_RXF1A : public Register<0x4000a4b8> {
            using F1AI = Field<0, 6>;    // Rx FIFO 1 Acknowledge Index
        };

        // FDCAN Rx Buffer Element Size Configuration Register
        struct FDCAN_RXESC : public Register<0x4000a4bc> {
            using F0DS = Field<0, 3>;    // Rx FIFO 1 Data Field Size:
            using F1DS = Field<4, 3>;    // Rx FIFO 0 Data Field Size:
            using RBDS = Field<8, 3>;    // Rx Buffer Data Field Size:
        };

        // FDCAN Tx Buffer Configuration Register
        struct FDCAN_TXBC : public Register<0x4000a4c0> {
            using TBSA = Field<2, 14>;    // Tx Buffers Start Address
            using NDTB = Field<16, 6>;    // Number of Dedicated Transmit Buffers
            using TFQS = Field<24, 6>;    // Transmit FIFO/Queue Size
            using TFQM = Field<30, 1>;    // Tx FIFO/Queue Mode
        };

        // FDCAN Tx FIFO/Queue Status Register
        struct FDCAN_TXFQS : public RegisterReadOnly<0x4000a4c4> {
            using TFFL = Field<0, 6>;    // Tx FIFO Free Level
            using TFGI = Field<8, 5>;    // TFGI
            using TFQPI = Field<16, 5>;    // Tx FIFO/Queue Put Index
            using TFQF = Field<21, 1>;    // Tx FIFO/Queue Full
        };

        // FDCAN Tx Buffer Element Size Configuration Register
        struct FDCAN_TXESC : public Register<0x4000a4c8> {
            using TBDS = Field<0, 3>;    // Tx Buffer Data Field Size:
        };

        // FDCAN Tx Buffer Request Pending Register
        struct FDCAN_TXBRP : public RegisterReadOnly<0x4000a4cc> {
            using TRP = Field<0, 32>;    // Transmission Request Pending
        };

        // FDCAN Tx Buffer Add Request Register
        struct FDCAN_TXBAR : public Register<0x4000a4d0> {
            using AR = Field<0, 32>;    // Add Request
        };

        // FDCAN Tx Buffer Cancellation Request Register
        struct FDCAN_TXBCR : public Register<0x4000a4d4> {
            using CR = Field<0, 32>;    // Cancellation Request
        };

        // FDCAN Tx Buffer Transmission Occurred Register
        struct FDCAN_TXBTO : public Register<0x4000a4d8> {
            using TO = Field<0, 32>;    // Transmission Occurred.
        };

        // FDCAN Tx Buffer Cancellation Finished Register
        struct FDCAN_TXBCF : public RegisterReadOnly<0x4000a4dc> {
            using CF = Field<0, 32>;    // Cancellation Finished
        };

        // FDCAN Tx Buffer Transmission Interrupt Enable Register
        struct FDCAN_TXBTIE : public Register<0x4000a4e0> {
            using TIE = Field<0, 32>;    // Transmission Interrupt Enable
        };

        // FDCAN Tx Buffer Cancellation Finished Interrupt Enable Register
        struct FDCAN_TXBCIE : public Register<0x4000a4e4> {
            using CF = Field<0, 32>;    // Cancellation Finished Interrupt Enable
        };

        // FDCAN Tx Event FIFO Configuration Register
        struct FDCAN_TXEFC : public Register<0x4000a4f0> {
            using EFSA = Field<2, 14>;    // Event FIFO Start Address
            using EFS = Field<16, 6>;    // Event FIFO Size
            using EFWM = Field<24, 6>;    // Event FIFO Watermark
        };

        // FDCAN Tx Event FIFO Status Register
        struct FDCAN_TXEFS : public Register<0x4000a4f4> {
            using EFFL = Field<0, 6>;    // Event FIFO Fill Level
            using EFGI = Field<8, 5>;    // Event FIFO Get Index.
            using EFF = Field<24, 1>;    // Event FIFO Full.
            using TEFL = Field<25, 1>;    // Tx Event FIFO Element Lost.
        };

        // FDCAN Tx Event FIFO Acknowledge Register
        struct FDCAN_TXEFA : public Register<0x4000a4f8> {
            using EFAI = Field<0, 5>;    // Event FIFO Acknowledge Index
        };

        // FDCAN TT Trigger Memory Configuration Register
        struct FDCAN_TTTMC : public Register<0x4000a500> {
            using TMSA = Field<2, 14>;    // Trigger Memory Start Address
            using TME = Field<16, 7>;    // Trigger Memory Elements
        };

        // FDCAN TT Reference Message Configuration Register
        struct FDCAN_TTRMC : public Register<0x4000a504> {
            using RID = Field<0, 29>;    // Reference Identifier.
            using XTD = Field<30, 1>;    // Extended Identifier
            using RMPS = Field<31, 1>;    // Reference Message Payload Select
        };

        // FDCAN TT Operation Configuration Register
        struct FDCAN_TTOCF : public Register<0x4000a508> {
            using OM = Field<0, 2>;    // Operation Mode
            using GEN = Field<3, 1>;    // Gap Enable
            using TM = Field<4, 1>;    // Time Master
            using LDSDL = Field<5, 3>;    // LD of Synchronization Deviation Limit
            using IRTO = Field<8, 7>;    // Initial Reference Trigger Offset
            using EECS = Field<15, 1>;    // Enable External Clock Synchronization
            using AWL = Field<16, 8>;    // Application Watchdog Limit
            using EGTF = Field<24, 1>;    // Enable Global Time Filtering
            using ECC = Field<25, 1>;    // Enable Clock Calibration
            using EVTP = Field<26, 1>;    // Event Trigger Polarity
        };

        // FDCAN TT Matrix Limits Register
        struct FDCAN_TTMLM : public Register<0x4000a50c> {
            using CCM = Field<0, 6>;    // Cycle Count Max
            using CSS = Field<6, 2>;    // Cycle Start Synchronization
            using TXEW = Field<8, 4>;    // Tx Enable Window
            using ENTT = Field<16, 12>;    // Expected Number of Tx Triggers
        };

        // FDCAN TUR Configuration Register
        struct FDCAN_TURCF : public Register<0x4000a510> {
            using NCL = Field<0, 16>;    // Numerator Configuration Low.
            using DC = Field<16, 14>;    // Denominator Configuration.
            using ELT = Field<31, 1>;    // Enable Local Time
        };

        // FDCAN TT Operation Control Register
        struct FDCAN_TTOCN : public Register<0x4000a514> {
            using SGT = Field<0, 1>;    // Set Global time
            using ECS = Field<1, 1>;    // External Clock Synchronization
            using SWP = Field<2, 1>;    // Stop Watch Polarity
            using SWS = Field<3, 2>;    // Stop Watch Source.
            using RTIE = Field<5, 1>;    // Register Time Mark Interrupt Pulse Enable
            using TMC = Field<6, 2>;    // Register Time Mark Compare
            using TTIE = Field<8, 1>;    // Trigger Time Mark Interrupt Pulse Enable
            using GCS = Field<9, 1>;    // Gap Control Select
            using FGP = Field<10, 1>;    // Finish Gap.
            using TMG = Field<11, 1>;    // Time Mark Gap
            using NIG = Field<12, 1>;    // Next is Gap
            using ESCN = Field<13, 1>;    // External Synchronization Control
            using LCKC = Field<15, 1>;    // TT Operation Control Register Locked
        };

        // FDCAN TT Global Time Preset Register
        struct CAN_TTGTP : public Register<0x4000a518> {
            using NCL = Field<0, 16>;    // Time Preset
            using CTP = Field<16, 16>;    // Cycle Time Target Phase
        };

        // FDCAN TT Time Mark Register
        struct FDCAN_TTTMK : public Register<0x4000a51c> {
            using TM = Field<0, 16>;    // Time Mark
            using TICC = Field<16, 7>;    // Time Mark Cycle Code
            using LCKM = Field<31, 1>;    // TT Time Mark Register Locked
        };

        // FDCAN TT Interrupt Register
        struct FDCAN_TTIR : public Register<0x4000a520> {
            using SBC = Field<0, 1>;    // Start of Basic Cycle
            using SMC = Field<1, 1>;    // Start of Matrix Cycle
            using CSM = Field<2, 1>;    // Change of Synchronization Mode
            using SOG = Field<3, 1>;    // Start of Gap
            using RTMI = Field<4, 1>;    // Register Time Mark Interrupt.
            using TTMI = Field<5, 1>;    // Trigger Time Mark Event Internal
            using SWE = Field<6, 1>;    // Stop Watch Event
            using GTW = Field<7, 1>;    // Global Time Wrap
            using GTD = Field<8, 1>;    // Global Time Discontinuity
            using GTE = Field<9, 1>;    // Global Time Error
            using TXU = Field<10, 1>;    // Tx Count Underflow
            using TXO = Field<11, 1>;    // Tx Count Overflow
            using SE1 = Field<12, 1>;    // Scheduling Error 1
            using SE2 = Field<13, 1>;    // Scheduling Error 2
            using ELC = Field<14, 1>;    // Error Level Changed.
            using IWTG = Field<15, 1>;    // Initialization Watch Trigger
            using WT = Field<16, 1>;    // Watch Trigger
            using AW = Field<17, 1>;    // Application Watchdog
            using CER = Field<18, 1>;    // Configuration Error
        };

        // FDCAN TT Interrupt Enable Register
        struct FDCAN_TTIE : public Register<0x4000a524> {
            using SBCE = Field<0, 1>;    // Start of Basic Cycle Interrupt Enable
            using SMCE = Field<1, 1>;    // Start of Matrix Cycle Interrupt Enable
            using CSME = Field<2, 1>;    // Change of Synchronization Mode Interrupt Enable
            using SOGE = Field<3, 1>;    // Start of Gap Interrupt Enable
            using RTMIE = Field<4, 1>;    // Register Time Mark Interrupt Enable
            using TTMIE = Field<5, 1>;    // Trigger Time Mark Event Internal Interrupt Enable
            using SWEE = Field<6, 1>;    // Stop Watch Event Interrupt Enable
            using GTWE = Field<7, 1>;    // Global Time Wrap Interrupt Enable
            using GTDE = Field<8, 1>;    // Global Time Discontinuity Interrupt Enable
            using GTEE = Field<9, 1>;    // Global Time Error Interrupt Enable
            using TXUE = Field<10, 1>;    // Tx Count Underflow Interrupt Enable
            using TXOE = Field<11, 1>;    // Tx Count Overflow Interrupt Enable
            using SE1E = Field<12, 1>;    // Scheduling Error 1 Interrupt Enable
            using SE2E = Field<13, 1>;    // Scheduling Error 2 Interrupt Enable
            using ELCE = Field<14, 1>;    // Change Error Level Interrupt Enable
            using IWTGE = Field<15, 1>;    // Initialization Watch Trigger Interrupt Enable
            using WTE = Field<16, 1>;    // Watch Trigger Interrupt Enable
            using AWE = Field<17, 1>;    // Application Watchdog Interrupt Enable
            using CERE = Field<18, 1>;    // Configuration Error Interrupt Enable
        };

        // FDCAN TT Interrupt Line Select Register
        struct FDCAN_TTILS : public Register<0x4000a528> {
            using SBCL = Field<0, 1>;    // Start of Basic Cycle Interrupt Line
            using SMCL = Field<1, 1>;    // Start of Matrix Cycle Interrupt Line
            using CSML = Field<2, 1>;    // Change of Synchronization Mode Interrupt Line
            using SOGL = Field<3, 1>;    // Start of Gap Interrupt Line
            using RTMIL = Field<4, 1>;    // Register Time Mark Interrupt Line
            using TTMIL = Field<5, 1>;    // Trigger Time Mark Event Internal Interrupt Line
            using SWEL = Field<6, 1>;    // Stop Watch Event Interrupt Line
            using GTWL = Field<7, 1>;    // Global Time Wrap Interrupt Line
            using GTDL = Field<8, 1>;    // Global Time Discontinuity Interrupt Line
            using GTEL = Field<9, 1>;    // Global Time Error Interrupt Line
            using TXUL = Field<10, 1>;    // Tx Count Underflow Interrupt Line
            using TXOL = Field<11, 1>;    // Tx Count Overflow Interrupt Line
            using SE1L = Field<12, 1>;    // Scheduling Error 1 Interrupt Line
            using SE2L = Field<13, 1>;    // Scheduling Error 2 Interrupt Line
            using ELCL = Field<14, 1>;    // Change Error Level Interrupt Line
            using IWTGL = Field<15, 1>;    // Initialization Watch Trigger Interrupt Line
            using WTL = Field<16, 1>;    // Watch Trigger Interrupt Line
            using AWL = Field<17, 1>;    // Application Watchdog Interrupt Line
            using CERL = Field<18, 1>;    // Configuration Error Interrupt Line
        };

        // FDCAN TT Operation Status Register
        struct FDCAN_TTOST : public Register<0x4000a52c> {
            using EL = Field<0, 2>;    // Error Level
            using MS = Field<2, 2>;    // Master State.
            using SYS = Field<4, 2>;    // Synchronization State
            using GTP = Field<6, 1>;    // Quality of Global Time Phase
            using QCS = Field<7, 1>;    // Quality of Clock Speed
            using RTO = Field<8, 8>;    // Reference Trigger Offset
            using WGTD = Field<22, 1>;    // Wait for Global Time Discontinuity
            using GFI = Field<23, 1>;    // Gap Finished Indicator.
            using TMP = Field<24, 3>;    // Time Master Priority
            using GSI = Field<27, 1>;    // Gap Started Indicator.
            using WFE = Field<28, 1>;    // Wait for Event
            using AWE = Field<29, 1>;    // Application Watchdog Event
            using WECS = Field<30, 1>;    // Wait for External Clock Synchronization
            using SPL = Field<31, 1>;    // Schedule Phase Lock
        };

        // FDCAN TUR Numerator Actual Register
        struct FDCAN_TURNA : public RegisterReadOnly<0x4000a530> {
            using NAV = Field<0, 18>;    // Numerator Actual Value
        };

        // FDCAN TT Local and Global Time Register
        struct FDCAN_TTLGT : public RegisterReadOnly<0x4000a534> {
            using LT = Field<0, 16>;    // Local Time
            using GT = Field<16, 16>;    // Global Time
        };

        // FDCAN TT Cycle Time and Count Register
        struct FDCAN_TTCTC : public RegisterReadOnly<0x4000a538> {
            using CT = Field<0, 16>;    // Cycle Time
            using CC = Field<16, 6>;    // Cycle Count
        };

        // FDCAN TT Capture Time Register
        struct FDCAN_TTCPT : public RegisterReadOnly<0x4000a53c> {
            using CT = Field<0, 6>;    // Cycle Count Value
            using SWV = Field<16, 16>;    // Stop Watch Value
        };

        // FDCAN TT Cycle Sync Mark Register
        struct FDCAN_TTCSM : public RegisterReadOnly<0x4000a540> {
            using CSM = Field<0, 16>;    // Cycle Sync Mark
        };

        // FDCAN TT Trigger Select Register
        struct FDCAN_TTTS : public Register<0x4000a700> {
            using SWTDEL = Field<0, 2>;    // Stop watch trigger input selection
            using EVTSEL = Field<4, 2>;    // Event trigger input selection
        };

    };

    // CCU registers
    struct CAN_CCU {
        // Clock Calibration Unit Core Release Register
        struct CREL : public Register<0x4000a800> {
            using DAY = Field<0, 8>;    // Time Stamp Day
            using MON = Field<8, 8>;    // Time Stamp Month
            using YEAR = Field<16, 4>;    // Time Stamp Year
            using SUBSTEP = Field<20, 4>;    // Sub-step of Core Release
            using STEP = Field<24, 4>;    // Step of Core Release
            using REL = Field<28, 4>;    // Core Release
        };

        // Calibration Configuration Register
        struct CCFG : public Register<0x4000a804> {
            using TQBT = Field<0, 5>;    // Time Quanta per Bit Time
            using BCC = Field<6, 1>;    // Bypass Clock Calibration
            using CFL = Field<7, 1>;    // Calibration Field Length
            using OCPM = Field<8, 8>;    // Oscillator Clock Periods Minimum
            using CDIV = Field<16, 4>;    // Clock Divider
            using SWR = Field<31, 1>;    // Software Reset
        };

        // Calibration Status Register
        struct CSTAT : public Register<0x4000a808> {
            using OCPC = Field<0, 18>;    // Oscillator Clock Period Counter
            using TQC = Field<18, 11>;    // Time Quanta Counter
            using CALS = Field<30, 2>;    // Calibration State
        };

        // Calibration Watchdog Register
        struct CWD : public Register<0x4000a80c> {
            using WDC = Field<0, 16>;    // WDC
            using WDV = Field<16, 16>;    // WDV
        };

        // Clock Calibration Unit Interrupt Register
        struct IR : public Register<0x4000a810> {
            using CWE = Field<0, 1>;    // Calibration Watchdog Event
            using CSC = Field<1, 1>;    // Calibration State Changed
        };

        // Clock Calibration Unit Interrupt Enable Register
        struct IE : public Register<0x4000a814> {
            using CWEE = Field<0, 1>;    // Calibration Watchdog Event Enable
            using CSCE = Field<1, 1>;    // Calibration State Changed Enable
        };

    };

    // Management data input/output slave
    struct MDIOS {
        // MDIOS configuration register
        struct CR : public Register<0x40009400> {
            using EN = Field<0, 1>;    // Peripheral enable
            using WRIE = Field<1, 1>;    // Register write interrupt enable
            using RDIE = Field<2, 1>;    // Register Read Interrupt Enable
            using EIE = Field<3, 1>;    // Error interrupt enable
            using DPC = Field<7, 1>;    // Disable Preamble Check
            using PORT_ADDRESS = Field<8, 5>;    // Slaves's address
        };

        // MDIOS write flag register
        struct WRFR : public RegisterReadOnly<0x40009404> {
            using WRF = Field<0, 32>;    // Write flags for MDIO registers 0 to 31
        };

        // MDIOS clear write flag register
        struct CWRFR : public Register<0x40009408> {
            using CWRF = Field<0, 32>;    // Clear the write flag
        };

        // MDIOS read flag register
        struct RDFR : public RegisterReadOnly<0x4000940c> {
            using RDF = Field<0, 32>;    // Read flags for MDIO registers 0 to 31
        };

        // MDIOS clear read flag register
        struct CRDFR : public Register<0x40009410> {
            using CRDF = Field<0, 32>;    // Clear the read flag
        };

        // MDIOS status register
        struct SR : public RegisterReadOnly<0x40009414> {
            using PERF = Field<0, 1>;    // Preamble error flag
            using SERF = Field<1, 1>;    // Start error flag
            using TERF = Field<2, 1>;    // Turnaround error flag
        };

        // MDIOS clear flag register
        struct CLRFR : public Register<0x40009418> {
            using CPERF = Field<0, 1>;    // Clear the preamble error flag
            using CSERF = Field<1, 1>;    // Clear the start error flag
            using CTERF = Field<2, 1>;    // Clear the turnaround error flag
        };

        // MDIOS input data register 0
        struct DINR0 : public RegisterReadOnly<0x4000941c> {
            using DIN0 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 1
        struct DINR1 : public RegisterReadOnly<0x40009420> {
            using DIN1 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 2
        struct DINR2 : public RegisterReadOnly<0x40009424> {
            using DIN2 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 3
        struct DINR3 : public RegisterReadOnly<0x40009428> {
            using DIN3 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 4
        struct DINR4 : public RegisterReadOnly<0x4000942c> {
            using DIN4 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 5
        struct DINR5 : public RegisterReadOnly<0x40009430> {
            using DIN5 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 6
        struct DINR6 : public RegisterReadOnly<0x40009434> {
            using DIN6 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 7
        struct DINR7 : public RegisterReadOnly<0x40009438> {
            using DIN7 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 8
        struct DINR8 : public RegisterReadOnly<0x4000943c> {
            using DIN8 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 9
        struct DINR9 : public RegisterReadOnly<0x40009440> {
            using DIN9 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 10
        struct DINR10 : public RegisterReadOnly<0x40009444> {
            using DIN10 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 11
        struct DINR11 : public RegisterReadOnly<0x40009448> {
            using DIN11 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 12
        struct DINR12 : public RegisterReadOnly<0x4000944c> {
            using DIN12 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 13
        struct DINR13 : public RegisterReadOnly<0x40009450> {
            using DIN13 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 14
        struct DINR14 : public RegisterReadOnly<0x40009454> {
            using DIN14 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 15
        struct DINR15 : public RegisterReadOnly<0x40009458> {
            using DIN15 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 16
        struct DINR16 : public RegisterReadOnly<0x4000945c> {
            using DIN16 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 17
        struct DINR17 : public RegisterReadOnly<0x40009460> {
            using DIN17 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 18
        struct DINR18 : public RegisterReadOnly<0x40009464> {
            using DIN18 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 19
        struct DINR19 : public RegisterReadOnly<0x40009468> {
            using DIN19 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 20
        struct DINR20 : public RegisterReadOnly<0x4000946c> {
            using DIN20 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 21
        struct DINR21 : public RegisterReadOnly<0x40009470> {
            using DIN21 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 22
        struct DINR22 : public RegisterReadOnly<0x40009474> {
            using DIN22 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 23
        struct DINR23 : public RegisterReadOnly<0x40009478> {
            using DIN23 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 24
        struct DINR24 : public RegisterReadOnly<0x4000947c> {
            using DIN24 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 25
        struct DINR25 : public RegisterReadOnly<0x40009480> {
            using DIN25 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 26
        struct DINR26 : public RegisterReadOnly<0x40009484> {
            using DIN26 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 27
        struct DINR27 : public RegisterReadOnly<0x40009488> {
            using DIN27 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 28
        struct DINR28 : public RegisterReadOnly<0x4000948c> {
            using DIN28 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 29
        struct DINR29 : public RegisterReadOnly<0x40009490> {
            using DIN29 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 30
        struct DINR30 : public RegisterReadOnly<0x40009494> {
            using DIN30 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS input data register 31
        struct DINR31 : public RegisterReadOnly<0x40009498> {
            using DIN31 = Field<0, 16>;    // Input data received from MDIO Master during write frames
        };

        // MDIOS output data register 0
        struct DOUTR0 : public Register<0x4000949c> {
            using DOUT0 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 1
        struct DOUTR1 : public Register<0x400094a0> {
            using DOUT1 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 2
        struct DOUTR2 : public Register<0x400094a4> {
            using DOUT2 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 3
        struct DOUTR3 : public Register<0x400094a8> {
            using DOUT3 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 4
        struct DOUTR4 : public Register<0x400094ac> {
            using DOUT4 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 5
        struct DOUTR5 : public Register<0x400094b0> {
            using DOUT5 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 6
        struct DOUTR6 : public Register<0x400094b4> {
            using DOUT6 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 7
        struct DOUTR7 : public Register<0x400094b8> {
            using DOUT7 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 8
        struct DOUTR8 : public Register<0x400094bc> {
            using DOUT8 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 9
        struct DOUTR9 : public Register<0x400094c0> {
            using DOUT9 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 10
        struct DOUTR10 : public Register<0x400094c4> {
            using DOUT10 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 11
        struct DOUTR11 : public Register<0x400094c8> {
            using DOUT11 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 12
        struct DOUTR12 : public Register<0x400094cc> {
            using DOUT12 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 13
        struct DOUTR13 : public Register<0x400094d0> {
            using DOUT13 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 14
        struct DOUTR14 : public Register<0x400094d4> {
            using DOUT14 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 15
        struct DOUTR15 : public Register<0x400094d8> {
            using DOUT15 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 16
        struct DOUTR16 : public Register<0x400094dc> {
            using DOUT16 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 17
        struct DOUTR17 : public Register<0x400094e0> {
            using DOUT17 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 18
        struct DOUTR18 : public Register<0x400094e4> {
            using DOUT18 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 19
        struct DOUTR19 : public Register<0x400094e8> {
            using DOUT19 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 20
        struct DOUTR20 : public Register<0x400094ec> {
            using DOUT20 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 21
        struct DOUTR21 : public Register<0x400094f0> {
            using DOUT21 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 22
        struct DOUTR22 : public Register<0x400094f4> {
            using DOUT22 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 23
        struct DOUTR23 : public Register<0x400094f8> {
            using DOUT23 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 24
        struct DOUTR24 : public Register<0x400094fc> {
            using DOUT24 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 25
        struct DOUTR25 : public Register<0x40009500> {
            using DOUT25 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 26
        struct DOUTR26 : public Register<0x40009504> {
            using DOUT26 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 27
        struct DOUTR27 : public Register<0x40009508> {
            using DOUT27 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 28
        struct DOUTR28 : public Register<0x4000950c> {
            using DOUT28 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 29
        struct DOUTR29 : public Register<0x40009510> {
            using DOUT29 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 30
        struct DOUTR30 : public Register<0x40009514> {
            using DOUT30 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

        // MDIOS output data register 31
        struct DOUTR31 : public Register<0x40009518> {
            using DOUT31 = Field<0, 16>;    // Output data sent to MDIO Master during read frames
        };

    };

    // Operational amplifiers
    struct OPAMP {
        // OPAMP1 control/status register
        struct OPAMP1_CSR : public Register<0x40009000> {
            using OPAEN = Field<0, 1>;    // Operational amplifier Enable
            using FORCE_VP = Field<1, 1>;    // Force internal reference on VP (reserved for test
            using VP_SEL = Field<2, 2>;    // Operational amplifier PGA mode
            using VM_SEL = Field<5, 2>;    // Inverting input selection
            using OPAHSM = Field<8, 1>;    // Operational amplifier high-speed mode
            using CALON = Field<11, 1>;    // Calibration mode enabled
            using CALSEL = Field<12, 2>;    // Calibration selection
            using PGA_GAIN = Field<14, 4>;    // allows to switch from AOP offset trimmed values to AOP offset
            using USERTRIM = Field<18, 1>;    // User trimming enable
            using TSTREF = Field<29, 1>;    // OPAMP calibration reference voltage output control (reserved for test)
            using CALOUT = Field<30, 1>;    // Operational amplifier calibration output
        };

        // OPAMP1 offset trimming register in normal mode
        struct OPAMP1_OTR : public Register<0x40009004> {
            using TRIMOFFSETN = Field<0, 5>;    // Trim for NMOS differential pairs
            using TRIMOFFSETP = Field<8, 5>;    // Trim for PMOS differential pairs
        };

        // OPAMP1 offset trimming register in low-power mode
        struct OPAMP1_HSOTR : public Register<0x40009008> {
            using TRIMLPOFFSETN = Field<0, 5>;    // Trim for NMOS differential pairs
            using TRIMLPOFFSETP = Field<8, 5>;    // Trim for PMOS differential pairs
        };

        // OPAMP2 control/status register
        struct OPAMP2_CSR : public Register<0x40009010> {
            using OPAEN = Field<0, 1>;    // Operational amplifier Enable
            using FORCE_VP = Field<1, 1>;    // Force internal reference on VP (reserved for test)
            using VM_SEL = Field<5, 2>;    // Inverting input selection
            using OPAHSM = Field<8, 1>;    // Operational amplifier high-speed mode
            using CALON = Field<11, 1>;    // Calibration mode enabled
            using CALSEL = Field<12, 2>;    // Calibration selection
            using PGA_GAIN = Field<14, 4>;    // Operational amplifier Programmable amplifier gain value
            using USERTRIM = Field<18, 1>;    // User trimming enable
            using TSTREF = Field<29, 1>;    // OPAMP calibration reference voltage output control (reserved for test)
            using CALOUT = Field<30, 1>;    // Operational amplifier calibration output
        };

        // OPAMP2 offset trimming register in normal mode
        struct OPAMP2_OTR : public Register<0x40009014> {
            using TRIMOFFSETN = Field<0, 5>;    // Trim for NMOS differential pairs
            using TRIMOFFSETP = Field<8, 5>;    // Trim for PMOS differential pairs
        };

        // OPAMP2 offset trimming register in low-power mode
        struct OPAMP2_HSOTR : public Register<0x40009018> {
            using TRIMLPOFFSETN = Field<0, 5>;    // Trim for NMOS differential pairs
            using TRIMLPOFFSETP = Field<8, 5>;    // Trim for PMOS differential pairs
        };

    };

    // Single Wire Protocol Master Interface
    struct SWPMI {
        // SWPMI Configuration/Control register
        struct CR : public Register<0x40008800> {
            using RXDMA = Field<0, 1>;    // Reception DMA enable
            using TXDMA = Field<1, 1>;    // Transmission DMA enable
            using RXMODE = Field<2, 1>;    // Reception buffering mode
            using TXMODE = Field<3, 1>;    // Transmission buffering mode
            using LPBK = Field<4, 1>;    // Loopback mode enable
            using SWPACT = Field<5, 1>;    // Single wire protocol master interface activate
            using DEACT = Field<10, 1>;    // Single wire protocol master interface deactivate
            using SWPTEN = Field<11, 1>;    // Single wire protocol master transceiver enable
        };

        // SWPMI Bitrate register
        struct BRR : public Register<0x40008804> {
            using BR = Field<0, 8>;    // Bitrate prescaler
        };

        // SWPMI Interrupt and Status register
        struct ISR : public RegisterReadOnly<0x4000880c> {
            using RXBFF = Field<0, 1>;    // Receive buffer full flag
            using TXBEF = Field<1, 1>;    // Transmit buffer empty flag
            using RXBERF = Field<2, 1>;    // Receive CRC error flag
            using RXOVRF = Field<3, 1>;    // Receive overrun error flag
            using TXUNRF = Field<4, 1>;    // Transmit underrun error flag
            using RXNE = Field<5, 1>;    // Receive data register not empty
            using TXE = Field<6, 1>;    // Transmit data register empty
            using TCF = Field<7, 1>;    // Transfer complete flag
            using SRF = Field<8, 1>;    // Slave resume flag
            using SUSP = Field<9, 1>;    // SUSPEND flag
            using DEACTF = Field<10, 1>;    // DEACTIVATED flag
            using RDYF = Field<11, 1>;    // transceiver ready flag
        };

        // SWPMI Interrupt Flag Clear register
        struct ICR : public RegisterWriteOnly<0x40008810> {
            using CRXBFF = Field<0, 1>;    // Clear receive buffer full flag
            using CTXBEF = Field<1, 1>;    // Clear transmit buffer empty flag
            using CRXBERF = Field<2, 1>;    // Clear receive CRC error flag
            using CRXOVRF = Field<3, 1>;    // Clear receive overrun error flag
            using CTXUNRF = Field<4, 1>;    // Clear transmit underrun error flag
            using CTCF = Field<7, 1>;    // Clear transfer complete flag
            using CSRF = Field<8, 1>;    // Clear slave resume flag
            using CRDYF = Field<11, 1>;    // Clear transceiver ready flag
        };

        // SWPMI Interrupt Enable register
        struct IER : public Register<0x40008814> {
            using RXBFIE = Field<0, 1>;    // Receive buffer full interrupt enable
            using TXBEIE = Field<1, 1>;    // Transmit buffer empty interrupt enable
            using RXBERIE = Field<2, 1>;    // Receive CRC error interrupt enable
            using RXOVRIE = Field<3, 1>;    // Receive overrun error interrupt enable
            using TXUNRIE = Field<4, 1>;    // Transmit underrun error interrupt enable
            using RIE = Field<5, 1>;    // Receive interrupt enable
            using TIE = Field<6, 1>;    // Transmit interrupt enable
            using TCIE = Field<7, 1>;    // Transmit complete interrupt enable
            using SRIE = Field<8, 1>;    // Slave resume interrupt enable
            using RDYIE = Field<11, 1>;    // Transceiver ready interrupt enable
        };

        // SWPMI Receive Frame Length register
        struct RFL : public RegisterReadOnly<0x40008818> {
            using Field = Field<0, 5>;    // Receive frame length
        };

        // SWPMI Transmit data register
        struct TDR : public RegisterWriteOnly<0x4000881c> {
            using TD = Field<0, 32>;    // Transmit data
        };

        // SWPMI Receive data register
        struct RDR : public RegisterReadOnly<0x40008820> {
            using RD = Field<0, 32>;    // received data
        };

        // SWPMI Option register
        struct OR : public Register<0x40008824> {
            using SWP_TBYP = Field<0, 1>;    // SWP transceiver bypass
            using SWP_CLASS = Field<1, 1>;    // SWP class selection
        };

    };

    // General purpose timers
    struct TIM2 {
        // control register 1
        struct CR1 : public Register<0x40000000> {
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000004> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000008> {
            using TS_4_3 = Field<20, 2>;    // Trigger selection
            using SMS_3 = Field<16, 1>;    // Slave mode selection - bit 3
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000000c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000010> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40000014> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40000018> {
            using CC1S = Field<0, 2>;    // CC1S
            using OC1FE = Field<2, 1>;    // OC1FE
            using OC1PE = Field<3, 1>;    // OC1PE
            using OC1M = Field<4, 3>;    // OC1M
            using OC1CE = Field<7, 1>;    // OC1CE
            using CC2S = Field<8, 2>;    // CC2S
            using OC2FE = Field<10, 1>;    // OC2FE
            using OC2PE = Field<11, 1>;    // OC2PE
            using OC2M = Field<12, 3>;    // OC2M
            using OC2CE = Field<15, 1>;    // OC2CE
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode - bit 3
            using OC2M_3 = Field<24, 1>;    // Output Compare 2 mode - bit 3
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000018> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4000001c> {
            using OC4M_3 = Field<24, 1>;    // Output Compare 2 mode - bit 3
            using OC3M_3 = Field<16, 1>;    // Output Compare 1 mode - bit 3
            using O24CE = Field<15, 1>;    // O24CE
            using OC4M = Field<12, 3>;    // OC4M
            using OC4PE = Field<11, 1>;    // OC4PE
            using OC4FE = Field<10, 1>;    // OC4FE
            using CC4S = Field<8, 2>;    // CC4S
            using OC3CE = Field<7, 1>;    // OC3CE
            using OC3M = Field<4, 3>;    // OC3M
            using OC3PE = Field<3, 1>;    // OC3PE
            using OC3FE = Field<2, 1>;    // OC3FE
            using CC3S = Field<0, 2>;    // CC3S
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000001c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000020> {
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 output Polarity
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000024> {
            using CNT_L = Field<0, 16>;    // low counter value
            using CNT_H = Field<16, 16>;    // High counter value
        };

        // prescaler
        struct PSC : public Register<0x40000028> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000002c> {
            using ARR_H = Field<16, 16>;    // High Auto-reload value
            using ARR_L = Field<0, 16>;    // Low Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000034> {
            using CCR1_H = Field<16, 16>;    // High Capture/Compare 1 value
            using CCR1_L = Field<0, 16>;    // Low Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40000038> {
            using CCR2_H = Field<16, 16>;    // High Capture/Compare 2 value
            using CCR2_L = Field<0, 16>;    // Low Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4000003c> {
            using CCR3_H = Field<16, 16>;    // High Capture/Compare value
            using CCR3_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40000040> {
            using CCR4_H = Field<16, 16>;    // High Capture/Compare value
            using CCR4_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40000048> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4000004c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // TIM alternate function option register 1
        struct AF1 : public Register<0x40000060> {
            using ETRSEL = Field<14, 4>;    // ETR source selection
        };

        // TIM timer input selection register
        struct TISEL : public Register<0x40000068> {
            using TI1SEL = Field<0, 4>;    // TI1[0] to TI1[15] input selection
            using TI2SEL = Field<8, 4>;    // TI2[0] to TI2[15] input selection
            using TI3SEL = Field<16, 4>;    // TI3[0] to TI3[15] input selection
            using TI4SEL = Field<24, 4>;    // TI4[0] to TI4[15] input selection
        };

    };

    // General purpose timers
    struct TIM3 {
        // control register 1
        struct CR1 : public Register<0x40000400> {
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000404> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000408> {
            using TS_4_3 = Field<20, 2>;    // Trigger selection
            using SMS_3 = Field<16, 1>;    // Slave mode selection - bit 3
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000040c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000410> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40000414> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40000418> {
            using CC1S = Field<0, 2>;    // CC1S
            using OC1FE = Field<2, 1>;    // OC1FE
            using OC1PE = Field<3, 1>;    // OC1PE
            using OC1M = Field<4, 3>;    // OC1M
            using OC1CE = Field<7, 1>;    // OC1CE
            using CC2S = Field<8, 2>;    // CC2S
            using OC2FE = Field<10, 1>;    // OC2FE
            using OC2PE = Field<11, 1>;    // OC2PE
            using OC2M = Field<12, 3>;    // OC2M
            using OC2CE = Field<15, 1>;    // OC2CE
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode - bit 3
            using OC2M_3 = Field<24, 1>;    // Output Compare 2 mode - bit 3
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000418> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4000041c> {
            using OC4M_3 = Field<24, 1>;    // Output Compare 2 mode - bit 3
            using OC3M_3 = Field<16, 1>;    // Output Compare 1 mode - bit 3
            using O24CE = Field<15, 1>;    // O24CE
            using OC4M = Field<12, 3>;    // OC4M
            using OC4PE = Field<11, 1>;    // OC4PE
            using OC4FE = Field<10, 1>;    // OC4FE
            using CC4S = Field<8, 2>;    // CC4S
            using OC3CE = Field<7, 1>;    // OC3CE
            using OC3M = Field<4, 3>;    // OC3M
            using OC3PE = Field<3, 1>;    // OC3PE
            using OC3FE = Field<2, 1>;    // OC3FE
            using CC3S = Field<0, 2>;    // CC3S
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000041c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000420> {
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 output Polarity
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000424> {
            using CNT_L = Field<0, 16>;    // low counter value
            using CNT_H = Field<16, 16>;    // High counter value
        };

        // prescaler
        struct PSC : public Register<0x40000428> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000042c> {
            using ARR_H = Field<16, 16>;    // High Auto-reload value
            using ARR_L = Field<0, 16>;    // Low Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000434> {
            using CCR1_H = Field<16, 16>;    // High Capture/Compare 1 value
            using CCR1_L = Field<0, 16>;    // Low Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40000438> {
            using CCR2_H = Field<16, 16>;    // High Capture/Compare 2 value
            using CCR2_L = Field<0, 16>;    // Low Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4000043c> {
            using CCR3_H = Field<16, 16>;    // High Capture/Compare value
            using CCR3_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40000440> {
            using CCR4_H = Field<16, 16>;    // High Capture/Compare value
            using CCR4_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40000448> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4000044c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // TIM alternate function option register 1
        struct AF1 : public Register<0x40000460> {
            using ETRSEL = Field<14, 4>;    // ETR source selection
        };

        // TIM timer input selection register
        struct TISEL : public Register<0x40000468> {
            using TI1SEL = Field<0, 4>;    // TI1[0] to TI1[15] input selection
            using TI2SEL = Field<8, 4>;    // TI2[0] to TI2[15] input selection
            using TI3SEL = Field<16, 4>;    // TI3[0] to TI3[15] input selection
            using TI4SEL = Field<24, 4>;    // TI4[0] to TI4[15] input selection
        };

    };

    // General purpose timers
    struct TIM4 {
        // control register 1
        struct CR1 : public Register<0x40000800> {
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000804> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000808> {
            using TS_4_3 = Field<20, 2>;    // Trigger selection
            using SMS_3 = Field<16, 1>;    // Slave mode selection - bit 3
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000080c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000810> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40000814> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40000818> {
            using CC1S = Field<0, 2>;    // CC1S
            using OC1FE = Field<2, 1>;    // OC1FE
            using OC1PE = Field<3, 1>;    // OC1PE
            using OC1M = Field<4, 3>;    // OC1M
            using OC1CE = Field<7, 1>;    // OC1CE
            using CC2S = Field<8, 2>;    // CC2S
            using OC2FE = Field<10, 1>;    // OC2FE
            using OC2PE = Field<11, 1>;    // OC2PE
            using OC2M = Field<12, 3>;    // OC2M
            using OC2CE = Field<15, 1>;    // OC2CE
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode - bit 3
            using OC2M_3 = Field<24, 1>;    // Output Compare 2 mode - bit 3
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000818> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4000081c> {
            using OC4M_3 = Field<24, 1>;    // Output Compare 2 mode - bit 3
            using OC3M_3 = Field<16, 1>;    // Output Compare 1 mode - bit 3
            using O24CE = Field<15, 1>;    // O24CE
            using OC4M = Field<12, 3>;    // OC4M
            using OC4PE = Field<11, 1>;    // OC4PE
            using OC4FE = Field<10, 1>;    // OC4FE
            using CC4S = Field<8, 2>;    // CC4S
            using OC3CE = Field<7, 1>;    // OC3CE
            using OC3M = Field<4, 3>;    // OC3M
            using OC3PE = Field<3, 1>;    // OC3PE
            using OC3FE = Field<2, 1>;    // OC3FE
            using CC3S = Field<0, 2>;    // CC3S
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000081c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000820> {
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 output Polarity
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000824> {
            using CNT_L = Field<0, 16>;    // low counter value
            using CNT_H = Field<16, 16>;    // High counter value
        };

        // prescaler
        struct PSC : public Register<0x40000828> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000082c> {
            using ARR_H = Field<16, 16>;    // High Auto-reload value
            using ARR_L = Field<0, 16>;    // Low Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000834> {
            using CCR1_H = Field<16, 16>;    // High Capture/Compare 1 value
            using CCR1_L = Field<0, 16>;    // Low Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40000838> {
            using CCR2_H = Field<16, 16>;    // High Capture/Compare 2 value
            using CCR2_L = Field<0, 16>;    // Low Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4000083c> {
            using CCR3_H = Field<16, 16>;    // High Capture/Compare value
            using CCR3_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40000840> {
            using CCR4_H = Field<16, 16>;    // High Capture/Compare value
            using CCR4_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40000848> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4000084c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // TIM alternate function option register 1
        struct AF1 : public Register<0x40000860> {
            using ETRSEL = Field<14, 4>;    // ETR source selection
        };

        // TIM timer input selection register
        struct TISEL : public Register<0x40000868> {
            using TI1SEL = Field<0, 4>;    // TI1[0] to TI1[15] input selection
            using TI2SEL = Field<8, 4>;    // TI2[0] to TI2[15] input selection
            using TI3SEL = Field<16, 4>;    // TI3[0] to TI3[15] input selection
            using TI4SEL = Field<24, 4>;    // TI4[0] to TI4[15] input selection
        };

    };

    // General purpose timers
    struct TIM5 {
        // control register 1
        struct CR1 : public Register<0x40000c00> {
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000c04> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000c08> {
            using TS_4_3 = Field<20, 2>;    // Trigger selection
            using SMS_3 = Field<16, 1>;    // Slave mode selection - bit 3
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x40000c0c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000c10> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40000c14> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40000c18> {
            using CC1S = Field<0, 2>;    // CC1S
            using OC1FE = Field<2, 1>;    // OC1FE
            using OC1PE = Field<3, 1>;    // OC1PE
            using OC1M = Field<4, 3>;    // OC1M
            using OC1CE = Field<7, 1>;    // OC1CE
            using CC2S = Field<8, 2>;    // CC2S
            using OC2FE = Field<10, 1>;    // OC2FE
            using OC2PE = Field<11, 1>;    // OC2PE
            using OC2M = Field<12, 3>;    // OC2M
            using OC2CE = Field<15, 1>;    // OC2CE
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode - bit 3
            using OC2M_3 = Field<24, 1>;    // Output Compare 2 mode - bit 3
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000c18> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x40000c1c> {
            using OC4M_3 = Field<24, 1>;    // Output Compare 2 mode - bit 3
            using OC3M_3 = Field<16, 1>;    // Output Compare 1 mode - bit 3
            using O24CE = Field<15, 1>;    // O24CE
            using OC4M = Field<12, 3>;    // OC4M
            using OC4PE = Field<11, 1>;    // OC4PE
            using OC4FE = Field<10, 1>;    // OC4FE
            using CC4S = Field<8, 2>;    // CC4S
            using OC3CE = Field<7, 1>;    // OC3CE
            using OC3M = Field<4, 3>;    // OC3M
            using OC3PE = Field<3, 1>;    // OC3PE
            using OC3FE = Field<2, 1>;    // OC3FE
            using CC3S = Field<0, 2>;    // CC3S
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x40000c1c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000c20> {
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 output Polarity
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000c24> {
            using CNT_L = Field<0, 16>;    // low counter value
            using CNT_H = Field<16, 16>;    // High counter value
        };

        // prescaler
        struct PSC : public Register<0x40000c28> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x40000c2c> {
            using ARR_H = Field<16, 16>;    // High Auto-reload value
            using ARR_L = Field<0, 16>;    // Low Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000c34> {
            using CCR1_H = Field<16, 16>;    // High Capture/Compare 1 value
            using CCR1_L = Field<0, 16>;    // Low Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40000c38> {
            using CCR2_H = Field<16, 16>;    // High Capture/Compare 2 value
            using CCR2_L = Field<0, 16>;    // Low Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x40000c3c> {
            using CCR3_H = Field<16, 16>;    // High Capture/Compare value
            using CCR3_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40000c40> {
            using CCR4_H = Field<16, 16>;    // High Capture/Compare value
            using CCR4_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40000c48> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x40000c4c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // TIM alternate function option register 1
        struct AF1 : public Register<0x40000c60> {
            using ETRSEL = Field<14, 4>;    // ETR source selection
        };

        // TIM timer input selection register
        struct TISEL : public Register<0x40000c68> {
            using TI1SEL = Field<0, 4>;    // TI1[0] to TI1[15] input selection
            using TI2SEL = Field<8, 4>;    // TI2[0] to TI2[15] input selection
            using TI3SEL = Field<16, 4>;    // TI3[0] to TI3[15] input selection
            using TI4SEL = Field<24, 4>;    // TI4[0] to TI4[15] input selection
        };

    };

    // General purpose timers
    struct TIM12 {
        // control register 1
        struct CR1 : public Register<0x40001800> {
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40001804> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40001808> {
            using TS_4_3 = Field<20, 2>;    // Trigger selection
            using SMS_3 = Field<16, 1>;    // Slave mode selection - bit 3
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000180c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40001810> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40001814> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40001818> {
            using CC1S = Field<0, 2>;    // CC1S
            using OC1FE = Field<2, 1>;    // OC1FE
            using OC1PE = Field<3, 1>;    // OC1PE
            using OC1M = Field<4, 3>;    // OC1M
            using OC1CE = Field<7, 1>;    // OC1CE
            using CC2S = Field<8, 2>;    // CC2S
            using OC2FE = Field<10, 1>;    // OC2FE
            using OC2PE = Field<11, 1>;    // OC2PE
            using OC2M = Field<12, 3>;    // OC2M
            using OC2CE = Field<15, 1>;    // OC2CE
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode - bit 3
            using OC2M_3 = Field<24, 1>;    // Output Compare 2 mode - bit 3
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40001818> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4000181c> {
            using OC4M_3 = Field<24, 1>;    // Output Compare 2 mode - bit 3
            using OC3M_3 = Field<16, 1>;    // Output Compare 1 mode - bit 3
            using O24CE = Field<15, 1>;    // O24CE
            using OC4M = Field<12, 3>;    // OC4M
            using OC4PE = Field<11, 1>;    // OC4PE
            using OC4FE = Field<10, 1>;    // OC4FE
            using CC4S = Field<8, 2>;    // CC4S
            using OC3CE = Field<7, 1>;    // OC3CE
            using OC3M = Field<4, 3>;    // OC3M
            using OC3PE = Field<3, 1>;    // OC3PE
            using OC3FE = Field<2, 1>;    // OC3FE
            using CC3S = Field<0, 2>;    // CC3S
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000181c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40001820> {
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 output Polarity
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40001824> {
            using CNT_L = Field<0, 16>;    // low counter value
            using CNT_H = Field<16, 16>;    // High counter value
        };

        // prescaler
        struct PSC : public Register<0x40001828> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000182c> {
            using ARR_H = Field<16, 16>;    // High Auto-reload value
            using ARR_L = Field<0, 16>;    // Low Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40001834> {
            using CCR1_H = Field<16, 16>;    // High Capture/Compare 1 value
            using CCR1_L = Field<0, 16>;    // Low Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40001838> {
            using CCR2_H = Field<16, 16>;    // High Capture/Compare 2 value
            using CCR2_L = Field<0, 16>;    // Low Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4000183c> {
            using CCR3_H = Field<16, 16>;    // High Capture/Compare value
            using CCR3_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40001840> {
            using CCR4_H = Field<16, 16>;    // High Capture/Compare value
            using CCR4_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40001848> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4000184c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // TIM alternate function option register 1
        struct AF1 : public Register<0x40001860> {
            using ETRSEL = Field<14, 4>;    // ETR source selection
        };

        // TIM timer input selection register
        struct TISEL : public Register<0x40001868> {
            using TI1SEL = Field<0, 4>;    // TI1[0] to TI1[15] input selection
            using TI2SEL = Field<8, 4>;    // TI2[0] to TI2[15] input selection
            using TI3SEL = Field<16, 4>;    // TI3[0] to TI3[15] input selection
            using TI4SEL = Field<24, 4>;    // TI4[0] to TI4[15] input selection
        };

    };

    // General purpose timers
    struct TIM13 {
        // control register 1
        struct CR1 : public Register<0x40001c00> {
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40001c04> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40001c08> {
            using TS_4_3 = Field<20, 2>;    // Trigger selection
            using SMS_3 = Field<16, 1>;    // Slave mode selection - bit 3
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x40001c0c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40001c10> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40001c14> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40001c18> {
            using CC1S = Field<0, 2>;    // CC1S
            using OC1FE = Field<2, 1>;    // OC1FE
            using OC1PE = Field<3, 1>;    // OC1PE
            using OC1M = Field<4, 3>;    // OC1M
            using OC1CE = Field<7, 1>;    // OC1CE
            using CC2S = Field<8, 2>;    // CC2S
            using OC2FE = Field<10, 1>;    // OC2FE
            using OC2PE = Field<11, 1>;    // OC2PE
            using OC2M = Field<12, 3>;    // OC2M
            using OC2CE = Field<15, 1>;    // OC2CE
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode - bit 3
            using OC2M_3 = Field<24, 1>;    // Output Compare 2 mode - bit 3
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40001c18> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x40001c1c> {
            using OC4M_3 = Field<24, 1>;    // Output Compare 2 mode - bit 3
            using OC3M_3 = Field<16, 1>;    // Output Compare 1 mode - bit 3
            using O24CE = Field<15, 1>;    // O24CE
            using OC4M = Field<12, 3>;    // OC4M
            using OC4PE = Field<11, 1>;    // OC4PE
            using OC4FE = Field<10, 1>;    // OC4FE
            using CC4S = Field<8, 2>;    // CC4S
            using OC3CE = Field<7, 1>;    // OC3CE
            using OC3M = Field<4, 3>;    // OC3M
            using OC3PE = Field<3, 1>;    // OC3PE
            using OC3FE = Field<2, 1>;    // OC3FE
            using CC3S = Field<0, 2>;    // CC3S
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x40001c1c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40001c20> {
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 output Polarity
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40001c24> {
            using CNT_L = Field<0, 16>;    // low counter value
            using CNT_H = Field<16, 16>;    // High counter value
        };

        // prescaler
        struct PSC : public Register<0x40001c28> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x40001c2c> {
            using ARR_H = Field<16, 16>;    // High Auto-reload value
            using ARR_L = Field<0, 16>;    // Low Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40001c34> {
            using CCR1_H = Field<16, 16>;    // High Capture/Compare 1 value
            using CCR1_L = Field<0, 16>;    // Low Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40001c38> {
            using CCR2_H = Field<16, 16>;    // High Capture/Compare 2 value
            using CCR2_L = Field<0, 16>;    // Low Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x40001c3c> {
            using CCR3_H = Field<16, 16>;    // High Capture/Compare value
            using CCR3_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40001c40> {
            using CCR4_H = Field<16, 16>;    // High Capture/Compare value
            using CCR4_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40001c48> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x40001c4c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // TIM alternate function option register 1
        struct AF1 : public Register<0x40001c60> {
            using ETRSEL = Field<14, 4>;    // ETR source selection
        };

        // TIM timer input selection register
        struct TISEL : public Register<0x40001c68> {
            using TI1SEL = Field<0, 4>;    // TI1[0] to TI1[15] input selection
            using TI2SEL = Field<8, 4>;    // TI2[0] to TI2[15] input selection
            using TI3SEL = Field<16, 4>;    // TI3[0] to TI3[15] input selection
            using TI4SEL = Field<24, 4>;    // TI4[0] to TI4[15] input selection
        };

    };

    // General purpose timers
    struct TIM14 {
        // control register 1
        struct CR1 : public Register<0x40002000> {
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40002004> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40002008> {
            using TS_4_3 = Field<20, 2>;    // Trigger selection
            using SMS_3 = Field<16, 1>;    // Slave mode selection - bit 3
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000200c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40002010> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40002014> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40002018> {
            using CC1S = Field<0, 2>;    // CC1S
            using OC1FE = Field<2, 1>;    // OC1FE
            using OC1PE = Field<3, 1>;    // OC1PE
            using OC1M = Field<4, 3>;    // OC1M
            using OC1CE = Field<7, 1>;    // OC1CE
            using CC2S = Field<8, 2>;    // CC2S
            using OC2FE = Field<10, 1>;    // OC2FE
            using OC2PE = Field<11, 1>;    // OC2PE
            using OC2M = Field<12, 3>;    // OC2M
            using OC2CE = Field<15, 1>;    // OC2CE
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode - bit 3
            using OC2M_3 = Field<24, 1>;    // Output Compare 2 mode - bit 3
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40002018> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4000201c> {
            using OC4M_3 = Field<24, 1>;    // Output Compare 2 mode - bit 3
            using OC3M_3 = Field<16, 1>;    // Output Compare 1 mode - bit 3
            using O24CE = Field<15, 1>;    // O24CE
            using OC4M = Field<12, 3>;    // OC4M
            using OC4PE = Field<11, 1>;    // OC4PE
            using OC4FE = Field<10, 1>;    // OC4FE
            using CC4S = Field<8, 2>;    // CC4S
            using OC3CE = Field<7, 1>;    // OC3CE
            using OC3M = Field<4, 3>;    // OC3M
            using OC3PE = Field<3, 1>;    // OC3PE
            using OC3FE = Field<2, 1>;    // OC3FE
            using CC3S = Field<0, 2>;    // CC3S
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000201c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40002020> {
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 output Polarity
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40002024> {
            using CNT_L = Field<0, 16>;    // low counter value
            using CNT_H = Field<16, 16>;    // High counter value
        };

        // prescaler
        struct PSC : public Register<0x40002028> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000202c> {
            using ARR_H = Field<16, 16>;    // High Auto-reload value
            using ARR_L = Field<0, 16>;    // Low Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40002034> {
            using CCR1_H = Field<16, 16>;    // High Capture/Compare 1 value
            using CCR1_L = Field<0, 16>;    // Low Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40002038> {
            using CCR2_H = Field<16, 16>;    // High Capture/Compare 2 value
            using CCR2_L = Field<0, 16>;    // Low Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4000203c> {
            using CCR3_H = Field<16, 16>;    // High Capture/Compare value
            using CCR3_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40002040> {
            using CCR4_H = Field<16, 16>;    // High Capture/Compare value
            using CCR4_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40002048> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4000204c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // TIM alternate function option register 1
        struct AF1 : public Register<0x40002060> {
            using ETRSEL = Field<14, 4>;    // ETR source selection
        };

        // TIM timer input selection register
        struct TISEL : public Register<0x40002068> {
            using TI1SEL = Field<0, 4>;    // TI1[0] to TI1[15] input selection
            using TI2SEL = Field<8, 4>;    // TI2[0] to TI2[15] input selection
            using TI3SEL = Field<16, 4>;    // TI3[0] to TI3[15] input selection
            using TI4SEL = Field<24, 4>;    // TI4[0] to TI4[15] input selection
        };

    };

    // Basic timers
    struct TIM6 {
        // control register 1
        struct CR1 : public Register<0x40001000> {
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40001004> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000100c> {
            using UDE = Field<8, 1>;    // Update DMA request enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40001010> {
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40001014> {
            using UG = Field<0, 1>;    // Update generation
        };

        // counter
        struct CNT : public Register<0x40001024> {
            using Field = Field<0, 16>;    // Low counter value
            using UIFCPY = Field<31, 1>;    // UIF Copy
        };

        // prescaler
        struct PSC : public Register<0x40001028> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000102c> {
            using Field = Field<0, 16>;    // Low Auto-reload value
        };

    };

    // Basic timers
    struct TIM7 {
        // control register 1
        struct CR1 : public Register<0x40001400> {
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40001404> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000140c> {
            using UDE = Field<8, 1>;    // Update DMA request enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40001410> {
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public RegisterWriteOnly<0x40001414> {
            using UG = Field<0, 1>;    // Update generation
        };

        // counter
        struct CNT : public Register<0x40001424> {
            using Field = Field<0, 16>;    // Low counter value
            using UIFCPY = Field<31, 1>;    // UIF Copy
        };

        // prescaler
        struct PSC : public Register<0x40001428> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000142c> {
            using Field = Field<0, 16>;    // Low Auto-reload value
        };

    };

    // Nested Vectored Interrupt Controller
    struct NVIC {
        // Interrupt Set-Enable Register
        struct ISER0 : public Register<0xe000e100> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Set-Enable Register
        struct ISER1 : public Register<0xe000e104> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Set-Enable Register
        struct ISER2 : public Register<0xe000e108> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Clear-Enable Register
        struct ICER0 : public Register<0xe000e180> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Clear-Enable Register
        struct ICER1 : public Register<0xe000e184> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Clear-Enable Register
        struct ICER2 : public Register<0xe000e188> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Set-Pending Register
        struct ISPR0 : public Register<0xe000e200> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Set-Pending Register
        struct ISPR1 : public Register<0xe000e204> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Set-Pending Register
        struct ISPR2 : public Register<0xe000e208> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR0 : public Register<0xe000e280> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR1 : public Register<0xe000e284> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR2 : public Register<0xe000e288> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Active Bit Register
        struct IABR0 : public RegisterReadOnly<0xe000e300> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Active Bit Register
        struct IABR1 : public RegisterReadOnly<0xe000e304> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Active Bit Register
        struct IABR2 : public RegisterReadOnly<0xe000e308> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Priority Register
        struct IPR0 : public Register<0xe000e400> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR1 : public Register<0xe000e404> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR2 : public Register<0xe000e408> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR3 : public Register<0xe000e40c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR4 : public Register<0xe000e410> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR5 : public Register<0xe000e414> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR6 : public Register<0xe000e418> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR7 : public Register<0xe000e41c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR8 : public Register<0xe000e420> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR9 : public Register<0xe000e424> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR10 : public Register<0xe000e428> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR11 : public Register<0xe000e42c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR12 : public Register<0xe000e430> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR13 : public Register<0xe000e434> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR14 : public Register<0xe000e438> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR15 : public Register<0xe000e43c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR16 : public Register<0xe000e440> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR17 : public Register<0xe000e444> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR18 : public Register<0xe000e448> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR19 : public Register<0xe000e44c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR20 : public Register<0xe000e450> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR21 : public Register<0xe000e454> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR22 : public Register<0xe000e458> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR23 : public Register<0xe000e45c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR24 : public Register<0xe000e460> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR25 : public Register<0xe000e464> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR26 : public Register<0xe000e468> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR27 : public Register<0xe000e46c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR28 : public Register<0xe000e470> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR29 : public Register<0xe000e474> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR30 : public Register<0xe000e478> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR31 : public Register<0xe000e47c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR32 : public Register<0xe000e480> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR33 : public Register<0xe000e484> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR34 : public Register<0xe000e488> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR35 : public Register<0xe000e48c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR36 : public Register<0xe000e490> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR37 : public Register<0xe000e494> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR38 : public Register<0xe000e498> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR39 : public Register<0xe000e49c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Set-Enable Register
        struct ISER3 : public Register<0xe000e10c> {
        };

        // Interrupt Set-Enable Register
        struct ISER4 : public Register<0xe000e110> {
        };

        // Interrupt Clear-Enable Register
        struct ICER3 : public Register<0xe000e18c> {
        };

        // Interrupt Clear-Enable Register
        struct ICER4 : public Register<0xe000e190> {
        };

        // Interrupt Set-Pending Register
        struct ISPR3 : public Register<0xe000e20c> {
        };

        // Interrupt Set-Pending Register
        struct ISPR4 : public Register<0xe000e210> {
        };

        // Interrupt Clear-Pending Register
        struct ICPR3 : public Register<0xe000e2c0> {
        };

        // Interrupt Clear-Pending Register
        struct ICPR4 : public Register<0xe000e2c4> {
        };

        // Interrupt Active Bit Register
        struct IABR3 : public Register<0xe000e30c> {
        };

        // Interrupt Active Bit Register
        struct IABR4 : public Register<0xe000e310> {
        };

    };

    // Memory protection unit
    struct MPU {
        // MPU type register
        struct MPU_TYPER : public RegisterReadOnly<0xe000ed90> {
            using SEPARATE = Field<0, 1>;    // Separate flag
            using DREGION = Field<8, 8>;    // Number of MPU data regions
            using IREGION = Field<16, 8>;    // Number of MPU instruction regions
        };

        // MPU control register
        struct MPU_CTRL : public RegisterReadOnly<0xe000ed94> {
            using ENABLE = Field<0, 1>;    // Enables the MPU
            using HFNMIENA = Field<1, 1>;    // Enables the operation of MPU during hard fault
            using PRIVDEFENA = Field<2, 1>;    // Enable priviliged software access to default memory map
        };

        // MPU region number register
        struct MPU_RNR : public Register<0xe000ed98> {
            using REGION = Field<0, 8>;    // MPU region
        };

        // MPU region base address register
        struct MPU_RBAR : public Register<0xe000ed9c> {
            using REGION = Field<0, 4>;    // MPU region field
            using VALID = Field<4, 1>;    // MPU region number valid
            using ADDR = Field<5, 27>;    // Region base address field
        };

        // MPU region attribute and size register
        struct MPU_RASR : public Register<0xe000eda0> {
            using ENABLE = Field<0, 1>;    // Region enable bit.
            using SIZE = Field<1, 5>;    // Size of the MPU protection region
            using SRD = Field<8, 8>;    // Subregion disable bits
            using B = Field<16, 1>;    // memory attribute
            using C = Field<17, 1>;    // memory attribute
            using S = Field<18, 1>;    // Shareable memory attribute
            using TEX = Field<19, 3>;    // memory attribute
            using AP = Field<24, 3>;    // Access permission
            using XN = Field<28, 1>;    // Instruction access disable bit
        };

    };

    // SysTick timer
    struct STK {
        // SysTick control and status register
        struct CSR : public Register<0xe000e010> {
            using ENABLE = Field<0, 1>;    // Counter enable
            using TICKINT = Field<1, 1>;    // SysTick exception request enable
            using CLKSOURCE = Field<2, 1>;    // Clock source selection
            using COUNTFLAG = Field<16, 1>;    // COUNTFLAG
        };

        // SysTick reload value register
        struct RVR : public Register<0xe000e014> {
            using RELOAD = Field<0, 24>;    // RELOAD value
        };

        // SysTick current value register
        struct CVR : public Register<0xe000e018> {
            using CURRENT = Field<0, 24>;    // Current counter value
        };

        // SysTick calibration value register
        struct CALIB : public Register<0xe000e01c> {
            using TENMS = Field<0, 24>;    // Calibration value
            using SKEW = Field<30, 1>;    // SKEW flag: Indicates whether the TENMS value is exact
            using NOREF = Field<31, 1>;    // NOREF flag. Reads as zero
        };

    };

    // Nested vectored interrupt controller
    struct NVIC_STIR {
        // Software trigger interrupt register
        struct STIR : public Register<0xe000ef00> {
            using INTID = Field<0, 9>;    // Software generated interrupt ID
        };

    };

    // Floating point unit CPACR
    struct FPU_CPACR {
        // Coprocessor access control register
        struct CPACR : public Register<0xe000ed88> {
            using CP = Field<20, 4>;    // CP
        };

    };

    // System control block ACTLR
    struct SCB_ACTRL {
        // Auxiliary control register
        struct ACTRL : public Register<0xe000e008> {
            using DISFOLD = Field<2, 1>;    // DISFOLD
            using FPEXCODIS = Field<10, 1>;    // FPEXCODIS
            using DISRAMODE = Field<11, 1>;    // DISRAMODE
            using DISITMATBFLUSH = Field<12, 1>;    // DISITMATBFLUSH
        };

    };

    // Floting point unit
    struct FPU {
        // Floating-point context control register
        struct FPCCR : public Register<0xe000ef34> {
            using LSPACT = Field<0, 1>;    // LSPACT
            using USER = Field<1, 1>;    // USER
            using THREAD = Field<3, 1>;    // THREAD
            using HFRDY = Field<4, 1>;    // HFRDY
            using MMRDY = Field<5, 1>;    // MMRDY
            using BFRDY = Field<6, 1>;    // BFRDY
            using MONRDY = Field<8, 1>;    // MONRDY
            using LSPEN = Field<30, 1>;    // LSPEN
            using ASPEN = Field<31, 1>;    // ASPEN
        };

        // Floating-point context address register
        struct FPCAR : public Register<0xe000ef38> {
            using ADDRESS = Field<3, 29>;    // Location of unpopulated floating-point
        };

        // Floating-point status control register
        struct FPSCR : public Register<0xe000ef3c> {
            using IOC = Field<0, 1>;    // Invalid operation cumulative exception bit
            using DZC = Field<1, 1>;    // Division by zero cumulative exception bit.
            using OFC = Field<2, 1>;    // Overflow cumulative exception bit
            using UFC = Field<3, 1>;    // Underflow cumulative exception bit
            using IXC = Field<4, 1>;    // Inexact cumulative exception bit
            using IDC = Field<7, 1>;    // Input denormal cumulative exception bit.
            using RMode = Field<22, 2>;    // Rounding Mode control field
            using FZ = Field<24, 1>;    // Flush-to-zero mode control bit:
            using DN = Field<25, 1>;    // Default NaN mode control bit
            using AHP = Field<26, 1>;    // Alternative half-precision control bit
            using V = Field<28, 1>;    // Overflow condition code flag
            using C = Field<29, 1>;    // Carry condition code flag
            using Z = Field<30, 1>;    // Zero condition code flag
            using N = Field<31, 1>;    // Negative condition code flag
        };

    };

    // System control block
    struct SCB {
        // CPUID base register
        struct CPUID : public RegisterReadOnly<0xe000ed00> {
            using Revision = Field<0, 4>;    // Revision number
            using PartNo = Field<4, 12>;    // Part number of the processor
            using Constant = Field<16, 4>;    // Reads as 0xF
            using Variant = Field<20, 4>;    // Variant number
            using Implementer = Field<24, 8>;    // Implementer code
        };

        // Interrupt control and state register
        struct ICSR : public Register<0xe000ed04> {
            using VECTACTIVE = Field<0, 9>;    // Active vector
            using RETTOBASE = Field<11, 1>;    // Return to base level
            using VECTPENDING = Field<12, 7>;    // Pending vector
            using ISRPENDING = Field<22, 1>;    // Interrupt pending flag
            using PENDSTCLR = Field<25, 1>;    // SysTick exception clear-pending bit
            using PENDSTSET = Field<26, 1>;    // SysTick exception set-pending bit
            using PENDSVCLR = Field<27, 1>;    // PendSV clear-pending bit
            using PENDSVSET = Field<28, 1>;    // PendSV set-pending bit
            using NMIPENDSET = Field<31, 1>;    // NMI set-pending bit.
        };

        // Vector table offset register
        struct VTOR : public Register<0xe000ed08> {
            using TBLOFF = Field<9, 21>;    // Vector table base offset field
        };

        // Application interrupt and reset control register
        struct AIRCR : public Register<0xe000ed0c> {
            using VECTRESET = Field<0, 1>;    // VECTRESET
            using VECTCLRACTIVE = Field<1, 1>;    // VECTCLRACTIVE
            using SYSRESETREQ = Field<2, 1>;    // SYSRESETREQ
            using PRIGROUP = Field<8, 3>;    // PRIGROUP
            using ENDIANESS = Field<15, 1>;    // ENDIANESS
            using VECTKEYSTAT = Field<16, 16>;    // Register key
        };

        // System control register
        struct SCR : public Register<0xe000ed10> {
            using SLEEPONEXIT = Field<1, 1>;    // SLEEPONEXIT
            using SLEEPDEEP = Field<2, 1>;    // SLEEPDEEP
            using SEVEONPEND = Field<4, 1>;    // Send Event on Pending bit
        };

        // Configuration and control register
        struct CCR : public Register<0xe000ed14> {
            using NONBASETHRDENA = Field<0, 1>;    // Configures how the processor enters Thread mode
            using USERSETMPEND = Field<1, 1>;    // USERSETMPEND
            using UNALIGN__TRP = Field<3, 1>;    // UNALIGN_ TRP
            using DIV_0_TRP = Field<4, 1>;    // DIV_0_TRP
            using BFHFNMIGN = Field<8, 1>;    // BFHFNMIGN
            using STKALIGN = Field<9, 1>;    // STKALIGN
            using DC = Field<16, 1>;    // DC
            using IC = Field<17, 1>;    // IC
            using BP = Field<18, 1>;    // BP
        };

        // System handler priority registers
        struct SHPR1 : public Register<0xe000ed18> {
            using PRI_4 = Field<0, 8>;    // Priority of system handler 4
            using PRI_5 = Field<8, 8>;    // Priority of system handler 5
            using PRI_6 = Field<16, 8>;    // Priority of system handler 6
        };

        // System handler priority registers
        struct SHPR2 : public Register<0xe000ed1c> {
            using PRI_11 = Field<24, 8>;    // Priority of system handler 11
        };

        // System handler priority registers
        struct SHPR3 : public Register<0xe000ed20> {
            using PRI_14 = Field<16, 8>;    // Priority of system handler 14
            using PRI_15 = Field<24, 8>;    // Priority of system handler 15
        };

        // System handler control and state register
        struct SHCRS : public Register<0xe000ed24> {
            using MEMFAULTACT = Field<0, 1>;    // Memory management fault exception active bit
            using BUSFAULTACT = Field<1, 1>;    // Bus fault exception active bit
            using USGFAULTACT = Field<3, 1>;    // Usage fault exception active bit
            using SVCALLACT = Field<7, 1>;    // SVC call active bit
            using MONITORACT = Field<8, 1>;    // Debug monitor active bit
            using PENDSVACT = Field<10, 1>;    // PendSV exception active bit
            using SYSTICKACT = Field<11, 1>;    // SysTick exception active bit
            using USGFAULTPENDED = Field<12, 1>;    // Usage fault exception pending bit
            using MEMFAULTPENDED = Field<13, 1>;    // Memory management fault exception pending bit
            using BUSFAULTPENDED = Field<14, 1>;    // Bus fault exception pending bit
            using SVCALLPENDED = Field<15, 1>;    // SVC call pending bit
            using MEMFAULTENA = Field<16, 1>;    // Memory management fault enable bit
            using BUSFAULTENA = Field<17, 1>;    // Bus fault enable bit
            using USGFAULTENA = Field<18, 1>;    // Usage fault enable bit
        };

        // Configurable fault status register
        struct CFSR_UFSR_BFSR_MMFSR : public Register<0xe000ed28> {
            using IACCVIOL = Field<0, 1>;    // IACCVIOL
            using DACCVIOL = Field<1, 1>;    // DACCVIOL
            using MUNSTKERR = Field<3, 1>;    // MUNSTKERR
            using MSTKERR = Field<4, 1>;    // MSTKERR
            using MLSPERR = Field<5, 1>;    // MLSPERR
            using MMARVALID = Field<7, 1>;    // MMARVALID
            using IBUSERR = Field<8, 1>;    // Instruction bus error
            using PRECISERR = Field<9, 1>;    // Precise data bus error
            using IMPRECISERR = Field<10, 1>;    // Imprecise data bus error
            using UNSTKERR = Field<11, 1>;    // Bus fault on unstacking for a return from exception
            using STKERR = Field<12, 1>;    // Bus fault on stacking for exception entry
            using LSPERR = Field<13, 1>;    // Bus fault on floating-point lazy state preservation
            using BFARVALID = Field<15, 1>;    // Bus Fault Address Register (BFAR) valid flag
            using UNDEFINSTR = Field<16, 1>;    // Undefined instruction usage fault
            using INVSTATE = Field<17, 1>;    // Invalid state usage fault
            using INVPC = Field<18, 1>;    // Invalid PC load usage fault
            using NOCP = Field<19, 1>;    // No coprocessor usage fault.
            using UNALIGNED = Field<24, 1>;    // Unaligned access usage fault
            using DIVBYZERO = Field<25, 1>;    // Divide by zero usage fault
        };

        // Hard fault status register
        struct HFSR : public Register<0xe000ed2c> {
            using VECTTBL = Field<1, 1>;    // Vector table hard fault
            using FORCED = Field<30, 1>;    // Forced hard fault
            using DEBUG_VT = Field<31, 1>;    // Reserved for Debug use
        };

        // Memory management fault address register
        struct MMFAR : public Register<0xe000ed34> {
            using ADDRESS = Field<0, 32>;    // Memory management fault address
        };

        // Bus fault address register
        struct BFAR : public Register<0xe000ed38> {
            using ADDRESS = Field<0, 32>;    // Bus fault address
        };

    };

    // Processor features
    struct PF {
        // Cache Level ID register
        struct CLIDR : public RegisterReadOnly<0xe000ed78> {
            using CL1 = Field<0, 3>;    // CL1
            using CL2 = Field<3, 3>;    // CL2
            using CL3 = Field<6, 3>;    // CL3
            using CL4 = Field<9, 3>;    // CL4
            using CL5 = Field<12, 3>;    // CL5
            using CL6 = Field<15, 3>;    // CL6
            using CL7 = Field<18, 3>;    // CL7
            using LoUIS = Field<21, 3>;    // LoUIS
            using LoC = Field<24, 3>;    // LoC
            using LoU = Field<27, 3>;    // LoU
        };

        // Cache Type register
        struct CTR : public RegisterReadOnly<0xe000ed7c> {
            using _IminLine = Field<0, 4>;    // IminLine
            using DMinLine = Field<16, 4>;    // DMinLine
            using ERG = Field<20, 4>;    // ERG
            using CWG = Field<24, 4>;    // CWG
            using Format = Field<29, 3>;    // Format
        };

        // Cache Size ID register
        struct CCSIDR : public RegisterReadOnly<0xe000ed80> {
            using LineSize = Field<0, 3>;    // LineSize
            using Associativity = Field<3, 10>;    // Associativity
            using NumSets = Field<13, 15>;    // NumSets
            using WA = Field<28, 1>;    // WA
            using RA = Field<29, 1>;    // RA
            using WB = Field<30, 1>;    // WB
            using WT = Field<31, 1>;    // WT
        };

    };

    // Access control
    struct AC {
        // Instruction and Data Tightly-Coupled Memory Control Registers
        struct ITCMCR : public Register<0xe000ef90> {
            using EN = Field<0, 1>;    // EN
            using RMW = Field<1, 1>;    // RMW
            using RETEN = Field<2, 1>;    // RETEN
            using SZ = Field<3, 4>;    // SZ
        };

        // Instruction and Data Tightly-Coupled Memory Control Registers
        struct DTCMCR : public Register<0xe000ef94> {
            using EN = Field<0, 1>;    // EN
            using RMW = Field<1, 1>;    // RMW
            using RETEN = Field<2, 1>;    // RETEN
            using SZ = Field<3, 4>;    // SZ
        };

        // AHBP Control register
        struct AHBPCR : public Register<0xe000ef98> {
            using EN = Field<0, 1>;    // EN
            using SZ = Field<1, 3>;    // SZ
        };

        // Auxiliary Cache Control register
        struct CACR : public Register<0xe000ef9c> {
            using SIWT = Field<0, 1>;    // SIWT
            using ECCEN = Field<1, 1>;    // ECCEN
            using FORCEWT = Field<2, 1>;    // FORCEWT
        };

        // AHB Slave Control register
        struct AHBSCR : public Register<0xe000efa0> {
            using CTL = Field<0, 2>;    // CTL
            using TPRI = Field<2, 9>;    // TPRI
            using INITCOUNT = Field<11, 5>;    // INITCOUNT
        };

        // Auxiliary Bus Fault Status register
        struct ABFSR : public Register<0xe000efa8> {
            using ITCM = Field<0, 1>;    // ITCM
            using DTCM = Field<1, 1>;    // DTCM
            using AHBP = Field<2, 1>;    // AHBP
            using AXIM = Field<3, 1>;    // AXIM
            using EPPB = Field<4, 1>;    // EPPB
            using AXIMTYPE = Field<8, 2>;    // AXIMTYPE
        };

    };

    static std::uint32_t const numInterrupts = 150;

    enum class Interrupts: std::uint32_t {
        WWDG1 = 0,
        PVD_PVM = 1,
        RTC_TAMP_STAMP_CSS_LSE = 2,
        RTC_WKUP = 3,
        FLASH = 4,
        RCC = 5,
        EXTI0 = 6,
        EXTI1 = 7,
        EXTI2 = 8,
        EXTI3 = 9,
        EXTI4 = 10,
        DMA_STR0 = 11,
        DMA_STR1 = 12,
        DMA_STR2 = 13,
        DMA_STR3 = 14,
        DMA_STR4 = 15,
        DMA_STR5 = 16,
        DMA_STR6 = 17,
        ADC1_2 = 18,
        FDCAN1_IT0 = 19,
        FDCAN2_IT0 = 20,
        FDCAN1_IT1 = 21,
        FDCAN2_IT1 = 22,
        EXTI9_5 = 23,
        TIM1_BRK = 24,
        TIM1_UP = 25,
        TIM1_TRG_COM = 26,
        TIM_CC = 27,
        TIM2 = 28,
        TIM3 = 29,
        TIM4 = 30,
        I2C1_EV = 31,
        I2C1_ER = 32,
        I2C2_EV = 33,
        I2C2_ER = 34,
        SPI1 = 35,
        SPI2 = 36,
        USART1 = 37,
        USART2 = 38,
        USART3 = 39,
        EXTI15_10 = 40,
        RTC_ALARM = 41,
        TIM8_BRK_TIM12 = 43,
        TIM8_UP_TIM13 = 44,
        TIM8_TRG_COM_TIM14 = 45,
        TIM8_CC = 46,
        DMA1_STR7 = 47,
        FMC = 48,
        SDMMC1 = 49,
        TIM5 = 50,
        SPI3 = 51,
        UART4 = 52,
        UART5 = 53,
        TIM6_DAC = 54,
        TIM7 = 55,
        DMA2_STR0 = 56,
        DMA2_STR1 = 57,
        DMA2_STR2 = 58,
        DMA2_STR3 = 59,
        DMA2_STR4 = 60,
        ETH = 61,
        ETH_WKUP = 62,
        FDCAN_CAL = 63,
        DMA2_STR5 = 68,
        DMA2_STR6 = 69,
        DMA2_STR7 = 70,
        USART6 = 71,
        I2C3_EV = 72,
        I2C3_ER = 73,
        OTG_HS_EP1_OUT = 74,
        OTG_HS_EP1_IN = 75,
        OTG_HS_WKUP = 76,
        OTG_HS = 77,
        DCMI = 78,
        FPU = 81,
        UART7 = 82,
        UART8 = 83,
        SPI4 = 84,
        SPI5 = 85,
        SPI6 = 86,
        SAI1 = 87,
        LTDC = 88,
        LTDC_ER = 89,
        DMA2D = 90,
        SAI2 = 91,
        QUADSPI = 92,
        LPTIM1 = 93,
        CEC = 94,
        I2C4_EV = 95,
        I2C4_ER = 96,
        SPDIF = 97,
        OTG_FS_EP1_OUT = 98,
        OTG_FS_EP1_IN = 99,
        OTG_FS_WKUP = 100,
        OTG_FS = 101,
        DMAMUX1_OV = 102,
        HRTIM1_MST = 103,
        HRTIM1_TIMA = 104,
        HRTIM_TIMB = 105,
        HRTIM1_TIMC = 106,
        HRTIM1_TIMD = 107,
        HRTIM_TIME = 108,
        HRTIM1_FLT = 109,
        DFSDM1_FLT0 = 110,
        DFSDM1_FLT1 = 111,
        DFSDM1_FLT2 = 112,
        DFSDM1_FLT3 = 113,
        SAI3 = 114,
        SWPMI1 = 115,
        TIM15 = 116,
        TIM16 = 117,
        TIM17 = 118,
        MDIOS_WKUP = 119,
        MDIOS = 120,
        JPEG = 121,
        MDMA = 122,
        SDMMC = 124,
        HSEM0 = 125,
        ADC3 = 127,
        DMAMUX2_OVR = 128,
        BDMA_CH1 = 129,
        BDMA_CH2 = 130,
        BDMA_CH3 = 131,
        BDMA_CH4 = 132,
        BDMA_CH5 = 133,
        BDMA_CH6 = 134,
        BDMA_CH7 = 135,
        BDMA_CH8 = 136,
        COMP = 137,
        LPTIM2 = 138,
        LPTIM3 = 139,
        LPTIM4 = 140,
        LPTIM5 = 141,
        LPUART = 142,
        WWDG1_RST = 143,
        CRS = 144,
        SAI4 = 146,
        WKUP = 149,
    };

};
