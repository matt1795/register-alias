// This is a file generated by svd-alias.

#pragma once

#include "svd-alias/bit-field.hpp"
#include "svd-alias/register.hpp"

struct STM32GBK1CBT6 {
    // Cyclic redundancy check calculation unit
    struct CRC {
        // Data register
        struct DR : public Register<0x40023000> {
            using Field = Field<0, 32>;    // Data register bits
        };

        // Independent data register
        struct IDR : public Register<0x40023004> {
            using Field = Field<0, 32>;    // General-purpose 8-bit data register bits
        };

        // Control register
        struct CR : public Register<0x40023008> {
            using REV_OUT = Field<7, 1>;    // Reverse output data
            using REV_IN = Field<5, 2>;    // Reverse input data
            using POLYSIZE = Field<3, 2>;    // Polynomial size
            using RESET = Field<0, 1>;    // RESET bit
        };

        // Initial CRC value
        struct INIT : public Register<0x40023010> {
            using CRC_INIT = Field<0, 32>;    // Programmable initial CRC value
        };

        // polynomial
        struct POL : public Register<0x40023014> {
            using Field = Field<0, 32>;    // Programmable polynomial
        };

    };

    // WinWATCHDOG
    struct WWDG {
        // Key register
        struct KR : public Register<0x40002c00> {
            using KEY = Field<0, 16>;    // Key value (write only, read 0x0000)
        };

        // Prescaler register
        struct PR : public Register<0x40002c04> {
            using Field = Field<0, 3>;    // Prescaler divider
        };

        // Reload register
        struct RLR : public Register<0x40002c08> {
            using RL = Field<0, 12>;    // Watchdog counter reload value
        };

        // Status register
        struct SR : public Register<0x40002c0c> {
            using WVU = Field<2, 1>;    // Watchdog counter window value update
            using RVU = Field<1, 1>;    // Watchdog counter reload value update
            using PVU = Field<0, 1>;    // Watchdog prescaler value update
        };

        // Window register
        struct WINR : public Register<0x40002c10> {
            using WIN = Field<0, 12>;    // Watchdog counter window value
        };

    };

    // System window watchdog
    struct IWDG {
        // Control register
        struct CR : public Register<0x40003000> {
            using WDGA = Field<7, 1>;    // Activation bit
            using T = Field<0, 7>;    // 7-bit counter (MSB to LSB)
        };

        // Configuration register
        struct CFR : public Register<0x40003004> {
            using WDGTB = Field<11, 3>;    // Timer base
            using EWI = Field<9, 1>;    // Early wakeup interrupt
            using W = Field<0, 7>;    // 7-bit window value
        };

        // Status register
        struct SR : public Register<0x40003008> {
            using EWIF = Field<0, 1>;    // Early wakeup interrupt flag
        };

    };

    // Inter-integrated circuit
    struct I2C1 {
        // Control register 1
        struct CR1 : public Register<0x40005400> {
            using PE = Field<0, 1>;    // Peripheral enable
            using TXIE = Field<1, 1>;    // TX Interrupt enable
            using RXIE = Field<2, 1>;    // RX Interrupt enable
            using ADDRIE = Field<3, 1>;    // Address match interrupt enable (slave only)
            using NACKIE = Field<4, 1>;    // Not acknowledge received interrupt enable
            using STOPIE = Field<5, 1>;    // STOP detection Interrupt enable
            using TCIE = Field<6, 1>;    // Transfer Complete interrupt enable
            using ERRIE = Field<7, 1>;    // Error interrupts enable
            using DNF = Field<8, 4>;    // Digital noise filter
            using ANFOFF = Field<12, 1>;    // Analog noise filter OFF
            using TXDMAEN = Field<14, 1>;    // DMA transmission requests enable
            using RXDMAEN = Field<15, 1>;    // DMA reception requests enable
            using SBC = Field<16, 1>;    // Slave byte control
            using NOSTRETCH = Field<17, 1>;    // Clock stretching disable
            using WUPEN = Field<18, 1>;    // Wakeup from STOP enable
            using GCEN = Field<19, 1>;    // General call enable
            using SMBHEN = Field<20, 1>;    // SMBus Host address enable
            using SMBDEN = Field<21, 1>;    // SMBus Device Default address enable
            using ALERTEN = Field<22, 1>;    // SMBUS alert enable
            using PECEN = Field<23, 1>;    // PEC enable
        };

        // Control register 2
        struct CR2 : public Register<0x40005404> {
            using PECBYTE = Field<26, 1>;    // Packet error checking byte
            using AUTOEND = Field<25, 1>;    // Automatic end mode (master mode)
            using RELOAD = Field<24, 1>;    // NBYTES reload mode
            using NBYTES = Field<16, 8>;    // Number of bytes
            using NACK = Field<15, 1>;    // NACK generation (slave mode)
            using STOP = Field<14, 1>;    // Stop generation (master mode)
            using START = Field<13, 1>;    // Start generation
            using HEAD10R = Field<12, 1>;    // 10-bit address header only read direction (master receiver mode)
            using ADD10 = Field<11, 1>;    // 10-bit addressing mode (master mode)
            using RD_WRN = Field<10, 1>;    // Transfer direction (master mode)
            using SADD = Field<0, 10>;    // Slave address bit (master mode)
        };

        // Own address register 1
        struct OAR1 : public Register<0x40005408> {
            using OA1 = Field<0, 10>;    // Interface address
            using OA1MODE = Field<10, 1>;    // Own Address 1 10-bit mode
            using OA1EN = Field<15, 1>;    // Own Address 1 enable
        };

        // Own address register 2
        struct OAR2 : public Register<0x4000540c> {
            using OA2 = Field<1, 7>;    // Interface address
            using OA2MSK = Field<8, 3>;    // Own Address 2 masks
            using OA2EN = Field<15, 1>;    // Own Address 2 enable
        };

        // Timing register
        struct TIMINGR : public Register<0x40005410> {
            using SCLL = Field<0, 8>;    // SCL low period (master mode)
            using SCLH = Field<8, 8>;    // SCL high period (master mode)
            using SDADEL = Field<16, 4>;    // Data hold time
            using SCLDEL = Field<20, 4>;    // Data setup time
            using PRESC = Field<28, 4>;    // Timing prescaler
        };

        // Status register 1
        struct TIMEOUTR : public Register<0x40005414> {
            using TIMEOUTA = Field<0, 12>;    // Bus timeout A
            using TIDLE = Field<12, 1>;    // Idle clock timeout detection
            using TIMOUTEN = Field<15, 1>;    // Clock timeout enable
            using TIMEOUTB = Field<16, 12>;    // Bus timeout B
            using TEXTEN = Field<31, 1>;    // Extended clock timeout enable
        };

        // Interrupt and Status register
        struct ISR : public Register<0x40005418> {
            using ADDCODE = Field<17, 7>;    // Address match code (Slave mode)
            using DIR = Field<16, 1>;    // Transfer direction (Slave mode)
            using BUSY = Field<15, 1>;    // Bus busy
            using ALERT = Field<13, 1>;    // SMBus alert
            using TIMEOUT = Field<12, 1>;    // Timeout or t_low detection flag
            using PECERR = Field<11, 1>;    // PEC Error in reception
            using OVR = Field<10, 1>;    // Overrun/Underrun (slave mode)
            using ARLO = Field<9, 1>;    // Arbitration lost
            using BERR = Field<8, 1>;    // Bus error
            using TCR = Field<7, 1>;    // Transfer Complete Reload
            using TC = Field<6, 1>;    // Transfer Complete (master mode)
            using STOPF = Field<5, 1>;    // Stop detection flag
            using NACKF = Field<4, 1>;    // Not acknowledge received flag
            using ADDR = Field<3, 1>;    // Address matched (slave mode)
            using RXNE = Field<2, 1>;    // Receive data register not empty (receivers)
            using TXIS = Field<1, 1>;    // Transmit interrupt status (transmitters)
            using TXE = Field<0, 1>;    // Transmit data register empty (transmitters)
        };

        // Interrupt clear register
        struct ICR : public Register<0x4000541c> {
            using ALERTCF = Field<13, 1>;    // Alert flag clear
            using TIMOUTCF = Field<12, 1>;    // Timeout detection flag clear
            using PECCF = Field<11, 1>;    // PEC Error flag clear
            using OVRCF = Field<10, 1>;    // Overrun/Underrun flag clear
            using ARLOCF = Field<9, 1>;    // Arbitration lost flag clear
            using BERRCF = Field<8, 1>;    // Bus error flag clear
            using STOPCF = Field<5, 1>;    // Stop detection flag clear
            using NACKCF = Field<4, 1>;    // Not Acknowledge flag clear
            using ADDRCF = Field<3, 1>;    // Address Matched flag clear
        };

        // PEC register
        struct PECR : public Register<0x40005420> {
            using PEC = Field<0, 8>;    // Packet error checking register
        };

        // Receive data register
        struct RXDR : public Register<0x40005424> {
            using RXDATA = Field<0, 8>;    // 8-bit receive data
        };

        // Transmit data register
        struct TXDR : public Register<0x40005428> {
            using TXDATA = Field<0, 8>;    // 8-bit transmit data
        };

    };

    // Inter-integrated circuit
    struct I2C2 {
        // Control register 1
        struct CR1 : public Register<0x40005800> {
            using PE = Field<0, 1>;    // Peripheral enable
            using TXIE = Field<1, 1>;    // TX Interrupt enable
            using RXIE = Field<2, 1>;    // RX Interrupt enable
            using ADDRIE = Field<3, 1>;    // Address match interrupt enable (slave only)
            using NACKIE = Field<4, 1>;    // Not acknowledge received interrupt enable
            using STOPIE = Field<5, 1>;    // STOP detection Interrupt enable
            using TCIE = Field<6, 1>;    // Transfer Complete interrupt enable
            using ERRIE = Field<7, 1>;    // Error interrupts enable
            using DNF = Field<8, 4>;    // Digital noise filter
            using ANFOFF = Field<12, 1>;    // Analog noise filter OFF
            using TXDMAEN = Field<14, 1>;    // DMA transmission requests enable
            using RXDMAEN = Field<15, 1>;    // DMA reception requests enable
            using SBC = Field<16, 1>;    // Slave byte control
            using NOSTRETCH = Field<17, 1>;    // Clock stretching disable
            using WUPEN = Field<18, 1>;    // Wakeup from STOP enable
            using GCEN = Field<19, 1>;    // General call enable
            using SMBHEN = Field<20, 1>;    // SMBus Host address enable
            using SMBDEN = Field<21, 1>;    // SMBus Device Default address enable
            using ALERTEN = Field<22, 1>;    // SMBUS alert enable
            using PECEN = Field<23, 1>;    // PEC enable
        };

        // Control register 2
        struct CR2 : public Register<0x40005804> {
            using PECBYTE = Field<26, 1>;    // Packet error checking byte
            using AUTOEND = Field<25, 1>;    // Automatic end mode (master mode)
            using RELOAD = Field<24, 1>;    // NBYTES reload mode
            using NBYTES = Field<16, 8>;    // Number of bytes
            using NACK = Field<15, 1>;    // NACK generation (slave mode)
            using STOP = Field<14, 1>;    // Stop generation (master mode)
            using START = Field<13, 1>;    // Start generation
            using HEAD10R = Field<12, 1>;    // 10-bit address header only read direction (master receiver mode)
            using ADD10 = Field<11, 1>;    // 10-bit addressing mode (master mode)
            using RD_WRN = Field<10, 1>;    // Transfer direction (master mode)
            using SADD = Field<0, 10>;    // Slave address bit (master mode)
        };

        // Own address register 1
        struct OAR1 : public Register<0x40005808> {
            using OA1 = Field<0, 10>;    // Interface address
            using OA1MODE = Field<10, 1>;    // Own Address 1 10-bit mode
            using OA1EN = Field<15, 1>;    // Own Address 1 enable
        };

        // Own address register 2
        struct OAR2 : public Register<0x4000580c> {
            using OA2 = Field<1, 7>;    // Interface address
            using OA2MSK = Field<8, 3>;    // Own Address 2 masks
            using OA2EN = Field<15, 1>;    // Own Address 2 enable
        };

        // Timing register
        struct TIMINGR : public Register<0x40005810> {
            using SCLL = Field<0, 8>;    // SCL low period (master mode)
            using SCLH = Field<8, 8>;    // SCL high period (master mode)
            using SDADEL = Field<16, 4>;    // Data hold time
            using SCLDEL = Field<20, 4>;    // Data setup time
            using PRESC = Field<28, 4>;    // Timing prescaler
        };

        // Status register 1
        struct TIMEOUTR : public Register<0x40005814> {
            using TIMEOUTA = Field<0, 12>;    // Bus timeout A
            using TIDLE = Field<12, 1>;    // Idle clock timeout detection
            using TIMOUTEN = Field<15, 1>;    // Clock timeout enable
            using TIMEOUTB = Field<16, 12>;    // Bus timeout B
            using TEXTEN = Field<31, 1>;    // Extended clock timeout enable
        };

        // Interrupt and Status register
        struct ISR : public Register<0x40005818> {
            using ADDCODE = Field<17, 7>;    // Address match code (Slave mode)
            using DIR = Field<16, 1>;    // Transfer direction (Slave mode)
            using BUSY = Field<15, 1>;    // Bus busy
            using ALERT = Field<13, 1>;    // SMBus alert
            using TIMEOUT = Field<12, 1>;    // Timeout or t_low detection flag
            using PECERR = Field<11, 1>;    // PEC Error in reception
            using OVR = Field<10, 1>;    // Overrun/Underrun (slave mode)
            using ARLO = Field<9, 1>;    // Arbitration lost
            using BERR = Field<8, 1>;    // Bus error
            using TCR = Field<7, 1>;    // Transfer Complete Reload
            using TC = Field<6, 1>;    // Transfer Complete (master mode)
            using STOPF = Field<5, 1>;    // Stop detection flag
            using NACKF = Field<4, 1>;    // Not acknowledge received flag
            using ADDR = Field<3, 1>;    // Address matched (slave mode)
            using RXNE = Field<2, 1>;    // Receive data register not empty (receivers)
            using TXIS = Field<1, 1>;    // Transmit interrupt status (transmitters)
            using TXE = Field<0, 1>;    // Transmit data register empty (transmitters)
        };

        // Interrupt clear register
        struct ICR : public Register<0x4000581c> {
            using ALERTCF = Field<13, 1>;    // Alert flag clear
            using TIMOUTCF = Field<12, 1>;    // Timeout detection flag clear
            using PECCF = Field<11, 1>;    // PEC Error flag clear
            using OVRCF = Field<10, 1>;    // Overrun/Underrun flag clear
            using ARLOCF = Field<9, 1>;    // Arbitration lost flag clear
            using BERRCF = Field<8, 1>;    // Bus error flag clear
            using STOPCF = Field<5, 1>;    // Stop detection flag clear
            using NACKCF = Field<4, 1>;    // Not Acknowledge flag clear
            using ADDRCF = Field<3, 1>;    // Address Matched flag clear
        };

        // PEC register
        struct PECR : public Register<0x40005820> {
            using PEC = Field<0, 8>;    // Packet error checking register
        };

        // Receive data register
        struct RXDR : public Register<0x40005824> {
            using RXDATA = Field<0, 8>;    // 8-bit receive data
        };

        // Transmit data register
        struct TXDR : public Register<0x40005828> {
            using TXDATA = Field<0, 8>;    // 8-bit transmit data
        };

    };

    // Inter-integrated circuit
    struct I2C3 {
        // Control register 1
        struct CR1 : public Register<0x40007800> {
            using PE = Field<0, 1>;    // Peripheral enable
            using TXIE = Field<1, 1>;    // TX Interrupt enable
            using RXIE = Field<2, 1>;    // RX Interrupt enable
            using ADDRIE = Field<3, 1>;    // Address match interrupt enable (slave only)
            using NACKIE = Field<4, 1>;    // Not acknowledge received interrupt enable
            using STOPIE = Field<5, 1>;    // STOP detection Interrupt enable
            using TCIE = Field<6, 1>;    // Transfer Complete interrupt enable
            using ERRIE = Field<7, 1>;    // Error interrupts enable
            using DNF = Field<8, 4>;    // Digital noise filter
            using ANFOFF = Field<12, 1>;    // Analog noise filter OFF
            using TXDMAEN = Field<14, 1>;    // DMA transmission requests enable
            using RXDMAEN = Field<15, 1>;    // DMA reception requests enable
            using SBC = Field<16, 1>;    // Slave byte control
            using NOSTRETCH = Field<17, 1>;    // Clock stretching disable
            using WUPEN = Field<18, 1>;    // Wakeup from STOP enable
            using GCEN = Field<19, 1>;    // General call enable
            using SMBHEN = Field<20, 1>;    // SMBus Host address enable
            using SMBDEN = Field<21, 1>;    // SMBus Device Default address enable
            using ALERTEN = Field<22, 1>;    // SMBUS alert enable
            using PECEN = Field<23, 1>;    // PEC enable
        };

        // Control register 2
        struct CR2 : public Register<0x40007804> {
            using PECBYTE = Field<26, 1>;    // Packet error checking byte
            using AUTOEND = Field<25, 1>;    // Automatic end mode (master mode)
            using RELOAD = Field<24, 1>;    // NBYTES reload mode
            using NBYTES = Field<16, 8>;    // Number of bytes
            using NACK = Field<15, 1>;    // NACK generation (slave mode)
            using STOP = Field<14, 1>;    // Stop generation (master mode)
            using START = Field<13, 1>;    // Start generation
            using HEAD10R = Field<12, 1>;    // 10-bit address header only read direction (master receiver mode)
            using ADD10 = Field<11, 1>;    // 10-bit addressing mode (master mode)
            using RD_WRN = Field<10, 1>;    // Transfer direction (master mode)
            using SADD = Field<0, 10>;    // Slave address bit (master mode)
        };

        // Own address register 1
        struct OAR1 : public Register<0x40007808> {
            using OA1 = Field<0, 10>;    // Interface address
            using OA1MODE = Field<10, 1>;    // Own Address 1 10-bit mode
            using OA1EN = Field<15, 1>;    // Own Address 1 enable
        };

        // Own address register 2
        struct OAR2 : public Register<0x4000780c> {
            using OA2 = Field<1, 7>;    // Interface address
            using OA2MSK = Field<8, 3>;    // Own Address 2 masks
            using OA2EN = Field<15, 1>;    // Own Address 2 enable
        };

        // Timing register
        struct TIMINGR : public Register<0x40007810> {
            using SCLL = Field<0, 8>;    // SCL low period (master mode)
            using SCLH = Field<8, 8>;    // SCL high period (master mode)
            using SDADEL = Field<16, 4>;    // Data hold time
            using SCLDEL = Field<20, 4>;    // Data setup time
            using PRESC = Field<28, 4>;    // Timing prescaler
        };

        // Status register 1
        struct TIMEOUTR : public Register<0x40007814> {
            using TIMEOUTA = Field<0, 12>;    // Bus timeout A
            using TIDLE = Field<12, 1>;    // Idle clock timeout detection
            using TIMOUTEN = Field<15, 1>;    // Clock timeout enable
            using TIMEOUTB = Field<16, 12>;    // Bus timeout B
            using TEXTEN = Field<31, 1>;    // Extended clock timeout enable
        };

        // Interrupt and Status register
        struct ISR : public Register<0x40007818> {
            using ADDCODE = Field<17, 7>;    // Address match code (Slave mode)
            using DIR = Field<16, 1>;    // Transfer direction (Slave mode)
            using BUSY = Field<15, 1>;    // Bus busy
            using ALERT = Field<13, 1>;    // SMBus alert
            using TIMEOUT = Field<12, 1>;    // Timeout or t_low detection flag
            using PECERR = Field<11, 1>;    // PEC Error in reception
            using OVR = Field<10, 1>;    // Overrun/Underrun (slave mode)
            using ARLO = Field<9, 1>;    // Arbitration lost
            using BERR = Field<8, 1>;    // Bus error
            using TCR = Field<7, 1>;    // Transfer Complete Reload
            using TC = Field<6, 1>;    // Transfer Complete (master mode)
            using STOPF = Field<5, 1>;    // Stop detection flag
            using NACKF = Field<4, 1>;    // Not acknowledge received flag
            using ADDR = Field<3, 1>;    // Address matched (slave mode)
            using RXNE = Field<2, 1>;    // Receive data register not empty (receivers)
            using TXIS = Field<1, 1>;    // Transmit interrupt status (transmitters)
            using TXE = Field<0, 1>;    // Transmit data register empty (transmitters)
        };

        // Interrupt clear register
        struct ICR : public Register<0x4000781c> {
            using ALERTCF = Field<13, 1>;    // Alert flag clear
            using TIMOUTCF = Field<12, 1>;    // Timeout detection flag clear
            using PECCF = Field<11, 1>;    // PEC Error flag clear
            using OVRCF = Field<10, 1>;    // Overrun/Underrun flag clear
            using ARLOCF = Field<9, 1>;    // Arbitration lost flag clear
            using BERRCF = Field<8, 1>;    // Bus error flag clear
            using STOPCF = Field<5, 1>;    // Stop detection flag clear
            using NACKCF = Field<4, 1>;    // Not Acknowledge flag clear
            using ADDRCF = Field<3, 1>;    // Address Matched flag clear
        };

        // PEC register
        struct PECR : public Register<0x40007820> {
            using PEC = Field<0, 8>;    // Packet error checking register
        };

        // Receive data register
        struct RXDR : public Register<0x40007824> {
            using RXDATA = Field<0, 8>;    // 8-bit receive data
        };

        // Transmit data register
        struct TXDR : public Register<0x40007828> {
            using TXDATA = Field<0, 8>;    // 8-bit transmit data
        };

    };

    // Flash
    struct FLASH {
        // Access control register
        struct ACR : public Register<0x40022000> {
            using LATENCY = Field<0, 4>;    // Latency
            using PRFTEN = Field<8, 1>;    // Prefetch enable
            using ICEN = Field<9, 1>;    // Instruction cache enable
            using DCEN = Field<10, 1>;    // Data cache enable
            using ICRST = Field<11, 1>;    // Instruction cache reset
            using DCRST = Field<12, 1>;    // Data cache reset
            using RUN_PD = Field<13, 1>;    // Flash Power-down mode during Low-power run mode
            using SLEEP_PD = Field<14, 1>;    // Flash Power-down mode during Low-power sleep mode
            using DBG_SWEN = Field<18, 1>;    // Debug software enable
        };

        // Power down key register
        struct PDKEYR : public Register<0x40022004> {
            using Field = Field<0, 32>;    // RUN_PD in FLASH_ACR key
        };

        // Flash key register
        struct KEYR : public Register<0x40022008> {
            using Field = Field<0, 32>;    // KEYR
        };

        // Option byte key register
        struct OPTKEYR : public Register<0x4002200c> {
            using Field = Field<0, 32>;    // Option byte key
        };

        // Status register
        struct SR : public Register<0x40022010> {
            using EOP = Field<0, 1>;    // End of operation
            using OPERR = Field<1, 1>;    // Operation error
            using PROGERR = Field<3, 1>;    // Programming error
            using WRPERR = Field<4, 1>;    // Write protected error
            using PGAERR = Field<5, 1>;    // Programming alignment error
            using SIZERR = Field<6, 1>;    // Size error
            using PGSERR = Field<7, 1>;    // Programming sequence error
            using MISERR = Field<8, 1>;    // Fast programming data miss error
            using FASTERR = Field<9, 1>;    // Fast programming error
            using RDERR = Field<14, 1>;    // PCROP read error
            using OPTVERR = Field<15, 1>;    // Option validity error
            using BSY = Field<16, 1>;    // Busy
        };

        // Flash control register
        struct CR : public Register<0x40022014> {
            using PG = Field<0, 1>;    // Programming
            using PER = Field<1, 1>;    // Page erase
            using MER1 = Field<2, 1>;    // Bank 1 Mass erase
            using PNB = Field<3, 7>;    // Page number
            using STRT = Field<16, 1>;    // Start
            using OPTSTRT = Field<17, 1>;    // Options modification start
            using FSTPG = Field<18, 1>;    // Fast programming
            using EOPIE = Field<24, 1>;    // End of operation interrupt enable
            using ERRIE = Field<25, 1>;    // Error interrupt enable
            using RDERRIE = Field<26, 1>;    // PCROP read error interrupt enable
            using OBL_LAUNCH = Field<27, 1>;    // Force the option byte loading
            using SEC_PROT1 = Field<28, 1>;    // SEC_PROT1
            using OPTLOCK = Field<30, 1>;    // Options Lock
            using LOCK = Field<31, 1>;    // FLASH_CR Lock
        };

        // Flash ECC register
        struct ECCR : public Register<0x40022018> {
            using ADDR_ECC = Field<0, 19>;    // ECC fail address
            using BK_ECC = Field<21, 1>;    // BK_ECC
            using SYSF_ECC = Field<22, 1>;    // SYSF_ECC
            using ECCIE = Field<24, 1>;    // ECCIE
            using ECCC2 = Field<28, 1>;    // ECC correction
            using ECCD2 = Field<29, 1>;    // ECC2 detection
            using ECCC = Field<30, 1>;    // ECC correction
            using ECCD = Field<31, 1>;    // ECC detection
        };

        // Flash option register
        struct OPTR : public Register<0x40022020> {
            using RDP = Field<0, 8>;    // Read protection level
            using BOR_LEV = Field<8, 3>;    // BOR reset Level
            using nRST_STOP = Field<12, 1>;    // nRST_STOP
            using nRST_STDBY = Field<13, 1>;    // nRST_STDBY
            using nRST_SHDW = Field<14, 1>;    // nRST_SHDW
            using IDWG_SW = Field<16, 1>;    // Independent watchdog selection
            using IWDG_STOP = Field<17, 1>;    // Independent watchdog counter freeze in Stop mode
            using IWDG_STDBY = Field<18, 1>;    // Independent watchdog counter freeze in Standby mode
            using WWDG_SW = Field<19, 1>;    // Window watchdog selection
            using nBOOT1 = Field<23, 1>;    // Boot configuration
            using SRAM2_PE = Field<24, 1>;    // SRAM2 parity check enable
            using SRAM2_RST = Field<25, 1>;    // SRAM2 Erase when system reset
            using nSWBOOT0 = Field<26, 1>;    // nSWBOOT0
            using nBOOT0 = Field<27, 1>;    // nBOOT0
            using NRST_MODE = Field<28, 2>;    // NRST_MODE
            using IRHEN = Field<30, 1>;    // IRHEN
        };

        // Flash Bank 1 PCROP Start address register
        struct PCROP1SR : public Register<0x40022024> {
            using PCROP1_STRT = Field<0, 15>;    // Bank 1 PCROP area start offset
        };

        // Flash Bank 1 PCROP End address register
        struct PCROP1ER : public Register<0x40022028> {
            using PCROP1_END = Field<0, 15>;    // Bank 1 PCROP area end offset
            using PCROP_RDP = Field<31, 1>;    // PCROP area preserved when RDP level decreased
        };

        // Flash Bank 1 WRP area A address register
        struct WRP1AR : public Register<0x4002202c> {
            using WRP1A_STRT = Field<0, 7>;    // Bank 1 WRP first area start offset
            using WRP1A_END = Field<16, 7>;    // Bank 1 WRP first area A end offset
        };

        // Flash Bank 1 WRP area B address register
        struct WRP1BR : public Register<0x40022030> {
            using WRP1B_STRT = Field<0, 7>;    // Bank 1 WRP second area B end offset
            using WRP1B_END = Field<16, 7>;    // Bank 1 WRP second area B start offset
        };

        // securable area bank1 register
        struct SEC1R : public Register<0x40022070> {
            using BOOT_LOCK = Field<16, 1>;    // BOOT_LOCK
            using SEC_SIZE1 = Field<0, 8>;    // SEC_SIZE1
        };

    };

    // Debug support
    struct DBGMCU {
        // MCU Device ID Code Register
        struct IDCODE : public Register<0xe0042000> {
            using DEV_ID = Field<0, 16>;    // Device Identifier
            using REV_ID = Field<16, 16>;    // Revision Identifier
        };

        // Debug MCU Configuration Register
        struct CR : public Register<0xe0042004> {
            using DBG_SLEEP = Field<0, 1>;    // Debug Sleep Mode
            using DBG_STOP = Field<1, 1>;    // Debug Stop Mode
            using DBG_STANDBY = Field<2, 1>;    // Debug Standby Mode
            using TRACE_IOEN = Field<5, 1>;    // Trace pin assignment control
            using TRACE_MODE = Field<6, 2>;    // Trace pin assignment control
        };

        // APB Low Freeze Register 1
        struct APB1L_FZ : public Register<0xe0042008> {
            using DBG_TIMER2_STOP = Field<0, 1>;    // Debug Timer 2 stopped when Core is halted
            using DBG_TIM3_STOP = Field<1, 1>;    // TIM3 counter stopped when core is halted
            using DBG_TIM4_STOP = Field<2, 1>;    // TIM4 counter stopped when core is halted
            using DBG_TIM5_STOP = Field<3, 1>;    // TIM5 counter stopped when core is halted
            using DBG_TIMER6_STOP = Field<4, 1>;    // Debug Timer 6 stopped when Core is halted
            using DBG_TIM7_STOP = Field<5, 1>;    // TIM7 counter stopped when core is halted
            using DBG_RTC_STOP = Field<10, 1>;    // Debug RTC stopped when Core is halted
            using DBG_WWDG_STOP = Field<11, 1>;    // Debug Window Wachdog stopped when Core is halted
            using DBG_IWDG_STOP = Field<12, 1>;    // Debug Independent Wachdog stopped when Core is halted
            using DBG_I2C1_STOP = Field<21, 1>;    // I2C1 SMBUS timeout mode stopped when core is halted
            using DBG_I2C2_STOP = Field<22, 1>;    // I2C2 SMBUS timeout mode stopped when core is halted
            using DBG_I2C3_STOP = Field<30, 1>;    // I2C3 SMBUS timeout mode stopped when core is halted
            using DBG_LPTIMER_STOP = Field<31, 1>;    // LPTIM1 counter stopped when core is halted
        };

        // APB Low Freeze Register 2
        struct APB1H_FZ : public Register<0xe004200c> {
            using DBG_I2C4_STOP = Field<1, 1>;    // DBG_I2C4_STOP
        };

        // APB High Freeze Register
        struct APB2_FZ : public Register<0xe0042010> {
            using DBG_TIM1_STOP = Field<11, 1>;    // TIM1 counter stopped when core is halted
            using DBG_TIM8_STOP = Field<13, 1>;    // TIM8 counter stopped when core is halted
            using DBG_TIM15_STOP = Field<16, 1>;    // TIM15 counter stopped when core is halted
            using DBG_TIM16_STOP = Field<17, 1>;    // TIM16 counter stopped when core is halted
            using DBG_TIM17_STOP = Field<18, 1>;    // TIM17 counter stopped when core is halted
            using DBG_TIM20_STOP = Field<20, 1>;    // TIM20counter stopped when core is halted
            using DBG_HRTIM0_STOP = Field<26, 1>;    // DBG_HRTIM0_STOP
            using DBG_HRTIM1_STOP = Field<27, 1>;    // DBG_HRTIM0_STOP
            using DBG_HRTIM2_STOP = Field<28, 1>;    // DBG_HRTIM0_STOP
            using DBG_HRTIM3_STOP = Field<29, 1>;    // DBG_HRTIM0_STOP
        };

    };

    // Reset and clock control
    struct RCC {
        // Clock control register
        struct CR : public Register<0x40021000> {
            using PLLSYSRDY = Field<25, 1>;    // Main PLL clock ready flag
            using PLLSYSON = Field<24, 1>;    // Main PLL enable
            using HSECSSON = Field<19, 1>;    // Clock security system enable
            using HSEBYP = Field<18, 1>;    // HSE crystal oscillator bypass
            using HSERDY = Field<17, 1>;    // HSE clock ready flag
            using HSEON = Field<16, 1>;    // HSE clock enable
            using HSIRDY = Field<10, 1>;    // HSI clock ready flag
            using HSIKERON = Field<9, 1>;    // HSI always enable for peripheral kernels
            using HSION = Field<8, 1>;    // HSI clock enable
        };

        // Internal clock sources calibration register
        struct ICSCR : public Register<0x40021004> {
            using HSICAL0 = Field<16, 8>;    // Internal High Speed clock Calibration
            using HSITRIM = Field<24, 7>;    // Internal High Speed clock trimming
        };

        // Clock configuration register
        struct CFGR : public Register<0x40021008> {
            using MCOPRE = Field<28, 3>;    // Microcontroller clock output prescaler
            using MCOSEL = Field<24, 4>;    // Microcontroller clock output
            using PPRE2 = Field<11, 3>;    // APB high-speed prescaler (APB2)
            using PPRE1 = Field<8, 3>;    // PB low-speed prescaler (APB1)
            using HPRE = Field<4, 4>;    // AHB prescaler
            using SWS = Field<2, 2>;    // System clock switch status
            using SW = Field<0, 2>;    // System clock switch
        };

        // PLL configuration register
        struct PLLSYSCFGR : public Register<0x4002100c> {
            using PLLSYSPDIV = Field<27, 5>;    // Main PLL division factor for PLLSAI2CLK
            using PLLSYSR = Field<25, 2>;    // Main PLL division factor for PLLCLK (system clock)
            using PLLSYSREN = Field<24, 1>;    // Main PLL PLLCLK output enable
            using PLLSYSQ = Field<21, 2>;    // Main PLL division factor for PLLUSB1CLK(48 MHz clock)
            using PLLSYSQEN = Field<20, 1>;    // Main PLL PLLUSB1CLK output enable
            using PLLSYSP = Field<17, 1>;    // Main PLL division factor for PLLSAI3CLK (SAI1 and SAI2 clock)
            using PLLPEN = Field<16, 1>;    // Main PLL PLLSAI3CLK output enable
            using PLLSYSN = Field<8, 7>;    // Main PLL multiplication factor for VCO
            using PLLSYSM = Field<4, 4>;    // Division factor for the main PLL and audio PLL (PLLSAI1 and PLLSAI2) input clock
            using PLLSRC = Field<0, 2>;    // Main PLL, PLLSAI1 and PLLSAI2 entry clock source
        };

        // Clock interrupt enable register
        struct CIER : public Register<0x40021018> {
            using LSIRDYIE = Field<0, 1>;    // LSI ready interrupt enable
            using LSERDYIE = Field<1, 1>;    // LSE ready interrupt enable
            using HSIRDYIE = Field<3, 1>;    // HSI ready interrupt enable
            using HSERDYIE = Field<4, 1>;    // HSE ready interrupt enable
            using PLLSYSRDYIE = Field<5, 1>;    // PLL ready interrupt enable
            using LSECSSIE = Field<9, 1>;    // LSE clock security system interrupt enable
            using RC48RDYIE = Field<10, 1>;    // HSI48 ready interrupt enable
        };

        // Clock interrupt flag register
        struct CIFR : public Register<0x4002101c> {
            using LSIRDYF = Field<0, 1>;    // LSI ready interrupt flag
            using LSERDYF = Field<1, 1>;    // LSE ready interrupt flag
            using HSIRDYF = Field<3, 1>;    // HSI ready interrupt flag
            using HSERDYF = Field<4, 1>;    // HSE ready interrupt flag
            using PLLSYSRDYF = Field<5, 1>;    // PLL ready interrupt flag
            using HSECSSF = Field<8, 1>;    // Clock security system interrupt flag
            using LSECSSF = Field<9, 1>;    // LSE Clock security system interrupt flag
            using RC48RDYF = Field<10, 1>;    // HSI48 ready interrupt flag
        };

        // Clock interrupt clear register
        struct CICR : public Register<0x40021020> {
            using LSIRDYC = Field<0, 1>;    // LSI ready interrupt clear
            using LSERDYC = Field<1, 1>;    // LSE ready interrupt clear
            using HSIRDYC = Field<3, 1>;    // HSI ready interrupt clear
            using HSERDYC = Field<4, 1>;    // HSE ready interrupt clear
            using PLLSYSRDYC = Field<5, 1>;    // PLL ready interrupt clear
            using HSECSSC = Field<8, 1>;    // Clock security system interrupt clear
            using LSECSSC = Field<9, 1>;    // LSE Clock security system interrupt clear
            using RC48RDYC = Field<10, 1>;    // HSI48 oscillator ready interrupt clear
        };

        // AHB1 peripheral reset register
        struct AHB1RSTR : public Register<0x40021028> {
            using DMA1RST = Field<0, 1>;    // DMA1 reset
            using DMA2RST = Field<1, 1>;    // DMA2 reset
            using DMAMUX1RST = Field<2, 1>;    // DMAMUXRST
            using CORDICRST = Field<3, 1>;    // CORDIC reset
            using MATRIXRST = Field<4, 1>;    // MATRIX reset
            using FLITFRST_ = Field<8, 1>;    // FLITF reset
            using CRCRST = Field<12, 1>;    // CRC reset
        };

        // AHB2 peripheral reset register
        struct AHB2RSTR : public Register<0x4002102c> {
            using GPIOARST = Field<0, 1>;    // IO port A reset
            using GPIOBRST = Field<1, 1>;    // IO port B reset
            using GPIOCRST = Field<2, 1>;    // IO port C reset
            using GPIODRST = Field<3, 1>;    // IO port D reset
            using GPIOERST = Field<4, 1>;    // IO port E reset
            using GPIOFRST = Field<5, 1>;    // IO port F reset
            using GPIOGRST = Field<6, 1>;    // IO port G reset
            using ADC12RST = Field<13, 1>;    // ADC reset
            using ADC345RST_ = Field<14, 1>;    // SAR ADC345 interface reset
            using DAC1RST_ = Field<16, 1>;    // DAC1 interface reset
            using DAC2RST = Field<17, 1>;    // DAC2 interface reset
            using DAC3RST = Field<18, 1>;    // DAC3 interface reset
            using DAC4RST = Field<19, 1>;    // DAC4 interface reset
            using CRYPTRST = Field<24, 1>;    // Cryptography module reset
            using RNGRST = Field<26, 1>;    // Random Number Generator module reset
        };

        // AHB3 peripheral reset register
        struct AHB3RSTR : public Register<0x40021030> {
            using FMCRST = Field<0, 1>;    // Flexible memory controller reset
            using QUADSPI1RST = Field<8, 1>;    // Quad SPI 1 module reset
        };

        // APB1 peripheral reset register 1
        struct APB1RSTR1 : public Register<0x40021038> {
            using LPTIM1RST = Field<31, 1>;    // Low Power Timer 1 reset
            using I2C3 = Field<30, 1>;    // I2C3 interface reset
            using PWRRST = Field<28, 1>;    // Power interface reset
            using FDCANRST = Field<25, 1>;    // FDCAN reset
            using USBDRST = Field<23, 1>;    // USBD reset
            using I2C2RST = Field<22, 1>;    // I2C2 reset
            using I2C1RST = Field<21, 1>;    // I2C1 reset
            using UART5RST = Field<20, 1>;    // UART5 reset
            using UART4RST = Field<19, 1>;    // UART4 reset
            using USART3RST = Field<18, 1>;    // USART3 reset
            using USART2RST = Field<17, 1>;    // USART2 reset
            using SPI3RST = Field<15, 1>;    // SPI3 reset
            using SPI2RST = Field<14, 1>;    // SPI2 reset
            using CRSRST = Field<8, 1>;    // Clock recovery system reset
            using TIM7RST = Field<5, 1>;    // TIM7 timer reset
            using TIM6RST = Field<4, 1>;    // TIM6 timer reset
            using TIM5RST = Field<3, 1>;    // TIM5 timer reset
            using TIM4RST = Field<2, 1>;    // TIM3 timer reset
            using TIM3RST = Field<1, 1>;    // TIM3 timer reset
            using TIM2RST = Field<0, 1>;    // TIM2 timer reset
        };

        // APB1 peripheral reset register 2
        struct APB1RSTR2 : public Register<0x4002103c> {
            using LPUART1RST = Field<0, 1>;    // Low-power UART 1 reset
            using I2C4RST = Field<1, 1>;    // I2C4 reset
            using USBPDRST = Field<8, 1>;    // USBPD reset
        };

        // APB2 peripheral reset register
        struct APB2RSTR : public Register<0x40021040> {
            using SYSCFGRST = Field<0, 1>;    // System configuration (SYSCFG) reset
            using TIM1RST = Field<11, 1>;    // TIM1 timer reset
            using SPI1RST = Field<12, 1>;    // SPI1 reset
            using TIM8RST = Field<13, 1>;    // TIM8 timer reset
            using USART1RST = Field<14, 1>;    // USART1 reset
            using SPI4RST = Field<15, 1>;    // SPI 4 reset
            using TIM15RST = Field<16, 1>;    // TIM15 timer reset
            using TIM16RST = Field<17, 1>;    // TIM16 timer reset
            using TIM17RST = Field<18, 1>;    // TIM17 timer reset
            using TIM20RST = Field<20, 1>;    // Timer 20 reset
            using SAI1RST = Field<21, 1>;    // Serial audio interface 1 (SAI1) reset
            using HRTIM1RST = Field<26, 1>;    // HRTIMER reset
        };

        // AHB1 peripheral clock enable register
        struct AHB1ENR : public Register<0x40021048> {
            using DMA1EN = Field<0, 1>;    // DMA1 clock enable
            using DMA2EN = Field<1, 1>;    // DMA2 clock enable
            using DMAMUXEN = Field<2, 1>;    // DMAMUX clock enable
            using CORDICEN = Field<3, 1>;    // CORDIC clock enable
            using FMACEN = Field<4, 1>;    // FMAC clock enable
            using FLITFEN = Field<8, 1>;    // FLITF clock enable
            using CRCEN = Field<12, 1>;    // CRC clock enable
        };

        // AHB2 peripheral clock enable register
        struct AHB2ENR : public Register<0x4002104c> {
            using GPIOAEN = Field<0, 1>;    // IO port A clock enable
            using GPIOBEN = Field<1, 1>;    // IO port B clock enable
            using GPIOCEN = Field<2, 1>;    // IO port C clock enable
            using GPIODEN = Field<3, 1>;    // IO port D clock enable
            using GPIOEEN = Field<4, 1>;    // IO port E clock enable
            using GPIOFEN = Field<5, 1>;    // IO port F clock enable
            using GPIOGEN = Field<6, 1>;    // IO port G clock enable
            using ADC12EN = Field<13, 1>;    // ADC clock enable
            using ADC345EN = Field<14, 1>;    // DCMI clock enable
            using DAC1 = Field<16, 1>;    // AES accelerator clock enable
            using DAC2 = Field<17, 1>;    // HASH clock enable
            using DAC3 = Field<18, 1>;    // Random Number Generator clock enable
            using DAC4 = Field<19, 1>;    // DAC4 clock enable
            using CRYPTEN = Field<24, 1>;    // Cryptography clock enable
            using RNGEN = Field<26, 1>;    // Random Number Generator clock enable
        };

        // AHB3 peripheral clock enable register
        struct AHB3ENR : public Register<0x40021050> {
            using FMCEN = Field<0, 1>;    // Flexible memory controller clock enable
            using QUADSPI1EN = Field<8, 1>;    // Quad SPI 1 module clock enable
        };

        // APB1ENR1
        struct APB1ENR1 : public Register<0x40021058> {
            using TIM2EN = Field<0, 1>;    // TIM2 timer clock enable
            using TIM3EN = Field<1, 1>;    // TIM3 timer clock enable
            using TIM4EN = Field<2, 1>;    // TIM4 timer clock enable
            using TIM5EN = Field<3, 1>;    // TIM5 timer clock enable
            using TIM6EN = Field<4, 1>;    // TIM6 timer clock enable
            using TIM7EN = Field<5, 1>;    // TIM7 timer clock enable
            using CRSEN = Field<8, 1>;    // CRSclock enable
            using RTCAPBEN = Field<10, 1>;    // RTC APB clock enable
            using WWDGEN = Field<11, 1>;    // Window watchdog clock enable
            using SPI2EN = Field<14, 1>;    // SPI2 clock enable
            using SP3EN = Field<15, 1>;    // SPI3 clock enable
            using USART2EN = Field<17, 1>;    // USART2 clock enable
            using USART3EN = Field<18, 1>;    // USART3 clock enable
            using UART4EN = Field<19, 1>;    // UART4 clock enable
            using UART5EN = Field<20, 1>;    // UART5 clock enable
            using I2C1EN = Field<21, 1>;    // I2C1 clock enable
            using I2C2EN = Field<22, 1>;    // I2C2 clock enable
            using USBDEN = Field<23, 1>;    // USBDclock enable
            using FDCANEN = Field<25, 1>;    // FDCAN clock enable
            using PWREN = Field<28, 1>;    // Power interface clock enable
            using I2C3 = Field<30, 1>;    // OPAMP interface clock enable
            using LPTIM1EN = Field<31, 1>;    // Low power timer 1 clock enable
        };

        // APB1 peripheral clock enable register 2
        struct APB1ENR2 : public Register<0x4002105c> {
            using LPUART1EN = Field<0, 1>;    // Low power UART 1 clock enable
            using I2C4EN = Field<1, 1>;    // I2C4 clock enable
            using USBPDEN = Field<8, 1>;    // USBPD clock enable
        };

        // APB2ENR
        struct APB2ENR : public Register<0x40021060> {
            using SYSCFGEN = Field<0, 1>;    // SYSCFG clock enable
            using TIM1EN = Field<11, 1>;    // TIM1 timer clock enable
            using SPI1EN = Field<12, 1>;    // SPI1 clock enable
            using TIM8EN = Field<13, 1>;    // TIM8 timer clock enable
            using USART1EN = Field<14, 1>;    // USART1clock enable
            using SPI4EN = Field<15, 1>;    // SPI 4 clock enable
            using TIM15EN = Field<16, 1>;    // TIM15 timer clock enable
            using TIM16EN = Field<17, 1>;    // TIM16 timer clock enable
            using TIM17EN = Field<18, 1>;    // TIM17 timer clock enable
            using TIM20EN = Field<20, 1>;    // Timer 20 clock enable
            using SAI1EN = Field<21, 1>;    // SAI1 clock enable
            using HRTIMEREN = Field<26, 1>;    // HRTIMER clock enable
        };

        // AHB1 peripheral clocks enable in Sleep and Stop modes register
        struct AHB1SMENR : public Register<0x40021068> {
            using DMA1SMEN = Field<0, 1>;    // DMA1 clocks enable during Sleep and Stop modes
            using DMA2SMEN = Field<1, 1>;    // DMA2 clocks enable during Sleep and Stop modes
            using DMAMUX1SMEN = Field<2, 1>;    // DMAMUX clock enable during Sleep and Stop modes
            using CORDICSMEN = Field<3, 1>;    // CORDIC clock enable during sleep mode
            using FLASHSMEN = Field<8, 1>;    // Flash memory interface clocks enable during Sleep and Stop modes
            using SRAM1SMEN = Field<9, 1>;    // SRAM1 interface clocks enable during Sleep and Stop modes
            using CRCSMEN = Field<12, 1>;    // CRCSMEN
            using FMACSMEN = Field<4, 1>;    // FMACSM clock enable
        };

        // AHB2 peripheral clocks enable in Sleep and Stop modes register
        struct AHB2SMENR : public Register<0x4002106c> {
            using GPIOASMEN = Field<0, 1>;    // IO port A clocks enable during Sleep and Stop modes
            using GPIOBSMEN = Field<1, 1>;    // IO port B clocks enable during Sleep and Stop modes
            using GPIOCSMEN = Field<2, 1>;    // IO port C clocks enable during Sleep and Stop modes
            using GPIODSMEN = Field<3, 1>;    // IO port D clocks enable during Sleep and Stop modes
            using GPIOESMEN = Field<4, 1>;    // IO port E clocks enable during Sleep and Stop modes
            using GPIOFSMEN = Field<5, 1>;    // IO port F clocks enable during Sleep and Stop modes
            using GPIOGSMEN = Field<6, 1>;    // IO port G clocks enable during Sleep and Stop modes
            using SRAM2SMEN = Field<9, 1>;    // SRAM2 interface clocks enable during Sleep and Stop modes
            using SRAM3SMEN = Field<10, 1>;    // SRAM2 interface clocks enable during Sleep and Stop modes
            using AD12CSMEN = Field<13, 1>;    // ADC clocks enable during Sleep and Stop modes
            using ADC345SMEN = Field<14, 1>;    // DCMI clock enable during Sleep and Stop modes
            using DAC1SMEN = Field<16, 1>;    // AES accelerator clocks enable during Sleep and Stop modes
            using DAC2SMEN = Field<17, 1>;    // HASH clock enable during Sleep and Stop modes
            using DAC3SMEN = Field<18, 1>;    // DAC3 clock enable during sleep mode
            using DAC4SMEN = Field<19, 1>;    // DAC4 clock enable during sleep mode
            using CRYPTSMEN = Field<24, 1>;    // Cryptography clock enable during sleep mode
            using RNGSMEN = Field<26, 1>;    // Random Number Generator clock enable during sleep mode
        };

        // AHB3 peripheral clocks enable in Sleep and Stop modes register
        struct AHB3SMENR : public Register<0x40021070> {
            using FMCSMEN = Field<0, 1>;    // Flexible memory controller clocks enable during Sleep and Stop modes
            using QUADSPI1SMEN = Field<8, 1>;    // QUAD SPI 1 module clock enable during sleep mode
        };

        // APB1SMENR1
        struct APB1SMENR1 : public Register<0x40021078> {
            using TIM2SMEN = Field<0, 1>;    // TIM2 timer clocks enable during Sleep and Stop modes
            using TIM3SMEN = Field<1, 1>;    // TIM3 timer clocks enable during Sleep and Stop modes
            using TIM4SMEN = Field<2, 1>;    // TIM4 timer clocks enable during Sleep and Stop modes
            using TIM5SMEN = Field<3, 1>;    // TIM5 timer clocks enable during Sleep and Stop modes
            using TIM6SMEN = Field<4, 1>;    // TIM6 timer clocks enable during Sleep and Stop modes
            using TIM7SMEN = Field<5, 1>;    // TIM7 timer clocks enable during Sleep and Stop modes
            using CRSSMEN = Field<8, 1>;    // CRS clock enable during sleep mode
            using RTCAPBSMEN = Field<10, 1>;    // RTC APB clock enable during Sleep and Stop modes
            using WWDGSMEN = Field<11, 1>;    // Window watchdog clocks enable during Sleep and Stop modes
            using SPI2SMEN = Field<14, 1>;    // SPI2 clocks enable during Sleep and Stop modes
            using SP3SMEN = Field<15, 1>;    // SPI3 clocks enable during Sleep and Stop modes
            using USART2SMEN = Field<17, 1>;    // USART2 clocks enable during Sleep and Stop modes
            using USART3SMEN = Field<18, 1>;    // USART3 clocks enable during Sleep and Stop modes
            using UART4SMEN = Field<19, 1>;    // UART4 clocks enable during Sleep and Stop modes
            using UART5SMEN = Field<20, 1>;    // UART5 clocks enable during Sleep and Stop modes
            using I2C1SMEN = Field<21, 1>;    // I2C1 clocks enable during Sleep and Stop modes
            using I2C2SMEN = Field<22, 1>;    // I2C2 clocks enable during Sleep and Stop modes
            using I2C3SMEN = Field<23, 1>;    // I2C3 clocks enable during Sleep and Stop modes
            using FDCANSMEN = Field<25, 1>;    // FDCAN clock enable during sleep mode
            using PWRSMEN = Field<28, 1>;    // Power interface clocks enable during Sleep and Stop modes
            using I2C3SMEN_3 = Field<30, 1>;    // I2C 3 interface clock enable during sleep mode
            using LPTIM1SMEN = Field<31, 1>;    // Low Power Timer1 clock enable during sleep mode
        };

        // APB1 peripheral clocks enable in Sleep and Stop modes register 2
        struct APB1SMENR2 : public Register<0x4002107c> {
            using LPUART1SMEN = Field<0, 1>;    // Low power UART 1 clocks enable during Sleep and Stop modes
            using I2C4SMEN = Field<1, 1>;    // I2C4 clocks enable during Sleep and Stop modes
            using USBPDSMEN = Field<8, 1>;    // USB PD clock enable during sleep mode
        };

        // APB2SMENR
        struct APB2SMENR : public Register<0x40021080> {
            using SYSCFGSMEN = Field<0, 1>;    // SYSCFG clocks enable during Sleep and Stop modes
            using TIM1SMEN = Field<11, 1>;    // TIM1 timer clocks enable during Sleep and Stop modes
            using SPI1SMEN = Field<12, 1>;    // SPI1 clocks enable during Sleep and Stop modes
            using TIM8SMEN = Field<13, 1>;    // TIM8 timer clocks enable during Sleep and Stop modes
            using USART1SMEN = Field<14, 1>;    // USART1clocks enable during Sleep and Stop modes
            using SPI4SMEN = Field<15, 1>;    // SPI4 timer clocks enable during Sleep and Stop modes
            using TIM15SMEN = Field<16, 1>;    // TIM15 timer clocks enable during Sleep and Stop modes
            using TIM16SMEN = Field<17, 1>;    // TIM16 timer clocks enable during Sleep and Stop modes
            using TIM17SMEN = Field<18, 1>;    // TIM17 timer clocks enable during Sleep and Stop modes
            using TIM20SMEN = Field<20, 1>;    // Timer 20clock enable during sleep mode
            using SAI1SMEN = Field<21, 1>;    // SAI1 clock enable during sleep mode
            using HRTIMERSMEN = Field<26, 1>;    // HRTIMER clock enable during sleep mode
        };

        // CCIPR
        struct CCIPR1 : public Register<0x40021088> {
            using ADC345SEL = Field<30, 2>;    // ADC3/4/5 clock source selection
            using ADCSEL = Field<28, 2>;    // ADCs clock source selection
            using CLK48SEL = Field<26, 2>;    // 48 MHz clock source selection
            using FDCANSEL = Field<24, 2>;    // SAI2 clock source selection
            using SPISEL_ = Field<22, 2>;    // SAI1 clock source selection
            using SAISEL = Field<20, 2>;    // Low power timer 2 clock source selection
            using LPTIM1SEL = Field<18, 2>;    // Low power timer 1 clock source selection
            using I2C3SEL = Field<16, 2>;    // I2C3 clock source selection
            using I2C2SEL = Field<14, 2>;    // I2C2 clock source selection
            using I2C1SEL = Field<12, 2>;    // I2C1 clock source selection
            using LPUART1SEL = Field<10, 2>;    // LPUART1 clock source selection
            using UART5SEL = Field<8, 2>;    // UART5 clock source selection
            using UART4SEL = Field<6, 2>;    // UART4 clock source selection
            using USART3SEL = Field<4, 2>;    // USART3 clock source selection
            using USART2SEL = Field<2, 2>;    // USART2 clock source selection
            using USART1SEL = Field<0, 2>;    // USART1 clock source selection
        };

        // BDCR
        struct BDCR : public Register<0x40021090> {
            using LSCOSEL = Field<25, 1>;    // Low speed clock output selection
            using LSCCOEN = Field<24, 1>;    // Low speed clock output enable
            using VSWRST = Field<16, 1>;    // Vswitch domain software reset
            using RTCEN = Field<15, 1>;    // RTC clock enable
            using RTCSEL = Field<8, 2>;    // RTC clock source selection
            using LSECSSD = Field<6, 1>;    // LSECSSD
            using LSECSSON = Field<5, 1>;    // LSECSSON
            using LSEDRV = Field<3, 2>;    // SE oscillator drive capability
            using LSEBYP = Field<2, 1>;    // LSE oscillator bypass
            using LSERDY = Field<1, 1>;    // LSE oscillator ready
            using LSEON = Field<0, 1>;    // LSE oscillator enable
        };

        // CSR
        struct CSR : public Register<0x40021094> {
            using LPWRSTF = Field<31, 1>;    // Low-power reset flag
            using WWDGRSTF = Field<30, 1>;    // Window watchdog reset flag
            using WDGRSTF = Field<29, 1>;    // Independent window watchdog reset flag
            using SFTRSTF = Field<28, 1>;    // Software reset flag
            using BORRSTF = Field<27, 1>;    // BOR flag
            using PADRSTF = Field<26, 1>;    // Pad reset flag
            using OBLRSTF = Field<25, 1>;    // Option byte loader reset flag
            using RMVF = Field<23, 1>;    // Remove reset flag
            using LSIRDY = Field<1, 1>;    // LSI oscillator ready
            using LSION = Field<0, 1>;    // LSI oscillator enable
        };

        // Clock recovery RC register
        struct CRRCR : public Register<0x40021098> {
            using RC48ON = Field<0, 1>;    // HSI48 clock enable
            using RC48RDY = Field<1, 1>;    // HSI48 clock ready flag
            using RC48CAL = Field<7, 9>;    // HSI48 clock calibration
        };

        // Peripherals independent clock configuration register
        struct CCIPR2 : public Register<0x4002109c> {
            using I2C4SEL = Field<0, 2>;    // I2C4 clock source selection
            using QUADSPISEL = Field<20, 2>;    // Octospi clock source selection
        };

    };

    // Power control
    struct PWR {
        // Power control register 1
        struct CR1 : public Register<0x40007000> {
            using LPR = Field<14, 1>;    // Low-power run
            using VOS = Field<9, 2>;    // Voltage scaling range selection
            using DBP = Field<8, 1>;    // Disable backup domain write protection
            using LPMS = Field<0, 3>;    // Low-power mode selection
        };

        // Power control register 2
        struct CR2 : public Register<0x40007004> {
            using PVMEN1 = Field<4, 1>;    // Peripheral voltage monitoring 1 enable: VDDA vs. COMP min voltage
            using PLS = Field<1, 3>;    // Power voltage detector level selection
            using PVDE = Field<0, 1>;    // Power voltage detector enable
            using PVMEN2 = Field<5, 1>;    // Peripheral voltage monitoring 2 enable: VDDA vs. Fast DAC min voltage
            using PVMEN3 = Field<6, 1>;    // Peripheral voltage monitoring 3 enable: VDDA vs. ADC min voltage 1.62V
            using PVMEN4 = Field<7, 1>;    // Peripheral voltage monitoring 4 enable: VDDA vs. OPAMP/DAC min voltage
        };

        // Power control register 3
        struct CR3 : public Register<0x40007008> {
            using EWUP1 = Field<0, 1>;    // Enable Wakeup pin WKUP1
            using EWUP2 = Field<1, 1>;    // Enable Wakeup pin WKUP2
            using EWUP3 = Field<2, 1>;    // Enable Wakeup pin WKUP3
            using EWUP4 = Field<3, 1>;    // Enable Wakeup pin WKUP4
            using EWUP5 = Field<4, 1>;    // Enable Wakeup pin WKUP5
            using RRS = Field<8, 1>;    // SRAM2 retention in Standby mode
            using APC = Field<10, 1>;    // Apply pull-up and pull-down configuration
            using UCPD1_STDBY = Field<13, 1>;    // STDBY
            using UCPD1_DBDIS = Field<14, 1>;    // DBDIS
            using EIWUL = Field<15, 1>;    // Enable external WakeUp line
        };

        // Power control register 4
        struct CR4 : public Register<0x4000700c> {
            using VBRS = Field<9, 1>;    // VBAT battery charging resistor selection
            using VBE = Field<8, 1>;    // VBAT battery charging enable
            using WP5 = Field<4, 1>;    // Wakeup pin WKUP5 polarity
            using WP4 = Field<3, 1>;    // Wakeup pin WKUP4 polarity
            using WP3 = Field<2, 1>;    // Wakeup pin WKUP3 polarity
            using WP2 = Field<1, 1>;    // Wakeup pin WKUP2 polarity
            using WP1 = Field<0, 1>;    // Wakeup pin WKUP1 polarity
        };

        // Power status register 1
        struct SR1 : public Register<0x40007010> {
            using WUFI = Field<15, 1>;    // Wakeup flag internal
            using SBF = Field<8, 1>;    // Standby flag
            using WUF5 = Field<4, 1>;    // Wakeup flag 5
            using WUF4 = Field<3, 1>;    // Wakeup flag 4
            using WUF3 = Field<2, 1>;    // Wakeup flag 3
            using WUF2 = Field<1, 1>;    // Wakeup flag 2
            using WUF1 = Field<0, 1>;    // Wakeup flag 1
        };

        // Power status register 2
        struct SR2 : public Register<0x40007014> {
            using PVMO4 = Field<15, 1>;    // Peripheral voltage monitoring output: VDDA vs. 2.2 V
            using PVMO3 = Field<14, 1>;    // Peripheral voltage monitoring output: VDDA vs. 1.62 V
            using PVMO2 = Field<13, 1>;    // Peripheral voltage monitoring output: VDDIO2 vs. 0.9 V
            using PVMO1 = Field<12, 1>;    // Peripheral voltage monitoring output: VDDUSB vs. 1.2 V
            using PVDO = Field<11, 1>;    // Power voltage detector output
            using VOSF = Field<10, 1>;    // Voltage scaling flag
            using REGLPF = Field<9, 1>;    // Low-power regulator flag
            using REGLPS = Field<8, 1>;    // Low-power regulator started
        };

        // Power status clear register
        struct SCR : public Register<0x40007018> {
            using CSBF = Field<8, 1>;    // Clear standby flag
            using CWUF5 = Field<4, 1>;    // Clear wakeup flag 5
            using CWUF4 = Field<3, 1>;    // Clear wakeup flag 4
            using CWUF3 = Field<2, 1>;    // Clear wakeup flag 3
            using CWUF2 = Field<1, 1>;    // Clear wakeup flag 2
            using CWUF1 = Field<0, 1>;    // Clear wakeup flag 1
        };

        // Power Port A pull-up control register
        struct PUCRA : public Register<0x40007020> {
            using PU15 = Field<15, 1>;    // Port A pull-up bit y (y=0..15)
            using PU13 = Field<13, 1>;    // Port A pull-up bit y (y=0..15)
            using PU12 = Field<12, 1>;    // Port A pull-up bit y (y=0..15)
            using PU11 = Field<11, 1>;    // Port A pull-up bit y (y=0..15)
            using PU10 = Field<10, 1>;    // Port A pull-up bit y (y=0..15)
            using PU9 = Field<9, 1>;    // Port A pull-up bit y (y=0..15)
            using PU8 = Field<8, 1>;    // Port A pull-up bit y (y=0..15)
            using PU7 = Field<7, 1>;    // Port A pull-up bit y (y=0..15)
            using PU6 = Field<6, 1>;    // Port A pull-up bit y (y=0..15)
            using PU5 = Field<5, 1>;    // Port A pull-up bit y (y=0..15)
            using PU4 = Field<4, 1>;    // Port A pull-up bit y (y=0..15)
            using PU3 = Field<3, 1>;    // Port A pull-up bit y (y=0..15)
            using PU2 = Field<2, 1>;    // Port A pull-up bit y (y=0..15)
            using PU1 = Field<1, 1>;    // Port A pull-up bit y (y=0..15)
            using PU0 = Field<0, 1>;    // Port A pull-up bit y (y=0..15)
        };

        // Power Port A pull-down control register
        struct PDCRA : public Register<0x40007024> {
            using PD14 = Field<14, 1>;    // Port A pull-down bit y (y=0..15)
            using PD12 = Field<12, 1>;    // Port A pull-down bit y (y=0..15)
            using PD11 = Field<11, 1>;    // Port A pull-down bit y (y=0..15)
            using PD10 = Field<10, 1>;    // Port A pull-down bit y (y=0..15)
            using PD9 = Field<9, 1>;    // Port A pull-down bit y (y=0..15)
            using PD8 = Field<8, 1>;    // Port A pull-down bit y (y=0..15)
            using PD7 = Field<7, 1>;    // Port A pull-down bit y (y=0..15)
            using PD6 = Field<6, 1>;    // Port A pull-down bit y (y=0..15)
            using PD5 = Field<5, 1>;    // Port A pull-down bit y (y=0..15)
            using PD4 = Field<4, 1>;    // Port A pull-down bit y (y=0..15)
            using PD3 = Field<3, 1>;    // Port A pull-down bit y (y=0..15)
            using PD2 = Field<2, 1>;    // Port A pull-down bit y (y=0..15)
            using PD1 = Field<1, 1>;    // Port A pull-down bit y (y=0..15)
            using PD0 = Field<0, 1>;    // Port A pull-down bit y (y=0..15)
        };

        // Power Port B pull-up control register
        struct PUCRB : public Register<0x40007028> {
            using PU15 = Field<15, 1>;    // Port B pull-up bit y (y=0..15)
            using PU14 = Field<14, 1>;    // Port B pull-up bit y (y=0..15)
            using PU13 = Field<13, 1>;    // Port B pull-up bit y (y=0..15)
            using PU12 = Field<12, 1>;    // Port B pull-up bit y (y=0..15)
            using PU11 = Field<11, 1>;    // Port B pull-up bit y (y=0..15)
            using PU10 = Field<10, 1>;    // Port B pull-up bit y (y=0..15)
            using PU9 = Field<9, 1>;    // Port B pull-up bit y (y=0..15)
            using PU8 = Field<8, 1>;    // Port B pull-up bit y (y=0..15)
            using PU7 = Field<7, 1>;    // Port B pull-up bit y (y=0..15)
            using PU6 = Field<6, 1>;    // Port B pull-up bit y (y=0..15)
            using PU5 = Field<5, 1>;    // Port B pull-up bit y (y=0..15)
            using PU4 = Field<4, 1>;    // Port B pull-up bit y (y=0..15)
            using PU3 = Field<3, 1>;    // Port B pull-up bit y (y=0..15)
            using PU2 = Field<2, 1>;    // Port B pull-up bit y (y=0..15)
            using PU1 = Field<1, 1>;    // Port B pull-up bit y (y=0..15)
            using PU0 = Field<0, 1>;    // Port B pull-up bit y (y=0..15)
        };

        // Power Port B pull-down control register
        struct PDCRB : public Register<0x4000702c> {
            using PD15 = Field<15, 1>;    // Port B pull-down bit y (y=0..15)
            using PD14 = Field<14, 1>;    // Port B pull-down bit y (y=0..15)
            using PD13 = Field<13, 1>;    // Port B pull-down bit y (y=0..15)
            using PD12 = Field<12, 1>;    // Port B pull-down bit y (y=0..15)
            using PD11 = Field<11, 1>;    // Port B pull-down bit y (y=0..15)
            using PD10 = Field<10, 1>;    // Port B pull-down bit y (y=0..15)
            using PD9 = Field<9, 1>;    // Port B pull-down bit y (y=0..15)
            using PD8 = Field<8, 1>;    // Port B pull-down bit y (y=0..15)
            using PD7 = Field<7, 1>;    // Port B pull-down bit y (y=0..15)
            using PD6 = Field<6, 1>;    // Port B pull-down bit y (y=0..15)
            using PD5 = Field<5, 1>;    // Port B pull-down bit y (y=0..15)
            using PD3 = Field<3, 1>;    // Port B pull-down bit y (y=0..15)
            using PD2 = Field<2, 1>;    // Port B pull-down bit y (y=0..15)
            using PD1 = Field<1, 1>;    // Port B pull-down bit y (y=0..15)
            using PD0 = Field<0, 1>;    // Port B pull-down bit y (y=0..15)
        };

        // Power Port C pull-up control register
        struct PUCRC : public Register<0x40007030> {
            using PU15 = Field<15, 1>;    // Port C pull-up bit y (y=0..15)
            using PU14 = Field<14, 1>;    // Port C pull-up bit y (y=0..15)
            using PU13 = Field<13, 1>;    // Port C pull-up bit y (y=0..15)
            using PU12 = Field<12, 1>;    // Port C pull-up bit y (y=0..15)
            using PU11 = Field<11, 1>;    // Port C pull-up bit y (y=0..15)
            using PU10 = Field<10, 1>;    // Port C pull-up bit y (y=0..15)
            using PU9 = Field<9, 1>;    // Port C pull-up bit y (y=0..15)
            using PU8 = Field<8, 1>;    // Port C pull-up bit y (y=0..15)
            using PU7 = Field<7, 1>;    // Port C pull-up bit y (y=0..15)
            using PU6 = Field<6, 1>;    // Port C pull-up bit y (y=0..15)
            using PU5 = Field<5, 1>;    // Port C pull-up bit y (y=0..15)
            using PU4 = Field<4, 1>;    // Port C pull-up bit y (y=0..15)
            using PU3 = Field<3, 1>;    // Port C pull-up bit y (y=0..15)
            using PU2 = Field<2, 1>;    // Port C pull-up bit y (y=0..15)
            using PU1 = Field<1, 1>;    // Port C pull-up bit y (y=0..15)
            using PU0 = Field<0, 1>;    // Port C pull-up bit y (y=0..15)
        };

        // Power Port C pull-down control register
        struct PDCRC : public Register<0x40007034> {
            using PD15 = Field<15, 1>;    // Port C pull-down bit y (y=0..15)
            using PD14 = Field<14, 1>;    // Port C pull-down bit y (y=0..15)
            using PD13 = Field<13, 1>;    // Port C pull-down bit y (y=0..15)
            using PD12 = Field<12, 1>;    // Port C pull-down bit y (y=0..15)
            using PD11 = Field<11, 1>;    // Port C pull-down bit y (y=0..15)
            using PD10 = Field<10, 1>;    // Port C pull-down bit y (y=0..15)
            using PD9 = Field<9, 1>;    // Port C pull-down bit y (y=0..15)
            using PD8 = Field<8, 1>;    // Port C pull-down bit y (y=0..15)
            using PD7 = Field<7, 1>;    // Port C pull-down bit y (y=0..15)
            using PD6 = Field<6, 1>;    // Port C pull-down bit y (y=0..15)
            using PD5 = Field<5, 1>;    // Port C pull-down bit y (y=0..15)
            using PD4 = Field<4, 1>;    // Port C pull-down bit y (y=0..15)
            using PD3 = Field<3, 1>;    // Port C pull-down bit y (y=0..15)
            using PD2 = Field<2, 1>;    // Port C pull-down bit y (y=0..15)
            using PD1 = Field<1, 1>;    // Port C pull-down bit y (y=0..15)
            using PD0 = Field<0, 1>;    // Port C pull-down bit y (y=0..15)
        };

        // Power Port D pull-up control register
        struct PUCRD : public Register<0x40007038> {
            using PU15 = Field<15, 1>;    // Port D pull-up bit y (y=0..15)
            using PU14 = Field<14, 1>;    // Port D pull-up bit y (y=0..15)
            using PU13 = Field<13, 1>;    // Port D pull-up bit y (y=0..15)
            using PU12 = Field<12, 1>;    // Port D pull-up bit y (y=0..15)
            using PU11 = Field<11, 1>;    // Port D pull-up bit y (y=0..15)
            using PU10 = Field<10, 1>;    // Port D pull-up bit y (y=0..15)
            using PU9 = Field<9, 1>;    // Port D pull-up bit y (y=0..15)
            using PU8 = Field<8, 1>;    // Port D pull-up bit y (y=0..15)
            using PU7 = Field<7, 1>;    // Port D pull-up bit y (y=0..15)
            using PU6 = Field<6, 1>;    // Port D pull-up bit y (y=0..15)
            using PU5 = Field<5, 1>;    // Port D pull-up bit y (y=0..15)
            using PU4 = Field<4, 1>;    // Port D pull-up bit y (y=0..15)
            using PU3 = Field<3, 1>;    // Port D pull-up bit y (y=0..15)
            using PU2 = Field<2, 1>;    // Port D pull-up bit y (y=0..15)
            using PU1 = Field<1, 1>;    // Port D pull-up bit y (y=0..15)
            using PU0 = Field<0, 1>;    // Port D pull-up bit y (y=0..15)
        };

        // Power Port D pull-down control register
        struct PDCRD : public Register<0x4000703c> {
            using PD15 = Field<15, 1>;    // Port D pull-down bit y (y=0..15)
            using PD14 = Field<14, 1>;    // Port D pull-down bit y (y=0..15)
            using PD13 = Field<13, 1>;    // Port D pull-down bit y (y=0..15)
            using PD12 = Field<12, 1>;    // Port D pull-down bit y (y=0..15)
            using PD11 = Field<11, 1>;    // Port D pull-down bit y (y=0..15)
            using PD10 = Field<10, 1>;    // Port D pull-down bit y (y=0..15)
            using PD9 = Field<9, 1>;    // Port D pull-down bit y (y=0..15)
            using PD8 = Field<8, 1>;    // Port D pull-down bit y (y=0..15)
            using PD7 = Field<7, 1>;    // Port D pull-down bit y (y=0..15)
            using PD6 = Field<6, 1>;    // Port D pull-down bit y (y=0..15)
            using PD5 = Field<5, 1>;    // Port D pull-down bit y (y=0..15)
            using PD4 = Field<4, 1>;    // Port D pull-down bit y (y=0..15)
            using PD3 = Field<3, 1>;    // Port D pull-down bit y (y=0..15)
            using PD2 = Field<2, 1>;    // Port D pull-down bit y (y=0..15)
            using PD1 = Field<1, 1>;    // Port D pull-down bit y (y=0..15)
            using PD0 = Field<0, 1>;    // Port D pull-down bit y (y=0..15)
        };

        // Power Port E pull-up control register
        struct PUCRE : public Register<0x40007040> {
            using PU15 = Field<15, 1>;    // Port E pull-up bit y (y=0..15)
            using PU14 = Field<14, 1>;    // Port E pull-up bit y (y=0..15)
            using PU13 = Field<13, 1>;    // Port E pull-up bit y (y=0..15)
            using PU12 = Field<12, 1>;    // Port E pull-up bit y (y=0..15)
            using PU11 = Field<11, 1>;    // Port E pull-up bit y (y=0..15)
            using PU10 = Field<10, 1>;    // Port E pull-up bit y (y=0..15)
            using PU9 = Field<9, 1>;    // Port E pull-up bit y (y=0..15)
            using PU8 = Field<8, 1>;    // Port E pull-up bit y (y=0..15)
            using PU7 = Field<7, 1>;    // Port E pull-up bit y (y=0..15)
            using PU6 = Field<6, 1>;    // Port E pull-up bit y (y=0..15)
            using PU5 = Field<5, 1>;    // Port E pull-up bit y (y=0..15)
            using PU4 = Field<4, 1>;    // Port E pull-up bit y (y=0..15)
            using PU3 = Field<3, 1>;    // Port E pull-up bit y (y=0..15)
            using PU2 = Field<2, 1>;    // Port E pull-up bit y (y=0..15)
            using PU1 = Field<1, 1>;    // Port E pull-up bit y (y=0..15)
            using PU0 = Field<0, 1>;    // Port E pull-up bit y (y=0..15)
        };

        // Power Port E pull-down control register
        struct PDCRE : public Register<0x40007044> {
            using PD15 = Field<15, 1>;    // Port E pull-down bit y (y=0..15)
            using PD14 = Field<14, 1>;    // Port E pull-down bit y (y=0..15)
            using PD13 = Field<13, 1>;    // Port E pull-down bit y (y=0..15)
            using PD12 = Field<12, 1>;    // Port E pull-down bit y (y=0..15)
            using PD11 = Field<11, 1>;    // Port E pull-down bit y (y=0..15)
            using PD10 = Field<10, 1>;    // Port E pull-down bit y (y=0..15)
            using PD9 = Field<9, 1>;    // Port E pull-down bit y (y=0..15)
            using PD8 = Field<8, 1>;    // Port E pull-down bit y (y=0..15)
            using PD7 = Field<7, 1>;    // Port E pull-down bit y (y=0..15)
            using PD6 = Field<6, 1>;    // Port E pull-down bit y (y=0..15)
            using PD5 = Field<5, 1>;    // Port E pull-down bit y (y=0..15)
            using PD4 = Field<4, 1>;    // Port E pull-down bit y (y=0..15)
            using PD3 = Field<3, 1>;    // Port E pull-down bit y (y=0..15)
            using PD2 = Field<2, 1>;    // Port E pull-down bit y (y=0..15)
            using PD1 = Field<1, 1>;    // Port E pull-down bit y (y=0..15)
            using PD0 = Field<0, 1>;    // Port E pull-down bit y (y=0..15)
        };

        // Power Port F pull-up control register
        struct PUCRF : public Register<0x40007048> {
            using PU15 = Field<15, 1>;    // Port F pull-up bit y (y=0..15)
            using PU14 = Field<14, 1>;    // Port F pull-up bit y (y=0..15)
            using PU13 = Field<13, 1>;    // Port F pull-up bit y (y=0..15)
            using PU12 = Field<12, 1>;    // Port F pull-up bit y (y=0..15)
            using PU11 = Field<11, 1>;    // Port F pull-up bit y (y=0..15)
            using PU10 = Field<10, 1>;    // Port F pull-up bit y (y=0..15)
            using PU9 = Field<9, 1>;    // Port F pull-up bit y (y=0..15)
            using PU8 = Field<8, 1>;    // Port F pull-up bit y (y=0..15)
            using PU7 = Field<7, 1>;    // Port F pull-up bit y (y=0..15)
            using PU6 = Field<6, 1>;    // Port F pull-up bit y (y=0..15)
            using PU5 = Field<5, 1>;    // Port F pull-up bit y (y=0..15)
            using PU4 = Field<4, 1>;    // Port F pull-up bit y (y=0..15)
            using PU3 = Field<3, 1>;    // Port F pull-up bit y (y=0..15)
            using PU2 = Field<2, 1>;    // Port F pull-up bit y (y=0..15)
            using PU1 = Field<1, 1>;    // Port F pull-up bit y (y=0..15)
            using PU0 = Field<0, 1>;    // Port F pull-up bit y (y=0..15)
        };

        // Power Port F pull-down control register
        struct PDCRF : public Register<0x4000704c> {
            using PD15 = Field<15, 1>;    // Port F pull-down bit y (y=0..15)
            using PD14 = Field<14, 1>;    // Port F pull-down bit y (y=0..15)
            using PD13 = Field<13, 1>;    // Port F pull-down bit y (y=0..15)
            using PD12 = Field<12, 1>;    // Port F pull-down bit y (y=0..15)
            using PD11 = Field<11, 1>;    // Port F pull-down bit y (y=0..15)
            using PD10 = Field<10, 1>;    // Port F pull-down bit y (y=0..15)
            using PD9 = Field<9, 1>;    // Port F pull-down bit y (y=0..15)
            using PD8 = Field<8, 1>;    // Port F pull-down bit y (y=0..15)
            using PD7 = Field<7, 1>;    // Port F pull-down bit y (y=0..15)
            using PD6 = Field<6, 1>;    // Port F pull-down bit y (y=0..15)
            using PD5 = Field<5, 1>;    // Port F pull-down bit y (y=0..15)
            using PD4 = Field<4, 1>;    // Port F pull-down bit y (y=0..15)
            using PD3 = Field<3, 1>;    // Port F pull-down bit y (y=0..15)
            using PD2 = Field<2, 1>;    // Port F pull-down bit y (y=0..15)
            using PD1 = Field<1, 1>;    // Port F pull-down bit y (y=0..15)
            using PD0 = Field<0, 1>;    // Port F pull-down bit y (y=0..15)
        };

        // Power Port G pull-up control register
        struct PUCRG : public Register<0x40007050> {
            using PU10 = Field<10, 1>;    // Port G pull-up bit y (y=0..15)
            using PU9 = Field<9, 1>;    // Port G pull-up bit y (y=0..15)
            using PU8 = Field<8, 1>;    // Port G pull-up bit y (y=0..15)
            using PU7 = Field<7, 1>;    // Port G pull-up bit y (y=0..15)
            using PU6 = Field<6, 1>;    // Port G pull-up bit y (y=0..15)
            using PU5 = Field<5, 1>;    // Port G pull-up bit y (y=0..15)
            using PU4 = Field<4, 1>;    // Port G pull-up bit y (y=0..15)
            using PU3 = Field<3, 1>;    // Port G pull-up bit y (y=0..15)
            using PU2 = Field<2, 1>;    // Port G pull-up bit y (y=0..15)
            using PU1 = Field<1, 1>;    // Port G pull-up bit y (y=0..15)
            using PU0 = Field<0, 1>;    // Port G pull-up bit y (y=0..15)
        };

        // Power Port G pull-down control register
        struct PDCRG : public Register<0x40007054> {
            using PD10 = Field<10, 1>;    // Port G pull-down bit y (y=0..15)
            using PD9 = Field<9, 1>;    // Port G pull-down bit y (y=0..15)
            using PD8 = Field<8, 1>;    // Port G pull-down bit y (y=0..15)
            using PD7 = Field<7, 1>;    // Port G pull-down bit y (y=0..15)
            using PD6 = Field<6, 1>;    // Port G pull-down bit y (y=0..15)
            using PD5 = Field<5, 1>;    // Port G pull-down bit y (y=0..15)
            using PD4 = Field<4, 1>;    // Port G pull-down bit y (y=0..15)
            using PD3 = Field<3, 1>;    // Port G pull-down bit y (y=0..15)
            using PD2 = Field<2, 1>;    // Port G pull-down bit y (y=0..15)
            using PD1 = Field<1, 1>;    // Port G pull-down bit y (y=0..15)
            using PD0 = Field<0, 1>;    // Port G pull-down bit y (y=0..15)
        };

        // Power control register 5
        struct CR5 : public Register<0x40007080> {
            using R1MODE = Field<0, 1>;    // Main regular range 1 mode
        };

    };

    // Random number generator
    struct RNG {
        // control register
        struct CR : public Register<0x50060800> {
            using CED = Field<5, 1>;    // Clock error detection
            using IE = Field<3, 1>;    // Interrupt enable
            using RNGEN = Field<2, 1>;    // Random number generator enable
        };

        // status register
        struct SR : public Register<0x50060804> {
            using SEIS = Field<6, 1>;    // Seed error interrupt status
            using CEIS = Field<5, 1>;    // Clock error interrupt status
            using SECS = Field<2, 1>;    // Seed error current status
            using CECS = Field<1, 1>;    // Clock error current status
            using DRDY = Field<0, 1>;    // Data ready
        };

        // data register
        struct DR : public Register<0x50060808> {
            using RNDATA = Field<0, 32>;    // Random data
        };

    };

    // Advanced encryption standard hardware accelerator
    struct AES {
        // control register
        struct CR : public Register<0x50060000> {
            using NPBLB = Field<20, 4>;    // NPBLB
            using KEYSIZE = Field<18, 1>;    // KEYSIZE
            using CHMOD_2 = Field<16, 1>;    // CHMOD_2
            using GCMPH = Field<13, 2>;    // GCMPH
            using DMAOUTEN = Field<12, 1>;    // Enable DMA management of data output phase
            using DMAINEN = Field<11, 1>;    // Enable DMA management of data input phase
            using ERRIE = Field<10, 1>;    // Error interrupt enable
            using CCFIE = Field<9, 1>;    // CCF flag interrupt enable
            using ERRC = Field<8, 1>;    // Error clear
            using CCFC = Field<7, 1>;    // Computation Complete Flag Clear
            using CHMOD = Field<5, 2>;    // AES chaining mode
            using MODE = Field<3, 2>;    // AES operating mode
            using DATATYPE = Field<1, 2>;    // Data type selection (for data in and data out to/from the cryptographic block)
            using EN = Field<0, 1>;    // AES enable
        };

        // status register
        struct SR : public Register<0x50060004> {
            using BUSY = Field<3, 1>;    // BUSY
            using WRERR = Field<2, 1>;    // Write error flag
            using RDERR = Field<1, 1>;    // Read error flag
            using CCF = Field<0, 1>;    // Computation complete flag
        };

        // data input register
        struct DINR : public Register<0x50060008> {
            using AES_DINR = Field<0, 32>;    // Data Input Register
        };

        // data output register
        struct DOUTR : public Register<0x5006000c> {
            using AES_DOUTR = Field<0, 32>;    // Data output register
        };

        // key register 0
        struct KEYR0 : public Register<0x50060010> {
            using AES_KEYR0 = Field<0, 32>;    // Data Output Register (LSB key [31:0])
        };

        // key register 1
        struct KEYR1 : public Register<0x50060014> {
            using AES_KEYR1 = Field<0, 32>;    // AES key register (key [63:32])
        };

        // key register 2
        struct KEYR2 : public Register<0x50060018> {
            using AES_KEYR2 = Field<0, 32>;    // AES key register (key [95:64])
        };

        // key register 3
        struct KEYR3 : public Register<0x5006001c> {
            using AES_KEYR3 = Field<0, 32>;    // AES key register (MSB key [127:96])
        };

        // initialization vector register 0
        struct IVR0 : public Register<0x50060020> {
            using AES_IVR0 = Field<0, 32>;    // initialization vector register (LSB IVR [31:0])
        };

        // initialization vector register 1
        struct IVR1 : public Register<0x50060024> {
            using AES_IVR1 = Field<0, 32>;    // Initialization Vector Register (IVR [63:32])
        };

        // initialization vector register 2
        struct IVR2 : public Register<0x50060028> {
            using AES_IVR2 = Field<0, 32>;    // Initialization Vector Register (IVR [95:64])
        };

        // initialization vector register 3
        struct IVR3 : public Register<0x5006002c> {
            using AES_IVR3 = Field<0, 32>;    // Initialization Vector Register (MSB IVR [127:96])
        };

        // key register 4
        struct KEYR4 : public Register<0x50060030> {
            using KEY = Field<0, 32>;    // AES key
        };

        // key register 5
        struct KEYR5 : public Register<0x50060034> {
            using KEY = Field<0, 32>;    // AES key
        };

        // key register 6
        struct KEYR6 : public Register<0x50060038> {
            using KEY = Field<0, 32>;    // AES key
        };

        // key register 7
        struct KEYR7 : public Register<0x5006003c> {
            using KEY = Field<0, 32>;    // AES key
        };

        // suspend registers
        struct SUSP0R : public Register<0x50060040> {
            using SUSP = Field<0, 32>;    // AES suspend
        };

        // suspend registers
        struct SUSP1R : public Register<0x50060044> {
            using SUSP = Field<0, 32>;    // AES suspend
        };

        // suspend registers
        struct SUSP2R : public Register<0x50060048> {
            using SUSP = Field<0, 32>;    // AES suspend
        };

        // suspend registers
        struct SUSP3R : public Register<0x5006004c> {
            using SUSP = Field<0, 32>;    // AES suspend
        };

        // suspend registers
        struct SUSP4R : public Register<0x50060050> {
            using SUSP = Field<0, 32>;    // AES suspend
        };

        // suspend registers
        struct SUSP5R : public Register<0x50060054> {
            using SUSP = Field<0, 32>;    // AES suspend
        };

        // suspend registers
        struct SUSP6R : public Register<0x50060058> {
            using SUSP = Field<0, 32>;    // AES suspend
        };

        // suspend registers
        struct SUSP7R : public Register<0x5006005c> {
            using SUSP = Field<0, 32>;    // AES suspend
        };

    };

    // General-purpose I/Os
    struct GPIOA {
        // GPIO port mode register
        struct MODER : public Register<0x48000000> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x48000004> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x48000008> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4800000c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x48000010> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x48000014> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x48000018> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4800001c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x48000020> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x48000024> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x48000028> {
            using BR0 = Field<0, 1>;    // Port Reset bit
            using BR1 = Field<1, 1>;    // Port Reset bit
            using BR2 = Field<2, 1>;    // Port Reset bit
            using BR3 = Field<3, 1>;    // Port Reset bit
            using BR4 = Field<4, 1>;    // Port Reset bit
            using BR5 = Field<5, 1>;    // Port Reset bit
            using BR6 = Field<6, 1>;    // Port Reset bit
            using BR7 = Field<7, 1>;    // Port Reset bit
            using BR8 = Field<8, 1>;    // Port Reset bit
            using BR9 = Field<9, 1>;    // Port Reset bit
            using BR10 = Field<10, 1>;    // Port Reset bit
            using BR11 = Field<11, 1>;    // Port Reset bit
            using BR12 = Field<12, 1>;    // Port Reset bit
            using BR13 = Field<13, 1>;    // Port Reset bit
            using BR14 = Field<14, 1>;    // Port Reset bit
            using BR15 = Field<15, 1>;    // Port Reset bit
        };

    };

    // General-purpose I/Os
    struct GPIOB {
        // GPIO port mode register
        struct MODER : public Register<0x48000400> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x48000404> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x48000408> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4800040c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x48000410> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x48000414> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x48000418> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4800041c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x48000420> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x48000424> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x48000428> {
            using BR0 = Field<0, 1>;    // Port Reset bit
            using BR1 = Field<1, 1>;    // Port Reset bit
            using BR2 = Field<2, 1>;    // Port Reset bit
            using BR3 = Field<3, 1>;    // Port Reset bit
            using BR4 = Field<4, 1>;    // Port Reset bit
            using BR5 = Field<5, 1>;    // Port Reset bit
            using BR6 = Field<6, 1>;    // Port Reset bit
            using BR7 = Field<7, 1>;    // Port Reset bit
            using BR8 = Field<8, 1>;    // Port Reset bit
            using BR9 = Field<9, 1>;    // Port Reset bit
            using BR10 = Field<10, 1>;    // Port Reset bit
            using BR11 = Field<11, 1>;    // Port Reset bit
            using BR12 = Field<12, 1>;    // Port Reset bit
            using BR13 = Field<13, 1>;    // Port Reset bit
            using BR14 = Field<14, 1>;    // Port Reset bit
            using BR15 = Field<15, 1>;    // Port Reset bit
        };

    };

    // General-purpose I/Os
    struct GPIOC {
        // GPIO port mode register
        struct MODER : public Register<0x48000800> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x48000804> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x48000808> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4800080c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x48000810> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x48000814> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x48000818> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4800081c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x48000820> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x48000824> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x48000828> {
            using BR0 = Field<0, 1>;    // Port Reset bit
            using BR1 = Field<1, 1>;    // Port Reset bit
            using BR2 = Field<2, 1>;    // Port Reset bit
            using BR3 = Field<3, 1>;    // Port Reset bit
            using BR4 = Field<4, 1>;    // Port Reset bit
            using BR5 = Field<5, 1>;    // Port Reset bit
            using BR6 = Field<6, 1>;    // Port Reset bit
            using BR7 = Field<7, 1>;    // Port Reset bit
            using BR8 = Field<8, 1>;    // Port Reset bit
            using BR9 = Field<9, 1>;    // Port Reset bit
            using BR10 = Field<10, 1>;    // Port Reset bit
            using BR11 = Field<11, 1>;    // Port Reset bit
            using BR12 = Field<12, 1>;    // Port Reset bit
            using BR13 = Field<13, 1>;    // Port Reset bit
            using BR14 = Field<14, 1>;    // Port Reset bit
            using BR15 = Field<15, 1>;    // Port Reset bit
        };

    };

    // General-purpose I/Os
    struct GPIOD {
        // GPIO port mode register
        struct MODER : public Register<0x48000c00> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x48000c04> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x48000c08> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x48000c0c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x48000c10> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x48000c14> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x48000c18> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x48000c1c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x48000c20> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x48000c24> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x48000c28> {
            using BR0 = Field<0, 1>;    // Port Reset bit
            using BR1 = Field<1, 1>;    // Port Reset bit
            using BR2 = Field<2, 1>;    // Port Reset bit
            using BR3 = Field<3, 1>;    // Port Reset bit
            using BR4 = Field<4, 1>;    // Port Reset bit
            using BR5 = Field<5, 1>;    // Port Reset bit
            using BR6 = Field<6, 1>;    // Port Reset bit
            using BR7 = Field<7, 1>;    // Port Reset bit
            using BR8 = Field<8, 1>;    // Port Reset bit
            using BR9 = Field<9, 1>;    // Port Reset bit
            using BR10 = Field<10, 1>;    // Port Reset bit
            using BR11 = Field<11, 1>;    // Port Reset bit
            using BR12 = Field<12, 1>;    // Port Reset bit
            using BR13 = Field<13, 1>;    // Port Reset bit
            using BR14 = Field<14, 1>;    // Port Reset bit
            using BR15 = Field<15, 1>;    // Port Reset bit
        };

    };

    // General-purpose I/Os
    struct GPIOE {
        // GPIO port mode register
        struct MODER : public Register<0x48001000> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x48001004> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x48001008> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4800100c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x48001010> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x48001014> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x48001018> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4800101c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x48001020> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x48001024> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x48001028> {
            using BR0 = Field<0, 1>;    // Port Reset bit
            using BR1 = Field<1, 1>;    // Port Reset bit
            using BR2 = Field<2, 1>;    // Port Reset bit
            using BR3 = Field<3, 1>;    // Port Reset bit
            using BR4 = Field<4, 1>;    // Port Reset bit
            using BR5 = Field<5, 1>;    // Port Reset bit
            using BR6 = Field<6, 1>;    // Port Reset bit
            using BR7 = Field<7, 1>;    // Port Reset bit
            using BR8 = Field<8, 1>;    // Port Reset bit
            using BR9 = Field<9, 1>;    // Port Reset bit
            using BR10 = Field<10, 1>;    // Port Reset bit
            using BR11 = Field<11, 1>;    // Port Reset bit
            using BR12 = Field<12, 1>;    // Port Reset bit
            using BR13 = Field<13, 1>;    // Port Reset bit
            using BR14 = Field<14, 1>;    // Port Reset bit
            using BR15 = Field<15, 1>;    // Port Reset bit
        };

    };

    // General-purpose I/Os
    struct GPIOF {
        // GPIO port mode register
        struct MODER : public Register<0x48001400> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x48001404> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x48001408> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4800140c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x48001410> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x48001414> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x48001418> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4800141c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x48001420> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x48001424> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x48001428> {
            using BR0 = Field<0, 1>;    // Port Reset bit
            using BR1 = Field<1, 1>;    // Port Reset bit
            using BR2 = Field<2, 1>;    // Port Reset bit
            using BR3 = Field<3, 1>;    // Port Reset bit
            using BR4 = Field<4, 1>;    // Port Reset bit
            using BR5 = Field<5, 1>;    // Port Reset bit
            using BR6 = Field<6, 1>;    // Port Reset bit
            using BR7 = Field<7, 1>;    // Port Reset bit
            using BR8 = Field<8, 1>;    // Port Reset bit
            using BR9 = Field<9, 1>;    // Port Reset bit
            using BR10 = Field<10, 1>;    // Port Reset bit
            using BR11 = Field<11, 1>;    // Port Reset bit
            using BR12 = Field<12, 1>;    // Port Reset bit
            using BR13 = Field<13, 1>;    // Port Reset bit
            using BR14 = Field<14, 1>;    // Port Reset bit
            using BR15 = Field<15, 1>;    // Port Reset bit
        };

    };

    // General-purpose I/Os
    struct GPIOG {
        // GPIO port mode register
        struct MODER : public Register<0x48001800> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x48001804> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x48001808> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4800180c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x48001810> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x48001814> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x48001818> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4800181c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x48001820> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x48001824> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x48001828> {
            using BR0 = Field<0, 1>;    // Port Reset bit
            using BR1 = Field<1, 1>;    // Port Reset bit
            using BR2 = Field<2, 1>;    // Port Reset bit
            using BR3 = Field<3, 1>;    // Port Reset bit
            using BR4 = Field<4, 1>;    // Port Reset bit
            using BR5 = Field<5, 1>;    // Port Reset bit
            using BR6 = Field<6, 1>;    // Port Reset bit
            using BR7 = Field<7, 1>;    // Port Reset bit
            using BR8 = Field<8, 1>;    // Port Reset bit
            using BR9 = Field<9, 1>;    // Port Reset bit
            using BR10 = Field<10, 1>;    // Port Reset bit
            using BR11 = Field<11, 1>;    // Port Reset bit
            using BR12 = Field<12, 1>;    // Port Reset bit
            using BR13 = Field<13, 1>;    // Port Reset bit
            using BR14 = Field<14, 1>;    // Port Reset bit
            using BR15 = Field<15, 1>;    // Port Reset bit
        };

    };

    // General purpose timers
    struct TIM15 {
        // control register 1
        struct CR1 : public Register<0x40014000> {
            using CEN = Field<0, 1>;    // Counter enable
            using UDIS = Field<1, 1>;    // Update disable
            using URS = Field<2, 1>;    // Update request source
            using OPM = Field<3, 1>;    // One-pulse mode
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CKD = Field<8, 2>;    // Clock division
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
            using DITHEN = Field<12, 1>;    // Dithering Enable
        };

        // control register 2
        struct CR2 : public Register<0x40014004> {
            using OIS2 = Field<10, 1>;    // Output idle state 2 (OC2 output)
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
        };

        // slave mode control register
        struct SMCR : public Register<0x40014008> {
            using TS_4_3 = Field<20, 2>;    // Trigger selection - bit 4:3
            using SMS_3 = Field<16, 1>;    // Slave mode selection - bit 3
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001400c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40014010> {
            using CC2OF = Field<10, 1>;    // Capture/Compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40014014> {
            using BG = Field<7, 1>;    // Break generation
            using TG = Field<6, 1>;    // Trigger generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register (output mode)
        struct CCMR1_Output : public Register<0x40014018> {
            using OC2M_3 = Field<24, 1>;    // Output Compare 2 mode - bit 3
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode
            using OC2M = Field<12, 3>;    // OC2M
            using OC2PE = Field<11, 1>;    // OC2PE
            using OC2FE = Field<10, 1>;    // OC2FE
            using CC2S = Field<8, 2>;    // CC2S
            using OC1CE = Field<7, 1>;    // OC1CE
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40014018> {
            using IC2F = Field<12, 4>;    // IC2F
            using IC2PSC = Field<10, 2>;    // IC2PSC
            using CC2S = Field<8, 2>;    // CC2S
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40014020> {
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 complementary output polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40014024> {
            using Field = Field<0, 16>;    // counter value
            using UIFCPY = Field<31, 1>;    // UIF Copy
        };

        // prescaler
        struct PSC : public Register<0x40014028> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001402c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // repetition counter register
        struct RCR : public Register<0x40014030> {
            using REP = Field<0, 8>;    // Repetition counter value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40014034> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40014038> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40014044> {
            using DTG = Field<0, 8>;    // Dead-time generator setup
            using LOCK = Field<8, 2>;    // Lock configuration
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using BKE = Field<12, 1>;    // Break enable
            using BKP = Field<13, 1>;    // Break polarity
            using AOE = Field<14, 1>;    // Automatic output enable
            using MOE = Field<15, 1>;    // Main output enable
            using BKF = Field<16, 4>;    // Break filter
            using BKDSRM = Field<26, 1>;    // BKDSRM
            using BKBID = Field<28, 1>;    // BKBID
        };

        // timer Deadtime Register 2
        struct DTR2 : public Register<0x40014054> {
            using DTGF = Field<0, 8>;    // Dead-time generator setup
            using DTAE = Field<16, 1>;    // Deadtime Asymmetric Enable
            using DTPE = Field<17, 1>;    // Deadtime Preload Enable
        };

        // TIM timer input selection register
        struct TISEL : public Register<0x4001405c> {
            using TI1SEL = Field<0, 4>;    // TI1[0] to TI1[15] input selection
            using TI2SEL = Field<8, 4>;    // TI2[0] to TI2[15] input selection
        };

        // TIM alternate function option register 1
        struct AF1 : public Register<0x40014060> {
            using BKCMP4P = Field<13, 1>;    // BRK COMP4 input polarity
            using BKCMP3P = Field<12, 1>;    // BRK COMP3 input polarity
            using BKCMP2P = Field<11, 1>;    // BRK COMP2 input polarity
            using BKCMP1P = Field<10, 1>;    // BRK COMP1 input polarity
            using BKINP = Field<9, 1>;    // BRK BKIN input polarity
            using BKCMP7E = Field<7, 1>;    // BRK COMP7 enable
            using BKCMP6E = Field<6, 1>;    // BRK COMP6 enable
            using BKCMP5E = Field<5, 1>;    // BRK COMP5 enable
            using BKCMP4E = Field<4, 1>;    // BRK COMP4 enable
            using BKCMP3E = Field<3, 1>;    // BRK COMP3 enable
            using BKCMP2E = Field<2, 1>;    // BRK COMP2 enable
            using BKCMP1E = Field<1, 1>;    // BRK COMP1 enable
            using BKINE = Field<0, 1>;    // BRK BKIN input enable
        };

        // TIM alternate function option register 2
        struct AF2 : public Register<0x40014064> {
            using OCRSEL = Field<16, 3>;    // OCREF_CLR source selection
        };

        // DMA control register
        struct DCR : public Register<0x400143dc> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x400143e0> {
            using DMAB = Field<0, 32>;    // DMA register for burst accesses
        };

    };

    // General purpose timers
    struct TIM16 {
        // control register 1
        struct CR1 : public Register<0x40014400> {
            using CEN = Field<0, 1>;    // Counter enable
            using UDIS = Field<1, 1>;    // Update disable
            using URS = Field<2, 1>;    // Update request source
            using OPM = Field<3, 1>;    // One-pulse mode
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CKD = Field<8, 2>;    // Clock division
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
            using DITHEN = Field<12, 1>;    // Dithering Enable
        };

        // control register 2
        struct CR2 : public Register<0x40014404> {
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001440c> {
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40014410> {
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40014414> {
            using BG = Field<7, 1>;    // Break generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register (output mode)
        struct CCMR1_Output : public Register<0x40014418> {
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40014418> {
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40014420> {
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40014424> {
            using Field = Field<0, 16>;    // counter value
            using UIFCPY = Field<31, 1>;    // UIF Copy
        };

        // prescaler
        struct PSC : public Register<0x40014428> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001442c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // repetition counter register
        struct RCR : public Register<0x40014430> {
            using REP = Field<0, 8>;    // Repetition counter value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40014434> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40014444> {
            using DTG = Field<0, 8>;    // Dead-time generator setup
            using LOCK = Field<8, 2>;    // Lock configuration
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using BKE = Field<12, 1>;    // Break enable
            using BKP = Field<13, 1>;    // Break polarity
            using AOE = Field<14, 1>;    // Automatic output enable
            using MOE = Field<15, 1>;    // Main output enable
            using BKF = Field<16, 4>;    // Break filter
            using BKDSRM = Field<26, 1>;    // BKDSRM
            using BKBID = Field<28, 1>;    // BKBID
        };

        // timer Deadtime Register 2
        struct DTR2 : public Register<0x40014454> {
            using DTGF = Field<0, 8>;    // Dead-time generator setup
            using DTAE = Field<16, 1>;    // Deadtime Asymmetric Enable
            using DTPE = Field<17, 1>;    // Deadtime Preload Enable
        };

        // TIM timer input selection register
        struct TISEL : public Register<0x4001445c> {
            using TI1SEL = Field<0, 4>;    // TI1[0] to TI1[15] input selection
        };

        // TIM alternate function option register 1
        struct AF1 : public Register<0x40014460> {
            using BKCMP4P = Field<13, 1>;    // BRK COMP4 input polarity
            using BKCMP3P = Field<12, 1>;    // BRK COMP3 input polarity
            using BKCMP2P = Field<11, 1>;    // BRK COMP2 input polarity
            using BKCMP1P = Field<10, 1>;    // BRK COMP1 input polarity
            using BKINP = Field<9, 1>;    // BRK BKIN input polarity
            using BKCMP7E = Field<7, 1>;    // BRK COMP7 enable
            using BKCMP6E = Field<6, 1>;    // BRK COMP6 enable
            using BKCMP5E = Field<5, 1>;    // BRK COMP5 enable
            using BKCMP4E = Field<4, 1>;    // BRK COMP4 enable
            using BKCMP3E = Field<3, 1>;    // BRK COMP3 enable
            using BKCMP2E = Field<2, 1>;    // BRK COMP2 enable
            using BKCMP1E = Field<1, 1>;    // BRK COMP1 enable
            using BKINE = Field<0, 1>;    // BRK BKIN input enable
        };

        // TIM alternate function option register 2
        struct AF2 : public Register<0x40014464> {
            using OCRSEL = Field<16, 3>;    // OCREF_CLR source selection
        };

        // DMA control register
        struct DCR : public Register<0x400147dc> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x400147e0> {
            using DMAB = Field<0, 32>;    // DMA register for burst accesses
        };

    };

    // General purpose timers
    struct TIM17 {
        // control register 1
        struct CR1 : public Register<0x40014800> {
            using CEN = Field<0, 1>;    // Counter enable
            using UDIS = Field<1, 1>;    // Update disable
            using URS = Field<2, 1>;    // Update request source
            using OPM = Field<3, 1>;    // One-pulse mode
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CKD = Field<8, 2>;    // Clock division
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
            using DITHEN = Field<12, 1>;    // Dithering Enable
        };

        // control register 2
        struct CR2 : public Register<0x40014804> {
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001480c> {
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40014810> {
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40014814> {
            using BG = Field<7, 1>;    // Break generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register (output mode)
        struct CCMR1_Output : public Register<0x40014818> {
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40014818> {
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40014820> {
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40014824> {
            using Field = Field<0, 16>;    // counter value
            using UIFCPY = Field<31, 1>;    // UIF Copy
        };

        // prescaler
        struct PSC : public Register<0x40014828> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001482c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // repetition counter register
        struct RCR : public Register<0x40014830> {
            using REP = Field<0, 8>;    // Repetition counter value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40014834> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40014844> {
            using DTG = Field<0, 8>;    // Dead-time generator setup
            using LOCK = Field<8, 2>;    // Lock configuration
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using BKE = Field<12, 1>;    // Break enable
            using BKP = Field<13, 1>;    // Break polarity
            using AOE = Field<14, 1>;    // Automatic output enable
            using MOE = Field<15, 1>;    // Main output enable
            using BKF = Field<16, 4>;    // Break filter
            using BKDSRM = Field<26, 1>;    // BKDSRM
            using BKBID = Field<28, 1>;    // BKBID
        };

        // timer Deadtime Register 2
        struct DTR2 : public Register<0x40014854> {
            using DTGF = Field<0, 8>;    // Dead-time generator setup
            using DTAE = Field<16, 1>;    // Deadtime Asymmetric Enable
            using DTPE = Field<17, 1>;    // Deadtime Preload Enable
        };

        // TIM timer input selection register
        struct TISEL : public Register<0x4001485c> {
            using TI1SEL = Field<0, 4>;    // TI1[0] to TI1[15] input selection
        };

        // TIM alternate function option register 1
        struct AF1 : public Register<0x40014860> {
            using BKCMP4P = Field<13, 1>;    // BRK COMP4 input polarity
            using BKCMP3P = Field<12, 1>;    // BRK COMP3 input polarity
            using BKCMP2P = Field<11, 1>;    // BRK COMP2 input polarity
            using BKCMP1P = Field<10, 1>;    // BRK COMP1 input polarity
            using BKINP = Field<9, 1>;    // BRK BKIN input polarity
            using BKCMP7E = Field<7, 1>;    // BRK COMP7 enable
            using BKCMP6E = Field<6, 1>;    // BRK COMP6 enable
            using BKCMP5E = Field<5, 1>;    // BRK COMP5 enable
            using BKCMP4E = Field<4, 1>;    // BRK COMP4 enable
            using BKCMP3E = Field<3, 1>;    // BRK COMP3 enable
            using BKCMP2E = Field<2, 1>;    // BRK COMP2 enable
            using BKCMP1E = Field<1, 1>;    // BRK COMP1 enable
            using BKINE = Field<0, 1>;    // BRK BKIN input enable
        };

        // TIM alternate function option register 2
        struct AF2 : public Register<0x40014864> {
            using OCRSEL = Field<16, 3>;    // OCREF_CLR source selection
        };

        // DMA control register
        struct DCR : public Register<0x40014bdc> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x40014be0> {
            using DMAB = Field<0, 32>;    // DMA register for burst accesses
        };

    };

    // Advanced-timers
    struct TIM1 {
        // control register 1
        struct CR1 : public Register<0x40012c00> {
            using DITHEN = Field<12, 1>;    // Dithering Enable
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40012c04> {
            using MMS_3 = Field<25, 1>;    // Master mode selection - bit 3
            using MMS2 = Field<20, 4>;    // Master mode selection 2
            using OIS6 = Field<18, 1>;    // Output Idle state 6 (OC6 output)
            using OIS5 = Field<16, 1>;    // Output Idle state 5 (OC5 output)
            using OIS4N = Field<15, 1>;    // Output Idle state 4 (OC4N output)
            using OIS4 = Field<14, 1>;    // Output Idle state 4
            using OIS3N = Field<13, 1>;    // Output Idle state 3
            using OIS3 = Field<12, 1>;    // Output Idle state 3
            using OIS2N = Field<11, 1>;    // Output Idle state 2
            using OIS2 = Field<10, 1>;    // Output Idle state 2
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
        };

        // slave mode control register
        struct SMCR : public Register<0x40012c08> {
            using SMSPS = Field<25, 1>;    // SMS Preload Source
            using SMSPE = Field<24, 1>;    // SMS Preload Enable
            using TS_4_3 = Field<20, 2>;    // Trigger selection - bit 4:3
            using SMS_3 = Field<16, 1>;    // Slave mode selection - bit 3
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using OCCS = Field<3, 1>;    // OCREF clear selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x40012c0c> {
            using TERRIE = Field<23, 1>;    // Transition Error interrupt enable
            using IERRIE = Field<22, 1>;    // Index Error interrupt enable
            using DIRIE = Field<21, 1>;    // Direction Change interrupt enable
            using IDXIE = Field<20, 1>;    // Index interrupt enable
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
        };

        // status register
        struct SR : public Register<0x40012c10> {
            using TERRF = Field<23, 1>;    // Transition Error interrupt flag
            using IERRF = Field<22, 1>;    // Index Error interrupt flag
            using DIRF = Field<21, 1>;    // Direction Change interrupt flag
            using IDXF = Field<20, 1>;    // Index interrupt flag
            using CC6IF = Field<17, 1>;    // Compare 6 interrupt flag
            using CC5IF = Field<16, 1>;    // Compare 5 interrupt flag
            using SBIF = Field<13, 1>;    // System Break interrupt flag
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using B2IF = Field<8, 1>;    // Break 2 interrupt flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40012c14> {
            using B2G = Field<8, 1>;    // Break 2 generation
            using BG = Field<7, 1>;    // Break generation
            using TG = Field<6, 1>;    // Trigger generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40012c18> {
            using OC2M_3 = Field<24, 1>;    // Output Compare 2 mode - bit 3
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode - bit 3
            using OC2CE = Field<15, 1>;    // Output Compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output Compare 2 mode
            using OC2PE = Field<11, 1>;    // Output Compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output Compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output Compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40012c18> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x40012c1c> {
            using OC4M_3 = Field<24, 1>;    // Output Compare 4 mode - bit 3
            using OC3M_3 = Field<16, 1>;    // Output Compare 3 mode - bit 3
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x40012c1c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40012c20> {
            using CC6P = Field<21, 1>;    // Capture/Compare 6 output polarity
            using CC6E = Field<20, 1>;    // Capture/Compare 6 output enable
            using CC5P = Field<17, 1>;    // Capture/Compare 5 output polarity
            using CC5E = Field<16, 1>;    // Capture/Compare 5 output enable
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 complementary output polarity
            using CC4NE = Field<14, 1>;    // Capture/Compare 4 complementary output enable
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3NE = Field<10, 1>;    // Capture/Compare 3 complementary output enable
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2NE = Field<6, 1>;    // Capture/Compare 2 complementary output enable
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40012c24> {
            using UIFCPY = Field<31, 1>;    // UIFCPY
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40012c28> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x40012c2c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // repetition counter register
        struct RCR : public Register<0x40012c30> {
            using REP = Field<0, 16>;    // Repetition counter value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40012c34> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40012c38> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x40012c3c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40012c40> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40012c44> {
            using BK2ID = Field<29, 1>;    // BK2ID
            using BKBID = Field<28, 1>;    // BKBID
            using BK2DSRM = Field<27, 1>;    // BK2DSRM
            using BKDSRM = Field<26, 1>;    // BKDSRM
            using BK2P = Field<25, 1>;    // Break 2 polarity
            using BK2E = Field<24, 1>;    // Break 2 Enable
            using BK2F = Field<20, 4>;    // Break 2 filter
            using BKF = Field<16, 4>;    // Break filter
            using MOE = Field<15, 1>;    // Main output enable
            using AOE = Field<14, 1>;    // Automatic output enable
            using BKP = Field<13, 1>;    // Break polarity
            using BKE = Field<12, 1>;    // Break enable
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using LOCK = Field<8, 2>;    // Lock configuration
            using DTG = Field<0, 8>;    // Dead-time generator setup
        };

        // capture/compare register 4
        struct CCR5 : public Register<0x40012c48> {
            using Field = Field<0, 16>;    // Capture/Compare value
            using GC5C1 = Field<29, 1>;    // Group Channel 5 and Channel 1
            using GC5C2 = Field<30, 1>;    // Group Channel 5 and Channel 2
            using GC5C3 = Field<31, 1>;    // Group Channel 5 and Channel 3
        };

        // capture/compare register 4
        struct CCR6 : public Register<0x40012c4c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR3_Output : public Register<0x40012c50> {
            using OC6M_bit3 = Field<24, 1>;    // Output Compare 6 mode bit 3
            using OC5M_bit3 = Field<16, 3>;    // Output Compare 5 mode bit 3
            using OC6CE = Field<15, 1>;    // Output compare 6 clear enable
            using OC6M = Field<12, 3>;    // Output compare 6 mode
            using OC6PE = Field<11, 1>;    // Output compare 6 preload enable
            using OC6FE = Field<10, 1>;    // Output compare 6 fast enable
            using OC5CE = Field<7, 1>;    // Output compare 5 clear enable
            using OC5M = Field<4, 3>;    // Output compare 5 mode
            using OC5PE = Field<3, 1>;    // Output compare 5 preload enable
            using OC5FE = Field<2, 1>;    // Output compare 5 fast enable
        };

        // timer Deadtime Register 2
        struct DTR2 : public Register<0x40012c54> {
            using DTPE = Field<17, 1>;    // Deadtime Preload Enable
            using DTAE = Field<16, 1>;    // Deadtime Asymmetric Enable
            using DTGF = Field<0, 8>;    // Dead-time falling edge generator setup
        };

        // DMA control register
        struct ECR : public Register<0x40012c58> {
            using IE = Field<0, 1>;    // Index Enable
            using IDIR = Field<1, 2>;    // Index Direction
            using IBLK = Field<3, 2>;    // Index Blanking
            using FIDX = Field<5, 1>;    // First Index
            using IPOS = Field<6, 2>;    // Index Positioning
            using PW = Field<16, 8>;    // Pulse width
            using PWPRSC = Field<24, 3>;    // Pulse Width prescaler
        };

        // TIM timer input selection register
        struct TISEL : public Register<0x40012c5c> {
            using TI1SEL = Field<0, 4>;    // TI1[0] to TI1[15] input selection
            using TI2SEL = Field<8, 4>;    // TI2[0] to TI2[15] input selection
            using TI3SEL = Field<16, 4>;    // TI3[0] to TI3[15] input selection
            using TI4SEL = Field<24, 4>;    // TI4[0] to TI4[15] input selection
        };

        // TIM alternate function option register 1
        struct AF1 : public Register<0x40012c60> {
            using ETRSEL = Field<14, 4>;    // ETR source selection
            using BKCMP4P = Field<13, 1>;    // BRK COMP4 input polarity
            using BKCMP3P = Field<12, 1>;    // BRK COMP3 input polarity
            using BKCMP2P = Field<11, 1>;    // BRK COMP2 input polarity
            using BKCMP1P = Field<10, 1>;    // BRK COMP1 input polarity
            using BKINP = Field<9, 1>;    // BRK BKIN input polarity
            using BKCMP7E = Field<7, 1>;    // BRK COMP7 enable
            using BKCMP6E = Field<6, 1>;    // BRK COMP6 enable
            using BKCMP5E = Field<5, 1>;    // BRK COMP5 enable
            using BKCMP4E = Field<4, 1>;    // BRK COMP4 enable
            using BKCMP3E = Field<3, 1>;    // BRK COMP3 enable
            using BKCMP2E = Field<2, 1>;    // BRK COMP2 enable
            using BKCMP1E = Field<1, 1>;    // BRK COMP1 enable
            using BKINE = Field<0, 1>;    // BRK BKIN input enable
        };

        // TIM alternate function option register 2
        struct AF2 : public Register<0x40012c64> {
            using OCRSEL = Field<16, 3>;    // OCREF_CLR source selection
            using BK2CMP4P = Field<13, 1>;    // BRK2 COMP4 input polarity
            using BK2CMP3P = Field<12, 1>;    // BRK2 COMP3 input polarity
            using BK2CMP2P = Field<11, 1>;    // BRK2 COMP2 input polarity
            using BK2CMP1P = Field<10, 1>;    // BRK2 COMP1 input polarity
            using BK2INP = Field<9, 1>;    // BRK2 BKIN input polarity
            using BK2CMP7E = Field<7, 1>;    // BRK2 COMP7 enable
            using BK2CMP6E = Field<6, 1>;    // BRK2 COMP6 enable
            using BK2CMP5E = Field<5, 1>;    // BRK2 COMP5 enable
            using BK2CMP4E = Field<4, 1>;    // BRK2 COMP4 enable
            using BK2CMP3E = Field<3, 1>;    // BRK2 COMP3 enable
            using BK2CMP2E = Field<2, 1>;    // BRK2 COMP2 enable
            using BK2CMP1E = Field<1, 1>;    // BRK2 COMP1 enable
            using BKINE = Field<0, 1>;    // BRK BKIN input enable
        };

        // control register
        struct DCR : public Register<0x40012fdc> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x40012fe0> {
            using DMAB = Field<0, 32>;    // DMA register for burst accesses
        };

    };

    // Advanced-timers
    struct TIM8 {
        // control register 1
        struct CR1 : public Register<0x40013400> {
            using DITHEN = Field<12, 1>;    // Dithering Enable
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40013404> {
            using MMS_3 = Field<25, 1>;    // Master mode selection - bit 3
            using MMS2 = Field<20, 4>;    // Master mode selection 2
            using OIS6 = Field<18, 1>;    // Output Idle state 6 (OC6 output)
            using OIS5 = Field<16, 1>;    // Output Idle state 5 (OC5 output)
            using OIS4N = Field<15, 1>;    // Output Idle state 4 (OC4N output)
            using OIS4 = Field<14, 1>;    // Output Idle state 4
            using OIS3N = Field<13, 1>;    // Output Idle state 3
            using OIS3 = Field<12, 1>;    // Output Idle state 3
            using OIS2N = Field<11, 1>;    // Output Idle state 2
            using OIS2 = Field<10, 1>;    // Output Idle state 2
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
        };

        // slave mode control register
        struct SMCR : public Register<0x40013408> {
            using SMSPS = Field<25, 1>;    // SMS Preload Source
            using SMSPE = Field<24, 1>;    // SMS Preload Enable
            using TS_4_3 = Field<20, 2>;    // Trigger selection - bit 4:3
            using SMS_3 = Field<16, 1>;    // Slave mode selection - bit 3
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using OCCS = Field<3, 1>;    // OCREF clear selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001340c> {
            using TERRIE = Field<23, 1>;    // Transition Error interrupt enable
            using IERRIE = Field<22, 1>;    // Index Error interrupt enable
            using DIRIE = Field<21, 1>;    // Direction Change interrupt enable
            using IDXIE = Field<20, 1>;    // Index interrupt enable
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
        };

        // status register
        struct SR : public Register<0x40013410> {
            using TERRF = Field<23, 1>;    // Transition Error interrupt flag
            using IERRF = Field<22, 1>;    // Index Error interrupt flag
            using DIRF = Field<21, 1>;    // Direction Change interrupt flag
            using IDXF = Field<20, 1>;    // Index interrupt flag
            using CC6IF = Field<17, 1>;    // Compare 6 interrupt flag
            using CC5IF = Field<16, 1>;    // Compare 5 interrupt flag
            using SBIF = Field<13, 1>;    // System Break interrupt flag
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using B2IF = Field<8, 1>;    // Break 2 interrupt flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40013414> {
            using B2G = Field<8, 1>;    // Break 2 generation
            using BG = Field<7, 1>;    // Break generation
            using TG = Field<6, 1>;    // Trigger generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40013418> {
            using OC2M_3 = Field<24, 1>;    // Output Compare 2 mode - bit 3
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode - bit 3
            using OC2CE = Field<15, 1>;    // Output Compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output Compare 2 mode
            using OC2PE = Field<11, 1>;    // Output Compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output Compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output Compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40013418> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4001341c> {
            using OC4M_3 = Field<24, 1>;    // Output Compare 4 mode - bit 3
            using OC3M_3 = Field<16, 1>;    // Output Compare 3 mode - bit 3
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4001341c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40013420> {
            using CC6P = Field<21, 1>;    // Capture/Compare 6 output polarity
            using CC6E = Field<20, 1>;    // Capture/Compare 6 output enable
            using CC5P = Field<17, 1>;    // Capture/Compare 5 output polarity
            using CC5E = Field<16, 1>;    // Capture/Compare 5 output enable
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 complementary output polarity
            using CC4NE = Field<14, 1>;    // Capture/Compare 4 complementary output enable
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3NE = Field<10, 1>;    // Capture/Compare 3 complementary output enable
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2NE = Field<6, 1>;    // Capture/Compare 2 complementary output enable
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40013424> {
            using UIFCPY = Field<31, 1>;    // UIFCPY
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40013428> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001342c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // repetition counter register
        struct RCR : public Register<0x40013430> {
            using REP = Field<0, 16>;    // Repetition counter value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40013434> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40013438> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4001343c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40013440> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40013444> {
            using BK2ID = Field<29, 1>;    // BK2ID
            using BKBID = Field<28, 1>;    // BKBID
            using BK2DSRM = Field<27, 1>;    // BK2DSRM
            using BKDSRM = Field<26, 1>;    // BKDSRM
            using BK2P = Field<25, 1>;    // Break 2 polarity
            using BK2E = Field<24, 1>;    // Break 2 Enable
            using BK2F = Field<20, 4>;    // Break 2 filter
            using BKF = Field<16, 4>;    // Break filter
            using MOE = Field<15, 1>;    // Main output enable
            using AOE = Field<14, 1>;    // Automatic output enable
            using BKP = Field<13, 1>;    // Break polarity
            using BKE = Field<12, 1>;    // Break enable
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using LOCK = Field<8, 2>;    // Lock configuration
            using DTG = Field<0, 8>;    // Dead-time generator setup
        };

        // capture/compare register 4
        struct CCR5 : public Register<0x40013448> {
            using Field = Field<0, 16>;    // Capture/Compare value
            using GC5C1 = Field<29, 1>;    // Group Channel 5 and Channel 1
            using GC5C2 = Field<30, 1>;    // Group Channel 5 and Channel 2
            using GC5C3 = Field<31, 1>;    // Group Channel 5 and Channel 3
        };

        // capture/compare register 4
        struct CCR6 : public Register<0x4001344c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR3_Output : public Register<0x40013450> {
            using OC6M_bit3 = Field<24, 1>;    // Output Compare 6 mode bit 3
            using OC5M_bit3 = Field<16, 3>;    // Output Compare 5 mode bit 3
            using OC6CE = Field<15, 1>;    // Output compare 6 clear enable
            using OC6M = Field<12, 3>;    // Output compare 6 mode
            using OC6PE = Field<11, 1>;    // Output compare 6 preload enable
            using OC6FE = Field<10, 1>;    // Output compare 6 fast enable
            using OC5CE = Field<7, 1>;    // Output compare 5 clear enable
            using OC5M = Field<4, 3>;    // Output compare 5 mode
            using OC5PE = Field<3, 1>;    // Output compare 5 preload enable
            using OC5FE = Field<2, 1>;    // Output compare 5 fast enable
        };

        // timer Deadtime Register 2
        struct DTR2 : public Register<0x40013454> {
            using DTPE = Field<17, 1>;    // Deadtime Preload Enable
            using DTAE = Field<16, 1>;    // Deadtime Asymmetric Enable
            using DTGF = Field<0, 8>;    // Dead-time falling edge generator setup
        };

        // DMA control register
        struct ECR : public Register<0x40013458> {
            using IE = Field<0, 1>;    // Index Enable
            using IDIR = Field<1, 2>;    // Index Direction
            using IBLK = Field<3, 2>;    // Index Blanking
            using FIDX = Field<5, 1>;    // First Index
            using IPOS = Field<6, 2>;    // Index Positioning
            using PW = Field<16, 8>;    // Pulse width
            using PWPRSC = Field<24, 3>;    // Pulse Width prescaler
        };

        // TIM timer input selection register
        struct TISEL : public Register<0x4001345c> {
            using TI1SEL = Field<0, 4>;    // TI1[0] to TI1[15] input selection
            using TI2SEL = Field<8, 4>;    // TI2[0] to TI2[15] input selection
            using TI3SEL = Field<16, 4>;    // TI3[0] to TI3[15] input selection
            using TI4SEL = Field<24, 4>;    // TI4[0] to TI4[15] input selection
        };

        // TIM alternate function option register 1
        struct AF1 : public Register<0x40013460> {
            using ETRSEL = Field<14, 4>;    // ETR source selection
            using BKCMP4P = Field<13, 1>;    // BRK COMP4 input polarity
            using BKCMP3P = Field<12, 1>;    // BRK COMP3 input polarity
            using BKCMP2P = Field<11, 1>;    // BRK COMP2 input polarity
            using BKCMP1P = Field<10, 1>;    // BRK COMP1 input polarity
            using BKINP = Field<9, 1>;    // BRK BKIN input polarity
            using BKCMP7E = Field<7, 1>;    // BRK COMP7 enable
            using BKCMP6E = Field<6, 1>;    // BRK COMP6 enable
            using BKCMP5E = Field<5, 1>;    // BRK COMP5 enable
            using BKCMP4E = Field<4, 1>;    // BRK COMP4 enable
            using BKCMP3E = Field<3, 1>;    // BRK COMP3 enable
            using BKCMP2E = Field<2, 1>;    // BRK COMP2 enable
            using BKCMP1E = Field<1, 1>;    // BRK COMP1 enable
            using BKINE = Field<0, 1>;    // BRK BKIN input enable
        };

        // TIM alternate function option register 2
        struct AF2 : public Register<0x40013464> {
            using OCRSEL = Field<16, 3>;    // OCREF_CLR source selection
            using BK2CMP4P = Field<13, 1>;    // BRK2 COMP4 input polarity
            using BK2CMP3P = Field<12, 1>;    // BRK2 COMP3 input polarity
            using BK2CMP2P = Field<11, 1>;    // BRK2 COMP2 input polarity
            using BK2CMP1P = Field<10, 1>;    // BRK2 COMP1 input polarity
            using BK2INP = Field<9, 1>;    // BRK2 BKIN input polarity
            using BK2CMP7E = Field<7, 1>;    // BRK2 COMP7 enable
            using BK2CMP6E = Field<6, 1>;    // BRK2 COMP6 enable
            using BK2CMP5E = Field<5, 1>;    // BRK2 COMP5 enable
            using BK2CMP4E = Field<4, 1>;    // BRK2 COMP4 enable
            using BK2CMP3E = Field<3, 1>;    // BRK2 COMP3 enable
            using BK2CMP2E = Field<2, 1>;    // BRK2 COMP2 enable
            using BK2CMP1E = Field<1, 1>;    // BRK2 COMP1 enable
            using BKINE = Field<0, 1>;    // BRK BKIN input enable
        };

        // control register
        struct DCR : public Register<0x400137dc> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x400137e0> {
            using DMAB = Field<0, 32>;    // DMA register for burst accesses
        };

    };

    // Advanced-timers
    struct TIM2 {
        // control register 1
        struct CR1 : public Register<0x40000000> {
            using DITHEN = Field<12, 1>;    // Dithering Enable
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000004> {
            using MMS_3 = Field<25, 1>;    // Master mode selection - bit 3
            using MMS2 = Field<20, 4>;    // Master mode selection 2
            using OIS6 = Field<18, 1>;    // Output Idle state 6 (OC6 output)
            using OIS5 = Field<16, 1>;    // Output Idle state 5 (OC5 output)
            using OIS4N = Field<15, 1>;    // Output Idle state 4 (OC4N output)
            using OIS4 = Field<14, 1>;    // Output Idle state 4
            using OIS3N = Field<13, 1>;    // Output Idle state 3
            using OIS3 = Field<12, 1>;    // Output Idle state 3
            using OIS2N = Field<11, 1>;    // Output Idle state 2
            using OIS2 = Field<10, 1>;    // Output Idle state 2
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
        };

        // slave mode control register
        struct SMCR : public Register<0x40000008> {
            using SMSPS = Field<25, 1>;    // SMS Preload Source
            using SMSPE = Field<24, 1>;    // SMS Preload Enable
            using TS_4_3 = Field<20, 2>;    // Trigger selection - bit 4:3
            using SMS_3 = Field<16, 1>;    // Slave mode selection - bit 3
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using OCCS = Field<3, 1>;    // OCREF clear selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000000c> {
            using TERRIE = Field<23, 1>;    // Transition Error interrupt enable
            using IERRIE = Field<22, 1>;    // Index Error interrupt enable
            using DIRIE = Field<21, 1>;    // Direction Change interrupt enable
            using IDXIE = Field<20, 1>;    // Index interrupt enable
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
        };

        // status register
        struct SR : public Register<0x40000010> {
            using TERRF = Field<23, 1>;    // Transition Error interrupt flag
            using IERRF = Field<22, 1>;    // Index Error interrupt flag
            using DIRF = Field<21, 1>;    // Direction Change interrupt flag
            using IDXF = Field<20, 1>;    // Index interrupt flag
            using CC6IF = Field<17, 1>;    // Compare 6 interrupt flag
            using CC5IF = Field<16, 1>;    // Compare 5 interrupt flag
            using SBIF = Field<13, 1>;    // System Break interrupt flag
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using B2IF = Field<8, 1>;    // Break 2 interrupt flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40000014> {
            using B2G = Field<8, 1>;    // Break 2 generation
            using BG = Field<7, 1>;    // Break generation
            using TG = Field<6, 1>;    // Trigger generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40000018> {
            using OC2M_3 = Field<24, 1>;    // Output Compare 2 mode - bit 3
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode - bit 3
            using OC2CE = Field<15, 1>;    // Output Compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output Compare 2 mode
            using OC2PE = Field<11, 1>;    // Output Compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output Compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output Compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000018> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4000001c> {
            using OC4M_3 = Field<24, 1>;    // Output Compare 4 mode - bit 3
            using OC3M_3 = Field<16, 1>;    // Output Compare 3 mode - bit 3
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000001c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000020> {
            using CC6P = Field<21, 1>;    // Capture/Compare 6 output polarity
            using CC6E = Field<20, 1>;    // Capture/Compare 6 output enable
            using CC5P = Field<17, 1>;    // Capture/Compare 5 output polarity
            using CC5E = Field<16, 1>;    // Capture/Compare 5 output enable
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 complementary output polarity
            using CC4NE = Field<14, 1>;    // Capture/Compare 4 complementary output enable
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3NE = Field<10, 1>;    // Capture/Compare 3 complementary output enable
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2NE = Field<6, 1>;    // Capture/Compare 2 complementary output enable
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000024> {
            using UIFCPY = Field<31, 1>;    // UIFCPY
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40000028> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000002c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // repetition counter register
        struct RCR : public Register<0x40000030> {
            using REP = Field<0, 16>;    // Repetition counter value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000034> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40000038> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4000003c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40000040> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40000044> {
            using BK2ID = Field<29, 1>;    // BK2ID
            using BKBID = Field<28, 1>;    // BKBID
            using BK2DSRM = Field<27, 1>;    // BK2DSRM
            using BKDSRM = Field<26, 1>;    // BKDSRM
            using BK2P = Field<25, 1>;    // Break 2 polarity
            using BK2E = Field<24, 1>;    // Break 2 Enable
            using BK2F = Field<20, 4>;    // Break 2 filter
            using BKF = Field<16, 4>;    // Break filter
            using MOE = Field<15, 1>;    // Main output enable
            using AOE = Field<14, 1>;    // Automatic output enable
            using BKP = Field<13, 1>;    // Break polarity
            using BKE = Field<12, 1>;    // Break enable
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using LOCK = Field<8, 2>;    // Lock configuration
            using DTG = Field<0, 8>;    // Dead-time generator setup
        };

        // capture/compare register 4
        struct CCR5 : public Register<0x40000048> {
            using Field = Field<0, 16>;    // Capture/Compare value
            using GC5C1 = Field<29, 1>;    // Group Channel 5 and Channel 1
            using GC5C2 = Field<30, 1>;    // Group Channel 5 and Channel 2
            using GC5C3 = Field<31, 1>;    // Group Channel 5 and Channel 3
        };

        // capture/compare register 4
        struct CCR6 : public Register<0x4000004c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR3_Output : public Register<0x40000050> {
            using OC6M_bit3 = Field<24, 1>;    // Output Compare 6 mode bit 3
            using OC5M_bit3 = Field<16, 3>;    // Output Compare 5 mode bit 3
            using OC6CE = Field<15, 1>;    // Output compare 6 clear enable
            using OC6M = Field<12, 3>;    // Output compare 6 mode
            using OC6PE = Field<11, 1>;    // Output compare 6 preload enable
            using OC6FE = Field<10, 1>;    // Output compare 6 fast enable
            using OC5CE = Field<7, 1>;    // Output compare 5 clear enable
            using OC5M = Field<4, 3>;    // Output compare 5 mode
            using OC5PE = Field<3, 1>;    // Output compare 5 preload enable
            using OC5FE = Field<2, 1>;    // Output compare 5 fast enable
        };

        // timer Deadtime Register 2
        struct DTR2 : public Register<0x40000054> {
            using DTPE = Field<17, 1>;    // Deadtime Preload Enable
            using DTAE = Field<16, 1>;    // Deadtime Asymmetric Enable
            using DTGF = Field<0, 8>;    // Dead-time falling edge generator setup
        };

        // DMA control register
        struct ECR : public Register<0x40000058> {
            using IE = Field<0, 1>;    // Index Enable
            using IDIR = Field<1, 2>;    // Index Direction
            using IBLK = Field<3, 2>;    // Index Blanking
            using FIDX = Field<5, 1>;    // First Index
            using IPOS = Field<6, 2>;    // Index Positioning
            using PW = Field<16, 8>;    // Pulse width
            using PWPRSC = Field<24, 3>;    // Pulse Width prescaler
        };

        // TIM timer input selection register
        struct TISEL : public Register<0x4000005c> {
            using TI1SEL = Field<0, 4>;    // TI1[0] to TI1[15] input selection
            using TI2SEL = Field<8, 4>;    // TI2[0] to TI2[15] input selection
            using TI3SEL = Field<16, 4>;    // TI3[0] to TI3[15] input selection
            using TI4SEL = Field<24, 4>;    // TI4[0] to TI4[15] input selection
        };

        // TIM alternate function option register 1
        struct AF1 : public Register<0x40000060> {
            using ETRSEL = Field<14, 4>;    // ETR source selection
            using BKCMP4P = Field<13, 1>;    // BRK COMP4 input polarity
            using BKCMP3P = Field<12, 1>;    // BRK COMP3 input polarity
            using BKCMP2P = Field<11, 1>;    // BRK COMP2 input polarity
            using BKCMP1P = Field<10, 1>;    // BRK COMP1 input polarity
            using BKINP = Field<9, 1>;    // BRK BKIN input polarity
            using BKCMP7E = Field<7, 1>;    // BRK COMP7 enable
            using BKCMP6E = Field<6, 1>;    // BRK COMP6 enable
            using BKCMP5E = Field<5, 1>;    // BRK COMP5 enable
            using BKCMP4E = Field<4, 1>;    // BRK COMP4 enable
            using BKCMP3E = Field<3, 1>;    // BRK COMP3 enable
            using BKCMP2E = Field<2, 1>;    // BRK COMP2 enable
            using BKCMP1E = Field<1, 1>;    // BRK COMP1 enable
            using BKINE = Field<0, 1>;    // BRK BKIN input enable
        };

        // TIM alternate function option register 2
        struct AF2 : public Register<0x40000064> {
            using OCRSEL = Field<16, 3>;    // OCREF_CLR source selection
            using BK2CMP4P = Field<13, 1>;    // BRK2 COMP4 input polarity
            using BK2CMP3P = Field<12, 1>;    // BRK2 COMP3 input polarity
            using BK2CMP2P = Field<11, 1>;    // BRK2 COMP2 input polarity
            using BK2CMP1P = Field<10, 1>;    // BRK2 COMP1 input polarity
            using BK2INP = Field<9, 1>;    // BRK2 BKIN input polarity
            using BK2CMP7E = Field<7, 1>;    // BRK2 COMP7 enable
            using BK2CMP6E = Field<6, 1>;    // BRK2 COMP6 enable
            using BK2CMP5E = Field<5, 1>;    // BRK2 COMP5 enable
            using BK2CMP4E = Field<4, 1>;    // BRK2 COMP4 enable
            using BK2CMP3E = Field<3, 1>;    // BRK2 COMP3 enable
            using BK2CMP2E = Field<2, 1>;    // BRK2 COMP2 enable
            using BK2CMP1E = Field<1, 1>;    // BRK2 COMP1 enable
            using BKINE = Field<0, 1>;    // BRK BKIN input enable
        };

        // control register
        struct DCR : public Register<0x400003dc> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x400003e0> {
            using DMAB = Field<0, 32>;    // DMA register for burst accesses
        };

    };

    // Advanced-timers
    struct TIM3 {
        // control register 1
        struct CR1 : public Register<0x40000400> {
            using DITHEN = Field<12, 1>;    // Dithering Enable
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000404> {
            using MMS_3 = Field<25, 1>;    // Master mode selection - bit 3
            using MMS2 = Field<20, 4>;    // Master mode selection 2
            using OIS6 = Field<18, 1>;    // Output Idle state 6 (OC6 output)
            using OIS5 = Field<16, 1>;    // Output Idle state 5 (OC5 output)
            using OIS4N = Field<15, 1>;    // Output Idle state 4 (OC4N output)
            using OIS4 = Field<14, 1>;    // Output Idle state 4
            using OIS3N = Field<13, 1>;    // Output Idle state 3
            using OIS3 = Field<12, 1>;    // Output Idle state 3
            using OIS2N = Field<11, 1>;    // Output Idle state 2
            using OIS2 = Field<10, 1>;    // Output Idle state 2
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
        };

        // slave mode control register
        struct SMCR : public Register<0x40000408> {
            using SMSPS = Field<25, 1>;    // SMS Preload Source
            using SMSPE = Field<24, 1>;    // SMS Preload Enable
            using TS_4_3 = Field<20, 2>;    // Trigger selection - bit 4:3
            using SMS_3 = Field<16, 1>;    // Slave mode selection - bit 3
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using OCCS = Field<3, 1>;    // OCREF clear selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000040c> {
            using TERRIE = Field<23, 1>;    // Transition Error interrupt enable
            using IERRIE = Field<22, 1>;    // Index Error interrupt enable
            using DIRIE = Field<21, 1>;    // Direction Change interrupt enable
            using IDXIE = Field<20, 1>;    // Index interrupt enable
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
        };

        // status register
        struct SR : public Register<0x40000410> {
            using TERRF = Field<23, 1>;    // Transition Error interrupt flag
            using IERRF = Field<22, 1>;    // Index Error interrupt flag
            using DIRF = Field<21, 1>;    // Direction Change interrupt flag
            using IDXF = Field<20, 1>;    // Index interrupt flag
            using CC6IF = Field<17, 1>;    // Compare 6 interrupt flag
            using CC5IF = Field<16, 1>;    // Compare 5 interrupt flag
            using SBIF = Field<13, 1>;    // System Break interrupt flag
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using B2IF = Field<8, 1>;    // Break 2 interrupt flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40000414> {
            using B2G = Field<8, 1>;    // Break 2 generation
            using BG = Field<7, 1>;    // Break generation
            using TG = Field<6, 1>;    // Trigger generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40000418> {
            using OC2M_3 = Field<24, 1>;    // Output Compare 2 mode - bit 3
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode - bit 3
            using OC2CE = Field<15, 1>;    // Output Compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output Compare 2 mode
            using OC2PE = Field<11, 1>;    // Output Compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output Compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output Compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000418> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4000041c> {
            using OC4M_3 = Field<24, 1>;    // Output Compare 4 mode - bit 3
            using OC3M_3 = Field<16, 1>;    // Output Compare 3 mode - bit 3
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000041c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000420> {
            using CC6P = Field<21, 1>;    // Capture/Compare 6 output polarity
            using CC6E = Field<20, 1>;    // Capture/Compare 6 output enable
            using CC5P = Field<17, 1>;    // Capture/Compare 5 output polarity
            using CC5E = Field<16, 1>;    // Capture/Compare 5 output enable
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 complementary output polarity
            using CC4NE = Field<14, 1>;    // Capture/Compare 4 complementary output enable
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3NE = Field<10, 1>;    // Capture/Compare 3 complementary output enable
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2NE = Field<6, 1>;    // Capture/Compare 2 complementary output enable
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000424> {
            using UIFCPY = Field<31, 1>;    // UIFCPY
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40000428> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000042c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // repetition counter register
        struct RCR : public Register<0x40000430> {
            using REP = Field<0, 16>;    // Repetition counter value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000434> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40000438> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4000043c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40000440> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40000444> {
            using BK2ID = Field<29, 1>;    // BK2ID
            using BKBID = Field<28, 1>;    // BKBID
            using BK2DSRM = Field<27, 1>;    // BK2DSRM
            using BKDSRM = Field<26, 1>;    // BKDSRM
            using BK2P = Field<25, 1>;    // Break 2 polarity
            using BK2E = Field<24, 1>;    // Break 2 Enable
            using BK2F = Field<20, 4>;    // Break 2 filter
            using BKF = Field<16, 4>;    // Break filter
            using MOE = Field<15, 1>;    // Main output enable
            using AOE = Field<14, 1>;    // Automatic output enable
            using BKP = Field<13, 1>;    // Break polarity
            using BKE = Field<12, 1>;    // Break enable
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using LOCK = Field<8, 2>;    // Lock configuration
            using DTG = Field<0, 8>;    // Dead-time generator setup
        };

        // capture/compare register 4
        struct CCR5 : public Register<0x40000448> {
            using Field = Field<0, 16>;    // Capture/Compare value
            using GC5C1 = Field<29, 1>;    // Group Channel 5 and Channel 1
            using GC5C2 = Field<30, 1>;    // Group Channel 5 and Channel 2
            using GC5C3 = Field<31, 1>;    // Group Channel 5 and Channel 3
        };

        // capture/compare register 4
        struct CCR6 : public Register<0x4000044c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR3_Output : public Register<0x40000450> {
            using OC6M_bit3 = Field<24, 1>;    // Output Compare 6 mode bit 3
            using OC5M_bit3 = Field<16, 3>;    // Output Compare 5 mode bit 3
            using OC6CE = Field<15, 1>;    // Output compare 6 clear enable
            using OC6M = Field<12, 3>;    // Output compare 6 mode
            using OC6PE = Field<11, 1>;    // Output compare 6 preload enable
            using OC6FE = Field<10, 1>;    // Output compare 6 fast enable
            using OC5CE = Field<7, 1>;    // Output compare 5 clear enable
            using OC5M = Field<4, 3>;    // Output compare 5 mode
            using OC5PE = Field<3, 1>;    // Output compare 5 preload enable
            using OC5FE = Field<2, 1>;    // Output compare 5 fast enable
        };

        // timer Deadtime Register 2
        struct DTR2 : public Register<0x40000454> {
            using DTPE = Field<17, 1>;    // Deadtime Preload Enable
            using DTAE = Field<16, 1>;    // Deadtime Asymmetric Enable
            using DTGF = Field<0, 8>;    // Dead-time falling edge generator setup
        };

        // DMA control register
        struct ECR : public Register<0x40000458> {
            using IE = Field<0, 1>;    // Index Enable
            using IDIR = Field<1, 2>;    // Index Direction
            using IBLK = Field<3, 2>;    // Index Blanking
            using FIDX = Field<5, 1>;    // First Index
            using IPOS = Field<6, 2>;    // Index Positioning
            using PW = Field<16, 8>;    // Pulse width
            using PWPRSC = Field<24, 3>;    // Pulse Width prescaler
        };

        // TIM timer input selection register
        struct TISEL : public Register<0x4000045c> {
            using TI1SEL = Field<0, 4>;    // TI1[0] to TI1[15] input selection
            using TI2SEL = Field<8, 4>;    // TI2[0] to TI2[15] input selection
            using TI3SEL = Field<16, 4>;    // TI3[0] to TI3[15] input selection
            using TI4SEL = Field<24, 4>;    // TI4[0] to TI4[15] input selection
        };

        // TIM alternate function option register 1
        struct AF1 : public Register<0x40000460> {
            using ETRSEL = Field<14, 4>;    // ETR source selection
            using BKCMP4P = Field<13, 1>;    // BRK COMP4 input polarity
            using BKCMP3P = Field<12, 1>;    // BRK COMP3 input polarity
            using BKCMP2P = Field<11, 1>;    // BRK COMP2 input polarity
            using BKCMP1P = Field<10, 1>;    // BRK COMP1 input polarity
            using BKINP = Field<9, 1>;    // BRK BKIN input polarity
            using BKCMP7E = Field<7, 1>;    // BRK COMP7 enable
            using BKCMP6E = Field<6, 1>;    // BRK COMP6 enable
            using BKCMP5E = Field<5, 1>;    // BRK COMP5 enable
            using BKCMP4E = Field<4, 1>;    // BRK COMP4 enable
            using BKCMP3E = Field<3, 1>;    // BRK COMP3 enable
            using BKCMP2E = Field<2, 1>;    // BRK COMP2 enable
            using BKCMP1E = Field<1, 1>;    // BRK COMP1 enable
            using BKINE = Field<0, 1>;    // BRK BKIN input enable
        };

        // TIM alternate function option register 2
        struct AF2 : public Register<0x40000464> {
            using OCRSEL = Field<16, 3>;    // OCREF_CLR source selection
            using BK2CMP4P = Field<13, 1>;    // BRK2 COMP4 input polarity
            using BK2CMP3P = Field<12, 1>;    // BRK2 COMP3 input polarity
            using BK2CMP2P = Field<11, 1>;    // BRK2 COMP2 input polarity
            using BK2CMP1P = Field<10, 1>;    // BRK2 COMP1 input polarity
            using BK2INP = Field<9, 1>;    // BRK2 BKIN input polarity
            using BK2CMP7E = Field<7, 1>;    // BRK2 COMP7 enable
            using BK2CMP6E = Field<6, 1>;    // BRK2 COMP6 enable
            using BK2CMP5E = Field<5, 1>;    // BRK2 COMP5 enable
            using BK2CMP4E = Field<4, 1>;    // BRK2 COMP4 enable
            using BK2CMP3E = Field<3, 1>;    // BRK2 COMP3 enable
            using BK2CMP2E = Field<2, 1>;    // BRK2 COMP2 enable
            using BK2CMP1E = Field<1, 1>;    // BRK2 COMP1 enable
            using BKINE = Field<0, 1>;    // BRK BKIN input enable
        };

        // control register
        struct DCR : public Register<0x400007dc> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x400007e0> {
            using DMAB = Field<0, 32>;    // DMA register for burst accesses
        };

    };

    // Advanced-timers
    struct TIM4 {
        // control register 1
        struct CR1 : public Register<0x40000800> {
            using DITHEN = Field<12, 1>;    // Dithering Enable
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000804> {
            using MMS_3 = Field<25, 1>;    // Master mode selection - bit 3
            using MMS2 = Field<20, 4>;    // Master mode selection 2
            using OIS6 = Field<18, 1>;    // Output Idle state 6 (OC6 output)
            using OIS5 = Field<16, 1>;    // Output Idle state 5 (OC5 output)
            using OIS4N = Field<15, 1>;    // Output Idle state 4 (OC4N output)
            using OIS4 = Field<14, 1>;    // Output Idle state 4
            using OIS3N = Field<13, 1>;    // Output Idle state 3
            using OIS3 = Field<12, 1>;    // Output Idle state 3
            using OIS2N = Field<11, 1>;    // Output Idle state 2
            using OIS2 = Field<10, 1>;    // Output Idle state 2
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
        };

        // slave mode control register
        struct SMCR : public Register<0x40000808> {
            using SMSPS = Field<25, 1>;    // SMS Preload Source
            using SMSPE = Field<24, 1>;    // SMS Preload Enable
            using TS_4_3 = Field<20, 2>;    // Trigger selection - bit 4:3
            using SMS_3 = Field<16, 1>;    // Slave mode selection - bit 3
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using OCCS = Field<3, 1>;    // OCREF clear selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000080c> {
            using TERRIE = Field<23, 1>;    // Transition Error interrupt enable
            using IERRIE = Field<22, 1>;    // Index Error interrupt enable
            using DIRIE = Field<21, 1>;    // Direction Change interrupt enable
            using IDXIE = Field<20, 1>;    // Index interrupt enable
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
        };

        // status register
        struct SR : public Register<0x40000810> {
            using TERRF = Field<23, 1>;    // Transition Error interrupt flag
            using IERRF = Field<22, 1>;    // Index Error interrupt flag
            using DIRF = Field<21, 1>;    // Direction Change interrupt flag
            using IDXF = Field<20, 1>;    // Index interrupt flag
            using CC6IF = Field<17, 1>;    // Compare 6 interrupt flag
            using CC5IF = Field<16, 1>;    // Compare 5 interrupt flag
            using SBIF = Field<13, 1>;    // System Break interrupt flag
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using B2IF = Field<8, 1>;    // Break 2 interrupt flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40000814> {
            using B2G = Field<8, 1>;    // Break 2 generation
            using BG = Field<7, 1>;    // Break generation
            using TG = Field<6, 1>;    // Trigger generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40000818> {
            using OC2M_3 = Field<24, 1>;    // Output Compare 2 mode - bit 3
            using OC1M_3 = Field<16, 1>;    // Output Compare 1 mode - bit 3
            using OC2CE = Field<15, 1>;    // Output Compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output Compare 2 mode
            using OC2PE = Field<11, 1>;    // Output Compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output Compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output Compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000818> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4000081c> {
            using OC4M_3 = Field<24, 1>;    // Output Compare 4 mode - bit 3
            using OC3M_3 = Field<16, 1>;    // Output Compare 3 mode - bit 3
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000081c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000820> {
            using CC6P = Field<21, 1>;    // Capture/Compare 6 output polarity
            using CC6E = Field<20, 1>;    // Capture/Compare 6 output enable
            using CC5P = Field<17, 1>;    // Capture/Compare 5 output polarity
            using CC5E = Field<16, 1>;    // Capture/Compare 5 output enable
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 complementary output polarity
            using CC4NE = Field<14, 1>;    // Capture/Compare 4 complementary output enable
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3NE = Field<10, 1>;    // Capture/Compare 3 complementary output enable
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2NE = Field<6, 1>;    // Capture/Compare 2 complementary output enable
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000824> {
            using UIFCPY = Field<31, 1>;    // UIFCPY
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40000828> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000082c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // repetition counter register
        struct RCR : public Register<0x40000830> {
            using REP = Field<0, 16>;    // Repetition counter value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000834> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40000838> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4000083c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40000840> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40000844> {
            using BK2ID = Field<29, 1>;    // BK2ID
            using BKBID = Field<28, 1>;    // BKBID
            using BK2DSRM = Field<27, 1>;    // BK2DSRM
            using BKDSRM = Field<26, 1>;    // BKDSRM
            using BK2P = Field<25, 1>;    // Break 2 polarity
            using BK2E = Field<24, 1>;    // Break 2 Enable
            using BK2F = Field<20, 4>;    // Break 2 filter
            using BKF = Field<16, 4>;    // Break filter
            using MOE = Field<15, 1>;    // Main output enable
            using AOE = Field<14, 1>;    // Automatic output enable
            using BKP = Field<13, 1>;    // Break polarity
            using BKE = Field<12, 1>;    // Break enable
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using LOCK = Field<8, 2>;    // Lock configuration
            using DTG = Field<0, 8>;    // Dead-time generator setup
        };

        // capture/compare register 4
        struct CCR5 : public Register<0x40000848> {
            using Field = Field<0, 16>;    // Capture/Compare value
            using GC5C1 = Field<29, 1>;    // Group Channel 5 and Channel 1
            using GC5C2 = Field<30, 1>;    // Group Channel 5 and Channel 2
            using GC5C3 = Field<31, 1>;    // Group Channel 5 and Channel 3
        };

        // capture/compare register 4
        struct CCR6 : public Register<0x4000084c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR3_Output : public Register<0x40000850> {
            using OC6M_bit3 = Field<24, 1>;    // Output Compare 6 mode bit 3
            using OC5M_bit3 = Field<16, 3>;    // Output Compare 5 mode bit 3
            using OC6CE = Field<15, 1>;    // Output compare 6 clear enable
            using OC6M = Field<12, 3>;    // Output compare 6 mode
            using OC6PE = Field<11, 1>;    // Output compare 6 preload enable
            using OC6FE = Field<10, 1>;    // Output compare 6 fast enable
            using OC5CE = Field<7, 1>;    // Output compare 5 clear enable
            using OC5M = Field<4, 3>;    // Output compare 5 mode
            using OC5PE = Field<3, 1>;    // Output compare 5 preload enable
            using OC5FE = Field<2, 1>;    // Output compare 5 fast enable
        };

        // timer Deadtime Register 2
        struct DTR2 : public Register<0x40000854> {
            using DTPE = Field<17, 1>;    // Deadtime Preload Enable
            using DTAE = Field<16, 1>;    // Deadtime Asymmetric Enable
            using DTGF = Field<0, 8>;    // Dead-time falling edge generator setup
        };

        // DMA control register
        struct ECR : public Register<0x40000858> {
            using IE = Field<0, 1>;    // Index Enable
            using IDIR = Field<1, 2>;    // Index Direction
            using IBLK = Field<3, 2>;    // Index Blanking
            using FIDX = Field<5, 1>;    // First Index
            using IPOS = Field<6, 2>;    // Index Positioning
            using PW = Field<16, 8>;    // Pulse width
            using PWPRSC = Field<24, 3>;    // Pulse Width prescaler
        };

        // TIM timer input selection register
        struct TISEL : public Register<0x4000085c> {
            using TI1SEL = Field<0, 4>;    // TI1[0] to TI1[15] input selection
            using TI2SEL = Field<8, 4>;    // TI2[0] to TI2[15] input selection
            using TI3SEL = Field<16, 4>;    // TI3[0] to TI3[15] input selection
            using TI4SEL = Field<24, 4>;    // TI4[0] to TI4[15] input selection
        };

        // TIM alternate function option register 1
        struct AF1 : public Register<0x40000860> {
            using ETRSEL = Field<14, 4>;    // ETR source selection
            using BKCMP4P = Field<13, 1>;    // BRK COMP4 input polarity
            using BKCMP3P = Field<12, 1>;    // BRK COMP3 input polarity
            using BKCMP2P = Field<11, 1>;    // BRK COMP2 input polarity
            using BKCMP1P = Field<10, 1>;    // BRK COMP1 input polarity
            using BKINP = Field<9, 1>;    // BRK BKIN input polarity
            using BKCMP7E = Field<7, 1>;    // BRK COMP7 enable
            using BKCMP6E = Field<6, 1>;    // BRK COMP6 enable
            using BKCMP5E = Field<5, 1>;    // BRK COMP5 enable
            using BKCMP4E = Field<4, 1>;    // BRK COMP4 enable
            using BKCMP3E = Field<3, 1>;    // BRK COMP3 enable
            using BKCMP2E = Field<2, 1>;    // BRK COMP2 enable
            using BKCMP1E = Field<1, 1>;    // BRK COMP1 enable
            using BKINE = Field<0, 1>;    // BRK BKIN input enable
        };

        // TIM alternate function option register 2
        struct AF2 : public Register<0x40000864> {
            using OCRSEL = Field<16, 3>;    // OCREF_CLR source selection
            using BK2CMP4P = Field<13, 1>;    // BRK2 COMP4 input polarity
            using BK2CMP3P = Field<12, 1>;    // BRK2 COMP3 input polarity
            using BK2CMP2P = Field<11, 1>;    // BRK2 COMP2 input polarity
            using BK2CMP1P = Field<10, 1>;    // BRK2 COMP1 input polarity
            using BK2INP = Field<9, 1>;    // BRK2 BKIN input polarity
            using BK2CMP7E = Field<7, 1>;    // BRK2 COMP7 enable
            using BK2CMP6E = Field<6, 1>;    // BRK2 COMP6 enable
            using BK2CMP5E = Field<5, 1>;    // BRK2 COMP5 enable
            using BK2CMP4E = Field<4, 1>;    // BRK2 COMP4 enable
            using BK2CMP3E = Field<3, 1>;    // BRK2 COMP3 enable
            using BK2CMP2E = Field<2, 1>;    // BRK2 COMP2 enable
            using BK2CMP1E = Field<1, 1>;    // BRK2 COMP1 enable
            using BKINE = Field<0, 1>;    // BRK BKIN input enable
        };

        // control register
        struct DCR : public Register<0x40000bdc> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x40000be0> {
            using DMAB = Field<0, 32>;    // DMA register for burst accesses
        };

    };

    // Basic-timers
    struct TIM6 {
        // control register 1
        struct CR1 : public Register<0x40001000> {
            using DITHEN = Field<12, 1>;    // Dithering Enable
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40001004> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000100c> {
            using UDE = Field<8, 1>;    // Update DMA request enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40001010> {
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40001014> {
            using UG = Field<0, 1>;    // Update generation
        };

        // counter
        struct CNT : public Register<0x40001024> {
            using UIFCPY = Field<31, 1>;    // UIF Copy
            using Field = Field<0, 16>;    // Low counter value
        };

        // prescaler
        struct PSC : public Register<0x40001028> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000102c> {
            using Field = Field<0, 16>;    // Low Auto-reload value
        };

    };

    // Basic-timers
    struct TIM7 {
        // control register 1
        struct CR1 : public Register<0x40001400> {
            using DITHEN = Field<12, 1>;    // Dithering Enable
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40001404> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000140c> {
            using UDE = Field<8, 1>;    // Update DMA request enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40001410> {
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40001414> {
            using UG = Field<0, 1>;    // Update generation
        };

        // counter
        struct CNT : public Register<0x40001424> {
            using UIFCPY = Field<31, 1>;    // UIF Copy
            using Field = Field<0, 16>;    // Low counter value
        };

        // prescaler
        struct PSC : public Register<0x40001428> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000142c> {
            using Field = Field<0, 16>;    // Low Auto-reload value
        };

    };

    // Low power timer
    struct LPTIMER1 {
        // Interrupt and Status Register
        struct ISR : public Register<0x40007c00> {
            using DOWN = Field<6, 1>;    // Counter direction change up to down
            using UP = Field<5, 1>;    // Counter direction change down to up
            using ARROK = Field<4, 1>;    // Autoreload register update OK
            using CMPOK = Field<3, 1>;    // Compare register update OK
            using EXTTRIG = Field<2, 1>;    // External trigger edge event
            using ARRM = Field<1, 1>;    // Autoreload match
            using CMPM = Field<0, 1>;    // Compare match
        };

        // Interrupt Clear Register
        struct ICR : public Register<0x40007c04> {
            using DOWNCF = Field<6, 1>;    // Direction change to down Clear Flag
            using UPCF = Field<5, 1>;    // Direction change to UP Clear Flag
            using ARROKCF = Field<4, 1>;    // Autoreload register update OK Clear Flag
            using CMPOKCF = Field<3, 1>;    // Compare register update OK Clear Flag
            using EXTTRIGCF = Field<2, 1>;    // External trigger valid edge Clear Flag
            using ARRMCF = Field<1, 1>;    // Autoreload match Clear Flag
            using CMPMCF = Field<0, 1>;    // compare match Clear Flag
        };

        // Interrupt Enable Register
        struct IER : public Register<0x40007c08> {
            using DOWNIE = Field<6, 1>;    // Direction change to down Interrupt Enable
            using UPIE = Field<5, 1>;    // Direction change to UP Interrupt Enable
            using ARROKIE = Field<4, 1>;    // Autoreload register update OK Interrupt Enable
            using CMPOKIE = Field<3, 1>;    // Compare register update OK Interrupt Enable
            using EXTTRIGIE = Field<2, 1>;    // External trigger valid edge Interrupt Enable
            using ARRMIE = Field<1, 1>;    // Autoreload match Interrupt Enable
            using CMPMIE = Field<0, 1>;    // Compare match Interrupt Enable
        };

        // Configuration Register
        struct CFGR : public Register<0x40007c0c> {
            using ENC = Field<24, 1>;    // Encoder mode enable
            using COUNTMODE = Field<23, 1>;    // counter mode enabled
            using PRELOAD = Field<22, 1>;    // Registers update mode
            using WAVPOL = Field<21, 1>;    // Waveform shape polarity
            using WAVE = Field<20, 1>;    // Waveform shape
            using TIMOUT = Field<19, 1>;    // Timeout enable
            using TRIGEN = Field<17, 2>;    // Trigger enable and polarity
            using TRIGSEL = Field<13, 4>;    // Trigger selector
            using PRESC = Field<9, 3>;    // Clock prescaler
            using TRGFLT = Field<6, 2>;    // Configurable digital filter for trigger
            using CKFLT = Field<3, 2>;    // Configurable digital filter for external clock
            using CKPOL = Field<1, 2>;    // Clock Polarity
            using CKSEL = Field<0, 1>;    // Clock selector
        };

        // Control Register
        struct CR : public Register<0x40007c10> {
            using RSTARE = Field<4, 1>;    // RSTARE
            using COUNTRST = Field<3, 1>;    // COUNTRST
            using CNTSTRT = Field<2, 1>;    // Timer start in continuous mode
            using SNGSTRT = Field<1, 1>;    // LPTIM start in single mode
            using ENABLE = Field<0, 1>;    // LPTIM Enable
        };

        // Compare Register
        struct CMP : public Register<0x40007c14> {
            using Field = Field<0, 16>;    // Compare value
        };

        // Autoreload Register
        struct ARR : public Register<0x40007c18> {
            using Field = Field<0, 16>;    // Auto reload value
        };

        // Counter Register
        struct CNT : public Register<0x40007c1c> {
            using Field = Field<0, 16>;    // Counter value
        };

        // option register
        struct OR : public Register<0x40007c20> {
            using IN1 = Field<0, 1>;    // IN1
            using IN2 = Field<1, 1>;    // IN2
            using IN1_2_1 = Field<2, 2>;    // IN1_2_1
            using IN2_2_1 = Field<4, 2>;    // IN2_2_1
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART1 {
        // Control register 1
        struct CR1 : public Register<0x40013800> {
            using RXFFIE = Field<31, 1>;    // RXFFIE
            using TXFEIE = Field<30, 1>;    // TXFEIE
            using FIFOEN = Field<29, 1>;    // FIFOEN
            using M1 = Field<28, 1>;    // M1
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40013804> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
            using DIS_NSS = Field<3, 1>;    // DIS_NSS
            using SLVEN = Field<0, 1>;    // SLVEN
        };

        // Control register 3
        struct CR3 : public Register<0x40013808> {
            using TXFTCFG = Field<29, 3>;    // TXFTCFG
            using RXFTIE = Field<28, 1>;    // RXFTIE
            using RXFTCFG = Field<25, 3>;    // RXFTCFG
            using TCBGTIE = Field<24, 1>;    // TCBGTIE
            using TXFTIE = Field<23, 1>;    // TXFTIE
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4001380c> {
            using DIV_Mantissa = Field<4, 12>;    // DIV_Mantissa
            using DIV_Fraction = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40013810> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40013814> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public Register<0x40013818> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public Register<0x4001381c> {
            using TXFT = Field<27, 1>;    // TXFT
            using RXFT = Field<26, 1>;    // RXFT
            using TCBGT = Field<25, 1>;    // TCBGT
            using RXFF = Field<24, 1>;    // RXFF
            using TXFE = Field<23, 1>;    // TXFE
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using UDR = Field<13, 1>;    // UDR
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public Register<0x40013820> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using UDRCF = Field<13, 1>;    // UDRCF
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCBGTCF = Field<7, 1>;    // TCBGTCF
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using TXFECF = Field<5, 1>;    // TXFECF
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public Register<0x40013824> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40013828> {
            using Field = Field<0, 9>;    // Transmit data value
        };

        // USART prescaler register
        struct PRESC : public Register<0x4001382c> {
            using PRESCALER = Field<0, 4>;    // PRESCALER
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART2 {
        // Control register 1
        struct CR1 : public Register<0x40004400> {
            using RXFFIE = Field<31, 1>;    // RXFFIE
            using TXFEIE = Field<30, 1>;    // TXFEIE
            using FIFOEN = Field<29, 1>;    // FIFOEN
            using M1 = Field<28, 1>;    // M1
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40004404> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
            using DIS_NSS = Field<3, 1>;    // DIS_NSS
            using SLVEN = Field<0, 1>;    // SLVEN
        };

        // Control register 3
        struct CR3 : public Register<0x40004408> {
            using TXFTCFG = Field<29, 3>;    // TXFTCFG
            using RXFTIE = Field<28, 1>;    // RXFTIE
            using RXFTCFG = Field<25, 3>;    // RXFTCFG
            using TCBGTIE = Field<24, 1>;    // TCBGTIE
            using TXFTIE = Field<23, 1>;    // TXFTIE
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4000440c> {
            using DIV_Mantissa = Field<4, 12>;    // DIV_Mantissa
            using DIV_Fraction = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40004410> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40004414> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public Register<0x40004418> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public Register<0x4000441c> {
            using TXFT = Field<27, 1>;    // TXFT
            using RXFT = Field<26, 1>;    // RXFT
            using TCBGT = Field<25, 1>;    // TCBGT
            using RXFF = Field<24, 1>;    // RXFF
            using TXFE = Field<23, 1>;    // TXFE
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using UDR = Field<13, 1>;    // UDR
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public Register<0x40004420> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using UDRCF = Field<13, 1>;    // UDRCF
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCBGTCF = Field<7, 1>;    // TCBGTCF
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using TXFECF = Field<5, 1>;    // TXFECF
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public Register<0x40004424> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40004428> {
            using Field = Field<0, 9>;    // Transmit data value
        };

        // USART prescaler register
        struct PRESC : public Register<0x4000442c> {
            using PRESCALER = Field<0, 4>;    // PRESCALER
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART3 {
        // Control register 1
        struct CR1 : public Register<0x40004800> {
            using RXFFIE = Field<31, 1>;    // RXFFIE
            using TXFEIE = Field<30, 1>;    // TXFEIE
            using FIFOEN = Field<29, 1>;    // FIFOEN
            using M1 = Field<28, 1>;    // M1
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40004804> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
            using DIS_NSS = Field<3, 1>;    // DIS_NSS
            using SLVEN = Field<0, 1>;    // SLVEN
        };

        // Control register 3
        struct CR3 : public Register<0x40004808> {
            using TXFTCFG = Field<29, 3>;    // TXFTCFG
            using RXFTIE = Field<28, 1>;    // RXFTIE
            using RXFTCFG = Field<25, 3>;    // RXFTCFG
            using TCBGTIE = Field<24, 1>;    // TCBGTIE
            using TXFTIE = Field<23, 1>;    // TXFTIE
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4000480c> {
            using DIV_Mantissa = Field<4, 12>;    // DIV_Mantissa
            using DIV_Fraction = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40004810> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40004814> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public Register<0x40004818> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public Register<0x4000481c> {
            using TXFT = Field<27, 1>;    // TXFT
            using RXFT = Field<26, 1>;    // RXFT
            using TCBGT = Field<25, 1>;    // TCBGT
            using RXFF = Field<24, 1>;    // RXFF
            using TXFE = Field<23, 1>;    // TXFE
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using UDR = Field<13, 1>;    // UDR
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public Register<0x40004820> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using UDRCF = Field<13, 1>;    // UDRCF
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCBGTCF = Field<7, 1>;    // TCBGTCF
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using TXFECF = Field<5, 1>;    // TXFECF
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public Register<0x40004824> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40004828> {
            using Field = Field<0, 9>;    // Transmit data value
        };

        // USART prescaler register
        struct PRESC : public Register<0x4000482c> {
            using PRESCALER = Field<0, 4>;    // PRESCALER
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct LPUART1 {
        // Control register 1
        struct CR1 : public Register<0x40008000> {
            using RXFFIE = Field<31, 1>;    // RXFFIE
            using TXFEIE = Field<30, 1>;    // TXFEIE
            using FIFOEN = Field<29, 1>;    // FIFOEN
            using M1 = Field<28, 1>;    // Word length
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40008004> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using STOP = Field<12, 2>;    // STOP bits
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x40008008> {
            using TXFTCFG = Field<29, 3>;    // TXFTCFG
            using RXFTIE = Field<28, 1>;    // RXFTIE
            using RXFTCFG = Field<25, 3>;    // RXFTCFG
            using TXFTIE = Field<23, 1>;    // TXFTIE
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4000800c> {
            using Field = Field<0, 20>;    // BRR
        };

        // Request register
        struct RQR : public Register<0x40008018> {
            using TXFRQ = Field<4, 1>;    // TXFRQ
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
        };

        // Interrupt & status register
        struct ISR : public Register<0x4000801c> {
            using TXFT = Field<27, 1>;    // TXFT
            using RXFT = Field<26, 1>;    // RXFT
            using RXFF = Field<24, 1>;    // RXFF
            using TXFE = Field<23, 1>;    // TXFE
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public Register<0x40008020> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public Register<0x40008024> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40008028> {
            using Field = Field<0, 9>;    // Transmit data value
        };

        // Prescaler register
        struct PRESC : public Register<0x4000802c> {
            using PRESCALER = Field<0, 4>;    // PRESCALER
        };

    };

    // Serial peripheral interface/Inter-IC sound
    struct SPI1 {
        // control register 1
        struct CR1 : public Register<0x40013000> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using DFF = Field<11, 1>;    // Data frame format
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40013004> {
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using SSOE = Field<2, 1>;    // SS output enable
            using NSSP = Field<3, 1>;    // NSS pulse management
            using FRF = Field<4, 1>;    // Frame format
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
            using DS = Field<8, 4>;    // Data size
            using FRXTH = Field<12, 1>;    // FIFO reception threshold
            using LDMA_RX = Field<13, 1>;    // Last DMA transfer for reception
            using LDMA_TX = Field<14, 1>;    // Last DMA transfer for transmission
        };

        // status register
        struct SR : public Register<0x40013008> {
            using RXNE = Field<0, 1>;    // Receive buffer not empty
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using CRCERR = Field<4, 1>;    // CRC error flag
            using MODF = Field<5, 1>;    // Mode fault
            using OVR = Field<6, 1>;    // Overrun flag
            using BSY = Field<7, 1>;    // Busy flag
            using TIFRFE = Field<8, 1>;    // TI frame format error
            using FRLVL = Field<9, 2>;    // FIFO reception level
            using FTLVL = Field<11, 2>;    // FIFO transmission level
        };

        // data register
        struct DR : public Register<0x4001300c> {
            using Field = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40013010> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public Register<0x40013014> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public Register<0x40013018> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

        // configuration register
        struct I2SCFGR : public Register<0x4001301c> {
            using CHLEN = Field<0, 1>;    // CHLEN
            using DATLEN = Field<1, 2>;    // DATLEN
            using CKPOL = Field<3, 1>;    // CKPOL
            using I2SSTD = Field<4, 2>;    // I2SSTD
            using PCMSYNC = Field<7, 1>;    // PCMSYNC
            using I2SCFG = Field<8, 2>;    // I2SCFG
            using I2SE = Field<10, 1>;    // I2SE
            using I2SMOD = Field<11, 1>;    // I2SMOD
        };

        // prescaler register
        struct I2SPR : public Register<0x40013020> {
            using I2SDIV = Field<0, 8>;    // I2SDIV
            using ODD = Field<8, 1>;    // ODD
            using MCKOE = Field<9, 1>;    // MCKOE
        };

    };

    // Serial peripheral interface/Inter-IC sound
    struct SPI3 {
        // control register 1
        struct CR1 : public Register<0x40003c00> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using DFF = Field<11, 1>;    // Data frame format
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40003c04> {
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using SSOE = Field<2, 1>;    // SS output enable
            using NSSP = Field<3, 1>;    // NSS pulse management
            using FRF = Field<4, 1>;    // Frame format
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
            using DS = Field<8, 4>;    // Data size
            using FRXTH = Field<12, 1>;    // FIFO reception threshold
            using LDMA_RX = Field<13, 1>;    // Last DMA transfer for reception
            using LDMA_TX = Field<14, 1>;    // Last DMA transfer for transmission
        };

        // status register
        struct SR : public Register<0x40003c08> {
            using RXNE = Field<0, 1>;    // Receive buffer not empty
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using CRCERR = Field<4, 1>;    // CRC error flag
            using MODF = Field<5, 1>;    // Mode fault
            using OVR = Field<6, 1>;    // Overrun flag
            using BSY = Field<7, 1>;    // Busy flag
            using TIFRFE = Field<8, 1>;    // TI frame format error
            using FRLVL = Field<9, 2>;    // FIFO reception level
            using FTLVL = Field<11, 2>;    // FIFO transmission level
        };

        // data register
        struct DR : public Register<0x40003c0c> {
            using Field = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40003c10> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public Register<0x40003c14> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public Register<0x40003c18> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

        // configuration register
        struct I2SCFGR : public Register<0x40003c1c> {
            using CHLEN = Field<0, 1>;    // CHLEN
            using DATLEN = Field<1, 2>;    // DATLEN
            using CKPOL = Field<3, 1>;    // CKPOL
            using I2SSTD = Field<4, 2>;    // I2SSTD
            using PCMSYNC = Field<7, 1>;    // PCMSYNC
            using I2SCFG = Field<8, 2>;    // I2SCFG
            using I2SE = Field<10, 1>;    // I2SE
            using I2SMOD = Field<11, 1>;    // I2SMOD
        };

        // prescaler register
        struct I2SPR : public Register<0x40003c20> {
            using I2SDIV = Field<0, 8>;    // I2SDIV
            using ODD = Field<8, 1>;    // ODD
            using MCKOE = Field<9, 1>;    // MCKOE
        };

    };

    // Serial peripheral interface/Inter-IC sound
    struct SPI2 {
        // control register 1
        struct CR1 : public Register<0x40003800> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using DFF = Field<11, 1>;    // Data frame format
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40003804> {
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using SSOE = Field<2, 1>;    // SS output enable
            using NSSP = Field<3, 1>;    // NSS pulse management
            using FRF = Field<4, 1>;    // Frame format
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
            using DS = Field<8, 4>;    // Data size
            using FRXTH = Field<12, 1>;    // FIFO reception threshold
            using LDMA_RX = Field<13, 1>;    // Last DMA transfer for reception
            using LDMA_TX = Field<14, 1>;    // Last DMA transfer for transmission
        };

        // status register
        struct SR : public Register<0x40003808> {
            using RXNE = Field<0, 1>;    // Receive buffer not empty
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using CRCERR = Field<4, 1>;    // CRC error flag
            using MODF = Field<5, 1>;    // Mode fault
            using OVR = Field<6, 1>;    // Overrun flag
            using BSY = Field<7, 1>;    // Busy flag
            using TIFRFE = Field<8, 1>;    // TI frame format error
            using FRLVL = Field<9, 2>;    // FIFO reception level
            using FTLVL = Field<11, 2>;    // FIFO transmission level
        };

        // data register
        struct DR : public Register<0x4000380c> {
            using Field = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40003810> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public Register<0x40003814> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public Register<0x40003818> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

        // configuration register
        struct I2SCFGR : public Register<0x4000381c> {
            using CHLEN = Field<0, 1>;    // CHLEN
            using DATLEN = Field<1, 2>;    // DATLEN
            using CKPOL = Field<3, 1>;    // CKPOL
            using I2SSTD = Field<4, 2>;    // I2SSTD
            using PCMSYNC = Field<7, 1>;    // PCMSYNC
            using I2SCFG = Field<8, 2>;    // I2SCFG
            using I2SE = Field<10, 1>;    // I2SE
            using I2SMOD = Field<11, 1>;    // I2SMOD
        };

        // prescaler register
        struct I2SPR : public Register<0x40003820> {
            using I2SDIV = Field<0, 8>;    // I2SDIV
            using ODD = Field<8, 1>;    // ODD
            using MCKOE = Field<9, 1>;    // MCKOE
        };

    };

    // External interrupt/event controller
    struct EXTI {
        // Interrupt mask register
        struct IMR1 : public Register<0x40010400> {
            using IM0 = Field<0, 1>;    // Interrupt Mask on line 0
            using IM1 = Field<1, 1>;    // Interrupt Mask on line 1
            using IM2 = Field<2, 1>;    // Interrupt Mask on line 2
            using IM3 = Field<3, 1>;    // Interrupt Mask on line 3
            using IM4 = Field<4, 1>;    // Interrupt Mask on line 4
            using IM5 = Field<5, 1>;    // Interrupt Mask on line 5
            using IM6 = Field<6, 1>;    // Interrupt Mask on line 6
            using IM7 = Field<7, 1>;    // Interrupt Mask on line 7
            using IM8 = Field<8, 1>;    // Interrupt Mask on line 8
            using IM9 = Field<9, 1>;    // Interrupt Mask on line 9
            using IM10 = Field<10, 1>;    // Interrupt Mask on line 10
            using IM11 = Field<11, 1>;    // Interrupt Mask on line 11
            using IM12 = Field<12, 1>;    // Interrupt Mask on line 12
            using IM13 = Field<13, 1>;    // Interrupt Mask on line 13
            using IM14 = Field<14, 1>;    // Interrupt Mask on line 14
            using IM15 = Field<15, 1>;    // Interrupt Mask on line 15
            using IM16 = Field<16, 1>;    // Interrupt Mask on line 16
            using IM17 = Field<17, 1>;    // Interrupt Mask on line 17
            using IM18 = Field<18, 1>;    // Interrupt Mask on line 18
            using IM19 = Field<19, 1>;    // Interrupt Mask on line 19
            using IM20 = Field<20, 1>;    // Interrupt Mask on line 20
            using IM21 = Field<21, 1>;    // Interrupt Mask on line 21
            using IM22 = Field<22, 1>;    // Interrupt Mask on line 22
            using IM23 = Field<23, 1>;    // Interrupt Mask on line 23
            using IM24 = Field<24, 1>;    // Interrupt Mask on line 24
            using IM25 = Field<25, 1>;    // Interrupt Mask on line 25
            using IM26 = Field<26, 1>;    // Interrupt Mask on line 26
            using IM27 = Field<27, 1>;    // Interrupt Mask on line 27
            using IM28 = Field<28, 1>;    // Interrupt Mask on line 28
            using IM29 = Field<29, 1>;    // Interrupt Mask on line 29
            using IM30 = Field<30, 1>;    // Interrupt Mask on line 30
            using IM31 = Field<31, 1>;    // Interrupt Mask on line 31
        };

        // Event mask register
        struct EMR1 : public Register<0x40010404> {
            using EM0 = Field<0, 1>;    // Event Mask on line 0
            using EM1 = Field<1, 1>;    // Event Mask on line 1
            using EM2 = Field<2, 1>;    // Event Mask on line 2
            using EM3 = Field<3, 1>;    // Event Mask on line 3
            using EM4 = Field<4, 1>;    // Event Mask on line 4
            using EM5 = Field<5, 1>;    // Event Mask on line 5
            using EM6 = Field<6, 1>;    // Event Mask on line 6
            using EM7 = Field<7, 1>;    // Event Mask on line 7
            using EM8 = Field<8, 1>;    // Event Mask on line 8
            using EM9 = Field<9, 1>;    // Event Mask on line 9
            using EM10 = Field<10, 1>;    // Event Mask on line 10
            using EM11 = Field<11, 1>;    // Event Mask on line 11
            using EM12 = Field<12, 1>;    // Event Mask on line 12
            using EM13 = Field<13, 1>;    // Event Mask on line 13
            using EM14 = Field<14, 1>;    // Event Mask on line 14
            using EM15 = Field<15, 1>;    // Event Mask on line 15
            using EM16 = Field<16, 1>;    // Event Mask on line 16
            using EM17 = Field<17, 1>;    // Event Mask on line 17
            using EM18 = Field<18, 1>;    // Event Mask on line 18
            using EM19 = Field<19, 1>;    // Event Mask on line 19
            using EM20 = Field<20, 1>;    // Event Mask on line 20
            using EM21 = Field<21, 1>;    // Event Mask on line 21
            using EM22 = Field<22, 1>;    // Event Mask on line 22
            using EM23 = Field<23, 1>;    // Event Mask on line 23
            using EM24 = Field<24, 1>;    // Event Mask on line 24
            using EM25 = Field<25, 1>;    // Event Mask on line 25
            using EM26 = Field<26, 1>;    // Event Mask on line 26
            using EM27 = Field<27, 1>;    // Event Mask on line 27
            using EM28 = Field<28, 1>;    // Event Mask on line 28
            using EM29 = Field<29, 1>;    // Event Mask on line 29
            using EM30 = Field<30, 1>;    // Event Mask on line 30
            using EM31 = Field<31, 1>;    // Event Mask on line 31
        };

        // Rising Trigger selection register
        struct RTSR1 : public Register<0x40010408> {
            using RT0 = Field<0, 1>;    // Rising trigger event configuration of line 0
            using RT1 = Field<1, 1>;    // Rising trigger event configuration of line 1
            using RT2 = Field<2, 1>;    // Rising trigger event configuration of line 2
            using RT3 = Field<3, 1>;    // Rising trigger event configuration of line 3
            using RT4 = Field<4, 1>;    // Rising trigger event configuration of line 4
            using RT5 = Field<5, 1>;    // Rising trigger event configuration of line 5
            using RT6 = Field<6, 1>;    // Rising trigger event configuration of line 6
            using RT7 = Field<7, 1>;    // Rising trigger event configuration of line 7
            using RT8 = Field<8, 1>;    // Rising trigger event configuration of line 8
            using RT9 = Field<9, 1>;    // Rising trigger event configuration of line 9
            using RT10 = Field<10, 1>;    // Rising trigger event configuration of line 10
            using RT11 = Field<11, 1>;    // Rising trigger event configuration of line 11
            using RT12 = Field<12, 1>;    // Rising trigger event configuration of line 12
            using RT13 = Field<13, 1>;    // Rising trigger event configuration of line 13
            using RT14 = Field<14, 1>;    // Rising trigger event configuration of line 14
            using RT15 = Field<15, 1>;    // Rising trigger event configuration of line 15
            using RT16 = Field<16, 1>;    // Rising trigger event configuration of line 16
            using RT18 = Field<18, 1>;    // Rising trigger event configuration of line 18
            using RT19 = Field<19, 1>;    // Rising trigger event configuration of line 19
            using RT20 = Field<20, 1>;    // Rising trigger event configuration of line 20
            using RT21 = Field<21, 1>;    // Rising trigger event configuration of line 21
            using RT22 = Field<22, 1>;    // Rising trigger event configuration of line 22
            using RT = Field<29, 3>;    // RT
        };

        // Falling Trigger selection register
        struct FTSR1 : public Register<0x4001040c> {
            using FT0 = Field<0, 1>;    // Falling trigger event configuration of line 0
            using FT1 = Field<1, 1>;    // Falling trigger event configuration of line 1
            using FT2 = Field<2, 1>;    // Falling trigger event configuration of line 2
            using FT3 = Field<3, 1>;    // Falling trigger event configuration of line 3
            using FT4 = Field<4, 1>;    // Falling trigger event configuration of line 4
            using FT5 = Field<5, 1>;    // Falling trigger event configuration of line 5
            using FT6 = Field<6, 1>;    // Falling trigger event configuration of line 6
            using FT7 = Field<7, 1>;    // Falling trigger event configuration of line 7
            using FT8 = Field<8, 1>;    // Falling trigger event configuration of line 8
            using FT9 = Field<9, 1>;    // Falling trigger event configuration of line 9
            using FT10 = Field<10, 1>;    // Falling trigger event configuration of line 10
            using FT11 = Field<11, 1>;    // Falling trigger event configuration of line 11
            using FT12 = Field<12, 1>;    // Falling trigger event configuration of line 12
            using FT13 = Field<13, 1>;    // Falling trigger event configuration of line 13
            using FT14 = Field<14, 1>;    // Falling trigger event configuration of line 14
            using FT15 = Field<15, 1>;    // Falling trigger event configuration of line 15
            using FT16 = Field<16, 1>;    // Falling trigger event configuration of line 16
            using FT18 = Field<18, 1>;    // Falling trigger event configuration of line 18
            using FT19 = Field<19, 1>;    // Falling trigger event configuration of line 19
            using FT20 = Field<20, 1>;    // Falling trigger event configuration of line 20
            using FT21 = Field<21, 1>;    // Falling trigger event configuration of line 21
            using FT22 = Field<22, 1>;    // Falling trigger event configuration of line 22
        };

        // Software interrupt event register
        struct SWIER1 : public Register<0x40010410> {
            using SWI0 = Field<0, 1>;    // Software Interrupt on line 0
            using SWI1 = Field<1, 1>;    // Software Interrupt on line 1
            using SWI2 = Field<2, 1>;    // Software Interrupt on line 2
            using SWI3 = Field<3, 1>;    // Software Interrupt on line 3
            using SWI4 = Field<4, 1>;    // Software Interrupt on line 4
            using SWI5 = Field<5, 1>;    // Software Interrupt on line 5
            using SWI6 = Field<6, 1>;    // Software Interrupt on line 6
            using SWI7 = Field<7, 1>;    // Software Interrupt on line 7
            using SWI8 = Field<8, 1>;    // Software Interrupt on line 8
            using SWI9 = Field<9, 1>;    // Software Interrupt on line 9
            using SWI10 = Field<10, 1>;    // Software Interrupt on line 10
            using SWI11 = Field<11, 1>;    // Software Interrupt on line 11
            using SWI12 = Field<12, 1>;    // Software Interrupt on line 12
            using SWI13 = Field<13, 1>;    // Software Interrupt on line 13
            using SWI14 = Field<14, 1>;    // Software Interrupt on line 14
            using SWI15 = Field<15, 1>;    // Software Interrupt on line 15
            using SWI16 = Field<16, 1>;    // Software Interrupt on line 16
            using SWI18 = Field<18, 1>;    // Software Interrupt on line 18
            using SWI19 = Field<19, 1>;    // Software Interrupt on line 19
            using SWI20 = Field<20, 1>;    // Software Interrupt on line 20
            using SWI21 = Field<21, 1>;    // Software Interrupt on line 21
            using SWI22 = Field<22, 1>;    // Software Interrupt on line 22
        };

        // Pending register
        struct PR1 : public Register<0x40010414> {
            using PIF0 = Field<0, 1>;    // Pending bit 0
            using PIF1 = Field<1, 1>;    // Pending bit 1
            using PIF2 = Field<2, 1>;    // Pending bit 2
            using PIF3 = Field<3, 1>;    // Pending bit 3
            using PIF4 = Field<4, 1>;    // Pending bit 4
            using PIF5 = Field<5, 1>;    // Pending bit 5
            using PIF6 = Field<6, 1>;    // Pending bit 6
            using PIF7 = Field<7, 1>;    // Pending bit 7
            using PIF8 = Field<8, 1>;    // Pending bit 8
            using PIF9 = Field<9, 1>;    // Pending bit 9
            using PIF10 = Field<10, 1>;    // Pending bit 10
            using PIF11 = Field<11, 1>;    // Pending bit 11
            using PIF12 = Field<12, 1>;    // Pending bit 12
            using PIF13 = Field<13, 1>;    // Pending bit 13
            using PIF14 = Field<14, 1>;    // Pending bit 14
            using PIF15 = Field<15, 1>;    // Pending bit 15
            using PIF16 = Field<16, 1>;    // Pending bit 16
            using PIF18 = Field<18, 1>;    // Pending bit 18
            using PIF19 = Field<19, 1>;    // Pending bit 19
            using PIF20 = Field<20, 1>;    // Pending bit 20
            using PIF21 = Field<21, 1>;    // Pending bit 21
            using PIF22 = Field<22, 1>;    // Pending bit 22
        };

        // Interrupt mask register
        struct IMR2 : public Register<0x40010420> {
            using IM32 = Field<0, 1>;    // Interrupt Mask on external/internal line 32
            using IM33 = Field<1, 1>;    // Interrupt Mask on external/internal line 33
            using IM34 = Field<2, 1>;    // Interrupt Mask on external/internal line 34
            using IM35 = Field<3, 1>;    // Interrupt Mask on external/internal line 35
            using IM36 = Field<4, 1>;    // Interrupt Mask on external/internal line 36
            using IM37 = Field<5, 1>;    // Interrupt Mask on external/internal line 37
            using IM38 = Field<6, 1>;    // Interrupt Mask on external/internal line 38
            using IM39 = Field<7, 1>;    // Interrupt Mask on external/internal line 39
            using IM40 = Field<8, 1>;    // Interrupt Mask on external/internal line 40
            using IM41 = Field<9, 1>;    // Interrupt Mask on external/internal line 41
            using IM42 = Field<10, 1>;    // Interrupt Mask on external/internal line 42
            using IM43 = Field<11, 1>;    // Interrupt Mask on external/internal line 43
        };

        // Event mask register
        struct EMR2 : public Register<0x40010424> {
            using EM32 = Field<0, 1>;    // Event mask on external/internal line 32
            using EM33 = Field<1, 1>;    // Event mask on external/internal line 33
            using EM34 = Field<2, 1>;    // Event mask on external/internal line 34
            using EM35 = Field<3, 1>;    // Event mask on external/internal line 35
            using EM36 = Field<4, 1>;    // Event mask on external/internal line 36
            using EM37 = Field<5, 1>;    // Event mask on external/internal line 37
            using EM38 = Field<6, 1>;    // Event mask on external/internal line 38
            using EM39 = Field<7, 1>;    // Event mask on external/internal line 39
            using EM40 = Field<8, 1>;    // Event mask on external/internal line 40
        };

        // Rising Trigger selection register
        struct RTSR2 : public Register<0x40010428> {
            using RT32 = Field<0, 1>;    // Rising trigger event configuration bit of line 32
            using RT33 = Field<1, 1>;    // Rising trigger event configuration bit of line 32
            using RT38 = Field<6, 1>;    // Rising trigger event configuration bit of line 38
            using RT39 = Field<7, 1>;    // Rising trigger event configuration bit of line 39
            using RT40 = Field<8, 1>;    // Rising trigger event configuration bit of line 40
            using RT41 = Field<9, 1>;    // Rising trigger event configuration bit of line 41
        };

        // Falling Trigger selection register
        struct FTSR2 : public Register<0x4001042c> {
            using FT35 = Field<3, 1>;    // Falling trigger event configuration bit of line 35
            using FT36 = Field<4, 1>;    // Falling trigger event configuration bit of line 36
            using FT37 = Field<5, 1>;    // Falling trigger event configuration bit of line 37
            using FT38 = Field<6, 1>;    // Falling trigger event configuration bit of line 38
        };

        // Software interrupt event register
        struct SWIER2 : public Register<0x40010430> {
            using SWI35 = Field<3, 1>;    // Software interrupt on line 35
            using SWI36 = Field<4, 1>;    // Software interrupt on line 36
            using SWI37 = Field<5, 1>;    // Software interrupt on line 37
            using SWI38 = Field<6, 1>;    // Software interrupt on line 38
        };

        // Pending register
        struct PR2 : public Register<0x40010434> {
            using PIF35 = Field<3, 1>;    // Pending interrupt flag on line 35
            using PIF36 = Field<4, 1>;    // Pending interrupt flag on line 36
            using PIF37 = Field<5, 1>;    // Pending interrupt flag on line 37
            using PIF38 = Field<6, 1>;    // Pending interrupt flag on line 38
        };

    };

    // Real-time clock
    struct RTC {
        // time register
        struct TR : public Register<0x40002800> {
            using PM = Field<22, 1>;    // AM/PM notation
            using HT = Field<20, 2>;    // Hour tens in BCD format
            using HU = Field<16, 4>;    // Hour units in BCD format
            using MNT = Field<12, 3>;    // Minute tens in BCD format
            using MNU = Field<8, 4>;    // Minute units in BCD format
            using ST = Field<4, 3>;    // Second tens in BCD format
            using SU = Field<0, 4>;    // Second units in BCD format
        };

        // date register
        struct DR : public Register<0x40002804> {
            using YT = Field<20, 4>;    // Year tens in BCD format
            using YU = Field<16, 4>;    // Year units in BCD format
            using WDU = Field<13, 3>;    // Week day units
            using MT = Field<12, 1>;    // Month tens in BCD format
            using MU = Field<8, 4>;    // Month units in BCD format
            using DT = Field<4, 2>;    // Date tens in BCD format
            using DU = Field<0, 4>;    // Date units in BCD format
        };

        // sub second register
        struct SSR : public Register<0x40002808> {
            using SS = Field<0, 16>;    // Sub second value
        };

        // initialization and status register
        struct ICSR : public Register<0x4000280c> {
            using ALRAWF = Field<0, 1>;    // Alarm A write flag
            using ALRBWF = Field<1, 1>;    // Alarm B write flag
            using WUTWF = Field<2, 1>;    // Wakeup timer write flag
            using SHPF = Field<3, 1>;    // Shift operation pending
            using INITS = Field<4, 1>;    // Initialization status flag
            using RSF = Field<5, 1>;    // Registers synchronization flag
            using INITF = Field<6, 1>;    // Initialization flag
            using INIT = Field<7, 1>;    // Initialization mode
            using RECALPF = Field<16, 1>;    // Recalibration pending Flag
        };

        // prescaler register
        struct PRER : public Register<0x40002810> {
            using PREDIV_A = Field<16, 7>;    // Asynchronous prescaler factor
            using PREDIV_S = Field<0, 15>;    // Synchronous prescaler factor
        };

        // wakeup timer register
        struct WUTR : public Register<0x40002814> {
            using WUT = Field<0, 16>;    // Wakeup auto-reload value bits
        };

        // control register
        struct CR : public Register<0x40002818> {
            using WCKSEL = Field<0, 3>;    // Wakeup clock selection
            using TSEDGE = Field<3, 1>;    // Time-stamp event active edge
            using REFCKON = Field<4, 1>;    // Reference clock detection enable (50 or 60 Hz)
            using BYPSHAD = Field<5, 1>;    // Bypass the shadow registers
            using FMT = Field<6, 1>;    // Hour format
            using ALRAE = Field<8, 1>;    // Alarm A enable
            using ALRBE = Field<9, 1>;    // Alarm B enable
            using WUTE = Field<10, 1>;    // Wakeup timer enable
            using TSE = Field<11, 1>;    // Time stamp enable
            using ALRAIE = Field<12, 1>;    // Alarm A interrupt enable
            using ALRBIE = Field<13, 1>;    // Alarm B interrupt enable
            using WUTIE = Field<14, 1>;    // Wakeup timer interrupt enable
            using TSIE = Field<15, 1>;    // Time-stamp interrupt enable
            using ADD1H = Field<16, 1>;    // Add 1 hour (summer time change)
            using SUB1H = Field<17, 1>;    // Subtract 1 hour (winter time change)
            using BKP = Field<18, 1>;    // Backup
            using COSEL = Field<19, 1>;    // Calibration output selection
            using POL = Field<20, 1>;    // Output polarity
            using OSEL = Field<21, 2>;    // Output selection
            using COE = Field<23, 1>;    // Calibration output enable
            using ITSE = Field<24, 1>;    // timestamp on internal event enable
            using TAMPTS = Field<25, 1>;    // TAMPTS
            using TAMPOE = Field<26, 1>;    // TAMPOE
            using TAMPALRM_PU = Field<29, 1>;    // TAMPALRM_PU
            using TAMPALRM_TYPE = Field<30, 1>;    // TAMPALRM_TYPE
            using OUT2EN = Field<31, 1>;    // OUT2EN
        };

        // write protection register
        struct WPR : public Register<0x40002824> {
            using KEY = Field<0, 8>;    // Write protection key
        };

        // calibration register
        struct CALR : public Register<0x40002828> {
            using CALP = Field<15, 1>;    // Increase frequency of RTC by 488.5 ppm
            using CALW8 = Field<14, 1>;    // Use an 8-second calibration cycle period
            using CALW16 = Field<13, 1>;    // Use a 16-second calibration cycle period
            using CALM = Field<0, 9>;    // Calibration minus
        };

        // shift control register
        struct SHIFTR : public Register<0x4000282c> {
            using ADD1S = Field<31, 1>;    // Add one second
            using SUBFS = Field<0, 15>;    // Subtract a fraction of a second
        };

        // time stamp time register
        struct TSTR : public Register<0x40002830> {
            using SU = Field<0, 4>;    // Second units in BCD format
            using ST = Field<4, 3>;    // Second tens in BCD format
            using MNU = Field<8, 4>;    // Minute units in BCD format
            using MNT = Field<12, 3>;    // Minute tens in BCD format
            using HU = Field<16, 4>;    // Hour units in BCD format
            using HT = Field<20, 2>;    // Hour tens in BCD format
            using PM = Field<22, 1>;    // AM/PM notation
        };

        // time stamp date register
        struct TSDR : public Register<0x40002834> {
            using WDU = Field<13, 3>;    // Week day units
            using MT = Field<12, 1>;    // Month tens in BCD format
            using MU = Field<8, 4>;    // Month units in BCD format
            using DT = Field<4, 2>;    // Date tens in BCD format
            using DU = Field<0, 4>;    // Date units in BCD format
        };

        // timestamp sub second register
        struct TSSSR : public Register<0x40002838> {
            using SS = Field<0, 16>;    // Sub second value
        };

        // alarm A register
        struct ALRMAR : public Register<0x40002840> {
            using MSK4 = Field<31, 1>;    // Alarm A date mask
            using WDSEL = Field<30, 1>;    // Week day selection
            using DT = Field<28, 2>;    // Date tens in BCD format
            using DU = Field<24, 4>;    // Date units or day in BCD format
            using MSK3 = Field<23, 1>;    // Alarm A hours mask
            using PM = Field<22, 1>;    // AM/PM notation
            using HT = Field<20, 2>;    // Hour tens in BCD format
            using HU = Field<16, 4>;    // Hour units in BCD format
            using MSK2 = Field<15, 1>;    // Alarm A minutes mask
            using MNT = Field<12, 3>;    // Minute tens in BCD format
            using MNU = Field<8, 4>;    // Minute units in BCD format
            using MSK1 = Field<7, 1>;    // Alarm A seconds mask
            using ST = Field<4, 3>;    // Second tens in BCD format
            using SU = Field<0, 4>;    // Second units in BCD format
        };

        // alarm A sub second register
        struct ALRMASSR : public Register<0x40002844> {
            using MASKSS = Field<24, 4>;    // Mask the most-significant bits starting at this bit
            using SS = Field<0, 15>;    // Sub seconds value
        };

        // alarm B register
        struct ALRMBR : public Register<0x40002848> {
            using MSK4 = Field<31, 1>;    // Alarm B date mask
            using WDSEL = Field<30, 1>;    // Week day selection
            using DT = Field<28, 2>;    // Date tens in BCD format
            using DU = Field<24, 4>;    // Date units or day in BCD format
            using MSK3 = Field<23, 1>;    // Alarm B hours mask
            using PM = Field<22, 1>;    // AM/PM notation
            using HT = Field<20, 2>;    // Hour tens in BCD format
            using HU = Field<16, 4>;    // Hour units in BCD format
            using MSK2 = Field<15, 1>;    // Alarm B minutes mask
            using MNT = Field<12, 3>;    // Minute tens in BCD format
            using MNU = Field<8, 4>;    // Minute units in BCD format
            using MSK1 = Field<7, 1>;    // Alarm B seconds mask
            using ST = Field<4, 3>;    // Second tens in BCD format
            using SU = Field<0, 4>;    // Second units in BCD format
        };

        // alarm B sub second register
        struct ALRMBSSR : public Register<0x4000284c> {
            using MASKSS = Field<24, 4>;    // Mask the most-significant bits starting at this bit
            using SS = Field<0, 15>;    // Sub seconds value
        };

        // status register
        struct SR : public Register<0x40002850> {
            using ALRAF = Field<0, 1>;    // ALRAF
            using ALRBF = Field<1, 1>;    // ALRBF
            using WUTF = Field<2, 1>;    // WUTF
            using TSF = Field<3, 1>;    // TSF
            using TSOVF = Field<4, 1>;    // TSOVF
            using ITSF = Field<5, 1>;    // ITSF
        };

        // status register
        struct MISR : public Register<0x40002854> {
            using ALRAMF = Field<0, 1>;    // ALRAMF
            using ALRBMF = Field<1, 1>;    // ALRBMF
            using WUTMF = Field<2, 1>;    // WUTMF
            using TSMF = Field<3, 1>;    // TSMF
            using TSOVMF = Field<4, 1>;    // TSOVMF
            using ITSMF = Field<5, 1>;    // ITSMF
        };

        // status register
        struct SCR : public Register<0x4000285c> {
            using CALRAF = Field<0, 1>;    // CALRAF
            using CALRBF = Field<1, 1>;    // CALRBF
            using CWUTF = Field<2, 1>;    // CWUTF
            using CTSF = Field<3, 1>;    // CTSF
            using CTSOVF = Field<4, 1>;    // CTSOVF
            using CITSF = Field<5, 1>;    // CITSF
        };

    };

    // DMA controller
    struct DMA1 {
        // interrupt status register
        struct ISR : public Register<0x40020000> {
            using TEIF8 = Field<31, 1>;    // TEIF8
            using HTIF8 = Field<30, 1>;    // HTIF8
            using TCIF8 = Field<29, 1>;    // TCIF8
            using GIF8 = Field<28, 1>;    // GIF8
            using TEIF7 = Field<27, 1>;    // TEIF7
            using HTIF7 = Field<26, 1>;    // HTIF7
            using TCIF7 = Field<25, 1>;    // TCIF7
            using GIF7 = Field<24, 1>;    // GIF7
            using TEIF6 = Field<23, 1>;    // TEIF6
            using HTIF6 = Field<22, 1>;    // HTIF6
            using TCIF6 = Field<21, 1>;    // TCIF6
            using GIF6 = Field<20, 1>;    // GIF6
            using TEIF5 = Field<19, 1>;    // TEIF5
            using HTIF5 = Field<18, 1>;    // HTIF5
            using TCIF5 = Field<17, 1>;    // TCIF5
            using GIF5 = Field<16, 1>;    // GIF5
            using TEIF4 = Field<15, 1>;    // TEIF4
            using HTIF4 = Field<14, 1>;    // HTIF4
            using TCIF4 = Field<13, 1>;    // TCIF4
            using GIF4 = Field<12, 1>;    // GIF4
            using TEIF3 = Field<11, 1>;    // TEIF3
            using HTIF3 = Field<10, 1>;    // HTIF3
            using TCIF3 = Field<9, 1>;    // TCIF3
            using GIF3 = Field<8, 1>;    // GIF3
            using TEIF2 = Field<7, 1>;    // TEIF2
            using HTIF2 = Field<6, 1>;    // HTIF2
            using TCIF2 = Field<5, 1>;    // TCIF2
            using GIF2 = Field<4, 1>;    // GIF2
            using TEIF1 = Field<3, 1>;    // TEIF1
            using HTIF1 = Field<2, 1>;    // HTIF1
            using TCIF1 = Field<1, 1>;    // TCIF1
            using GIF1 = Field<0, 1>;    // GIF1
        };

        // DMA interrupt flag clear register
        struct IFCR : public Register<0x40020004> {
            using TEIF8 = Field<31, 1>;    // TEIF8
            using HTIF8 = Field<30, 1>;    // HTIF8
            using TCIF8 = Field<29, 1>;    // TCIF8
            using GIF8 = Field<28, 1>;    // GIF8
            using TEIF7 = Field<27, 1>;    // TEIF7
            using HTIF7 = Field<26, 1>;    // HTIF7
            using TCIF7 = Field<25, 1>;    // TCIF7
            using GIF7 = Field<24, 1>;    // GIF7
            using TEIF6 = Field<23, 1>;    // TEIF6
            using HTIF6 = Field<22, 1>;    // HTIF6
            using TCIF6 = Field<21, 1>;    // TCIF6
            using GIF6 = Field<20, 1>;    // GIF6
            using TEIF5 = Field<19, 1>;    // TEIF5
            using HTIF5 = Field<18, 1>;    // HTIF5
            using TCIF5 = Field<17, 1>;    // TCIF5
            using GIF5 = Field<16, 1>;    // GIF5
            using TEIF4 = Field<15, 1>;    // TEIF4
            using HTIF4 = Field<14, 1>;    // HTIF4
            using TCIF4 = Field<13, 1>;    // TCIF4
            using GIF4 = Field<12, 1>;    // GIF4
            using TEIF3 = Field<11, 1>;    // TEIF3
            using HTIF3 = Field<10, 1>;    // HTIF3
            using TCIF3 = Field<9, 1>;    // TCIF3
            using GIF3 = Field<8, 1>;    // GIF3
            using TEIF2 = Field<7, 1>;    // TEIF2
            using HTIF2 = Field<6, 1>;    // HTIF2
            using TCIF2 = Field<5, 1>;    // TCIF2
            using GIF2 = Field<4, 1>;    // GIF2
            using TEIF1 = Field<3, 1>;    // TEIF1
            using HTIF1 = Field<2, 1>;    // HTIF1
            using TCIF1 = Field<1, 1>;    // TCIF1
            using GIF1 = Field<0, 1>;    // GIF1
        };

        // DMA channel 1 configuration register
        struct CCR1 : public Register<0x40020008> {
            using EN = Field<0, 1>;    // channel enable
            using TCIE = Field<1, 1>;    // TCIE
            using HTIE = Field<2, 1>;    // HTIE
            using TEIE = Field<3, 1>;    // TEIE
            using DIR = Field<4, 1>;    // DIR
            using CIRC = Field<5, 1>;    // CIRC
            using PINC = Field<6, 1>;    // PINC
            using MINC = Field<7, 1>;    // MINC
            using PSIZE = Field<8, 2>;    // PSIZE
            using MSIZE = Field<10, 2>;    // MSIZE
            using PL = Field<12, 2>;    // PL
            using MEM2MEM = Field<14, 1>;    // MEM2MEM
        };

        // DMA channel 2 configuration register
        struct CCR2 : public Register<0x4002001c> {
            using EN = Field<0, 1>;    // channel enable
            using TCIE = Field<1, 1>;    // TCIE
            using HTIE = Field<2, 1>;    // HTIE
            using TEIE = Field<3, 1>;    // TEIE
            using DIR = Field<4, 1>;    // DIR
            using CIRC = Field<5, 1>;    // CIRC
            using PINC = Field<6, 1>;    // PINC
            using MINC = Field<7, 1>;    // MINC
            using PSIZE = Field<8, 2>;    // PSIZE
            using MSIZE = Field<10, 2>;    // MSIZE
            using PL = Field<12, 2>;    // PL
            using MEM2MEM = Field<14, 1>;    // MEM2MEM
        };

        // DMA channel 3 configuration register
        struct CCR3 : public Register<0x40020030> {
            using EN = Field<0, 1>;    // channel enable
            using TCIE = Field<1, 1>;    // TCIE
            using HTIE = Field<2, 1>;    // HTIE
            using TEIE = Field<3, 1>;    // TEIE
            using DIR = Field<4, 1>;    // DIR
            using CIRC = Field<5, 1>;    // CIRC
            using PINC = Field<6, 1>;    // PINC
            using MINC = Field<7, 1>;    // MINC
            using PSIZE = Field<8, 2>;    // PSIZE
            using MSIZE = Field<10, 2>;    // MSIZE
            using PL = Field<12, 2>;    // PL
            using MEM2MEM = Field<14, 1>;    // MEM2MEM
        };

        // DMA channel 3 configuration register
        struct CCR4 : public Register<0x40020044> {
            using EN = Field<0, 1>;    // channel enable
            using TCIE = Field<1, 1>;    // TCIE
            using HTIE = Field<2, 1>;    // HTIE
            using TEIE = Field<3, 1>;    // TEIE
            using DIR = Field<4, 1>;    // DIR
            using CIRC = Field<5, 1>;    // CIRC
            using PINC = Field<6, 1>;    // PINC
            using MINC = Field<7, 1>;    // MINC
            using PSIZE = Field<8, 2>;    // PSIZE
            using MSIZE = Field<10, 2>;    // MSIZE
            using PL = Field<12, 2>;    // PL
            using MEM2MEM = Field<14, 1>;    // MEM2MEM
        };

        // DMA channel 4 configuration register
        struct CCR5 : public Register<0x40020058> {
            using EN = Field<0, 1>;    // channel enable
            using TCIE = Field<1, 1>;    // TCIE
            using HTIE = Field<2, 1>;    // HTIE
            using TEIE = Field<3, 1>;    // TEIE
            using DIR = Field<4, 1>;    // DIR
            using CIRC = Field<5, 1>;    // CIRC
            using PINC = Field<6, 1>;    // PINC
            using MINC = Field<7, 1>;    // MINC
            using PSIZE = Field<8, 2>;    // PSIZE
            using MSIZE = Field<10, 2>;    // MSIZE
            using PL = Field<12, 2>;    // PL
            using MEM2MEM = Field<14, 1>;    // MEM2MEM
        };

        // DMA channel 5 configuration register
        struct CCR6 : public Register<0x4002006c> {
            using EN = Field<0, 1>;    // channel enable
            using TCIE = Field<1, 1>;    // TCIE
            using HTIE = Field<2, 1>;    // HTIE
            using TEIE = Field<3, 1>;    // TEIE
            using DIR = Field<4, 1>;    // DIR
            using CIRC = Field<5, 1>;    // CIRC
            using PINC = Field<6, 1>;    // PINC
            using MINC = Field<7, 1>;    // MINC
            using PSIZE = Field<8, 2>;    // PSIZE
            using MSIZE = Field<10, 2>;    // MSIZE
            using PL = Field<12, 2>;    // PL
            using MEM2MEM = Field<14, 1>;    // MEM2MEM
        };

        // DMA channel 6 configuration register
        struct CCR7 : public Register<0x40020080> {
            using EN = Field<0, 1>;    // channel enable
            using TCIE = Field<1, 1>;    // TCIE
            using HTIE = Field<2, 1>;    // HTIE
            using TEIE = Field<3, 1>;    // TEIE
            using DIR = Field<4, 1>;    // DIR
            using CIRC = Field<5, 1>;    // CIRC
            using PINC = Field<6, 1>;    // PINC
            using MINC = Field<7, 1>;    // MINC
            using PSIZE = Field<8, 2>;    // PSIZE
            using MSIZE = Field<10, 2>;    // MSIZE
            using PL = Field<12, 2>;    // PL
            using MEM2MEM = Field<14, 1>;    // MEM2MEM
        };

        // DMA channel 7 configuration register
        struct CCR8 : public Register<0x40020094> {
            using EN = Field<0, 1>;    // channel enable
            using TCIE = Field<1, 1>;    // TCIE
            using HTIE = Field<2, 1>;    // HTIE
            using TEIE = Field<3, 1>;    // TEIE
            using DIR = Field<4, 1>;    // DIR
            using CIRC = Field<5, 1>;    // CIRC
            using PINC = Field<6, 1>;    // PINC
            using MINC = Field<7, 1>;    // MINC
            using PSIZE = Field<8, 2>;    // PSIZE
            using MSIZE = Field<10, 2>;    // MSIZE
            using PL = Field<12, 2>;    // PL
            using MEM2MEM = Field<14, 1>;    // MEM2MEM
        };

        // channel x number of data to transfer register
        struct CNDTR1 : public Register<0x4002000c> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // channel x number of data to transfer register
        struct CNDTR2 : public Register<0x40020020> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // channel x number of data to transfer register
        struct CNDTR3 : public Register<0x40020034> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // channel x number of data to transfer register
        struct CNDTR4 : public Register<0x40020048> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // channel x number of data to transfer register
        struct CNDTR5 : public Register<0x4002005c> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // channel x number of data to transfer register
        struct CNDTR6 : public Register<0x40020070> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // channel x number of data to transfer register
        struct CNDTR7 : public Register<0x40020084> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // channel x number of data to transfer register
        struct CNDTR8 : public Register<0x40020098> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // DMA channel x peripheral address register
        struct CPAR1 : public Register<0x40020010> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel x peripheral address register
        struct CPAR2 : public Register<0x40020024> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel x peripheral address register
        struct CPAR3 : public Register<0x40020038> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel x peripheral address register
        struct CPAR4 : public Register<0x4002004c> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel x peripheral address register
        struct CPAR5 : public Register<0x40020060> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel x peripheral address register
        struct CPAR6 : public Register<0x40020074> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel x peripheral address register
        struct CPAR7 : public Register<0x40020088> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel x peripheral address register
        struct CPAR8 : public Register<0x4002009c> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel x memory address register
        struct CMAR1 : public Register<0x40020014> {
            using MA = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // DMA channel x memory address register
        struct CMAR2 : public Register<0x40020028> {
            using MA = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // DMA channel x memory address register
        struct CMAR3 : public Register<0x4002003c> {
            using MA = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // DMA channel x memory address register
        struct CMAR4 : public Register<0x40020050> {
            using MA = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // DMA channel x memory address register
        struct CMAR5 : public Register<0x40020064> {
            using MA = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // DMA channel x memory address register
        struct CMAR6 : public Register<0x40020078> {
            using MA = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // DMA channel x memory address register
        struct CMAR7 : public Register<0x4002008c> {
            using MA = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // DMA channel x memory address register
        struct CMAR8 : public Register<0x400200a0> {
            using MA = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

    };

    // DMA controller
    struct DMA2 {
        // interrupt status register
        struct ISR : public Register<0x40020400> {
            using TEIF8 = Field<31, 1>;    // TEIF8
            using HTIF8 = Field<30, 1>;    // HTIF8
            using TCIF8 = Field<29, 1>;    // TCIF8
            using GIF8 = Field<28, 1>;    // GIF8
            using TEIF7 = Field<27, 1>;    // TEIF7
            using HTIF7 = Field<26, 1>;    // HTIF7
            using TCIF7 = Field<25, 1>;    // TCIF7
            using GIF7 = Field<24, 1>;    // GIF7
            using TEIF6 = Field<23, 1>;    // TEIF6
            using HTIF6 = Field<22, 1>;    // HTIF6
            using TCIF6 = Field<21, 1>;    // TCIF6
            using GIF6 = Field<20, 1>;    // GIF6
            using TEIF5 = Field<19, 1>;    // TEIF5
            using HTIF5 = Field<18, 1>;    // HTIF5
            using TCIF5 = Field<17, 1>;    // TCIF5
            using GIF5 = Field<16, 1>;    // GIF5
            using TEIF4 = Field<15, 1>;    // TEIF4
            using HTIF4 = Field<14, 1>;    // HTIF4
            using TCIF4 = Field<13, 1>;    // TCIF4
            using GIF4 = Field<12, 1>;    // GIF4
            using TEIF3 = Field<11, 1>;    // TEIF3
            using HTIF3 = Field<10, 1>;    // HTIF3
            using TCIF3 = Field<9, 1>;    // TCIF3
            using GIF3 = Field<8, 1>;    // GIF3
            using TEIF2 = Field<7, 1>;    // TEIF2
            using HTIF2 = Field<6, 1>;    // HTIF2
            using TCIF2 = Field<5, 1>;    // TCIF2
            using GIF2 = Field<4, 1>;    // GIF2
            using TEIF1 = Field<3, 1>;    // TEIF1
            using HTIF1 = Field<2, 1>;    // HTIF1
            using TCIF1 = Field<1, 1>;    // TCIF1
            using GIF1 = Field<0, 1>;    // GIF1
        };

        // DMA interrupt flag clear register
        struct IFCR : public Register<0x40020404> {
            using TEIF8 = Field<31, 1>;    // TEIF8
            using HTIF8 = Field<30, 1>;    // HTIF8
            using TCIF8 = Field<29, 1>;    // TCIF8
            using GIF8 = Field<28, 1>;    // GIF8
            using TEIF7 = Field<27, 1>;    // TEIF7
            using HTIF7 = Field<26, 1>;    // HTIF7
            using TCIF7 = Field<25, 1>;    // TCIF7
            using GIF7 = Field<24, 1>;    // GIF7
            using TEIF6 = Field<23, 1>;    // TEIF6
            using HTIF6 = Field<22, 1>;    // HTIF6
            using TCIF6 = Field<21, 1>;    // TCIF6
            using GIF6 = Field<20, 1>;    // GIF6
            using TEIF5 = Field<19, 1>;    // TEIF5
            using HTIF5 = Field<18, 1>;    // HTIF5
            using TCIF5 = Field<17, 1>;    // TCIF5
            using GIF5 = Field<16, 1>;    // GIF5
            using TEIF4 = Field<15, 1>;    // TEIF4
            using HTIF4 = Field<14, 1>;    // HTIF4
            using TCIF4 = Field<13, 1>;    // TCIF4
            using GIF4 = Field<12, 1>;    // GIF4
            using TEIF3 = Field<11, 1>;    // TEIF3
            using HTIF3 = Field<10, 1>;    // HTIF3
            using TCIF3 = Field<9, 1>;    // TCIF3
            using GIF3 = Field<8, 1>;    // GIF3
            using TEIF2 = Field<7, 1>;    // TEIF2
            using HTIF2 = Field<6, 1>;    // HTIF2
            using TCIF2 = Field<5, 1>;    // TCIF2
            using GIF2 = Field<4, 1>;    // GIF2
            using TEIF1 = Field<3, 1>;    // TEIF1
            using HTIF1 = Field<2, 1>;    // HTIF1
            using TCIF1 = Field<1, 1>;    // TCIF1
            using GIF1 = Field<0, 1>;    // GIF1
        };

        // DMA channel 1 configuration register
        struct CCR1 : public Register<0x40020408> {
            using EN = Field<0, 1>;    // channel enable
            using TCIE = Field<1, 1>;    // TCIE
            using HTIE = Field<2, 1>;    // HTIE
            using TEIE = Field<3, 1>;    // TEIE
            using DIR = Field<4, 1>;    // DIR
            using CIRC = Field<5, 1>;    // CIRC
            using PINC = Field<6, 1>;    // PINC
            using MINC = Field<7, 1>;    // MINC
            using PSIZE = Field<8, 2>;    // PSIZE
            using MSIZE = Field<10, 2>;    // MSIZE
            using PL = Field<12, 2>;    // PL
            using MEM2MEM = Field<14, 1>;    // MEM2MEM
        };

        // DMA channel 2 configuration register
        struct CCR2 : public Register<0x4002041c> {
            using EN = Field<0, 1>;    // channel enable
            using TCIE = Field<1, 1>;    // TCIE
            using HTIE = Field<2, 1>;    // HTIE
            using TEIE = Field<3, 1>;    // TEIE
            using DIR = Field<4, 1>;    // DIR
            using CIRC = Field<5, 1>;    // CIRC
            using PINC = Field<6, 1>;    // PINC
            using MINC = Field<7, 1>;    // MINC
            using PSIZE = Field<8, 2>;    // PSIZE
            using MSIZE = Field<10, 2>;    // MSIZE
            using PL = Field<12, 2>;    // PL
            using MEM2MEM = Field<14, 1>;    // MEM2MEM
        };

        // DMA channel 3 configuration register
        struct CCR3 : public Register<0x40020430> {
            using EN = Field<0, 1>;    // channel enable
            using TCIE = Field<1, 1>;    // TCIE
            using HTIE = Field<2, 1>;    // HTIE
            using TEIE = Field<3, 1>;    // TEIE
            using DIR = Field<4, 1>;    // DIR
            using CIRC = Field<5, 1>;    // CIRC
            using PINC = Field<6, 1>;    // PINC
            using MINC = Field<7, 1>;    // MINC
            using PSIZE = Field<8, 2>;    // PSIZE
            using MSIZE = Field<10, 2>;    // MSIZE
            using PL = Field<12, 2>;    // PL
            using MEM2MEM = Field<14, 1>;    // MEM2MEM
        };

        // DMA channel 3 configuration register
        struct CCR4 : public Register<0x40020444> {
            using EN = Field<0, 1>;    // channel enable
            using TCIE = Field<1, 1>;    // TCIE
            using HTIE = Field<2, 1>;    // HTIE
            using TEIE = Field<3, 1>;    // TEIE
            using DIR = Field<4, 1>;    // DIR
            using CIRC = Field<5, 1>;    // CIRC
            using PINC = Field<6, 1>;    // PINC
            using MINC = Field<7, 1>;    // MINC
            using PSIZE = Field<8, 2>;    // PSIZE
            using MSIZE = Field<10, 2>;    // MSIZE
            using PL = Field<12, 2>;    // PL
            using MEM2MEM = Field<14, 1>;    // MEM2MEM
        };

        // DMA channel 4 configuration register
        struct CCR5 : public Register<0x40020458> {
            using EN = Field<0, 1>;    // channel enable
            using TCIE = Field<1, 1>;    // TCIE
            using HTIE = Field<2, 1>;    // HTIE
            using TEIE = Field<3, 1>;    // TEIE
            using DIR = Field<4, 1>;    // DIR
            using CIRC = Field<5, 1>;    // CIRC
            using PINC = Field<6, 1>;    // PINC
            using MINC = Field<7, 1>;    // MINC
            using PSIZE = Field<8, 2>;    // PSIZE
            using MSIZE = Field<10, 2>;    // MSIZE
            using PL = Field<12, 2>;    // PL
            using MEM2MEM = Field<14, 1>;    // MEM2MEM
        };

        // DMA channel 5 configuration register
        struct CCR6 : public Register<0x4002046c> {
            using EN = Field<0, 1>;    // channel enable
            using TCIE = Field<1, 1>;    // TCIE
            using HTIE = Field<2, 1>;    // HTIE
            using TEIE = Field<3, 1>;    // TEIE
            using DIR = Field<4, 1>;    // DIR
            using CIRC = Field<5, 1>;    // CIRC
            using PINC = Field<6, 1>;    // PINC
            using MINC = Field<7, 1>;    // MINC
            using PSIZE = Field<8, 2>;    // PSIZE
            using MSIZE = Field<10, 2>;    // MSIZE
            using PL = Field<12, 2>;    // PL
            using MEM2MEM = Field<14, 1>;    // MEM2MEM
        };

        // DMA channel 6 configuration register
        struct CCR7 : public Register<0x40020480> {
            using EN = Field<0, 1>;    // channel enable
            using TCIE = Field<1, 1>;    // TCIE
            using HTIE = Field<2, 1>;    // HTIE
            using TEIE = Field<3, 1>;    // TEIE
            using DIR = Field<4, 1>;    // DIR
            using CIRC = Field<5, 1>;    // CIRC
            using PINC = Field<6, 1>;    // PINC
            using MINC = Field<7, 1>;    // MINC
            using PSIZE = Field<8, 2>;    // PSIZE
            using MSIZE = Field<10, 2>;    // MSIZE
            using PL = Field<12, 2>;    // PL
            using MEM2MEM = Field<14, 1>;    // MEM2MEM
        };

        // DMA channel 7 configuration register
        struct CCR8 : public Register<0x40020494> {
            using EN = Field<0, 1>;    // channel enable
            using TCIE = Field<1, 1>;    // TCIE
            using HTIE = Field<2, 1>;    // HTIE
            using TEIE = Field<3, 1>;    // TEIE
            using DIR = Field<4, 1>;    // DIR
            using CIRC = Field<5, 1>;    // CIRC
            using PINC = Field<6, 1>;    // PINC
            using MINC = Field<7, 1>;    // MINC
            using PSIZE = Field<8, 2>;    // PSIZE
            using MSIZE = Field<10, 2>;    // MSIZE
            using PL = Field<12, 2>;    // PL
            using MEM2MEM = Field<14, 1>;    // MEM2MEM
        };

        // channel x number of data to transfer register
        struct CNDTR1 : public Register<0x4002040c> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // channel x number of data to transfer register
        struct CNDTR2 : public Register<0x40020420> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // channel x number of data to transfer register
        struct CNDTR3 : public Register<0x40020434> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // channel x number of data to transfer register
        struct CNDTR4 : public Register<0x40020448> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // channel x number of data to transfer register
        struct CNDTR5 : public Register<0x4002045c> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // channel x number of data to transfer register
        struct CNDTR6 : public Register<0x40020470> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // channel x number of data to transfer register
        struct CNDTR7 : public Register<0x40020484> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // channel x number of data to transfer register
        struct CNDTR8 : public Register<0x40020498> {
            using NDT = Field<0, 16>;    // Number of data items to transfer
        };

        // DMA channel x peripheral address register
        struct CPAR1 : public Register<0x40020410> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel x peripheral address register
        struct CPAR2 : public Register<0x40020424> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel x peripheral address register
        struct CPAR3 : public Register<0x40020438> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel x peripheral address register
        struct CPAR4 : public Register<0x4002044c> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel x peripheral address register
        struct CPAR5 : public Register<0x40020460> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel x peripheral address register
        struct CPAR6 : public Register<0x40020474> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel x peripheral address register
        struct CPAR7 : public Register<0x40020488> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel x peripheral address register
        struct CPAR8 : public Register<0x4002049c> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // DMA channel x memory address register
        struct CMAR1 : public Register<0x40020414> {
            using MA = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // DMA channel x memory address register
        struct CMAR2 : public Register<0x40020428> {
            using MA = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // DMA channel x memory address register
        struct CMAR3 : public Register<0x4002043c> {
            using MA = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // DMA channel x memory address register
        struct CMAR4 : public Register<0x40020450> {
            using MA = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // DMA channel x memory address register
        struct CMAR5 : public Register<0x40020464> {
            using MA = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // DMA channel x memory address register
        struct CMAR6 : public Register<0x40020478> {
            using MA = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // DMA channel x memory address register
        struct CMAR7 : public Register<0x4002048c> {
            using MA = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

        // DMA channel x memory address register
        struct CMAR8 : public Register<0x400204a0> {
            using MA = Field<0, 32>;    // Memory 1 address (used in case of Double buffer mode)
        };

    };

    // DMAMUX
    struct DMAMUX {
        // DMAMux - DMA request line multiplexer channel x control register
        struct C0CR : public Register<0x40020800> {
            using DMAREQ_ID = Field<0, 7>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C1CR : public Register<0x40020804> {
            using DMAREQ_ID = Field<0, 7>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C2CR : public Register<0x40020808> {
            using DMAREQ_ID = Field<0, 7>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C3CR : public Register<0x4002080c> {
            using DMAREQ_ID = Field<0, 7>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C4CR : public Register<0x40020810> {
            using DMAREQ_ID = Field<0, 7>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C5CR : public Register<0x40020814> {
            using DMAREQ_ID = Field<0, 7>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C6CR : public Register<0x40020818> {
            using DMAREQ_ID = Field<0, 7>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C7CR : public Register<0x4002081c> {
            using DMAREQ_ID = Field<0, 7>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C8CR : public Register<0x40020820> {
            using DMAREQ_ID = Field<0, 7>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C9CR : public Register<0x40020824> {
            using DMAREQ_ID = Field<0, 7>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C10CR : public Register<0x40020828> {
            using DMAREQ_ID = Field<0, 7>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C11CR : public Register<0x4002082c> {
            using DMAREQ_ID = Field<0, 7>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C12CR : public Register<0x40020830> {
            using DMAREQ_ID = Field<0, 7>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C13CR : public Register<0x40020834> {
            using DMAREQ_ID = Field<0, 7>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C14CR : public Register<0x40020838> {
            using DMAREQ_ID = Field<0, 7>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request line multiplexer channel x control register
        struct C15CR : public Register<0x4002083c> {
            using DMAREQ_ID = Field<0, 7>;    // Input DMA request line selected
            using SOIE = Field<8, 1>;    // Interrupt enable at synchronization event overrun
            using EGE = Field<9, 1>;    // Event generation enable/disable
            using SE = Field<16, 1>;    // Synchronous operating mode enable/disable
            using SPOL = Field<17, 2>;    // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
            using NBREQ = Field<19, 5>;    // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
            using SYNC_ID = Field<24, 5>;    // Synchronization input selected
        };

        // DMAMux - DMA request generator channel x control register
        struct RG0CR : public Register<0x40020900> {
            using SIG_ID = Field<0, 5>;    // DMA request trigger input selected
            using OIE = Field<8, 1>;    // Interrupt enable at trigger event overrun
            using GE = Field<16, 1>;    // DMA request generator channel enable/disable
            using GPOL = Field<17, 2>;    // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
            using GNBREQ = Field<19, 5>;    // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
        };

        // DMAMux - DMA request generator channel x control register
        struct RG1CR : public Register<0x40020904> {
            using SIG_ID = Field<0, 5>;    // DMA request trigger input selected
            using OIE = Field<8, 1>;    // Interrupt enable at trigger event overrun
            using GE = Field<16, 1>;    // DMA request generator channel enable/disable
            using GPOL = Field<17, 2>;    // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
            using GNBREQ = Field<19, 5>;    // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
        };

        // DMAMux - DMA request generator channel x control register
        struct RG2CR : public Register<0x40020908> {
            using SIG_ID = Field<0, 5>;    // DMA request trigger input selected
            using OIE = Field<8, 1>;    // Interrupt enable at trigger event overrun
            using GE = Field<16, 1>;    // DMA request generator channel enable/disable
            using GPOL = Field<17, 2>;    // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
            using GNBREQ = Field<19, 5>;    // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
        };

        // DMAMux - DMA request generator channel x control register
        struct RG3CR : public Register<0x4002090c> {
            using SIG_ID = Field<0, 5>;    // DMA request trigger input selected
            using OIE = Field<8, 1>;    // Interrupt enable at trigger event overrun
            using GE = Field<16, 1>;    // DMA request generator channel enable/disable
            using GPOL = Field<17, 2>;    // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
            using GNBREQ = Field<19, 5>;    // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
        };

        // DMAMux - DMA request generator status register
        struct RGSR : public Register<0x40020940> {
            using OF = Field<0, 4>;    // Trigger event overrun flag The flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding COFx bit in DMAMUX_RGCFR register.
        };

        // DMAMux - DMA request generator clear flag register
        struct RGCFR : public Register<0x40020944> {
            using COF = Field<0, 4>;    // Clear trigger event overrun flag Upon setting, this bit clears the corresponding overrun flag OFx in the DMAMUX_RGCSR register.
        };

        // DMAMUX request line multiplexer interrupt channel status register
        struct CSR : public Register<0x40020880> {
            using SOF = Field<0, 16>;    // Synchronization overrun event flag
        };

        // DMAMUX request line multiplexer interrupt clear flag register
        struct CFR : public Register<0x40020884> {
            using CSOF = Field<0, 16>;    // Clear synchronization overrun event flag
        };

    };

    // System configuration controller
    struct SYSCFG {
        // Remap Memory register
        struct MEMRMP : public Register<0x40010000> {
            using MEM_MODE = Field<0, 3>;    // Memory mapping selection
            using FB_mode = Field<8, 1>;    // User Flash Bank mode
        };

        // peripheral mode configuration register
        struct CFGR1 : public Register<0x40010004> {
            using BOOSTEN = Field<8, 1>;    // BOOSTEN
            using ANASWVDD = Field<9, 1>;    // GPIO analog switch control voltage selection
            using I2C_PB6_FMP = Field<16, 1>;    // FM+ drive capability on PB6
            using I2C_PB7_FMP = Field<17, 1>;    // FM+ drive capability on PB6
            using I2C_PB8_FMP = Field<18, 1>;    // FM+ drive capability on PB6
            using I2C_PB9_FMP = Field<19, 1>;    // FM+ drive capability on PB6
            using I2C1_FMP = Field<20, 1>;    // I2C1 FM+ drive capability enable
            using I2C2_FMP = Field<21, 1>;    // I2C1 FM+ drive capability enable
            using I2C3_FMP = Field<22, 1>;    // I2C1 FM+ drive capability enable
            using I2C4_FMP = Field<23, 1>;    // I2C1 FM+ drive capability enable
            using FPU_IE = Field<26, 6>;    // FPU Interrupts Enable
        };

        // external interrupt configuration register 1
        struct EXTICR1 : public Register<0x40010008> {
            using EXTI3 = Field<12, 4>;    // EXTI x configuration (x = 0 to 3)
            using EXTI2 = Field<8, 4>;    // EXTI x configuration (x = 0 to 3)
            using EXTI1 = Field<4, 4>;    // EXTI x configuration (x = 0 to 3)
            using EXTI0 = Field<0, 4>;    // EXTI x configuration (x = 0 to 3)
        };

        // external interrupt configuration register 2
        struct EXTICR2 : public Register<0x4001000c> {
            using EXTI7 = Field<12, 4>;    // EXTI x configuration (x = 4 to 7)
            using EXTI6 = Field<8, 4>;    // EXTI x configuration (x = 4 to 7)
            using EXTI5 = Field<4, 4>;    // EXTI x configuration (x = 4 to 7)
            using EXTI4 = Field<0, 4>;    // EXTI x configuration (x = 4 to 7)
        };

        // external interrupt configuration register 3
        struct EXTICR3 : public Register<0x40010010> {
            using EXTI11 = Field<12, 4>;    // EXTI x configuration (x = 8 to 11)
            using EXTI10 = Field<8, 4>;    // EXTI10
            using EXTI9 = Field<4, 4>;    // EXTI x configuration (x = 8 to 11)
            using EXTI8 = Field<0, 4>;    // EXTI x configuration (x = 8 to 11)
        };

        // external interrupt configuration register 4
        struct EXTICR4 : public Register<0x40010014> {
            using EXTI15 = Field<12, 4>;    // EXTI x configuration (x = 12 to 15)
            using EXTI14 = Field<8, 4>;    // EXTI x configuration (x = 12 to 15)
            using EXTI13 = Field<4, 4>;    // EXTI x configuration (x = 12 to 15)
            using EXTI12 = Field<0, 4>;    // EXTI x configuration (x = 12 to 15)
        };

        // CCM SRAM control and status register
        struct SCSR : public Register<0x40010018> {
            using CCMER = Field<0, 1>;    // CCM SRAM Erase
            using CCMBSY = Field<1, 1>;    // CCM SRAM busy by erase operation
        };

        // configuration register 2
        struct CFGR2 : public Register<0x4001001c> {
            using CLL = Field<0, 1>;    // Core Lockup Lock
            using SPL = Field<1, 1>;    // SRAM Parity Lock
            using PVDL = Field<2, 1>;    // PVD Lock
            using ECCL = Field<3, 1>;    // ECC Lock
            using SPF = Field<8, 1>;    // SRAM Parity Flag
        };

        // SRAM Write protection register 1
        struct SWPR : public Register<0x40010020> {
            using Page0_WP = Field<0, 1>;    // Write protection
            using Page1_WP = Field<1, 1>;    // Write protection
            using Page2_WP = Field<2, 1>;    // Write protection
            using Page3_WP = Field<3, 1>;    // Write protection
            using Page4_WP = Field<4, 1>;    // Write protection
            using Page5_WP = Field<5, 1>;    // Write protection
            using Page6_WP = Field<6, 1>;    // Write protection
            using Page7_WP = Field<7, 1>;    // Write protection
            using Page8_WP = Field<8, 1>;    // Write protection
            using Page9_WP = Field<9, 1>;    // Write protection
            using Page10_WP = Field<10, 1>;    // Write protection
            using Page11_WP = Field<11, 1>;    // Write protection
            using Page12_WP = Field<12, 1>;    // Write protection
            using Page13_WP = Field<13, 1>;    // Write protection
            using Page14_WP = Field<14, 1>;    // Write protection
            using Page15_WP = Field<15, 1>;    // Write protection
            using Page16_WP = Field<16, 1>;    // Write protection
            using Page17_WP = Field<17, 1>;    // Write protection
            using Page18_WP = Field<18, 1>;    // Write protection
            using Page19_WP = Field<19, 1>;    // Write protection
            using Page20_WP = Field<20, 1>;    // Write protection
            using Page21_WP = Field<21, 1>;    // Write protection
            using Page22_WP = Field<22, 1>;    // Write protection
            using Page23_WP = Field<23, 1>;    // Write protection
            using Page24_WP = Field<24, 1>;    // Write protection
            using Page25_WP = Field<25, 1>;    // Write protection
            using Page26_WP = Field<26, 1>;    // Write protection
            using Page27_WP = Field<27, 1>;    // Write protection
            using Page28_WP = Field<28, 1>;    // Write protection
            using Page29_WP = Field<29, 1>;    // Write protection
            using Page30_WP = Field<30, 1>;    // Write protection
            using Page31_WP = Field<31, 1>;    // Write protection
        };

        // SRAM2 Key Register
        struct SKR : public Register<0x40010024> {
            using KEY = Field<0, 8>;    // SRAM2 Key for software erase
        };

    };

    // Comparator control and status register
    struct COMP {
        // Comparator control/status register
        struct COMP_C1CSR : public Register<0x40010200> {
            using EN = Field<0, 1>;    // EN
            using COMP_DEGLITCH_EN = Field<1, 1>;    // COMP_DEGLITCH_EN
            using INMSEL = Field<4, 3>;    // INMSEL
            using INPSEL = Field<8, 1>;    // INPSEL
            using POL = Field<15, 1>;    // POL
            using HYST = Field<16, 3>;    // HYST
            using BLANKSEL = Field<19, 3>;    // BLANKSEL
            using BRGEN = Field<22, 1>;    // BRGEN
            using SCALEN = Field<23, 1>;    // SCALEN
            using VALUE = Field<30, 1>;    // VALUE
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Comparator control/status register
        struct COMP_C2CSR : public Register<0x40010204> {
            using EN = Field<0, 1>;    // EN
            using COMP_DEGLITCH_EN = Field<1, 1>;    // COMP_DEGLITCH_EN
            using INMSEL = Field<4, 3>;    // INMSEL
            using INPSEL = Field<8, 1>;    // INPSEL
            using POL = Field<15, 1>;    // POL
            using HYST = Field<16, 3>;    // HYST
            using BLANKSEL = Field<19, 3>;    // BLANKSEL
            using BRGEN = Field<22, 1>;    // BRGEN
            using SCALEN = Field<23, 1>;    // SCALEN
            using VALUE = Field<30, 1>;    // VALUE
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Comparator control/status register
        struct COMP_C3CSR : public Register<0x40010208> {
            using EN = Field<0, 1>;    // EN
            using COMP_DEGLITCH_EN = Field<1, 1>;    // COMP_DEGLITCH_EN
            using INMSEL = Field<4, 3>;    // INMSEL
            using INPSEL = Field<8, 1>;    // INPSEL
            using POL = Field<15, 1>;    // POL
            using HYST = Field<16, 3>;    // HYST
            using BLANKSEL = Field<19, 3>;    // BLANKSEL
            using BRGEN = Field<22, 1>;    // BRGEN
            using SCALEN = Field<23, 1>;    // SCALEN
            using VALUE = Field<30, 1>;    // VALUE
            using LOCK = Field<31, 1>;    // LOCK
        };

        // Comparator control/status register
        struct COMP_C4CSR : public Register<0x40010212> {
            using EN = Field<0, 1>;    // EN
            using COMP_DEGLITCH_EN = Field<1, 1>;    // COMP_DEGLITCH_EN
            using INMSEL = Field<4, 3>;    // INMSEL
            using INPSEL = Field<8, 1>;    // INPSEL
            using POL = Field<15, 1>;    // POL
            using HYST = Field<16, 3>;    // HYST
            using BLANKSEL = Field<19, 3>;    // BLANKSEL
            using BRGEN = Field<22, 1>;    // BRGEN
            using SCALEN = Field<23, 1>;    // SCALEN
            using VALUE = Field<30, 1>;    // VALUE
            using LOCK = Field<31, 1>;    // LOCK
        };

    };

    // Operational amplifiers
    struct OPAMP {
        // OPAMP1 control/status register
        struct OPAMP1_CSR : public Register<0x40010300> {
            using OPAEN = Field<0, 1>;    // Operational amplifier Enable
            using FORCE_VP = Field<1, 1>;    // FORCE_VP
            using VP_SEL = Field<2, 2>;    // VP_SEL
            using USERTRIM = Field<4, 1>;    // USERTRIM
            using VM_SEL = Field<5, 2>;    // VM_SEL
            using OPAHSM = Field<7, 1>;    // OPAHSM
            using OPAINTOEN = Field<8, 1>;    // OPAINTOEN
            using CALON = Field<11, 1>;    // CALON
            using CALSEL = Field<12, 2>;    // CALSEL
            using PGA_GAIN = Field<14, 5>;    // PGA_GAIN
            using TRIMOFFSETP = Field<19, 5>;    // TRIMOFFSETP
            using TRIMOFFSETN = Field<24, 5>;    // TRIMOFFSETN
            using CALOUT = Field<30, 1>;    // CALOUT
            using LOCK = Field<31, 1>;    // LOCK
        };

        // OPAMP2 control/status register
        struct OPAMP2_CSR : public Register<0x40010304> {
            using OPAEN = Field<0, 1>;    // Operational amplifier Enable
            using FORCE_VP = Field<1, 1>;    // FORCE_VP
            using VP_SEL = Field<2, 2>;    // VP_SEL
            using USERTRIM = Field<4, 1>;    // USERTRIM
            using VM_SEL = Field<5, 2>;    // VM_SEL
            using OPAHSM = Field<7, 1>;    // OPAHSM
            using OPAINTOEN = Field<8, 1>;    // OPAINTOEN
            using CALON = Field<11, 1>;    // CALON
            using CALSEL = Field<12, 2>;    // CALSEL
            using PGA_GAIN = Field<14, 5>;    // PGA_GAIN
            using TRIMOFFSETP = Field<19, 5>;    // TRIMOFFSETP
            using TRIMOFFSETN = Field<24, 5>;    // TRIMOFFSETN
            using CALOUT = Field<30, 1>;    // CALOUT
            using LOCK = Field<31, 1>;    // LOCK
        };

        // OPAMP3 control/status register
        struct OPAMP3_CSR : public Register<0x40010308> {
            using OPAEN = Field<0, 1>;    // Operational amplifier Enable
            using FORCE_VP = Field<1, 1>;    // FORCE_VP
            using VP_SEL = Field<2, 2>;    // VP_SEL
            using USERTRIM = Field<4, 1>;    // USERTRIM
            using VM_SEL = Field<5, 2>;    // VM_SEL
            using OPAHSM = Field<7, 1>;    // OPAHSM
            using OPAINTOEN = Field<8, 1>;    // OPAINTOEN
            using CALON = Field<11, 1>;    // CALON
            using CALSEL = Field<12, 2>;    // CALSEL
            using PGA_GAIN = Field<14, 5>;    // PGA_GAIN
            using TRIMOFFSETP = Field<19, 5>;    // TRIMOFFSETP
            using TRIMOFFSETN = Field<24, 5>;    // TRIMOFFSETN
            using CALOUT = Field<30, 1>;    // CALOUT
            using LOCK = Field<31, 1>;    // LOCK
        };

        // OPAMP1 control/status register
        struct OPAMP1_TCMR : public Register<0x40010318> {
            using VMS_SEL = Field<0, 1>;    // VMS_SEL
            using VPS_SEL = Field<1, 2>;    // VPS_SEL
            using T1CM_EN = Field<3, 1>;    // T1CM_EN
            using T8CM_EN = Field<4, 1>;    // T8CM_EN
            using T20CM_EN = Field<5, 1>;    // T20CM_EN
            using LOCK = Field<31, 1>;    // LOCK
        };

        // OPAMP2 control/status register
        struct OPAMP2_TCMR : public Register<0x4001031c> {
            using VMS_SEL = Field<0, 1>;    // VMS_SEL
            using VPS_SEL = Field<1, 2>;    // VPS_SEL
            using T1CM_EN = Field<3, 1>;    // T1CM_EN
            using T8CM_EN = Field<4, 1>;    // T8CM_EN
            using T20CM_EN = Field<5, 1>;    // T20CM_EN
            using LOCK = Field<31, 1>;    // LOCK
        };

        // OPAMP3 control/status register
        struct OPAMP3_TCMR : public Register<0x40010320> {
            using VMS_SEL = Field<0, 1>;    // VMS_SEL
            using VPS_SEL = Field<1, 2>;    // VPS_SEL
            using T1CM_EN = Field<3, 1>;    // T1CM_EN
            using T8CM_EN = Field<4, 1>;    // T8CM_EN
            using T20CM_EN = Field<5, 1>;    // T20CM_EN
            using LOCK = Field<31, 1>;    // LOCK
        };

    };

    // Digital-to-analog converter
    struct DAC1 {
        // DAC control register
        struct DAC_CR : public Register<0x50000800> {
            using EN1 = Field<0, 1>;    // DAC channel1 enable This bit is set and cleared by software to enable/disable DAC channel1.
            using TEN1 = Field<1, 1>;    // DAC channel1 trigger enable
            using TSEL1 = Field<2, 4>;    // DAC channel1 trigger selection These bits select the external event used to trigger DAC channel1. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
            using WAVE1 = Field<6, 2>;    // DAC channel1 noise/triangle wave generation enable These bits are set and cleared by software. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
            using MAMP1 = Field<8, 4>;    // DAC channel1 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
            using DMAEN1 = Field<12, 1>;    // DAC channel1 DMA enable This bit is set and cleared by software.
            using DMAUDRIE1 = Field<13, 1>;    // DAC channel1 DMA Underrun Interrupt enable This bit is set and cleared by software.
            using CEN1 = Field<14, 1>;    // DAC Channel 1 calibration enable This bit is set and cleared by software to enable/disable DAC channel 1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
            using EN2 = Field<16, 1>;    // DAC channel2 enable This bit is set and cleared by software to enable/disable DAC channel2.
            using TEN2 = Field<17, 1>;    // DAC channel2 trigger enable
            using TSEL2 = Field<18, 4>;    // DAC channel2 trigger selection These bits select the external event used to trigger DAC channel2 Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled).
            using WAVE2 = Field<22, 2>;    // DAC channel2 noise/triangle wave generation enable These bits are set/reset by software. 1x: Triangle wave generation enabled Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled)
            using MAMP2 = Field<24, 4>;    // DAC channel2 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
            using DMAEN2 = Field<28, 1>;    // DAC channel2 DMA enable This bit is set and cleared by software.
            using DMAUDRIE2 = Field<29, 1>;    // DAC channel2 DMA underrun interrupt enable This bit is set and cleared by software.
            using CEN2 = Field<30, 1>;    // DAC Channel 2 calibration enable This bit is set and cleared by software to enable/disable DAC channel 2 calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
        };

        // DAC software trigger register
        struct DAC_SWTRGR : public Register<0x50000804> {
            using SWTRIG1 = Field<0, 1>;    // DAC channel1 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register.
            using SWTRIG2 = Field<1, 1>;    // DAC channel2 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register.
            using SWTRIGB1 = Field<16, 1>;    // DAC channel1 software trigger B
            using SWTRIGB2 = Field<17, 1>;    // DAC channel2 software trigger B
        };

        // DAC channel1 12-bit right-aligned data holding register
        struct DAC_DHR12R1 : public Register<0x50000808> {
            using DACC1DHR = Field<0, 12>;    // DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
            using DACC1DHRB = Field<16, 12>;    // DAC channel1 12-bit right-aligned data B
        };

        // DAC channel1 12-bit left aligned data holding register
        struct DAC_DHR12L1 : public Register<0x5000080c> {
            using DACC1DHR = Field<4, 12>;    // DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
            using DACC1DHRB = Field<20, 12>;    // DAC channel1 12-bit left-aligned data B
        };

        // DAC channel1 8-bit right aligned data holding register
        struct DAC_DHR8R1 : public Register<0x50000810> {
            using DACC1DHR = Field<0, 8>;    // DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
            using DACC1DHRB = Field<8, 8>;    // DAC channel1 8-bit right-aligned data
        };

        // DAC channel2 12-bit right aligned data holding register
        struct DAC_DHR12R2 : public Register<0x50000814> {
            using DACC2DHR = Field<0, 12>;    // DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
            using DACC2DHRB = Field<16, 12>;    // DAC channel2 12-bit right-aligned data
        };

        // DAC channel2 12-bit left aligned data holding register
        struct DAC_DHR12L2 : public Register<0x50000818> {
            using DACC2DHR = Field<4, 12>;    // DAC channel2 12-bit left-aligned data These bits are written by software which specify 12-bit data for DAC channel2.
            using DACC2DHRB = Field<20, 12>;    // DAC channel2 12-bit left-aligned data B
        };

        // DAC channel2 8-bit right-aligned data holding register
        struct DAC_DHR8R2 : public Register<0x5000081c> {
            using DACC2DHR = Field<0, 8>;    // DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
            using DACC2DHRB = Field<8, 8>;    // DAC channel2 8-bit right-aligned data
        };

        // Dual DAC 12-bit right-aligned data holding register
        struct DAC_DHR12RD : public Register<0x50000820> {
            using DACC1DHR = Field<0, 12>;    // DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
            using DACC2DHR = Field<16, 12>;    // DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
        };

        // DUAL DAC 12-bit left aligned data holding register
        struct DAC_DHR12LD : public Register<0x50000824> {
            using DACC1DHR = Field<4, 12>;    // DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
            using DACC2DHR = Field<20, 12>;    // DAC channel2 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
        };

        // DUAL DAC 8-bit right aligned data holding register
        struct DAC_DHR8RD : public Register<0x50000828> {
            using DACC1DHR = Field<0, 8>;    // DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
            using DACC2DHR = Field<8, 8>;    // DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
        };

        // DAC channel1 data output register
        struct DAC_DOR1 : public Register<0x5000082c> {
            using DACC1DOR = Field<0, 12>;    // DAC channel1 data output These bits are read-only, they contain data output for DAC channel1.
            using DACC1DORB = Field<16, 12>;    // DAC channel1 data output
        };

        // DAC channel2 data output register
        struct DAC_DOR2 : public Register<0x50000830> {
            using DACC2DOR = Field<0, 12>;    // DAC channel2 data output These bits are read-only, they contain data output for DAC channel2.
            using DACC2DORB = Field<16, 12>;    // DAC channel2 data output
        };

        // DAC status register
        struct DAC_SR : public Register<0x50000834> {
            using DAC1RDY = Field<11, 1>;    // DAC channel1 ready status bit
            using DORSTAT1 = Field<12, 1>;    // DAC channel1 output register status bit
            using DMAUDR1 = Field<13, 1>;    // DAC channel1 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
            using CAL_FLAG1 = Field<14, 1>;    // DAC Channel 1 calibration offset status This bit is set and cleared by hardware
            using BWST1 = Field<15, 1>;    // DAC Channel 1 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization).
            using DAC2RDY = Field<27, 1>;    // DAC channel 2 ready status bit
            using DORSTAT2 = Field<28, 1>;    // DAC channel 2 output register status bit
            using DMAUDR2 = Field<29, 1>;    // DAC channel2 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
            using CAL_FLAG2 = Field<30, 1>;    // DAC Channel 2 calibration offset status This bit is set and cleared by hardware
            using BWST2 = Field<31, 1>;    // DAC Channel 2 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR2, It is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization).
        };

        // DAC calibration control register
        struct DAC_CCR : public Register<0x50000838> {
            using OTRIM1 = Field<0, 5>;    // DAC Channel 1 offset trimming value
            using OTRIM2 = Field<16, 5>;    // DAC Channel 2 offset trimming value
        };

        // DAC mode control register
        struct DAC_MCR : public Register<0x5000083c> {
            using MODE1 = Field<0, 3>;    // DAC Channel 1 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 1 mode: DAC Channel 1 in normal Mode DAC Channel 1 in sample &amp; hold mode
            using DMADOUBLE1 = Field<8, 1>;    // DAC Channel1 DMA double data mode
            using SINFORMAT1 = Field<9, 1>;    // Enable signed format for DAC channel1
            using HFSEL = Field<14, 2>;    // High frequency interface mode selection
            using MODE2 = Field<16, 3>;    // DAC Channel 2 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 2 mode: DAC Channel 2 in normal Mode DAC Channel 2 in sample &amp; hold mode
            using DMADOUBLE2 = Field<24, 1>;    // DAC Channel2 DMA double data mode
            using SINFORMAT2 = Field<25, 1>;    // Enable signed format for DAC channel2
        };

        // DAC Sample and Hold sample time register 1
        struct DAC_SHSR1 : public Register<0x50000840> {
            using TSAMPLE1 = Field<0, 10>;    // DAC Channel 1 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, If BWSTx=1, the write operation is ignored.
        };

        // DAC Sample and Hold sample time register 2
        struct DAC_SHSR2 : public Register<0x50000844> {
            using TSAMPLE2 = Field<0, 10>;    // DAC Channel 2 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel2 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, if BWSTx=1, the write operation is ignored.
        };

        // DAC Sample and Hold hold time register
        struct DAC_SHHR : public Register<0x50000848> {
            using THOLD1 = Field<0, 10>;    // DAC Channel 1 hold Time (only valid in sample &amp; hold mode) Hold time= (THOLD[9:0]) x T LSI
            using THOLD2 = Field<16, 10>;    // DAC Channel 2 hold time (only valid in sample &amp; hold mode). Hold time= (THOLD[9:0]) x T LSI
        };

        // DAC Sample and Hold refresh time register
        struct DAC_SHRR : public Register<0x5000084c> {
            using TREFRESH1 = Field<0, 8>;    // DAC Channel 1 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
            using TREFRESH2 = Field<16, 8>;    // DAC Channel 2 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
        };

        // Sawtooth register
        struct DAC_STR1 : public Register<0x50000858> {
            using STRSTDATA1 = Field<0, 12>;    // DAC Channel 1 Sawtooth reset value
            using STDIR1 = Field<12, 1>;    // DAC Channel1 Sawtooth direction setting
            using STINCDATA1 = Field<16, 16>;    // DAC CH1 Sawtooth increment value (12.4 bit format)
        };

        // Sawtooth register
        struct DAC_STR2 : public Register<0x5000085c> {
            using STRSTDATA2 = Field<0, 12>;    // DAC Channel 2 Sawtooth reset value
            using STDIR2 = Field<12, 1>;    // DAC Channel2 Sawtooth direction setting
            using STINCDATA2 = Field<16, 16>;    // DAC CH2 Sawtooth increment value (12.4 bit format)
        };

        // Sawtooth Mode register
        struct DAC_STMODR : public Register<0x50000860> {
            using STRSTTRIGSEL1 = Field<0, 4>;    // DAC Channel 1 Sawtooth Reset trigger selection
            using STINCTRIGSEL1 = Field<8, 4>;    // DAC Channel 1 Sawtooth Increment trigger selection
            using STRSTTRIGSEL2 = Field<16, 4>;    // DAC Channel 1 Sawtooth Reset trigger selection
            using STINCTRIGSEL2 = Field<24, 4>;    // DAC Channel 2 Sawtooth Increment trigger selection
        };

    };

    // Digital-to-analog converter
    struct DAC2 {
        // DAC control register
        struct DAC_CR : public Register<0x50000c00> {
            using EN1 = Field<0, 1>;    // DAC channel1 enable This bit is set and cleared by software to enable/disable DAC channel1.
            using TEN1 = Field<1, 1>;    // DAC channel1 trigger enable
            using TSEL1 = Field<2, 4>;    // DAC channel1 trigger selection These bits select the external event used to trigger DAC channel1. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
            using WAVE1 = Field<6, 2>;    // DAC channel1 noise/triangle wave generation enable These bits are set and cleared by software. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
            using MAMP1 = Field<8, 4>;    // DAC channel1 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
            using DMAEN1 = Field<12, 1>;    // DAC channel1 DMA enable This bit is set and cleared by software.
            using DMAUDRIE1 = Field<13, 1>;    // DAC channel1 DMA Underrun Interrupt enable This bit is set and cleared by software.
            using CEN1 = Field<14, 1>;    // DAC Channel 1 calibration enable This bit is set and cleared by software to enable/disable DAC channel 1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
            using EN2 = Field<16, 1>;    // DAC channel2 enable This bit is set and cleared by software to enable/disable DAC channel2.
            using TEN2 = Field<17, 1>;    // DAC channel2 trigger enable
            using TSEL2 = Field<18, 4>;    // DAC channel2 trigger selection These bits select the external event used to trigger DAC channel2 Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled).
            using WAVE2 = Field<22, 2>;    // DAC channel2 noise/triangle wave generation enable These bits are set/reset by software. 1x: Triangle wave generation enabled Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled)
            using MAMP2 = Field<24, 4>;    // DAC channel2 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
            using DMAEN2 = Field<28, 1>;    // DAC channel2 DMA enable This bit is set and cleared by software.
            using DMAUDRIE2 = Field<29, 1>;    // DAC channel2 DMA underrun interrupt enable This bit is set and cleared by software.
            using CEN2 = Field<30, 1>;    // DAC Channel 2 calibration enable This bit is set and cleared by software to enable/disable DAC channel 2 calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
        };

        // DAC software trigger register
        struct DAC_SWTRGR : public Register<0x50000c04> {
            using SWTRIG1 = Field<0, 1>;    // DAC channel1 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register.
            using SWTRIG2 = Field<1, 1>;    // DAC channel2 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register.
            using SWTRIGB1 = Field<16, 1>;    // DAC channel1 software trigger B
            using SWTRIGB2 = Field<17, 1>;    // DAC channel2 software trigger B
        };

        // DAC channel1 12-bit right-aligned data holding register
        struct DAC_DHR12R1 : public Register<0x50000c08> {
            using DACC1DHR = Field<0, 12>;    // DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
            using DACC1DHRB = Field<16, 12>;    // DAC channel1 12-bit right-aligned data B
        };

        // DAC channel1 12-bit left aligned data holding register
        struct DAC_DHR12L1 : public Register<0x50000c0c> {
            using DACC1DHR = Field<4, 12>;    // DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
            using DACC1DHRB = Field<20, 12>;    // DAC channel1 12-bit left-aligned data B
        };

        // DAC channel1 8-bit right aligned data holding register
        struct DAC_DHR8R1 : public Register<0x50000c10> {
            using DACC1DHR = Field<0, 8>;    // DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
            using DACC1DHRB = Field<8, 8>;    // DAC channel1 8-bit right-aligned data
        };

        // DAC channel2 12-bit right aligned data holding register
        struct DAC_DHR12R2 : public Register<0x50000c14> {
            using DACC2DHR = Field<0, 12>;    // DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
            using DACC2DHRB = Field<16, 12>;    // DAC channel2 12-bit right-aligned data
        };

        // DAC channel2 12-bit left aligned data holding register
        struct DAC_DHR12L2 : public Register<0x50000c18> {
            using DACC2DHR = Field<4, 12>;    // DAC channel2 12-bit left-aligned data These bits are written by software which specify 12-bit data for DAC channel2.
            using DACC2DHRB = Field<20, 12>;    // DAC channel2 12-bit left-aligned data B
        };

        // DAC channel2 8-bit right-aligned data holding register
        struct DAC_DHR8R2 : public Register<0x50000c1c> {
            using DACC2DHR = Field<0, 8>;    // DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
            using DACC2DHRB = Field<8, 8>;    // DAC channel2 8-bit right-aligned data
        };

        // Dual DAC 12-bit right-aligned data holding register
        struct DAC_DHR12RD : public Register<0x50000c20> {
            using DACC1DHR = Field<0, 12>;    // DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
            using DACC2DHR = Field<16, 12>;    // DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
        };

        // DUAL DAC 12-bit left aligned data holding register
        struct DAC_DHR12LD : public Register<0x50000c24> {
            using DACC1DHR = Field<4, 12>;    // DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
            using DACC2DHR = Field<20, 12>;    // DAC channel2 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
        };

        // DUAL DAC 8-bit right aligned data holding register
        struct DAC_DHR8RD : public Register<0x50000c28> {
            using DACC1DHR = Field<0, 8>;    // DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
            using DACC2DHR = Field<8, 8>;    // DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
        };

        // DAC channel1 data output register
        struct DAC_DOR1 : public Register<0x50000c2c> {
            using DACC1DOR = Field<0, 12>;    // DAC channel1 data output These bits are read-only, they contain data output for DAC channel1.
            using DACC1DORB = Field<16, 12>;    // DAC channel1 data output
        };

        // DAC channel2 data output register
        struct DAC_DOR2 : public Register<0x50000c30> {
            using DACC2DOR = Field<0, 12>;    // DAC channel2 data output These bits are read-only, they contain data output for DAC channel2.
            using DACC2DORB = Field<16, 12>;    // DAC channel2 data output
        };

        // DAC status register
        struct DAC_SR : public Register<0x50000c34> {
            using DAC1RDY = Field<11, 1>;    // DAC channel1 ready status bit
            using DORSTAT1 = Field<12, 1>;    // DAC channel1 output register status bit
            using DMAUDR1 = Field<13, 1>;    // DAC channel1 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
            using CAL_FLAG1 = Field<14, 1>;    // DAC Channel 1 calibration offset status This bit is set and cleared by hardware
            using BWST1 = Field<15, 1>;    // DAC Channel 1 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization).
            using DAC2RDY = Field<27, 1>;    // DAC channel 2 ready status bit
            using DORSTAT2 = Field<28, 1>;    // DAC channel 2 output register status bit
            using DMAUDR2 = Field<29, 1>;    // DAC channel2 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
            using CAL_FLAG2 = Field<30, 1>;    // DAC Channel 2 calibration offset status This bit is set and cleared by hardware
            using BWST2 = Field<31, 1>;    // DAC Channel 2 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR2, It is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization).
        };

        // DAC calibration control register
        struct DAC_CCR : public Register<0x50000c38> {
            using OTRIM1 = Field<0, 5>;    // DAC Channel 1 offset trimming value
            using OTRIM2 = Field<16, 5>;    // DAC Channel 2 offset trimming value
        };

        // DAC mode control register
        struct DAC_MCR : public Register<0x50000c3c> {
            using MODE1 = Field<0, 3>;    // DAC Channel 1 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 1 mode: DAC Channel 1 in normal Mode DAC Channel 1 in sample &amp; hold mode
            using DMADOUBLE1 = Field<8, 1>;    // DAC Channel1 DMA double data mode
            using SINFORMAT1 = Field<9, 1>;    // Enable signed format for DAC channel1
            using HFSEL = Field<14, 2>;    // High frequency interface mode selection
            using MODE2 = Field<16, 3>;    // DAC Channel 2 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 2 mode: DAC Channel 2 in normal Mode DAC Channel 2 in sample &amp; hold mode
            using DMADOUBLE2 = Field<24, 1>;    // DAC Channel2 DMA double data mode
            using SINFORMAT2 = Field<25, 1>;    // Enable signed format for DAC channel2
        };

        // DAC Sample and Hold sample time register 1
        struct DAC_SHSR1 : public Register<0x50000c40> {
            using TSAMPLE1 = Field<0, 10>;    // DAC Channel 1 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, If BWSTx=1, the write operation is ignored.
        };

        // DAC Sample and Hold sample time register 2
        struct DAC_SHSR2 : public Register<0x50000c44> {
            using TSAMPLE2 = Field<0, 10>;    // DAC Channel 2 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel2 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, if BWSTx=1, the write operation is ignored.
        };

        // DAC Sample and Hold hold time register
        struct DAC_SHHR : public Register<0x50000c48> {
            using THOLD1 = Field<0, 10>;    // DAC Channel 1 hold Time (only valid in sample &amp; hold mode) Hold time= (THOLD[9:0]) x T LSI
            using THOLD2 = Field<16, 10>;    // DAC Channel 2 hold time (only valid in sample &amp; hold mode). Hold time= (THOLD[9:0]) x T LSI
        };

        // DAC Sample and Hold refresh time register
        struct DAC_SHRR : public Register<0x50000c4c> {
            using TREFRESH1 = Field<0, 8>;    // DAC Channel 1 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
            using TREFRESH2 = Field<16, 8>;    // DAC Channel 2 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
        };

        // Sawtooth register
        struct DAC_STR1 : public Register<0x50000c58> {
            using STRSTDATA1 = Field<0, 12>;    // DAC Channel 1 Sawtooth reset value
            using STDIR1 = Field<12, 1>;    // DAC Channel1 Sawtooth direction setting
            using STINCDATA1 = Field<16, 16>;    // DAC CH1 Sawtooth increment value (12.4 bit format)
        };

        // Sawtooth register
        struct DAC_STR2 : public Register<0x50000c5c> {
            using STRSTDATA2 = Field<0, 12>;    // DAC Channel 2 Sawtooth reset value
            using STDIR2 = Field<12, 1>;    // DAC Channel2 Sawtooth direction setting
            using STINCDATA2 = Field<16, 16>;    // DAC CH2 Sawtooth increment value (12.4 bit format)
        };

        // Sawtooth Mode register
        struct DAC_STMODR : public Register<0x50000c60> {
            using STRSTTRIGSEL1 = Field<0, 4>;    // DAC Channel 1 Sawtooth Reset trigger selection
            using STINCTRIGSEL1 = Field<8, 4>;    // DAC Channel 1 Sawtooth Increment trigger selection
            using STRSTTRIGSEL2 = Field<16, 4>;    // DAC Channel 1 Sawtooth Reset trigger selection
            using STINCTRIGSEL2 = Field<24, 4>;    // DAC Channel 2 Sawtooth Increment trigger selection
        };

    };

    // Digital-to-analog converter
    struct DAC3 {
        // DAC control register
        struct DAC_CR : public Register<0x50001000> {
            using EN1 = Field<0, 1>;    // DAC channel1 enable This bit is set and cleared by software to enable/disable DAC channel1.
            using TEN1 = Field<1, 1>;    // DAC channel1 trigger enable
            using TSEL1 = Field<2, 4>;    // DAC channel1 trigger selection These bits select the external event used to trigger DAC channel1. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
            using WAVE1 = Field<6, 2>;    // DAC channel1 noise/triangle wave generation enable These bits are set and cleared by software. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
            using MAMP1 = Field<8, 4>;    // DAC channel1 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
            using DMAEN1 = Field<12, 1>;    // DAC channel1 DMA enable This bit is set and cleared by software.
            using DMAUDRIE1 = Field<13, 1>;    // DAC channel1 DMA Underrun Interrupt enable This bit is set and cleared by software.
            using CEN1 = Field<14, 1>;    // DAC Channel 1 calibration enable This bit is set and cleared by software to enable/disable DAC channel 1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
            using EN2 = Field<16, 1>;    // DAC channel2 enable This bit is set and cleared by software to enable/disable DAC channel2.
            using TEN2 = Field<17, 1>;    // DAC channel2 trigger enable
            using TSEL2 = Field<18, 4>;    // DAC channel2 trigger selection These bits select the external event used to trigger DAC channel2 Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled).
            using WAVE2 = Field<22, 2>;    // DAC channel2 noise/triangle wave generation enable These bits are set/reset by software. 1x: Triangle wave generation enabled Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled)
            using MAMP2 = Field<24, 4>;    // DAC channel2 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
            using DMAEN2 = Field<28, 1>;    // DAC channel2 DMA enable This bit is set and cleared by software.
            using DMAUDRIE2 = Field<29, 1>;    // DAC channel2 DMA underrun interrupt enable This bit is set and cleared by software.
            using CEN2 = Field<30, 1>;    // DAC Channel 2 calibration enable This bit is set and cleared by software to enable/disable DAC channel 2 calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
        };

        // DAC software trigger register
        struct DAC_SWTRGR : public Register<0x50001004> {
            using SWTRIG1 = Field<0, 1>;    // DAC channel1 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register.
            using SWTRIG2 = Field<1, 1>;    // DAC channel2 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register.
            using SWTRIGB1 = Field<16, 1>;    // DAC channel1 software trigger B
            using SWTRIGB2 = Field<17, 1>;    // DAC channel2 software trigger B
        };

        // DAC channel1 12-bit right-aligned data holding register
        struct DAC_DHR12R1 : public Register<0x50001008> {
            using DACC1DHR = Field<0, 12>;    // DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
            using DACC1DHRB = Field<16, 12>;    // DAC channel1 12-bit right-aligned data B
        };

        // DAC channel1 12-bit left aligned data holding register
        struct DAC_DHR12L1 : public Register<0x5000100c> {
            using DACC1DHR = Field<4, 12>;    // DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
            using DACC1DHRB = Field<20, 12>;    // DAC channel1 12-bit left-aligned data B
        };

        // DAC channel1 8-bit right aligned data holding register
        struct DAC_DHR8R1 : public Register<0x50001010> {
            using DACC1DHR = Field<0, 8>;    // DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
            using DACC1DHRB = Field<8, 8>;    // DAC channel1 8-bit right-aligned data
        };

        // DAC channel2 12-bit right aligned data holding register
        struct DAC_DHR12R2 : public Register<0x50001014> {
            using DACC2DHR = Field<0, 12>;    // DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
            using DACC2DHRB = Field<16, 12>;    // DAC channel2 12-bit right-aligned data
        };

        // DAC channel2 12-bit left aligned data holding register
        struct DAC_DHR12L2 : public Register<0x50001018> {
            using DACC2DHR = Field<4, 12>;    // DAC channel2 12-bit left-aligned data These bits are written by software which specify 12-bit data for DAC channel2.
            using DACC2DHRB = Field<20, 12>;    // DAC channel2 12-bit left-aligned data B
        };

        // DAC channel2 8-bit right-aligned data holding register
        struct DAC_DHR8R2 : public Register<0x5000101c> {
            using DACC2DHR = Field<0, 8>;    // DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
            using DACC2DHRB = Field<8, 8>;    // DAC channel2 8-bit right-aligned data
        };

        // Dual DAC 12-bit right-aligned data holding register
        struct DAC_DHR12RD : public Register<0x50001020> {
            using DACC1DHR = Field<0, 12>;    // DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
            using DACC2DHR = Field<16, 12>;    // DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
        };

        // DUAL DAC 12-bit left aligned data holding register
        struct DAC_DHR12LD : public Register<0x50001024> {
            using DACC1DHR = Field<4, 12>;    // DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
            using DACC2DHR = Field<20, 12>;    // DAC channel2 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
        };

        // DUAL DAC 8-bit right aligned data holding register
        struct DAC_DHR8RD : public Register<0x50001028> {
            using DACC1DHR = Field<0, 8>;    // DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
            using DACC2DHR = Field<8, 8>;    // DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
        };

        // DAC channel1 data output register
        struct DAC_DOR1 : public Register<0x5000102c> {
            using DACC1DOR = Field<0, 12>;    // DAC channel1 data output These bits are read-only, they contain data output for DAC channel1.
            using DACC1DORB = Field<16, 12>;    // DAC channel1 data output
        };

        // DAC channel2 data output register
        struct DAC_DOR2 : public Register<0x50001030> {
            using DACC2DOR = Field<0, 12>;    // DAC channel2 data output These bits are read-only, they contain data output for DAC channel2.
            using DACC2DORB = Field<16, 12>;    // DAC channel2 data output
        };

        // DAC status register
        struct DAC_SR : public Register<0x50001034> {
            using DAC1RDY = Field<11, 1>;    // DAC channel1 ready status bit
            using DORSTAT1 = Field<12, 1>;    // DAC channel1 output register status bit
            using DMAUDR1 = Field<13, 1>;    // DAC channel1 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
            using CAL_FLAG1 = Field<14, 1>;    // DAC Channel 1 calibration offset status This bit is set and cleared by hardware
            using BWST1 = Field<15, 1>;    // DAC Channel 1 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization).
            using DAC2RDY = Field<27, 1>;    // DAC channel 2 ready status bit
            using DORSTAT2 = Field<28, 1>;    // DAC channel 2 output register status bit
            using DMAUDR2 = Field<29, 1>;    // DAC channel2 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
            using CAL_FLAG2 = Field<30, 1>;    // DAC Channel 2 calibration offset status This bit is set and cleared by hardware
            using BWST2 = Field<31, 1>;    // DAC Channel 2 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR2, It is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization).
        };

        // DAC calibration control register
        struct DAC_CCR : public Register<0x50001038> {
            using OTRIM1 = Field<0, 5>;    // DAC Channel 1 offset trimming value
            using OTRIM2 = Field<16, 5>;    // DAC Channel 2 offset trimming value
        };

        // DAC mode control register
        struct DAC_MCR : public Register<0x5000103c> {
            using MODE1 = Field<0, 3>;    // DAC Channel 1 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 1 mode: DAC Channel 1 in normal Mode DAC Channel 1 in sample &amp; hold mode
            using DMADOUBLE1 = Field<8, 1>;    // DAC Channel1 DMA double data mode
            using SINFORMAT1 = Field<9, 1>;    // Enable signed format for DAC channel1
            using HFSEL = Field<14, 2>;    // High frequency interface mode selection
            using MODE2 = Field<16, 3>;    // DAC Channel 2 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 2 mode: DAC Channel 2 in normal Mode DAC Channel 2 in sample &amp; hold mode
            using DMADOUBLE2 = Field<24, 1>;    // DAC Channel2 DMA double data mode
            using SINFORMAT2 = Field<25, 1>;    // Enable signed format for DAC channel2
        };

        // DAC Sample and Hold sample time register 1
        struct DAC_SHSR1 : public Register<0x50001040> {
            using TSAMPLE1 = Field<0, 10>;    // DAC Channel 1 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, If BWSTx=1, the write operation is ignored.
        };

        // DAC Sample and Hold sample time register 2
        struct DAC_SHSR2 : public Register<0x50001044> {
            using TSAMPLE2 = Field<0, 10>;    // DAC Channel 2 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel2 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, if BWSTx=1, the write operation is ignored.
        };

        // DAC Sample and Hold hold time register
        struct DAC_SHHR : public Register<0x50001048> {
            using THOLD1 = Field<0, 10>;    // DAC Channel 1 hold Time (only valid in sample &amp; hold mode) Hold time= (THOLD[9:0]) x T LSI
            using THOLD2 = Field<16, 10>;    // DAC Channel 2 hold time (only valid in sample &amp; hold mode). Hold time= (THOLD[9:0]) x T LSI
        };

        // DAC Sample and Hold refresh time register
        struct DAC_SHRR : public Register<0x5000104c> {
            using TREFRESH1 = Field<0, 8>;    // DAC Channel 1 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
            using TREFRESH2 = Field<16, 8>;    // DAC Channel 2 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
        };

        // Sawtooth register
        struct DAC_STR1 : public Register<0x50001058> {
            using STRSTDATA1 = Field<0, 12>;    // DAC Channel 1 Sawtooth reset value
            using STDIR1 = Field<12, 1>;    // DAC Channel1 Sawtooth direction setting
            using STINCDATA1 = Field<16, 16>;    // DAC CH1 Sawtooth increment value (12.4 bit format)
        };

        // Sawtooth register
        struct DAC_STR2 : public Register<0x5000105c> {
            using STRSTDATA2 = Field<0, 12>;    // DAC Channel 2 Sawtooth reset value
            using STDIR2 = Field<12, 1>;    // DAC Channel2 Sawtooth direction setting
            using STINCDATA2 = Field<16, 16>;    // DAC CH2 Sawtooth increment value (12.4 bit format)
        };

        // Sawtooth Mode register
        struct DAC_STMODR : public Register<0x50001060> {
            using STRSTTRIGSEL1 = Field<0, 4>;    // DAC Channel 1 Sawtooth Reset trigger selection
            using STINCTRIGSEL1 = Field<8, 4>;    // DAC Channel 1 Sawtooth Increment trigger selection
            using STRSTTRIGSEL2 = Field<16, 4>;    // DAC Channel 1 Sawtooth Reset trigger selection
            using STINCTRIGSEL2 = Field<24, 4>;    // DAC Channel 2 Sawtooth Increment trigger selection
        };

    };

    // Digital-to-analog converter
    struct DAC4 {
        // DAC control register
        struct DAC_CR : public Register<0x50001400> {
            using EN1 = Field<0, 1>;    // DAC channel1 enable This bit is set and cleared by software to enable/disable DAC channel1.
            using TEN1 = Field<1, 1>;    // DAC channel1 trigger enable
            using TSEL1 = Field<2, 4>;    // DAC channel1 trigger selection These bits select the external event used to trigger DAC channel1. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
            using WAVE1 = Field<6, 2>;    // DAC channel1 noise/triangle wave generation enable These bits are set and cleared by software. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
            using MAMP1 = Field<8, 4>;    // DAC channel1 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
            using DMAEN1 = Field<12, 1>;    // DAC channel1 DMA enable This bit is set and cleared by software.
            using DMAUDRIE1 = Field<13, 1>;    // DAC channel1 DMA Underrun Interrupt enable This bit is set and cleared by software.
            using CEN1 = Field<14, 1>;    // DAC Channel 1 calibration enable This bit is set and cleared by software to enable/disable DAC channel 1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
            using EN2 = Field<16, 1>;    // DAC channel2 enable This bit is set and cleared by software to enable/disable DAC channel2.
            using TEN2 = Field<17, 1>;    // DAC channel2 trigger enable
            using TSEL2 = Field<18, 4>;    // DAC channel2 trigger selection These bits select the external event used to trigger DAC channel2 Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled).
            using WAVE2 = Field<22, 2>;    // DAC channel2 noise/triangle wave generation enable These bits are set/reset by software. 1x: Triangle wave generation enabled Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled)
            using MAMP2 = Field<24, 4>;    // DAC channel2 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
            using DMAEN2 = Field<28, 1>;    // DAC channel2 DMA enable This bit is set and cleared by software.
            using DMAUDRIE2 = Field<29, 1>;    // DAC channel2 DMA underrun interrupt enable This bit is set and cleared by software.
            using CEN2 = Field<30, 1>;    // DAC Channel 2 calibration enable This bit is set and cleared by software to enable/disable DAC channel 2 calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
        };

        // DAC software trigger register
        struct DAC_SWTRGR : public Register<0x50001404> {
            using SWTRIG1 = Field<0, 1>;    // DAC channel1 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register.
            using SWTRIG2 = Field<1, 1>;    // DAC channel2 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register.
            using SWTRIGB1 = Field<16, 1>;    // DAC channel1 software trigger B
            using SWTRIGB2 = Field<17, 1>;    // DAC channel2 software trigger B
        };

        // DAC channel1 12-bit right-aligned data holding register
        struct DAC_DHR12R1 : public Register<0x50001408> {
            using DACC1DHR = Field<0, 12>;    // DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
            using DACC1DHRB = Field<16, 12>;    // DAC channel1 12-bit right-aligned data B
        };

        // DAC channel1 12-bit left aligned data holding register
        struct DAC_DHR12L1 : public Register<0x5000140c> {
            using DACC1DHR = Field<4, 12>;    // DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
            using DACC1DHRB = Field<20, 12>;    // DAC channel1 12-bit left-aligned data B
        };

        // DAC channel1 8-bit right aligned data holding register
        struct DAC_DHR8R1 : public Register<0x50001410> {
            using DACC1DHR = Field<0, 8>;    // DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
            using DACC1DHRB = Field<8, 8>;    // DAC channel1 8-bit right-aligned data
        };

        // DAC channel2 12-bit right aligned data holding register
        struct DAC_DHR12R2 : public Register<0x50001414> {
            using DACC2DHR = Field<0, 12>;    // DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
            using DACC2DHRB = Field<16, 12>;    // DAC channel2 12-bit right-aligned data
        };

        // DAC channel2 12-bit left aligned data holding register
        struct DAC_DHR12L2 : public Register<0x50001418> {
            using DACC2DHR = Field<4, 12>;    // DAC channel2 12-bit left-aligned data These bits are written by software which specify 12-bit data for DAC channel2.
            using DACC2DHRB = Field<20, 12>;    // DAC channel2 12-bit left-aligned data B
        };

        // DAC channel2 8-bit right-aligned data holding register
        struct DAC_DHR8R2 : public Register<0x5000141c> {
            using DACC2DHR = Field<0, 8>;    // DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
            using DACC2DHRB = Field<8, 8>;    // DAC channel2 8-bit right-aligned data
        };

        // Dual DAC 12-bit right-aligned data holding register
        struct DAC_DHR12RD : public Register<0x50001420> {
            using DACC1DHR = Field<0, 12>;    // DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
            using DACC2DHR = Field<16, 12>;    // DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
        };

        // DUAL DAC 12-bit left aligned data holding register
        struct DAC_DHR12LD : public Register<0x50001424> {
            using DACC1DHR = Field<4, 12>;    // DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
            using DACC2DHR = Field<20, 12>;    // DAC channel2 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
        };

        // DUAL DAC 8-bit right aligned data holding register
        struct DAC_DHR8RD : public Register<0x50001428> {
            using DACC1DHR = Field<0, 8>;    // DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
            using DACC2DHR = Field<8, 8>;    // DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
        };

        // DAC channel1 data output register
        struct DAC_DOR1 : public Register<0x5000142c> {
            using DACC1DOR = Field<0, 12>;    // DAC channel1 data output These bits are read-only, they contain data output for DAC channel1.
            using DACC1DORB = Field<16, 12>;    // DAC channel1 data output
        };

        // DAC channel2 data output register
        struct DAC_DOR2 : public Register<0x50001430> {
            using DACC2DOR = Field<0, 12>;    // DAC channel2 data output These bits are read-only, they contain data output for DAC channel2.
            using DACC2DORB = Field<16, 12>;    // DAC channel2 data output
        };

        // DAC status register
        struct DAC_SR : public Register<0x50001434> {
            using DAC1RDY = Field<11, 1>;    // DAC channel1 ready status bit
            using DORSTAT1 = Field<12, 1>;    // DAC channel1 output register status bit
            using DMAUDR1 = Field<13, 1>;    // DAC channel1 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
            using CAL_FLAG1 = Field<14, 1>;    // DAC Channel 1 calibration offset status This bit is set and cleared by hardware
            using BWST1 = Field<15, 1>;    // DAC Channel 1 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization).
            using DAC2RDY = Field<27, 1>;    // DAC channel 2 ready status bit
            using DORSTAT2 = Field<28, 1>;    // DAC channel 2 output register status bit
            using DMAUDR2 = Field<29, 1>;    // DAC channel2 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
            using CAL_FLAG2 = Field<30, 1>;    // DAC Channel 2 calibration offset status This bit is set and cleared by hardware
            using BWST2 = Field<31, 1>;    // DAC Channel 2 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR2, It is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization).
        };

        // DAC calibration control register
        struct DAC_CCR : public Register<0x50001438> {
            using OTRIM1 = Field<0, 5>;    // DAC Channel 1 offset trimming value
            using OTRIM2 = Field<16, 5>;    // DAC Channel 2 offset trimming value
        };

        // DAC mode control register
        struct DAC_MCR : public Register<0x5000143c> {
            using MODE1 = Field<0, 3>;    // DAC Channel 1 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 1 mode: DAC Channel 1 in normal Mode DAC Channel 1 in sample &amp; hold mode
            using DMADOUBLE1 = Field<8, 1>;    // DAC Channel1 DMA double data mode
            using SINFORMAT1 = Field<9, 1>;    // Enable signed format for DAC channel1
            using HFSEL = Field<14, 2>;    // High frequency interface mode selection
            using MODE2 = Field<16, 3>;    // DAC Channel 2 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 2 mode: DAC Channel 2 in normal Mode DAC Channel 2 in sample &amp; hold mode
            using DMADOUBLE2 = Field<24, 1>;    // DAC Channel2 DMA double data mode
            using SINFORMAT2 = Field<25, 1>;    // Enable signed format for DAC channel2
        };

        // DAC Sample and Hold sample time register 1
        struct DAC_SHSR1 : public Register<0x50001440> {
            using TSAMPLE1 = Field<0, 10>;    // DAC Channel 1 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, If BWSTx=1, the write operation is ignored.
        };

        // DAC Sample and Hold sample time register 2
        struct DAC_SHSR2 : public Register<0x50001444> {
            using TSAMPLE2 = Field<0, 10>;    // DAC Channel 2 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel2 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, if BWSTx=1, the write operation is ignored.
        };

        // DAC Sample and Hold hold time register
        struct DAC_SHHR : public Register<0x50001448> {
            using THOLD1 = Field<0, 10>;    // DAC Channel 1 hold Time (only valid in sample &amp; hold mode) Hold time= (THOLD[9:0]) x T LSI
            using THOLD2 = Field<16, 10>;    // DAC Channel 2 hold time (only valid in sample &amp; hold mode). Hold time= (THOLD[9:0]) x T LSI
        };

        // DAC Sample and Hold refresh time register
        struct DAC_SHRR : public Register<0x5000144c> {
            using TREFRESH1 = Field<0, 8>;    // DAC Channel 1 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
            using TREFRESH2 = Field<16, 8>;    // DAC Channel 2 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
        };

        // Sawtooth register
        struct DAC_STR1 : public Register<0x50001458> {
            using STRSTDATA1 = Field<0, 12>;    // DAC Channel 1 Sawtooth reset value
            using STDIR1 = Field<12, 1>;    // DAC Channel1 Sawtooth direction setting
            using STINCDATA1 = Field<16, 16>;    // DAC CH1 Sawtooth increment value (12.4 bit format)
        };

        // Sawtooth register
        struct DAC_STR2 : public Register<0x5000145c> {
            using STRSTDATA2 = Field<0, 12>;    // DAC Channel 2 Sawtooth reset value
            using STDIR2 = Field<12, 1>;    // DAC Channel2 Sawtooth direction setting
            using STINCDATA2 = Field<16, 16>;    // DAC CH2 Sawtooth increment value (12.4 bit format)
        };

        // Sawtooth Mode register
        struct DAC_STMODR : public Register<0x50001460> {
            using STRSTTRIGSEL1 = Field<0, 4>;    // DAC Channel 1 Sawtooth Reset trigger selection
            using STINCTRIGSEL1 = Field<8, 4>;    // DAC Channel 1 Sawtooth Increment trigger selection
            using STRSTTRIGSEL2 = Field<16, 4>;    // DAC Channel 1 Sawtooth Reset trigger selection
            using STINCTRIGSEL2 = Field<24, 4>;    // DAC Channel 2 Sawtooth Increment trigger selection
        };

    };

    // Analog-to-Digital Converter
    struct ADC1 {
        // interrupt and status register
        struct ISR : public Register<0x50000000> {
            using JQOVF = Field<10, 1>;    // JQOVF
            using AWD3 = Field<9, 1>;    // AWD3
            using AWD2 = Field<8, 1>;    // AWD2
            using AWD1 = Field<7, 1>;    // AWD1
            using JEOS = Field<6, 1>;    // JEOS
            using JEOC = Field<5, 1>;    // JEOC
            using OVR = Field<4, 1>;    // OVR
            using EOS = Field<3, 1>;    // EOS
            using EOC = Field<2, 1>;    // EOC
            using EOSMP = Field<1, 1>;    // EOSMP
            using ADRDY = Field<0, 1>;    // ADRDY
        };

        // interrupt enable register
        struct IER : public Register<0x50000004> {
            using JQOVFIE = Field<10, 1>;    // JQOVFIE
            using AWD3IE = Field<9, 1>;    // AWD3IE
            using AWD2IE = Field<8, 1>;    // AWD2IE
            using AWD1IE = Field<7, 1>;    // AWD1IE
            using JEOSIE = Field<6, 1>;    // JEOSIE
            using JEOCIE = Field<5, 1>;    // JEOCIE
            using OVRIE = Field<4, 1>;    // OVRIE
            using EOSIE = Field<3, 1>;    // EOSIE
            using EOCIE = Field<2, 1>;    // EOCIE
            using EOSMPIE = Field<1, 1>;    // EOSMPIE
            using ADRDYIE = Field<0, 1>;    // ADRDYIE
        };

        // control register
        struct CR : public Register<0x50000008> {
            using ADCAL = Field<31, 1>;    // ADCAL
            using ADCALDIF = Field<30, 1>;    // ADCALDIF
            using DEEPPWD = Field<29, 1>;    // DEEPPWD
            using ADVREGEN = Field<28, 1>;    // ADVREGEN
            using JADSTP = Field<5, 1>;    // JADSTP
            using ADSTP = Field<4, 1>;    // ADSTP
            using JADSTART = Field<3, 1>;    // JADSTART
            using ADSTART = Field<2, 1>;    // ADSTART
            using ADDIS = Field<1, 1>;    // ADDIS
            using ADEN = Field<0, 1>;    // ADEN
        };

        // configuration register
        struct CFGR : public Register<0x5000000c> {
            using JQDIS = Field<31, 1>;    // Injected Queue disable
            using AWDCH1CH = Field<26, 5>;    // AWDCH1CH
            using JAUTO = Field<25, 1>;    // JAUTO
            using JAWD1EN = Field<24, 1>;    // JAWD1EN
            using AWD1EN = Field<23, 1>;    // AWD1EN
            using AWD1SGL = Field<22, 1>;    // AWD1SGL
            using JQM = Field<21, 1>;    // JQM
            using JDISCEN = Field<20, 1>;    // JDISCEN
            using DISCNUM = Field<17, 3>;    // DISCNUM
            using DISCEN = Field<16, 1>;    // DISCEN
            using ALIGN = Field<15, 1>;    // ALIGN
            using AUTDLY = Field<14, 1>;    // AUTDLY
            using CONT = Field<13, 1>;    // CONT
            using OVRMOD = Field<12, 1>;    // OVRMOD
            using EXTEN = Field<10, 2>;    // EXTEN
            using EXTSEL = Field<6, 4>;    // EXTSEL
            using ALIGN_5 = Field<5, 1>;    // ALIGN_5
            using RES = Field<3, 2>;    // RES
            using DMACFG = Field<1, 1>;    // DMACFG
            using DMAEN = Field<0, 1>;    // DMAEN
        };

        // configuration register
        struct CFGR2 : public Register<0x50000010> {
            using SMPTRIG = Field<27, 1>;    // SMPTRIG
            using BULB = Field<26, 1>;    // BULB
            using SWTRIG = Field<25, 1>;    // SWTRIG
            using GCOMP = Field<16, 1>;    // GCOMP
            using ROVSM = Field<10, 1>;    // EXTEN
            using TROVS = Field<9, 1>;    // Triggered Regular Oversampling
            using OVSS = Field<5, 4>;    // ALIGN
            using OVSR = Field<2, 3>;    // RES
            using JOVSE = Field<1, 1>;    // DMACFG
            using ROVSE = Field<0, 1>;    // DMAEN
        };

        // sample time register 1
        struct SMPR1 : public Register<0x50000014> {
            using SMP9 = Field<27, 3>;    // SMP9
            using SMP8 = Field<24, 3>;    // SMP8
            using SMP7 = Field<21, 3>;    // SMP7
            using SMP6 = Field<18, 3>;    // SMP6
            using SMP5 = Field<15, 3>;    // SMP5
            using SMP4 = Field<12, 3>;    // SMP4
            using SMP3 = Field<9, 3>;    // SMP3
            using SMP2 = Field<6, 3>;    // SMP2
            using SMP1 = Field<3, 3>;    // SMP1
            using SMPPLUS = Field<31, 1>;    // Addition of one clock cycle to the sampling time
            using SMP0 = Field<0, 3>;    // SMP0
        };

        // sample time register 2
        struct SMPR2 : public Register<0x50000018> {
            using SMP18 = Field<24, 3>;    // SMP18
            using SMP17 = Field<21, 3>;    // SMP17
            using SMP16 = Field<18, 3>;    // SMP16
            using SMP15 = Field<15, 3>;    // SMP15
            using SMP14 = Field<12, 3>;    // SMP14
            using SMP13 = Field<9, 3>;    // SMP13
            using SMP12 = Field<6, 3>;    // SMP12
            using SMP11 = Field<3, 3>;    // SMP11
            using SMP10 = Field<0, 3>;    // SMP10
        };

        // watchdog threshold register 1
        struct TR1 : public Register<0x50000020> {
            using HT1 = Field<16, 12>;    // HT1
            using AWDFILT = Field<12, 3>;    // AWDFILT
            using LT1 = Field<0, 12>;    // LT1
        };

        // watchdog threshold register
        struct TR2 : public Register<0x50000024> {
            using HT2 = Field<16, 8>;    // HT2
            using LT2 = Field<0, 8>;    // LT2
        };

        // watchdog threshold register 3
        struct TR3 : public Register<0x50000028> {
            using HT3 = Field<16, 8>;    // HT3
            using LT3 = Field<0, 8>;    // LT3
        };

        // regular sequence register 1
        struct SQR1 : public Register<0x50000030> {
            using SQ4 = Field<24, 5>;    // SQ4
            using SQ3 = Field<18, 5>;    // SQ3
            using SQ2 = Field<12, 5>;    // SQ2
            using SQ1 = Field<6, 5>;    // SQ1
            using L = Field<0, 4>;    // Regular channel sequence length
        };

        // regular sequence register 2
        struct SQR2 : public Register<0x50000034> {
            using SQ9 = Field<24, 5>;    // SQ9
            using SQ8 = Field<18, 5>;    // SQ8
            using SQ7 = Field<12, 5>;    // SQ7
            using SQ6 = Field<6, 5>;    // SQ6
            using SQ5 = Field<0, 5>;    // SQ5
        };

        // regular sequence register 3
        struct SQR3 : public Register<0x50000038> {
            using SQ14 = Field<24, 5>;    // SQ14
            using SQ13 = Field<18, 5>;    // SQ13
            using SQ12 = Field<12, 5>;    // SQ12
            using SQ11 = Field<6, 5>;    // SQ11
            using SQ10 = Field<0, 5>;    // SQ10
        };

        // regular sequence register 4
        struct SQR4 : public Register<0x5000003c> {
            using SQ16 = Field<6, 5>;    // SQ16
            using SQ15 = Field<0, 5>;    // SQ15
        };

        // regular Data Register
        struct DR : public Register<0x50000040> {
            using RDATA = Field<0, 16>;    // Regular Data converted
        };

        // injected sequence register
        struct JSQR : public Register<0x5000004c> {
            using JSQ4 = Field<27, 5>;    // JSQ4
            using JSQ3 = Field<21, 5>;    // JSQ3
            using JSQ2 = Field<15, 5>;    // JSQ2
            using JSQ1 = Field<9, 5>;    // JSQ1
            using JEXTEN = Field<7, 2>;    // JEXTEN
            using JEXTSEL = Field<2, 5>;    // JEXTSEL
            using JL = Field<0, 2>;    // JL
        };

        // offset register 1
        struct OFR1 : public Register<0x50000060> {
            using OFFSET1_EN = Field<31, 1>;    // OFFSET1_EN
            using OFFSET1_CH = Field<26, 5>;    // OFFSET1_CH
            using SATEN = Field<25, 1>;    // SATEN
            using OFFSETPOS = Field<24, 1>;    // OFFSETPOS
            using OFFSET1 = Field<0, 12>;    // OFFSET1
        };

        // offset register 2
        struct OFR2 : public Register<0x50000064> {
            using OFFSET1_EN = Field<31, 1>;    // OFFSET1_EN
            using OFFSET1_CH = Field<26, 5>;    // OFFSET1_CH
            using SATEN = Field<25, 1>;    // SATEN
            using OFFSETPOS = Field<24, 1>;    // OFFSETPOS
            using OFFSET1 = Field<0, 12>;    // OFFSET1
        };

        // offset register 3
        struct OFR3 : public Register<0x50000068> {
            using OFFSET1_EN = Field<31, 1>;    // OFFSET1_EN
            using OFFSET1_CH = Field<26, 5>;    // OFFSET1_CH
            using SATEN = Field<25, 1>;    // SATEN
            using OFFSETPOS = Field<24, 1>;    // OFFSETPOS
            using OFFSET1 = Field<0, 12>;    // OFFSET1
        };

        // offset register 4
        struct OFR4 : public Register<0x5000006c> {
            using OFFSET1_EN = Field<31, 1>;    // OFFSET1_EN
            using OFFSET1_CH = Field<26, 5>;    // OFFSET1_CH
            using SATEN = Field<25, 1>;    // SATEN
            using OFFSETPOS = Field<24, 1>;    // OFFSETPOS
            using OFFSET1 = Field<0, 12>;    // OFFSET1
        };

        // injected data register 1
        struct JDR1 : public Register<0x50000080> {
            using JDATA1 = Field<0, 16>;    // JDATA1
        };

        // injected data register 2
        struct JDR2 : public Register<0x50000084> {
            using JDATA2 = Field<0, 16>;    // JDATA2
        };

        // injected data register 3
        struct JDR3 : public Register<0x50000088> {
            using JDATA3 = Field<0, 16>;    // JDATA3
        };

        // injected data register 4
        struct JDR4 : public Register<0x5000008c> {
            using JDATA4 = Field<0, 16>;    // JDATA4
        };

        // Analog Watchdog 2 Configuration Register
        struct AWD2CR : public Register<0x500000a0> {
            using AWD2CH = Field<0, 19>;    // AWD2CH
        };

        // Analog Watchdog 3 Configuration Register
        struct AWD3CR : public Register<0x500000a4> {
            using AWD3CH = Field<0, 19>;    // AWD3CH
        };

        // Differential Mode Selection Register 2
        struct DIFSEL : public Register<0x500000b0> {
            using DIFSEL_0 = Field<0, 1>;    // Differential mode for channels 0
            using DIFSEL_1_18 = Field<1, 18>;    // Differential mode for channels 15 to 1
        };

        // Calibration Factors
        struct CALFACT : public Register<0x500000b4> {
            using CALFACT_D = Field<16, 7>;    // CALFACT_D
            using CALFACT_S = Field<0, 7>;    // CALFACT_S
        };

        // Gain compensation Register
        struct GCOMP : public Register<0x500000c0> {
            using GCOMPCOEFF = Field<0, 14>;    // GCOMPCOEFF
        };

    };

    // Analog-to-Digital Converter
    struct ADC2 {
        // interrupt and status register
        struct ISR : public Register<0x50000100> {
            using JQOVF = Field<10, 1>;    // JQOVF
            using AWD3 = Field<9, 1>;    // AWD3
            using AWD2 = Field<8, 1>;    // AWD2
            using AWD1 = Field<7, 1>;    // AWD1
            using JEOS = Field<6, 1>;    // JEOS
            using JEOC = Field<5, 1>;    // JEOC
            using OVR = Field<4, 1>;    // OVR
            using EOS = Field<3, 1>;    // EOS
            using EOC = Field<2, 1>;    // EOC
            using EOSMP = Field<1, 1>;    // EOSMP
            using ADRDY = Field<0, 1>;    // ADRDY
        };

        // interrupt enable register
        struct IER : public Register<0x50000104> {
            using JQOVFIE = Field<10, 1>;    // JQOVFIE
            using AWD3IE = Field<9, 1>;    // AWD3IE
            using AWD2IE = Field<8, 1>;    // AWD2IE
            using AWD1IE = Field<7, 1>;    // AWD1IE
            using JEOSIE = Field<6, 1>;    // JEOSIE
            using JEOCIE = Field<5, 1>;    // JEOCIE
            using OVRIE = Field<4, 1>;    // OVRIE
            using EOSIE = Field<3, 1>;    // EOSIE
            using EOCIE = Field<2, 1>;    // EOCIE
            using EOSMPIE = Field<1, 1>;    // EOSMPIE
            using ADRDYIE = Field<0, 1>;    // ADRDYIE
        };

        // control register
        struct CR : public Register<0x50000108> {
            using ADCAL = Field<31, 1>;    // ADCAL
            using ADCALDIF = Field<30, 1>;    // ADCALDIF
            using DEEPPWD = Field<29, 1>;    // DEEPPWD
            using ADVREGEN = Field<28, 1>;    // ADVREGEN
            using JADSTP = Field<5, 1>;    // JADSTP
            using ADSTP = Field<4, 1>;    // ADSTP
            using JADSTART = Field<3, 1>;    // JADSTART
            using ADSTART = Field<2, 1>;    // ADSTART
            using ADDIS = Field<1, 1>;    // ADDIS
            using ADEN = Field<0, 1>;    // ADEN
        };

        // configuration register
        struct CFGR : public Register<0x5000010c> {
            using JQDIS = Field<31, 1>;    // Injected Queue disable
            using AWDCH1CH = Field<26, 5>;    // AWDCH1CH
            using JAUTO = Field<25, 1>;    // JAUTO
            using JAWD1EN = Field<24, 1>;    // JAWD1EN
            using AWD1EN = Field<23, 1>;    // AWD1EN
            using AWD1SGL = Field<22, 1>;    // AWD1SGL
            using JQM = Field<21, 1>;    // JQM
            using JDISCEN = Field<20, 1>;    // JDISCEN
            using DISCNUM = Field<17, 3>;    // DISCNUM
            using DISCEN = Field<16, 1>;    // DISCEN
            using ALIGN = Field<15, 1>;    // ALIGN
            using AUTDLY = Field<14, 1>;    // AUTDLY
            using CONT = Field<13, 1>;    // CONT
            using OVRMOD = Field<12, 1>;    // OVRMOD
            using EXTEN = Field<10, 2>;    // EXTEN
            using EXTSEL = Field<6, 4>;    // EXTSEL
            using ALIGN_5 = Field<5, 1>;    // ALIGN_5
            using RES = Field<3, 2>;    // RES
            using DMACFG = Field<1, 1>;    // DMACFG
            using DMAEN = Field<0, 1>;    // DMAEN
        };

        // configuration register
        struct CFGR2 : public Register<0x50000110> {
            using SMPTRIG = Field<27, 1>;    // SMPTRIG
            using BULB = Field<26, 1>;    // BULB
            using SWTRIG = Field<25, 1>;    // SWTRIG
            using GCOMP = Field<16, 1>;    // GCOMP
            using ROVSM = Field<10, 1>;    // EXTEN
            using TROVS = Field<9, 1>;    // Triggered Regular Oversampling
            using OVSS = Field<5, 4>;    // ALIGN
            using OVSR = Field<2, 3>;    // RES
            using JOVSE = Field<1, 1>;    // DMACFG
            using ROVSE = Field<0, 1>;    // DMAEN
        };

        // sample time register 1
        struct SMPR1 : public Register<0x50000114> {
            using SMP9 = Field<27, 3>;    // SMP9
            using SMP8 = Field<24, 3>;    // SMP8
            using SMP7 = Field<21, 3>;    // SMP7
            using SMP6 = Field<18, 3>;    // SMP6
            using SMP5 = Field<15, 3>;    // SMP5
            using SMP4 = Field<12, 3>;    // SMP4
            using SMP3 = Field<9, 3>;    // SMP3
            using SMP2 = Field<6, 3>;    // SMP2
            using SMP1 = Field<3, 3>;    // SMP1
            using SMPPLUS = Field<31, 1>;    // Addition of one clock cycle to the sampling time
            using SMP0 = Field<0, 3>;    // SMP0
        };

        // sample time register 2
        struct SMPR2 : public Register<0x50000118> {
            using SMP18 = Field<24, 3>;    // SMP18
            using SMP17 = Field<21, 3>;    // SMP17
            using SMP16 = Field<18, 3>;    // SMP16
            using SMP15 = Field<15, 3>;    // SMP15
            using SMP14 = Field<12, 3>;    // SMP14
            using SMP13 = Field<9, 3>;    // SMP13
            using SMP12 = Field<6, 3>;    // SMP12
            using SMP11 = Field<3, 3>;    // SMP11
            using SMP10 = Field<0, 3>;    // SMP10
        };

        // watchdog threshold register 1
        struct TR1 : public Register<0x50000120> {
            using HT1 = Field<16, 12>;    // HT1
            using AWDFILT = Field<12, 3>;    // AWDFILT
            using LT1 = Field<0, 12>;    // LT1
        };

        // watchdog threshold register
        struct TR2 : public Register<0x50000124> {
            using HT2 = Field<16, 8>;    // HT2
            using LT2 = Field<0, 8>;    // LT2
        };

        // watchdog threshold register 3
        struct TR3 : public Register<0x50000128> {
            using HT3 = Field<16, 8>;    // HT3
            using LT3 = Field<0, 8>;    // LT3
        };

        // regular sequence register 1
        struct SQR1 : public Register<0x50000130> {
            using SQ4 = Field<24, 5>;    // SQ4
            using SQ3 = Field<18, 5>;    // SQ3
            using SQ2 = Field<12, 5>;    // SQ2
            using SQ1 = Field<6, 5>;    // SQ1
            using L = Field<0, 4>;    // Regular channel sequence length
        };

        // regular sequence register 2
        struct SQR2 : public Register<0x50000134> {
            using SQ9 = Field<24, 5>;    // SQ9
            using SQ8 = Field<18, 5>;    // SQ8
            using SQ7 = Field<12, 5>;    // SQ7
            using SQ6 = Field<6, 5>;    // SQ6
            using SQ5 = Field<0, 5>;    // SQ5
        };

        // regular sequence register 3
        struct SQR3 : public Register<0x50000138> {
            using SQ14 = Field<24, 5>;    // SQ14
            using SQ13 = Field<18, 5>;    // SQ13
            using SQ12 = Field<12, 5>;    // SQ12
            using SQ11 = Field<6, 5>;    // SQ11
            using SQ10 = Field<0, 5>;    // SQ10
        };

        // regular sequence register 4
        struct SQR4 : public Register<0x5000013c> {
            using SQ16 = Field<6, 5>;    // SQ16
            using SQ15 = Field<0, 5>;    // SQ15
        };

        // regular Data Register
        struct DR : public Register<0x50000140> {
            using RDATA = Field<0, 16>;    // Regular Data converted
        };

        // injected sequence register
        struct JSQR : public Register<0x5000014c> {
            using JSQ4 = Field<27, 5>;    // JSQ4
            using JSQ3 = Field<21, 5>;    // JSQ3
            using JSQ2 = Field<15, 5>;    // JSQ2
            using JSQ1 = Field<9, 5>;    // JSQ1
            using JEXTEN = Field<7, 2>;    // JEXTEN
            using JEXTSEL = Field<2, 5>;    // JEXTSEL
            using JL = Field<0, 2>;    // JL
        };

        // offset register 1
        struct OFR1 : public Register<0x50000160> {
            using OFFSET1_EN = Field<31, 1>;    // OFFSET1_EN
            using OFFSET1_CH = Field<26, 5>;    // OFFSET1_CH
            using SATEN = Field<25, 1>;    // SATEN
            using OFFSETPOS = Field<24, 1>;    // OFFSETPOS
            using OFFSET1 = Field<0, 12>;    // OFFSET1
        };

        // offset register 2
        struct OFR2 : public Register<0x50000164> {
            using OFFSET1_EN = Field<31, 1>;    // OFFSET1_EN
            using OFFSET1_CH = Field<26, 5>;    // OFFSET1_CH
            using SATEN = Field<25, 1>;    // SATEN
            using OFFSETPOS = Field<24, 1>;    // OFFSETPOS
            using OFFSET1 = Field<0, 12>;    // OFFSET1
        };

        // offset register 3
        struct OFR3 : public Register<0x50000168> {
            using OFFSET1_EN = Field<31, 1>;    // OFFSET1_EN
            using OFFSET1_CH = Field<26, 5>;    // OFFSET1_CH
            using SATEN = Field<25, 1>;    // SATEN
            using OFFSETPOS = Field<24, 1>;    // OFFSETPOS
            using OFFSET1 = Field<0, 12>;    // OFFSET1
        };

        // offset register 4
        struct OFR4 : public Register<0x5000016c> {
            using OFFSET1_EN = Field<31, 1>;    // OFFSET1_EN
            using OFFSET1_CH = Field<26, 5>;    // OFFSET1_CH
            using SATEN = Field<25, 1>;    // SATEN
            using OFFSETPOS = Field<24, 1>;    // OFFSETPOS
            using OFFSET1 = Field<0, 12>;    // OFFSET1
        };

        // injected data register 1
        struct JDR1 : public Register<0x50000180> {
            using JDATA1 = Field<0, 16>;    // JDATA1
        };

        // injected data register 2
        struct JDR2 : public Register<0x50000184> {
            using JDATA2 = Field<0, 16>;    // JDATA2
        };

        // injected data register 3
        struct JDR3 : public Register<0x50000188> {
            using JDATA3 = Field<0, 16>;    // JDATA3
        };

        // injected data register 4
        struct JDR4 : public Register<0x5000018c> {
            using JDATA4 = Field<0, 16>;    // JDATA4
        };

        // Analog Watchdog 2 Configuration Register
        struct AWD2CR : public Register<0x500001a0> {
            using AWD2CH = Field<0, 19>;    // AWD2CH
        };

        // Analog Watchdog 3 Configuration Register
        struct AWD3CR : public Register<0x500001a4> {
            using AWD3CH = Field<0, 19>;    // AWD3CH
        };

        // Differential Mode Selection Register 2
        struct DIFSEL : public Register<0x500001b0> {
            using DIFSEL_0 = Field<0, 1>;    // Differential mode for channels 0
            using DIFSEL_1_18 = Field<1, 18>;    // Differential mode for channels 15 to 1
        };

        // Calibration Factors
        struct CALFACT : public Register<0x500001b4> {
            using CALFACT_D = Field<16, 7>;    // CALFACT_D
            using CALFACT_S = Field<0, 7>;    // CALFACT_S
        };

        // Gain compensation Register
        struct GCOMP : public Register<0x500001c0> {
            using GCOMPCOEFF = Field<0, 14>;    // GCOMPCOEFF
        };

    };

    // Analog-to-Digital Converter
    struct ADC12_Common {
        // ADC Common status register
        struct CSR : public Register<0x50000200> {
            using ADDRDY_MST = Field<0, 1>;    // ADDRDY_MST
            using EOSMP_MST = Field<1, 1>;    // EOSMP_MST
            using EOC_MST = Field<2, 1>;    // EOC_MST
            using EOS_MST = Field<3, 1>;    // EOS_MST
            using OVR_MST = Field<4, 1>;    // OVR_MST
            using JEOC_MST = Field<5, 1>;    // JEOC_MST
            using JEOS_MST = Field<6, 1>;    // JEOS_MST
            using AWD1_MST = Field<7, 1>;    // AWD1_MST
            using AWD2_MST = Field<8, 1>;    // AWD2_MST
            using AWD3_MST = Field<9, 1>;    // AWD3_MST
            using JQOVF_MST = Field<10, 1>;    // JQOVF_MST
            using ADRDY_SLV = Field<16, 1>;    // ADRDY_SLV
            using EOSMP_SLV = Field<17, 1>;    // EOSMP_SLV
            using EOC_SLV = Field<18, 1>;    // End of regular conversion of the slave ADC
            using EOS_SLV = Field<19, 1>;    // End of regular sequence flag of the slave ADC
            using OVR_SLV = Field<20, 1>;    // Overrun flag of the slave ADC
            using JEOC_SLV = Field<21, 1>;    // End of injected conversion flag of the slave ADC
            using JEOS_SLV = Field<22, 1>;    // End of injected sequence flag of the slave ADC
            using AWD1_SLV = Field<23, 1>;    // Analog watchdog 1 flag of the slave ADC
            using AWD2_SLV = Field<24, 1>;    // Analog watchdog 2 flag of the slave ADC
            using AWD3_SLV = Field<25, 1>;    // Analog watchdog 3 flag of the slave ADC
            using JQOVF_SLV = Field<26, 1>;    // Injected Context Queue Overflow flag of the slave ADC
        };

        // ADC common control register
        struct CCR : public Register<0x50000208> {
            using DUAL = Field<0, 5>;    // Dual ADC mode selection
            using DELAY = Field<8, 4>;    // Delay between 2 sampling phases
            using DMACFG = Field<13, 1>;    // DMA configuration (for multi-ADC mode)
            using MDMA = Field<14, 2>;    // Direct memory access mode for multi ADC mode
            using CKMODE = Field<16, 2>;    // ADC clock mode
            using VREFEN = Field<22, 1>;    // VREFINT enable
            using CH17SEL = Field<23, 1>;    // CH17 selection
            using CH18SEL = Field<24, 1>;    // CH18 selection
            using PRESC = Field<18, 4>;    // ADC prescaler
        };

        // ADC common regular data register for dual and triple modes
        struct CDR : public Register<0x5000020c> {
            using RDATA_SLV = Field<16, 16>;    // Regular data of the slave ADC
            using RDATA_MST = Field<0, 16>;    // Regular data of the master ADC
        };

    };

    // Analog-to-Digital Converter
    struct ADC345_Common {
        // ADC Common status register
        struct CSR : public Register<0x50000700> {
            using ADDRDY_MST = Field<0, 1>;    // ADDRDY_MST
            using EOSMP_MST = Field<1, 1>;    // EOSMP_MST
            using EOC_MST = Field<2, 1>;    // EOC_MST
            using EOS_MST = Field<3, 1>;    // EOS_MST
            using OVR_MST = Field<4, 1>;    // OVR_MST
            using JEOC_MST = Field<5, 1>;    // JEOC_MST
            using JEOS_MST = Field<6, 1>;    // JEOS_MST
            using AWD1_MST = Field<7, 1>;    // AWD1_MST
            using AWD2_MST = Field<8, 1>;    // AWD2_MST
            using AWD3_MST = Field<9, 1>;    // AWD3_MST
            using JQOVF_MST = Field<10, 1>;    // JQOVF_MST
            using ADRDY_SLV = Field<16, 1>;    // ADRDY_SLV
            using EOSMP_SLV = Field<17, 1>;    // EOSMP_SLV
            using EOC_SLV = Field<18, 1>;    // End of regular conversion of the slave ADC
            using EOS_SLV = Field<19, 1>;    // End of regular sequence flag of the slave ADC
            using OVR_SLV = Field<20, 1>;    // Overrun flag of the slave ADC
            using JEOC_SLV = Field<21, 1>;    // End of injected conversion flag of the slave ADC
            using JEOS_SLV = Field<22, 1>;    // End of injected sequence flag of the slave ADC
            using AWD1_SLV = Field<23, 1>;    // Analog watchdog 1 flag of the slave ADC
            using AWD2_SLV = Field<24, 1>;    // Analog watchdog 2 flag of the slave ADC
            using AWD3_SLV = Field<25, 1>;    // Analog watchdog 3 flag of the slave ADC
            using JQOVF_SLV = Field<26, 1>;    // Injected Context Queue Overflow flag of the slave ADC
        };

        // ADC common control register
        struct CCR : public Register<0x50000708> {
            using DUAL = Field<0, 5>;    // Dual ADC mode selection
            using DELAY = Field<8, 4>;    // Delay between 2 sampling phases
            using DMACFG = Field<13, 1>;    // DMA configuration (for multi-ADC mode)
            using MDMA = Field<14, 2>;    // Direct memory access mode for multi ADC mode
            using CKMODE = Field<16, 2>;    // ADC clock mode
            using VREFEN = Field<22, 1>;    // VREFINT enable
            using CH17SEL = Field<23, 1>;    // CH17 selection
            using CH18SEL = Field<24, 1>;    // CH18 selection
            using PRESC = Field<18, 4>;    // ADC prescaler
        };

        // ADC common regular data register for dual and triple modes
        struct CDR : public Register<0x5000070c> {
            using RDATA_SLV = Field<16, 16>;    // Regular data of the slave ADC
            using RDATA_MST = Field<0, 16>;    // Regular data of the master ADC
        };

    };

    // Filter Math Accelerator
    struct FMAC {
        // FMAC X1 Buffer Configuration register
        struct X1BUFCFG : public Register<0x40021400> {
            using X1_BASE = Field<0, 8>;    // X1_BASE
            using X1_BUF_SIZE = Field<8, 8>;    // X1_BUF_SIZE
            using FULL_WM = Field<24, 2>;    // FULL_WM
        };

        // FMAC X2 Buffer Configuration register
        struct X2BUFCFG : public Register<0x40021404> {
            using X2_BASE = Field<0, 8>;    // X1_BASE
            using X2_BUF_SIZE = Field<8, 8>;    // X1_BUF_SIZE
        };

        // FMAC Y Buffer Configuration register
        struct YBUFCFG : public Register<0x40021408> {
            using Y_BASE = Field<0, 8>;    // X1_BASE
            using Y_BUF_SIZE = Field<8, 8>;    // X1_BUF_SIZE
            using EMPTY_WM = Field<24, 2>;    // EMPTY_WM
        };

        // FMAC Parameter register
        struct PARAM : public Register<0x4002140c> {
            using START = Field<31, 1>;    // START
            using FUNC = Field<24, 7>;    // FUNC
            using R = Field<16, 8>;    // R
            using Q = Field<8, 8>;    // Q
            using P = Field<0, 8>;    // P
        };

        // FMAC Control register
        struct CR : public Register<0x40021410> {
            using RESET = Field<16, 1>;    // RESET
            using CLIPEN = Field<15, 1>;    // CLIPEN
            using DMAWEN = Field<9, 1>;    // DMAWEN
            using DMAREN = Field<8, 1>;    // DMAREN
            using SATIEN = Field<4, 1>;    // SATIEN
            using UNFLIEN = Field<3, 1>;    // UNFLIEN
            using OVFLIEN = Field<2, 1>;    // OVFLIEN
            using WIEN = Field<1, 1>;    // WIEN
            using RIEN = Field<0, 1>;    // RIEN
        };

        // FMAC Status register
        struct SR : public Register<0x40021414> {
            using YEMPTY = Field<0, 1>;    // YEMPTY
            using X1FULL = Field<1, 1>;    // X1FULL
            using OVFL = Field<8, 1>;    // OVFL
            using UNFL = Field<9, 1>;    // UNFL
            using SAT = Field<10, 1>;    // SAT
        };

        // FMAC Write Data register
        struct WDATA : public Register<0x40021418> {
            using Field = Field<0, 16>;    // WDATA
        };

        // FMAC Read Data register
        struct RDATA : public Register<0x4002141c> {
            using Field = Field<0, 16>;    // RDATA
        };

    };

    // CORDIC Co-processor
    struct CORDIC {
        // CORDIC Control Status register
        struct CSR : public Register<0x40020c00> {
            using FUNC = Field<0, 4>;    // FUNC
            using PRECISION = Field<4, 4>;    // PRECISION
            using SCALE = Field<8, 3>;    // SCALE
            using IEN = Field<16, 1>;    // IEN
            using DMAREN = Field<17, 1>;    // DMAREN
            using DMAWEN = Field<18, 1>;    // DMAWEN
            using NRES = Field<19, 1>;    // NRES
            using NARGS = Field<20, 1>;    // NARGS
            using RESSIZE = Field<21, 1>;    // RESSIZE
            using ARGSIZE = Field<22, 1>;    // ARGSIZE
            using RRDY = Field<31, 1>;    // RRDY
        };

        // FMAC Write Data register
        struct WDATA : public Register<0x40020c04> {
            using ARG = Field<0, 32>;    // ARG
        };

        // FMAC Read Data register
        struct RDATA : public Register<0x40020c08> {
            using RES = Field<0, 32>;    // RES
        };

    };

    // Serial audio interface
    struct SAI {
        // BConfiguration register 1
        struct BCR1 : public Register<0x40015424> {
            using MCKEN = Field<27, 1>;    // MCKEN
            using OSR = Field<26, 1>;    // OSR
            using MCJDIV = Field<20, 6>;    // Master clock divider
            using NODIV = Field<19, 1>;    // No divider
            using DMAEN = Field<17, 1>;    // DMA enable
            using SAIBEN = Field<16, 1>;    // Audio block B enable
            using OutDri = Field<13, 1>;    // Output drive
            using MONO = Field<12, 1>;    // Mono mode
            using SYNCEN = Field<10, 2>;    // Synchronization enable
            using CKSTR = Field<9, 1>;    // Clock strobing edge
            using LSBFIRST = Field<8, 1>;    // Least significant bit first
            using DS = Field<5, 3>;    // Data size
            using PRTCFG = Field<2, 2>;    // Protocol configuration
            using MODE = Field<0, 2>;    // Audio block mode
        };

        // BConfiguration register 2
        struct BCR2 : public Register<0x40015428> {
            using COMP = Field<14, 2>;    // Companding mode
            using CPL = Field<13, 1>;    // Complement bit
            using MUTECN = Field<7, 6>;    // Mute counter
            using MUTEVAL = Field<6, 1>;    // Mute value
            using MUTE = Field<5, 1>;    // Mute
            using TRIS = Field<4, 1>;    // Tristate management on data line
            using FFLUS = Field<3, 1>;    // FIFO flush
            using FTH = Field<0, 3>;    // FIFO threshold
        };

        // BFRCR
        struct BFRCR : public Register<0x4001542c> {
            using FSOFF = Field<18, 1>;    // Frame synchronization offset
            using FSPOL = Field<17, 1>;    // Frame synchronization polarity
            using FSDEF = Field<16, 1>;    // Frame synchronization definition
            using FSALL = Field<8, 7>;    // Frame synchronization active level length
            using FRL = Field<0, 8>;    // Frame length
        };

        // BSlot register
        struct BSLOTR : public Register<0x40015430> {
            using SLOTEN = Field<16, 16>;    // Slot enable
            using NBSLOT = Field<8, 4>;    // Number of slots in an audio frame
            using SLOTSZ = Field<6, 2>;    // Slot size
            using FBOFF = Field<0, 5>;    // First bit offset
        };

        // BInterrupt mask register2
        struct BIM : public Register<0x40015434> {
            using LFSDETIE = Field<6, 1>;    // Late frame synchronization detection interrupt enable
            using AFSDETIE = Field<5, 1>;    // Anticipated frame synchronization detection interrupt enable
            using CNRDYIE = Field<4, 1>;    // Codec not ready interrupt enable
            using FREQIE = Field<3, 1>;    // FIFO request interrupt enable
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration interrupt enable
            using MUTEDET = Field<1, 1>;    // Mute detection interrupt enable
            using OVRUDRIE = Field<0, 1>;    // Overrun/underrun interrupt enable
        };

        // BStatus register
        struct BSR : public Register<0x40015438> {
            using FLVL = Field<16, 3>;    // FIFO level threshold
            using LFSDET = Field<6, 1>;    // Late frame synchronization detection
            using AFSDET = Field<5, 1>;    // Anticipated frame synchronization detection
            using CNRDY = Field<4, 1>;    // Codec not ready
            using FREQ = Field<3, 1>;    // FIFO request
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration flag
            using MUTEDET = Field<1, 1>;    // Mute detection
            using OVRUDR = Field<0, 1>;    // Overrun / underrun
        };

        // BClear flag register
        struct BCLRFR : public Register<0x4001543c> {
            using LFSDET = Field<6, 1>;    // Clear late frame synchronization detection flag
            using CAFSDET = Field<5, 1>;    // Clear anticipated frame synchronization detection flag
            using CNRDY = Field<4, 1>;    // Clear codec not ready flag
            using WCKCFG = Field<2, 1>;    // Clear wrong clock configuration flag
            using MUTEDET = Field<1, 1>;    // Mute detection flag
            using OVRUDR = Field<0, 1>;    // Clear overrun / underrun
        };

        // BData register
        struct BDR : public Register<0x40015440> {
            using DATA = Field<0, 32>;    // Data
        };

        // AConfiguration register 1
        struct ACR1 : public Register<0x40015404> {
            using MCKEN = Field<27, 1>;    // MCKEN
            using OSR = Field<26, 1>;    // OSR
            using MCJDIV = Field<20, 6>;    // Master clock divider
            using NODIV = Field<19, 1>;    // No divider
            using DMAEN = Field<17, 1>;    // DMA enable
            using SAIAEN = Field<16, 1>;    // Audio block A enable
            using OutDri = Field<13, 1>;    // Output drive
            using MONO = Field<12, 1>;    // Mono mode
            using SYNCEN = Field<10, 2>;    // Synchronization enable
            using CKSTR = Field<9, 1>;    // Clock strobing edge
            using LSBFIRST = Field<8, 1>;    // Least significant bit first
            using DS = Field<5, 3>;    // Data size
            using PRTCFG = Field<2, 2>;    // Protocol configuration
            using MODE = Field<0, 2>;    // Audio block mode
        };

        // AConfiguration register 2
        struct ACR2 : public Register<0x40015408> {
            using COMP = Field<14, 2>;    // Companding mode
            using CPL = Field<13, 1>;    // Complement bit
            using MUTECN = Field<7, 6>;    // Mute counter
            using MUTEVAL = Field<6, 1>;    // Mute value
            using MUTE = Field<5, 1>;    // Mute
            using TRIS = Field<4, 1>;    // Tristate management on data line
            using FFLUS = Field<3, 1>;    // FIFO flush
            using FTH = Field<0, 3>;    // FIFO threshold
        };

        // AFRCR
        struct AFRCR : public Register<0x4001540c> {
            using FSOFF = Field<18, 1>;    // Frame synchronization offset
            using FSPOL = Field<17, 1>;    // Frame synchronization polarity
            using FSDEF = Field<16, 1>;    // Frame synchronization definition
            using FSALL = Field<8, 7>;    // Frame synchronization active level length
            using FRL = Field<0, 8>;    // Frame length
        };

        // ASlot register
        struct ASLOTR : public Register<0x40015410> {
            using SLOTEN = Field<16, 16>;    // Slot enable
            using NBSLOT = Field<8, 4>;    // Number of slots in an audio frame
            using SLOTSZ = Field<6, 2>;    // Slot size
            using FBOFF = Field<0, 5>;    // First bit offset
        };

        // AInterrupt mask register2
        struct AIM : public Register<0x40015414> {
            using LFSDET = Field<6, 1>;    // Late frame synchronization detection interrupt enable
            using AFSDETIE = Field<5, 1>;    // Anticipated frame synchronization detection interrupt enable
            using CNRDYIE = Field<4, 1>;    // Codec not ready interrupt enable
            using FREQIE = Field<3, 1>;    // FIFO request interrupt enable
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration interrupt enable
            using MUTEDET = Field<1, 1>;    // Mute detection interrupt enable
            using OVRUDRIE = Field<0, 1>;    // Overrun/underrun interrupt enable
        };

        // AStatus register
        struct ASR : public Register<0x40015418> {
            using FLVL = Field<16, 3>;    // FIFO level threshold
            using LFSDET = Field<6, 1>;    // Late frame synchronization detection
            using AFSDET = Field<5, 1>;    // Anticipated frame synchronization detection
            using CNRDY = Field<4, 1>;    // Codec not ready
            using FREQ = Field<3, 1>;    // FIFO request
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration flag. This bit is read only
            using MUTEDET = Field<1, 1>;    // Mute detection
            using OVRUDR = Field<0, 1>;    // Overrun / underrun
        };

        // AClear flag register
        struct ACLRFR : public Register<0x4001541c> {
            using LFSDET = Field<6, 1>;    // Clear late frame synchronization detection flag
            using CAFSDET = Field<5, 1>;    // Clear anticipated frame synchronization detection flag
            using CNRDY = Field<4, 1>;    // Clear codec not ready flag
            using WCKCFG = Field<2, 1>;    // Clear wrong clock configuration flag
            using MUTEDET = Field<1, 1>;    // Mute detection flag
            using OVRUDR = Field<0, 1>;    // Clear overrun / underrun
        };

        // AData register
        struct ADR : public Register<0x40015420> {
            using DATA = Field<0, 32>;    // Data
        };

        // PDM control register
        struct PDMCR : public Register<0x40015444> {
            using PDMEN = Field<0, 1>;    // PDMEN
            using MICNBR = Field<4, 2>;    // MICNBR
            using CKEN1 = Field<8, 1>;    // CKEN1
            using CKEN2 = Field<9, 1>;    // CKEN2
            using CKEN3 = Field<10, 1>;    // CKEN3
            using CKEN4 = Field<11, 1>;    // CKEN4
        };

        // PDM delay register
        struct PDMDLY : public Register<0x40015448> {
            using DLYM1L = Field<0, 3>;    // DLYM1L
            using DLYM1R = Field<4, 3>;    // DLYM1R
            using DLYM2L = Field<8, 3>;    // DLYM2L
            using DLYM2R = Field<12, 3>;    // DLYM2R
            using DLYM3L = Field<16, 3>;    // DLYM3L
            using DLYM3R = Field<20, 3>;    // DLYM3R
            using DLYM4L = Field<24, 3>;    // DLYM4L
            using DLYM4R = Field<28, 3>;    // DLYM4R
        };

    };

    // Tamper and backup registers
    struct TAMP {
        // control register 1
        struct CR1 : public Register<0x40002400> {
            using TAMP1E = Field<0, 1>;    // TAMP1E
            using TAMP2E = Field<1, 1>;    // TAMP2E
            using TAMP3E = Field<2, 1>;    // TAMP2E
            using ITAMP3E = Field<18, 1>;    // ITAMP3E
            using ITAMP4E = Field<19, 1>;    // ITAMP4E
            using ITAMP5E = Field<20, 1>;    // ITAMP5E
            using ITAMP6E = Field<21, 1>;    // ITAMP6E
        };

        // control register 2
        struct CR2 : public Register<0x40002404> {
            using TAMP1NOER = Field<0, 1>;    // TAMP1NOER
            using TAMP2NOER = Field<1, 1>;    // TAMP2NOER
            using TAMP3NOER = Field<2, 1>;    // TAMP3NOER
            using TAMP1MSK = Field<16, 1>;    // TAMP1MSK
            using TAMP2MSK = Field<17, 1>;    // TAMP2MSK
            using TAMP3MSK = Field<18, 1>;    // TAMP3MSK
            using TAMP1TRG = Field<24, 1>;    // TAMP1TRG
            using TAMP2TRG = Field<25, 1>;    // TAMP2TRG
            using TAMP3TRG = Field<26, 1>;    // TAMP3TRG
        };

        // TAMP filter control register
        struct FLTCR : public Register<0x4000240c> {
            using TAMPFREQ = Field<0, 3>;    // TAMPFREQ
            using TAMPFLT = Field<3, 2>;    // TAMPFLT
            using TAMPPRCH = Field<5, 2>;    // TAMPPRCH
            using TAMPPUDIS = Field<7, 1>;    // TAMPPUDIS
        };

        // TAMP interrupt enable register
        struct IER : public Register<0x4000242c> {
            using TAMP1IE = Field<0, 1>;    // TAMP1IE
            using TAMP2IE = Field<1, 1>;    // TAMP2IE
            using TAMP3IE = Field<2, 1>;    // TAMP3IE
            using ITAMP3IE = Field<18, 1>;    // ITAMP3IE
            using ITAMP4IE = Field<19, 1>;    // ITAMP4IE
            using ITAMP5IE = Field<20, 1>;    // ITAMP5IE
            using ITAMP6IE = Field<21, 1>;    // ITAMP6IE
        };

        // TAMP status register
        struct SR : public Register<0x40002430> {
            using TAMP1F = Field<0, 1>;    // TAMP1F
            using TAMP2F = Field<1, 1>;    // TAMP2F
            using TAMP3F = Field<2, 1>;    // TAMP3F
            using ITAMP3F = Field<18, 1>;    // ITAMP3F
            using ITAMP4F = Field<19, 1>;    // ITAMP4F
            using ITAMP5F = Field<20, 1>;    // ITAMP5F
            using ITAMP6F = Field<21, 1>;    // ITAMP6F
        };

        // TAMP masked interrupt status register
        struct MISR : public Register<0x40002434> {
            using TAMP1MF = Field<0, 1>;    // TAMP1MF:
            using TAMP2MF = Field<1, 1>;    // TAMP2MF
            using TAMP3MF = Field<2, 1>;    // TAMP3MF
            using ITAMP3MF = Field<18, 1>;    // ITAMP3MF
            using ITAMP4MF = Field<19, 1>;    // ITAMP4MF
            using ITAMP5MF = Field<20, 1>;    // ITAMP5MF
            using ITAMP6MF = Field<21, 1>;    // ITAMP6MF
        };

        // TAMP status clear register
        struct SCR : public Register<0x4000243c> {
            using CTAMP1F = Field<0, 1>;    // CTAMP1F
            using CTAMP2F = Field<1, 1>;    // CTAMP2F
            using CTAMP3F = Field<2, 1>;    // CTAMP3F
            using CITAMP3F = Field<18, 1>;    // CITAMP3F
            using CITAMP4F = Field<19, 1>;    // CITAMP4F
            using CITAMP5F = Field<20, 1>;    // CITAMP5F
            using CITAMP6F = Field<21, 1>;    // CITAMP6F
        };

        // TAMP backup register
        struct BKP0R : public Register<0x40002500> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP1R : public Register<0x40002504> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP2R : public Register<0x40002508> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP3R : public Register<0x4000250c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP4R : public Register<0x40002510> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP5R : public Register<0x40002514> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP6R : public Register<0x40002518> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP7R : public Register<0x4000251c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP8R : public Register<0x40002520> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP9R : public Register<0x40002524> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP10R : public Register<0x40002528> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP11R : public Register<0x4000252c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP12R : public Register<0x40002530> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP13R : public Register<0x40002534> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP14R : public Register<0x40002538> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP15R : public Register<0x4000253c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP16R : public Register<0x40002540> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP17R : public Register<0x40002544> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP18R : public Register<0x40002548> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP19R : public Register<0x4000254c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP20R : public Register<0x40002550> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP21R : public Register<0x40002554> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP22R : public Register<0x40002558> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP23R : public Register<0x4000255c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP24R : public Register<0x40002560> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP25R : public Register<0x40002564> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP26R : public Register<0x40002568> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP27R : public Register<0x4000256c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP28R : public Register<0x40002570> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP29R : public Register<0x40002574> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP30R : public Register<0x40002578> {
            using BKP = Field<0, 32>;    // BKP
        };

        // TAMP backup register
        struct BKP31R : public Register<0x4000257c> {
            using BKP = Field<0, 32>;    // BKP
        };

    };

    // Floting point unit
    struct FPU {
        // Floating-point context control register
        struct FPCCR : public Register<0xe000ef34> {
            using LSPACT = Field<0, 1>;    // LSPACT
            using USER = Field<1, 1>;    // USER
            using THREAD = Field<3, 1>;    // THREAD
            using HFRDY = Field<4, 1>;    // HFRDY
            using MMRDY = Field<5, 1>;    // MMRDY
            using BFRDY = Field<6, 1>;    // BFRDY
            using MONRDY = Field<8, 1>;    // MONRDY
            using LSPEN = Field<30, 1>;    // LSPEN
            using ASPEN = Field<31, 1>;    // ASPEN
        };

        // Floating-point context address register
        struct FPCAR : public Register<0xe000ef38> {
            using ADDRESS = Field<3, 29>;    // Location of unpopulated floating-point
        };

        // Floating-point status control register
        struct FPSCR : public Register<0xe000ef3c> {
            using IOC = Field<0, 1>;    // Invalid operation cumulative exception bit
            using DZC = Field<1, 1>;    // Division by zero cumulative exception bit.
            using OFC = Field<2, 1>;    // Overflow cumulative exception bit
            using UFC = Field<3, 1>;    // Underflow cumulative exception bit
            using IXC = Field<4, 1>;    // Inexact cumulative exception bit
            using IDC = Field<7, 1>;    // Input denormal cumulative exception bit.
            using RMode = Field<22, 2>;    // Rounding Mode control field
            using FZ = Field<24, 1>;    // Flush-to-zero mode control bit:
            using DN = Field<25, 1>;    // Default NaN mode control bit
            using AHP = Field<26, 1>;    // Alternative half-precision control bit
            using V = Field<28, 1>;    // Overflow condition code flag
            using C = Field<29, 1>;    // Carry condition code flag
            using Z = Field<30, 1>;    // Zero condition code flag
            using N = Field<31, 1>;    // Negative condition code flag
        };

    };

    // Memory protection unit
    struct MPU {
        // MPU type register
        struct TYPER : public Register<0xe000e084> {
            using SEPARATE = Field<0, 1>;    // Separate flag
            using DREGION = Field<8, 8>;    // Number of MPU data regions
            using IREGION = Field<16, 8>;    // Number of MPU instruction regions
        };

        // MPU control register
        struct CTRL : public Register<0xe000e088> {
            using ENABLE = Field<0, 1>;    // Enables the MPU
            using HFNMIENA = Field<1, 1>;    // Enables the operation of MPU during hard fault
            using PRIVDEFENA = Field<2, 1>;    // Enable priviliged software access to default memory map
        };

        // MPU region number register
        struct RNR : public Register<0xe000e08c> {
            using REGION = Field<0, 8>;    // MPU region
        };

        // MPU region base address register
        struct RBAR : public Register<0xe000e090> {
            using REGION = Field<0, 4>;    // MPU region field
            using VALID = Field<4, 1>;    // MPU region number valid
            using ADDR = Field<5, 27>;    // Region base address field
        };

        // MPU region attribute and size register
        struct RASR : public Register<0xe000e094> {
            using ENABLE = Field<0, 1>;    // Region enable bit.
            using SIZE = Field<1, 5>;    // Size of the MPU protection region
            using SRD = Field<8, 8>;    // Subregion disable bits
            using B = Field<16, 1>;    // memory attribute
            using C = Field<17, 1>;    // memory attribute
            using S = Field<18, 1>;    // Shareable memory attribute
            using TEX = Field<19, 3>;    // memory attribute
            using AP = Field<24, 3>;    // Access permission
            using XN = Field<28, 1>;    // Instruction access disable bit
        };

    };

    // SysTick timer
    struct STK {
        // SysTick control and status register
        struct CTRL : public Register<0xe000e010> {
            using ENABLE = Field<0, 1>;    // Counter enable
            using TICKINT = Field<1, 1>;    // SysTick exception request enable
            using CLKSOURCE = Field<2, 1>;    // Clock source selection
            using COUNTFLAG = Field<16, 1>;    // COUNTFLAG
        };

        // SysTick reload value register
        struct LOAD : public Register<0xe000e014> {
            using RELOAD = Field<0, 24>;    // RELOAD value
        };

        // SysTick current value register
        struct VAL : public Register<0xe000e018> {
            using CURRENT = Field<0, 24>;    // Current counter value
        };

        // SysTick calibration value register
        struct CALIB : public Register<0xe000e01c> {
            using TENMS = Field<0, 24>;    // Calibration value
            using SKEW = Field<30, 1>;    // SKEW flag: Indicates whether the TENMS value is exact
            using NOREF = Field<31, 1>;    // NOREF flag. Reads as zero
        };

    };

    // System control block
    struct SCB {
        // CPUID base register
        struct CPUID : public Register<0xe000e040> {
            using Revision = Field<0, 4>;    // Revision number
            using PartNo = Field<4, 12>;    // Part number of the processor
            using Constant = Field<16, 4>;    // Reads as 0xF
            using Variant = Field<20, 4>;    // Variant number
            using Implementer = Field<24, 8>;    // Implementer code
        };

        // Interrupt control and state register
        struct ICSR : public Register<0xe000e044> {
            using VECTACTIVE = Field<0, 9>;    // Active vector
            using RETTOBASE = Field<11, 1>;    // Return to base level
            using VECTPENDING = Field<12, 7>;    // Pending vector
            using ISRPENDING = Field<22, 1>;    // Interrupt pending flag
            using PENDSTCLR = Field<25, 1>;    // SysTick exception clear-pending bit
            using PENDSTSET = Field<26, 1>;    // SysTick exception set-pending bit
            using PENDSVCLR = Field<27, 1>;    // PendSV clear-pending bit
            using PENDSVSET = Field<28, 1>;    // PendSV set-pending bit
            using NMIPENDSET = Field<31, 1>;    // NMI set-pending bit.
        };

        // Vector table offset register
        struct VTOR : public Register<0xe000e048> {
            using TBLOFF = Field<9, 21>;    // Vector table base offset field
        };

        // Application interrupt and reset control register
        struct AIRCR : public Register<0xe000e04c> {
            using VECTRESET = Field<0, 1>;    // VECTRESET
            using VECTCLRACTIVE = Field<1, 1>;    // VECTCLRACTIVE
            using SYSRESETREQ = Field<2, 1>;    // SYSRESETREQ
            using PRIGROUP = Field<8, 3>;    // PRIGROUP
            using ENDIANESS = Field<15, 1>;    // ENDIANESS
            using VECTKEYSTAT = Field<16, 16>;    // Register key
        };

        // System control register
        struct SCR : public Register<0xe000e050> {
            using SLEEPONEXIT = Field<1, 1>;    // SLEEPONEXIT
            using SLEEPDEEP = Field<2, 1>;    // SLEEPDEEP
            using SEVEONPEND = Field<4, 1>;    // Send Event on Pending bit
        };

        // Configuration and control register
        struct CCR : public Register<0xe000e054> {
            using NONBASETHRDENA = Field<0, 1>;    // Configures how the processor enters Thread mode
            using USERSETMPEND = Field<1, 1>;    // USERSETMPEND
            using UNALIGN__TRP = Field<3, 1>;    // UNALIGN_ TRP
            using DIV_0_TRP = Field<4, 1>;    // DIV_0_TRP
            using BFHFNMIGN = Field<8, 1>;    // BFHFNMIGN
            using STKALIGN = Field<9, 1>;    // STKALIGN
        };

        // System handler priority registers
        struct SHPR1 : public Register<0xe000e058> {
            using PRI_4 = Field<0, 8>;    // Priority of system handler 4
            using PRI_5 = Field<8, 8>;    // Priority of system handler 5
            using PRI_6 = Field<16, 8>;    // Priority of system handler 6
        };

        // System handler priority registers
        struct SHPR2 : public Register<0xe000e05c> {
            using PRI_11 = Field<24, 8>;    // Priority of system handler 11
        };

        // System handler priority registers
        struct SHPR3 : public Register<0xe000e060> {
            using PRI_14 = Field<16, 8>;    // Priority of system handler 14
            using PRI_15 = Field<24, 8>;    // Priority of system handler 15
        };

        // System handler control and state register
        struct SHCRS : public Register<0xe000e064> {
            using MEMFAULTACT = Field<0, 1>;    // Memory management fault exception active bit
            using BUSFAULTACT = Field<1, 1>;    // Bus fault exception active bit
            using USGFAULTACT = Field<3, 1>;    // Usage fault exception active bit
            using SVCALLACT = Field<7, 1>;    // SVC call active bit
            using MONITORACT = Field<8, 1>;    // Debug monitor active bit
            using PENDSVACT = Field<10, 1>;    // PendSV exception active bit
            using SYSTICKACT = Field<11, 1>;    // SysTick exception active bit
            using USGFAULTPENDED = Field<12, 1>;    // Usage fault exception pending bit
            using MEMFAULTPENDED = Field<13, 1>;    // Memory management fault exception pending bit
            using BUSFAULTPENDED = Field<14, 1>;    // Bus fault exception pending bit
            using SVCALLPENDED = Field<15, 1>;    // SVC call pending bit
            using MEMFAULTENA = Field<16, 1>;    // Memory management fault enable bit
            using BUSFAULTENA = Field<17, 1>;    // Bus fault enable bit
            using USGFAULTENA = Field<18, 1>;    // Usage fault enable bit
        };

        // Configurable fault status register
        struct CFSR_UFSR_BFSR_MMFSR : public Register<0xe000e068> {
            using IACCVIOL = Field<1, 1>;    // Instruction access violation flag
            using MUNSTKERR = Field<3, 1>;    // Memory manager fault on unstacking for a return from exception
            using MSTKERR = Field<4, 1>;    // Memory manager fault on stacking for exception entry.
            using MLSPERR = Field<5, 1>;    // MLSPERR
            using MMARVALID = Field<7, 1>;    // Memory Management Fault Address Register (MMAR) valid flag
            using IBUSERR = Field<8, 1>;    // Instruction bus error
            using PRECISERR = Field<9, 1>;    // Precise data bus error
            using IMPRECISERR = Field<10, 1>;    // Imprecise data bus error
            using UNSTKERR = Field<11, 1>;    // Bus fault on unstacking for a return from exception
            using STKERR = Field<12, 1>;    // Bus fault on stacking for exception entry
            using LSPERR = Field<13, 1>;    // Bus fault on floating-point lazy state preservation
            using BFARVALID = Field<15, 1>;    // Bus Fault Address Register (BFAR) valid flag
            using UNDEFINSTR = Field<16, 1>;    // Undefined instruction usage fault
            using INVSTATE = Field<17, 1>;    // Invalid state usage fault
            using INVPC = Field<18, 1>;    // Invalid PC load usage fault
            using NOCP = Field<19, 1>;    // No coprocessor usage fault.
            using UNALIGNED = Field<24, 1>;    // Unaligned access usage fault
            using DIVBYZERO = Field<25, 1>;    // Divide by zero usage fault
        };

        // Hard fault status register
        struct HFSR : public Register<0xe000e06c> {
            using VECTTBL = Field<1, 1>;    // Vector table hard fault
            using FORCED = Field<30, 1>;    // Forced hard fault
            using DEBUG_VT = Field<31, 1>;    // Reserved for Debug use
        };

        // Memory management fault address register
        struct MMFAR : public Register<0xe000e074> {
            using Field = Field<0, 32>;    // Memory management fault address
        };

        // Bus fault address register
        struct BFAR : public Register<0xe000e078> {
            using Field = Field<0, 32>;    // Bus fault address
        };

        // Auxiliary fault status register
        struct AFSR : public Register<0xe000e07c> {
            using IMPDEF = Field<0, 32>;    // Implementation defined
        };

    };

    // Nested Vectored Interrupt Controller
    struct NVIC {
        // Interrupt Set-Enable Register
        struct ISER0 : public Register<0xe000e100> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Set-Enable Register
        struct ISER1 : public Register<0xe000e104> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Set-Enable Register
        struct ISER2 : public Register<0xe000e108> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Set-Enable Register
        struct ISER3 : public Register<0xe000e10c> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Clear-Enable Register
        struct ICER0 : public Register<0xe000e180> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Clear-Enable Register
        struct ICER1 : public Register<0xe000e184> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Clear-Enable Register
        struct ICER2 : public Register<0xe000e188> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Clear-Enable Register
        struct ICER3 : public Register<0xe000e18c> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Set-Pending Register
        struct ISPR0 : public Register<0xe000e200> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Set-Pending Register
        struct ISPR1 : public Register<0xe000e204> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Set-Pending Register
        struct ISPR2 : public Register<0xe000e208> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Set-Pending Register
        struct ISPR3 : public Register<0xe000e20c> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR0 : public Register<0xe000e280> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR1 : public Register<0xe000e284> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR2 : public Register<0xe000e288> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR3 : public Register<0xe000e28c> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Active Bit Register
        struct IABR0 : public Register<0xe000e300> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Active Bit Register
        struct IABR1 : public Register<0xe000e304> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Active Bit Register
        struct IABR2 : public Register<0xe000e308> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Active Bit Register
        struct IABR3 : public Register<0xe000e30c> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Priority Register
        struct IPR0 : public Register<0xe000e400> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR1 : public Register<0xe000e404> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR2 : public Register<0xe000e408> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR3 : public Register<0xe000e40c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR4 : public Register<0xe000e410> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR5 : public Register<0xe000e414> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR6 : public Register<0xe000e418> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR7 : public Register<0xe000e41c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR8 : public Register<0xe000e420> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR9 : public Register<0xe000e424> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR10 : public Register<0xe000e428> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR11 : public Register<0xe000e42c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR12 : public Register<0xe000e430> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR13 : public Register<0xe000e434> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR14 : public Register<0xe000e438> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR15 : public Register<0xe000e43c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR16 : public Register<0xe000e440> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR17 : public Register<0xe000e444> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR18 : public Register<0xe000e448> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR19 : public Register<0xe000e44c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR20 : public Register<0xe000e450> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR21 : public Register<0xe000e454> {
        };

        // Interrupt Priority Register
        struct IPR22 : public Register<0xe000e458> {
        };

        // Interrupt Priority Register
        struct IPR23 : public Register<0xe000e45c> {
        };

        // Interrupt Priority Register
        struct IPR24 : public Register<0xe000e460> {
        };

        // Interrupt Priority Register
        struct IPR25 : public Register<0xe000e464> {
        };

        // Software trigger interrupt register
        struct STIR : public Register<0xe000ef00> {
            using INTID = Field<0, 9>;    // Software generated interrupt ID
        };

    };

    // Floating point unit CPACR
    struct FPU_CPACR {
        // Coprocessor access control register
        struct CPACR : public Register<0xe000ef08> {
            using CP = Field<20, 4>;    // CP
        };

    };

    // System control block ACTLR
    struct SCB_ACTRL {
        // Auxiliary control register
        struct ACTRL : public Register<0xe000e008> {
            using DISMCYCINT = Field<0, 1>;    // DISMCYCINT
            using DISDEFWBUF = Field<1, 1>;    // DISDEFWBUF
            using DISFOLD = Field<2, 1>;    // DISFOLD
            using DISFPCA = Field<8, 1>;    // DISFPCA
            using DISOOFP = Field<9, 1>;    // DISOOFP
        };

    };

    // FDCAN
    struct FDCAN {
        // FDCAN Core Release Register
        struct CREL : public Register<0x4000a400> {
            using DAY = Field<0, 8>;    // DAY
            using MON = Field<8, 8>;    // MON
            using YEAR = Field<16, 4>;    // YEAR
            using SUBSTEP = Field<20, 4>;    // SUBSTEP
            using STEP = Field<24, 4>;    // STEP
            using REL = Field<28, 4>;    // REL
        };

        // FDCAN Core Release Register
        struct ENDN : public Register<0x4000a404> {
            using ETV = Field<0, 32>;    // ETV
        };

        // This register is only writable if bits CCCR.CCE and CCCR.INIT are set. The CAN bit time may be programed in the range of 4 to 25 time quanta. The CAN time quantum may be programmed in the range of 1 to 1024 FDCAN clock periods. tq = (DBRP + 1) FDCAN clock period. DTSEG1 is the sum of Prop_Seg and Phase_Seg1. DTSEG2 is Phase_Seg2. Therefore the length of the bit time is (programmed values) [DTSEG1 + DTSEG2 + 3] tq or (functional values) [Sync_Seg + Prop_Seg + Phase_Seg1 + Phase_Seg2] tq. The Information Processing Time (IPT) is zero, meaning the data for the next bit is available at the first clock edge after the sample point.
        struct DBTP : public Register<0x4000a40c> {
            using DSJW = Field<0, 4>;    // DSJW
            using DTSEG2 = Field<4, 4>;    // DTSEG2
            using DTSEG1 = Field<8, 5>;    // DTSEG1
            using DBRP = Field<16, 5>;    // DBRP
            using TDC = Field<23, 1>;    // TDC
        };

        // Write access to the Test Register has to be enabled by setting bit CCCR[TEST] to 1 . All Test Register functions are set to their reset values when bit CCCR[TEST] is reset. Loop Back mode and software control of Tx pin FDCANx_TX are hardware test modes. Programming TX differently from 00 may disturb the message transfer on the CAN bus.
        struct TEST : public Register<0x4000a410> {
            using LBCK = Field<4, 1>;    // LBCK
            using TX = Field<5, 2>;    // TX
            using RX = Field<7, 1>;    // RX
        };

        // The RAM Watchdog monitors the READY output of the Message RAM. A Message RAM access starts the Message RAM Watchdog Counter with the value configured by the RWD[WDC] bits. The counter is reloaded with RWD[WDC] bits when the Message RAM signals successful completion by activating its READY output. In case there is no response from the Message RAM until the counter has counted down to 0, the counter stops and interrupt flag IR[WDI] bit is set. The RAM Watchdog Counter is clocked by the fdcan_pclk clock.
        struct RWD : public Register<0x4000a414> {
            using WDC = Field<0, 8>;    // WDC
            using WDV = Field<8, 8>;    // WDV
        };

        // For details about setting and resetting of single bits see Software initialization.
        struct CCCR : public Register<0x4000a418> {
            using INIT = Field<0, 1>;    // INIT
            using CCE = Field<1, 1>;    // CCE
            using ASM = Field<2, 1>;    // ASM
            using CSA = Field<3, 1>;    // CSA
            using CSR = Field<4, 1>;    // CSR
            using MON = Field<5, 1>;    // MON
            using DAR = Field<6, 1>;    // DAR
            using TEST = Field<7, 1>;    // TEST
            using FDOE = Field<8, 1>;    // FDOE
            using BRSE = Field<9, 1>;    // BRSE
            using PXHD = Field<12, 1>;    // PXHD
            using EFBI = Field<13, 1>;    // EFBI
            using TXP = Field<14, 1>;    // TXP
            using NISO = Field<15, 1>;    // NISO
        };

        // FDCAN_NBTP
        struct NBTP : public Register<0x4000a41c> {
            using TSEG2 = Field<0, 7>;    // TSEG2
            using NTSEG1 = Field<8, 8>;    // NTSEG1
            using NBRP = Field<16, 9>;    // NBRP
            using NSJW = Field<25, 7>;    // NSJW
        };

        // FDCAN Timestamp Counter Configuration Register
        struct TSCC : public Register<0x4000a420> {
            using TSS = Field<0, 2>;    // TSS
            using TCP = Field<16, 4>;    // TCP
        };

        // FDCAN Timestamp Counter Value Register
        struct TSCV : public Register<0x4000a424> {
            using TSC = Field<0, 16>;    // TSC
        };

        // FDCAN Timeout Counter Configuration Register
        struct TOCC : public Register<0x4000a428> {
            using ETOC = Field<0, 1>;    // ETOC
            using TOS = Field<1, 2>;    // TOS
            using TOP = Field<16, 16>;    // TOP
        };

        // FDCAN Timeout Counter Value Register
        struct TOCV : public Register<0x4000a42c> {
            using TOC = Field<0, 16>;    // TOC
        };

        // FDCAN Error Counter Register
        struct ECR : public Register<0x4000a440> {
            using TEC = Field<0, 8>;    // TEC
            using TREC = Field<8, 7>;    // TREC
            using RP = Field<15, 1>;    // RP
            using CEL = Field<16, 8>;    // CEL
        };

        // FDCAN Protocol Status Register
        struct PSR : public Register<0x4000a444> {
            using LEC = Field<0, 3>;    // LEC
            using ACT = Field<3, 2>;    // ACT
            using EP = Field<5, 1>;    // EP
            using EW = Field<6, 1>;    // EW
            using BO = Field<7, 1>;    // BO
            using DLEC = Field<8, 3>;    // DLEC
            using RESI = Field<11, 1>;    // RESI
            using RBRS = Field<12, 1>;    // RBRS
            using REDL = Field<13, 1>;    // REDL
            using PXE = Field<14, 1>;    // PXE
            using TDCV = Field<16, 7>;    // TDCV
        };

        // FDCAN Transmitter Delay Compensation Register
        struct TDCR : public Register<0x4000a448> {
            using TDCF = Field<0, 7>;    // TDCF
            using TDCO = Field<8, 7>;    // TDCO
        };

        // The flags are set when one of the listed conditions is detected (edge-sensitive). The flags remain set until the Host clears them. A flag is cleared by writing a 1 to the corresponding bit position. Writing a 0 has no effect. A hard reset will clear the register. The configuration of IE controls whether an interrupt is generated. The configuration of ILS controls on which interrupt line an interrupt is signaled.
        struct IR : public Register<0x4000a450> {
            using RF0N = Field<0, 1>;    // RF0N
            using RF0W = Field<1, 1>;    // RF0W
            using RF0F = Field<2, 1>;    // RF0F
            using RF0L = Field<3, 1>;    // RF0L
            using RF1N = Field<4, 1>;    // RF1N
            using RF1W = Field<5, 1>;    // RF1W
            using RF1F = Field<6, 1>;    // RF1F
            using RF1L = Field<7, 1>;    // RF1L
            using HPM = Field<8, 1>;    // HPM
            using TC = Field<9, 1>;    // TC
            using TCF = Field<10, 1>;    // TCF
            using TFE = Field<11, 1>;    // TFE
            using TEFN = Field<12, 1>;    // TEFN
            using TEFW = Field<13, 1>;    // TEFW
            using TEFF = Field<14, 1>;    // TEFF
            using TEFL = Field<15, 1>;    // TEFL
            using TSW = Field<16, 1>;    // TSW
            using MRAF = Field<17, 1>;    // MRAF
            using TOO = Field<18, 1>;    // TOO
            using DRX = Field<19, 1>;    // DRX
            using ELO = Field<22, 1>;    // ELO
            using EP = Field<23, 1>;    // EP
            using EW = Field<24, 1>;    // EW
            using BO = Field<25, 1>;    // BO
            using WDI = Field<26, 1>;    // WDI
            using PEA = Field<27, 1>;    // PEA
            using PED = Field<28, 1>;    // PED
            using ARA = Field<29, 1>;    // ARA
        };

        // The settings in the Interrupt Enable register determine which status changes in the Interrupt Register will be signaled on an interrupt line.
        struct IE : public Register<0x4000a454> {
            using RF0NE = Field<0, 1>;    // RF0NE
            using RF0WE = Field<1, 1>;    // RF0WE
            using RF0FE = Field<2, 1>;    // RF0FE
            using RF0LE = Field<3, 1>;    // RF0LE
            using RF1NE = Field<4, 1>;    // RF1NE
            using RF1WE = Field<5, 1>;    // RF1WE
            using RF1FE = Field<6, 1>;    // RF1FE
            using RF1LE = Field<7, 1>;    // RF1LE
            using HPME = Field<8, 1>;    // HPME
            using TCE = Field<9, 1>;    // TCE
            using TCFE = Field<10, 1>;    // TCFE
            using TFEE = Field<11, 1>;    // TFEE
            using TEFNE = Field<12, 1>;    // TEFNE
            using TEFWE = Field<13, 1>;    // TEFWE
            using TEFFE = Field<14, 1>;    // TEFFE
            using TEFLE = Field<15, 1>;    // TEFLE
            using TSWE = Field<16, 1>;    // TSWE
            using MRAFE = Field<17, 1>;    // MRAFE
            using TOOE = Field<18, 1>;    // TOOE
            using DRX = Field<19, 1>;    // DRX
            using BECE = Field<20, 1>;    // BECE
            using BEUE = Field<21, 1>;    // BEUE
            using ELOE = Field<22, 1>;    // ELOE
            using EPE = Field<23, 1>;    // EPE
            using EWE = Field<24, 1>;    // EWE
            using BOE = Field<25, 1>;    // BOE
            using WDIE = Field<26, 1>;    // WDIE
            using PEAE = Field<27, 1>;    // PEAE
            using PEDE = Field<28, 1>;    // PEDE
            using ARAE = Field<29, 1>;    // ARAE
        };

        // The Interrupt Line Select register assigns an interrupt generated by a specific interrupt flag from the Interrupt Register to one of the two module interrupt lines. For interrupt generation the respective interrupt line has to be enabled via ILE[EINT0] and ILE[EINT1].
        struct ILS : public Register<0x4000a458> {
            using RF0NL = Field<0, 1>;    // RF0NL
            using RF0WL = Field<1, 1>;    // RF0WL
            using RF0FL = Field<2, 1>;    // RF0FL
            using RF0LL = Field<3, 1>;    // RF0LL
            using RF1NL = Field<4, 1>;    // RF1NL
            using RF1WL = Field<5, 1>;    // RF1WL
            using RF1FL = Field<6, 1>;    // RF1FL
            using RF1LL = Field<7, 1>;    // RF1LL
            using HPML = Field<8, 1>;    // HPML
            using TCL = Field<9, 1>;    // TCL
            using TCFL = Field<10, 1>;    // TCFL
            using TFEL = Field<11, 1>;    // TFEL
            using TEFNL = Field<12, 1>;    // TEFNL
            using TEFWL = Field<13, 1>;    // TEFWL
            using TEFFL = Field<14, 1>;    // TEFFL
            using TEFLL = Field<15, 1>;    // TEFLL
            using TSWL = Field<16, 1>;    // TSWL
            using MRAFL = Field<17, 1>;    // MRAFL
            using TOOL = Field<18, 1>;    // TOOL
            using DRXL = Field<19, 1>;    // DRXL
            using BECL = Field<20, 1>;    // BECL
            using BEUL = Field<21, 1>;    // BEUL
            using ELOL = Field<22, 1>;    // ELOL
            using EPL = Field<23, 1>;    // EPL
            using EWL = Field<24, 1>;    // EWL
            using BOL = Field<25, 1>;    // BOL
            using WDIL = Field<26, 1>;    // WDIL
            using PEAL = Field<27, 1>;    // PEAL
            using PEDL = Field<28, 1>;    // PEDL
            using ARAL = Field<29, 1>;    // ARAL
        };

        // Each of the two interrupt lines to the CPU can be enabled/disabled separately by programming bits EINT0 and EINT1.
        struct ILE : public Register<0x4000a45c> {
            using EINT0 = Field<0, 1>;    // EINT0
            using EINT1 = Field<1, 1>;    // EINT1
        };

        // Global settings for Message ID filtering. The Global Filter Configuration controls the filter path for standard and extended messages as described in Figure706: Standard Message ID filter path and Figure707: Extended Message ID filter path.
        struct RXGFC : public Register<0x4000a480> {
            using RRFE = Field<0, 1>;    // RRFE
            using RRFS = Field<1, 1>;    // RRFS
            using ANFE = Field<2, 2>;    // ANFE
            using ANFS = Field<4, 2>;    // ANFS
        };

        // FDCAN Extended ID and Mask Register
        struct XIDAM : public Register<0x4000a484> {
            using EIDM = Field<0, 29>;    // EIDM
        };

        // This register is updated every time a Message ID filter element configured to generate a priority event match. This can be used to monitor the status of incoming high priority messages and to enable fast access to these messages.
        struct HPMS : public Register<0x4000a488> {
            using BIDX = Field<0, 6>;    // BIDX
            using MSI = Field<6, 2>;    // MSI
            using FIDX = Field<8, 7>;    // FIDX
            using FLST = Field<15, 1>;    // FLST
        };

        // FDCAN Rx FIFO 0 Status Register
        struct RXF0S : public Register<0x4000a490> {
            using F0FL = Field<0, 7>;    // F0FL
            using F0GI = Field<8, 6>;    // F0GI
            using F0PI = Field<16, 6>;    // F0PI
            using F0F = Field<24, 1>;    // F0F
            using RF0L = Field<25, 1>;    // RF0L
        };

        // CAN Rx FIFO 0 Acknowledge Register
        struct RXF0A : public Register<0x4000a494> {
            using F0AI = Field<0, 6>;    // F0AI
        };

        // FDCAN Rx FIFO 1 Status Register
        struct RXF1S : public Register<0x4000a498> {
            using F1FL = Field<0, 7>;    // F1FL
            using F1GI = Field<8, 6>;    // F1GI
            using F1PI = Field<16, 6>;    // F1PI
            using F1F = Field<24, 1>;    // F1F
            using RF1L = Field<25, 1>;    // RF1L
            using DMS = Field<30, 2>;    // DMS
        };

        // FDCAN Rx FIFO 1 Acknowledge Register
        struct RXF1A : public Register<0x4000a49c> {
            using F1AI = Field<0, 6>;    // F1AI
        };

        // FDCAN Tx Buffer Configuration Register
        struct TXBC : public Register<0x4000a4c0> {
            using TBSA = Field<2, 14>;    // TBSA
            using NDTB = Field<16, 6>;    // NDTB
            using TFQS = Field<24, 6>;    // TFQS
            using TFQM = Field<30, 1>;    // TFQM
        };

        // The Tx FIFO/Queue status is related to the pending Tx requests listed in register TXBRP. Therefore the effect of Add/Cancellation requests may be delayed due to a running Tx scan (TXBRP not yet updated).
        struct TXFQS : public Register<0x4000a4c4> {
            using TFFL = Field<0, 6>;    // TFFL
            using TFGI = Field<8, 5>;    // TFGI
            using TFQPI = Field<16, 5>;    // TFQPI
            using TFQF = Field<21, 1>;    // TFQF
        };

        // FDCAN Tx Buffer Request Pending Register
        struct TXBRP : public Register<0x4000a4c8> {
            using TRP = Field<0, 32>;    // TRP
        };

        // FDCAN Tx Buffer Add Request Register
        struct TXBAR : public Register<0x4000a4cc> {
            using AR = Field<0, 32>;    // AR
        };

        // FDCAN Tx Buffer Cancellation Request Register
        struct TXBCR : public Register<0x4000a4d0> {
            using CR = Field<0, 32>;    // CR
        };

        // FDCAN Tx Buffer Transmission Occurred Register
        struct TXBTO : public Register<0x4000a4d4> {
            using TO = Field<0, 32>;    // TO
        };

        // FDCAN Tx Buffer Cancellation Finished Register
        struct TXBCF : public Register<0x4000a4d8> {
            using CF = Field<0, 32>;    // CF
        };

        // FDCAN Tx Buffer Transmission Interrupt Enable Register
        struct TXBTIE : public Register<0x4000a4dc> {
            using TIE = Field<0, 32>;    // TIE
        };

        // FDCAN Tx Buffer Cancellation Finished Interrupt Enable Register
        struct TXBCIE : public Register<0x4000a4e0> {
            using CFIE = Field<0, 32>;    // CFIE
        };

        // FDCAN Tx Event FIFO Status Register
        struct TXEFS : public Register<0x4000a4e4> {
            using EFFL = Field<0, 6>;    // EFFL
            using EFGI = Field<8, 5>;    // EFGI
            using EFPI = Field<16, 5>;    // EFPI
            using EFF = Field<24, 1>;    // EFF
            using TEFL = Field<25, 1>;    // TEFL
        };

        // FDCAN Tx Event FIFO Acknowledge Register
        struct TXEFA : public Register<0x4000a4e8> {
            using EFAI = Field<0, 5>;    // EFAI
        };

        // FDCAN CFG clock divider register
        struct CKDIV : public Register<0x4000a500> {
            using PDIV = Field<0, 4>;    // input clock divider. the APB clock could be divided prior to be used by the CAN sub
        };

    };

    // FDCAN
    struct FDCAN1 {
        // FDCAN Core Release Register
        struct CREL : public Register<0x40006400> {
            using DAY = Field<0, 8>;    // DAY
            using MON = Field<8, 8>;    // MON
            using YEAR = Field<16, 4>;    // YEAR
            using SUBSTEP = Field<20, 4>;    // SUBSTEP
            using STEP = Field<24, 4>;    // STEP
            using REL = Field<28, 4>;    // REL
        };

        // FDCAN Core Release Register
        struct ENDN : public Register<0x40006404> {
            using ETV = Field<0, 32>;    // ETV
        };

        // This register is only writable if bits CCCR.CCE and CCCR.INIT are set. The CAN bit time may be programed in the range of 4 to 25 time quanta. The CAN time quantum may be programmed in the range of 1 to 1024 FDCAN clock periods. tq = (DBRP + 1) FDCAN clock period. DTSEG1 is the sum of Prop_Seg and Phase_Seg1. DTSEG2 is Phase_Seg2. Therefore the length of the bit time is (programmed values) [DTSEG1 + DTSEG2 + 3] tq or (functional values) [Sync_Seg + Prop_Seg + Phase_Seg1 + Phase_Seg2] tq. The Information Processing Time (IPT) is zero, meaning the data for the next bit is available at the first clock edge after the sample point.
        struct DBTP : public Register<0x4000640c> {
            using DSJW = Field<0, 4>;    // DSJW
            using DTSEG2 = Field<4, 4>;    // DTSEG2
            using DTSEG1 = Field<8, 5>;    // DTSEG1
            using DBRP = Field<16, 5>;    // DBRP
            using TDC = Field<23, 1>;    // TDC
        };

        // Write access to the Test Register has to be enabled by setting bit CCCR[TEST] to 1 . All Test Register functions are set to their reset values when bit CCCR[TEST] is reset. Loop Back mode and software control of Tx pin FDCANx_TX are hardware test modes. Programming TX differently from 00 may disturb the message transfer on the CAN bus.
        struct TEST : public Register<0x40006410> {
            using LBCK = Field<4, 1>;    // LBCK
            using TX = Field<5, 2>;    // TX
            using RX = Field<7, 1>;    // RX
        };

        // The RAM Watchdog monitors the READY output of the Message RAM. A Message RAM access starts the Message RAM Watchdog Counter with the value configured by the RWD[WDC] bits. The counter is reloaded with RWD[WDC] bits when the Message RAM signals successful completion by activating its READY output. In case there is no response from the Message RAM until the counter has counted down to 0, the counter stops and interrupt flag IR[WDI] bit is set. The RAM Watchdog Counter is clocked by the fdcan_pclk clock.
        struct RWD : public Register<0x40006414> {
            using WDC = Field<0, 8>;    // WDC
            using WDV = Field<8, 8>;    // WDV
        };

        // For details about setting and resetting of single bits see Software initialization.
        struct CCCR : public Register<0x40006418> {
            using INIT = Field<0, 1>;    // INIT
            using CCE = Field<1, 1>;    // CCE
            using ASM = Field<2, 1>;    // ASM
            using CSA = Field<3, 1>;    // CSA
            using CSR = Field<4, 1>;    // CSR
            using MON = Field<5, 1>;    // MON
            using DAR = Field<6, 1>;    // DAR
            using TEST = Field<7, 1>;    // TEST
            using FDOE = Field<8, 1>;    // FDOE
            using BRSE = Field<9, 1>;    // BRSE
            using PXHD = Field<12, 1>;    // PXHD
            using EFBI = Field<13, 1>;    // EFBI
            using TXP = Field<14, 1>;    // TXP
            using NISO = Field<15, 1>;    // NISO
        };

        // FDCAN_NBTP
        struct NBTP : public Register<0x4000641c> {
            using TSEG2 = Field<0, 7>;    // TSEG2
            using NTSEG1 = Field<8, 8>;    // NTSEG1
            using NBRP = Field<16, 9>;    // NBRP
            using NSJW = Field<25, 7>;    // NSJW
        };

        // FDCAN Timestamp Counter Configuration Register
        struct TSCC : public Register<0x40006420> {
            using TSS = Field<0, 2>;    // TSS
            using TCP = Field<16, 4>;    // TCP
        };

        // FDCAN Timestamp Counter Value Register
        struct TSCV : public Register<0x40006424> {
            using TSC = Field<0, 16>;    // TSC
        };

        // FDCAN Timeout Counter Configuration Register
        struct TOCC : public Register<0x40006428> {
            using ETOC = Field<0, 1>;    // ETOC
            using TOS = Field<1, 2>;    // TOS
            using TOP = Field<16, 16>;    // TOP
        };

        // FDCAN Timeout Counter Value Register
        struct TOCV : public Register<0x4000642c> {
            using TOC = Field<0, 16>;    // TOC
        };

        // FDCAN Error Counter Register
        struct ECR : public Register<0x40006440> {
            using TEC = Field<0, 8>;    // TEC
            using TREC = Field<8, 7>;    // TREC
            using RP = Field<15, 1>;    // RP
            using CEL = Field<16, 8>;    // CEL
        };

        // FDCAN Protocol Status Register
        struct PSR : public Register<0x40006444> {
            using LEC = Field<0, 3>;    // LEC
            using ACT = Field<3, 2>;    // ACT
            using EP = Field<5, 1>;    // EP
            using EW = Field<6, 1>;    // EW
            using BO = Field<7, 1>;    // BO
            using DLEC = Field<8, 3>;    // DLEC
            using RESI = Field<11, 1>;    // RESI
            using RBRS = Field<12, 1>;    // RBRS
            using REDL = Field<13, 1>;    // REDL
            using PXE = Field<14, 1>;    // PXE
            using TDCV = Field<16, 7>;    // TDCV
        };

        // FDCAN Transmitter Delay Compensation Register
        struct TDCR : public Register<0x40006448> {
            using TDCF = Field<0, 7>;    // TDCF
            using TDCO = Field<8, 7>;    // TDCO
        };

        // The flags are set when one of the listed conditions is detected (edge-sensitive). The flags remain set until the Host clears them. A flag is cleared by writing a 1 to the corresponding bit position. Writing a 0 has no effect. A hard reset will clear the register. The configuration of IE controls whether an interrupt is generated. The configuration of ILS controls on which interrupt line an interrupt is signaled.
        struct IR : public Register<0x40006450> {
            using RF0N = Field<0, 1>;    // RF0N
            using RF0W = Field<1, 1>;    // RF0W
            using RF0F = Field<2, 1>;    // RF0F
            using RF0L = Field<3, 1>;    // RF0L
            using RF1N = Field<4, 1>;    // RF1N
            using RF1W = Field<5, 1>;    // RF1W
            using RF1F = Field<6, 1>;    // RF1F
            using RF1L = Field<7, 1>;    // RF1L
            using HPM = Field<8, 1>;    // HPM
            using TC = Field<9, 1>;    // TC
            using TCF = Field<10, 1>;    // TCF
            using TFE = Field<11, 1>;    // TFE
            using TEFN = Field<12, 1>;    // TEFN
            using TEFW = Field<13, 1>;    // TEFW
            using TEFF = Field<14, 1>;    // TEFF
            using TEFL = Field<15, 1>;    // TEFL
            using TSW = Field<16, 1>;    // TSW
            using MRAF = Field<17, 1>;    // MRAF
            using TOO = Field<18, 1>;    // TOO
            using DRX = Field<19, 1>;    // DRX
            using ELO = Field<22, 1>;    // ELO
            using EP = Field<23, 1>;    // EP
            using EW = Field<24, 1>;    // EW
            using BO = Field<25, 1>;    // BO
            using WDI = Field<26, 1>;    // WDI
            using PEA = Field<27, 1>;    // PEA
            using PED = Field<28, 1>;    // PED
            using ARA = Field<29, 1>;    // ARA
        };

        // The settings in the Interrupt Enable register determine which status changes in the Interrupt Register will be signaled on an interrupt line.
        struct IE : public Register<0x40006454> {
            using RF0NE = Field<0, 1>;    // RF0NE
            using RF0WE = Field<1, 1>;    // RF0WE
            using RF0FE = Field<2, 1>;    // RF0FE
            using RF0LE = Field<3, 1>;    // RF0LE
            using RF1NE = Field<4, 1>;    // RF1NE
            using RF1WE = Field<5, 1>;    // RF1WE
            using RF1FE = Field<6, 1>;    // RF1FE
            using RF1LE = Field<7, 1>;    // RF1LE
            using HPME = Field<8, 1>;    // HPME
            using TCE = Field<9, 1>;    // TCE
            using TCFE = Field<10, 1>;    // TCFE
            using TFEE = Field<11, 1>;    // TFEE
            using TEFNE = Field<12, 1>;    // TEFNE
            using TEFWE = Field<13, 1>;    // TEFWE
            using TEFFE = Field<14, 1>;    // TEFFE
            using TEFLE = Field<15, 1>;    // TEFLE
            using TSWE = Field<16, 1>;    // TSWE
            using MRAFE = Field<17, 1>;    // MRAFE
            using TOOE = Field<18, 1>;    // TOOE
            using DRX = Field<19, 1>;    // DRX
            using BECE = Field<20, 1>;    // BECE
            using BEUE = Field<21, 1>;    // BEUE
            using ELOE = Field<22, 1>;    // ELOE
            using EPE = Field<23, 1>;    // EPE
            using EWE = Field<24, 1>;    // EWE
            using BOE = Field<25, 1>;    // BOE
            using WDIE = Field<26, 1>;    // WDIE
            using PEAE = Field<27, 1>;    // PEAE
            using PEDE = Field<28, 1>;    // PEDE
            using ARAE = Field<29, 1>;    // ARAE
        };

        // The Interrupt Line Select register assigns an interrupt generated by a specific interrupt flag from the Interrupt Register to one of the two module interrupt lines. For interrupt generation the respective interrupt line has to be enabled via ILE[EINT0] and ILE[EINT1].
        struct ILS : public Register<0x40006458> {
            using RF0NL = Field<0, 1>;    // RF0NL
            using RF0WL = Field<1, 1>;    // RF0WL
            using RF0FL = Field<2, 1>;    // RF0FL
            using RF0LL = Field<3, 1>;    // RF0LL
            using RF1NL = Field<4, 1>;    // RF1NL
            using RF1WL = Field<5, 1>;    // RF1WL
            using RF1FL = Field<6, 1>;    // RF1FL
            using RF1LL = Field<7, 1>;    // RF1LL
            using HPML = Field<8, 1>;    // HPML
            using TCL = Field<9, 1>;    // TCL
            using TCFL = Field<10, 1>;    // TCFL
            using TFEL = Field<11, 1>;    // TFEL
            using TEFNL = Field<12, 1>;    // TEFNL
            using TEFWL = Field<13, 1>;    // TEFWL
            using TEFFL = Field<14, 1>;    // TEFFL
            using TEFLL = Field<15, 1>;    // TEFLL
            using TSWL = Field<16, 1>;    // TSWL
            using MRAFL = Field<17, 1>;    // MRAFL
            using TOOL = Field<18, 1>;    // TOOL
            using DRXL = Field<19, 1>;    // DRXL
            using BECL = Field<20, 1>;    // BECL
            using BEUL = Field<21, 1>;    // BEUL
            using ELOL = Field<22, 1>;    // ELOL
            using EPL = Field<23, 1>;    // EPL
            using EWL = Field<24, 1>;    // EWL
            using BOL = Field<25, 1>;    // BOL
            using WDIL = Field<26, 1>;    // WDIL
            using PEAL = Field<27, 1>;    // PEAL
            using PEDL = Field<28, 1>;    // PEDL
            using ARAL = Field<29, 1>;    // ARAL
        };

        // Each of the two interrupt lines to the CPU can be enabled/disabled separately by programming bits EINT0 and EINT1.
        struct ILE : public Register<0x4000645c> {
            using EINT0 = Field<0, 1>;    // EINT0
            using EINT1 = Field<1, 1>;    // EINT1
        };

        // Global settings for Message ID filtering. The Global Filter Configuration controls the filter path for standard and extended messages as described in Figure706: Standard Message ID filter path and Figure707: Extended Message ID filter path.
        struct RXGFC : public Register<0x40006480> {
            using RRFE = Field<0, 1>;    // RRFE
            using RRFS = Field<1, 1>;    // RRFS
            using ANFE = Field<2, 2>;    // ANFE
            using ANFS = Field<4, 2>;    // ANFS
        };

        // FDCAN Extended ID and Mask Register
        struct XIDAM : public Register<0x40006484> {
            using EIDM = Field<0, 29>;    // EIDM
        };

        // This register is updated every time a Message ID filter element configured to generate a priority event match. This can be used to monitor the status of incoming high priority messages and to enable fast access to these messages.
        struct HPMS : public Register<0x40006488> {
            using BIDX = Field<0, 6>;    // BIDX
            using MSI = Field<6, 2>;    // MSI
            using FIDX = Field<8, 7>;    // FIDX
            using FLST = Field<15, 1>;    // FLST
        };

        // FDCAN Rx FIFO 0 Status Register
        struct RXF0S : public Register<0x40006490> {
            using F0FL = Field<0, 7>;    // F0FL
            using F0GI = Field<8, 6>;    // F0GI
            using F0PI = Field<16, 6>;    // F0PI
            using F0F = Field<24, 1>;    // F0F
            using RF0L = Field<25, 1>;    // RF0L
        };

        // CAN Rx FIFO 0 Acknowledge Register
        struct RXF0A : public Register<0x40006494> {
            using F0AI = Field<0, 6>;    // F0AI
        };

        // FDCAN Rx FIFO 1 Status Register
        struct RXF1S : public Register<0x40006498> {
            using F1FL = Field<0, 7>;    // F1FL
            using F1GI = Field<8, 6>;    // F1GI
            using F1PI = Field<16, 6>;    // F1PI
            using F1F = Field<24, 1>;    // F1F
            using RF1L = Field<25, 1>;    // RF1L
            using DMS = Field<30, 2>;    // DMS
        };

        // FDCAN Rx FIFO 1 Acknowledge Register
        struct RXF1A : public Register<0x4000649c> {
            using F1AI = Field<0, 6>;    // F1AI
        };

        // FDCAN Tx Buffer Configuration Register
        struct TXBC : public Register<0x400064c0> {
            using TBSA = Field<2, 14>;    // TBSA
            using NDTB = Field<16, 6>;    // NDTB
            using TFQS = Field<24, 6>;    // TFQS
            using TFQM = Field<30, 1>;    // TFQM
        };

        // The Tx FIFO/Queue status is related to the pending Tx requests listed in register TXBRP. Therefore the effect of Add/Cancellation requests may be delayed due to a running Tx scan (TXBRP not yet updated).
        struct TXFQS : public Register<0x400064c4> {
            using TFFL = Field<0, 6>;    // TFFL
            using TFGI = Field<8, 5>;    // TFGI
            using TFQPI = Field<16, 5>;    // TFQPI
            using TFQF = Field<21, 1>;    // TFQF
        };

        // FDCAN Tx Buffer Request Pending Register
        struct TXBRP : public Register<0x400064c8> {
            using TRP = Field<0, 32>;    // TRP
        };

        // FDCAN Tx Buffer Add Request Register
        struct TXBAR : public Register<0x400064cc> {
            using AR = Field<0, 32>;    // AR
        };

        // FDCAN Tx Buffer Cancellation Request Register
        struct TXBCR : public Register<0x400064d0> {
            using CR = Field<0, 32>;    // CR
        };

        // FDCAN Tx Buffer Transmission Occurred Register
        struct TXBTO : public Register<0x400064d4> {
            using TO = Field<0, 32>;    // TO
        };

        // FDCAN Tx Buffer Cancellation Finished Register
        struct TXBCF : public Register<0x400064d8> {
            using CF = Field<0, 32>;    // CF
        };

        // FDCAN Tx Buffer Transmission Interrupt Enable Register
        struct TXBTIE : public Register<0x400064dc> {
            using TIE = Field<0, 32>;    // TIE
        };

        // FDCAN Tx Buffer Cancellation Finished Interrupt Enable Register
        struct TXBCIE : public Register<0x400064e0> {
            using CFIE = Field<0, 32>;    // CFIE
        };

        // FDCAN Tx Event FIFO Status Register
        struct TXEFS : public Register<0x400064e4> {
            using EFFL = Field<0, 6>;    // EFFL
            using EFGI = Field<8, 5>;    // EFGI
            using EFPI = Field<16, 5>;    // EFPI
            using EFF = Field<24, 1>;    // EFF
            using TEFL = Field<25, 1>;    // TEFL
        };

        // FDCAN Tx Event FIFO Acknowledge Register
        struct TXEFA : public Register<0x400064e8> {
            using EFAI = Field<0, 5>;    // EFAI
        };

        // FDCAN CFG clock divider register
        struct CKDIV : public Register<0x40006500> {
            using PDIV = Field<0, 4>;    // input clock divider. the APB clock could be divided prior to be used by the CAN sub
        };

    };

    // UCPD1
    struct UCPD1 {
        // UCPD configuration register 1
        struct CFG1 : public Register<0x4000a000> {
            using HBITCLKDIV = Field<0, 6>;    // HBITCLKDIV
            using IFRGAP = Field<6, 5>;    // IFRGAP
            using TRANSWIN = Field<11, 5>;    // TRANSWIN
            using PSC_USBPDCLK = Field<17, 3>;    // PSC_USBPDCLK
            using RXORDSETEN = Field<20, 9>;    // RXORDSETEN
            using TXDMAEN = Field<29, 1>;    // TXDMAEN
            using RXDMAEN = Field<30, 1>;    // RXDMAEN
            using UCPDEN = Field<31, 1>;    // UCPDEN
        };

        // UCPD configuration register 2
        struct CFG2 : public Register<0x4000a004> {
            using RXFILTDIS = Field<0, 1>;    // RXFILTDIS
            using RXFILT2N3 = Field<1, 1>;    // RXFILT2N3
            using FORCECLK = Field<2, 1>;    // FORCECLK
            using WUPEN = Field<3, 1>;    // WUPEN
        };

        // UCPD configuration register 2
        struct CR : public Register<0x4000a00c> {
            using TXMODE = Field<0, 2>;    // TXMODE
            using TXSEND = Field<2, 1>;    // TXSEND
            using TXHRST = Field<3, 1>;    // TXHRST
            using RXMODE = Field<4, 1>;    // RXMODE
            using PHYRXEN = Field<5, 1>;    // PHYRXEN
            using PHYCCSEL = Field<6, 1>;    // PHYCCSEL
            using ANASUBMODE = Field<7, 2>;    // ANASUBMODE
            using ANAMODE = Field<9, 1>;    // ANAMODE
            using CCENABLE = Field<10, 2>;    // CCENABLE
            using FRSRXEN = Field<16, 1>;    // FRSRXEN
            using FRSTX = Field<17, 1>;    // FRSTX
            using RDCH = Field<18, 1>;    // RDCH
            using CC1TCDIS = Field<20, 1>;    // CC1TCDIS
            using CC2TCDIS = Field<21, 1>;    // CC2TCDIS
        };

        // UCPD Interrupt Mask Register
        struct IMR : public Register<0x4000a010> {
            using TXISIE = Field<0, 1>;    // TXISIE
            using TXMSGDISCIE = Field<1, 1>;    // TXMSGDISCIE
            using TXMSGSENTIE = Field<2, 1>;    // TXMSGSENTIE
            using TXMSGABTIE = Field<3, 1>;    // TXMSGABTIE
            using HRSTDISCIE = Field<4, 1>;    // HRSTDISCIE
            using HRSTSENTIE = Field<5, 1>;    // HRSTSENTIE
            using TXUNDIE = Field<6, 1>;    // TXUNDIE
            using RXNEIE = Field<8, 1>;    // RXNEIE
            using RXORDDETIE = Field<9, 1>;    // RXORDDETIE
            using RXHRSTDETIE = Field<10, 1>;    // RXHRSTDETIE
            using RXOVRIE = Field<11, 1>;    // RXOVRIE
            using RXMSGENDIE = Field<12, 1>;    // RXMSGENDIE
            using TYPECEVT1IE = Field<14, 1>;    // TYPECEVT1IE
            using TYPECEVT2IE = Field<15, 1>;    // TYPECEVT2IE
            using FRSEVTIE = Field<20, 1>;    // FRSEVTIE
        };

        // UCPD Status Register
        struct SR : public Register<0x4000a014> {
            using TXIS = Field<0, 1>;    // TXIS
            using TXMSGDISC = Field<1, 1>;    // TXMSGDISC
            using TXMSGSENT = Field<2, 1>;    // TXMSGSENT
            using TXMSGABT = Field<3, 1>;    // TXMSGABT
            using HRSTDISC = Field<4, 1>;    // HRSTDISC
            using HRSTSENT = Field<5, 1>;    // HRSTSENT
            using TXUND = Field<6, 1>;    // TXUND
            using RXNE = Field<8, 1>;    // RXNE
            using RXORDDET = Field<9, 1>;    // RXORDDET
            using RXHRSTDET = Field<10, 1>;    // RXHRSTDET
            using RXOVR = Field<11, 1>;    // RXOVR
            using RXMSGEND = Field<12, 1>;    // RXMSGEND
            using RXERR = Field<13, 1>;    // RXERR
            using TYPECEVT1 = Field<14, 1>;    // TYPECEVT1
            using TYPECEVT2 = Field<15, 1>;    // TYPECEVT2
            using TYPEC_VSTATE_CC1 = Field<16, 2>;    // TYPEC_VSTATE_CC1
            using TYPEC_VSTATE_CC2 = Field<18, 2>;    // TYPEC_VSTATE_CC2
            using FRSEVT = Field<20, 1>;    // FRSEVT
        };

        // UCPD Interrupt Clear Register
        struct ICR : public Register<0x4000a018> {
            using TXMSGDISCCF = Field<1, 1>;    // TXMSGDISCCF
            using TXMSGSENTCF = Field<2, 1>;    // TXMSGSENTCF
            using TXMSGABTCF = Field<3, 1>;    // TXMSGABTCF
            using HRSTDISCCF = Field<4, 1>;    // HRSTDISCCF
            using HRSTSENTCF = Field<5, 1>;    // HRSTSENTCF
            using TXUNDCF = Field<6, 1>;    // TXUNDCF
            using RXORDDETCF = Field<9, 1>;    // RXORDDETCF
            using RXHRSTDETCF = Field<10, 1>;    // RXHRSTDETCF
            using RXOVRCF = Field<11, 1>;    // RXOVRCF
            using RXMSGENDCF = Field<12, 1>;    // RXMSGENDCF
            using TYPECEVT1CF = Field<14, 1>;    // TYPECEVT1CF
            using TYPECEVT2CF = Field<15, 1>;    // TYPECEVT2CF
            using FRSEVTCF = Field<20, 1>;    // FRSEVTCF
        };

        // UCPD Tx Ordered Set Type Register
        struct TX_ORDSET : public Register<0x4000a01c> {
            using TXORDSET = Field<0, 20>;    // TXORDSET
        };

        // UCPD Tx Paysize Register
        struct TX_PAYSZ : public Register<0x4000a020> {
            using TXPAYSZ = Field<0, 10>;    // TXPAYSZ
        };

        // UCPD Tx Data Register
        struct TXDR : public Register<0x4000a024> {
            using TXDATA = Field<0, 8>;    // TXDATA
        };

        // UCPD Rx Ordered Set Register
        struct RX_ORDSET : public Register<0x4000a028> {
            using RXORDSET = Field<0, 3>;    // RXORDSET
            using RXSOP3OF4 = Field<3, 1>;    // RXSOP3OF4
            using RXSOPKINVALID = Field<4, 3>;    // RXSOPKINVALID
        };

        // UCPD Rx Paysize Register
        struct RX_PAYSZ : public Register<0x4000a02c> {
            using RXPAYSZ = Field<0, 10>;    // RXPAYSZ
        };

        // UCPD Rx Data Register
        struct RXDR : public Register<0x4000a030> {
            using RXDATA = Field<0, 8>;    // RXDATA
        };

        // UCPD Rx Ordered Set Extension Register 1
        struct RX_ORDEXT1 : public Register<0x4000a034> {
            using RXSOPX1 = Field<0, 20>;    // RXSOPX1
        };

        // UCPD Rx Ordered Set Extension Register 2
        struct RX_ORDEXT2 : public Register<0x4000a038> {
            using RXSOPX2 = Field<0, 20>;    // RXSOPX2
        };

    };

    // USB_FS_device
    struct USB_FS_device {
        // USB endpoint n register
        struct EP0R : public Register<0x40005c00> {
            using EA = Field<0, 4>;    // EA
            using STAT_TX = Field<4, 2>;    // STAT_TX
            using DTOG_TX = Field<6, 1>;    // DTOG_TX
            using CTR_TX = Field<7, 1>;    // CTR_TX
            using EP_KIND = Field<8, 1>;    // EP_KIND
            using EP_TYPE = Field<9, 2>;    // EP_TYPE
            using SETUP = Field<11, 1>;    // SETUP
            using STAT_RX = Field<12, 2>;    // STAT_RX
            using DTOG_RX = Field<14, 1>;    // DTOG_RX
            using CTR_RX = Field<15, 1>;    // CTR_RX
        };

        // USB endpoint n register
        struct EP1R : public Register<0x40005c04> {
            using EA = Field<0, 4>;    // EA
            using STAT_TX = Field<4, 2>;    // STAT_TX
            using DTOG_TX = Field<6, 1>;    // DTOG_TX
            using CTR_TX = Field<7, 1>;    // CTR_TX
            using EP_KIND = Field<8, 1>;    // EP_KIND
            using EP_TYPE = Field<9, 2>;    // EP_TYPE
            using SETUP = Field<11, 1>;    // SETUP
            using STAT_RX = Field<12, 2>;    // STAT_RX
            using DTOG_RX = Field<14, 1>;    // DTOG_RX
            using CTR_RX = Field<15, 1>;    // CTR_RX
        };

        // USB endpoint n register
        struct EP2R : public Register<0x40005c08> {
            using EA = Field<0, 4>;    // EA
            using STAT_TX = Field<4, 2>;    // STAT_TX
            using DTOG_TX = Field<6, 1>;    // DTOG_TX
            using CTR_TX = Field<7, 1>;    // CTR_TX
            using EP_KIND = Field<8, 1>;    // EP_KIND
            using EP_TYPE = Field<9, 2>;    // EP_TYPE
            using SETUP = Field<11, 1>;    // SETUP
            using STAT_RX = Field<12, 2>;    // STAT_RX
            using DTOG_RX = Field<14, 1>;    // DTOG_RX
            using CTR_RX = Field<15, 1>;    // CTR_RX
        };

        // USB endpoint n register
        struct EP3R : public Register<0x40005c0c> {
            using EA = Field<0, 4>;    // EA
            using STAT_TX = Field<4, 2>;    // STAT_TX
            using DTOG_TX = Field<6, 1>;    // DTOG_TX
            using CTR_TX = Field<7, 1>;    // CTR_TX
            using EP_KIND = Field<8, 1>;    // EP_KIND
            using EP_TYPE = Field<9, 2>;    // EP_TYPE
            using SETUP = Field<11, 1>;    // SETUP
            using STAT_RX = Field<12, 2>;    // STAT_RX
            using DTOG_RX = Field<14, 1>;    // DTOG_RX
            using CTR_RX = Field<15, 1>;    // CTR_RX
        };

        // USB endpoint n register
        struct EP4R : public Register<0x40005c10> {
            using EA = Field<0, 4>;    // EA
            using STAT_TX = Field<4, 2>;    // STAT_TX
            using DTOG_TX = Field<6, 1>;    // DTOG_TX
            using CTR_TX = Field<7, 1>;    // CTR_TX
            using EP_KIND = Field<8, 1>;    // EP_KIND
            using EP_TYPE = Field<9, 2>;    // EP_TYPE
            using SETUP = Field<11, 1>;    // SETUP
            using STAT_RX = Field<12, 2>;    // STAT_RX
            using DTOG_RX = Field<14, 1>;    // DTOG_RX
            using CTR_RX = Field<15, 1>;    // CTR_RX
        };

        // USB endpoint n register
        struct EP5R : public Register<0x40005c14> {
            using EA = Field<0, 4>;    // EA
            using STAT_TX = Field<4, 2>;    // STAT_TX
            using DTOG_TX = Field<6, 1>;    // DTOG_TX
            using CTR_TX = Field<7, 1>;    // CTR_TX
            using EP_KIND = Field<8, 1>;    // EP_KIND
            using EP_TYPE = Field<9, 2>;    // EP_TYPE
            using SETUP = Field<11, 1>;    // SETUP
            using STAT_RX = Field<12, 2>;    // STAT_RX
            using DTOG_RX = Field<14, 1>;    // DTOG_RX
            using CTR_RX = Field<15, 1>;    // CTR_RX
        };

        // USB endpoint n register
        struct EP6R : public Register<0x40005c18> {
            using EA = Field<0, 4>;    // EA
            using STAT_TX = Field<4, 2>;    // STAT_TX
            using DTOG_TX = Field<6, 1>;    // DTOG_TX
            using CTR_TX = Field<7, 1>;    // CTR_TX
            using EP_KIND = Field<8, 1>;    // EP_KIND
            using EP_TYPE = Field<9, 2>;    // EP_TYPE
            using SETUP = Field<11, 1>;    // SETUP
            using STAT_RX = Field<12, 2>;    // STAT_RX
            using DTOG_RX = Field<14, 1>;    // DTOG_RX
            using CTR_RX = Field<15, 1>;    // CTR_RX
        };

        // USB endpoint n register
        struct EP7R : public Register<0x40005c1c> {
            using EA = Field<0, 4>;    // EA
            using STAT_TX = Field<4, 2>;    // STAT_TX
            using DTOG_TX = Field<6, 1>;    // DTOG_TX
            using CTR_TX = Field<7, 1>;    // CTR_TX
            using EP_KIND = Field<8, 1>;    // EP_KIND
            using EP_TYPE = Field<9, 2>;    // EP_TYPE
            using SETUP = Field<11, 1>;    // SETUP
            using STAT_RX = Field<12, 2>;    // STAT_RX
            using DTOG_RX = Field<14, 1>;    // DTOG_RX
            using CTR_RX = Field<15, 1>;    // CTR_RX
        };

        // USB control register
        struct CNTR : public Register<0x40005c40> {
            using FRES = Field<0, 1>;    // FRES
            using PDWN = Field<1, 1>;    // PDWN
            using LP_MODE = Field<2, 1>;    // LP_MODE
            using FSUSP = Field<3, 1>;    // FSUSP
            using RESUME = Field<4, 1>;    // RESUME
            using L1RESUME = Field<5, 1>;    // L1RESUME
            using L1REQM = Field<7, 1>;    // L1REQM
            using ESOFM = Field<8, 1>;    // ESOFM
            using SOFM = Field<9, 1>;    // SOFM
            using RESETM = Field<10, 1>;    // RESETM
            using SUSPM = Field<11, 1>;    // SUSPM
            using WKUPM = Field<12, 1>;    // WKUPM
            using ERRM = Field<13, 1>;    // ERRM
            using PMAOVRM = Field<14, 1>;    // PMAOVRM
            using CTRM = Field<15, 1>;    // CTRM
        };

        // USB interrupt status register
        struct ISTR : public Register<0x40005c44> {
            using EP_ID = Field<0, 4>;    // EP_ID
            using DIR = Field<4, 1>;    // DIR
            using L1REQ = Field<7, 1>;    // L1REQ
            using ESOF = Field<8, 1>;    // ESOF
            using SOF = Field<9, 1>;    // SOF
            using RESET = Field<10, 1>;    // RESET
            using SUSP = Field<11, 1>;    // SUSP
            using WKUP = Field<12, 1>;    // WKUP
            using ERR = Field<13, 1>;    // ERR
            using PMAOVR = Field<14, 1>;    // PMAOVR
            using CTR = Field<15, 1>;    // CTR
        };

        // USB frame number register
        struct FNR : public Register<0x40005c48> {
            using FN = Field<0, 11>;    // FN
            using LSOF = Field<11, 2>;    // LSOF
            using LCK = Field<13, 1>;    // LCK
            using RXDM = Field<14, 1>;    // RXDM
            using RXDP = Field<15, 1>;    // RXDP
        };

        // USB device address
        struct DADDR : public Register<0x40005c4c> {
            using ADD = Field<0, 7>;    // ADD
            using EF = Field<7, 1>;    // EF
        };

        // Buffer table address
        struct BTABLE : public Register<0x40005c50> {
            using Field = Field<3, 13>;    // BTABLE
        };

    };

    // CRS
    struct CRS {
        // CRS control register
        struct CR : public Register<0x40002000> {
            using SYNCOKIE = Field<0, 1>;    // SYNC event OK interrupt enable
            using SYNCWARNIE = Field<1, 1>;    // SYNC warning interrupt enable
            using ERRIE = Field<2, 1>;    // Synchronization or trimming error interrupt enable
            using ESYNCIE = Field<3, 1>;    // Expected SYNC interrupt enable
            using CEN = Field<5, 1>;    // Frequency error counter enable This bit enables the oscillator clock for the frequency error counter. When this bit is set, the CRS_CFGR register is write-protected and cannot be modified.
            using AUTOTRIMEN = Field<6, 1>;    // Automatic trimming enable This bit enables the automatic hardware adjustment of TRIM bits according to the measured frequency error between two SYNC events. If this bit is set, the TRIM bits are read-only. The TRIM value can be adjusted by hardware by one or two steps at a time, depending on the measured frequency error value. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details.
            using SWSYNC = Field<7, 1>;    // Generate software SYNC event This bit is set by software in order to generate a software SYNC event. It is automatically cleared by hardware.
            using TRIM = Field<8, 7>;    // HSI48 oscillator smooth trimming These bits provide a user-programmable trimming value to the HSI48 oscillator. They can be programmed to adjust to variations in voltage and temperature that influence the frequency of the HSI48. The default value is 32, which corresponds to the middle of the trimming interval. The trimming step is around 67 kHz between two consecutive TRIM steps. A higher TRIM value corresponds to a higher output frequency. When the AUTOTRIMEN bit is set, this field is controlled by hardware and is read-only.
        };

        // This register can be written only when the frequency error counter is disabled (CEN bit is cleared in CRS_CR). When the counter is enabled, this register is write-protected.
        struct CFGR : public Register<0x40002004> {
            using RELOAD = Field<0, 16>;    // Counter reload value RELOAD is the value to be loaded in the frequency error counter with each SYNC event. Refer to Section7.3.3: Frequency error measurement for more details about counter behavior.
            using FELIM = Field<16, 8>;    // Frequency error limit FELIM contains the value to be used to evaluate the captured frequency error value latched in the FECAP[15:0] bits of the CRS_ISR register. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details about FECAP evaluation.
            using SYNCDIV = Field<24, 3>;    // SYNC divider These bits are set and cleared by software to control the division factor of the SYNC signal.
            using SYNCSRC = Field<28, 2>;    // SYNC signal source selection These bits are set and cleared by software to select the SYNC signal source. Note: When using USB LPM (Link Power Management) and the device is in Sleep mode, the periodic USB SOF will not be generated by the host. No SYNC signal will therefore be provided to the CRS to calibrate the HSI48 on the run. To guarantee the required clock precision after waking up from Sleep mode, the LSE or reference clock on the GPIOs should be used as SYNC signal.
            using SYNCPOL = Field<31, 1>;    // SYNC polarity selection This bit is set and cleared by software to select the input polarity for the SYNC signal source.
        };

        // CRS interrupt and status register
        struct ISR : public Register<0x40002008> {
            using SYNCOKF = Field<0, 1>;    // SYNC event OK flag This flag is set by hardware when the measured frequency error is smaller than FELIM * 3. This means that either no adjustment of the TRIM value is needed or that an adjustment by one trimming step is enough to compensate the frequency error. An interrupt is generated if the SYNCOKIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCOKC bit in the CRS_ICR register.
            using SYNCWARNF = Field<1, 1>;    // SYNC warning flag This flag is set by hardware when the measured frequency error is greater than or equal to FELIM * 3, but smaller than FELIM * 128. This means that to compensate the frequency error, the TRIM value must be adjusted by two steps or more. An interrupt is generated if the SYNCWARNIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCWARNC bit in the CRS_ICR register.
            using ERRF = Field<2, 1>;    // Error flag This flag is set by hardware in case of any synchronization or trimming error. It is the logical OR of the TRIMOVF, SYNCMISS and SYNCERR bits. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software in reaction to setting the ERRC bit in the CRS_ICR register, which clears the TRIMOVF, SYNCMISS and SYNCERR bits.
            using ESYNCF = Field<3, 1>;    // Expected SYNC flag This flag is set by hardware when the frequency error counter reached a zero value. An interrupt is generated if the ESYNCIE bit is set in the CRS_CR register. It is cleared by software by setting the ESYNCC bit in the CRS_ICR register.
            using SYNCERR = Field<8, 1>;    // SYNC error This flag is set by hardware when the SYNC pulse arrives before the ESYNC event and the measured frequency error is greater than or equal to FELIM * 128. This means that the frequency error is too big (internal frequency too low) to be compensated by adjusting the TRIM value, and that some other action should be taken. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
            using SYNCMISS = Field<9, 1>;    // SYNC missed This flag is set by hardware when the frequency error counter reached value FELIM * 128 and no SYNC was detected, meaning either that a SYNC pulse was missed or that the frequency error is too big (internal frequency too high) to be compensated by adjusting the TRIM value, and that some other action should be taken. At this point, the frequency error counter is stopped (waiting for a next SYNC) and an interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
            using TRIMOVF = Field<10, 1>;    // Trimming overflow or underflow This flag is set by hardware when the automatic trimming tries to over- or under-flow the TRIM value. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
            using FEDIR = Field<15, 1>;    // Frequency error direction FEDIR is the counting direction of the frequency error counter latched in the time of the last SYNC event. It shows whether the actual frequency is below or above the target.
            using FECAP = Field<16, 16>;    // Frequency error capture FECAP is the frequency error counter value latched in the time ofthe last SYNC event. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details about FECAP usage.
        };

        // CRS interrupt flag clear register
        struct ICR : public Register<0x4000200c> {
            using SYNCOKC = Field<0, 1>;    // SYNC event OK clear flag Writing 1 to this bit clears the SYNCOKF flag in the CRS_ISR register.
            using SYNCWARNC = Field<1, 1>;    // SYNC warning clear flag Writing 1 to this bit clears the SYNCWARNF flag in the CRS_ISR register.
            using ERRC = Field<2, 1>;    // Error clear flag Writing 1 to this bit clears TRIMOVF, SYNCMISS and SYNCERR bits and consequently also the ERRF flag in the CRS_ISR register.
            using ESYNCC = Field<3, 1>;    // Expected SYNC clear flag Writing 1 to this bit clears the ESYNCF flag in the CRS_ISR register.
        };

    };

};
