// This is a file generated by svd-alias.

#pragma once

#include "svd-alias/bit-field.hpp"
#include "svd-alias/register.hpp"

struct STM32L4S7 {
    // Digital-to-analog converter
    struct DAC {
        // control register
        struct CR : public Register<0x40007400> {
            using EN1 = Field<0, 1>;    // DAC channel1 enable
            using TEN1 = Field<2, 1>;    // DAC channel1 trigger enable
            using TSEL1 = Field<3, 3>;    // DAC channel1 trigger selection
            using WAVE1 = Field<6, 2>;    // DAC channel1 noise/triangle wave generation enable
            using MAMP1 = Field<8, 4>;    // DAC channel1 mask/amplitude selector
            using DMAEN1 = Field<12, 1>;    // DAC channel1 DMA enable
            using DMAUDRIE1 = Field<13, 1>;    // DAC channel1 DMA Underrun Interrupt enable
            using CEN1 = Field<14, 1>;    // DAC Channel 1 calibration enable
            using EN2 = Field<16, 1>;    // DAC channel2 enable
            using TEN2 = Field<18, 1>;    // DAC channel2 trigger enable
            using TSEL2 = Field<19, 3>;    // DAC channel2 trigger selection
            using WAVE2 = Field<22, 2>;    // DAC channel2 noise/triangle wave generation enable
            using MAMP2 = Field<24, 4>;    // DAC channel2 mask/amplitude selector
            using DMAEN2 = Field<28, 1>;    // DAC channel2 DMA enable
            using DMAUDRIE2 = Field<29, 1>;    // DAC channel2 DMA underrun interrupt enable
            using CEN2 = Field<30, 1>;    // DAC Channel 2 calibration enable
        };

        // software trigger register
        struct SWTRIGR : public Register<0x40007404> {
            using SWTRIG1 = Field<0, 1>;    // DAC channel1 software trigger
            using SWTRIG2 = Field<1, 1>;    // DAC channel2 software trigger
        };

        // channel1 12-bit right-aligned data holding register
        struct DHR12R1 : public Register<0x40007408> {
            using DACC1DHR = Field<0, 12>;    // DAC channel1 12-bit right-aligned data
        };

        // channel1 12-bit left-aligned data holding register
        struct DHR12L1 : public Register<0x4000740c> {
            using DACC1DHR = Field<4, 12>;    // DAC channel1 12-bit left-aligned data
        };

        // channel1 8-bit right-aligned data holding register
        struct DHR8R1 : public Register<0x40007410> {
            using DACC1DHR = Field<0, 8>;    // DAC channel1 8-bit right-aligned data
        };

        // channel2 12-bit right aligned data holding register
        struct DHR12R2 : public Register<0x40007414> {
            using DACC2DHR = Field<0, 12>;    // DAC channel2 12-bit right-aligned data
        };

        // channel2 12-bit left aligned data holding register
        struct DHR12L2 : public Register<0x40007418> {
            using DACC2DHR = Field<4, 12>;    // DAC channel2 12-bit left-aligned data
        };

        // channel2 8-bit right-aligned data holding register
        struct DHR8R2 : public Register<0x4000741c> {
            using DACC2DHR = Field<0, 8>;    // DAC channel2 8-bit right-aligned data
        };

        // Dual DAC 12-bit right-aligned data holding register
        struct DHR12RD : public Register<0x40007420> {
            using DACC1DHR = Field<0, 12>;    // DAC channel1 12-bit right-aligned data
            using DACC2DHR = Field<16, 12>;    // DAC channel2 12-bit right-aligned data
        };

        // DUAL DAC 12-bit left aligned data holding register
        struct DHR12LD : public Register<0x40007424> {
            using DACC1DHR = Field<4, 12>;    // DAC channel1 12-bit left-aligned data
            using DACC2DHR = Field<20, 12>;    // DAC channel2 12-bit left-aligned data
        };

        // DUAL DAC 8-bit right aligned data holding register
        struct DHR8RD : public Register<0x40007428> {
            using DACC1DHR = Field<0, 8>;    // DAC channel1 8-bit right-aligned data
            using DACC2DHR = Field<8, 8>;    // DAC channel2 8-bit right-aligned data
        };

        // channel1 data output register
        struct DOR1 : public Register<0x4000742c> {
            using DACC1DOR = Field<0, 12>;    // DAC channel1 data output
        };

        // channel2 data output register
        struct DOR2 : public Register<0x40007430> {
            using DACC2DOR = Field<0, 12>;    // DAC channel2 data output
        };

        // status register
        struct SR : public Register<0x40007434> {
            using DMAUDR1 = Field<13, 1>;    // DAC channel1 DMA underrun flag
            using CAL_FLAG1 = Field<14, 1>;    // DAC Channel 1 calibration offset status
            using BWST1 = Field<15, 1>;    // DAC Channel 1 busy writing sample time flag
            using DMAUDR2 = Field<29, 1>;    // DAC channel2 DMA underrun flag
            using CAL_FLAG2 = Field<30, 1>;    // DAC Channel 2 calibration offset status
            using BWST2 = Field<31, 1>;    // DAC Channel 2 busy writing sample time flag
        };

        // calibration control register
        struct CCR : public Register<0x40007438> {
            using OTRIM1 = Field<0, 5>;    // DAC Channel 1 offset trimming value
            using OTRIM2 = Field<16, 5>;    // DAC Channel 2 offset trimming value
        };

        // mode control register
        struct MCR : public Register<0x4000743c> {
            using MODE1 = Field<0, 3>;    // DAC Channel 1 mode
            using MODE2 = Field<16, 3>;    // DAC Channel 2 mode
        };

        // Sample and Hold sample time register 1
        struct SHSR1 : public Register<0x40007440> {
            using TSAMPLE1 = Field<0, 10>;    // DAC Channel 1 sample Time
        };

        // Sample and Hold sample time register 2
        struct SHSR2 : public Register<0x40007444> {
            using TSAMPLE2 = Field<0, 10>;    // DAC Channel 2 sample Time
        };

        // Sample and Hold hold time register
        struct SHHR : public Register<0x40007448> {
            using THOLD1 = Field<0, 10>;    // DAC Channel 1 hold Time
            using THOLD2 = Field<16, 10>;    // DAC Channel 2 hold time
        };

        // Sample and Hold refresh time register
        struct SHRR : public Register<0x4000744c> {
            using TREFRESH1 = Field<0, 8>;    // DAC Channel 1 refresh Time
            using TREFRESH2 = Field<16, 8>;    // DAC Channel 2 refresh Time
        };

    };

    // Direct memory access controller
    struct DMA1 {
        // interrupt status register
        struct ISR : public Register<0x40020000> {
            using TEIF7 = Field<27, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF7 = Field<26, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF7 = Field<25, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF7 = Field<24, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF6 = Field<23, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF6 = Field<22, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF6 = Field<21, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF6 = Field<20, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF5 = Field<19, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF5 = Field<18, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF5 = Field<17, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF5 = Field<16, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF4 = Field<15, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF4 = Field<14, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF4 = Field<13, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF4 = Field<12, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF3 = Field<11, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF3 = Field<10, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF3 = Field<9, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF3 = Field<8, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF2 = Field<7, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF2 = Field<6, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF2 = Field<5, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF2 = Field<4, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF1 = Field<3, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF1 = Field<2, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF1 = Field<1, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF1 = Field<0, 1>;    // Channel x global interrupt flag (x = 1 ..7)
        };

        // interrupt flag clear register
        struct IFCR : public Register<0x40020004> {
            using CTEIF7 = Field<27, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF7 = Field<26, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF7 = Field<25, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF7 = Field<24, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF6 = Field<23, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF6 = Field<22, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF6 = Field<21, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF6 = Field<20, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF5 = Field<19, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF5 = Field<18, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF5 = Field<17, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF5 = Field<16, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF4 = Field<15, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF4 = Field<14, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF4 = Field<13, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF4 = Field<12, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF3 = Field<11, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF3 = Field<10, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF3 = Field<9, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF3 = Field<8, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF2 = Field<7, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF2 = Field<6, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF2 = Field<5, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF2 = Field<4, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF1 = Field<3, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF1 = Field<2, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF1 = Field<1, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF1 = Field<0, 1>;    // Channel x global interrupt clear (x = 1 ..7)
        };

        // channel x configuration register
        struct CCR1 : public Register<0x40020008> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR1 : public Register<0x4002000c> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR1 : public Register<0x40020010> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR1 : public Register<0x40020014> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR2 : public Register<0x4002001c> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR2 : public Register<0x40020020> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR2 : public Register<0x40020024> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR2 : public Register<0x40020028> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR3 : public Register<0x40020030> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR3 : public Register<0x40020034> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR3 : public Register<0x40020038> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR3 : public Register<0x4002003c> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR4 : public Register<0x40020044> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR4 : public Register<0x40020048> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR4 : public Register<0x4002004c> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR4 : public Register<0x40020050> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR5 : public Register<0x40020058> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR5 : public Register<0x4002005c> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR5 : public Register<0x40020060> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR5 : public Register<0x40020064> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR6 : public Register<0x4002006c> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR6 : public Register<0x40020070> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR6 : public Register<0x40020074> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR6 : public Register<0x40020078> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR7 : public Register<0x40020080> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR7 : public Register<0x40020084> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR7 : public Register<0x40020088> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR7 : public Register<0x4002008c> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel selection register
        struct CSELR : public Register<0x400200a8> {
            using C7S = Field<24, 4>;    // DMA channel 7 selection
            using C6S = Field<20, 4>;    // DMA channel 6 selection
            using C5S = Field<16, 4>;    // DMA channel 5 selection
            using C4S = Field<12, 4>;    // DMA channel 4 selection
            using C3S = Field<8, 4>;    // DMA channel 3 selection
            using C2S = Field<4, 4>;    // DMA channel 2 selection
            using C1S = Field<0, 4>;    // DMA channel 1 selection
        };

    };

    // Direct memory access controller
    struct DMA2 {
        // interrupt status register
        struct ISR : public Register<0x40020400> {
            using TEIF7 = Field<27, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF7 = Field<26, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF7 = Field<25, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF7 = Field<24, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF6 = Field<23, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF6 = Field<22, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF6 = Field<21, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF6 = Field<20, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF5 = Field<19, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF5 = Field<18, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF5 = Field<17, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF5 = Field<16, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF4 = Field<15, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF4 = Field<14, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF4 = Field<13, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF4 = Field<12, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF3 = Field<11, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF3 = Field<10, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF3 = Field<9, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF3 = Field<8, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF2 = Field<7, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF2 = Field<6, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF2 = Field<5, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF2 = Field<4, 1>;    // Channel x global interrupt flag (x = 1 ..7)
            using TEIF1 = Field<3, 1>;    // Channel x transfer error flag (x = 1 ..7)
            using HTIF1 = Field<2, 1>;    // Channel x half transfer flag (x = 1 ..7)
            using TCIF1 = Field<1, 1>;    // Channel x transfer complete flag (x = 1 ..7)
            using GIF1 = Field<0, 1>;    // Channel x global interrupt flag (x = 1 ..7)
        };

        // interrupt flag clear register
        struct IFCR : public Register<0x40020404> {
            using CTEIF7 = Field<27, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF7 = Field<26, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF7 = Field<25, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF7 = Field<24, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF6 = Field<23, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF6 = Field<22, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF6 = Field<21, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF6 = Field<20, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF5 = Field<19, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF5 = Field<18, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF5 = Field<17, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF5 = Field<16, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF4 = Field<15, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF4 = Field<14, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF4 = Field<13, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF4 = Field<12, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF3 = Field<11, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF3 = Field<10, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF3 = Field<9, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF3 = Field<8, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF2 = Field<7, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF2 = Field<6, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF2 = Field<5, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF2 = Field<4, 1>;    // Channel x global interrupt clear (x = 1 ..7)
            using CTEIF1 = Field<3, 1>;    // Channel x transfer error clear (x = 1 ..7)
            using CHTIF1 = Field<2, 1>;    // Channel x half transfer clear (x = 1 ..7)
            using CTCIF1 = Field<1, 1>;    // Channel x transfer complete clear (x = 1 ..7)
            using CGIF1 = Field<0, 1>;    // Channel x global interrupt clear (x = 1 ..7)
        };

        // channel x configuration register
        struct CCR1 : public Register<0x40020408> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR1 : public Register<0x4002040c> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR1 : public Register<0x40020410> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR1 : public Register<0x40020414> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR2 : public Register<0x4002041c> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR2 : public Register<0x40020420> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR2 : public Register<0x40020424> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR2 : public Register<0x40020428> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR3 : public Register<0x40020430> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR3 : public Register<0x40020434> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR3 : public Register<0x40020438> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR3 : public Register<0x4002043c> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR4 : public Register<0x40020444> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR4 : public Register<0x40020448> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR4 : public Register<0x4002044c> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR4 : public Register<0x40020450> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR5 : public Register<0x40020458> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR5 : public Register<0x4002045c> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR5 : public Register<0x40020460> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR5 : public Register<0x40020464> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR6 : public Register<0x4002046c> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR6 : public Register<0x40020470> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR6 : public Register<0x40020474> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR6 : public Register<0x40020478> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel x configuration register
        struct CCR7 : public Register<0x40020480> {
            using MEM2MEM = Field<14, 1>;    // Memory to memory mode
            using PL = Field<12, 2>;    // Channel priority level
            using MSIZE = Field<10, 2>;    // Memory size
            using PSIZE = Field<8, 2>;    // Peripheral size
            using MINC = Field<7, 1>;    // Memory increment mode
            using PINC = Field<6, 1>;    // Peripheral increment mode
            using CIRC = Field<5, 1>;    // Circular mode
            using DIR = Field<4, 1>;    // Data transfer direction
            using TEIE = Field<3, 1>;    // Transfer error interrupt enable
            using HTIE = Field<2, 1>;    // Half transfer interrupt enable
            using TCIE = Field<1, 1>;    // Transfer complete interrupt enable
            using EN = Field<0, 1>;    // Channel enable
        };

        // channel x number of data register
        struct CNDTR7 : public Register<0x40020484> {
            using NDT = Field<0, 16>;    // Number of data to transfer
        };

        // channel x peripheral address register
        struct CPAR7 : public Register<0x40020488> {
            using PA = Field<0, 32>;    // Peripheral address
        };

        // channel x memory address register
        struct CMAR7 : public Register<0x4002048c> {
            using MA = Field<0, 32>;    // Memory address
        };

        // channel selection register
        struct CSELR : public Register<0x400204a8> {
            using C7S = Field<24, 4>;    // DMA channel 7 selection
            using C6S = Field<20, 4>;    // DMA channel 6 selection
            using C5S = Field<16, 4>;    // DMA channel 5 selection
            using C4S = Field<12, 4>;    // DMA channel 4 selection
            using C3S = Field<8, 4>;    // DMA channel 3 selection
            using C2S = Field<4, 4>;    // DMA channel 2 selection
            using C1S = Field<0, 4>;    // DMA channel 1 selection
        };

    };

    // Cyclic redundancy check calculation unit
    struct CRC {
        // Data register
        struct DR : public Register<0x40023000> {
            using Field = Field<0, 32>;    // Data register bits
        };

        // Independent data register
        struct IDR : public Register<0x40023004> {
            using Field = Field<0, 8>;    // General-purpose 8-bit data register bits
        };

        // Control register
        struct CR : public Register<0x40023008> {
            using REV_OUT = Field<7, 1>;    // Reverse output data
            using REV_IN = Field<5, 2>;    // Reverse input data
            using POLYSIZE = Field<3, 2>;    // Polynomial size
            using RESET = Field<0, 1>;    // RESET bit
        };

        // Initial CRC value
        struct INIT : public Register<0x40023010> {
            using CRC_INIT = Field<0, 32>;    // Programmable initial CRC value
        };

        // polynomial
        struct POL : public Register<0x40023014> {
            using Polynomialcoefficients = Field<0, 32>;    // Programmable polynomial
        };

    };

    // Liquid crystal display controller
    struct LTCD {
        // LTDC Synchronization Size Configuration Register
        struct SSCR : public Register<0x40016808> {
            using VSH = Field<0, 11>;    // Vertical Synchronization Height (in units of horizontal scan line)
            using HSW = Field<16, 12>;    // Horizontal Synchronization Width (in units of pixel clock period)
        };

        // LTDC Back Porch Configuration Register
        struct BPCR : public Register<0x4001680c> {
            using AVBP = Field<0, 11>;    // Accumulated Vertical back porch (in units of horizontal scan line)
            using AHBP = Field<16, 12>;    // Accumulated Horizontal back porch (in units of pixel clock period)
        };

        // LTDC Active Width Configuration Register
        struct AWCR : public Register<0x40016810> {
            using AAH = Field<0, 11>;    // Accumulated Active Height (in units of horizontal scan line)
            using AAW = Field<16, 12>;    // Accumulated Active Width (in units of pixel clock period)
        };

        // LTDC Total Width Configuration Register
        struct TWCR : public Register<0x40016814> {
            using TOTALH = Field<0, 11>;    // Total Height (in units of horizontal scan line)
            using TOTALW = Field<16, 12>;    // Total Width (in units of pixel clock period)
        };

        // LTDC Global Control Register
        struct GCR : public Register<0x40016818> {
            using LTDCEN = Field<0, 1>;    // LCD-TFT controller enable bit
            using DBW = Field<4, 3>;    // Dither Blue Width
            using DGW = Field<8, 3>;    // Dither Green Width
            using DRW = Field<12, 3>;    // Dither Red Width
            using DEN = Field<16, 1>;    // Dither Enable
            using PCPOL = Field<28, 1>;    // Pixel Clock Polarity
            using DEPOL = Field<29, 1>;    // Not Data Enable Polarity
            using VSPOL = Field<30, 1>;    // Vertical Synchronization Polarity
            using HSPOL = Field<31, 1>;    // Horizontal Synchronization Polarity
        };

        // LTDC Shadow Reload Configuration Register
        struct SRCR : public Register<0x40016824> {
            using IMR = Field<0, 1>;    // Immediate Reload
            using VBR = Field<1, 1>;    // Vertical Blanking Reload
        };

        // LTDC Background Color Configuration Register
        struct BCCR : public Register<0x4001682c> {
            using BCBLUE = Field<0, 8>;    // Background Color Blue value
            using BCGREEN = Field<8, 8>;    // Background Color Green value
            using BCRED = Field<16, 8>;    // Background Color Red value
        };

        // LTDC Interrupt Enable Register
        struct IER : public Register<0x40016834> {
            using LIE = Field<0, 1>;    // Line Interrupt Enable
            using FUIE = Field<1, 1>;    // FIFO Underrun Interrupt Enable
            using TERRIE = Field<2, 1>;    // Transfer Error Interrupt Enable
            using RRIE = Field<3, 1>;    // Register Reload interrupt enable
        };

        // LTDC Interrupt Status Register
        struct ISR : public Register<0x40016838> {
            using LIF = Field<0, 1>;    // Line Interrupt flag
            using FUIF = Field<1, 1>;    // FIFO Underrun Interrupt flag
            using TERRIF = Field<2, 1>;    // Transfer Error interrupt flag
            using RRIF = Field<3, 1>;    // Register Reload Interrupt Flag
        };

        // LTDC Interrupt Clear Register
        struct ICR : public Register<0x4001683c> {
            using CLIF = Field<0, 1>;    // Clears the Line Interrupt Flag
            using CFUIF = Field<1, 1>;    // Clears the FIFO Underrun Interrupt flag
            using CTERRIF = Field<2, 1>;    // Clears the Transfer Error Interrupt Flag
            using CRRIF = Field<3, 1>;    // Clears Register Reload Interrupt Flag
        };

        // LTDC Line Interrupt Position Configuration Register
        struct LIPCR : public Register<0x40016840> {
            using LIPOS = Field<0, 11>;    // Line Interrupt Position
        };

        // LTDC Current Position Status Register
        struct CPSR : public Register<0x40016844> {
            using CYPOS = Field<0, 16>;    // Current Y Position
            using CXPOS = Field<16, 16>;    // Current X Position
        };

        // LTDC Current Display Status Register
        struct CDSR : public Register<0x40016848> {
            using VDES = Field<0, 1>;    // Vertical Data Enable display Status
            using HDES = Field<1, 1>;    // Horizontal Data Enable display Status
            using VSYNCS = Field<2, 1>;    // Vertical Synchronization display Status
            using HSYNCS = Field<3, 1>;    // Horizontal Synchronization display Status
        };

        // LTDC Layer Control Register
        struct L1CR : public Register<0x40016884> {
            using LEN = Field<0, 1>;    // Layer Enable
            using COLKEN = Field<1, 1>;    // Color Keying Enable
            using CLUTEN = Field<4, 1>;    // Color Look-Up Table Enable
        };

        // LTDC Layer Control Register
        struct L2CR : public Register<0x40016904> {
            using LEN = Field<0, 1>;    // Layer Enable
            using COLKEN = Field<1, 1>;    // Color Keying Enable
            using CLUTEN = Field<4, 1>;    // Color Look-Up Table Enable
        };

        // LTDC Layer Window Horizontal Position Configuration Register
        struct L1WHPCR : public Register<0x40016888> {
            using WHSTPOS = Field<0, 12>;    // Window Horizontal Start Position
            using WHSPPOS = Field<16, 12>;    // Window Horizontal Stop Position
        };

        // LTDC Layerx Window Horizontal Position Configuration Register
        struct L2WHPCR : public Register<0x40016908> {
            using WHSTPOS = Field<0, 12>;    // Window Horizontal Start Position
            using WHSPPOS = Field<16, 12>;    // Window Horizontal Stop Position
        };

        // LTDC Layer Window Vertical Position Configuration Register
        struct L1WVPCR : public Register<0x4001688c> {
            using WVSTPOS = Field<0, 11>;    // Window Vertical Start Position
            using WVSPPOS = Field<16, 11>;    // Window Vertical Stop Position
        };

        // LTDC Layer Window Vertical Position Configuration Register
        struct L2WVPCR : public Register<0x4001690c> {
            using WVSTPOS = Field<0, 11>;    // Window Vertical Start Position
            using WVSPPOS = Field<16, 11>;    // Window Vertical Stop Position
        };

        // LTDC Layer Color Keying Configuration Register
        struct L1CKCR : public Register<0x40016890> {
            using CKBLUE = Field<0, 8>;    // Color Key Blue value
            using CKGREEN = Field<8, 8>;    // Color Key Green value
            using CKRED = Field<16, 8>;    // Color Key Red value
        };

        // LTDC Layer Color Keying Configuration Register
        struct L2CKCR : public Register<0x40016910> {
            using CKBLUE = Field<0, 8>;    // Color Key Blue value
            using CKGREEN = Field<8, 8>;    // Color Key Green value
            using CKRED = Field<16, 8>;    // Color Key Red value
        };

        // LTDC Layer Pixel Format Configuration Register
        struct L1PFCR : public Register<0x40016894> {
            using PF = Field<0, 3>;    // Pixel Format
        };

        // LTDC Layer Pixel Format Configuration Register
        struct L2PFCR : public Register<0x40016914> {
            using PF = Field<0, 3>;    // Pixel Format
        };

        // LTDC Layer Constant Alpha Configuration Register
        struct L1CACR : public Register<0x40016898> {
            using CONSTA = Field<0, 8>;    // Constant Alpha
        };

        // LTDC Layer Constant Alpha Configuration Register
        struct L2CACR : public Register<0x40016918> {
            using CONSTA = Field<0, 8>;    // Constant Alpha
        };

        // LTDC Layer Default Color Configuration Register
        struct L1DCCR : public Register<0x4001689c> {
            using DCBLUE = Field<0, 8>;    // Default Color Blue
            using DCGREEN = Field<8, 8>;    // Default Color Green
            using DCRED = Field<16, 8>;    // Default Color Red
            using DCALPHA = Field<24, 8>;    // Default Color Alpha
        };

        // LTDC Layer Default Color Configuration Register
        struct L2DCCR : public Register<0x4001691c> {
            using DCBLUE = Field<0, 8>;    // Default Color Blue
            using DCGREEN = Field<8, 8>;    // Default Color Green
            using DCRED = Field<16, 8>;    // Default Color Red
            using DCALPHA = Field<24, 8>;    // Default Color Alpha
        };

        // LTDC Layer Blending Factors Configuration Register
        struct L1BFCR : public Register<0x400168a0> {
            using BF2 = Field<0, 3>;    // Blending Factor 2
            using BF1 = Field<8, 3>;    // Blending Factor 1
        };

        // LTDC Layer Blending Factors Configuration Register
        struct L2BFCR : public Register<0x40016924> {
            using BF2 = Field<0, 3>;    // Blending Factor 2
            using BF1 = Field<8, 3>;    // Blending Factor 1
        };

        // LTDC Layer Color Frame Buffer Address Register
        struct L1CFBAR : public Register<0x400168ac> {
            using CFBADD = Field<0, 32>;    // Color Frame Buffer Start Address
        };

        // LTDC Layer Color Frame Buffer Address Register
        struct L2CFBAR : public Register<0x4001692c> {
            using CFBADD = Field<0, 32>;    // Color Frame Buffer Start Address
        };

        // LTDC Layer Color Frame Buffer Length Register
        struct L1CFBLR : public Register<0x400168b0> {
            using CFBLL = Field<0, 13>;    // Color Frame Buffer Line Length
            using CFBP = Field<16, 13>;    // Color Frame Buffer Pitch in bytes
        };

        // LTDC Layer Color Frame Buffer Length Register
        struct L2CFBLR : public Register<0x40016930> {
            using CFBLL = Field<0, 13>;    // Color Frame Buffer Line Length
            using CFBP = Field<16, 13>;    // Color Frame Buffer Pitch in bytes
        };

        // LTDC Layer ColorFrame Buffer Line Number Register
        struct L1CFBLNR : public Register<0x400168b4> {
            using CFBLNBR = Field<0, 11>;    // Frame Buffer Line Number
        };

        // LTDC Layer ColorFrame Buffer Line Number Register
        struct L2CFBLNR : public Register<0x40016934> {
            using CFBLNBR = Field<0, 11>;    // Frame Buffer Line Number
        };

        // LTDC Layerx CLUT Write Register
        struct L1CLUTWR : public Register<0x400168c4> {
            using BLUE = Field<0, 8>;    // Blue value
            using GREEN = Field<8, 8>;    // Green value
            using RED = Field<16, 8>;    // Red value
            using CLUTADD = Field<24, 8>;    // CLUT Address
        };

        // LTDC Layerx CLUT Write Register
        struct L2CLUTWR : public Register<0x40016944> {
            using BLUE = Field<0, 8>;    // Blue value
            using GREEN = Field<8, 8>;    // Green value
            using RED = Field<16, 8>;    // Red value
            using CLUTADD = Field<24, 8>;    // CLUT Address
        };

    };

    // Touch sensing controller
    struct TSC {
        // control register
        struct CR : public Register<0x40024000> {
            using CTPH = Field<28, 4>;    // Charge transfer pulse high
            using CTPL = Field<24, 4>;    // Charge transfer pulse low
            using SSD = Field<17, 7>;    // Spread spectrum deviation
            using SSE = Field<16, 1>;    // Spread spectrum enable
            using SSPSC = Field<15, 1>;    // Spread spectrum prescaler
            using PGPSC = Field<12, 3>;    // pulse generator prescaler
            using MCV = Field<5, 3>;    // Max count value
            using IODEF = Field<4, 1>;    // I/O Default mode
            using SYNCPOL = Field<3, 1>;    // Synchronization pin polarity
            using AM = Field<2, 1>;    // Acquisition mode
            using START = Field<1, 1>;    // Start a new acquisition
            using TSCE = Field<0, 1>;    // Touch sensing controller enable
        };

        // interrupt enable register
        struct IER : public Register<0x40024004> {
            using MCEIE = Field<1, 1>;    // Max count error interrupt enable
            using EOAIE = Field<0, 1>;    // End of acquisition interrupt enable
        };

        // interrupt clear register
        struct ICR : public Register<0x40024008> {
            using MCEIC = Field<1, 1>;    // Max count error interrupt clear
            using EOAIC = Field<0, 1>;    // End of acquisition interrupt clear
        };

        // interrupt status register
        struct ISR : public Register<0x4002400c> {
            using MCEF = Field<1, 1>;    // Max count error flag
            using EOAF = Field<0, 1>;    // End of acquisition flag
        };

        // I/O hysteresis control register
        struct IOHCR : public Register<0x40024010> {
            using G8_IO4 = Field<31, 1>;    // G8_IO4
            using G8_IO3 = Field<30, 1>;    // G8_IO3
            using G8_IO2 = Field<29, 1>;    // G8_IO2
            using G8_IO1 = Field<28, 1>;    // G8_IO1
            using G7_IO4 = Field<27, 1>;    // G7_IO4
            using G7_IO3 = Field<26, 1>;    // G7_IO3
            using G7_IO2 = Field<25, 1>;    // G7_IO2
            using G7_IO1 = Field<24, 1>;    // G7_IO1
            using G6_IO4 = Field<23, 1>;    // G6_IO4
            using G6_IO3 = Field<22, 1>;    // G6_IO3
            using G6_IO2 = Field<21, 1>;    // G6_IO2
            using G6_IO1 = Field<20, 1>;    // G6_IO1
            using G5_IO4 = Field<19, 1>;    // G5_IO4
            using G5_IO3 = Field<18, 1>;    // G5_IO3
            using G5_IO2 = Field<17, 1>;    // G5_IO2
            using G5_IO1 = Field<16, 1>;    // G5_IO1
            using G4_IO4 = Field<15, 1>;    // G4_IO4
            using G4_IO3 = Field<14, 1>;    // G4_IO3
            using G4_IO2 = Field<13, 1>;    // G4_IO2
            using G4_IO1 = Field<12, 1>;    // G4_IO1
            using G3_IO4 = Field<11, 1>;    // G3_IO4
            using G3_IO3 = Field<10, 1>;    // G3_IO3
            using G3_IO2 = Field<9, 1>;    // G3_IO2
            using G3_IO1 = Field<8, 1>;    // G3_IO1
            using G2_IO4 = Field<7, 1>;    // G2_IO4
            using G2_IO3 = Field<6, 1>;    // G2_IO3
            using G2_IO2 = Field<5, 1>;    // G2_IO2
            using G2_IO1 = Field<4, 1>;    // G2_IO1
            using G1_IO4 = Field<3, 1>;    // G1_IO4
            using G1_IO3 = Field<2, 1>;    // G1_IO3
            using G1_IO2 = Field<1, 1>;    // G1_IO2
            using G1_IO1 = Field<0, 1>;    // G1_IO1
        };

        // I/O analog switch control register
        struct IOASCR : public Register<0x40024018> {
            using G8_IO4 = Field<31, 1>;    // G8_IO4
            using G8_IO3 = Field<30, 1>;    // G8_IO3
            using G8_IO2 = Field<29, 1>;    // G8_IO2
            using G8_IO1 = Field<28, 1>;    // G8_IO1
            using G7_IO4 = Field<27, 1>;    // G7_IO4
            using G7_IO3 = Field<26, 1>;    // G7_IO3
            using G7_IO2 = Field<25, 1>;    // G7_IO2
            using G7_IO1 = Field<24, 1>;    // G7_IO1
            using G6_IO4 = Field<23, 1>;    // G6_IO4
            using G6_IO3 = Field<22, 1>;    // G6_IO3
            using G6_IO2 = Field<21, 1>;    // G6_IO2
            using G6_IO1 = Field<20, 1>;    // G6_IO1
            using G5_IO4 = Field<19, 1>;    // G5_IO4
            using G5_IO3 = Field<18, 1>;    // G5_IO3
            using G5_IO2 = Field<17, 1>;    // G5_IO2
            using G5_IO1 = Field<16, 1>;    // G5_IO1
            using G4_IO4 = Field<15, 1>;    // G4_IO4
            using G4_IO3 = Field<14, 1>;    // G4_IO3
            using G4_IO2 = Field<13, 1>;    // G4_IO2
            using G4_IO1 = Field<12, 1>;    // G4_IO1
            using G3_IO4 = Field<11, 1>;    // G3_IO4
            using G3_IO3 = Field<10, 1>;    // G3_IO3
            using G3_IO2 = Field<9, 1>;    // G3_IO2
            using G3_IO1 = Field<8, 1>;    // G3_IO1
            using G2_IO4 = Field<7, 1>;    // G2_IO4
            using G2_IO3 = Field<6, 1>;    // G2_IO3
            using G2_IO2 = Field<5, 1>;    // G2_IO2
            using G2_IO1 = Field<4, 1>;    // G2_IO1
            using G1_IO4 = Field<3, 1>;    // G1_IO4
            using G1_IO3 = Field<2, 1>;    // G1_IO3
            using G1_IO2 = Field<1, 1>;    // G1_IO2
            using G1_IO1 = Field<0, 1>;    // G1_IO1
        };

        // I/O sampling control register
        struct IOSCR : public Register<0x40024020> {
            using G8_IO4 = Field<31, 1>;    // G8_IO4
            using G8_IO3 = Field<30, 1>;    // G8_IO3
            using G8_IO2 = Field<29, 1>;    // G8_IO2
            using G8_IO1 = Field<28, 1>;    // G8_IO1
            using G7_IO4 = Field<27, 1>;    // G7_IO4
            using G7_IO3 = Field<26, 1>;    // G7_IO3
            using G7_IO2 = Field<25, 1>;    // G7_IO2
            using G7_IO1 = Field<24, 1>;    // G7_IO1
            using G6_IO4 = Field<23, 1>;    // G6_IO4
            using G6_IO3 = Field<22, 1>;    // G6_IO3
            using G6_IO2 = Field<21, 1>;    // G6_IO2
            using G6_IO1 = Field<20, 1>;    // G6_IO1
            using G5_IO4 = Field<19, 1>;    // G5_IO4
            using G5_IO3 = Field<18, 1>;    // G5_IO3
            using G5_IO2 = Field<17, 1>;    // G5_IO2
            using G5_IO1 = Field<16, 1>;    // G5_IO1
            using G4_IO4 = Field<15, 1>;    // G4_IO4
            using G4_IO3 = Field<14, 1>;    // G4_IO3
            using G4_IO2 = Field<13, 1>;    // G4_IO2
            using G4_IO1 = Field<12, 1>;    // G4_IO1
            using G3_IO4 = Field<11, 1>;    // G3_IO4
            using G3_IO3 = Field<10, 1>;    // G3_IO3
            using G3_IO2 = Field<9, 1>;    // G3_IO2
            using G3_IO1 = Field<8, 1>;    // G3_IO1
            using G2_IO4 = Field<7, 1>;    // G2_IO4
            using G2_IO3 = Field<6, 1>;    // G2_IO3
            using G2_IO2 = Field<5, 1>;    // G2_IO2
            using G2_IO1 = Field<4, 1>;    // G2_IO1
            using G1_IO4 = Field<3, 1>;    // G1_IO4
            using G1_IO3 = Field<2, 1>;    // G1_IO3
            using G1_IO2 = Field<1, 1>;    // G1_IO2
            using G1_IO1 = Field<0, 1>;    // G1_IO1
        };

        // I/O channel control register
        struct IOCCR : public Register<0x40024028> {
            using G8_IO4 = Field<31, 1>;    // G8_IO4
            using G8_IO3 = Field<30, 1>;    // G8_IO3
            using G8_IO2 = Field<29, 1>;    // G8_IO2
            using G8_IO1 = Field<28, 1>;    // G8_IO1
            using G7_IO4 = Field<27, 1>;    // G7_IO4
            using G7_IO3 = Field<26, 1>;    // G7_IO3
            using G7_IO2 = Field<25, 1>;    // G7_IO2
            using G7_IO1 = Field<24, 1>;    // G7_IO1
            using G6_IO4 = Field<23, 1>;    // G6_IO4
            using G6_IO3 = Field<22, 1>;    // G6_IO3
            using G6_IO2 = Field<21, 1>;    // G6_IO2
            using G6_IO1 = Field<20, 1>;    // G6_IO1
            using G5_IO4 = Field<19, 1>;    // G5_IO4
            using G5_IO3 = Field<18, 1>;    // G5_IO3
            using G5_IO2 = Field<17, 1>;    // G5_IO2
            using G5_IO1 = Field<16, 1>;    // G5_IO1
            using G4_IO4 = Field<15, 1>;    // G4_IO4
            using G4_IO3 = Field<14, 1>;    // G4_IO3
            using G4_IO2 = Field<13, 1>;    // G4_IO2
            using G4_IO1 = Field<12, 1>;    // G4_IO1
            using G3_IO4 = Field<11, 1>;    // G3_IO4
            using G3_IO3 = Field<10, 1>;    // G3_IO3
            using G3_IO2 = Field<9, 1>;    // G3_IO2
            using G3_IO1 = Field<8, 1>;    // G3_IO1
            using G2_IO4 = Field<7, 1>;    // G2_IO4
            using G2_IO3 = Field<6, 1>;    // G2_IO3
            using G2_IO2 = Field<5, 1>;    // G2_IO2
            using G2_IO1 = Field<4, 1>;    // G2_IO1
            using G1_IO4 = Field<3, 1>;    // G1_IO4
            using G1_IO3 = Field<2, 1>;    // G1_IO3
            using G1_IO2 = Field<1, 1>;    // G1_IO2
            using G1_IO1 = Field<0, 1>;    // G1_IO1
        };

        // I/O group control status register
        struct IOGCSR : public Register<0x40024030> {
            using G8S = Field<23, 1>;    // Analog I/O group x status
            using G7S = Field<22, 1>;    // Analog I/O group x status
            using G6S = Field<21, 1>;    // Analog I/O group x status
            using G5S = Field<20, 1>;    // Analog I/O group x status
            using G4S = Field<19, 1>;    // Analog I/O group x status
            using G3S = Field<18, 1>;    // Analog I/O group x status
            using G2S = Field<17, 1>;    // Analog I/O group x status
            using G1S = Field<16, 1>;    // Analog I/O group x status
            using G8E = Field<7, 1>;    // Analog I/O group x enable
            using G7E = Field<6, 1>;    // Analog I/O group x enable
            using G6E = Field<5, 1>;    // Analog I/O group x enable
            using G5E = Field<4, 1>;    // Analog I/O group x enable
            using G4E = Field<3, 1>;    // Analog I/O group x enable
            using G3E = Field<2, 1>;    // Analog I/O group x enable
            using G2E = Field<1, 1>;    // Analog I/O group x enable
            using G1E = Field<0, 1>;    // Analog I/O group x enable
        };

        // I/O group x counter register
        struct IOG1CR : public Register<0x40024034> {
            using CNT = Field<0, 14>;    // Counter value
        };

        // I/O group x counter register
        struct IOG2CR : public Register<0x40024038> {
            using CNT = Field<0, 14>;    // Counter value
        };

        // I/O group x counter register
        struct IOG3CR : public Register<0x4002403c> {
            using CNT = Field<0, 14>;    // Counter value
        };

        // I/O group x counter register
        struct IOG4CR : public Register<0x40024040> {
            using CNT = Field<0, 14>;    // Counter value
        };

        // I/O group x counter register
        struct IOG5CR : public Register<0x40024044> {
            using CNT = Field<0, 14>;    // Counter value
        };

        // I/O group x counter register
        struct IOG6CR : public Register<0x40024048> {
            using CNT = Field<0, 14>;    // Counter value
        };

        // I/O group x counter register
        struct IOG7CR : public Register<0x4002404c> {
            using CNT = Field<0, 14>;    // Counter value
        };

        // I/O group x counter register
        struct IOG8CR : public Register<0x40024050> {
            using CNT = Field<0, 14>;    // Counter value
        };

    };

    // Independent watchdog
    struct IWDG {
        // Key register
        struct KR : public Register<0x40003000> {
            using KEY = Field<0, 16>;    // Key value (write only, read 0x0000)
        };

        // Prescaler register
        struct PR : public Register<0x40003004> {
            using Field = Field<0, 3>;    // Prescaler divider
        };

        // Reload register
        struct RLR : public Register<0x40003008> {
            using RL = Field<0, 12>;    // Watchdog counter reload value
        };

        // Status register
        struct SR : public Register<0x4000300c> {
            using WVU = Field<2, 1>;    // Watchdog counter window value update
            using RVU = Field<1, 1>;    // Watchdog counter reload value update
            using PVU = Field<0, 1>;    // Watchdog prescaler value update
        };

        // Window register
        struct WINR : public Register<0x40003010> {
            using WIN = Field<0, 12>;    // Watchdog counter window value
        };

    };

    // System window watchdog
    struct WWDG {
        // Control register
        struct CR : public Register<0x40002c00> {
            using WDGA = Field<7, 1>;    // Activation bit
            using T = Field<0, 7>;    // 7-bit counter (MSB to LSB)
        };

        // Configuration register
        struct CFR : public Register<0x40002c04> {
            using EWI = Field<9, 1>;    // Early wakeup interrupt
            using WDGTB = Field<7, 2>;    // Timer base
            using W = Field<0, 7>;    // 7-bit window value
        };

        // Status register
        struct SR : public Register<0x40002c08> {
            using EWIF = Field<0, 1>;    // Early wakeup interrupt flag
        };

    };

    // Comparator
    struct COMP {
        // Comparator 1 control and status register
        struct COMP1_CSR : public Register<0x40010200> {
            using COMP1_EN = Field<0, 1>;    // Comparator 1 enable bit
            using COMP1_PWRMODE = Field<2, 2>;    // Power Mode of the comparator 1
            using COMP1_INMSEL = Field<4, 3>;    // Comparator 1 Input Minus connection configuration bit
            using COMP1_INPSEL = Field<7, 1>;    // Comparator1 input plus selection bit
            using COMP1_POLARITY = Field<15, 1>;    // Comparator 1 polarity selection bit
            using COMP1_HYST = Field<16, 2>;    // Comparator 1 hysteresis selection bits
            using COMP1_BLANKING = Field<18, 3>;    // Comparator 1 blanking source selection bits
            using COMP1_BRGEN = Field<22, 1>;    // Scaler bridge enable
            using COMP1_SCALEN = Field<23, 1>;    // Voltage scaler enable bit
            using COMP1_VALUE = Field<30, 1>;    // Comparator 1 output status bit
            using COMP1_LOCK = Field<31, 1>;    // COMP1_CSR register lock bit
        };

        // Comparator 2 control and status register
        struct COMP2_CSR : public Register<0x40010204> {
            using COMP2_EN = Field<0, 1>;    // Comparator 2 enable bit
            using COMP2_PWRMODE = Field<2, 2>;    // Power Mode of the comparator 2
            using COMP2_INMSEL = Field<4, 3>;    // Comparator 2 Input Minus connection configuration bit
            using COMP2_INPSEL = Field<7, 1>;    // Comparator 2 Input Plus connection configuration bit
            using COMP2_WINMODE = Field<9, 1>;    // Windows mode selection bit
            using COMP2_POLARITY = Field<15, 1>;    // Comparator 2 polarity selection bit
            using COMP2_HYST = Field<16, 2>;    // Comparator 2 hysteresis selection bits
            using COMP2_BLANKING = Field<18, 3>;    // Comparator 2 blanking source selection bits
            using COMP2_BRGEN = Field<22, 1>;    // Scaler bridge enable
            using COMP2_SCALEN = Field<23, 1>;    // Voltage scaler enable bit
            using COMP2_VALUE = Field<30, 1>;    // Comparator 2 output status bit
            using COMP2_LOCK = Field<31, 1>;    // COMP2_CSR register lock bit
        };

    };

    // Firewall
    struct FIREWALL {
        // Code segment start address
        struct CSSA : public Register<0x40011c00> {
            using ADD = Field<8, 16>;    // code segment start address
        };

        // Code segment length
        struct CSL : public Register<0x40011c04> {
            using LENG = Field<8, 14>;    // code segment length
        };

        // Non-volatile data segment start address
        struct NVDSSA : public Register<0x40011c08> {
            using ADD = Field<8, 16>;    // Non-volatile data segment start address
        };

        // Non-volatile data segment length
        struct NVDSL : public Register<0x40011c0c> {
            using LENG = Field<8, 14>;    // Non-volatile data segment length
        };

        // Volatile data segment start address
        struct VDSSA : public Register<0x40011c10> {
            using ADD = Field<6, 10>;    // Volatile data segment start address
        };

        // Volatile data segment length
        struct VDSL : public Register<0x40011c14> {
            using LENG = Field<6, 10>;    // Non-volatile data segment length
        };

        // Configuration register
        struct CR : public Register<0x40011c20> {
            using VDE = Field<2, 1>;    // Volatile data execution
            using VDS = Field<1, 1>;    // Volatile data shared
            using FPA = Field<0, 1>;    // Firewall pre alarm
        };

    };

    // Inter-integrated circuit
    struct I2C1 {
        // Control register 1
        struct CR1 : public Register<0x40005400> {
            using PE = Field<0, 1>;    // Peripheral enable
            using TXIE = Field<1, 1>;    // TX Interrupt enable
            using RXIE = Field<2, 1>;    // RX Interrupt enable
            using ADDRIE = Field<3, 1>;    // Address match interrupt enable (slave only)
            using NACKIE = Field<4, 1>;    // Not acknowledge received interrupt enable
            using STOPIE = Field<5, 1>;    // STOP detection Interrupt enable
            using TCIE = Field<6, 1>;    // Transfer Complete interrupt enable
            using ERRIE = Field<7, 1>;    // Error interrupts enable
            using DNF = Field<8, 4>;    // Digital noise filter
            using ANFOFF = Field<12, 1>;    // Analog noise filter OFF
            using TXDMAEN = Field<14, 1>;    // DMA transmission requests enable
            using RXDMAEN = Field<15, 1>;    // DMA reception requests enable
            using SBC = Field<16, 1>;    // Slave byte control
            using NOSTRETCH = Field<17, 1>;    // Clock stretching disable
            using WUPEN = Field<18, 1>;    // Wakeup from STOP enable
            using GCEN = Field<19, 1>;    // General call enable
            using SMBHEN = Field<20, 1>;    // SMBus Host address enable
            using SMBDEN = Field<21, 1>;    // SMBus Device Default address enable
            using ALERTEN = Field<22, 1>;    // SMBUS alert enable
            using PECEN = Field<23, 1>;    // PEC enable
        };

        // Control register 2
        struct CR2 : public Register<0x40005404> {
            using PECBYTE = Field<26, 1>;    // Packet error checking byte
            using AUTOEND = Field<25, 1>;    // Automatic end mode (master mode)
            using RELOAD = Field<24, 1>;    // NBYTES reload mode
            using NBYTES = Field<16, 8>;    // Number of bytes
            using NACK = Field<15, 1>;    // NACK generation (slave mode)
            using STOP = Field<14, 1>;    // Stop generation (master mode)
            using START = Field<13, 1>;    // Start generation
            using HEAD10R = Field<12, 1>;    // 10-bit address header only read direction (master receiver mode)
            using ADD10 = Field<11, 1>;    // 10-bit addressing mode (master mode)
            using RD_WRN = Field<10, 1>;    // Transfer direction (master mode)
            using SADD = Field<0, 10>;    // Slave address bit (master mode)
        };

        // Own address register 1
        struct OAR1 : public Register<0x40005408> {
            using OA1 = Field<0, 10>;    // Interface address
            using OA1MODE = Field<10, 1>;    // Own Address 1 10-bit mode
            using OA1EN = Field<15, 1>;    // Own Address 1 enable
        };

        // Own address register 2
        struct OAR2 : public Register<0x4000540c> {
            using OA2 = Field<1, 7>;    // Interface address
            using OA2MSK = Field<8, 3>;    // Own Address 2 masks
            using OA2EN = Field<15, 1>;    // Own Address 2 enable
        };

        // Timing register
        struct TIMINGR : public Register<0x40005410> {
            using SCLL = Field<0, 8>;    // SCL low period (master mode)
            using SCLH = Field<8, 8>;    // SCL high period (master mode)
            using SDADEL = Field<16, 4>;    // Data hold time
            using SCLDEL = Field<20, 4>;    // Data setup time
            using PRESC = Field<28, 4>;    // Timing prescaler
        };

        // Status register 1
        struct TIMEOUTR : public Register<0x40005414> {
            using TIMEOUTA = Field<0, 12>;    // Bus timeout A
            using TIDLE = Field<12, 1>;    // Idle clock timeout detection
            using TIMOUTEN = Field<15, 1>;    // Clock timeout enable
            using TIMEOUTB = Field<16, 12>;    // Bus timeout B
            using TEXTEN = Field<31, 1>;    // Extended clock timeout enable
        };

        // Interrupt and Status register
        struct ISR : public Register<0x40005418> {
            using ADDCODE = Field<17, 7>;    // Address match code (Slave mode)
            using DIR = Field<16, 1>;    // Transfer direction (Slave mode)
            using BUSY = Field<15, 1>;    // Bus busy
            using ALERT = Field<13, 1>;    // SMBus alert
            using TIMEOUT = Field<12, 1>;    // Timeout or t_low detection flag
            using PECERR = Field<11, 1>;    // PEC Error in reception
            using OVR = Field<10, 1>;    // Overrun/Underrun (slave mode)
            using ARLO = Field<9, 1>;    // Arbitration lost
            using BERR = Field<8, 1>;    // Bus error
            using TCR = Field<7, 1>;    // Transfer Complete Reload
            using TC = Field<6, 1>;    // Transfer Complete (master mode)
            using STOPF = Field<5, 1>;    // Stop detection flag
            using NACKF = Field<4, 1>;    // Not acknowledge received flag
            using ADDR = Field<3, 1>;    // Address matched (slave mode)
            using RXNE = Field<2, 1>;    // Receive data register not empty (receivers)
            using TXIS = Field<1, 1>;    // Transmit interrupt status (transmitters)
            using TXE = Field<0, 1>;    // Transmit data register empty (transmitters)
        };

        // Interrupt clear register
        struct ICR : public Register<0x4000541c> {
            using ALERTCF = Field<13, 1>;    // Alert flag clear
            using TIMOUTCF = Field<12, 1>;    // Timeout detection flag clear
            using PECCF = Field<11, 1>;    // PEC Error flag clear
            using OVRCF = Field<10, 1>;    // Overrun/Underrun flag clear
            using ARLOCF = Field<9, 1>;    // Arbitration lost flag clear
            using BERRCF = Field<8, 1>;    // Bus error flag clear
            using STOPCF = Field<5, 1>;    // Stop detection flag clear
            using NACKCF = Field<4, 1>;    // Not Acknowledge flag clear
            using ADDRCF = Field<3, 1>;    // Address Matched flag clear
        };

        // PEC register
        struct PECR : public Register<0x40005420> {
            using PEC = Field<0, 8>;    // Packet error checking register
        };

        // Receive data register
        struct RXDR : public Register<0x40005424> {
            using RXDATA = Field<0, 8>;    // 8-bit receive data
        };

        // Transmit data register
        struct TXDR : public Register<0x40005428> {
            using TXDATA = Field<0, 8>;    // 8-bit transmit data
        };

    };

    // Inter-integrated circuit
    struct I2C2 {
        // Control register 1
        struct CR1 : public Register<0x40005800> {
            using PE = Field<0, 1>;    // Peripheral enable
            using TXIE = Field<1, 1>;    // TX Interrupt enable
            using RXIE = Field<2, 1>;    // RX Interrupt enable
            using ADDRIE = Field<3, 1>;    // Address match interrupt enable (slave only)
            using NACKIE = Field<4, 1>;    // Not acknowledge received interrupt enable
            using STOPIE = Field<5, 1>;    // STOP detection Interrupt enable
            using TCIE = Field<6, 1>;    // Transfer Complete interrupt enable
            using ERRIE = Field<7, 1>;    // Error interrupts enable
            using DNF = Field<8, 4>;    // Digital noise filter
            using ANFOFF = Field<12, 1>;    // Analog noise filter OFF
            using TXDMAEN = Field<14, 1>;    // DMA transmission requests enable
            using RXDMAEN = Field<15, 1>;    // DMA reception requests enable
            using SBC = Field<16, 1>;    // Slave byte control
            using NOSTRETCH = Field<17, 1>;    // Clock stretching disable
            using WUPEN = Field<18, 1>;    // Wakeup from STOP enable
            using GCEN = Field<19, 1>;    // General call enable
            using SMBHEN = Field<20, 1>;    // SMBus Host address enable
            using SMBDEN = Field<21, 1>;    // SMBus Device Default address enable
            using ALERTEN = Field<22, 1>;    // SMBUS alert enable
            using PECEN = Field<23, 1>;    // PEC enable
        };

        // Control register 2
        struct CR2 : public Register<0x40005804> {
            using PECBYTE = Field<26, 1>;    // Packet error checking byte
            using AUTOEND = Field<25, 1>;    // Automatic end mode (master mode)
            using RELOAD = Field<24, 1>;    // NBYTES reload mode
            using NBYTES = Field<16, 8>;    // Number of bytes
            using NACK = Field<15, 1>;    // NACK generation (slave mode)
            using STOP = Field<14, 1>;    // Stop generation (master mode)
            using START = Field<13, 1>;    // Start generation
            using HEAD10R = Field<12, 1>;    // 10-bit address header only read direction (master receiver mode)
            using ADD10 = Field<11, 1>;    // 10-bit addressing mode (master mode)
            using RD_WRN = Field<10, 1>;    // Transfer direction (master mode)
            using SADD = Field<0, 10>;    // Slave address bit (master mode)
        };

        // Own address register 1
        struct OAR1 : public Register<0x40005808> {
            using OA1 = Field<0, 10>;    // Interface address
            using OA1MODE = Field<10, 1>;    // Own Address 1 10-bit mode
            using OA1EN = Field<15, 1>;    // Own Address 1 enable
        };

        // Own address register 2
        struct OAR2 : public Register<0x4000580c> {
            using OA2 = Field<1, 7>;    // Interface address
            using OA2MSK = Field<8, 3>;    // Own Address 2 masks
            using OA2EN = Field<15, 1>;    // Own Address 2 enable
        };

        // Timing register
        struct TIMINGR : public Register<0x40005810> {
            using SCLL = Field<0, 8>;    // SCL low period (master mode)
            using SCLH = Field<8, 8>;    // SCL high period (master mode)
            using SDADEL = Field<16, 4>;    // Data hold time
            using SCLDEL = Field<20, 4>;    // Data setup time
            using PRESC = Field<28, 4>;    // Timing prescaler
        };

        // Status register 1
        struct TIMEOUTR : public Register<0x40005814> {
            using TIMEOUTA = Field<0, 12>;    // Bus timeout A
            using TIDLE = Field<12, 1>;    // Idle clock timeout detection
            using TIMOUTEN = Field<15, 1>;    // Clock timeout enable
            using TIMEOUTB = Field<16, 12>;    // Bus timeout B
            using TEXTEN = Field<31, 1>;    // Extended clock timeout enable
        };

        // Interrupt and Status register
        struct ISR : public Register<0x40005818> {
            using ADDCODE = Field<17, 7>;    // Address match code (Slave mode)
            using DIR = Field<16, 1>;    // Transfer direction (Slave mode)
            using BUSY = Field<15, 1>;    // Bus busy
            using ALERT = Field<13, 1>;    // SMBus alert
            using TIMEOUT = Field<12, 1>;    // Timeout or t_low detection flag
            using PECERR = Field<11, 1>;    // PEC Error in reception
            using OVR = Field<10, 1>;    // Overrun/Underrun (slave mode)
            using ARLO = Field<9, 1>;    // Arbitration lost
            using BERR = Field<8, 1>;    // Bus error
            using TCR = Field<7, 1>;    // Transfer Complete Reload
            using TC = Field<6, 1>;    // Transfer Complete (master mode)
            using STOPF = Field<5, 1>;    // Stop detection flag
            using NACKF = Field<4, 1>;    // Not acknowledge received flag
            using ADDR = Field<3, 1>;    // Address matched (slave mode)
            using RXNE = Field<2, 1>;    // Receive data register not empty (receivers)
            using TXIS = Field<1, 1>;    // Transmit interrupt status (transmitters)
            using TXE = Field<0, 1>;    // Transmit data register empty (transmitters)
        };

        // Interrupt clear register
        struct ICR : public Register<0x4000581c> {
            using ALERTCF = Field<13, 1>;    // Alert flag clear
            using TIMOUTCF = Field<12, 1>;    // Timeout detection flag clear
            using PECCF = Field<11, 1>;    // PEC Error flag clear
            using OVRCF = Field<10, 1>;    // Overrun/Underrun flag clear
            using ARLOCF = Field<9, 1>;    // Arbitration lost flag clear
            using BERRCF = Field<8, 1>;    // Bus error flag clear
            using STOPCF = Field<5, 1>;    // Stop detection flag clear
            using NACKCF = Field<4, 1>;    // Not Acknowledge flag clear
            using ADDRCF = Field<3, 1>;    // Address Matched flag clear
        };

        // PEC register
        struct PECR : public Register<0x40005820> {
            using PEC = Field<0, 8>;    // Packet error checking register
        };

        // Receive data register
        struct RXDR : public Register<0x40005824> {
            using RXDATA = Field<0, 8>;    // 8-bit receive data
        };

        // Transmit data register
        struct TXDR : public Register<0x40005828> {
            using TXDATA = Field<0, 8>;    // 8-bit transmit data
        };

    };

    // Inter-integrated circuit
    struct I2C3 {
        // Control register 1
        struct CR1 : public Register<0x40005c00> {
            using PE = Field<0, 1>;    // Peripheral enable
            using TXIE = Field<1, 1>;    // TX Interrupt enable
            using RXIE = Field<2, 1>;    // RX Interrupt enable
            using ADDRIE = Field<3, 1>;    // Address match interrupt enable (slave only)
            using NACKIE = Field<4, 1>;    // Not acknowledge received interrupt enable
            using STOPIE = Field<5, 1>;    // STOP detection Interrupt enable
            using TCIE = Field<6, 1>;    // Transfer Complete interrupt enable
            using ERRIE = Field<7, 1>;    // Error interrupts enable
            using DNF = Field<8, 4>;    // Digital noise filter
            using ANFOFF = Field<12, 1>;    // Analog noise filter OFF
            using TXDMAEN = Field<14, 1>;    // DMA transmission requests enable
            using RXDMAEN = Field<15, 1>;    // DMA reception requests enable
            using SBC = Field<16, 1>;    // Slave byte control
            using NOSTRETCH = Field<17, 1>;    // Clock stretching disable
            using WUPEN = Field<18, 1>;    // Wakeup from STOP enable
            using GCEN = Field<19, 1>;    // General call enable
            using SMBHEN = Field<20, 1>;    // SMBus Host address enable
            using SMBDEN = Field<21, 1>;    // SMBus Device Default address enable
            using ALERTEN = Field<22, 1>;    // SMBUS alert enable
            using PECEN = Field<23, 1>;    // PEC enable
        };

        // Control register 2
        struct CR2 : public Register<0x40005c04> {
            using PECBYTE = Field<26, 1>;    // Packet error checking byte
            using AUTOEND = Field<25, 1>;    // Automatic end mode (master mode)
            using RELOAD = Field<24, 1>;    // NBYTES reload mode
            using NBYTES = Field<16, 8>;    // Number of bytes
            using NACK = Field<15, 1>;    // NACK generation (slave mode)
            using STOP = Field<14, 1>;    // Stop generation (master mode)
            using START = Field<13, 1>;    // Start generation
            using HEAD10R = Field<12, 1>;    // 10-bit address header only read direction (master receiver mode)
            using ADD10 = Field<11, 1>;    // 10-bit addressing mode (master mode)
            using RD_WRN = Field<10, 1>;    // Transfer direction (master mode)
            using SADD = Field<0, 10>;    // Slave address bit (master mode)
        };

        // Own address register 1
        struct OAR1 : public Register<0x40005c08> {
            using OA1 = Field<0, 10>;    // Interface address
            using OA1MODE = Field<10, 1>;    // Own Address 1 10-bit mode
            using OA1EN = Field<15, 1>;    // Own Address 1 enable
        };

        // Own address register 2
        struct OAR2 : public Register<0x40005c0c> {
            using OA2 = Field<1, 7>;    // Interface address
            using OA2MSK = Field<8, 3>;    // Own Address 2 masks
            using OA2EN = Field<15, 1>;    // Own Address 2 enable
        };

        // Timing register
        struct TIMINGR : public Register<0x40005c10> {
            using SCLL = Field<0, 8>;    // SCL low period (master mode)
            using SCLH = Field<8, 8>;    // SCL high period (master mode)
            using SDADEL = Field<16, 4>;    // Data hold time
            using SCLDEL = Field<20, 4>;    // Data setup time
            using PRESC = Field<28, 4>;    // Timing prescaler
        };

        // Status register 1
        struct TIMEOUTR : public Register<0x40005c14> {
            using TIMEOUTA = Field<0, 12>;    // Bus timeout A
            using TIDLE = Field<12, 1>;    // Idle clock timeout detection
            using TIMOUTEN = Field<15, 1>;    // Clock timeout enable
            using TIMEOUTB = Field<16, 12>;    // Bus timeout B
            using TEXTEN = Field<31, 1>;    // Extended clock timeout enable
        };

        // Interrupt and Status register
        struct ISR : public Register<0x40005c18> {
            using ADDCODE = Field<17, 7>;    // Address match code (Slave mode)
            using DIR = Field<16, 1>;    // Transfer direction (Slave mode)
            using BUSY = Field<15, 1>;    // Bus busy
            using ALERT = Field<13, 1>;    // SMBus alert
            using TIMEOUT = Field<12, 1>;    // Timeout or t_low detection flag
            using PECERR = Field<11, 1>;    // PEC Error in reception
            using OVR = Field<10, 1>;    // Overrun/Underrun (slave mode)
            using ARLO = Field<9, 1>;    // Arbitration lost
            using BERR = Field<8, 1>;    // Bus error
            using TCR = Field<7, 1>;    // Transfer Complete Reload
            using TC = Field<6, 1>;    // Transfer Complete (master mode)
            using STOPF = Field<5, 1>;    // Stop detection flag
            using NACKF = Field<4, 1>;    // Not acknowledge received flag
            using ADDR = Field<3, 1>;    // Address matched (slave mode)
            using RXNE = Field<2, 1>;    // Receive data register not empty (receivers)
            using TXIS = Field<1, 1>;    // Transmit interrupt status (transmitters)
            using TXE = Field<0, 1>;    // Transmit data register empty (transmitters)
        };

        // Interrupt clear register
        struct ICR : public Register<0x40005c1c> {
            using ALERTCF = Field<13, 1>;    // Alert flag clear
            using TIMOUTCF = Field<12, 1>;    // Timeout detection flag clear
            using PECCF = Field<11, 1>;    // PEC Error flag clear
            using OVRCF = Field<10, 1>;    // Overrun/Underrun flag clear
            using ARLOCF = Field<9, 1>;    // Arbitration lost flag clear
            using BERRCF = Field<8, 1>;    // Bus error flag clear
            using STOPCF = Field<5, 1>;    // Stop detection flag clear
            using NACKCF = Field<4, 1>;    // Not Acknowledge flag clear
            using ADDRCF = Field<3, 1>;    // Address Matched flag clear
        };

        // PEC register
        struct PECR : public Register<0x40005c20> {
            using PEC = Field<0, 8>;    // Packet error checking register
        };

        // Receive data register
        struct RXDR : public Register<0x40005c24> {
            using RXDATA = Field<0, 8>;    // 8-bit receive data
        };

        // Transmit data register
        struct TXDR : public Register<0x40005c28> {
            using TXDATA = Field<0, 8>;    // 8-bit transmit data
        };

    };

    // Inter-integrated circuit
    struct I2C4 {
        // Control register 1
        struct CR1 : public Register<0x40008400> {
            using PE = Field<0, 1>;    // Peripheral enable
            using TXIE = Field<1, 1>;    // TX Interrupt enable
            using RXIE = Field<2, 1>;    // RX Interrupt enable
            using ADDRIE = Field<3, 1>;    // Address match interrupt enable (slave only)
            using NACKIE = Field<4, 1>;    // Not acknowledge received interrupt enable
            using STOPIE = Field<5, 1>;    // STOP detection Interrupt enable
            using TCIE = Field<6, 1>;    // Transfer Complete interrupt enable
            using ERRIE = Field<7, 1>;    // Error interrupts enable
            using DNF = Field<8, 4>;    // Digital noise filter
            using ANFOFF = Field<12, 1>;    // Analog noise filter OFF
            using TXDMAEN = Field<14, 1>;    // DMA transmission requests enable
            using RXDMAEN = Field<15, 1>;    // DMA reception requests enable
            using SBC = Field<16, 1>;    // Slave byte control
            using NOSTRETCH = Field<17, 1>;    // Clock stretching disable
            using WUPEN = Field<18, 1>;    // Wakeup from STOP enable
            using GCEN = Field<19, 1>;    // General call enable
            using SMBHEN = Field<20, 1>;    // SMBus Host address enable
            using SMBDEN = Field<21, 1>;    // SMBus Device Default address enable
            using ALERTEN = Field<22, 1>;    // SMBUS alert enable
            using PECEN = Field<23, 1>;    // PEC enable
        };

        // Control register 2
        struct CR2 : public Register<0x40008404> {
            using PECBYTE = Field<26, 1>;    // Packet error checking byte
            using AUTOEND = Field<25, 1>;    // Automatic end mode (master mode)
            using RELOAD = Field<24, 1>;    // NBYTES reload mode
            using NBYTES = Field<16, 8>;    // Number of bytes
            using NACK = Field<15, 1>;    // NACK generation (slave mode)
            using STOP = Field<14, 1>;    // Stop generation (master mode)
            using START = Field<13, 1>;    // Start generation
            using HEAD10R = Field<12, 1>;    // 10-bit address header only read direction (master receiver mode)
            using ADD10 = Field<11, 1>;    // 10-bit addressing mode (master mode)
            using RD_WRN = Field<10, 1>;    // Transfer direction (master mode)
            using SADD = Field<0, 10>;    // Slave address bit (master mode)
        };

        // Own address register 1
        struct OAR1 : public Register<0x40008408> {
            using OA1 = Field<0, 10>;    // Interface address
            using OA1MODE = Field<10, 1>;    // Own Address 1 10-bit mode
            using OA1EN = Field<15, 1>;    // Own Address 1 enable
        };

        // Own address register 2
        struct OAR2 : public Register<0x4000840c> {
            using OA2 = Field<1, 7>;    // Interface address
            using OA2MSK = Field<8, 3>;    // Own Address 2 masks
            using OA2EN = Field<15, 1>;    // Own Address 2 enable
        };

        // Timing register
        struct TIMINGR : public Register<0x40008410> {
            using SCLL = Field<0, 8>;    // SCL low period (master mode)
            using SCLH = Field<8, 8>;    // SCL high period (master mode)
            using SDADEL = Field<16, 4>;    // Data hold time
            using SCLDEL = Field<20, 4>;    // Data setup time
            using PRESC = Field<28, 4>;    // Timing prescaler
        };

        // Status register 1
        struct TIMEOUTR : public Register<0x40008414> {
            using TIMEOUTA = Field<0, 12>;    // Bus timeout A
            using TIDLE = Field<12, 1>;    // Idle clock timeout detection
            using TIMOUTEN = Field<15, 1>;    // Clock timeout enable
            using TIMEOUTB = Field<16, 12>;    // Bus timeout B
            using TEXTEN = Field<31, 1>;    // Extended clock timeout enable
        };

        // Interrupt and Status register
        struct ISR : public Register<0x40008418> {
            using ADDCODE = Field<17, 7>;    // Address match code (Slave mode)
            using DIR = Field<16, 1>;    // Transfer direction (Slave mode)
            using BUSY = Field<15, 1>;    // Bus busy
            using ALERT = Field<13, 1>;    // SMBus alert
            using TIMEOUT = Field<12, 1>;    // Timeout or t_low detection flag
            using PECERR = Field<11, 1>;    // PEC Error in reception
            using OVR = Field<10, 1>;    // Overrun/Underrun (slave mode)
            using ARLO = Field<9, 1>;    // Arbitration lost
            using BERR = Field<8, 1>;    // Bus error
            using TCR = Field<7, 1>;    // Transfer Complete Reload
            using TC = Field<6, 1>;    // Transfer Complete (master mode)
            using STOPF = Field<5, 1>;    // Stop detection flag
            using NACKF = Field<4, 1>;    // Not acknowledge received flag
            using ADDR = Field<3, 1>;    // Address matched (slave mode)
            using RXNE = Field<2, 1>;    // Receive data register not empty (receivers)
            using TXIS = Field<1, 1>;    // Transmit interrupt status (transmitters)
            using TXE = Field<0, 1>;    // Transmit data register empty (transmitters)
        };

        // Interrupt clear register
        struct ICR : public Register<0x4000841c> {
            using ALERTCF = Field<13, 1>;    // Alert flag clear
            using TIMOUTCF = Field<12, 1>;    // Timeout detection flag clear
            using PECCF = Field<11, 1>;    // PEC Error flag clear
            using OVRCF = Field<10, 1>;    // Overrun/Underrun flag clear
            using ARLOCF = Field<9, 1>;    // Arbitration lost flag clear
            using BERRCF = Field<8, 1>;    // Bus error flag clear
            using STOPCF = Field<5, 1>;    // Stop detection flag clear
            using NACKCF = Field<4, 1>;    // Not Acknowledge flag clear
            using ADDRCF = Field<3, 1>;    // Address Matched flag clear
        };

        // PEC register
        struct PECR : public Register<0x40008420> {
            using PEC = Field<0, 8>;    // Packet error checking register
        };

        // Receive data register
        struct RXDR : public Register<0x40008424> {
            using RXDATA = Field<0, 8>;    // 8-bit receive data
        };

        // Transmit data register
        struct TXDR : public Register<0x40008428> {
            using TXDATA = Field<0, 8>;    // 8-bit transmit data
        };

    };

    // Flash
    struct FLASH {
        // Access control register
        struct ACR : public Register<0x40022000> {
            using LATENCY = Field<0, 3>;    // Latency
            using PRFTEN = Field<8, 1>;    // Prefetch enable
            using ICEN = Field<9, 1>;    // Instruction cache enable
            using DCEN = Field<10, 1>;    // Data cache enable
            using ICRST = Field<11, 1>;    // Instruction cache reset
            using DCRST = Field<12, 1>;    // Data cache reset
            using RUN_PD = Field<13, 1>;    // Flash Power-down mode during Low-power run mode
            using SLEEP_PD = Field<14, 1>;    // Flash Power-down mode during Low-power sleep mode
        };

        // Power down key register
        struct PDKEYR : public Register<0x40022004> {
            using Field = Field<0, 32>;    // RUN_PD in FLASH_ACR key
        };

        // Flash key register
        struct KEYR : public Register<0x40022008> {
            using Field = Field<0, 32>;    // KEYR
        };

        // Option byte key register
        struct OPTKEYR : public Register<0x4002200c> {
            using Field = Field<0, 32>;    // Option byte key
        };

        // Status register
        struct SR : public Register<0x40022010> {
            using EOP = Field<0, 1>;    // End of operation
            using OPERR = Field<1, 1>;    // Operation error
            using PROGERR = Field<3, 1>;    // Programming error
            using WRPERR = Field<4, 1>;    // Write protected error
            using PGAERR = Field<5, 1>;    // Programming alignment error
            using SIZERR = Field<6, 1>;    // Size error
            using PGSERR = Field<7, 1>;    // Programming sequence error
            using MISERR = Field<8, 1>;    // Fast programming data miss error
            using FASTERR = Field<9, 1>;    // Fast programming error
            using RDERR = Field<14, 1>;    // PCROP read error
            using OPTVERR = Field<15, 1>;    // Option validity error
            using BSY = Field<16, 1>;    // Busy
        };

        // Flash control register
        struct CR : public Register<0x40022014> {
            using PG = Field<0, 1>;    // Programming
            using PER = Field<1, 1>;    // Page erase
            using MER1 = Field<2, 1>;    // Bank 1 Mass erase
            using PNB = Field<3, 8>;    // Page number
            using BKER = Field<11, 1>;    // Bank erase
            using MER2 = Field<15, 1>;    // Bank 2 Mass erase
            using START = Field<16, 1>;    // Start
            using OPTSTRT = Field<17, 1>;    // Options modification start
            using FSTPG = Field<18, 1>;    // Fast programming
            using EOPIE = Field<24, 1>;    // End of operation interrupt enable
            using ERRIE = Field<25, 1>;    // Error interrupt enable
            using RDERRIE = Field<26, 1>;    // PCROP read error interrupt enable
            using OBL_LAUNCH = Field<27, 1>;    // Force the option byte loading
            using OPTLOCK = Field<30, 1>;    // Options Lock
            using LOCK = Field<31, 1>;    // FLASH_CR Lock
        };

        // Flash ECC register
        struct ECCR : public Register<0x40022018> {
            using ADDR_ECC = Field<0, 19>;    // ECC fail address
            using BK_ECC = Field<19, 1>;    // ECC fail bank
            using SYSF_ECC = Field<20, 1>;    // System Flash ECC fail
            using ECCIE = Field<24, 1>;    // ECC correction interrupt enable
            using ECCC = Field<30, 1>;    // ECC correction
            using ECCD = Field<31, 1>;    // ECC detection
        };

        // Flash option register
        struct OPTR : public Register<0x40022020> {
            using RDP = Field<0, 8>;    // Read protection level
            using BOR_LEV = Field<8, 3>;    // BOR reset Level
            using nRST_STOP = Field<12, 1>;    // nRST_STOP
            using nRST_STDBY = Field<13, 1>;    // nRST_STDBY
            using IDWG_SW = Field<16, 1>;    // Independent watchdog selection
            using IWDG_STOP = Field<17, 1>;    // Independent watchdog counter freeze in Stop mode
            using IWDG_STDBY = Field<18, 1>;    // Independent watchdog counter freeze in Standby mode
            using WWDG_SW = Field<19, 1>;    // Window watchdog selection
            using BFB2 = Field<20, 1>;    // Dual-bank boot
            using DUALBANK = Field<21, 1>;    // Dual-Bank on 512 KB or 256 KB Flash memory devices
            using nBOOT1 = Field<23, 1>;    // Boot configuration
            using SRAM2_PE = Field<24, 1>;    // SRAM2 parity check enable
            using SRAM2_RST = Field<25, 1>;    // SRAM2 Erase when system reset
        };

        // Flash Bank 1 PCROP Start address register
        struct PCROP1SR : public Register<0x40022024> {
            using PCROP1_STRT = Field<0, 16>;    // Bank 1 PCROP area start offset
        };

        // Flash Bank 1 PCROP End address register
        struct PCROP1ER : public Register<0x40022028> {
            using PCROP1_END = Field<0, 16>;    // Bank 1 PCROP area end offset
            using PCROP_RDP = Field<31, 1>;    // PCROP area preserved when RDP level decreased
        };

        // Flash Bank 1 WRP area A address register
        struct WRP1AR : public Register<0x4002202c> {
            using WRP1A_STRT = Field<0, 8>;    // Bank 1 WRP first area start offset
            using WRP1A_END = Field<16, 8>;    // Bank 1 WRP first area A end offset
        };

        // Flash Bank 1 WRP area B address register
        struct WRP1BR : public Register<0x40022030> {
            using WRP1B_STRT = Field<16, 8>;    // Bank 1 WRP second area B end offset
            using WRP1B_END = Field<0, 8>;    // Bank 1 WRP second area B start offset
        };

        // Flash Bank 2 PCROP Start address register
        struct PCROP2SR : public Register<0x40022044> {
            using PCROP2_STRT = Field<0, 16>;    // Bank 2 PCROP area start offset
        };

        // Flash Bank 2 PCROP End address register
        struct PCROP2ER : public Register<0x40022048> {
            using PCROP2_END = Field<0, 16>;    // Bank 2 PCROP area end offset
        };

        // Flash Bank 2 WRP area A address register
        struct WRP2AR : public Register<0x4002204c> {
            using WRP2A_STRT = Field<0, 8>;    // Bank 2 WRP first area A start offset
            using WRP2A_END = Field<16, 8>;    // Bank 2 WRP first area A end offset
        };

        // Flash Bank 2 WRP area B address register
        struct WRP2BR : public Register<0x40022050> {
            using WRP2B_STRT = Field<0, 8>;    // Bank 2 WRP second area B start offset
            using WRP2B_END = Field<16, 8>;    // Bank 2 WRP second area B end offset
        };

    };

    // Debug support
    struct DBGMCU {
        // MCU Device ID Code Register
        struct IDCODE : public Register<0xe0042000> {
            using DEV_ID = Field<0, 16>;    // Device Identifier
            using REV_ID = Field<16, 16>;    // Revision Identifier
        };

        // Debug MCU Configuration Register
        struct CR : public Register<0xe0042004> {
            using DBG_SLEEP = Field<0, 1>;    // Debug Sleep Mode
            using DBG_STOP = Field<1, 1>;    // Debug Stop Mode
            using DBG_STANDBY = Field<2, 1>;    // Debug Standby Mode
            using TRACE_IOEN = Field<5, 1>;    // Trace pin assignment control
            using TRACE_MODE = Field<6, 2>;    // Trace pin assignment control
        };

        // APB Low Freeze Register 1
        struct APB1_FZR1 : public Register<0xe0042008> {
            using DBG_TIMER2_STOP = Field<0, 1>;    // Debug Timer 2 stopped when Core is halted
            using DBG_TIM3_STOP = Field<1, 1>;    // TIM3 counter stopped when core is halted
            using DBG_TIM4_STOP = Field<2, 1>;    // TIM4 counter stopped when core is halted
            using DBG_TIM5_STOP = Field<3, 1>;    // TIM5 counter stopped when core is halted
            using DBG_TIMER6_STOP = Field<4, 1>;    // Debug Timer 6 stopped when Core is halted
            using DBG_TIM7_STOP = Field<5, 1>;    // TIM7 counter stopped when core is halted
            using DBG_RTC_STOP = Field<10, 1>;    // Debug RTC stopped when Core is halted
            using DBG_WWDG_STOP = Field<11, 1>;    // Debug Window Wachdog stopped when Core is halted
            using DBG_IWDG_STOP = Field<12, 1>;    // Debug Independent Wachdog stopped when Core is halted
            using DBG_I2C1_STOP = Field<21, 1>;    // I2C1 SMBUS timeout mode stopped when core is halted
            using DBG_I2C2_STOP = Field<22, 1>;    // I2C2 SMBUS timeout mode stopped when core is halted
            using DBG_I2C3_STOP = Field<23, 1>;    // I2C3 SMBUS timeout counter stopped when core is halted
            using DBG_CAN_STOP = Field<25, 1>;    // bxCAN stopped when core is halted
            using DBG_LPTIMER_STOP = Field<31, 1>;    // LPTIM1 counter stopped when core is halted
        };

        // APB Low Freeze Register 2
        struct APB1_FZR2 : public Register<0xe004200c> {
            using DBG_LPTIM2_STOP = Field<5, 1>;    // LPTIM2 counter stopped when core is halted
        };

        // APB High Freeze Register
        struct APB2_FZR : public Register<0xe0042010> {
            using DBG_TIM1_STOP = Field<11, 1>;    // TIM1 counter stopped when core is halted
            using DBG_TIM8_STOP = Field<13, 1>;    // TIM8 counter stopped when core is halted
            using DBG_TIM15_STOP = Field<16, 1>;    // TIM15 counter stopped when core is halted
            using DBG_TIM16_STOP = Field<17, 1>;    // TIM16 counter stopped when core is halted
            using DBG_TIM17_STOP = Field<18, 1>;    // TIM17 counter stopped when core is halted
        };

    };

    // OctoSPI
    struct OCTOSPI1 {
        // control register
        struct CR : public Register<0xa0001000> {
            using FMODE = Field<28, 2>;    // Functional mode
            using PMM = Field<23, 1>;    // Polling match mode
            using APMS = Field<22, 1>;    // Automatic poll mode stop
            using TOIE = Field<20, 1>;    // TimeOut interrupt enable
            using SMIE = Field<19, 1>;    // Status match interrupt enable
            using FTIE = Field<18, 1>;    // FIFO threshold interrupt enable
            using TCIE = Field<17, 1>;    // Transfer complete interrupt enable
            using TEIE = Field<16, 1>;    // Transfer error interrupt enable
            using FTHRES = Field<8, 5>;    // IFO threshold level
            using FSEL = Field<7, 1>;    // FLASH memory selection
            using DQM = Field<6, 1>;    // Dual-quad mode
            using TCEN = Field<3, 1>;    // Timeout counter enable
            using DMAEN = Field<2, 1>;    // DMA enable
            using ABORT = Field<1, 1>;    // Abort request
            using EN = Field<0, 1>;    // Enable
        };

        // device configuration register
        struct DCR1 : public Register<0xa0001008> {
            using CKMODE = Field<0, 1>;    // Mode 0 / mode 3
            using FRCK = Field<1, 1>;    // Free running clock
            using CSHT = Field<8, 3>;    // Chip-select high time
            using DEVSIZE = Field<16, 5>;    // Device size
            using MTYP = Field<24, 2>;    // Memory type
        };

        // device configuration register 2
        struct DCR2 : public Register<0xa000100c> {
            using PRESCALER = Field<0, 8>;    // Clock prescaler
            using WRAPSIZE = Field<16, 3>;    // Wrap size
        };

        // device configuration register 3
        struct DCR3 : public Register<0xa0001010> {
            using CSBOUND = Field<16, 5>;    // CS boundary
        };

        // status register
        struct SR : public Register<0xa0001020> {
            using TEF = Field<0, 1>;    // Transfer error flag
            using TCF = Field<1, 1>;    // Transfer complete flag
            using FTF = Field<2, 1>;    // FIFO threshold flag
            using SMF = Field<3, 1>;    // Status match flag
            using TOF = Field<4, 1>;    // Timeout flag
            using BUSY = Field<5, 1>;    // BUSY
            using FLEVEL = Field<8, 6>;    // FIFO level
        };

        // flag clear register
        struct FCR : public Register<0xa0001024> {
            using CTEF = Field<0, 1>;    // Clear transfer error flag
            using CTCF = Field<1, 1>;    // Clear transfer complete flag
            using CSMF = Field<3, 1>;    // Clear status match flag
            using CTOF = Field<4, 1>;    // Clear timeout flag
        };

        // data length register
        struct DLR : public Register<0xa0001040> {
            using DL = Field<0, 32>;    // Data length
        };

        // address register
        struct AR : public Register<0xa0001048> {
            using ADDRESS = Field<0, 32>;    // ADDRESS
        };

        // data register
        struct DR : public Register<0xa0001050> {
            using DATA = Field<0, 32>;    // Data
        };

        // polling status mask register
        struct PSMKR : public Register<0xa0001080> {
            using MASK = Field<0, 32>;    // Status mask
        };

        // polling status match register
        struct PSMAR : public Register<0xa0001088> {
            using MATCH = Field<0, 32>;    // Status match
        };

        // polling interval register
        struct PIR : public Register<0xa0001090> {
            using INTERVAL = Field<0, 16>;    // Polling interval
        };

        // communication configuration register
        struct CCR : public Register<0xa0001100> {
            using IMODE = Field<0, 3>;    // Instruction mode
            using IDTR = Field<3, 1>;    // Instruction double transfer rate
            using ISIZE = Field<4, 2>;    // Instruction size
            using ADMODE = Field<8, 3>;    // Address mode
            using ADDTR = Field<11, 1>;    // Address double transfer rate
            using ADSIZE = Field<12, 2>;    // Address size
            using ABMODE = Field<16, 3>;    // Alternate byte mode
            using ABDTR = Field<19, 1>;    // Alternate bytes double transfer rate
            using ABSIZE = Field<20, 2>;    // Alternate bytes size
            using DMODE = Field<24, 3>;    // Data mode
            using DDTR = Field<27, 1>;    // Alternate bytes double transfer rate
            using DQSE = Field<29, 1>;    // DQS enable
            using SIOO = Field<31, 1>;    // Send instruction only once mode
        };

        // timing configuration register
        struct TCR : public Register<0xa0001108> {
            using DCYC = Field<0, 5>;    // Number of dummy cycles
            using DHQC = Field<28, 1>;    // Delay hold quarter cycle
            using SSHIFT = Field<30, 1>;    // Sample shift
        };

        // instruction register
        struct IR : public Register<0xa0001110> {
            using INSTRUCTION = Field<0, 32>;    // INSTRUCTION
        };

        // alternate bytes register
        struct ABR : public Register<0xa0001120> {
            using ALTERNATE = Field<0, 32>;    // Alternate bytes
        };

        // low-power timeout register
        struct LPTR : public Register<0xa0001130> {
            using TIMEOUT = Field<0, 16>;    // Timeout period
        };

        // write communication configuration register
        struct WCCR : public Register<0xa0001180> {
            using IMODE = Field<0, 3>;    // Instruction mode
            using IDTR = Field<3, 1>;    // Instruction double transfer rate
            using ISIZE = Field<4, 2>;    // Instruction size
            using ADMODE = Field<8, 3>;    // Address mode
            using ADDTR = Field<11, 1>;    // Address double transfer rate
            using ADSIZE = Field<12, 2>;    // Address size
            using ABMODE = Field<16, 3>;    // Alternate byte mode
            using ABDTR = Field<19, 1>;    // Alternate bytes double transfer rate
            using ABSIZE = Field<20, 2>;    // Alternate bytes size
            using DMODE = Field<24, 3>;    // Data mode
            using DDTR = Field<27, 1>;    // alternate bytes double transfer rate
            using DQSE = Field<29, 1>;    // DQS enable
            using SIOO = Field<31, 1>;    // Send instruction only once mode
        };

        // write timing configuration register
        struct WTCR : public Register<0xa0001188> {
            using DCYC = Field<0, 5>;    // Number of dummy cycles
        };

        // write instruction register
        struct WIR : public Register<0xa0001190> {
            using INSTRUCTION = Field<0, 32>;    // INSTRUCTION
        };

        // write alternate bytes register
        struct WABR : public Register<0xa00011a0> {
            using ALTERNATE = Field<0, 32>;    // Alternate bytes
        };

        // HyperBusTM latency configuration register
        struct HLCR : public Register<0xa0001200> {
            using LM = Field<0, 1>;    // Latency mode
            using WZL = Field<1, 1>;    // Write zero latency
            using TACC = Field<8, 8>;    // Access time
            using TRWR = Field<16, 8>;    // Read write recovery time
        };

        // HW configuration register
        struct HWCFGR : public Register<0xa00013f0> {
            using AXI = Field<0, 4>;    // AXI interface
            using FIFO = Field<4, 8>;    // FIFO depth
            using PRES = Field<12, 8>;    // Prescaler
            using IDL = Field<20, 4>;    // ID Length
            using MMW = Field<24, 4>;    // Memory map write
            using MST = Field<28, 4>;    // Master
        };

        // version register
        struct VER : public Register<0xa00013f4> {
            using Field = Field<0, 8>;    // Version
        };

        // identification
        struct ID : public Register<0xa00013f8> {
            using Field = Field<0, 32>;    // Identification
        };

        // magic ID
        struct MID : public Register<0xa00013fc> {
            using Field = Field<0, 32>;    // Magic ID
        };

    };

    // OctoSPI
    struct OCTOSPI2 {
        // control register
        struct CR : public Register<0xa0001400> {
            using FMODE = Field<28, 2>;    // Functional mode
            using PMM = Field<23, 1>;    // Polling match mode
            using APMS = Field<22, 1>;    // Automatic poll mode stop
            using TOIE = Field<20, 1>;    // TimeOut interrupt enable
            using SMIE = Field<19, 1>;    // Status match interrupt enable
            using FTIE = Field<18, 1>;    // FIFO threshold interrupt enable
            using TCIE = Field<17, 1>;    // Transfer complete interrupt enable
            using TEIE = Field<16, 1>;    // Transfer error interrupt enable
            using FTHRES = Field<8, 5>;    // IFO threshold level
            using FSEL = Field<7, 1>;    // FLASH memory selection
            using DQM = Field<6, 1>;    // Dual-quad mode
            using TCEN = Field<3, 1>;    // Timeout counter enable
            using DMAEN = Field<2, 1>;    // DMA enable
            using ABORT = Field<1, 1>;    // Abort request
            using EN = Field<0, 1>;    // Enable
        };

        // device configuration register
        struct DCR1 : public Register<0xa0001408> {
            using CKMODE = Field<0, 1>;    // Mode 0 / mode 3
            using FRCK = Field<1, 1>;    // Free running clock
            using CSHT = Field<8, 3>;    // Chip-select high time
            using DEVSIZE = Field<16, 5>;    // Device size
            using MTYP = Field<24, 2>;    // Memory type
        };

        // device configuration register 2
        struct DCR2 : public Register<0xa000140c> {
            using PRESCALER = Field<0, 8>;    // Clock prescaler
            using WRAPSIZE = Field<16, 3>;    // Wrap size
        };

        // device configuration register 3
        struct DCR3 : public Register<0xa0001410> {
            using CSBOUND = Field<16, 5>;    // CS boundary
        };

        // status register
        struct SR : public Register<0xa0001420> {
            using TEF = Field<0, 1>;    // Transfer error flag
            using TCF = Field<1, 1>;    // Transfer complete flag
            using FTF = Field<2, 1>;    // FIFO threshold flag
            using SMF = Field<3, 1>;    // Status match flag
            using TOF = Field<4, 1>;    // Timeout flag
            using BUSY = Field<5, 1>;    // BUSY
            using FLEVEL = Field<8, 6>;    // FIFO level
        };

        // flag clear register
        struct FCR : public Register<0xa0001424> {
            using CTEF = Field<0, 1>;    // Clear transfer error flag
            using CTCF = Field<1, 1>;    // Clear transfer complete flag
            using CSMF = Field<3, 1>;    // Clear status match flag
            using CTOF = Field<4, 1>;    // Clear timeout flag
        };

        // data length register
        struct DLR : public Register<0xa0001440> {
            using DL = Field<0, 32>;    // Data length
        };

        // address register
        struct AR : public Register<0xa0001448> {
            using ADDRESS = Field<0, 32>;    // ADDRESS
        };

        // data register
        struct DR : public Register<0xa0001450> {
            using DATA = Field<0, 32>;    // Data
        };

        // polling status mask register
        struct PSMKR : public Register<0xa0001480> {
            using MASK = Field<0, 32>;    // Status mask
        };

        // polling status match register
        struct PSMAR : public Register<0xa0001488> {
            using MATCH = Field<0, 32>;    // Status match
        };

        // polling interval register
        struct PIR : public Register<0xa0001490> {
            using INTERVAL = Field<0, 16>;    // Polling interval
        };

        // communication configuration register
        struct CCR : public Register<0xa0001500> {
            using IMODE = Field<0, 3>;    // Instruction mode
            using IDTR = Field<3, 1>;    // Instruction double transfer rate
            using ISIZE = Field<4, 2>;    // Instruction size
            using ADMODE = Field<8, 3>;    // Address mode
            using ADDTR = Field<11, 1>;    // Address double transfer rate
            using ADSIZE = Field<12, 2>;    // Address size
            using ABMODE = Field<16, 3>;    // Alternate byte mode
            using ABDTR = Field<19, 1>;    // Alternate bytes double transfer rate
            using ABSIZE = Field<20, 2>;    // Alternate bytes size
            using DMODE = Field<24, 3>;    // Data mode
            using DDTR = Field<27, 1>;    // Alternate bytes double transfer rate
            using DQSE = Field<29, 1>;    // DQS enable
            using SIOO = Field<31, 1>;    // Send instruction only once mode
        };

        // timing configuration register
        struct TCR : public Register<0xa0001508> {
            using DCYC = Field<0, 5>;    // Number of dummy cycles
            using DHQC = Field<28, 1>;    // Delay hold quarter cycle
            using SSHIFT = Field<30, 1>;    // Sample shift
        };

        // instruction register
        struct IR : public Register<0xa0001510> {
            using INSTRUCTION = Field<0, 32>;    // INSTRUCTION
        };

        // alternate bytes register
        struct ABR : public Register<0xa0001520> {
            using ALTERNATE = Field<0, 32>;    // Alternate bytes
        };

        // low-power timeout register
        struct LPTR : public Register<0xa0001530> {
            using TIMEOUT = Field<0, 16>;    // Timeout period
        };

        // write communication configuration register
        struct WCCR : public Register<0xa0001580> {
            using IMODE = Field<0, 3>;    // Instruction mode
            using IDTR = Field<3, 1>;    // Instruction double transfer rate
            using ISIZE = Field<4, 2>;    // Instruction size
            using ADMODE = Field<8, 3>;    // Address mode
            using ADDTR = Field<11, 1>;    // Address double transfer rate
            using ADSIZE = Field<12, 2>;    // Address size
            using ABMODE = Field<16, 3>;    // Alternate byte mode
            using ABDTR = Field<19, 1>;    // Alternate bytes double transfer rate
            using ABSIZE = Field<20, 2>;    // Alternate bytes size
            using DMODE = Field<24, 3>;    // Data mode
            using DDTR = Field<27, 1>;    // alternate bytes double transfer rate
            using DQSE = Field<29, 1>;    // DQS enable
            using SIOO = Field<31, 1>;    // Send instruction only once mode
        };

        // write timing configuration register
        struct WTCR : public Register<0xa0001588> {
            using DCYC = Field<0, 5>;    // Number of dummy cycles
        };

        // write instruction register
        struct WIR : public Register<0xa0001590> {
            using INSTRUCTION = Field<0, 32>;    // INSTRUCTION
        };

        // write alternate bytes register
        struct WABR : public Register<0xa00015a0> {
            using ALTERNATE = Field<0, 32>;    // Alternate bytes
        };

        // HyperBusTM latency configuration register
        struct HLCR : public Register<0xa0001600> {
            using LM = Field<0, 1>;    // Latency mode
            using WZL = Field<1, 1>;    // Write zero latency
            using TACC = Field<8, 8>;    // Access time
            using TRWR = Field<16, 8>;    // Read write recovery time
        };

        // HW configuration register
        struct HWCFGR : public Register<0xa00017f0> {
            using AXI = Field<0, 4>;    // AXI interface
            using FIFO = Field<4, 8>;    // FIFO depth
            using PRES = Field<12, 8>;    // Prescaler
            using IDL = Field<20, 4>;    // ID Length
            using MMW = Field<24, 4>;    // Memory map write
            using MST = Field<28, 4>;    // Master
        };

        // version register
        struct VER : public Register<0xa00017f4> {
            using Field = Field<0, 8>;    // Version
        };

        // identification
        struct ID : public Register<0xa00017f8> {
            using Field = Field<0, 32>;    // Identification
        };

        // magic ID
        struct MID : public Register<0xa00017fc> {
            using Field = Field<0, 32>;    // Magic ID
        };

    };

    // Reset and clock control
    struct RCC {
        // Clock control register
        struct CR : public Register<0x40021000> {
            using PLLSAI2RDY = Field<29, 1>;    // SAI2 PLL clock ready flag
            using PLLSAI2ON = Field<28, 1>;    // SAI2 PLL enable
            using PLLSAI1RDY = Field<27, 1>;    // SAI1 PLL clock ready flag
            using PLLSAI1ON = Field<26, 1>;    // SAI1 PLL enable
            using PLLRDY = Field<25, 1>;    // Main PLL clock ready flag
            using PLLON = Field<24, 1>;    // Main PLL enable
            using CSSON = Field<19, 1>;    // Clock security system enable
            using HSEBYP = Field<18, 1>;    // HSE crystal oscillator bypass
            using HSERDY = Field<17, 1>;    // HSE clock ready flag
            using HSEON = Field<16, 1>;    // HSE clock enable
            using HSIASFS = Field<11, 1>;    // HSI automatic start from Stop
            using HSIRDY = Field<10, 1>;    // HSI clock ready flag
            using HSIKERON = Field<9, 1>;    // HSI always enable for peripheral kernels
            using HSION = Field<8, 1>;    // HSI clock enable
            using MSIRANGE = Field<4, 4>;    // MSI clock ranges
            using MSIRGSEL = Field<3, 1>;    // MSI clock range selection
            using MSIPLLEN = Field<2, 1>;    // MSI clock PLL enable
            using MSIRDY = Field<1, 1>;    // MSI clock ready flag
            using MSION = Field<0, 1>;    // MSI clock enable
        };

        // Internal clock sources calibration register
        struct ICSCR : public Register<0x40021004> {
            using HSITRIM = Field<24, 7>;    // HSI clock trimming
            using HSICAL = Field<16, 8>;    // HSI clock calibration
            using MSITRIM = Field<8, 8>;    // MSI clock trimming
            using MSICAL = Field<0, 8>;    // MSI clock calibration
        };

        // Clock configuration register
        struct CFGR : public Register<0x40021008> {
            using MCOPRE = Field<28, 3>;    // Microcontroller clock output prescaler
            using MCOSEL = Field<24, 3>;    // Microcontroller clock output
            using STOPWUCK = Field<15, 1>;    // Wakeup from Stop and CSS backup clock selection
            using PPRE2 = Field<11, 3>;    // APB high-speed prescaler (APB2)
            using PPRE1 = Field<8, 3>;    // PB low-speed prescaler (APB1)
            using HPRE = Field<4, 4>;    // AHB prescaler
            using SWS = Field<2, 2>;    // System clock switch status
            using SW = Field<0, 2>;    // System clock switch
        };

        // PLL configuration register
        struct PLLCFGR : public Register<0x4002100c> {
            using PLLPDIV = Field<27, 5>;    // Main PLL division factor for PLLSAI2CLK
            using PLLR = Field<25, 2>;    // Main PLL division factor for PLLCLK (system clock)
            using PLLREN = Field<24, 1>;    // Main PLL PLLCLK output enable
            using PLLQ = Field<21, 2>;    // Main PLL division factor for PLLUSB1CLK(48 MHz clock)
            using PLLQEN = Field<20, 1>;    // Main PLL PLLUSB1CLK output enable
            using PLLP = Field<17, 1>;    // Main PLL division factor for PLLSAI3CLK (SAI1 and SAI2 clock)
            using PLLPEN = Field<16, 1>;    // Main PLL PLLSAI3CLK output enable
            using PLLN = Field<8, 7>;    // Main PLL multiplication factor for VCO
            using PLLM = Field<4, 4>;    // Division factor for the main PLL and audio PLL (PLLSAI1 and PLLSAI2) input clock
            using PLLSRC = Field<0, 2>;    // Main PLL, PLLSAI1 and PLLSAI2 entry clock source
        };

        // PLLSAI1 configuration register
        struct PLLSAI1CFGR : public Register<0x40021010> {
            using PLLSAI1PDIV = Field<27, 5>;    // PLLSAI1 division factor for PLLSAI1CLK
            using PLLSAI1R = Field<25, 2>;    // PLLSAI1 division factor for PLLADC1CLK (ADC clock)
            using PLLSAI1REN = Field<24, 1>;    // PLLSAI1 PLLADC1CLK output enable
            using PLLSAI1Q = Field<21, 2>;    // SAI1PLL division factor for PLLUSB2CLK (48 MHz clock)
            using PLLSAI1QEN = Field<20, 1>;    // SAI1PLL PLLUSB2CLK output enable
            using PLLSAI1P = Field<17, 1>;    // SAI1PLL division factor for PLLSAI1CLK (SAI1 or SAI2 clock)
            using PLLSAI1PEN = Field<16, 1>;    // SAI1PLL PLLSAI1CLK output enable
            using PLLSAI1N = Field<8, 7>;    // SAI1PLL multiplication factor for VCO
            using PLLSAI1M = Field<4, 4>;    // Division factor for PLLSAI1 input clock
        };

        // PLLSAI2 configuration register
        struct PLLSAI2CFGR : public Register<0x40021014> {
            using PLLSAI2PDIV = Field<27, 5>;    // PLLSAI2 division factor for PLLSAI2CLK
            using PLLSAI2R = Field<25, 2>;    // PLLSAI2 division factor for PLLADC2CLK (ADC clock)
            using PLLSAI2REN = Field<24, 1>;    // PLLSAI2 PLLADC2CLK output enable
            using PLLSAI2Q = Field<21, 2>;    // SAI2PLL PLLSAI2CLK output enable
            using PLLSAI2QEN = Field<20, 1>;    // PLLSAI2 division factor for PLLDISCLK
            using PLLSAI2P = Field<17, 1>;    // SAI1PLL division factor for PLLSAI2CLK (SAI1 or SAI2 clock)
            using PLLSAI2PEN = Field<16, 1>;    // SAI2PLL PLLSAI2CLK output enable
            using PLLSAI2N = Field<8, 7>;    // SAI2PLL multiplication factor for VCO
            using PLLSAI2M = Field<4, 4>;    // Division factor for PLLSAI2 input clock
        };

        // Clock interrupt enable register
        struct CIER : public Register<0x40021018> {
            using LSIRDYIE = Field<0, 1>;    // LSI ready interrupt enable
            using LSERDYIE = Field<1, 1>;    // LSE ready interrupt enable
            using MSIRDYIE = Field<2, 1>;    // MSI ready interrupt enable
            using HSIRDYIE = Field<3, 1>;    // HSI ready interrupt enable
            using HSERDYIE = Field<4, 1>;    // HSE ready interrupt enable
            using PLLRDYIE = Field<5, 1>;    // PLL ready interrupt enable
            using PLLSAI1RDYIE = Field<6, 1>;    // PLLSAI1 ready interrupt enable
            using PLLSAI2RDYIE = Field<7, 1>;    // PLLSAI2 ready interrupt enable
            using LSECSSIE = Field<9, 1>;    // LSE clock security system interrupt enable
            using HSI48RDYIE = Field<10, 1>;    // HSI48 ready interrupt enable
        };

        // Clock interrupt flag register
        struct CIFR : public Register<0x4002101c> {
            using LSIRDYF = Field<0, 1>;    // LSI ready interrupt flag
            using LSERDYF = Field<1, 1>;    // LSE ready interrupt flag
            using MSIRDYF = Field<2, 1>;    // MSI ready interrupt flag
            using HSIRDYF = Field<3, 1>;    // HSI ready interrupt flag
            using HSERDYF = Field<4, 1>;    // HSE ready interrupt flag
            using PLLRDYF = Field<5, 1>;    // PLL ready interrupt flag
            using PLLSAI1RDYF = Field<6, 1>;    // PLLSAI1 ready interrupt flag
            using PLLSAI2RDYF = Field<7, 1>;    // PLLSAI2 ready interrupt flag
            using CSSF = Field<8, 1>;    // Clock security system interrupt flag
            using LSECSSF = Field<9, 1>;    // LSE Clock security system interrupt flag
            using HSI48RDYF = Field<10, 1>;    // HSI48 ready interrupt flag
        };

        // Clock interrupt clear register
        struct CICR : public Register<0x40021020> {
            using LSIRDYC = Field<0, 1>;    // LSI ready interrupt clear
            using LSERDYC = Field<1, 1>;    // LSE ready interrupt clear
            using MSIRDYC = Field<2, 1>;    // MSI ready interrupt clear
            using HSIRDYC = Field<3, 1>;    // HSI ready interrupt clear
            using HSERDYC = Field<4, 1>;    // HSE ready interrupt clear
            using PLLRDYC = Field<5, 1>;    // PLL ready interrupt clear
            using PLLSAI1RDYC = Field<6, 1>;    // PLLSAI1 ready interrupt clear
            using PLLSAI2RDYC = Field<7, 1>;    // PLLSAI2 ready interrupt clear
            using CSSC = Field<8, 1>;    // Clock security system interrupt clear
            using LSECSSC = Field<9, 1>;    // LSE Clock security system interrupt clear
            using HSI48RDYC = Field<10, 1>;    // HSI48 oscillator ready interrupt clear
        };

        // AHB1 peripheral reset register
        struct AHB1RSTR : public Register<0x40021028> {
            using DMA1RST = Field<0, 1>;    // DMA1 reset
            using DMA2RST = Field<1, 1>;    // DMA2 reset
            using DMAMUX1RST = Field<2, 1>;    // DMAMUXRST
            using FLASHRST = Field<8, 1>;    // Flash memory interface reset
            using CRCRST = Field<12, 1>;    // CRC reset
            using TSCRST = Field<16, 1>;    // Touch Sensing Controller reset
            using DMA2DRST = Field<17, 1>;    // DMA2D reset
            using GFXMMURST = Field<18, 1>;    // GFXMMU reset
        };

        // AHB2 peripheral reset register
        struct AHB2RSTR : public Register<0x4002102c> {
            using GPIOARST = Field<0, 1>;    // IO port A reset
            using GPIOBRST = Field<1, 1>;    // IO port B reset
            using GPIOCRST = Field<2, 1>;    // IO port C reset
            using GPIODRST = Field<3, 1>;    // IO port D reset
            using GPIOERST = Field<4, 1>;    // IO port E reset
            using GPIOFRST = Field<5, 1>;    // IO port F reset
            using GPIOGRST = Field<6, 1>;    // IO port G reset
            using GPIOHRST = Field<7, 1>;    // IO port H reset
            using GPIOIRST = Field<8, 1>;    // IO port I reset
            using OTGFSRST = Field<12, 1>;    // USB OTG FS reset
            using ADCRST = Field<13, 1>;    // ADC reset
            using DCMIRST = Field<14, 1>;    // Digital Camera Interface reset
            using AESRST = Field<16, 1>;    // AES hardware accelerator reset
            using HASHRST = Field<17, 1>;    // Hash reset
            using RNGRST = Field<18, 1>;    // Random number generator reset
            using OSPIMRST = Field<20, 1>;    // OCTOSPI IO manager reset
            using SDMMC1RST = Field<22, 1>;    // SDMMC1 reset
        };

        // AHB3 peripheral reset register
        struct AHB3RSTR : public Register<0x40021030> {
            using FMCRST = Field<0, 1>;    // Flexible memory controller reset
            using OSPI2RST = Field<9, 1>;    // OctOSPI2 memory interface reset
        };

        // APB1 peripheral reset register 1
        struct APB1RSTR1 : public Register<0x40021038> {
            using LPTIM1RST = Field<31, 1>;    // Low Power Timer 1 reset
            using OPAMPRST = Field<30, 1>;    // OPAMP interface reset
            using DAC1RST = Field<29, 1>;    // DAC1 interface reset
            using PWRRST = Field<28, 1>;    // Power interface reset
            using CAN1RST = Field<25, 1>;    // CAN1 reset
            using CRSRST = Field<24, 1>;    // CRS reset
            using I2C3RST = Field<23, 1>;    // I2C3 reset
            using I2C2RST = Field<22, 1>;    // I2C2 reset
            using I2C1RST = Field<21, 1>;    // I2C1 reset
            using UART5RST = Field<20, 1>;    // UART5 reset
            using UART4RST = Field<19, 1>;    // UART4 reset
            using USART3RST = Field<18, 1>;    // USART3 reset
            using USART2RST = Field<17, 1>;    // USART2 reset
            using SPI3RST = Field<15, 1>;    // SPI3 reset
            using SPI2RST = Field<14, 1>;    // SPI2 reset
            using TIM7RST = Field<5, 1>;    // TIM7 timer reset
            using TIM6RST = Field<4, 1>;    // TIM6 timer reset
            using TIM5RST = Field<3, 1>;    // TIM5 timer reset
            using TIM4RST = Field<2, 1>;    // TIM3 timer reset
            using TIM3RST = Field<1, 1>;    // TIM3 timer reset
            using TIM2RST = Field<0, 1>;    // TIM2 timer reset
        };

        // APB1 peripheral reset register 2
        struct APB1RSTR2 : public Register<0x4002103c> {
            using LPUART1RST = Field<0, 1>;    // Low-power UART 1 reset
            using I2C4RST = Field<1, 1>;    // I2C4 reset
            using LPTIM2RST = Field<5, 1>;    // Low-power timer 2 reset
        };

        // APB2 peripheral reset register
        struct APB2RSTR : public Register<0x40021040> {
            using SYSCFGRST = Field<0, 1>;    // System configuration (SYSCFG) reset
            using TIM1RST = Field<11, 1>;    // TIM1 timer reset
            using SPI1RST = Field<12, 1>;    // SPI1 reset
            using TIM8RST = Field<13, 1>;    // TIM8 timer reset
            using USART1RST = Field<14, 1>;    // USART1 reset
            using TIM15RST = Field<16, 1>;    // TIM15 timer reset
            using TIM16RST = Field<17, 1>;    // TIM16 timer reset
            using TIM17RST = Field<18, 1>;    // TIM17 timer reset
            using SAI1RST = Field<21, 1>;    // Serial audio interface 1 (SAI1) reset
            using SAI2RST = Field<22, 1>;    // Serial audio interface 2 (SAI2) reset
            using DFSDM1RST = Field<24, 1>;    // Digital filters for sigma-delata modulators (DFSDM) reset
            using LTDCRST = Field<26, 1>;    // LCD-TFT reset
            using DSIRST = Field<27, 1>;    // DSI reset
        };

        // AHB1 peripheral clock enable register
        struct AHB1ENR : public Register<0x40021048> {
            using DMA1EN = Field<0, 1>;    // DMA1 clock enable
            using DMA2EN = Field<1, 1>;    // DMA2 clock enable
            using DMAMUX1EN = Field<2, 1>;    // DMAMUX clock enable
            using FLASHEN = Field<8, 1>;    // Flash memory interface clock enable
            using CRCEN = Field<12, 1>;    // CRC clock enable
            using TSCEN = Field<16, 1>;    // Touch Sensing Controller clock enable
            using DMA2DEN = Field<17, 1>;    // DMA2D clock enable
            using GFXMMUEN = Field<18, 1>;    // Graphic MMU clock enable
        };

        // AHB2 peripheral clock enable register
        struct AHB2ENR : public Register<0x4002104c> {
            using GPIOAEN = Field<0, 1>;    // IO port A clock enable
            using GPIOBEN = Field<1, 1>;    // IO port B clock enable
            using GPIOCEN = Field<2, 1>;    // IO port C clock enable
            using GPIODEN = Field<3, 1>;    // IO port D clock enable
            using GPIOEEN = Field<4, 1>;    // IO port E clock enable
            using GPIOFEN = Field<5, 1>;    // IO port F clock enable
            using GPIOGEN = Field<6, 1>;    // IO port G clock enable
            using GPIOHEN = Field<7, 1>;    // IO port H clock enable
            using GPIOIEN = Field<8, 1>;    // IO port I clock enable
            using OTGFSEN = Field<12, 1>;    // OTG full speed clock enable
            using ADCEN = Field<13, 1>;    // ADC clock enable
            using DCMIEN = Field<14, 1>;    // DCMI clock enable
            using AESEN = Field<16, 1>;    // AES accelerator clock enable
            using HASHEN = Field<17, 1>;    // HASH clock enable
            using RNGEN = Field<18, 1>;    // Random Number Generator clock enable
            using OSPIMEN = Field<20, 1>;    // OctoSPI IO manager clock enable
            using SDMMC1EN = Field<22, 1>;    // SDMMC1 clock enable
        };

        // AHB3 peripheral clock enable register
        struct AHB3ENR : public Register<0x40021050> {
            using FMCEN = Field<0, 1>;    // Flexible memory controller clock enable
            using OSPI2EN = Field<9, 1>;    // OSPI2EN memory interface clock enable
        };

        // APB1ENR1
        struct APB1ENR1 : public Register<0x40021058> {
            using TIM2EN = Field<0, 1>;    // TIM2 timer clock enable
            using TIM3EN = Field<1, 1>;    // TIM3 timer clock enable
            using TIM4EN = Field<2, 1>;    // TIM4 timer clock enable
            using TIM5EN = Field<3, 1>;    // TIM5 timer clock enable
            using TIM6EN = Field<4, 1>;    // TIM6 timer clock enable
            using TIM7EN = Field<5, 1>;    // TIM7 timer clock enable
            using RTCAPBEN = Field<10, 1>;    // RTC APB clock enable
            using WWDGEN = Field<11, 1>;    // Window watchdog clock enable
            using SPI2EN = Field<14, 1>;    // SPI2 clock enable
            using SP3EN = Field<15, 1>;    // SPI3 clock enable
            using USART2EN = Field<17, 1>;    // USART2 clock enable
            using USART3EN = Field<18, 1>;    // USART3 clock enable
            using UART4EN = Field<19, 1>;    // UART4 clock enable
            using UART5EN = Field<20, 1>;    // UART5 clock enable
            using I2C1EN = Field<21, 1>;    // I2C1 clock enable
            using I2C2EN = Field<22, 1>;    // I2C2 clock enable
            using I2C3EN = Field<23, 1>;    // I2C3 clock enable
            using CRSEN = Field<24, 1>;    // Clock Recovery System clock enable
            using CAN1EN = Field<25, 1>;    // CAN1 clock enable
            using PWREN = Field<28, 1>;    // Power interface clock enable
            using DAC1EN = Field<29, 1>;    // DAC1 interface clock enable
            using OPAMPEN = Field<30, 1>;    // OPAMP interface clock enable
            using LPTIM1EN = Field<31, 1>;    // Low power timer 1 clock enable
        };

        // APB1 peripheral clock enable register 2
        struct APB1ENR2 : public Register<0x4002105c> {
            using LPUART1EN = Field<0, 1>;    // Low power UART 1 clock enable
            using I2C4EN = Field<1, 1>;    // I2C4 clock enable
            using LPTIM2EN = Field<5, 1>;    // LPTIM2EN
        };

        // APB2ENR
        struct APB2ENR : public Register<0x40021060> {
            using SYSCFGEN = Field<0, 1>;    // SYSCFG clock enable
            using FWEN = Field<7, 1>;    // Firewall clock enable
            using TIM1EN = Field<11, 1>;    // TIM1 timer clock enable
            using SPI1EN = Field<12, 1>;    // SPI1 clock enable
            using TIM8EN = Field<13, 1>;    // TIM8 timer clock enable
            using USART1EN = Field<14, 1>;    // USART1clock enable
            using TIM15EN = Field<16, 1>;    // TIM15 timer clock enable
            using TIM16EN = Field<17, 1>;    // TIM16 timer clock enable
            using TIM17EN = Field<18, 1>;    // TIM17 timer clock enable
            using SAI1EN = Field<21, 1>;    // SAI1 clock enable
            using SAI2EN = Field<22, 1>;    // SAI2 clock enable
            using DFSDM1EN = Field<24, 1>;    // DFSDM timer clock enable
            using LTDCEN = Field<26, 1>;    // LCD-TFT clock enable
            using DSIEN = Field<27, 1>;    // DSI clock enable
        };

        // AHB1 peripheral clocks enable in Sleep and Stop modes register
        struct AHB1SMENR : public Register<0x40021068> {
            using DMA1SMEN = Field<0, 1>;    // DMA1 clocks enable during Sleep and Stop modes
            using DMA2SMEN = Field<1, 1>;    // DMA2 clocks enable during Sleep and Stop modes
            using DMAMUX1SMEN = Field<2, 1>;    // DMAMUX clock enable during Sleep and Stop modes
            using FLASHSMEN = Field<8, 1>;    // Flash memory interface clocks enable during Sleep and Stop modes
            using SRAM1SMEN = Field<9, 1>;    // SRAM1 interface clocks enable during Sleep and Stop modes
            using CRCSMEN = Field<12, 1>;    // CRCSMEN
            using TSCSMEN = Field<16, 1>;    // Touch Sensing Controller clocks enable during Sleep and Stop modes
            using DMA2DSMEN = Field<17, 1>;    // DMA2D clock enable during Sleep and Stop modes
            using GFXMMUSMEN = Field<18, 1>;    // GFXMMU clock enable during Sleep and Stop modes
        };

        // AHB2 peripheral clocks enable in Sleep and Stop modes register
        struct AHB2SMENR : public Register<0x4002106c> {
            using GPIOASMEN = Field<0, 1>;    // IO port A clocks enable during Sleep and Stop modes
            using GPIOBSMEN = Field<1, 1>;    // IO port B clocks enable during Sleep and Stop modes
            using GPIOCSMEN = Field<2, 1>;    // IO port C clocks enable during Sleep and Stop modes
            using GPIODSMEN = Field<3, 1>;    // IO port D clocks enable during Sleep and Stop modes
            using GPIOESMEN = Field<4, 1>;    // IO port E clocks enable during Sleep and Stop modes
            using GPIOFSMEN = Field<5, 1>;    // IO port F clocks enable during Sleep and Stop modes
            using GPIOGSMEN = Field<6, 1>;    // IO port G clocks enable during Sleep and Stop modes
            using GPIOHSMEN = Field<7, 1>;    // IO port H clocks enable during Sleep and Stop modes
            using GPIOISMEN = Field<8, 1>;    // IO port I clocks enable during Sleep and Stop modes
            using SRAM2SMEN = Field<9, 1>;    // SRAM2 interface clocks enable during Sleep and Stop modes
            using SRAM3SMEN = Field<10, 1>;    // SRAM2 interface clocks enable during Sleep and Stop modes
            using OTGFSSMEN = Field<12, 1>;    // OTG full speed clocks enable during Sleep and Stop modes
            using ADCFSSMEN = Field<13, 1>;    // ADC clocks enable during Sleep and Stop modes
            using DCMISMEN = Field<14, 1>;    // DCMI clock enable during Sleep and Stop modes
            using AESSMEN = Field<16, 1>;    // AES accelerator clocks enable during Sleep and Stop modes
            using HASHSMEN = Field<17, 1>;    // HASH clock enable during Sleep and Stop modes
            using RNGSMEN = Field<18, 1>;    // Random Number Generator clocks enable during Sleep and Stop modes
            using OSPIMSMEN = Field<20, 1>;    // OctoSPI IO manager clocks enable during Sleep and Stop modes
            using SDMMC1SMEN = Field<22, 1>;    // SDMMC1 clocks enable during Sleep and Stop modes
        };

        // AHB3 peripheral clocks enable in Sleep and Stop modes register
        struct AHB3SMENR : public Register<0x40021070> {
            using FMCSMEN = Field<0, 1>;    // Flexible memory controller clocks enable during Sleep and Stop modes
            using OCTOSPI2 = Field<9, 1>;    // OctoSPI2 memory interface clocks enable during Sleep and Stop modes
        };

        // APB1SMENR1
        struct APB1SMENR1 : public Register<0x40021078> {
            using TIM2SMEN = Field<0, 1>;    // TIM2 timer clocks enable during Sleep and Stop modes
            using TIM3SMEN = Field<1, 1>;    // TIM3 timer clocks enable during Sleep and Stop modes
            using TIM4SMEN = Field<2, 1>;    // TIM4 timer clocks enable during Sleep and Stop modes
            using TIM5SMEN = Field<3, 1>;    // TIM5 timer clocks enable during Sleep and Stop modes
            using TIM6SMEN = Field<4, 1>;    // TIM6 timer clocks enable during Sleep and Stop modes
            using TIM7SMEN = Field<5, 1>;    // TIM7 timer clocks enable during Sleep and Stop modes
            using RTCAPBSMEN = Field<10, 1>;    // RTC APB clock enable during Sleep and Stop modes
            using WWDGSMEN = Field<11, 1>;    // Window watchdog clocks enable during Sleep and Stop modes
            using SPI2SMEN = Field<14, 1>;    // SPI2 clocks enable during Sleep and Stop modes
            using SP3SMEN = Field<15, 1>;    // SPI3 clocks enable during Sleep and Stop modes
            using USART2SMEN = Field<17, 1>;    // USART2 clocks enable during Sleep and Stop modes
            using USART3SMEN = Field<18, 1>;    // USART3 clocks enable during Sleep and Stop modes
            using UART4SMEN = Field<19, 1>;    // UART4 clocks enable during Sleep and Stop modes
            using UART5SMEN = Field<20, 1>;    // UART5 clocks enable during Sleep and Stop modes
            using I2C1SMEN = Field<21, 1>;    // I2C1 clocks enable during Sleep and Stop modes
            using I2C2SMEN = Field<22, 1>;    // I2C2 clocks enable during Sleep and Stop modes
            using I2C3SMEN = Field<23, 1>;    // I2C3 clocks enable during Sleep and Stop modes
            using CRSSMEN = Field<24, 1>;    // CRS clock enable during Sleep and Stop modes
            using CAN1SMEN = Field<25, 1>;    // CAN1 clocks enable during Sleep and Stop modes
            using PWRSMEN = Field<28, 1>;    // Power interface clocks enable during Sleep and Stop modes
            using DAC1SMEN = Field<29, 1>;    // DAC1 interface clocks enable during Sleep and Stop modes
            using OPAMPSMEN = Field<30, 1>;    // OPAMP interface clocks enable during Sleep and Stop modes
            using LPTIM1SMEN = Field<31, 1>;    // Low power timer 1 clocks enable during Sleep and Stop modes
        };

        // APB1 peripheral clocks enable in Sleep and Stop modes register 2
        struct APB1SMENR2 : public Register<0x4002107c> {
            using LPUART1SMEN = Field<0, 1>;    // Low power UART 1 clocks enable during Sleep and Stop modes
            using I2C4SMEN = Field<1, 1>;    // I2C4 clocks enable during Sleep and Stop modes
            using LPTIM2SMEN = Field<5, 1>;    // LPTIM2SMEN
        };

        // APB2SMENR
        struct APB2SMENR : public Register<0x40021080> {
            using SYSCFGSMEN = Field<0, 1>;    // SYSCFG clocks enable during Sleep and Stop modes
            using TIM1SMEN = Field<11, 1>;    // TIM1 timer clocks enable during Sleep and Stop modes
            using SPI1SMEN = Field<12, 1>;    // SPI1 clocks enable during Sleep and Stop modes
            using TIM8SMEN = Field<13, 1>;    // TIM8 timer clocks enable during Sleep and Stop modes
            using USART1SMEN = Field<14, 1>;    // USART1clocks enable during Sleep and Stop modes
            using TIM15SMEN = Field<16, 1>;    // TIM15 timer clocks enable during Sleep and Stop modes
            using TIM16SMEN = Field<17, 1>;    // TIM16 timer clocks enable during Sleep and Stop modes
            using TIM17SMEN = Field<18, 1>;    // TIM17 timer clocks enable during Sleep and Stop modes
            using SAI1SMEN = Field<21, 1>;    // SAI1 clocks enable during Sleep and Stop modes
            using SAI2SMEN = Field<22, 1>;    // SAI2 clocks enable during Sleep and Stop modes
            using DFSDM1SMEN = Field<24, 1>;    // DFSDM timer clocks enable during Sleep and Stop modes
            using LTDCSMEN = Field<26, 1>;    // LCD-TFT timer clocks enable during Sleep and Stop modes
            using DSISMEN = Field<27, 1>;    // DSI clocks enable during Sleep and Stop modes
        };

        // CCIPR
        struct CCIPR : public Register<0x40021088> {
            using ADCSEL = Field<28, 2>;    // ADCs clock source selection
            using CLK48SEL = Field<26, 2>;    // 48 MHz clock source selection
            using SAI2SEL = Field<24, 2>;    // SAI2 clock source selection
            using SAI1SEL = Field<22, 2>;    // SAI1 clock source selection
            using LPTIM2SEL = Field<20, 2>;    // Low power timer 2 clock source selection
            using LPTIM1SEL = Field<18, 2>;    // Low power timer 1 clock source selection
            using I2C3SEL = Field<16, 2>;    // I2C3 clock source selection
            using I2C2SEL = Field<14, 2>;    // I2C2 clock source selection
            using I2C1SEL = Field<12, 2>;    // I2C1 clock source selection
            using LPUART1SEL = Field<10, 2>;    // LPUART1 clock source selection
            using UART5SEL = Field<8, 2>;    // UART5 clock source selection
            using UART4SEL = Field<6, 2>;    // UART4 clock source selection
            using USART3SEL = Field<4, 2>;    // USART3 clock source selection
            using USART2SEL = Field<2, 2>;    // USART2 clock source selection
            using USART1SEL = Field<0, 2>;    // USART1 clock source selection
        };

        // BDCR
        struct BDCR : public Register<0x40021090> {
            using LSCOSEL = Field<25, 1>;    // Low speed clock output selection
            using LSCOEN = Field<24, 1>;    // Low speed clock output enable
            using BDRST = Field<16, 1>;    // Backup domain software reset
            using RTCEN = Field<15, 1>;    // RTC clock enable
            using RTCSEL = Field<8, 2>;    // RTC clock source selection
            using LSECSSD = Field<6, 1>;    // LSECSSD
            using LSECSSON = Field<5, 1>;    // LSECSSON
            using LSEDRV = Field<3, 2>;    // SE oscillator drive capability
            using LSEBYP = Field<2, 1>;    // LSE oscillator bypass
            using LSERDY = Field<1, 1>;    // LSE oscillator ready
            using LSEON = Field<0, 1>;    // LSE oscillator enable
        };

        // CSR
        struct CSR : public Register<0x40021094> {
            using LPWRSTF = Field<31, 1>;    // Low-power reset flag
            using WWDGRSTF = Field<30, 1>;    // Window watchdog reset flag
            using IWDGRSTF = Field<29, 1>;    // Independent window watchdog reset flag
            using SFTRSTF = Field<28, 1>;    // Software reset flag
            using BORRSTF = Field<27, 1>;    // BOR flag
            using PINRSTF = Field<26, 1>;    // Pin reset flag
            using OBLRSTF = Field<25, 1>;    // Option byte loader reset flag
            using FWRSTF = Field<24, 1>;    // Firewall reset flag
            using RMVF = Field<23, 1>;    // Remove reset flag
            using MSISRANGE = Field<8, 4>;    // SI range after Standby mode
            using LSIRDY = Field<1, 1>;    // LSI oscillator ready
            using LSION = Field<0, 1>;    // LSI oscillator enable
        };

        // Clock recovery RC register
        struct CRRCR : public Register<0x40021098> {
            using HSI48ON = Field<0, 1>;    // HSI48 clock enable
            using HSI48RDY = Field<1, 1>;    // HSI48 clock ready flag
            using HSI48CAL = Field<7, 9>;    // HSI48 clock calibration
        };

        // Peripherals independent clock configuration register
        struct CCIPR2 : public Register<0x4002109c> {
            using I2C4SEL = Field<0, 2>;    // I2C4 clock source selection
            using DFSDMSEL = Field<2, 1>;    // Digital filter for sigma delta modulator kernel clock source selection
            using ADFSDMSEL = Field<3, 2>;    // Digital filter for sigma delta modulator audio clock source selection
            using SAI1SEL = Field<5, 3>;    // SAI1 clock source selection
            using SAI2SEL = Field<8, 3>;    // SAI2 clock source selection
            using DSISEL = Field<12, 1>;    // clock selection
            using SDMMCSEL = Field<14, 1>;    // SDMMC clock selection
            using PLLSAI2DIVR = Field<16, 2>;    // division factor for LTDC clock
            using OSPISEL = Field<20, 2>;    // Octospi clock source selection
        };

    };

    // Power control
    struct PWR {
        // Power control register 1
        struct CR1 : public Register<0x40007000> {
            using LPR = Field<14, 1>;    // Low-power run
            using VOS = Field<9, 2>;    // Voltage scaling range selection
            using DBP = Field<8, 1>;    // Disable backup domain write protection
            using LPMS = Field<0, 3>;    // Low-power mode selection
        };

        // Power control register 2
        struct CR2 : public Register<0x40007004> {
            using USV = Field<10, 1>;    // VDDUSB USB supply valid
            using IOSV = Field<9, 1>;    // VDDIO2 Independent I/Os supply valid
            using PVME4 = Field<7, 1>;    // Peripheral voltage monitoring 4 enable: VDDA vs. 2.2V
            using PVME3 = Field<6, 1>;    // Peripheral voltage monitoring 3 enable: VDDA vs. 1.62V
            using PVME2 = Field<5, 1>;    // Peripheral voltage monitoring 2 enable: VDDIO2 vs. 0.9V
            using PVME1 = Field<4, 1>;    // Peripheral voltage monitoring 1 enable: VDDUSB vs. 1.2V
            using PLS = Field<1, 3>;    // Power voltage detector level selection
            using PVDE = Field<0, 1>;    // Power voltage detector enable
        };

        // Power control register 3
        struct CR3 : public Register<0x40007008> {
            using EWF = Field<15, 1>;    // Enable internal wakeup line
            using APC = Field<10, 1>;    // Apply pull-up and pull-down configuration
            using RRS = Field<8, 1>;    // SRAM2 retention in Standby mode
            using EWUP5 = Field<4, 1>;    // Enable Wakeup pin WKUP5
            using EWUP4 = Field<3, 1>;    // Enable Wakeup pin WKUP4
            using EWUP3 = Field<2, 1>;    // Enable Wakeup pin WKUP3
            using EWUP2 = Field<1, 1>;    // Enable Wakeup pin WKUP2
            using EWUP1 = Field<0, 1>;    // Enable Wakeup pin WKUP1
        };

        // Power control register 4
        struct CR4 : public Register<0x4000700c> {
            using VBRS = Field<9, 1>;    // VBAT battery charging resistor selection
            using VBE = Field<8, 1>;    // VBAT battery charging enable
            using WP5 = Field<4, 1>;    // Wakeup pin WKUP5 polarity
            using WP4 = Field<3, 1>;    // Wakeup pin WKUP4 polarity
            using WP3 = Field<2, 1>;    // Wakeup pin WKUP3 polarity
            using WP2 = Field<1, 1>;    // Wakeup pin WKUP2 polarity
            using WP1 = Field<0, 1>;    // Wakeup pin WKUP1 polarity
        };

        // Power status register 1
        struct SR1 : public Register<0x40007010> {
            using WUFI = Field<15, 1>;    // Wakeup flag internal
            using CSBF = Field<8, 1>;    // Standby flag
            using CWUF5 = Field<4, 1>;    // Wakeup flag 5
            using CWUF4 = Field<3, 1>;    // Wakeup flag 4
            using CWUF3 = Field<2, 1>;    // Wakeup flag 3
            using CWUF2 = Field<1, 1>;    // Wakeup flag 2
            using CWUF1 = Field<0, 1>;    // Wakeup flag 1
        };

        // Power status register 2
        struct SR2 : public Register<0x40007014> {
            using PVMO4 = Field<15, 1>;    // Peripheral voltage monitoring output: VDDA vs. 2.2 V
            using PVMO3 = Field<14, 1>;    // Peripheral voltage monitoring output: VDDA vs. 1.62 V
            using PVMO2 = Field<13, 1>;    // Peripheral voltage monitoring output: VDDIO2 vs. 0.9 V
            using PVMO1 = Field<12, 1>;    // Peripheral voltage monitoring output: VDDUSB vs. 1.2 V
            using PVDO = Field<11, 1>;    // Power voltage detector output
            using VOSF = Field<10, 1>;    // Voltage scaling flag
            using REGLPF = Field<9, 1>;    // Low-power regulator flag
            using REGLPS = Field<8, 1>;    // Low-power regulator started
        };

        // Power status clear register
        struct SCR : public Register<0x40007018> {
            using SBF = Field<8, 1>;    // Clear standby flag
            using WUF5 = Field<4, 1>;    // Clear wakeup flag 5
            using WUF4 = Field<3, 1>;    // Clear wakeup flag 4
            using WUF3 = Field<2, 1>;    // Clear wakeup flag 3
            using WUF2 = Field<1, 1>;    // Clear wakeup flag 2
            using WUF1 = Field<0, 1>;    // Clear wakeup flag 1
        };

        // Power Port A pull-up control register
        struct PUCRA : public Register<0x40007020> {
            using PU15 = Field<15, 1>;    // Port A pull-up bit y (y=0..15)
            using PU14 = Field<14, 1>;    // Port A pull-up bit y (y=0..15)
            using PU13 = Field<13, 1>;    // Port A pull-up bit y (y=0..15)
            using PU12 = Field<12, 1>;    // Port A pull-up bit y (y=0..15)
            using PU11 = Field<11, 1>;    // Port A pull-up bit y (y=0..15)
            using PU10 = Field<10, 1>;    // Port A pull-up bit y (y=0..15)
            using PU9 = Field<9, 1>;    // Port A pull-up bit y (y=0..15)
            using PU8 = Field<8, 1>;    // Port A pull-up bit y (y=0..15)
            using PU7 = Field<7, 1>;    // Port A pull-up bit y (y=0..15)
            using PU6 = Field<6, 1>;    // Port A pull-up bit y (y=0..15)
            using PU5 = Field<5, 1>;    // Port A pull-up bit y (y=0..15)
            using PU4 = Field<4, 1>;    // Port A pull-up bit y (y=0..15)
            using PU3 = Field<3, 1>;    // Port A pull-up bit y (y=0..15)
            using PU2 = Field<2, 1>;    // Port A pull-up bit y (y=0..15)
            using PU1 = Field<1, 1>;    // Port A pull-up bit y (y=0..15)
            using PU0 = Field<0, 1>;    // Port A pull-up bit y (y=0..15)
        };

        // Power Port A pull-down control register
        struct PDCRA : public Register<0x40007024> {
            using PD15 = Field<15, 1>;    // Port A pull-down bit y (y=0..15)
            using PD14 = Field<14, 1>;    // Port A pull-down bit y (y=0..15)
            using PD13 = Field<13, 1>;    // Port A pull-down bit y (y=0..15)
            using PD12 = Field<12, 1>;    // Port A pull-down bit y (y=0..15)
            using PD11 = Field<11, 1>;    // Port A pull-down bit y (y=0..15)
            using PD10 = Field<10, 1>;    // Port A pull-down bit y (y=0..15)
            using PD9 = Field<9, 1>;    // Port A pull-down bit y (y=0..15)
            using PD8 = Field<8, 1>;    // Port A pull-down bit y (y=0..15)
            using PD7 = Field<7, 1>;    // Port A pull-down bit y (y=0..15)
            using PD6 = Field<6, 1>;    // Port A pull-down bit y (y=0..15)
            using PD5 = Field<5, 1>;    // Port A pull-down bit y (y=0..15)
            using PD4 = Field<4, 1>;    // Port A pull-down bit y (y=0..15)
            using PD3 = Field<3, 1>;    // Port A pull-down bit y (y=0..15)
            using PD2 = Field<2, 1>;    // Port A pull-down bit y (y=0..15)
            using PD1 = Field<1, 1>;    // Port A pull-down bit y (y=0..15)
            using PD0 = Field<0, 1>;    // Port A pull-down bit y (y=0..15)
        };

        // Power Port B pull-up control register
        struct PUCRB : public Register<0x40007028> {
            using PU15 = Field<15, 1>;    // Port B pull-up bit y (y=0..15)
            using PU14 = Field<14, 1>;    // Port B pull-up bit y (y=0..15)
            using PU13 = Field<13, 1>;    // Port B pull-up bit y (y=0..15)
            using PU12 = Field<12, 1>;    // Port B pull-up bit y (y=0..15)
            using PU11 = Field<11, 1>;    // Port B pull-up bit y (y=0..15)
            using PU10 = Field<10, 1>;    // Port B pull-up bit y (y=0..15)
            using PU9 = Field<9, 1>;    // Port B pull-up bit y (y=0..15)
            using PU8 = Field<8, 1>;    // Port B pull-up bit y (y=0..15)
            using PU7 = Field<7, 1>;    // Port B pull-up bit y (y=0..15)
            using PU6 = Field<6, 1>;    // Port B pull-up bit y (y=0..15)
            using PU5 = Field<5, 1>;    // Port B pull-up bit y (y=0..15)
            using PU4 = Field<4, 1>;    // Port B pull-up bit y (y=0..15)
            using PU3 = Field<3, 1>;    // Port B pull-up bit y (y=0..15)
            using PU2 = Field<2, 1>;    // Port B pull-up bit y (y=0..15)
            using PU1 = Field<1, 1>;    // Port B pull-up bit y (y=0..15)
            using PU0 = Field<0, 1>;    // Port B pull-up bit y (y=0..15)
        };

        // Power Port B pull-down control register
        struct PDCRB : public Register<0x4000702c> {
            using PD15 = Field<15, 1>;    // Port B pull-down bit y (y=0..15)
            using PD14 = Field<14, 1>;    // Port B pull-down bit y (y=0..15)
            using PD13 = Field<13, 1>;    // Port B pull-down bit y (y=0..15)
            using PD12 = Field<12, 1>;    // Port B pull-down bit y (y=0..15)
            using PD11 = Field<11, 1>;    // Port B pull-down bit y (y=0..15)
            using PD10 = Field<10, 1>;    // Port B pull-down bit y (y=0..15)
            using PD9 = Field<9, 1>;    // Port B pull-down bit y (y=0..15)
            using PD8 = Field<8, 1>;    // Port B pull-down bit y (y=0..15)
            using PD7 = Field<7, 1>;    // Port B pull-down bit y (y=0..15)
            using PD6 = Field<6, 1>;    // Port B pull-down bit y (y=0..15)
            using PD5 = Field<5, 1>;    // Port B pull-down bit y (y=0..15)
            using PD4 = Field<4, 1>;    // Port B pull-down bit y (y=0..15)
            using PD3 = Field<3, 1>;    // Port B pull-down bit y (y=0..15)
            using PD2 = Field<2, 1>;    // Port B pull-down bit y (y=0..15)
            using PD1 = Field<1, 1>;    // Port B pull-down bit y (y=0..15)
            using PD0 = Field<0, 1>;    // Port B pull-down bit y (y=0..15)
        };

        // Power Port C pull-up control register
        struct PUCRC : public Register<0x40007030> {
            using PU15 = Field<15, 1>;    // Port C pull-up bit y (y=0..15)
            using PU14 = Field<14, 1>;    // Port C pull-up bit y (y=0..15)
            using PU13 = Field<13, 1>;    // Port C pull-up bit y (y=0..15)
            using PU12 = Field<12, 1>;    // Port C pull-up bit y (y=0..15)
            using PU11 = Field<11, 1>;    // Port C pull-up bit y (y=0..15)
            using PU10 = Field<10, 1>;    // Port C pull-up bit y (y=0..15)
            using PU9 = Field<9, 1>;    // Port C pull-up bit y (y=0..15)
            using PU8 = Field<8, 1>;    // Port C pull-up bit y (y=0..15)
            using PU7 = Field<7, 1>;    // Port C pull-up bit y (y=0..15)
            using PU6 = Field<6, 1>;    // Port C pull-up bit y (y=0..15)
            using PU5 = Field<5, 1>;    // Port C pull-up bit y (y=0..15)
            using PU4 = Field<4, 1>;    // Port C pull-up bit y (y=0..15)
            using PU3 = Field<3, 1>;    // Port C pull-up bit y (y=0..15)
            using PU2 = Field<2, 1>;    // Port C pull-up bit y (y=0..15)
            using PU1 = Field<1, 1>;    // Port C pull-up bit y (y=0..15)
            using PU0 = Field<0, 1>;    // Port C pull-up bit y (y=0..15)
        };

        // Power Port C pull-down control register
        struct PDCRC : public Register<0x40007034> {
            using PD15 = Field<15, 1>;    // Port C pull-down bit y (y=0..15)
            using PD14 = Field<14, 1>;    // Port C pull-down bit y (y=0..15)
            using PD13 = Field<13, 1>;    // Port C pull-down bit y (y=0..15)
            using PD12 = Field<12, 1>;    // Port C pull-down bit y (y=0..15)
            using PD11 = Field<11, 1>;    // Port C pull-down bit y (y=0..15)
            using PD10 = Field<10, 1>;    // Port C pull-down bit y (y=0..15)
            using PD9 = Field<9, 1>;    // Port C pull-down bit y (y=0..15)
            using PD8 = Field<8, 1>;    // Port C pull-down bit y (y=0..15)
            using PD7 = Field<7, 1>;    // Port C pull-down bit y (y=0..15)
            using PD6 = Field<6, 1>;    // Port C pull-down bit y (y=0..15)
            using PD5 = Field<5, 1>;    // Port C pull-down bit y (y=0..15)
            using PD4 = Field<4, 1>;    // Port C pull-down bit y (y=0..15)
            using PD3 = Field<3, 1>;    // Port C pull-down bit y (y=0..15)
            using PD2 = Field<2, 1>;    // Port C pull-down bit y (y=0..15)
            using PD1 = Field<1, 1>;    // Port C pull-down bit y (y=0..15)
            using PD0 = Field<0, 1>;    // Port C pull-down bit y (y=0..15)
        };

        // Power Port D pull-up control register
        struct PUCRD : public Register<0x40007038> {
            using PU15 = Field<15, 1>;    // Port D pull-up bit y (y=0..15)
            using PU14 = Field<14, 1>;    // Port D pull-up bit y (y=0..15)
            using PU13 = Field<13, 1>;    // Port D pull-up bit y (y=0..15)
            using PU12 = Field<12, 1>;    // Port D pull-up bit y (y=0..15)
            using PU11 = Field<11, 1>;    // Port D pull-up bit y (y=0..15)
            using PU10 = Field<10, 1>;    // Port D pull-up bit y (y=0..15)
            using PU9 = Field<9, 1>;    // Port D pull-up bit y (y=0..15)
            using PU8 = Field<8, 1>;    // Port D pull-up bit y (y=0..15)
            using PU7 = Field<7, 1>;    // Port D pull-up bit y (y=0..15)
            using PU6 = Field<6, 1>;    // Port D pull-up bit y (y=0..15)
            using PU5 = Field<5, 1>;    // Port D pull-up bit y (y=0..15)
            using PU4 = Field<4, 1>;    // Port D pull-up bit y (y=0..15)
            using PU3 = Field<3, 1>;    // Port D pull-up bit y (y=0..15)
            using PU2 = Field<2, 1>;    // Port D pull-up bit y (y=0..15)
            using PU1 = Field<1, 1>;    // Port D pull-up bit y (y=0..15)
            using PU0 = Field<0, 1>;    // Port D pull-up bit y (y=0..15)
        };

        // Power Port D pull-down control register
        struct PDCRD : public Register<0x4000703c> {
            using PD15 = Field<15, 1>;    // Port D pull-down bit y (y=0..15)
            using PD14 = Field<14, 1>;    // Port D pull-down bit y (y=0..15)
            using PD13 = Field<13, 1>;    // Port D pull-down bit y (y=0..15)
            using PD12 = Field<12, 1>;    // Port D pull-down bit y (y=0..15)
            using PD11 = Field<11, 1>;    // Port D pull-down bit y (y=0..15)
            using PD10 = Field<10, 1>;    // Port D pull-down bit y (y=0..15)
            using PD9 = Field<9, 1>;    // Port D pull-down bit y (y=0..15)
            using PD8 = Field<8, 1>;    // Port D pull-down bit y (y=0..15)
            using PD7 = Field<7, 1>;    // Port D pull-down bit y (y=0..15)
            using PD6 = Field<6, 1>;    // Port D pull-down bit y (y=0..15)
            using PD5 = Field<5, 1>;    // Port D pull-down bit y (y=0..15)
            using PD4 = Field<4, 1>;    // Port D pull-down bit y (y=0..15)
            using PD3 = Field<3, 1>;    // Port D pull-down bit y (y=0..15)
            using PD2 = Field<2, 1>;    // Port D pull-down bit y (y=0..15)
            using PD1 = Field<1, 1>;    // Port D pull-down bit y (y=0..15)
            using PD0 = Field<0, 1>;    // Port D pull-down bit y (y=0..15)
        };

        // Power Port E pull-up control register
        struct PUCRE : public Register<0x40007040> {
            using PU15 = Field<15, 1>;    // Port E pull-up bit y (y=0..15)
            using PU14 = Field<14, 1>;    // Port E pull-up bit y (y=0..15)
            using PU13 = Field<13, 1>;    // Port E pull-up bit y (y=0..15)
            using PU12 = Field<12, 1>;    // Port E pull-up bit y (y=0..15)
            using PU11 = Field<11, 1>;    // Port E pull-up bit y (y=0..15)
            using PU10 = Field<10, 1>;    // Port E pull-up bit y (y=0..15)
            using PU9 = Field<9, 1>;    // Port E pull-up bit y (y=0..15)
            using PU8 = Field<8, 1>;    // Port E pull-up bit y (y=0..15)
            using PU7 = Field<7, 1>;    // Port E pull-up bit y (y=0..15)
            using PU6 = Field<6, 1>;    // Port E pull-up bit y (y=0..15)
            using PU5 = Field<5, 1>;    // Port E pull-up bit y (y=0..15)
            using PU4 = Field<4, 1>;    // Port E pull-up bit y (y=0..15)
            using PU3 = Field<3, 1>;    // Port E pull-up bit y (y=0..15)
            using PU2 = Field<2, 1>;    // Port E pull-up bit y (y=0..15)
            using PU1 = Field<1, 1>;    // Port E pull-up bit y (y=0..15)
            using PU0 = Field<0, 1>;    // Port E pull-up bit y (y=0..15)
        };

        // Power Port E pull-down control register
        struct PDCRE : public Register<0x40007044> {
            using PD15 = Field<15, 1>;    // Port E pull-down bit y (y=0..15)
            using PD14 = Field<14, 1>;    // Port E pull-down bit y (y=0..15)
            using PD13 = Field<13, 1>;    // Port E pull-down bit y (y=0..15)
            using PD12 = Field<12, 1>;    // Port E pull-down bit y (y=0..15)
            using PD11 = Field<11, 1>;    // Port E pull-down bit y (y=0..15)
            using PD10 = Field<10, 1>;    // Port E pull-down bit y (y=0..15)
            using PD9 = Field<9, 1>;    // Port E pull-down bit y (y=0..15)
            using PD8 = Field<8, 1>;    // Port E pull-down bit y (y=0..15)
            using PD7 = Field<7, 1>;    // Port E pull-down bit y (y=0..15)
            using PD6 = Field<6, 1>;    // Port E pull-down bit y (y=0..15)
            using PD5 = Field<5, 1>;    // Port E pull-down bit y (y=0..15)
            using PD4 = Field<4, 1>;    // Port E pull-down bit y (y=0..15)
            using PD3 = Field<3, 1>;    // Port E pull-down bit y (y=0..15)
            using PD2 = Field<2, 1>;    // Port E pull-down bit y (y=0..15)
            using PD1 = Field<1, 1>;    // Port E pull-down bit y (y=0..15)
            using PD0 = Field<0, 1>;    // Port E pull-down bit y (y=0..15)
        };

        // Power Port F pull-up control register
        struct PUCRF : public Register<0x40007048> {
            using PU15 = Field<15, 1>;    // Port F pull-up bit y (y=0..15)
            using PU14 = Field<14, 1>;    // Port F pull-up bit y (y=0..15)
            using PU13 = Field<13, 1>;    // Port F pull-up bit y (y=0..15)
            using PU12 = Field<12, 1>;    // Port F pull-up bit y (y=0..15)
            using PU11 = Field<11, 1>;    // Port F pull-up bit y (y=0..15)
            using PU10 = Field<10, 1>;    // Port F pull-up bit y (y=0..15)
            using PU9 = Field<9, 1>;    // Port F pull-up bit y (y=0..15)
            using PU8 = Field<8, 1>;    // Port F pull-up bit y (y=0..15)
            using PU7 = Field<7, 1>;    // Port F pull-up bit y (y=0..15)
            using PU6 = Field<6, 1>;    // Port F pull-up bit y (y=0..15)
            using PU5 = Field<5, 1>;    // Port F pull-up bit y (y=0..15)
            using PU4 = Field<4, 1>;    // Port F pull-up bit y (y=0..15)
            using PU3 = Field<3, 1>;    // Port F pull-up bit y (y=0..15)
            using PU2 = Field<2, 1>;    // Port F pull-up bit y (y=0..15)
            using PU1 = Field<1, 1>;    // Port F pull-up bit y (y=0..15)
            using PU0 = Field<0, 1>;    // Port F pull-up bit y (y=0..15)
        };

        // Power Port F pull-down control register
        struct PDCRF : public Register<0x4000704c> {
            using PD15 = Field<15, 1>;    // Port F pull-down bit y (y=0..15)
            using PD14 = Field<14, 1>;    // Port F pull-down bit y (y=0..15)
            using PD13 = Field<13, 1>;    // Port F pull-down bit y (y=0..15)
            using PD12 = Field<12, 1>;    // Port F pull-down bit y (y=0..15)
            using PD11 = Field<11, 1>;    // Port F pull-down bit y (y=0..15)
            using PD10 = Field<10, 1>;    // Port F pull-down bit y (y=0..15)
            using PD9 = Field<9, 1>;    // Port F pull-down bit y (y=0..15)
            using PD8 = Field<8, 1>;    // Port F pull-down bit y (y=0..15)
            using PD7 = Field<7, 1>;    // Port F pull-down bit y (y=0..15)
            using PD6 = Field<6, 1>;    // Port F pull-down bit y (y=0..15)
            using PD5 = Field<5, 1>;    // Port F pull-down bit y (y=0..15)
            using PD4 = Field<4, 1>;    // Port F pull-down bit y (y=0..15)
            using PD3 = Field<3, 1>;    // Port F pull-down bit y (y=0..15)
            using PD2 = Field<2, 1>;    // Port F pull-down bit y (y=0..15)
            using PD1 = Field<1, 1>;    // Port F pull-down bit y (y=0..15)
            using PD0 = Field<0, 1>;    // Port F pull-down bit y (y=0..15)
        };

        // Power Port G pull-up control register
        struct PUCRG : public Register<0x40007050> {
            using PU15 = Field<15, 1>;    // Port G pull-up bit y (y=0..15)
            using PU14 = Field<14, 1>;    // Port G pull-up bit y (y=0..15)
            using PU13 = Field<13, 1>;    // Port G pull-up bit y (y=0..15)
            using PU12 = Field<12, 1>;    // Port G pull-up bit y (y=0..15)
            using PU11 = Field<11, 1>;    // Port G pull-up bit y (y=0..15)
            using PU10 = Field<10, 1>;    // Port G pull-up bit y (y=0..15)
            using PU9 = Field<9, 1>;    // Port G pull-up bit y (y=0..15)
            using PU8 = Field<8, 1>;    // Port G pull-up bit y (y=0..15)
            using PU7 = Field<7, 1>;    // Port G pull-up bit y (y=0..15)
            using PU6 = Field<6, 1>;    // Port G pull-up bit y (y=0..15)
            using PU5 = Field<5, 1>;    // Port G pull-up bit y (y=0..15)
            using PU4 = Field<4, 1>;    // Port G pull-up bit y (y=0..15)
            using PU3 = Field<3, 1>;    // Port G pull-up bit y (y=0..15)
            using PU2 = Field<2, 1>;    // Port G pull-up bit y (y=0..15)
            using PU1 = Field<1, 1>;    // Port G pull-up bit y (y=0..15)
            using PU0 = Field<0, 1>;    // Port G pull-up bit y (y=0..15)
        };

        // Power Port G pull-down control register
        struct PDCRG : public Register<0x40007054> {
            using PD15 = Field<15, 1>;    // Port G pull-down bit y (y=0..15)
            using PD14 = Field<14, 1>;    // Port G pull-down bit y (y=0..15)
            using PD13 = Field<13, 1>;    // Port G pull-down bit y (y=0..15)
            using PD12 = Field<12, 1>;    // Port G pull-down bit y (y=0..15)
            using PD11 = Field<11, 1>;    // Port G pull-down bit y (y=0..15)
            using PD10 = Field<10, 1>;    // Port G pull-down bit y (y=0..15)
            using PD9 = Field<9, 1>;    // Port G pull-down bit y (y=0..15)
            using PD8 = Field<8, 1>;    // Port G pull-down bit y (y=0..15)
            using PD7 = Field<7, 1>;    // Port G pull-down bit y (y=0..15)
            using PD6 = Field<6, 1>;    // Port G pull-down bit y (y=0..15)
            using PD5 = Field<5, 1>;    // Port G pull-down bit y (y=0..15)
            using PD4 = Field<4, 1>;    // Port G pull-down bit y (y=0..15)
            using PD3 = Field<3, 1>;    // Port G pull-down bit y (y=0..15)
            using PD2 = Field<2, 1>;    // Port G pull-down bit y (y=0..15)
            using PD1 = Field<1, 1>;    // Port G pull-down bit y (y=0..15)
            using PD0 = Field<0, 1>;    // Port G pull-down bit y (y=0..15)
        };

        // Power Port H pull-up control register
        struct PUCRH : public Register<0x40007058> {
            using PU1 = Field<1, 1>;    // Port H pull-up bit y (y=0..1)
            using PU0 = Field<0, 1>;    // Port H pull-up bit y (y=0..1)
        };

        // Power Port H pull-down control register
        struct PDCRH : public Register<0x4000705c> {
            using PD1 = Field<1, 1>;    // Port H pull-down bit y (y=0..1)
            using PD0 = Field<0, 1>;    // Port H pull-down bit y (y=0..1)
        };

    };

    // System configuration controller
    struct SYSCFG {
        // memory remap register
        struct MEMRMP : public Register<0x40010000> {
            using FB_MODE = Field<8, 1>;    // Flash Bank mode selection
            using QFS = Field<3, 1>;    // QUADSPI memory mapping swap
            using MEM_MODE = Field<0, 3>;    // Memory mapping selection
        };

        // configuration register 1
        struct CFGR1 : public Register<0x40010004> {
            using FPU_IE = Field<26, 6>;    // Floating Point Unit interrupts enable bits
            using I2C3_FMP = Field<22, 1>;    // I2C3 Fast-mode Plus driving capability activation
            using I2C2_FMP = Field<21, 1>;    // I2C2 Fast-mode Plus driving capability activation
            using I2C1_FMP = Field<20, 1>;    // I2C1 Fast-mode Plus driving capability activation
            using I2C_PB9_FMP = Field<19, 1>;    // Fast-mode Plus (Fm+) driving capability activation on PB9
            using I2C_PB8_FMP = Field<18, 1>;    // Fast-mode Plus (Fm+) driving capability activation on PB8
            using I2C_PB7_FMP = Field<17, 1>;    // Fast-mode Plus (Fm+) driving capability activation on PB7
            using I2C_PB6_FMP = Field<16, 1>;    // Fast-mode Plus (Fm+) driving capability activation on PB6
            using BOOSTEN = Field<8, 1>;    // I/O analog switch voltage booster enable
            using FWDIS = Field<0, 1>;    // Firewall disable
        };

        // external interrupt configuration register 1
        struct EXTICR1 : public Register<0x40010008> {
            using EXTI3 = Field<12, 3>;    // EXTI 3 configuration bits
            using EXTI2 = Field<8, 3>;    // EXTI 2 configuration bits
            using EXTI1 = Field<4, 3>;    // EXTI 1 configuration bits
            using EXTI0 = Field<0, 3>;    // EXTI 0 configuration bits
        };

        // external interrupt configuration register 2
        struct EXTICR2 : public Register<0x4001000c> {
            using EXTI7 = Field<12, 3>;    // EXTI 7 configuration bits
            using EXTI6 = Field<8, 3>;    // EXTI 6 configuration bits
            using EXTI5 = Field<4, 3>;    // EXTI 5 configuration bits
            using EXTI4 = Field<0, 3>;    // EXTI 4 configuration bits
        };

        // external interrupt configuration register 3
        struct EXTICR3 : public Register<0x40010010> {
            using EXTI11 = Field<12, 3>;    // EXTI 11 configuration bits
            using EXTI10 = Field<8, 3>;    // EXTI 10 configuration bits
            using EXTI9 = Field<4, 3>;    // EXTI 9 configuration bits
            using EXTI8 = Field<0, 3>;    // EXTI 8 configuration bits
        };

        // external interrupt configuration register 4
        struct EXTICR4 : public Register<0x40010014> {
            using EXTI15 = Field<12, 3>;    // EXTI15 configuration bits
            using EXTI14 = Field<8, 3>;    // EXTI14 configuration bits
            using EXTI13 = Field<4, 3>;    // EXTI13 configuration bits
            using EXTI12 = Field<0, 3>;    // EXTI12 configuration bits
        };

        // SCSR
        struct SCSR : public Register<0x40010018> {
            using SRAM2BSY = Field<1, 1>;    // SRAM2 busy by erase operation
            using SRAM2ER = Field<0, 1>;    // SRAM2 Erase
        };

        // CFGR2
        struct CFGR2 : public Register<0x4001001c> {
            using SPF = Field<8, 1>;    // SRAM2 parity error flag
            using ECCL = Field<3, 1>;    // ECC Lock
            using PVDL = Field<2, 1>;    // PVD lock enable bit
            using SPL = Field<1, 1>;    // SRAM2 parity lock bit
            using CLL = Field<0, 1>;    // Cortex-M4 LOCKUP (Hardfault) output enable bit
        };

        // SWPR
        struct SWPR : public Register<0x40010020> {
            using P31WP = Field<31, 1>;    // SRAM2 page 31 write protection
            using P30WP = Field<30, 1>;    // P30WP
            using P29WP = Field<29, 1>;    // P29WP
            using P28WP = Field<28, 1>;    // P28WP
            using P27WP = Field<27, 1>;    // P27WP
            using P26WP = Field<26, 1>;    // P26WP
            using P25WP = Field<25, 1>;    // P25WP
            using P24WP = Field<24, 1>;    // P24WP
            using P23WP = Field<23, 1>;    // P23WP
            using P22WP = Field<22, 1>;    // P22WP
            using P21WP = Field<21, 1>;    // P21WP
            using P20WP = Field<20, 1>;    // P20WP
            using P19WP = Field<19, 1>;    // P19WP
            using P18WP = Field<18, 1>;    // P18WP
            using P17WP = Field<17, 1>;    // P17WP
            using P16WP = Field<16, 1>;    // P16WP
            using P15WP = Field<15, 1>;    // P15WP
            using P14WP = Field<14, 1>;    // P14WP
            using P13WP = Field<13, 1>;    // P13WP
            using P12WP = Field<12, 1>;    // P12WP
            using P11WP = Field<11, 1>;    // P11WP
            using P10WP = Field<10, 1>;    // P10WP
            using P9WP = Field<9, 1>;    // P9WP
            using P8WP = Field<8, 1>;    // P8WP
            using P7WP = Field<7, 1>;    // P7WP
            using P6WP = Field<6, 1>;    // P6WP
            using P5WP = Field<5, 1>;    // P5WP
            using P4WP = Field<4, 1>;    // P4WP
            using P3WP = Field<3, 1>;    // P3WP
            using P2WP = Field<2, 1>;    // P2WP
            using P1WP = Field<1, 1>;    // P1WP
            using P0WP = Field<0, 1>;    // P0WP
        };

        // SKR
        struct SKR : public Register<0x40010024> {
            using KEY = Field<0, 8>;    // SRAM2 write protection key for software erase
        };

    };

    // Digital filter for sigma delta modulators
    struct DFSDM1 {
        // channel configuration y register
        struct CHCFG0R1 : public Register<0x40016000> {
            using DFSDMEN = Field<31, 1>;    // DFSDMEN
            using CKOUTSRC = Field<30, 1>;    // CKOUTSRC
            using CKOUTDIV = Field<16, 8>;    // CKOUTDIV
            using DATPACK = Field<14, 2>;    // DATPACK
            using DATMPX = Field<12, 2>;    // DATMPX
            using CHINSEL = Field<8, 1>;    // CHINSEL
            using CHEN = Field<7, 1>;    // CHEN
            using CKABEN = Field<6, 1>;    // CKABEN
            using SCDEN = Field<5, 1>;    // SCDEN
            using SPICKSEL = Field<2, 2>;    // SPICKSEL
            using SITP = Field<0, 2>;    // SITP
        };

        // channel configuration y register
        struct CHCFG0R2 : public Register<0x40016004> {
            using OFFSET = Field<8, 24>;    // OFFSET
            using DTRBS = Field<3, 5>;    // DTRBS
        };

        // analog watchdog and short-circuit detector register
        struct AWSCD0R : public Register<0x40016008> {
            using AWFORD = Field<22, 2>;    // AWFORD
            using AWFOSR = Field<16, 5>;    // AWFOSR
            using BKSCD = Field<12, 4>;    // BKSCD
            using SCDT = Field<0, 8>;    // SCDT
        };

        // channel watchdog filter data register
        struct CHWDAT0R : public Register<0x4001600c> {
            using WDATA = Field<0, 16>;    // WDATA
        };

        // channel data input register
        struct CHDATIN0R : public Register<0x40016010> {
            using INDAT1 = Field<16, 16>;    // INDAT1
            using INDAT0 = Field<0, 16>;    // INDAT0
        };

        // CHCFG1R1
        struct CHCFG1R1 : public Register<0x40016020> {
            using DATPACK = Field<14, 2>;    // DATPACK
            using DATMPX = Field<12, 2>;    // DATMPX
            using CHINSEL = Field<8, 1>;    // CHINSEL
            using CHEN = Field<7, 1>;    // CHEN
            using CKABEN = Field<6, 1>;    // CKABEN
            using SCDEN = Field<5, 1>;    // SCDEN
            using SPICKSEL = Field<2, 2>;    // SPICKSEL
            using SITP = Field<0, 2>;    // SITP
        };

        // CHCFG1R2
        struct CHCFG1R2 : public Register<0x40016024> {
            using OFFSET = Field<8, 24>;    // OFFSET
            using DTRBS = Field<3, 5>;    // DTRBS
        };

        // AWSCD1R
        struct AWSCD1R : public Register<0x40016028> {
            using AWFORD = Field<22, 2>;    // AWFORD
            using AWFOSR = Field<16, 5>;    // AWFOSR
            using BKSCD = Field<12, 4>;    // BKSCD
            using SCDT = Field<0, 8>;    // SCDT
        };

        // CHWDAT1R
        struct CHWDAT1R : public Register<0x4001602c> {
            using WDATA = Field<0, 16>;    // WDATA
        };

        // CHDATIN1R
        struct CHDATIN1R : public Register<0x40016030> {
            using INDAT1 = Field<16, 16>;    // INDAT1
            using INDAT0 = Field<0, 16>;    // INDAT0
        };

        // CHCFG2R1
        struct CHCFG2R1 : public Register<0x40016040> {
            using DATPACK = Field<14, 2>;    // DATPACK
            using DATMPX = Field<12, 2>;    // DATMPX
            using CHINSEL = Field<8, 1>;    // CHINSEL
            using CHEN = Field<7, 1>;    // CHEN
            using CKABEN = Field<6, 1>;    // CKABEN
            using SCDEN = Field<5, 1>;    // SCDEN
            using SPICKSEL = Field<2, 2>;    // SPICKSEL
            using SITP = Field<0, 2>;    // SITP
        };

        // CHCFG2R2
        struct CHCFG2R2 : public Register<0x40016044> {
            using OFFSET = Field<8, 24>;    // OFFSET
            using DTRBS = Field<3, 5>;    // DTRBS
        };

        // AWSCD2R
        struct AWSCD2R : public Register<0x40016048> {
            using AWFORD = Field<22, 2>;    // AWFORD
            using AWFOSR = Field<16, 5>;    // AWFOSR
            using BKSCD = Field<12, 4>;    // BKSCD
            using SCDT = Field<0, 8>;    // SCDT
        };

        // CHWDAT2R
        struct CHWDAT2R : public Register<0x4001604c> {
            using WDATA = Field<0, 16>;    // WDATA
        };

        // CHDATIN2R
        struct CHDATIN2R : public Register<0x40016050> {
            using INDAT1 = Field<16, 16>;    // INDAT1
            using INDAT0 = Field<0, 16>;    // INDAT0
        };

        // CHCFG3R1
        struct CHCFG3R1 : public Register<0x40016060> {
            using DATPACK = Field<14, 2>;    // DATPACK
            using DATMPX = Field<12, 2>;    // DATMPX
            using CHINSEL = Field<8, 1>;    // CHINSEL
            using CHEN = Field<7, 1>;    // CHEN
            using CKABEN = Field<6, 1>;    // CKABEN
            using SCDEN = Field<5, 1>;    // SCDEN
            using SPICKSEL = Field<2, 2>;    // SPICKSEL
            using SITP = Field<0, 2>;    // SITP
        };

        // CHCFG3R2
        struct CHCFG3R2 : public Register<0x40016064> {
            using OFFSET = Field<8, 24>;    // OFFSET
            using DTRBS = Field<3, 5>;    // DTRBS
        };

        // AWSCD3R
        struct AWSCD3R : public Register<0x40016068> {
            using AWFORD = Field<22, 2>;    // AWFORD
            using AWFOSR = Field<16, 5>;    // AWFOSR
            using BKSCD = Field<12, 4>;    // BKSCD
            using SCDT = Field<0, 8>;    // SCDT
        };

        // CHWDAT3R
        struct CHWDAT3R : public Register<0x4001606c> {
            using WDATA = Field<0, 16>;    // WDATA
        };

        // CHDATIN3R
        struct CHDATIN3R : public Register<0x40016070> {
            using INDAT1 = Field<16, 16>;    // INDAT1
            using INDAT0 = Field<0, 16>;    // INDAT0
        };

        // CHCFG4R1
        struct CHCFG4R1 : public Register<0x40016080> {
            using DATPACK = Field<14, 2>;    // DATPACK
            using DATMPX = Field<12, 2>;    // DATMPX
            using CHINSEL = Field<8, 1>;    // CHINSEL
            using CHEN = Field<7, 1>;    // CHEN
            using CKABEN = Field<6, 1>;    // CKABEN
            using SCDEN = Field<5, 1>;    // SCDEN
            using SPICKSEL = Field<2, 2>;    // SPICKSEL
            using SITP = Field<0, 2>;    // SITP
        };

        // CHCFG4R2
        struct CHCFG4R2 : public Register<0x40016084> {
            using OFFSET = Field<8, 24>;    // OFFSET
            using DTRBS = Field<3, 5>;    // DTRBS
        };

        // AWSCD4R
        struct AWSCD4R : public Register<0x40016088> {
            using AWFORD = Field<22, 2>;    // AWFORD
            using AWFOSR = Field<16, 5>;    // AWFOSR
            using BKSCD = Field<12, 4>;    // BKSCD
            using SCDT = Field<0, 8>;    // SCDT
        };

        // CHWDAT4R
        struct CHWDAT4R : public Register<0x4001608c> {
            using WDATA = Field<0, 16>;    // WDATA
        };

        // CHDATIN4R
        struct CHDATIN4R : public Register<0x40016090> {
            using INDAT1 = Field<16, 16>;    // INDAT1
            using INDAT0 = Field<0, 16>;    // INDAT0
        };

        // CHCFG5R1
        struct CHCFG5R1 : public Register<0x400160a0> {
            using DATPACK = Field<14, 2>;    // DATPACK
            using DATMPX = Field<12, 2>;    // DATMPX
            using CHINSEL = Field<8, 1>;    // CHINSEL
            using CHEN = Field<7, 1>;    // CHEN
            using CKABEN = Field<6, 1>;    // CKABEN
            using SCDEN = Field<5, 1>;    // SCDEN
            using SPICKSEL = Field<2, 2>;    // SPICKSEL
            using SITP = Field<0, 2>;    // SITP
        };

        // CHCFG5R2
        struct CHCFG5R2 : public Register<0x400160a4> {
            using OFFSET = Field<8, 24>;    // OFFSET
            using DTRBS = Field<3, 5>;    // DTRBS
        };

        // AWSCD5R
        struct AWSCD5R : public Register<0x400160a8> {
            using AWFORD = Field<22, 2>;    // AWFORD
            using AWFOSR = Field<16, 5>;    // AWFOSR
            using BKSCD = Field<12, 4>;    // BKSCD
            using SCDT = Field<0, 8>;    // SCDT
        };

        // CHWDAT5R
        struct CHWDAT5R : public Register<0x400160ac> {
            using WDATA = Field<0, 16>;    // WDATA
        };

        // CHDATIN5R
        struct CHDATIN5R : public Register<0x400160b0> {
            using INDAT1 = Field<16, 16>;    // INDAT1
            using INDAT0 = Field<0, 16>;    // INDAT0
        };

        // CHCFG6R1
        struct CHCFG6R1 : public Register<0x400160c0> {
            using DATPACK = Field<14, 2>;    // DATPACK
            using DATMPX = Field<12, 2>;    // DATMPX
            using CHINSEL = Field<8, 1>;    // CHINSEL
            using CHEN = Field<7, 1>;    // CHEN
            using CKABEN = Field<6, 1>;    // CKABEN
            using SCDEN = Field<5, 1>;    // SCDEN
            using SPICKSEL = Field<2, 2>;    // SPICKSEL
            using SITP = Field<0, 2>;    // SITP
        };

        // CHCFG6R2
        struct CHCFG6R2 : public Register<0x400160c4> {
            using OFFSET = Field<8, 24>;    // OFFSET
            using DTRBS = Field<3, 5>;    // DTRBS
        };

        // AWSCD6R
        struct AWSCD6R : public Register<0x400160c8> {
            using AWFORD = Field<22, 2>;    // AWFORD
            using AWFOSR = Field<16, 5>;    // AWFOSR
            using BKSCD = Field<12, 4>;    // BKSCD
            using SCDT = Field<0, 8>;    // SCDT
        };

        // CHWDAT6R
        struct CHWDAT6R : public Register<0x400160cc> {
            using WDATA = Field<0, 16>;    // WDATA
        };

        // CHDATIN6R
        struct CHDATIN6R : public Register<0x400160d0> {
            using INDAT1 = Field<16, 16>;    // INDAT1
            using INDAT0 = Field<0, 16>;    // INDAT0
        };

        // CHCFG7R1
        struct CHCFG7R1 : public Register<0x400160e0> {
            using DATPACK = Field<14, 2>;    // DATPACK
            using DATMPX = Field<12, 2>;    // DATMPX
            using CHINSEL = Field<8, 1>;    // CHINSEL
            using CHEN = Field<7, 1>;    // CHEN
            using CKABEN = Field<6, 1>;    // CKABEN
            using SCDEN = Field<5, 1>;    // SCDEN
            using SPICKSEL = Field<2, 2>;    // SPICKSEL
            using SITP = Field<0, 2>;    // SITP
        };

        // CHCFG7R2
        struct CHCFG7R2 : public Register<0x400160e4> {
            using OFFSET = Field<8, 24>;    // OFFSET
            using DTRBS = Field<3, 5>;    // DTRBS
        };

        // AWSCD7R
        struct AWSCD7R : public Register<0x400160e8> {
            using AWFORD = Field<22, 2>;    // AWFORD
            using AWFOSR = Field<16, 5>;    // AWFOSR
            using BKSCD = Field<12, 4>;    // BKSCD
            using SCDT = Field<0, 8>;    // SCDT
        };

        // CHWDAT7R
        struct CHWDAT7R : public Register<0x400160ec> {
            using WDATA = Field<0, 16>;    // WDATA
        };

        // CHDATIN7R
        struct CHDATIN7R : public Register<0x400160f0> {
            using INDAT1 = Field<16, 16>;    // INDAT1
            using INDAT0 = Field<0, 16>;    // INDAT0
        };

        // control register 1
        struct DFSDM0_CR1 : public Register<0x40016100> {
            using AWFSEL = Field<30, 1>;    // Analog watchdog fast mode select
            using FAST = Field<29, 1>;    // Fast conversion mode selection for regular conversions
            using RCH = Field<24, 3>;    // Regular channel selection
            using RDMAEN = Field<21, 1>;    // DMA channel enabled to read data for the regular conversion
            using RSYNC = Field<19, 1>;    // Launch regular conversion synchronously with DFSDM0
            using RCONT = Field<18, 1>;    // Continuous mode selection for regular conversions
            using RSWSTART = Field<17, 1>;    // Software start of a conversion on the regular channel
            using JEXTEN = Field<13, 2>;    // Trigger enable and trigger edge selection for injected conversions
            using JEXTSEL = Field<8, 3>;    // Trigger signal selection for launching injected conversions
            using JDMAEN = Field<5, 1>;    // DMA channel enabled to read data for the injected channel group
            using JSCAN = Field<4, 1>;    // Scanning conversion mode for injected conversions
            using JSYNC = Field<3, 1>;    // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
            using JSWSTART = Field<1, 1>;    // Start a conversion of the injected group of channels
            using DFEN = Field<0, 1>;    // DFSDM enable
        };

        // control register 2
        struct DFSDM0_CR2 : public Register<0x40016104> {
            using AWDCH = Field<16, 8>;    // Analog watchdog channel selection
            using EXCH = Field<8, 8>;    // Extremes detector channel selection
            using CKABIE = Field<6, 1>;    // Clock absence interrupt enable
            using SCDIE = Field<5, 1>;    // Short-circuit detector interrupt enable
            using AWDIE = Field<4, 1>;    // Analog watchdog interrupt enable
            using ROVRIE = Field<3, 1>;    // Regular data overrun interrupt enable
            using JOVRIE = Field<2, 1>;    // Injected data overrun interrupt enable
            using REOCIE = Field<1, 1>;    // Regular end of conversion interrupt enable
            using JEOCIE = Field<0, 1>;    // Injected end of conversion interrupt enable
        };

        // interrupt and status register
        struct DFSDM0_ISR : public Register<0x40016108> {
            using SCDF = Field<24, 8>;    // short-circuit detector flag
            using CKABF = Field<16, 8>;    // Clock absence flag
            using RCIP = Field<14, 1>;    // Regular conversion in progress status
            using JCIP = Field<13, 1>;    // Injected conversion in progress status
            using AWDF = Field<4, 1>;    // Analog watchdog
            using ROVRF = Field<3, 1>;    // Regular conversion overrun flag
            using JOVRF = Field<2, 1>;    // Injected conversion overrun flag
            using REOCF = Field<1, 1>;    // End of regular conversion flag
            using JEOCF = Field<0, 1>;    // End of injected conversion flag
        };

        // interrupt flag clear register
        struct DFSDM0_ICR : public Register<0x4001610c> {
            using CLRSCDF = Field<24, 8>;    // Clear the short-circuit detector flag
            using CLRCKABF = Field<16, 8>;    // Clear the clock absence flag
            using CLRROVRF = Field<3, 1>;    // Clear the regular conversion overrun flag
            using CLRJOVRF = Field<2, 1>;    // Clear the injected conversion overrun flag
        };

        // injected channel group selection register
        struct DFSDM0_JCHGR : public Register<0x40016110> {
            using JCHG = Field<0, 8>;    // Injected channel group selection
        };

        // filter control register
        struct DFSDM0_FCR : public Register<0x40016114> {
            using FORD = Field<29, 3>;    // Sinc filter order
            using FOSR = Field<16, 10>;    // Sinc filter oversampling ratio (decimation rate)
            using IOSR = Field<0, 8>;    // Integrator oversampling ratio (averaging length)
        };

        // data register for injected group
        struct DFSDM0_JDATAR : public Register<0x40016118> {
            using JDATA = Field<8, 24>;    // Injected group conversion data
            using JDATACH = Field<0, 3>;    // Injected channel most recently converted
        };

        // data register for the regular channel
        struct DFSDM0_RDATAR : public Register<0x4001611c> {
            using RDATA = Field<8, 24>;    // Regular channel conversion data
            using RPEND = Field<4, 1>;    // Regular channel pending data
            using RDATACH = Field<0, 3>;    // Regular channel most recently converted
        };

        // analog watchdog high threshold register
        struct DFSDM0_AWHTR : public Register<0x40016120> {
            using AWHT = Field<8, 24>;    // Analog watchdog high threshold
            using BKAWH = Field<0, 4>;    // Break signal assignment to analog watchdog high threshold event
        };

        // analog watchdog low threshold register
        struct DFSDM0_AWLTR : public Register<0x40016124> {
            using AWLT = Field<8, 24>;    // Analog watchdog low threshold
            using BKAWL = Field<0, 4>;    // Break signal assignment to analog watchdog low threshold event
        };

        // analog watchdog status register
        struct DFSDM0_AWSR : public Register<0x40016128> {
            using AWHTF = Field<8, 8>;    // Analog watchdog high threshold flag
            using AWLTF = Field<0, 8>;    // Analog watchdog low threshold flag
        };

        // analog watchdog clear flag register
        struct DFSDM0_AWCFR : public Register<0x4001612c> {
            using CLRAWHTF = Field<8, 8>;    // Clear the analog watchdog high threshold flag
            using CLRAWLTF = Field<0, 8>;    // Clear the analog watchdog low threshold flag
        };

        // Extremes detector maximum register
        struct DFSDM0_EXMAX : public Register<0x40016130> {
            using EXMAX = Field<8, 24>;    // Extremes detector maximum value
            using EXMAXCH = Field<0, 3>;    // Extremes detector maximum data channel
        };

        // Extremes detector minimum register
        struct DFSDM0_EXMIN : public Register<0x40016134> {
            using EXMIN = Field<8, 24>;    // EXMIN
            using EXMINCH = Field<0, 3>;    // Extremes detector minimum data channel
        };

        // conversion timer register
        struct DFSDM0_CNVTIMR : public Register<0x40016138> {
            using CNVCNT = Field<4, 28>;    // 28-bit timer counting conversion time t = CNVCNT[27:0] / fDFSDM_CKIN
        };

        // control register 1
        struct DFSDM1_CR1 : public Register<0x40016200> {
            using AWFSEL = Field<30, 1>;    // Analog watchdog fast mode select
            using FAST = Field<29, 1>;    // Fast conversion mode selection for regular conversions
            using RCH = Field<24, 3>;    // Regular channel selection
            using RDMAEN = Field<21, 1>;    // DMA channel enabled to read data for the regular conversion
            using RSYNC = Field<19, 1>;    // Launch regular conversion synchronously with DFSDM0
            using RCONT = Field<18, 1>;    // Continuous mode selection for regular conversions
            using RSWSTART = Field<17, 1>;    // Software start of a conversion on the regular channel
            using JEXTEN = Field<13, 2>;    // Trigger enable and trigger edge selection for injected conversions
            using JEXTSEL = Field<8, 3>;    // Trigger signal selection for launching injected conversions
            using JDMAEN = Field<5, 1>;    // DMA channel enabled to read data for the injected channel group
            using JSCAN = Field<4, 1>;    // Scanning conversion mode for injected conversions
            using JSYNC = Field<3, 1>;    // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
            using JSWSTART = Field<1, 1>;    // Start a conversion of the injected group of channels
            using DFEN = Field<0, 1>;    // DFSDM enable
        };

        // control register 2
        struct DFSDM1_CR2 : public Register<0x40016204> {
            using AWDCH = Field<16, 8>;    // Analog watchdog channel selection
            using EXCH = Field<8, 8>;    // Extremes detector channel selection
            using CKABIE = Field<6, 1>;    // Clock absence interrupt enable
            using SCDIE = Field<5, 1>;    // Short-circuit detector interrupt enable
            using AWDIE = Field<4, 1>;    // Analog watchdog interrupt enable
            using ROVRIE = Field<3, 1>;    // Regular data overrun interrupt enable
            using JOVRIE = Field<2, 1>;    // Injected data overrun interrupt enable
            using REOCIE = Field<1, 1>;    // Regular end of conversion interrupt enable
            using JEOCIE = Field<0, 1>;    // Injected end of conversion interrupt enable
        };

        // interrupt and status register
        struct DFSDM1_ISR : public Register<0x40016208> {
            using SCDF = Field<24, 8>;    // short-circuit detector flag
            using CKABF = Field<16, 8>;    // Clock absence flag
            using RCIP = Field<14, 1>;    // Regular conversion in progress status
            using JCIP = Field<13, 1>;    // Injected conversion in progress status
            using AWDF = Field<4, 1>;    // Analog watchdog
            using ROVRF = Field<3, 1>;    // Regular conversion overrun flag
            using JOVRF = Field<2, 1>;    // Injected conversion overrun flag
            using REOCF = Field<1, 1>;    // End of regular conversion flag
            using JEOCF = Field<0, 1>;    // End of injected conversion flag
        };

        // interrupt flag clear register
        struct DFSDM1_ICR : public Register<0x4001620c> {
            using CLRSCDF = Field<24, 8>;    // Clear the short-circuit detector flag
            using CLRCKABF = Field<16, 8>;    // Clear the clock absence flag
            using CLRROVRF = Field<3, 1>;    // Clear the regular conversion overrun flag
            using CLRJOVRF = Field<2, 1>;    // Clear the injected conversion overrun flag
        };

        // injected channel group selection register
        struct DFSDM1_JCHGR : public Register<0x40016210> {
            using JCHG = Field<0, 8>;    // Injected channel group selection
        };

        // filter control register
        struct DFSDM1_FCR : public Register<0x40016214> {
            using FORD = Field<29, 3>;    // Sinc filter order
            using FOSR = Field<16, 10>;    // Sinc filter oversampling ratio (decimation rate)
            using IOSR = Field<0, 8>;    // Integrator oversampling ratio (averaging length)
        };

        // data register for injected group
        struct DFSDM1_JDATAR : public Register<0x40016218> {
            using JDATA = Field<8, 24>;    // Injected group conversion data
            using JDATACH = Field<0, 3>;    // Injected channel most recently converted
        };

        // data register for the regular channel
        struct DFSDM1_RDATAR : public Register<0x4001621c> {
            using RDATA = Field<8, 24>;    // Regular channel conversion data
            using RPEND = Field<4, 1>;    // Regular channel pending data
            using RDATACH = Field<0, 3>;    // Regular channel most recently converted
        };

        // analog watchdog high threshold register
        struct DFSDM1_AWHTR : public Register<0x40016220> {
            using AWHT = Field<8, 24>;    // Analog watchdog high threshold
            using BKAWH = Field<0, 4>;    // Break signal assignment to analog watchdog high threshold event
        };

        // analog watchdog low threshold register
        struct DFSDM1_AWLTR : public Register<0x40016224> {
            using AWLT = Field<8, 24>;    // Analog watchdog low threshold
            using BKAWL = Field<0, 4>;    // Break signal assignment to analog watchdog low threshold event
        };

        // analog watchdog status register
        struct DFSDM1_AWSR : public Register<0x40016228> {
            using AWHTF = Field<8, 8>;    // Analog watchdog high threshold flag
            using AWLTF = Field<0, 8>;    // Analog watchdog low threshold flag
        };

        // analog watchdog clear flag register
        struct DFSDM1_AWCFR : public Register<0x4001622c> {
            using CLRAWHTF = Field<8, 8>;    // Clear the analog watchdog high threshold flag
            using CLRAWLTF = Field<0, 8>;    // Clear the analog watchdog low threshold flag
        };

        // Extremes detector maximum register
        struct DFSDM1_EXMAX : public Register<0x40016230> {
            using EXMAX = Field<8, 24>;    // Extremes detector maximum value
            using EXMAXCH = Field<0, 3>;    // Extremes detector maximum data channel
        };

        // Extremes detector minimum register
        struct DFSDM1_EXMIN : public Register<0x40016234> {
            using EXMIN = Field<8, 24>;    // EXMIN
            using EXMINCH = Field<0, 3>;    // Extremes detector minimum data channel
        };

        // conversion timer register
        struct DFSDM1_CNVTIMR : public Register<0x40016238> {
            using CNVCNT = Field<4, 28>;    // 28-bit timer counting conversion time t = CNVCNT[27:0] / fDFSDM_CKIN
        };

        // control register 1
        struct DFSDM2_CR1 : public Register<0x40016300> {
            using AWFSEL = Field<30, 1>;    // Analog watchdog fast mode select
            using FAST = Field<29, 1>;    // Fast conversion mode selection for regular conversions
            using RCH = Field<24, 3>;    // Regular channel selection
            using RDMAEN = Field<21, 1>;    // DMA channel enabled to read data for the regular conversion
            using RSYNC = Field<19, 1>;    // Launch regular conversion synchronously with DFSDM0
            using RCONT = Field<18, 1>;    // Continuous mode selection for regular conversions
            using RSWSTART = Field<17, 1>;    // Software start of a conversion on the regular channel
            using JEXTEN = Field<13, 2>;    // Trigger enable and trigger edge selection for injected conversions
            using JEXTSEL = Field<8, 3>;    // Trigger signal selection for launching injected conversions
            using JDMAEN = Field<5, 1>;    // DMA channel enabled to read data for the injected channel group
            using JSCAN = Field<4, 1>;    // Scanning conversion mode for injected conversions
            using JSYNC = Field<3, 1>;    // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
            using JSWSTART = Field<1, 1>;    // Start a conversion of the injected group of channels
            using DFEN = Field<0, 1>;    // DFSDM enable
        };

        // control register 2
        struct DFSDM2_CR2 : public Register<0x40016304> {
            using AWDCH = Field<16, 8>;    // Analog watchdog channel selection
            using EXCH = Field<8, 8>;    // Extremes detector channel selection
            using CKABIE = Field<6, 1>;    // Clock absence interrupt enable
            using SCDIE = Field<5, 1>;    // Short-circuit detector interrupt enable
            using AWDIE = Field<4, 1>;    // Analog watchdog interrupt enable
            using ROVRIE = Field<3, 1>;    // Regular data overrun interrupt enable
            using JOVRIE = Field<2, 1>;    // Injected data overrun interrupt enable
            using REOCIE = Field<1, 1>;    // Regular end of conversion interrupt enable
            using JEOCIE = Field<0, 1>;    // Injected end of conversion interrupt enable
        };

        // interrupt and status register
        struct DFSDM2_ISR : public Register<0x40016308> {
            using SCDF = Field<24, 8>;    // short-circuit detector flag
            using CKABF = Field<16, 8>;    // Clock absence flag
            using RCIP = Field<14, 1>;    // Regular conversion in progress status
            using JCIP = Field<13, 1>;    // Injected conversion in progress status
            using AWDF = Field<4, 1>;    // Analog watchdog
            using ROVRF = Field<3, 1>;    // Regular conversion overrun flag
            using JOVRF = Field<2, 1>;    // Injected conversion overrun flag
            using REOCF = Field<1, 1>;    // End of regular conversion flag
            using JEOCF = Field<0, 1>;    // End of injected conversion flag
        };

        // interrupt flag clear register
        struct DFSDM2_ICR : public Register<0x4001630c> {
            using CLRSCDF = Field<24, 8>;    // Clear the short-circuit detector flag
            using CLRCKABF = Field<16, 8>;    // Clear the clock absence flag
            using CLRROVRF = Field<3, 1>;    // Clear the regular conversion overrun flag
            using CLRJOVRF = Field<2, 1>;    // Clear the injected conversion overrun flag
        };

        // injected channel group selection register
        struct DFSDM2_JCHGR : public Register<0x40016310> {
            using JCHG = Field<0, 8>;    // Injected channel group selection
        };

        // filter control register
        struct DFSDM2_FCR : public Register<0x40016314> {
            using FORD = Field<29, 3>;    // Sinc filter order
            using FOSR = Field<16, 10>;    // Sinc filter oversampling ratio (decimation rate)
            using IOSR = Field<0, 8>;    // Integrator oversampling ratio (averaging length)
        };

        // data register for injected group
        struct DFSDM2_JDATAR : public Register<0x40016318> {
            using JDATA = Field<8, 24>;    // Injected group conversion data
            using JDATACH = Field<0, 3>;    // Injected channel most recently converted
        };

        // data register for the regular channel
        struct DFSDM2_RDATAR : public Register<0x4001631c> {
            using RDATA = Field<8, 24>;    // Regular channel conversion data
            using RPEND = Field<4, 1>;    // Regular channel pending data
            using RDATACH = Field<0, 3>;    // Regular channel most recently converted
        };

        // analog watchdog high threshold register
        struct DFSDM2_AWHTR : public Register<0x40016320> {
            using AWHT = Field<8, 24>;    // Analog watchdog high threshold
            using BKAWH = Field<0, 4>;    // Break signal assignment to analog watchdog high threshold event
        };

        // analog watchdog low threshold register
        struct DFSDM2_AWLTR : public Register<0x40016324> {
            using AWLT = Field<8, 24>;    // Analog watchdog low threshold
            using BKAWL = Field<0, 4>;    // Break signal assignment to analog watchdog low threshold event
        };

        // analog watchdog status register
        struct DFSDM2_AWSR : public Register<0x40016328> {
            using AWHTF = Field<8, 8>;    // Analog watchdog high threshold flag
            using AWLTF = Field<0, 8>;    // Analog watchdog low threshold flag
        };

        // analog watchdog clear flag register
        struct DFSDM2_AWCFR : public Register<0x4001632c> {
            using CLRAWHTF = Field<8, 8>;    // Clear the analog watchdog high threshold flag
            using CLRAWLTF = Field<0, 8>;    // Clear the analog watchdog low threshold flag
        };

        // Extremes detector maximum register
        struct DFSDM2_EXMAX : public Register<0x40016330> {
            using EXMAX = Field<8, 24>;    // Extremes detector maximum value
            using EXMAXCH = Field<0, 3>;    // Extremes detector maximum data channel
        };

        // Extremes detector minimum register
        struct DFSDM2_EXMIN : public Register<0x40016334> {
            using EXMIN = Field<8, 24>;    // EXMIN
            using EXMINCH = Field<0, 3>;    // Extremes detector minimum data channel
        };

        // conversion timer register
        struct DFSDM2_CNVTIMR : public Register<0x40016338> {
            using CNVCNT = Field<4, 28>;    // 28-bit timer counting conversion time t = CNVCNT[27:0] / fDFSDM_CKIN
        };

        // control register 1
        struct DFSDM3_CR1 : public Register<0x40016400> {
            using AWFSEL = Field<30, 1>;    // Analog watchdog fast mode select
            using FAST = Field<29, 1>;    // Fast conversion mode selection for regular conversions
            using RCH = Field<24, 3>;    // Regular channel selection
            using RDMAEN = Field<21, 1>;    // DMA channel enabled to read data for the regular conversion
            using RSYNC = Field<19, 1>;    // Launch regular conversion synchronously with DFSDM0
            using RCONT = Field<18, 1>;    // Continuous mode selection for regular conversions
            using RSWSTART = Field<17, 1>;    // Software start of a conversion on the regular channel
            using JEXTEN = Field<13, 2>;    // Trigger enable and trigger edge selection for injected conversions
            using JEXTSEL = Field<8, 3>;    // Trigger signal selection for launching injected conversions
            using JDMAEN = Field<5, 1>;    // DMA channel enabled to read data for the injected channel group
            using JSCAN = Field<4, 1>;    // Scanning conversion mode for injected conversions
            using JSYNC = Field<3, 1>;    // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
            using JSWSTART = Field<1, 1>;    // Start a conversion of the injected group of channels
            using DFEN = Field<0, 1>;    // DFSDM enable
        };

        // control register 2
        struct DFSDM3_CR2 : public Register<0x40016404> {
            using AWDCH = Field<16, 8>;    // Analog watchdog channel selection
            using EXCH = Field<8, 8>;    // Extremes detector channel selection
            using CKABIE = Field<6, 1>;    // Clock absence interrupt enable
            using SCDIE = Field<5, 1>;    // Short-circuit detector interrupt enable
            using AWDIE = Field<4, 1>;    // Analog watchdog interrupt enable
            using ROVRIE = Field<3, 1>;    // Regular data overrun interrupt enable
            using JOVRIE = Field<2, 1>;    // Injected data overrun interrupt enable
            using REOCIE = Field<1, 1>;    // Regular end of conversion interrupt enable
            using JEOCIE = Field<0, 1>;    // Injected end of conversion interrupt enable
        };

        // interrupt and status register
        struct DFSDM3_ISR : public Register<0x40016408> {
            using SCDF = Field<24, 8>;    // short-circuit detector flag
            using CKABF = Field<16, 8>;    // Clock absence flag
            using RCIP = Field<14, 1>;    // Regular conversion in progress status
            using JCIP = Field<13, 1>;    // Injected conversion in progress status
            using AWDF = Field<4, 1>;    // Analog watchdog
            using ROVRF = Field<3, 1>;    // Regular conversion overrun flag
            using JOVRF = Field<2, 1>;    // Injected conversion overrun flag
            using REOCF = Field<1, 1>;    // End of regular conversion flag
            using JEOCF = Field<0, 1>;    // End of injected conversion flag
        };

        // interrupt flag clear register
        struct DFSDM3_ICR : public Register<0x4001640c> {
            using CLRSCDF = Field<24, 8>;    // Clear the short-circuit detector flag
            using CLRCKABF = Field<16, 8>;    // Clear the clock absence flag
            using CLRROVRF = Field<3, 1>;    // Clear the regular conversion overrun flag
            using CLRJOVRF = Field<2, 1>;    // Clear the injected conversion overrun flag
        };

        // injected channel group selection register
        struct DFSDM3_JCHGR : public Register<0x40016410> {
            using JCHG = Field<0, 8>;    // Injected channel group selection
        };

        // filter control register
        struct DFSDM3_FCR : public Register<0x40016414> {
            using FORD = Field<29, 3>;    // Sinc filter order
            using FOSR = Field<16, 10>;    // Sinc filter oversampling ratio (decimation rate)
            using IOSR = Field<0, 8>;    // Integrator oversampling ratio (averaging length)
        };

        // data register for injected group
        struct DFSDM3_JDATAR : public Register<0x40016418> {
            using JDATA = Field<8, 24>;    // Injected group conversion data
            using JDATACH = Field<0, 3>;    // Injected channel most recently converted
        };

        // data register for the regular channel
        struct DFSDM3_RDATAR : public Register<0x4001641c> {
            using RDATA = Field<8, 24>;    // Regular channel conversion data
            using RPEND = Field<4, 1>;    // Regular channel pending data
            using RDATACH = Field<0, 3>;    // Regular channel most recently converted
        };

        // analog watchdog high threshold register
        struct DFSDM3_AWHTR : public Register<0x40016420> {
            using AWHT = Field<8, 24>;    // Analog watchdog high threshold
            using BKAWH = Field<0, 4>;    // Break signal assignment to analog watchdog high threshold event
        };

        // analog watchdog low threshold register
        struct DFSDM3_AWLTR : public Register<0x40016424> {
            using AWLT = Field<8, 24>;    // Analog watchdog low threshold
            using BKAWL = Field<0, 4>;    // Break signal assignment to analog watchdog low threshold event
        };

        // analog watchdog status register
        struct DFSDM3_AWSR : public Register<0x40016428> {
            using AWHTF = Field<8, 8>;    // Analog watchdog high threshold flag
            using AWLTF = Field<0, 8>;    // Analog watchdog low threshold flag
        };

        // analog watchdog clear flag register
        struct DFSDM3_AWCFR : public Register<0x4001642c> {
            using CLRAWHTF = Field<8, 8>;    // Clear the analog watchdog high threshold flag
            using CLRAWLTF = Field<0, 8>;    // Clear the analog watchdog low threshold flag
        };

        // Extremes detector maximum register
        struct DFSDM3_EXMAX : public Register<0x40016430> {
            using EXMAX = Field<8, 24>;    // Extremes detector maximum value
            using EXMAXCH = Field<0, 3>;    // Extremes detector maximum data channel
        };

        // Extremes detector minimum register
        struct DFSDM3_EXMIN : public Register<0x40016434> {
            using EXMIN = Field<8, 24>;    // EXMIN
            using EXMINCH = Field<0, 3>;    // Extremes detector minimum data channel
        };

        // conversion timer register
        struct DFSDM3_CNVTIMR : public Register<0x40016438> {
            using CNVCNT = Field<4, 28>;    // 28-bit timer counting conversion time t = CNVCNT[27:0] / fDFSDM_CKIN
        };

    };

    // Random number generator
    struct RNG {
        // control register
        struct CR : public Register<0x50060800> {
            using IE = Field<3, 1>;    // Interrupt enable
            using RNGEN = Field<2, 1>;    // Random number generator enable
        };

        // status register
        struct SR : public Register<0x50060804> {
            using SEIS = Field<6, 1>;    // Seed error interrupt status
            using CEIS = Field<5, 1>;    // Clock error interrupt status
            using SECS = Field<2, 1>;    // Seed error current status
            using CECS = Field<1, 1>;    // Clock error current status
            using DRDY = Field<0, 1>;    // Data ready
        };

        // data register
        struct DR : public Register<0x50060808> {
            using RNDATA = Field<0, 32>;    // Random data
        };

    };

    // Advanced encryption standard hardware accelerator
    struct AES {
        // control register
        struct CR : public Register<0x50060000> {
            using DMAOUTEN = Field<12, 1>;    // Enable DMA management of data output phase
            using DMAINEN = Field<11, 1>;    // Enable DMA management of data input phase
            using ERRIE = Field<10, 1>;    // Error interrupt enable
            using CCFIE = Field<9, 1>;    // CCF flag interrupt enable
            using ERRC = Field<8, 1>;    // Error clear
            using CCFC = Field<7, 1>;    // Computation Complete Flag Clear
            using CHMOD = Field<5, 2>;    // AES chaining mode
            using MODE = Field<3, 2>;    // AES operating mode
            using DATATYPE = Field<1, 2>;    // Data type selection (for data in and data out to/from the cryptographic block)
            using EN = Field<0, 1>;    // AES enable
        };

        // status register
        struct SR : public Register<0x50060004> {
            using WRERR = Field<2, 1>;    // Write error flag
            using RDERR = Field<1, 1>;    // Read error flag
            using CCF = Field<0, 1>;    // Computation complete flag
        };

        // data input register
        struct DINR : public Register<0x50060008> {
            using AES_DINR = Field<0, 32>;    // Data Input Register
        };

        // data output register
        struct DOUTR : public Register<0x5006000c> {
            using AES_DOUTR = Field<0, 32>;    // Data output register
        };

        // key register 0
        struct KEYR0 : public Register<0x50060010> {
            using AES_KEYR0 = Field<0, 32>;    // Data Output Register (LSB key [31:0])
        };

        // key register 1
        struct KEYR1 : public Register<0x50060014> {
            using AES_KEYR1 = Field<0, 32>;    // AES key register (key [63:32])
        };

        // key register 2
        struct KEYR2 : public Register<0x50060018> {
            using AES_KEYR2 = Field<0, 32>;    // AES key register (key [95:64])
        };

        // key register 3
        struct KEYR3 : public Register<0x5006001c> {
            using AES_KEYR3 = Field<0, 32>;    // AES key register (MSB key [127:96])
        };

        // initialization vector register 0
        struct IVR0 : public Register<0x50060020> {
            using AES_IVR0 = Field<0, 32>;    // initialization vector register (LSB IVR [31:0])
        };

        // initialization vector register 1
        struct IVR1 : public Register<0x50060024> {
            using AES_IVR1 = Field<0, 32>;    // Initialization Vector Register (IVR [63:32])
        };

        // initialization vector register 2
        struct IVR2 : public Register<0x50060028> {
            using AES_IVR2 = Field<0, 32>;    // Initialization Vector Register (IVR [95:64])
        };

        // initialization vector register 3
        struct IVR3 : public Register<0x5006002c> {
            using AES_IVR3 = Field<0, 32>;    // Initialization Vector Register (MSB IVR [127:96])
        };

    };

    // Analog-to-Digital Converter
    struct ADC {
        // interrupt and status register
        struct ISR : public Register<0x50040000> {
            using JQOVF = Field<10, 1>;    // JQOVF
            using AWD3 = Field<9, 1>;    // AWD3
            using AWD2 = Field<8, 1>;    // AWD2
            using AWD1 = Field<7, 1>;    // AWD1
            using JEOS = Field<6, 1>;    // JEOS
            using JEOC = Field<5, 1>;    // JEOC
            using OVR = Field<4, 1>;    // OVR
            using EOS = Field<3, 1>;    // EOS
            using EOC = Field<2, 1>;    // EOC
            using EOSMP = Field<1, 1>;    // EOSMP
            using ADRDY = Field<0, 1>;    // ADRDY
        };

        // interrupt enable register
        struct IER : public Register<0x50040004> {
            using JQOVFIE = Field<10, 1>;    // JQOVFIE
            using AWD3IE = Field<9, 1>;    // AWD3IE
            using AWD2IE = Field<8, 1>;    // AWD2IE
            using AWD1IE = Field<7, 1>;    // AWD1IE
            using JEOSIE = Field<6, 1>;    // JEOSIE
            using JEOCIE = Field<5, 1>;    // JEOCIE
            using OVRIE = Field<4, 1>;    // OVRIE
            using EOSIE = Field<3, 1>;    // EOSIE
            using EOCIE = Field<2, 1>;    // EOCIE
            using EOSMPIE = Field<1, 1>;    // EOSMPIE
            using ADRDYIE = Field<0, 1>;    // ADRDYIE
        };

        // control register
        struct CR : public Register<0x50040008> {
            using ADCAL = Field<31, 1>;    // ADCAL
            using ADCALDIF = Field<30, 1>;    // ADCALDIF
            using DEEPPWD = Field<29, 1>;    // DEEPPWD
            using ADVREGEN = Field<28, 1>;    // ADVREGEN
            using JADSTP = Field<5, 1>;    // JADSTP
            using ADSTP = Field<4, 1>;    // ADSTP
            using JADSTART = Field<3, 1>;    // JADSTART
            using ADSTART = Field<2, 1>;    // ADSTART
            using ADDIS = Field<1, 1>;    // ADDIS
            using ADEN = Field<0, 1>;    // ADEN
        };

        // configuration register
        struct CFGR : public Register<0x5004000c> {
            using AWDCH1CH = Field<26, 5>;    // AWDCH1CH
            using JAUTO = Field<25, 1>;    // JAUTO
            using JAWD1EN = Field<24, 1>;    // JAWD1EN
            using AWD1EN = Field<23, 1>;    // AWD1EN
            using AWD1SGL = Field<22, 1>;    // AWD1SGL
            using JQM = Field<21, 1>;    // JQM
            using JDISCEN = Field<20, 1>;    // JDISCEN
            using DISCNUM = Field<17, 3>;    // DISCNUM
            using DISCEN = Field<16, 1>;    // DISCEN
            using AUTDLY = Field<14, 1>;    // AUTDLY
            using CONT = Field<13, 1>;    // CONT
            using OVRMOD = Field<12, 1>;    // OVRMOD
            using EXTEN = Field<10, 2>;    // EXTEN
            using EXTSEL = Field<6, 4>;    // EXTSEL
            using ALIGN = Field<5, 1>;    // ALIGN
            using RES = Field<3, 2>;    // RES
            using DMACFG = Field<1, 1>;    // DMACFG
            using DMAEN = Field<0, 1>;    // DMAEN
            using JQDIS = Field<31, 1>;    // Injected Queue disable
        };

        // configuration register
        struct CFGR2 : public Register<0x50040010> {
            using ROVSM = Field<10, 1>;    // EXTEN
            using TROVS = Field<9, 1>;    // Triggered Regular Oversampling
            using OVSS = Field<5, 4>;    // ALIGN
            using OVSR = Field<2, 3>;    // RES
            using JOVSE = Field<1, 1>;    // DMACFG
            using ROVSE = Field<0, 1>;    // DMAEN
        };

        // sample time register 1
        struct SMPR1 : public Register<0x50040014> {
            using SMP9 = Field<27, 3>;    // SMP9
            using SMP8 = Field<24, 3>;    // SMP8
            using SMP7 = Field<21, 3>;    // SMP7
            using SMP6 = Field<18, 3>;    // SMP6
            using SMP5 = Field<15, 3>;    // SMP5
            using SMP4 = Field<12, 3>;    // SMP4
            using SMP3 = Field<9, 3>;    // SMP3
            using SMP2 = Field<6, 3>;    // SMP2
            using SMP1 = Field<3, 3>;    // SMP1
            using SMPPLUS = Field<31, 1>;    // Addition of one clock cycle to the sampling time
            using SMP0 = Field<0, 3>;    // SMP0
        };

        // sample time register 2
        struct SMPR2 : public Register<0x50040018> {
            using SMP18 = Field<24, 3>;    // SMP18
            using SMP17 = Field<21, 3>;    // SMP17
            using SMP16 = Field<18, 3>;    // SMP16
            using SMP15 = Field<15, 3>;    // SMP15
            using SMP14 = Field<12, 3>;    // SMP14
            using SMP13 = Field<9, 3>;    // SMP13
            using SMP12 = Field<6, 3>;    // SMP12
            using SMP11 = Field<3, 3>;    // SMP11
            using SMP10 = Field<0, 3>;    // SMP10
        };

        // watchdog threshold register 1
        struct TR1 : public Register<0x50040020> {
            using HT1 = Field<16, 12>;    // HT1
            using LT1 = Field<0, 12>;    // LT1
        };

        // watchdog threshold register
        struct TR2 : public Register<0x50040024> {
            using HT2 = Field<16, 8>;    // HT2
            using LT2 = Field<0, 8>;    // LT2
        };

        // watchdog threshold register 3
        struct TR3 : public Register<0x50040028> {
            using HT3 = Field<16, 8>;    // HT3
            using LT3 = Field<0, 8>;    // LT3
        };

        // regular sequence register 1
        struct SQR1 : public Register<0x50040030> {
            using SQ4 = Field<24, 5>;    // SQ4
            using SQ3 = Field<18, 5>;    // SQ3
            using SQ2 = Field<12, 5>;    // SQ2
            using SQ1 = Field<6, 5>;    // SQ1
            using L = Field<0, 4>;    // Regular channel sequence length
        };

        // regular sequence register 2
        struct SQR2 : public Register<0x50040034> {
            using SQ9 = Field<24, 5>;    // SQ9
            using SQ8 = Field<18, 5>;    // SQ8
            using SQ7 = Field<12, 5>;    // SQ7
            using SQ6 = Field<6, 5>;    // SQ6
            using SQ5 = Field<0, 5>;    // SQ5
        };

        // regular sequence register 3
        struct SQR3 : public Register<0x50040038> {
            using SQ14 = Field<24, 5>;    // SQ14
            using SQ13 = Field<18, 5>;    // SQ13
            using SQ12 = Field<12, 5>;    // SQ12
            using SQ11 = Field<6, 5>;    // SQ11
            using SQ10 = Field<0, 5>;    // SQ10
        };

        // regular sequence register 4
        struct SQR4 : public Register<0x5004003c> {
            using SQ16 = Field<6, 5>;    // SQ16
            using SQ15 = Field<0, 5>;    // SQ15
        };

        // regular Data Register
        struct DR : public Register<0x50040040> {
            using RDATA = Field<0, 16>;    // Regular Data converted
        };

        // injected sequence register
        struct JSQR : public Register<0x5004004c> {
            using JSQ4 = Field<26, 5>;    // JSQ4
            using JSQ3 = Field<20, 5>;    // JSQ3
            using JSQ2 = Field<14, 5>;    // JSQ2
            using JSQ1 = Field<8, 5>;    // JSQ1
            using JEXTEN = Field<6, 2>;    // JEXTEN
            using JEXTSEL = Field<2, 4>;    // JEXTSEL
            using JL = Field<0, 2>;    // JL
        };

        // offset register 1
        struct OFR1 : public Register<0x50040060> {
            using OFFSET1_EN = Field<31, 1>;    // OFFSET1_EN
            using OFFSET1_CH = Field<26, 5>;    // OFFSET1_CH
            using OFFSET1 = Field<0, 12>;    // OFFSET1
        };

        // offset register 2
        struct OFR2 : public Register<0x50040064> {
            using OFFSET2_EN = Field<31, 1>;    // OFFSET2_EN
            using OFFSET2_CH = Field<26, 5>;    // OFFSET2_CH
            using OFFSET2 = Field<0, 12>;    // OFFSET2
        };

        // offset register 3
        struct OFR3 : public Register<0x50040068> {
            using OFFSET3_EN = Field<31, 1>;    // OFFSET3_EN
            using OFFSET3_CH = Field<26, 5>;    // OFFSET3_CH
            using OFFSET3 = Field<0, 12>;    // OFFSET3
        };

        // offset register 4
        struct OFR4 : public Register<0x5004006c> {
            using OFFSET4_EN = Field<31, 1>;    // OFFSET4_EN
            using OFFSET4_CH = Field<26, 5>;    // OFFSET4_CH
            using OFFSET4 = Field<0, 12>;    // OFFSET4
        };

        // injected data register 1
        struct JDR1 : public Register<0x50040080> {
            using JDATA1 = Field<0, 16>;    // JDATA1
        };

        // injected data register 2
        struct JDR2 : public Register<0x50040084> {
            using JDATA2 = Field<0, 16>;    // JDATA2
        };

        // injected data register 3
        struct JDR3 : public Register<0x50040088> {
            using JDATA3 = Field<0, 16>;    // JDATA3
        };

        // injected data register 4
        struct JDR4 : public Register<0x5004008c> {
            using JDATA4 = Field<0, 16>;    // JDATA4
        };

        // Analog Watchdog 2 Configuration Register
        struct AWD2CR : public Register<0x500400a0> {
            using AWD2CH = Field<0, 18>;    // AWD2CH
        };

        // Analog Watchdog 3 Configuration Register
        struct AWD3CR : public Register<0x500400a4> {
            using AWD3CH = Field<0, 18>;    // AWD3CH
        };

        // Differential Mode Selection Register 2
        struct DIFSEL : public Register<0x500400b0> {
            using DIFSEL_1_15 = Field<1, 15>;    // Differential mode for channels 15 to 1
            using DIFSEL_16_18 = Field<16, 3>;    // Differential mode for channels 18 to 16
        };

        // Calibration Factors
        struct CALFACT : public Register<0x500400b4> {
            using CALFACT_D = Field<16, 7>;    // CALFACT_D
            using CALFACT_S = Field<0, 7>;    // CALFACT_S
        };

    };

    // Analog-to-Digital Converter
    struct ADC_Common {
        // ADC Common status register
        struct CSR : public Register<0x50040300> {
            using ADDRDY_MST = Field<0, 1>;    // ADDRDY_MST
            using EOSMP_MST = Field<1, 1>;    // EOSMP_MST
            using EOC_MST = Field<2, 1>;    // EOC_MST
            using EOS_MST = Field<3, 1>;    // EOS_MST
            using OVR_MST = Field<4, 1>;    // OVR_MST
            using JEOC_MST = Field<5, 1>;    // JEOC_MST
            using JEOS_MST = Field<6, 1>;    // JEOS_MST
            using AWD1_MST = Field<7, 1>;    // AWD1_MST
            using AWD2_MST = Field<8, 1>;    // AWD2_MST
            using AWD3_MST = Field<9, 1>;    // AWD3_MST
            using JQOVF_MST = Field<10, 1>;    // JQOVF_MST
            using ADRDY_SLV = Field<16, 1>;    // ADRDY_SLV
            using EOSMP_SLV = Field<17, 1>;    // EOSMP_SLV
            using EOC_SLV = Field<18, 1>;    // End of regular conversion of the slave ADC
            using EOS_SLV = Field<19, 1>;    // End of regular sequence flag of the slave ADC
            using OVR_SLV = Field<20, 1>;    // Overrun flag of the slave ADC
            using JEOC_SLV = Field<21, 1>;    // End of injected conversion flag of the slave ADC
            using JEOS_SLV = Field<22, 1>;    // End of injected sequence flag of the slave ADC
            using AWD1_SLV = Field<23, 1>;    // Analog watchdog 1 flag of the slave ADC
            using AWD2_SLV = Field<24, 1>;    // Analog watchdog 2 flag of the slave ADC
            using AWD3_SLV = Field<25, 1>;    // Analog watchdog 3 flag of the slave ADC
            using JQOVF_SLV = Field<26, 1>;    // Injected Context Queue Overflow flag of the slave ADC
        };

        // ADC common control register
        struct CCR : public Register<0x50040308> {
            using DUAL = Field<0, 5>;    // Dual ADC mode selection
            using DELAY = Field<8, 4>;    // Delay between 2 sampling phases
            using DMACFG = Field<13, 1>;    // DMA configuration (for multi-ADC mode)
            using MDMA = Field<14, 2>;    // Direct memory access mode for multi ADC mode
            using CKMODE = Field<16, 2>;    // ADC clock mode
            using VREFEN = Field<22, 1>;    // VREFINT enable
            using CH17SEL = Field<23, 1>;    // CH17 selection
            using CH18SEL = Field<24, 1>;    // CH18 selection
            using PRESC = Field<18, 4>;    // ADC prescaler
        };

        // ADC common regular data register for dual and triple modes
        struct CDR : public Register<0x5004030c> {
            using RDATA_SLV = Field<16, 16>;    // Regular data of the slave ADC
            using RDATA_MST = Field<0, 16>;    // Regular data of the master ADC
        };

    };

    // General-purpose I/Os
    struct GPIOA {
        // GPIO port mode register
        struct MODER : public Register<0x48000000> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x48000004> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x48000008> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4800000c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x48000010> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x48000014> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x48000018> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4800001c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x48000020> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x48000024> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x48000028> {
            using BR0 = Field<0, 1>;    // Port Reset bit
            using BR1 = Field<1, 1>;    // Port Reset bit
            using BR2 = Field<2, 1>;    // Port Reset bit
            using BR3 = Field<3, 1>;    // Port Reset bit
            using BR4 = Field<4, 1>;    // Port Reset bit
            using BR5 = Field<5, 1>;    // Port Reset bit
            using BR6 = Field<6, 1>;    // Port Reset bit
            using BR7 = Field<7, 1>;    // Port Reset bit
            using BR8 = Field<8, 1>;    // Port Reset bit
            using BR9 = Field<9, 1>;    // Port Reset bit
            using BR10 = Field<10, 1>;    // Port Reset bit
            using BR11 = Field<11, 1>;    // Port Reset bit
            using BR12 = Field<12, 1>;    // Port Reset bit
            using BR13 = Field<13, 1>;    // Port Reset bit
            using BR14 = Field<14, 1>;    // Port Reset bit
            using BR15 = Field<15, 1>;    // Port Reset bit
        };

        // GPIO port analog switch control register
        struct ASCR : public Register<0x4800002c> {
            using ASC0 = Field<0, 1>;    // Port analog switch control
            using ASC1 = Field<1, 1>;    // Port analog switch control
            using ASC2 = Field<2, 1>;    // Port analog switch control
            using ASC3 = Field<3, 1>;    // Port analog switch control
            using ASC4 = Field<4, 1>;    // Port analog switch control
            using ASC5 = Field<5, 1>;    // Port analog switch control
            using ASC6 = Field<6, 1>;    // Port analog switch control
            using ASC7 = Field<7, 1>;    // Port analog switch control
            using ASC8 = Field<8, 1>;    // Port analog switch control
            using ASC9 = Field<9, 1>;    // Port analog switch control
            using ASC10 = Field<10, 1>;    // Port analog switch control
            using ASC11 = Field<11, 1>;    // Port analog switch control
            using ASC12 = Field<12, 1>;    // Port analog switch control
            using ASC13 = Field<13, 1>;    // Port analog switch control
            using ASC14 = Field<14, 1>;    // Port analog switch control
            using ASC15 = Field<15, 1>;    // Port analog switch control
        };

    };

    // General-purpose I/Os
    struct GPIOB {
        // GPIO port mode register
        struct MODER : public Register<0x48000400> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x48000404> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x48000408> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4800040c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x48000410> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x48000414> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x48000418> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4800041c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x48000420> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x48000424> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x48000428> {
            using BR0 = Field<0, 1>;    // Port Reset bit
            using BR1 = Field<1, 1>;    // Port Reset bit
            using BR2 = Field<2, 1>;    // Port Reset bit
            using BR3 = Field<3, 1>;    // Port Reset bit
            using BR4 = Field<4, 1>;    // Port Reset bit
            using BR5 = Field<5, 1>;    // Port Reset bit
            using BR6 = Field<6, 1>;    // Port Reset bit
            using BR7 = Field<7, 1>;    // Port Reset bit
            using BR8 = Field<8, 1>;    // Port Reset bit
            using BR9 = Field<9, 1>;    // Port Reset bit
            using BR10 = Field<10, 1>;    // Port Reset bit
            using BR11 = Field<11, 1>;    // Port Reset bit
            using BR12 = Field<12, 1>;    // Port Reset bit
            using BR13 = Field<13, 1>;    // Port Reset bit
            using BR14 = Field<14, 1>;    // Port Reset bit
            using BR15 = Field<15, 1>;    // Port Reset bit
        };

        // GPIO port analog switch control register
        struct ASCR : public Register<0x4800042c> {
            using ASC0 = Field<0, 1>;    // Port analog switch control
            using ASC1 = Field<1, 1>;    // Port analog switch control
            using ASC2 = Field<2, 1>;    // Port analog switch control
            using ASC3 = Field<3, 1>;    // Port analog switch control
            using ASC4 = Field<4, 1>;    // Port analog switch control
            using ASC5 = Field<5, 1>;    // Port analog switch control
            using ASC6 = Field<6, 1>;    // Port analog switch control
            using ASC7 = Field<7, 1>;    // Port analog switch control
            using ASC8 = Field<8, 1>;    // Port analog switch control
            using ASC9 = Field<9, 1>;    // Port analog switch control
            using ASC10 = Field<10, 1>;    // Port analog switch control
            using ASC11 = Field<11, 1>;    // Port analog switch control
            using ASC12 = Field<12, 1>;    // Port analog switch control
            using ASC13 = Field<13, 1>;    // Port analog switch control
            using ASC14 = Field<14, 1>;    // Port analog switch control
            using ASC15 = Field<15, 1>;    // Port analog switch control
        };

    };

    // General-purpose I/Os
    struct GPIOC {
        // GPIO port mode register
        struct MODER : public Register<0x48000800> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x48000804> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x48000808> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4800080c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x48000810> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x48000814> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x48000818> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4800081c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x48000820> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x48000824> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x48000828> {
            using BR0 = Field<0, 1>;    // Port Reset bit
            using BR1 = Field<1, 1>;    // Port Reset bit
            using BR2 = Field<2, 1>;    // Port Reset bit
            using BR3 = Field<3, 1>;    // Port Reset bit
            using BR4 = Field<4, 1>;    // Port Reset bit
            using BR5 = Field<5, 1>;    // Port Reset bit
            using BR6 = Field<6, 1>;    // Port Reset bit
            using BR7 = Field<7, 1>;    // Port Reset bit
            using BR8 = Field<8, 1>;    // Port Reset bit
            using BR9 = Field<9, 1>;    // Port Reset bit
            using BR10 = Field<10, 1>;    // Port Reset bit
            using BR11 = Field<11, 1>;    // Port Reset bit
            using BR12 = Field<12, 1>;    // Port Reset bit
            using BR13 = Field<13, 1>;    // Port Reset bit
            using BR14 = Field<14, 1>;    // Port Reset bit
            using BR15 = Field<15, 1>;    // Port Reset bit
        };

        // GPIO port analog switch control register
        struct ASCR : public Register<0x4800082c> {
            using ASC0 = Field<0, 1>;    // Port analog switch control
            using ASC1 = Field<1, 1>;    // Port analog switch control
            using ASC2 = Field<2, 1>;    // Port analog switch control
            using ASC3 = Field<3, 1>;    // Port analog switch control
            using ASC4 = Field<4, 1>;    // Port analog switch control
            using ASC5 = Field<5, 1>;    // Port analog switch control
            using ASC6 = Field<6, 1>;    // Port analog switch control
            using ASC7 = Field<7, 1>;    // Port analog switch control
            using ASC8 = Field<8, 1>;    // Port analog switch control
            using ASC9 = Field<9, 1>;    // Port analog switch control
            using ASC10 = Field<10, 1>;    // Port analog switch control
            using ASC11 = Field<11, 1>;    // Port analog switch control
            using ASC12 = Field<12, 1>;    // Port analog switch control
            using ASC13 = Field<13, 1>;    // Port analog switch control
            using ASC14 = Field<14, 1>;    // Port analog switch control
            using ASC15 = Field<15, 1>;    // Port analog switch control
        };

    };

    // General-purpose I/Os
    struct GPIOD {
        // GPIO port mode register
        struct MODER : public Register<0x48000c00> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x48000c04> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x48000c08> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x48000c0c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x48000c10> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x48000c14> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x48000c18> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x48000c1c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x48000c20> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x48000c24> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x48000c28> {
            using BR0 = Field<0, 1>;    // Port Reset bit
            using BR1 = Field<1, 1>;    // Port Reset bit
            using BR2 = Field<2, 1>;    // Port Reset bit
            using BR3 = Field<3, 1>;    // Port Reset bit
            using BR4 = Field<4, 1>;    // Port Reset bit
            using BR5 = Field<5, 1>;    // Port Reset bit
            using BR6 = Field<6, 1>;    // Port Reset bit
            using BR7 = Field<7, 1>;    // Port Reset bit
            using BR8 = Field<8, 1>;    // Port Reset bit
            using BR9 = Field<9, 1>;    // Port Reset bit
            using BR10 = Field<10, 1>;    // Port Reset bit
            using BR11 = Field<11, 1>;    // Port Reset bit
            using BR12 = Field<12, 1>;    // Port Reset bit
            using BR13 = Field<13, 1>;    // Port Reset bit
            using BR14 = Field<14, 1>;    // Port Reset bit
            using BR15 = Field<15, 1>;    // Port Reset bit
        };

        // GPIO port analog switch control register
        struct ASCR : public Register<0x48000c2c> {
            using ASC0 = Field<0, 1>;    // Port analog switch control
            using ASC1 = Field<1, 1>;    // Port analog switch control
            using ASC2 = Field<2, 1>;    // Port analog switch control
            using ASC3 = Field<3, 1>;    // Port analog switch control
            using ASC4 = Field<4, 1>;    // Port analog switch control
            using ASC5 = Field<5, 1>;    // Port analog switch control
            using ASC6 = Field<6, 1>;    // Port analog switch control
            using ASC7 = Field<7, 1>;    // Port analog switch control
            using ASC8 = Field<8, 1>;    // Port analog switch control
            using ASC9 = Field<9, 1>;    // Port analog switch control
            using ASC10 = Field<10, 1>;    // Port analog switch control
            using ASC11 = Field<11, 1>;    // Port analog switch control
            using ASC12 = Field<12, 1>;    // Port analog switch control
            using ASC13 = Field<13, 1>;    // Port analog switch control
            using ASC14 = Field<14, 1>;    // Port analog switch control
            using ASC15 = Field<15, 1>;    // Port analog switch control
        };

    };

    // General-purpose I/Os
    struct GPIOE {
        // GPIO port mode register
        struct MODER : public Register<0x48001000> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x48001004> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x48001008> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4800100c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x48001010> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x48001014> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x48001018> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4800101c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x48001020> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x48001024> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x48001028> {
            using BR0 = Field<0, 1>;    // Port Reset bit
            using BR1 = Field<1, 1>;    // Port Reset bit
            using BR2 = Field<2, 1>;    // Port Reset bit
            using BR3 = Field<3, 1>;    // Port Reset bit
            using BR4 = Field<4, 1>;    // Port Reset bit
            using BR5 = Field<5, 1>;    // Port Reset bit
            using BR6 = Field<6, 1>;    // Port Reset bit
            using BR7 = Field<7, 1>;    // Port Reset bit
            using BR8 = Field<8, 1>;    // Port Reset bit
            using BR9 = Field<9, 1>;    // Port Reset bit
            using BR10 = Field<10, 1>;    // Port Reset bit
            using BR11 = Field<11, 1>;    // Port Reset bit
            using BR12 = Field<12, 1>;    // Port Reset bit
            using BR13 = Field<13, 1>;    // Port Reset bit
            using BR14 = Field<14, 1>;    // Port Reset bit
            using BR15 = Field<15, 1>;    // Port Reset bit
        };

        // GPIO port analog switch control register
        struct ASCR : public Register<0x4800102c> {
            using ASC0 = Field<0, 1>;    // Port analog switch control
            using ASC1 = Field<1, 1>;    // Port analog switch control
            using ASC2 = Field<2, 1>;    // Port analog switch control
            using ASC3 = Field<3, 1>;    // Port analog switch control
            using ASC4 = Field<4, 1>;    // Port analog switch control
            using ASC5 = Field<5, 1>;    // Port analog switch control
            using ASC6 = Field<6, 1>;    // Port analog switch control
            using ASC7 = Field<7, 1>;    // Port analog switch control
            using ASC8 = Field<8, 1>;    // Port analog switch control
            using ASC9 = Field<9, 1>;    // Port analog switch control
            using ASC10 = Field<10, 1>;    // Port analog switch control
            using ASC11 = Field<11, 1>;    // Port analog switch control
            using ASC12 = Field<12, 1>;    // Port analog switch control
            using ASC13 = Field<13, 1>;    // Port analog switch control
            using ASC14 = Field<14, 1>;    // Port analog switch control
            using ASC15 = Field<15, 1>;    // Port analog switch control
        };

    };

    // General-purpose I/Os
    struct GPIOF {
        // GPIO port mode register
        struct MODER : public Register<0x48001400> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x48001404> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x48001408> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4800140c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x48001410> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x48001414> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x48001418> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4800141c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x48001420> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x48001424> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x48001428> {
            using BR0 = Field<0, 1>;    // Port Reset bit
            using BR1 = Field<1, 1>;    // Port Reset bit
            using BR2 = Field<2, 1>;    // Port Reset bit
            using BR3 = Field<3, 1>;    // Port Reset bit
            using BR4 = Field<4, 1>;    // Port Reset bit
            using BR5 = Field<5, 1>;    // Port Reset bit
            using BR6 = Field<6, 1>;    // Port Reset bit
            using BR7 = Field<7, 1>;    // Port Reset bit
            using BR8 = Field<8, 1>;    // Port Reset bit
            using BR9 = Field<9, 1>;    // Port Reset bit
            using BR10 = Field<10, 1>;    // Port Reset bit
            using BR11 = Field<11, 1>;    // Port Reset bit
            using BR12 = Field<12, 1>;    // Port Reset bit
            using BR13 = Field<13, 1>;    // Port Reset bit
            using BR14 = Field<14, 1>;    // Port Reset bit
            using BR15 = Field<15, 1>;    // Port Reset bit
        };

        // GPIO port analog switch control register
        struct ASCR : public Register<0x4800142c> {
            using ASC0 = Field<0, 1>;    // Port analog switch control
            using ASC1 = Field<1, 1>;    // Port analog switch control
            using ASC2 = Field<2, 1>;    // Port analog switch control
            using ASC3 = Field<3, 1>;    // Port analog switch control
            using ASC4 = Field<4, 1>;    // Port analog switch control
            using ASC5 = Field<5, 1>;    // Port analog switch control
            using ASC6 = Field<6, 1>;    // Port analog switch control
            using ASC7 = Field<7, 1>;    // Port analog switch control
            using ASC8 = Field<8, 1>;    // Port analog switch control
            using ASC9 = Field<9, 1>;    // Port analog switch control
            using ASC10 = Field<10, 1>;    // Port analog switch control
            using ASC11 = Field<11, 1>;    // Port analog switch control
            using ASC12 = Field<12, 1>;    // Port analog switch control
            using ASC13 = Field<13, 1>;    // Port analog switch control
            using ASC14 = Field<14, 1>;    // Port analog switch control
            using ASC15 = Field<15, 1>;    // Port analog switch control
        };

    };

    // General-purpose I/Os
    struct GPIOG {
        // GPIO port mode register
        struct MODER : public Register<0x48001800> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x48001804> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x48001808> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4800180c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x48001810> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x48001814> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x48001818> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4800181c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x48001820> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x48001824> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x48001828> {
            using BR0 = Field<0, 1>;    // Port Reset bit
            using BR1 = Field<1, 1>;    // Port Reset bit
            using BR2 = Field<2, 1>;    // Port Reset bit
            using BR3 = Field<3, 1>;    // Port Reset bit
            using BR4 = Field<4, 1>;    // Port Reset bit
            using BR5 = Field<5, 1>;    // Port Reset bit
            using BR6 = Field<6, 1>;    // Port Reset bit
            using BR7 = Field<7, 1>;    // Port Reset bit
            using BR8 = Field<8, 1>;    // Port Reset bit
            using BR9 = Field<9, 1>;    // Port Reset bit
            using BR10 = Field<10, 1>;    // Port Reset bit
            using BR11 = Field<11, 1>;    // Port Reset bit
            using BR12 = Field<12, 1>;    // Port Reset bit
            using BR13 = Field<13, 1>;    // Port Reset bit
            using BR14 = Field<14, 1>;    // Port Reset bit
            using BR15 = Field<15, 1>;    // Port Reset bit
        };

        // GPIO port analog switch control register
        struct ASCR : public Register<0x4800182c> {
            using ASC0 = Field<0, 1>;    // Port analog switch control
            using ASC1 = Field<1, 1>;    // Port analog switch control
            using ASC2 = Field<2, 1>;    // Port analog switch control
            using ASC3 = Field<3, 1>;    // Port analog switch control
            using ASC4 = Field<4, 1>;    // Port analog switch control
            using ASC5 = Field<5, 1>;    // Port analog switch control
            using ASC6 = Field<6, 1>;    // Port analog switch control
            using ASC7 = Field<7, 1>;    // Port analog switch control
            using ASC8 = Field<8, 1>;    // Port analog switch control
            using ASC9 = Field<9, 1>;    // Port analog switch control
            using ASC10 = Field<10, 1>;    // Port analog switch control
            using ASC11 = Field<11, 1>;    // Port analog switch control
            using ASC12 = Field<12, 1>;    // Port analog switch control
            using ASC13 = Field<13, 1>;    // Port analog switch control
            using ASC14 = Field<14, 1>;    // Port analog switch control
            using ASC15 = Field<15, 1>;    // Port analog switch control
        };

    };

    // General-purpose I/Os
    struct GPIOH {
        // GPIO port mode register
        struct MODER : public Register<0x48001c00> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x48001c04> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x48001c08> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x48001c0c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x48001c10> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x48001c14> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x48001c18> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x48001c1c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x48001c20> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x48001c24> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x48001c28> {
            using BR0 = Field<0, 1>;    // Port Reset bit
            using BR1 = Field<1, 1>;    // Port Reset bit
            using BR2 = Field<2, 1>;    // Port Reset bit
            using BR3 = Field<3, 1>;    // Port Reset bit
            using BR4 = Field<4, 1>;    // Port Reset bit
            using BR5 = Field<5, 1>;    // Port Reset bit
            using BR6 = Field<6, 1>;    // Port Reset bit
            using BR7 = Field<7, 1>;    // Port Reset bit
            using BR8 = Field<8, 1>;    // Port Reset bit
            using BR9 = Field<9, 1>;    // Port Reset bit
            using BR10 = Field<10, 1>;    // Port Reset bit
            using BR11 = Field<11, 1>;    // Port Reset bit
            using BR12 = Field<12, 1>;    // Port Reset bit
            using BR13 = Field<13, 1>;    // Port Reset bit
            using BR14 = Field<14, 1>;    // Port Reset bit
            using BR15 = Field<15, 1>;    // Port Reset bit
        };

        // GPIO port analog switch control register
        struct ASCR : public Register<0x48001c2c> {
            using ASC0 = Field<0, 1>;    // Port analog switch control
            using ASC1 = Field<1, 1>;    // Port analog switch control
            using ASC2 = Field<2, 1>;    // Port analog switch control
            using ASC3 = Field<3, 1>;    // Port analog switch control
            using ASC4 = Field<4, 1>;    // Port analog switch control
            using ASC5 = Field<5, 1>;    // Port analog switch control
            using ASC6 = Field<6, 1>;    // Port analog switch control
            using ASC7 = Field<7, 1>;    // Port analog switch control
            using ASC8 = Field<8, 1>;    // Port analog switch control
            using ASC9 = Field<9, 1>;    // Port analog switch control
            using ASC10 = Field<10, 1>;    // Port analog switch control
            using ASC11 = Field<11, 1>;    // Port analog switch control
            using ASC12 = Field<12, 1>;    // Port analog switch control
            using ASC13 = Field<13, 1>;    // Port analog switch control
            using ASC14 = Field<14, 1>;    // Port analog switch control
            using ASC15 = Field<15, 1>;    // Port analog switch control
        };

    };

    // General-purpose I/Os
    struct GPIOI {
        // GPIO port mode register
        struct MODER : public Register<0x48002000> {
            using MODER15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using MODER14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using MODER13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using MODER12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using MODER11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using MODER10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using MODER9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using MODER8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using MODER7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using MODER6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using MODER5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using MODER4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using MODER3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using MODER2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using MODER1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using MODER0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output type register
        struct OTYPER : public Register<0x48002004> {
            using OT15 = Field<15, 1>;    // Port x configuration bits (y = 0..15)
            using OT14 = Field<14, 1>;    // Port x configuration bits (y = 0..15)
            using OT13 = Field<13, 1>;    // Port x configuration bits (y = 0..15)
            using OT12 = Field<12, 1>;    // Port x configuration bits (y = 0..15)
            using OT11 = Field<11, 1>;    // Port x configuration bits (y = 0..15)
            using OT10 = Field<10, 1>;    // Port x configuration bits (y = 0..15)
            using OT9 = Field<9, 1>;    // Port x configuration bits (y = 0..15)
            using OT8 = Field<8, 1>;    // Port x configuration bits (y = 0..15)
            using OT7 = Field<7, 1>;    // Port x configuration bits (y = 0..15)
            using OT6 = Field<6, 1>;    // Port x configuration bits (y = 0..15)
            using OT5 = Field<5, 1>;    // Port x configuration bits (y = 0..15)
            using OT4 = Field<4, 1>;    // Port x configuration bits (y = 0..15)
            using OT3 = Field<3, 1>;    // Port x configuration bits (y = 0..15)
            using OT2 = Field<2, 1>;    // Port x configuration bits (y = 0..15)
            using OT1 = Field<1, 1>;    // Port x configuration bits (y = 0..15)
            using OT0 = Field<0, 1>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port output speed register
        struct OSPEEDR : public Register<0x48002008> {
            using OSPEEDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using OSPEEDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port pull-up/pull-down register
        struct PUPDR : public Register<0x4800200c> {
            using PUPDR15 = Field<30, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR14 = Field<28, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR13 = Field<26, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR12 = Field<24, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR11 = Field<22, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR10 = Field<20, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR9 = Field<18, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR8 = Field<16, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR7 = Field<14, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR6 = Field<12, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR5 = Field<10, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR4 = Field<8, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR3 = Field<6, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR2 = Field<4, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR1 = Field<2, 2>;    // Port x configuration bits (y = 0..15)
            using PUPDR0 = Field<0, 2>;    // Port x configuration bits (y = 0..15)
        };

        // GPIO port input data register
        struct IDR : public Register<0x48002010> {
            using IDR15 = Field<15, 1>;    // Port input data (y = 0..15)
            using IDR14 = Field<14, 1>;    // Port input data (y = 0..15)
            using IDR13 = Field<13, 1>;    // Port input data (y = 0..15)
            using IDR12 = Field<12, 1>;    // Port input data (y = 0..15)
            using IDR11 = Field<11, 1>;    // Port input data (y = 0..15)
            using IDR10 = Field<10, 1>;    // Port input data (y = 0..15)
            using IDR9 = Field<9, 1>;    // Port input data (y = 0..15)
            using IDR8 = Field<8, 1>;    // Port input data (y = 0..15)
            using IDR7 = Field<7, 1>;    // Port input data (y = 0..15)
            using IDR6 = Field<6, 1>;    // Port input data (y = 0..15)
            using IDR5 = Field<5, 1>;    // Port input data (y = 0..15)
            using IDR4 = Field<4, 1>;    // Port input data (y = 0..15)
            using IDR3 = Field<3, 1>;    // Port input data (y = 0..15)
            using IDR2 = Field<2, 1>;    // Port input data (y = 0..15)
            using IDR1 = Field<1, 1>;    // Port input data (y = 0..15)
            using IDR0 = Field<0, 1>;    // Port input data (y = 0..15)
        };

        // GPIO port output data register
        struct ODR : public Register<0x48002014> {
            using ODR15 = Field<15, 1>;    // Port output data (y = 0..15)
            using ODR14 = Field<14, 1>;    // Port output data (y = 0..15)
            using ODR13 = Field<13, 1>;    // Port output data (y = 0..15)
            using ODR12 = Field<12, 1>;    // Port output data (y = 0..15)
            using ODR11 = Field<11, 1>;    // Port output data (y = 0..15)
            using ODR10 = Field<10, 1>;    // Port output data (y = 0..15)
            using ODR9 = Field<9, 1>;    // Port output data (y = 0..15)
            using ODR8 = Field<8, 1>;    // Port output data (y = 0..15)
            using ODR7 = Field<7, 1>;    // Port output data (y = 0..15)
            using ODR6 = Field<6, 1>;    // Port output data (y = 0..15)
            using ODR5 = Field<5, 1>;    // Port output data (y = 0..15)
            using ODR4 = Field<4, 1>;    // Port output data (y = 0..15)
            using ODR3 = Field<3, 1>;    // Port output data (y = 0..15)
            using ODR2 = Field<2, 1>;    // Port output data (y = 0..15)
            using ODR1 = Field<1, 1>;    // Port output data (y = 0..15)
            using ODR0 = Field<0, 1>;    // Port output data (y = 0..15)
        };

        // GPIO port bit set/reset register
        struct BSRR : public Register<0x48002018> {
            using BR15 = Field<31, 1>;    // Port x reset bit y (y = 0..15)
            using BR14 = Field<30, 1>;    // Port x reset bit y (y = 0..15)
            using BR13 = Field<29, 1>;    // Port x reset bit y (y = 0..15)
            using BR12 = Field<28, 1>;    // Port x reset bit y (y = 0..15)
            using BR11 = Field<27, 1>;    // Port x reset bit y (y = 0..15)
            using BR10 = Field<26, 1>;    // Port x reset bit y (y = 0..15)
            using BR9 = Field<25, 1>;    // Port x reset bit y (y = 0..15)
            using BR8 = Field<24, 1>;    // Port x reset bit y (y = 0..15)
            using BR7 = Field<23, 1>;    // Port x reset bit y (y = 0..15)
            using BR6 = Field<22, 1>;    // Port x reset bit y (y = 0..15)
            using BR5 = Field<21, 1>;    // Port x reset bit y (y = 0..15)
            using BR4 = Field<20, 1>;    // Port x reset bit y (y = 0..15)
            using BR3 = Field<19, 1>;    // Port x reset bit y (y = 0..15)
            using BR2 = Field<18, 1>;    // Port x reset bit y (y = 0..15)
            using BR1 = Field<17, 1>;    // Port x reset bit y (y = 0..15)
            using BR0 = Field<16, 1>;    // Port x set bit y (y= 0..15)
            using BS15 = Field<15, 1>;    // Port x set bit y (y= 0..15)
            using BS14 = Field<14, 1>;    // Port x set bit y (y= 0..15)
            using BS13 = Field<13, 1>;    // Port x set bit y (y= 0..15)
            using BS12 = Field<12, 1>;    // Port x set bit y (y= 0..15)
            using BS11 = Field<11, 1>;    // Port x set bit y (y= 0..15)
            using BS10 = Field<10, 1>;    // Port x set bit y (y= 0..15)
            using BS9 = Field<9, 1>;    // Port x set bit y (y= 0..15)
            using BS8 = Field<8, 1>;    // Port x set bit y (y= 0..15)
            using BS7 = Field<7, 1>;    // Port x set bit y (y= 0..15)
            using BS6 = Field<6, 1>;    // Port x set bit y (y= 0..15)
            using BS5 = Field<5, 1>;    // Port x set bit y (y= 0..15)
            using BS4 = Field<4, 1>;    // Port x set bit y (y= 0..15)
            using BS3 = Field<3, 1>;    // Port x set bit y (y= 0..15)
            using BS2 = Field<2, 1>;    // Port x set bit y (y= 0..15)
            using BS1 = Field<1, 1>;    // Port x set bit y (y= 0..15)
            using BS0 = Field<0, 1>;    // Port x set bit y (y= 0..15)
        };

        // GPIO port configuration lock register
        struct LCKR : public Register<0x4800201c> {
            using LCKK = Field<16, 1>;    // Port x lock bit y (y= 0..15)
            using LCK15 = Field<15, 1>;    // Port x lock bit y (y= 0..15)
            using LCK14 = Field<14, 1>;    // Port x lock bit y (y= 0..15)
            using LCK13 = Field<13, 1>;    // Port x lock bit y (y= 0..15)
            using LCK12 = Field<12, 1>;    // Port x lock bit y (y= 0..15)
            using LCK11 = Field<11, 1>;    // Port x lock bit y (y= 0..15)
            using LCK10 = Field<10, 1>;    // Port x lock bit y (y= 0..15)
            using LCK9 = Field<9, 1>;    // Port x lock bit y (y= 0..15)
            using LCK8 = Field<8, 1>;    // Port x lock bit y (y= 0..15)
            using LCK7 = Field<7, 1>;    // Port x lock bit y (y= 0..15)
            using LCK6 = Field<6, 1>;    // Port x lock bit y (y= 0..15)
            using LCK5 = Field<5, 1>;    // Port x lock bit y (y= 0..15)
            using LCK4 = Field<4, 1>;    // Port x lock bit y (y= 0..15)
            using LCK3 = Field<3, 1>;    // Port x lock bit y (y= 0..15)
            using LCK2 = Field<2, 1>;    // Port x lock bit y (y= 0..15)
            using LCK1 = Field<1, 1>;    // Port x lock bit y (y= 0..15)
            using LCK0 = Field<0, 1>;    // Port x lock bit y (y= 0..15)
        };

        // GPIO alternate function low register
        struct AFRL : public Register<0x48002020> {
            using AFRL7 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL6 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL5 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL4 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL3 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL2 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL1 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 0..7)
            using AFRL0 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 0..7)
        };

        // GPIO alternate function high register
        struct AFRH : public Register<0x48002024> {
            using AFRH15 = Field<28, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH14 = Field<24, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH13 = Field<20, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH12 = Field<16, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH11 = Field<12, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH10 = Field<8, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH9 = Field<4, 4>;    // Alternate function selection for port x bit y (y = 8..15)
            using AFRH8 = Field<0, 4>;    // Alternate function selection for port x bit y (y = 8..15)
        };

        // GPIO port bit reset register
        struct BRR : public Register<0x48002028> {
            using BR0 = Field<0, 1>;    // Port Reset bit
            using BR1 = Field<1, 1>;    // Port Reset bit
            using BR2 = Field<2, 1>;    // Port Reset bit
            using BR3 = Field<3, 1>;    // Port Reset bit
            using BR4 = Field<4, 1>;    // Port Reset bit
            using BR5 = Field<5, 1>;    // Port Reset bit
            using BR6 = Field<6, 1>;    // Port Reset bit
            using BR7 = Field<7, 1>;    // Port Reset bit
            using BR8 = Field<8, 1>;    // Port Reset bit
            using BR9 = Field<9, 1>;    // Port Reset bit
            using BR10 = Field<10, 1>;    // Port Reset bit
            using BR11 = Field<11, 1>;    // Port Reset bit
            using BR12 = Field<12, 1>;    // Port Reset bit
            using BR13 = Field<13, 1>;    // Port Reset bit
            using BR14 = Field<14, 1>;    // Port Reset bit
            using BR15 = Field<15, 1>;    // Port Reset bit
        };

    };

    // Serial audio interface
    struct SAI1 {
        // BConfiguration register 1
        struct BCR1 : public Register<0x40015424> {
            using MCJDIV = Field<20, 4>;    // Master clock divider
            using NODIV = Field<19, 1>;    // No divider
            using DMAEN = Field<17, 1>;    // DMA enable
            using SAIBEN = Field<16, 1>;    // Audio block B enable
            using OutDri = Field<13, 1>;    // Output drive
            using MONO = Field<12, 1>;    // Mono mode
            using SYNCEN = Field<10, 2>;    // Synchronization enable
            using CKSTR = Field<9, 1>;    // Clock strobing edge
            using LSBFIRST = Field<8, 1>;    // Least significant bit first
            using DS = Field<5, 3>;    // Data size
            using PRTCFG = Field<2, 2>;    // Protocol configuration
            using MODE = Field<0, 2>;    // Audio block mode
        };

        // BConfiguration register 2
        struct BCR2 : public Register<0x40015428> {
            using COMP = Field<14, 2>;    // Companding mode
            using CPL = Field<13, 1>;    // Complement bit
            using MUTECN = Field<7, 6>;    // Mute counter
            using MUTEVAL = Field<6, 1>;    // Mute value
            using MUTE = Field<5, 1>;    // Mute
            using TRIS = Field<4, 1>;    // Tristate management on data line
            using FFLUS = Field<3, 1>;    // FIFO flush
            using FTH = Field<0, 3>;    // FIFO threshold
        };

        // BFRCR
        struct BFRCR : public Register<0x4001542c> {
            using FSOFF = Field<18, 1>;    // Frame synchronization offset
            using FSPOL = Field<17, 1>;    // Frame synchronization polarity
            using FSDEF = Field<16, 1>;    // Frame synchronization definition
            using FSALL = Field<8, 7>;    // Frame synchronization active level length
            using FRL = Field<0, 8>;    // Frame length
        };

        // BSlot register
        struct BSLOTR : public Register<0x40015430> {
            using SLOTEN = Field<16, 16>;    // Slot enable
            using NBSLOT = Field<8, 4>;    // Number of slots in an audio frame
            using SLOTSZ = Field<6, 2>;    // Slot size
            using FBOFF = Field<0, 5>;    // First bit offset
        };

        // BInterrupt mask register2
        struct BIM : public Register<0x40015434> {
            using LFSDETIE = Field<6, 1>;    // Late frame synchronization detection interrupt enable
            using AFSDETIE = Field<5, 1>;    // Anticipated frame synchronization detection interrupt enable
            using CNRDYIE = Field<4, 1>;    // Codec not ready interrupt enable
            using FREQIE = Field<3, 1>;    // FIFO request interrupt enable
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration interrupt enable
            using MUTEDET = Field<1, 1>;    // Mute detection interrupt enable
            using OVRUDRIE = Field<0, 1>;    // Overrun/underrun interrupt enable
        };

        // BStatus register
        struct BSR : public Register<0x40015438> {
            using FLVL = Field<16, 3>;    // FIFO level threshold
            using LFSDET = Field<6, 1>;    // Late frame synchronization detection
            using AFSDET = Field<5, 1>;    // Anticipated frame synchronization detection
            using CNRDY = Field<4, 1>;    // Codec not ready
            using FREQ = Field<3, 1>;    // FIFO request
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration flag
            using MUTEDET = Field<1, 1>;    // Mute detection
            using OVRUDR = Field<0, 1>;    // Overrun / underrun
        };

        // BClear flag register
        struct BCLRFR : public Register<0x4001543c> {
            using LFSDET = Field<6, 1>;    // Clear late frame synchronization detection flag
            using CAFSDET = Field<5, 1>;    // Clear anticipated frame synchronization detection flag
            using CNRDY = Field<4, 1>;    // Clear codec not ready flag
            using WCKCFG = Field<2, 1>;    // Clear wrong clock configuration flag
            using MUTEDET = Field<1, 1>;    // Mute detection flag
            using OVRUDR = Field<0, 1>;    // Clear overrun / underrun
        };

        // BData register
        struct BDR : public Register<0x40015440> {
            using DATA = Field<0, 32>;    // Data
        };

        // AConfiguration register 1
        struct ACR1 : public Register<0x40015404> {
            using MCJDIV = Field<20, 4>;    // Master clock divider
            using NODIV = Field<19, 1>;    // No divider
            using DMAEN = Field<17, 1>;    // DMA enable
            using SAIAEN = Field<16, 1>;    // Audio block A enable
            using OutDri = Field<13, 1>;    // Output drive
            using MONO = Field<12, 1>;    // Mono mode
            using SYNCEN = Field<10, 2>;    // Synchronization enable
            using CKSTR = Field<9, 1>;    // Clock strobing edge
            using LSBFIRST = Field<8, 1>;    // Least significant bit first
            using DS = Field<5, 3>;    // Data size
            using PRTCFG = Field<2, 2>;    // Protocol configuration
            using MODE = Field<0, 2>;    // Audio block mode
        };

        // AConfiguration register 2
        struct ACR2 : public Register<0x40015408> {
            using COMP = Field<14, 2>;    // Companding mode
            using CPL = Field<13, 1>;    // Complement bit
            using MUTECN = Field<7, 6>;    // Mute counter
            using MUTEVAL = Field<6, 1>;    // Mute value
            using MUTE = Field<5, 1>;    // Mute
            using TRIS = Field<4, 1>;    // Tristate management on data line
            using FFLUS = Field<3, 1>;    // FIFO flush
            using FTH = Field<0, 3>;    // FIFO threshold
        };

        // AFRCR
        struct AFRCR : public Register<0x4001540c> {
            using FSOFF = Field<18, 1>;    // Frame synchronization offset
            using FSPOL = Field<17, 1>;    // Frame synchronization polarity
            using FSDEF = Field<16, 1>;    // Frame synchronization definition
            using FSALL = Field<8, 7>;    // Frame synchronization active level length
            using FRL = Field<0, 8>;    // Frame length
        };

        // ASlot register
        struct ASLOTR : public Register<0x40015410> {
            using SLOTEN = Field<16, 16>;    // Slot enable
            using NBSLOT = Field<8, 4>;    // Number of slots in an audio frame
            using SLOTSZ = Field<6, 2>;    // Slot size
            using FBOFF = Field<0, 5>;    // First bit offset
        };

        // AInterrupt mask register2
        struct AIM : public Register<0x40015414> {
            using LFSDET = Field<6, 1>;    // Late frame synchronization detection interrupt enable
            using AFSDETIE = Field<5, 1>;    // Anticipated frame synchronization detection interrupt enable
            using CNRDYIE = Field<4, 1>;    // Codec not ready interrupt enable
            using FREQIE = Field<3, 1>;    // FIFO request interrupt enable
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration interrupt enable
            using MUTEDET = Field<1, 1>;    // Mute detection interrupt enable
            using OVRUDRIE = Field<0, 1>;    // Overrun/underrun interrupt enable
        };

        // AStatus register
        struct ASR : public Register<0x40015418> {
            using FLVL = Field<16, 3>;    // FIFO level threshold
            using LFSDET = Field<6, 1>;    // Late frame synchronization detection
            using AFSDET = Field<5, 1>;    // Anticipated frame synchronization detection
            using CNRDY = Field<4, 1>;    // Codec not ready
            using FREQ = Field<3, 1>;    // FIFO request
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration flag. This bit is read only
            using MUTEDET = Field<1, 1>;    // Mute detection
            using OVRUDR = Field<0, 1>;    // Overrun / underrun
        };

        // AClear flag register
        struct ACLRFR : public Register<0x4001541c> {
            using LFSDET = Field<6, 1>;    // Clear late frame synchronization detection flag
            using CAFSDET = Field<5, 1>;    // Clear anticipated frame synchronization detection flag
            using CNRDY = Field<4, 1>;    // Clear codec not ready flag
            using WCKCFG = Field<2, 1>;    // Clear wrong clock configuration flag
            using MUTEDET = Field<1, 1>;    // Mute detection flag
            using OVRUDR = Field<0, 1>;    // Clear overrun / underrun
        };

        // AData register
        struct ADR : public Register<0x40015420> {
            using DATA = Field<0, 32>;    // Data
        };

    };

    // Serial audio interface
    struct SAI2 {
        // BConfiguration register 1
        struct BCR1 : public Register<0x40015824> {
            using MCJDIV = Field<20, 4>;    // Master clock divider
            using NODIV = Field<19, 1>;    // No divider
            using DMAEN = Field<17, 1>;    // DMA enable
            using SAIBEN = Field<16, 1>;    // Audio block B enable
            using OutDri = Field<13, 1>;    // Output drive
            using MONO = Field<12, 1>;    // Mono mode
            using SYNCEN = Field<10, 2>;    // Synchronization enable
            using CKSTR = Field<9, 1>;    // Clock strobing edge
            using LSBFIRST = Field<8, 1>;    // Least significant bit first
            using DS = Field<5, 3>;    // Data size
            using PRTCFG = Field<2, 2>;    // Protocol configuration
            using MODE = Field<0, 2>;    // Audio block mode
        };

        // BConfiguration register 2
        struct BCR2 : public Register<0x40015828> {
            using COMP = Field<14, 2>;    // Companding mode
            using CPL = Field<13, 1>;    // Complement bit
            using MUTECN = Field<7, 6>;    // Mute counter
            using MUTEVAL = Field<6, 1>;    // Mute value
            using MUTE = Field<5, 1>;    // Mute
            using TRIS = Field<4, 1>;    // Tristate management on data line
            using FFLUS = Field<3, 1>;    // FIFO flush
            using FTH = Field<0, 3>;    // FIFO threshold
        };

        // BFRCR
        struct BFRCR : public Register<0x4001582c> {
            using FSOFF = Field<18, 1>;    // Frame synchronization offset
            using FSPOL = Field<17, 1>;    // Frame synchronization polarity
            using FSDEF = Field<16, 1>;    // Frame synchronization definition
            using FSALL = Field<8, 7>;    // Frame synchronization active level length
            using FRL = Field<0, 8>;    // Frame length
        };

        // BSlot register
        struct BSLOTR : public Register<0x40015830> {
            using SLOTEN = Field<16, 16>;    // Slot enable
            using NBSLOT = Field<8, 4>;    // Number of slots in an audio frame
            using SLOTSZ = Field<6, 2>;    // Slot size
            using FBOFF = Field<0, 5>;    // First bit offset
        };

        // BInterrupt mask register2
        struct BIM : public Register<0x40015834> {
            using LFSDETIE = Field<6, 1>;    // Late frame synchronization detection interrupt enable
            using AFSDETIE = Field<5, 1>;    // Anticipated frame synchronization detection interrupt enable
            using CNRDYIE = Field<4, 1>;    // Codec not ready interrupt enable
            using FREQIE = Field<3, 1>;    // FIFO request interrupt enable
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration interrupt enable
            using MUTEDET = Field<1, 1>;    // Mute detection interrupt enable
            using OVRUDRIE = Field<0, 1>;    // Overrun/underrun interrupt enable
        };

        // BStatus register
        struct BSR : public Register<0x40015838> {
            using FLVL = Field<16, 3>;    // FIFO level threshold
            using LFSDET = Field<6, 1>;    // Late frame synchronization detection
            using AFSDET = Field<5, 1>;    // Anticipated frame synchronization detection
            using CNRDY = Field<4, 1>;    // Codec not ready
            using FREQ = Field<3, 1>;    // FIFO request
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration flag
            using MUTEDET = Field<1, 1>;    // Mute detection
            using OVRUDR = Field<0, 1>;    // Overrun / underrun
        };

        // BClear flag register
        struct BCLRFR : public Register<0x4001583c> {
            using LFSDET = Field<6, 1>;    // Clear late frame synchronization detection flag
            using CAFSDET = Field<5, 1>;    // Clear anticipated frame synchronization detection flag
            using CNRDY = Field<4, 1>;    // Clear codec not ready flag
            using WCKCFG = Field<2, 1>;    // Clear wrong clock configuration flag
            using MUTEDET = Field<1, 1>;    // Mute detection flag
            using OVRUDR = Field<0, 1>;    // Clear overrun / underrun
        };

        // BData register
        struct BDR : public Register<0x40015840> {
            using DATA = Field<0, 32>;    // Data
        };

        // AConfiguration register 1
        struct ACR1 : public Register<0x40015804> {
            using MCJDIV = Field<20, 4>;    // Master clock divider
            using NODIV = Field<19, 1>;    // No divider
            using DMAEN = Field<17, 1>;    // DMA enable
            using SAIAEN = Field<16, 1>;    // Audio block A enable
            using OutDri = Field<13, 1>;    // Output drive
            using MONO = Field<12, 1>;    // Mono mode
            using SYNCEN = Field<10, 2>;    // Synchronization enable
            using CKSTR = Field<9, 1>;    // Clock strobing edge
            using LSBFIRST = Field<8, 1>;    // Least significant bit first
            using DS = Field<5, 3>;    // Data size
            using PRTCFG = Field<2, 2>;    // Protocol configuration
            using MODE = Field<0, 2>;    // Audio block mode
        };

        // AConfiguration register 2
        struct ACR2 : public Register<0x40015808> {
            using COMP = Field<14, 2>;    // Companding mode
            using CPL = Field<13, 1>;    // Complement bit
            using MUTECN = Field<7, 6>;    // Mute counter
            using MUTEVAL = Field<6, 1>;    // Mute value
            using MUTE = Field<5, 1>;    // Mute
            using TRIS = Field<4, 1>;    // Tristate management on data line
            using FFLUS = Field<3, 1>;    // FIFO flush
            using FTH = Field<0, 3>;    // FIFO threshold
        };

        // AFRCR
        struct AFRCR : public Register<0x4001580c> {
            using FSOFF = Field<18, 1>;    // Frame synchronization offset
            using FSPOL = Field<17, 1>;    // Frame synchronization polarity
            using FSDEF = Field<16, 1>;    // Frame synchronization definition
            using FSALL = Field<8, 7>;    // Frame synchronization active level length
            using FRL = Field<0, 8>;    // Frame length
        };

        // ASlot register
        struct ASLOTR : public Register<0x40015810> {
            using SLOTEN = Field<16, 16>;    // Slot enable
            using NBSLOT = Field<8, 4>;    // Number of slots in an audio frame
            using SLOTSZ = Field<6, 2>;    // Slot size
            using FBOFF = Field<0, 5>;    // First bit offset
        };

        // AInterrupt mask register2
        struct AIM : public Register<0x40015814> {
            using LFSDET = Field<6, 1>;    // Late frame synchronization detection interrupt enable
            using AFSDETIE = Field<5, 1>;    // Anticipated frame synchronization detection interrupt enable
            using CNRDYIE = Field<4, 1>;    // Codec not ready interrupt enable
            using FREQIE = Field<3, 1>;    // FIFO request interrupt enable
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration interrupt enable
            using MUTEDET = Field<1, 1>;    // Mute detection interrupt enable
            using OVRUDRIE = Field<0, 1>;    // Overrun/underrun interrupt enable
        };

        // AStatus register
        struct ASR : public Register<0x40015818> {
            using FLVL = Field<16, 3>;    // FIFO level threshold
            using LFSDET = Field<6, 1>;    // Late frame synchronization detection
            using AFSDET = Field<5, 1>;    // Anticipated frame synchronization detection
            using CNRDY = Field<4, 1>;    // Codec not ready
            using FREQ = Field<3, 1>;    // FIFO request
            using WCKCFG = Field<2, 1>;    // Wrong clock configuration flag. This bit is read only
            using MUTEDET = Field<1, 1>;    // Mute detection
            using OVRUDR = Field<0, 1>;    // Overrun / underrun
        };

        // AClear flag register
        struct ACLRFR : public Register<0x4001581c> {
            using LFSDET = Field<6, 1>;    // Clear late frame synchronization detection flag
            using CAFSDET = Field<5, 1>;    // Clear anticipated frame synchronization detection flag
            using CNRDY = Field<4, 1>;    // Clear codec not ready flag
            using WCKCFG = Field<2, 1>;    // Clear wrong clock configuration flag
            using MUTEDET = Field<1, 1>;    // Mute detection flag
            using OVRUDR = Field<0, 1>;    // Clear overrun / underrun
        };

        // AData register
        struct ADR : public Register<0x40015820> {
            using DATA = Field<0, 32>;    // Data
        };

    };

    // General-purpose-timers
    struct TIM2 {
        // control register 1
        struct CR1 : public Register<0x40000000> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000004> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000008> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000000c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000010> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40000014> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40000018> {
            using OC2CE = Field<15, 1>;    // Output compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output compare 2 mode
            using OC2PE = Field<11, 1>;    // Output compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output compare 1 mode
            using OC1PE = Field<3, 1>;    // Output compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000018> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4000001c> {
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000001c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000020> {
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 output Polarity
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000024> {
            using CNT_H = Field<16, 16>;    // High counter value (TIM2 only)
            using CNT_L = Field<0, 16>;    // Low counter value
        };

        // prescaler
        struct PSC : public Register<0x40000028> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000002c> {
            using ARR_H = Field<16, 16>;    // High Auto-reload value (TIM2 only)
            using ARR_L = Field<0, 16>;    // Low Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000034> {
            using CCR1_H = Field<16, 16>;    // High Capture/Compare 1 value (TIM2 only)
            using CCR1_L = Field<0, 16>;    // Low Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40000038> {
            using CCR2_H = Field<16, 16>;    // High Capture/Compare 2 value (TIM2 only)
            using CCR2_L = Field<0, 16>;    // Low Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4000003c> {
            using CCR3_H = Field<16, 16>;    // High Capture/Compare value (TIM2 only)
            using CCR3_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40000040> {
            using CCR4_H = Field<16, 16>;    // High Capture/Compare value (TIM2 only)
            using CCR4_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40000048> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4000004c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // TIM2 option register
        struct OR : public Register<0x40000050> {
            using ETR_RMP = Field<0, 3>;    // Timer2 ETR remap
            using TI4_RMP = Field<3, 2>;    // Internal trigger
        };

    };

    // General-purpose-timers
    struct TIM3 {
        // control register 1
        struct CR1 : public Register<0x40000400> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000404> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000408> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000040c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000410> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40000414> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40000418> {
            using OC2CE = Field<15, 1>;    // Output compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output compare 2 mode
            using OC2PE = Field<11, 1>;    // Output compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output compare 1 mode
            using OC1PE = Field<3, 1>;    // Output compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000418> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4000041c> {
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000041c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000420> {
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 output Polarity
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000424> {
            using CNT_H = Field<16, 16>;    // High counter value (TIM2 only)
            using CNT_L = Field<0, 16>;    // Low counter value
        };

        // prescaler
        struct PSC : public Register<0x40000428> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000042c> {
            using ARR_H = Field<16, 16>;    // High Auto-reload value (TIM2 only)
            using ARR_L = Field<0, 16>;    // Low Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000434> {
            using CCR1_H = Field<16, 16>;    // High Capture/Compare 1 value (TIM2 only)
            using CCR1_L = Field<0, 16>;    // Low Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40000438> {
            using CCR2_H = Field<16, 16>;    // High Capture/Compare 2 value (TIM2 only)
            using CCR2_L = Field<0, 16>;    // Low Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4000043c> {
            using CCR3_H = Field<16, 16>;    // High Capture/Compare value (TIM2 only)
            using CCR3_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40000440> {
            using CCR4_H = Field<16, 16>;    // High Capture/Compare value (TIM2 only)
            using CCR4_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40000448> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4000044c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // TIM2 option register
        struct OR : public Register<0x40000450> {
            using ETR_RMP = Field<0, 3>;    // Timer2 ETR remap
            using TI4_RMP = Field<3, 2>;    // Internal trigger
        };

    };

    // General-purpose-timers
    struct TIM4 {
        // control register 1
        struct CR1 : public Register<0x40000800> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000804> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000808> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000080c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000810> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40000814> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40000818> {
            using OC2CE = Field<15, 1>;    // Output compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output compare 2 mode
            using OC2PE = Field<11, 1>;    // Output compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output compare 1 mode
            using OC1PE = Field<3, 1>;    // Output compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000818> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4000081c> {
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4000081c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000820> {
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 output Polarity
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000824> {
            using CNT_H = Field<16, 16>;    // High counter value (TIM2 only)
            using CNT_L = Field<0, 16>;    // Low counter value
        };

        // prescaler
        struct PSC : public Register<0x40000828> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000082c> {
            using ARR_H = Field<16, 16>;    // High Auto-reload value (TIM2 only)
            using ARR_L = Field<0, 16>;    // Low Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000834> {
            using CCR1_H = Field<16, 16>;    // High Capture/Compare 1 value (TIM2 only)
            using CCR1_L = Field<0, 16>;    // Low Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40000838> {
            using CCR2_H = Field<16, 16>;    // High Capture/Compare 2 value (TIM2 only)
            using CCR2_L = Field<0, 16>;    // Low Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4000083c> {
            using CCR3_H = Field<16, 16>;    // High Capture/Compare value (TIM2 only)
            using CCR3_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40000840> {
            using CCR4_H = Field<16, 16>;    // High Capture/Compare value (TIM2 only)
            using CCR4_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40000848> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4000084c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // TIM2 option register
        struct OR : public Register<0x40000850> {
            using ETR_RMP = Field<0, 3>;    // Timer2 ETR remap
            using TI4_RMP = Field<3, 2>;    // Internal trigger
        };

    };

    // General-purpose-timers
    struct TIM5 {
        // control register 1
        struct CR1 : public Register<0x40000c00> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40000c04> {
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
        };

        // slave mode control register
        struct SMCR : public Register<0x40000c08> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x40000c0c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40000c10> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40000c14> {
            using TG = Field<6, 1>;    // Trigger generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40000c18> {
            using OC2CE = Field<15, 1>;    // Output compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output compare 2 mode
            using OC2PE = Field<11, 1>;    // Output compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output compare 1 mode
            using OC1PE = Field<3, 1>;    // Output compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40000c18> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PSC = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x40000c1c> {
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x40000c1c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40000c20> {
            using CC4NP = Field<15, 1>;    // Capture/Compare 4 output Polarity
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40000c24> {
            using CNT_H = Field<16, 16>;    // High counter value (TIM2 only)
            using CNT_L = Field<0, 16>;    // Low counter value
        };

        // prescaler
        struct PSC : public Register<0x40000c28> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x40000c2c> {
            using ARR_H = Field<16, 16>;    // High Auto-reload value (TIM2 only)
            using ARR_L = Field<0, 16>;    // Low Auto-reload value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40000c34> {
            using CCR1_H = Field<16, 16>;    // High Capture/Compare 1 value (TIM2 only)
            using CCR1_L = Field<0, 16>;    // Low Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40000c38> {
            using CCR2_H = Field<16, 16>;    // High Capture/Compare 2 value (TIM2 only)
            using CCR2_L = Field<0, 16>;    // Low Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x40000c3c> {
            using CCR3_H = Field<16, 16>;    // High Capture/Compare value (TIM2 only)
            using CCR3_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40000c40> {
            using CCR4_H = Field<16, 16>;    // High Capture/Compare value (TIM2 only)
            using CCR4_L = Field<0, 16>;    // Low Capture/Compare value
        };

        // DMA control register
        struct DCR : public Register<0x40000c48> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x40000c4c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // TIM2 option register
        struct OR : public Register<0x40000c50> {
            using ETR_RMP = Field<0, 3>;    // Timer2 ETR remap
            using TI4_RMP = Field<3, 2>;    // Internal trigger
        };

    };

    // General purpose timers
    struct TIM15 {
        // control register 1
        struct CR1 : public Register<0x40014000> {
            using CEN = Field<0, 1>;    // Counter enable
            using UDIS = Field<1, 1>;    // Update disable
            using URS = Field<2, 1>;    // Update request source
            using OPM = Field<3, 1>;    // One-pulse mode
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CKD = Field<8, 2>;    // Clock division
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
        };

        // control register 2
        struct CR2 : public Register<0x40014004> {
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001400c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40014010> {
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40014014> {
            using BG = Field<7, 1>;    // Break generation
            using TG = Field<6, 1>;    // Trigger generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register (output mode)
        struct CCMR1_Output : public Register<0x40014018> {
            using OC1M_2 = Field<16, 1>;    // Output Compare 1 mode
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40014018> {
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40014020> {
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40014024> {
            using Field = Field<0, 16>;    // counter value
            using UIFCPY = Field<31, 1>;    // UIF Copy
        };

        // prescaler
        struct PSC : public Register<0x40014028> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001402c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // repetition counter register
        struct RCR : public Register<0x40014030> {
            using REP = Field<0, 8>;    // Repetition counter value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40014034> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40014044> {
            using DTG = Field<0, 8>;    // Dead-time generator setup
            using LOCK = Field<8, 2>;    // Lock configuration
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using BKE = Field<12, 1>;    // Break enable
            using BKP = Field<13, 1>;    // Break polarity
            using AOE = Field<14, 1>;    // Automatic output enable
            using MOE = Field<15, 1>;    // Main output enable
            using BKF = Field<16, 4>;    // Break filter
        };

        // DMA control register
        struct DCR : public Register<0x40014048> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4001404c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

    };

    // General purpose timers
    struct TIM16 {
        // control register 1
        struct CR1 : public Register<0x40014400> {
            using CEN = Field<0, 1>;    // Counter enable
            using UDIS = Field<1, 1>;    // Update disable
            using URS = Field<2, 1>;    // Update request source
            using OPM = Field<3, 1>;    // One-pulse mode
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CKD = Field<8, 2>;    // Clock division
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
        };

        // control register 2
        struct CR2 : public Register<0x40014404> {
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001440c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40014410> {
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40014414> {
            using BG = Field<7, 1>;    // Break generation
            using TG = Field<6, 1>;    // Trigger generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register (output mode)
        struct CCMR1_Output : public Register<0x40014418> {
            using OC1M_2 = Field<16, 1>;    // Output Compare 1 mode
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40014418> {
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40014420> {
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40014424> {
            using Field = Field<0, 16>;    // counter value
            using UIFCPY = Field<31, 1>;    // UIF Copy
        };

        // prescaler
        struct PSC : public Register<0x40014428> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001442c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // repetition counter register
        struct RCR : public Register<0x40014430> {
            using REP = Field<0, 8>;    // Repetition counter value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40014434> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40014444> {
            using DTG = Field<0, 8>;    // Dead-time generator setup
            using LOCK = Field<8, 2>;    // Lock configuration
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using BKE = Field<12, 1>;    // Break enable
            using BKP = Field<13, 1>;    // Break polarity
            using AOE = Field<14, 1>;    // Automatic output enable
            using MOE = Field<15, 1>;    // Main output enable
            using BKF = Field<16, 4>;    // Break filter
        };

        // DMA control register
        struct DCR : public Register<0x40014448> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4001444c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // TIM16 option register 1
        struct OR1 : public Register<0x40014450> {
            using TI1_RMP = Field<0, 2>;    // Input capture 1 remap
        };

        // TIM17 option register 1
        struct OR2 : public Register<0x40014460> {
            using BKINE = Field<0, 1>;    // BRK BKIN input enable
            using BKCMP1E = Field<1, 1>;    // BRK COMP1 enable
            using BKCMP2E = Field<2, 1>;    // BRK COMP2 enable
            using BKDFBK1E = Field<8, 1>;    // BRK DFSDM_BREAK1 enable
            using BKINP = Field<9, 1>;    // BRK BKIN input polarity
            using BKCMP1P = Field<10, 1>;    // BRK COMP1 input polarity
            using BKCMP2P = Field<11, 1>;    // BRK COMP2 input polarit
        };

    };

    // General purpose timers
    struct TIM17 {
        // control register 1
        struct CR1 : public Register<0x40014800> {
            using CEN = Field<0, 1>;    // Counter enable
            using UDIS = Field<1, 1>;    // Update disable
            using URS = Field<2, 1>;    // Update request source
            using OPM = Field<3, 1>;    // One-pulse mode
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CKD = Field<8, 2>;    // Clock division
            using UIFREMAP = Field<11, 1>;    // UIF status bit remapping
        };

        // control register 2
        struct CR2 : public Register<0x40014804> {
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001480c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40014810> {
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40014814> {
            using BG = Field<7, 1>;    // Break generation
            using TG = Field<6, 1>;    // Trigger generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register (output mode)
        struct CCMR1_Output : public Register<0x40014818> {
            using OC1M_2 = Field<16, 1>;    // Output Compare 1 mode
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40014818> {
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using IC1PSC = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40014820> {
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40014824> {
            using Field = Field<0, 16>;    // counter value
            using UIFCPY = Field<31, 1>;    // UIF Copy
        };

        // prescaler
        struct PSC : public Register<0x40014828> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001482c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // repetition counter register
        struct RCR : public Register<0x40014830> {
            using REP = Field<0, 8>;    // Repetition counter value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40014834> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40014844> {
            using DTG = Field<0, 8>;    // Dead-time generator setup
            using LOCK = Field<8, 2>;    // Lock configuration
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using BKE = Field<12, 1>;    // Break enable
            using BKP = Field<13, 1>;    // Break polarity
            using AOE = Field<14, 1>;    // Automatic output enable
            using MOE = Field<15, 1>;    // Main output enable
            using BKF = Field<16, 4>;    // Break filter
        };

        // DMA control register
        struct DCR : public Register<0x40014848> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4001484c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // TIM16 option register 1
        struct OR1 : public Register<0x40014850> {
            using TI1_RMP = Field<0, 2>;    // Input capture 1 remap
        };

        // TIM17 option register 1
        struct OR2 : public Register<0x40014860> {
            using BKINE = Field<0, 1>;    // BRK BKIN input enable
            using BKCMP1E = Field<1, 1>;    // BRK COMP1 enable
            using BKCMP2E = Field<2, 1>;    // BRK COMP2 enable
            using BKDFBK1E = Field<8, 1>;    // BRK DFSDM_BREAK1 enable
            using BKINP = Field<9, 1>;    // BRK BKIN input polarity
            using BKCMP1P = Field<10, 1>;    // BRK COMP1 input polarity
            using BKCMP2P = Field<11, 1>;    // BRK COMP2 input polarit
        };

    };

    // Advanced-timers
    struct TIM1 {
        // control register 1
        struct CR1 : public Register<0x40012c00> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40012c04> {
            using OIS4 = Field<14, 1>;    // Output Idle state 4
            using OIS3N = Field<13, 1>;    // Output Idle state 3
            using OIS3 = Field<12, 1>;    // Output Idle state 3
            using OIS2N = Field<11, 1>;    // Output Idle state 2
            using OIS2 = Field<10, 1>;    // Output Idle state 2
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
        };

        // slave mode control register
        struct SMCR : public Register<0x40012c08> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x40012c0c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
        };

        // status register
        struct SR : public Register<0x40012c10> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40012c14> {
            using BG = Field<7, 1>;    // Break generation
            using TG = Field<6, 1>;    // Trigger generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40012c18> {
            using OC2CE = Field<15, 1>;    // Output Compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output Compare 2 mode
            using OC2PE = Field<11, 1>;    // Output Compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output Compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output Compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40012c18> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x40012c1c> {
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x40012c1c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40012c20> {
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3NE = Field<10, 1>;    // Capture/Compare 3 complementary output enable
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2NE = Field<6, 1>;    // Capture/Compare 2 complementary output enable
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40012c24> {
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40012c28> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x40012c2c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // repetition counter register
        struct RCR : public Register<0x40012c30> {
            using REP = Field<0, 8>;    // Repetition counter value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40012c34> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40012c38> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x40012c3c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40012c40> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40012c44> {
            using MOE = Field<15, 1>;    // Main output enable
            using AOE = Field<14, 1>;    // Automatic output enable
            using BKP = Field<13, 1>;    // Break polarity
            using BKE = Field<12, 1>;    // Break enable
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using LOCK = Field<8, 2>;    // Lock configuration
            using DTG = Field<0, 8>;    // Dead-time generator setup
        };

        // DMA control register
        struct DCR : public Register<0x40012c48> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x40012c4c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // DMA address for full transfer
        struct OR1 : public Register<0x40012c50> {
            using ETR_ADC1_RMP = Field<0, 2>;    // External trigger remap on ADC1 analog watchdog
            using ETR_ADC3_RMP = Field<2, 2>;    // External trigger remap on ADC3 analog watchdog
            using TI1_RMP = Field<4, 1>;    // Input Capture 1 remap
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR3_Output : public Register<0x40012c54> {
            using OC6M_bit3 = Field<24, 1>;    // Output Compare 6 mode bit 3
            using OC5M_bit3 = Field<16, 3>;    // Output Compare 5 mode bit 3
            using OC6CE = Field<15, 1>;    // Output compare 6 clear enable
            using OC6M = Field<12, 3>;    // Output compare 6 mode
            using OC6PE = Field<11, 1>;    // Output compare 6 preload enable
            using OC6FE = Field<10, 1>;    // Output compare 6 fast enable
            using OC5CE = Field<7, 1>;    // Output compare 5 clear enable
            using OC5M = Field<4, 3>;    // Output compare 5 mode
            using OC5PE = Field<3, 1>;    // Output compare 5 preload enable
            using OC5FE = Field<2, 1>;    // Output compare 5 fast enable
        };

        // capture/compare register 4
        struct CCR5 : public Register<0x40012c58> {
            using Field = Field<0, 16>;    // Capture/Compare value
            using GC5C1 = Field<29, 1>;    // Group Channel 5 and Channel 1
            using GC5C2 = Field<30, 1>;    // Group Channel 5 and Channel 2
            using GC5C3 = Field<31, 1>;    // Group Channel 5 and Channel 3
        };

        // capture/compare register 4
        struct CCR6 : public Register<0x40012c5c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // DMA address for full transfer
        struct OR2 : public Register<0x40012c60> {
            using BKINE = Field<0, 1>;    // BRK BKIN input enable
            using BKCMP1E = Field<1, 1>;    // BRK COMP1 enable
            using BKCMP2E = Field<2, 1>;    // BRK COMP2 enable
            using BKDFBK0E = Field<8, 1>;    // BRK DFSDM_BREAK0 enable
            using BKINP = Field<9, 1>;    // BRK BKIN input polarity
            using BKCMP1P = Field<10, 1>;    // BRK COMP1 input polarity
            using BKCMP2P = Field<11, 1>;    // BRK COMP2 input polarity
            using ETRSEL = Field<14, 3>;    // ETR source selection
        };

        // DMA address for full transfer
        struct OR3 : public Register<0x40012c64> {
            using BK2INE = Field<0, 1>;    // BRK2 BKIN input enable
            using BK2CMP1E = Field<1, 1>;    // BRK2 COMP1 enable
            using BK2CMP2E = Field<2, 1>;    // BRK2 COMP2 enable
            using BK2DFBK0E = Field<8, 1>;    // BRK2 DFSDM_BREAK0 enable
            using BK2INP = Field<9, 1>;    // BRK2 BKIN input polarity
            using BK2CMP1P = Field<10, 1>;    // BRK2 COMP1 input polarity
            using BK2CMP2P = Field<11, 1>;    // BRK2 COMP2 input polarity
        };

    };

    // Advanced-timers
    struct TIM8 {
        // control register 1
        struct CR1 : public Register<0x40013400> {
            using CKD = Field<8, 2>;    // Clock division
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using CMS = Field<5, 2>;    // Center-aligned mode selection
            using DIR = Field<4, 1>;    // Direction
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40013404> {
            using OIS4 = Field<14, 1>;    // Output Idle state 4
            using OIS3N = Field<13, 1>;    // Output Idle state 3
            using OIS3 = Field<12, 1>;    // Output Idle state 3
            using OIS2N = Field<11, 1>;    // Output Idle state 2
            using OIS2 = Field<10, 1>;    // Output Idle state 2
            using OIS1N = Field<9, 1>;    // Output Idle state 1
            using OIS1 = Field<8, 1>;    // Output Idle state 1
            using TI1S = Field<7, 1>;    // TI1 selection
            using MMS = Field<4, 3>;    // Master mode selection
            using CCDS = Field<3, 1>;    // Capture/compare DMA selection
            using CCUS = Field<2, 1>;    // Capture/compare control update selection
            using CCPC = Field<0, 1>;    // Capture/compare preloaded control
        };

        // slave mode control register
        struct SMCR : public Register<0x40013408> {
            using ETP = Field<15, 1>;    // External trigger polarity
            using ECE = Field<14, 1>;    // External clock enable
            using ETPS = Field<12, 2>;    // External trigger prescaler
            using ETF = Field<8, 4>;    // External trigger filter
            using MSM = Field<7, 1>;    // Master/Slave mode
            using TS = Field<4, 3>;    // Trigger selection
            using SMS = Field<0, 3>;    // Slave mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4001340c> {
            using TDE = Field<14, 1>;    // Trigger DMA request enable
            using COMDE = Field<13, 1>;    // COM DMA request enable
            using CC4DE = Field<12, 1>;    // Capture/Compare 4 DMA request enable
            using CC3DE = Field<11, 1>;    // Capture/Compare 3 DMA request enable
            using CC2DE = Field<10, 1>;    // Capture/Compare 2 DMA request enable
            using CC1DE = Field<9, 1>;    // Capture/Compare 1 DMA request enable
            using UDE = Field<8, 1>;    // Update DMA request enable
            using TIE = Field<6, 1>;    // Trigger interrupt enable
            using CC4IE = Field<4, 1>;    // Capture/Compare 4 interrupt enable
            using CC3IE = Field<3, 1>;    // Capture/Compare 3 interrupt enable
            using CC2IE = Field<2, 1>;    // Capture/Compare 2 interrupt enable
            using CC1IE = Field<1, 1>;    // Capture/Compare 1 interrupt enable
            using UIE = Field<0, 1>;    // Update interrupt enable
            using BIE = Field<7, 1>;    // Break interrupt enable
            using COMIE = Field<5, 1>;    // COM interrupt enable
        };

        // status register
        struct SR : public Register<0x40013410> {
            using CC4OF = Field<12, 1>;    // Capture/Compare 4 overcapture flag
            using CC3OF = Field<11, 1>;    // Capture/Compare 3 overcapture flag
            using CC2OF = Field<10, 1>;    // Capture/compare 2 overcapture flag
            using CC1OF = Field<9, 1>;    // Capture/Compare 1 overcapture flag
            using BIF = Field<7, 1>;    // Break interrupt flag
            using TIF = Field<6, 1>;    // Trigger interrupt flag
            using COMIF = Field<5, 1>;    // COM interrupt flag
            using CC4IF = Field<4, 1>;    // Capture/Compare 4 interrupt flag
            using CC3IF = Field<3, 1>;    // Capture/Compare 3 interrupt flag
            using CC2IF = Field<2, 1>;    // Capture/Compare 2 interrupt flag
            using CC1IF = Field<1, 1>;    // Capture/compare 1 interrupt flag
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40013414> {
            using BG = Field<7, 1>;    // Break generation
            using TG = Field<6, 1>;    // Trigger generation
            using COMG = Field<5, 1>;    // Capture/Compare control update generation
            using CC4G = Field<4, 1>;    // Capture/compare 4 generation
            using CC3G = Field<3, 1>;    // Capture/compare 3 generation
            using CC2G = Field<2, 1>;    // Capture/compare 2 generation
            using CC1G = Field<1, 1>;    // Capture/compare 1 generation
            using UG = Field<0, 1>;    // Update generation
        };

        // capture/compare mode register 1 (output mode)
        struct CCMR1_Output : public Register<0x40013418> {
            using OC2CE = Field<15, 1>;    // Output Compare 2 clear enable
            using OC2M = Field<12, 3>;    // Output Compare 2 mode
            using OC2PE = Field<11, 1>;    // Output Compare 2 preload enable
            using OC2FE = Field<10, 1>;    // Output Compare 2 fast enable
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using OC1CE = Field<7, 1>;    // Output Compare 1 clear enable
            using OC1M = Field<4, 3>;    // Output Compare 1 mode
            using OC1PE = Field<3, 1>;    // Output Compare 1 preload enable
            using OC1FE = Field<2, 1>;    // Output Compare 1 fast enable
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 1 (input mode)
        struct CCMR1_Input : public Register<0x40013418> {
            using IC2F = Field<12, 4>;    // Input capture 2 filter
            using IC2PCS = Field<10, 2>;    // Input capture 2 prescaler
            using CC2S = Field<8, 2>;    // Capture/Compare 2 selection
            using IC1F = Field<4, 4>;    // Input capture 1 filter
            using ICPCS = Field<2, 2>;    // Input capture 1 prescaler
            using CC1S = Field<0, 2>;    // Capture/Compare 1 selection
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR2_Output : public Register<0x4001341c> {
            using OC4CE = Field<15, 1>;    // Output compare 4 clear enable
            using OC4M = Field<12, 3>;    // Output compare 4 mode
            using OC4PE = Field<11, 1>;    // Output compare 4 preload enable
            using OC4FE = Field<10, 1>;    // Output compare 4 fast enable
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using OC3CE = Field<7, 1>;    // Output compare 3 clear enable
            using OC3M = Field<4, 3>;    // Output compare 3 mode
            using OC3PE = Field<3, 1>;    // Output compare 3 preload enable
            using OC3FE = Field<2, 1>;    // Output compare 3 fast enable
            using CC3S = Field<0, 2>;    // Capture/Compare 3 selection
        };

        // capture/compare mode register 2 (input mode)
        struct CCMR2_Input : public Register<0x4001341c> {
            using IC4F = Field<12, 4>;    // Input capture 4 filter
            using IC4PSC = Field<10, 2>;    // Input capture 4 prescaler
            using CC4S = Field<8, 2>;    // Capture/Compare 4 selection
            using IC3F = Field<4, 4>;    // Input capture 3 filter
            using IC3PSC = Field<2, 2>;    // Input capture 3 prescaler
            using CC3S = Field<0, 2>;    // Capture/compare 3 selection
        };

        // capture/compare enable register
        struct CCER : public Register<0x40013420> {
            using CC4P = Field<13, 1>;    // Capture/Compare 3 output Polarity
            using CC4E = Field<12, 1>;    // Capture/Compare 4 output enable
            using CC3NP = Field<11, 1>;    // Capture/Compare 3 output Polarity
            using CC3NE = Field<10, 1>;    // Capture/Compare 3 complementary output enable
            using CC3P = Field<9, 1>;    // Capture/Compare 3 output Polarity
            using CC3E = Field<8, 1>;    // Capture/Compare 3 output enable
            using CC2NP = Field<7, 1>;    // Capture/Compare 2 output Polarity
            using CC2NE = Field<6, 1>;    // Capture/Compare 2 complementary output enable
            using CC2P = Field<5, 1>;    // Capture/Compare 2 output Polarity
            using CC2E = Field<4, 1>;    // Capture/Compare 2 output enable
            using CC1NP = Field<3, 1>;    // Capture/Compare 1 output Polarity
            using CC1NE = Field<2, 1>;    // Capture/Compare 1 complementary output enable
            using CC1P = Field<1, 1>;    // Capture/Compare 1 output Polarity
            using CC1E = Field<0, 1>;    // Capture/Compare 1 output enable
        };

        // counter
        struct CNT : public Register<0x40013424> {
            using Field = Field<0, 16>;    // counter value
        };

        // prescaler
        struct PSC : public Register<0x40013428> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4001342c> {
            using Field = Field<0, 16>;    // Auto-reload value
        };

        // repetition counter register
        struct RCR : public Register<0x40013430> {
            using REP = Field<0, 8>;    // Repetition counter value
        };

        // capture/compare register 1
        struct CCR1 : public Register<0x40013434> {
            using Field = Field<0, 16>;    // Capture/Compare 1 value
        };

        // capture/compare register 2
        struct CCR2 : public Register<0x40013438> {
            using Field = Field<0, 16>;    // Capture/Compare 2 value
        };

        // capture/compare register 3
        struct CCR3 : public Register<0x4001343c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // capture/compare register 4
        struct CCR4 : public Register<0x40013440> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // break and dead-time register
        struct BDTR : public Register<0x40013444> {
            using MOE = Field<15, 1>;    // Main output enable
            using AOE = Field<14, 1>;    // Automatic output enable
            using BKP = Field<13, 1>;    // Break polarity
            using BKE = Field<12, 1>;    // Break enable
            using OSSR = Field<11, 1>;    // Off-state selection for Run mode
            using OSSI = Field<10, 1>;    // Off-state selection for Idle mode
            using LOCK = Field<8, 2>;    // Lock configuration
            using DTG = Field<0, 8>;    // Dead-time generator setup
        };

        // DMA control register
        struct DCR : public Register<0x40013448> {
            using DBL = Field<8, 5>;    // DMA burst length
            using DBA = Field<0, 5>;    // DMA base address
        };

        // DMA address for full transfer
        struct DMAR : public Register<0x4001344c> {
            using DMAB = Field<0, 16>;    // DMA register for burst accesses
        };

        // DMA address for full transfer
        struct OR1 : public Register<0x40013450> {
            using ETR_ADC2_RMP = Field<0, 2>;    // External trigger remap on ADC2 analog watchdog
            using ETR_ADC3_RMP = Field<2, 2>;    // External trigger remap on ADC3 analog watchdog
            using TI1_RMP = Field<4, 1>;    // Input Capture 1 remap
        };

        // capture/compare mode register 2 (output mode)
        struct CCMR3_Output : public Register<0x40013454> {
            using OC6M_bit3 = Field<24, 1>;    // Output Compare 6 mode bit 3
            using OC5M_bit3 = Field<16, 3>;    // Output Compare 5 mode bit 3
            using OC6CE = Field<15, 1>;    // Output compare 6 clear enable
            using OC6M = Field<12, 3>;    // Output compare 6 mode
            using OC6PE = Field<11, 1>;    // Output compare 6 preload enable
            using OC6FE = Field<10, 1>;    // Output compare 6 fast enable
            using OC5CE = Field<7, 1>;    // Output compare 5 clear enable
            using OC5M = Field<4, 3>;    // Output compare 5 mode
            using OC5PE = Field<3, 1>;    // Output compare 5 preload enable
            using OC5FE = Field<2, 1>;    // Output compare 5 fast enable
        };

        // capture/compare register 4
        struct CCR5 : public Register<0x40013458> {
            using Field = Field<0, 16>;    // Capture/Compare value
            using GC5C1 = Field<29, 1>;    // Group Channel 5 and Channel 1
            using GC5C2 = Field<30, 1>;    // Group Channel 5 and Channel 2
            using GC5C3 = Field<31, 1>;    // Group Channel 5 and Channel 3
        };

        // capture/compare register 4
        struct CCR6 : public Register<0x4001345c> {
            using Field = Field<0, 16>;    // Capture/Compare value
        };

        // DMA address for full transfer
        struct OR2 : public Register<0x40013460> {
            using BKINE = Field<0, 1>;    // BRK BKIN input enable
            using BKCMP1E = Field<1, 1>;    // BRK COMP1 enable
            using BKCMP2E = Field<2, 1>;    // BRK COMP2 enable
            using BKDFBK2E = Field<8, 1>;    // BRK DFSDM_BREAK2 enable
            using BKINP = Field<9, 1>;    // BRK BKIN input polarity
            using BKCMP1P = Field<10, 1>;    // BRK COMP1 input polarity
            using BKCMP2P = Field<11, 1>;    // BRK COMP2 input polarity
            using ETRSEL = Field<14, 3>;    // ETR source selection
        };

        // DMA address for full transfer
        struct OR3 : public Register<0x40013464> {
            using BK2INE = Field<0, 1>;    // BRK2 BKIN input enable
            using BK2CMP1E = Field<1, 1>;    // BRK2 COMP1 enable
            using BK2CMP2E = Field<2, 1>;    // BRK2 COMP2 enable
            using BK2DFBK3E = Field<8, 1>;    // BRK2 DFSDM_BREAK3 enable
            using BK2INP = Field<9, 1>;    // BRK2 BKIN input polarity
            using BK2CMP1P = Field<10, 1>;    // BRK2 COMP1 input polarity
            using BK2CMP2P = Field<11, 1>;    // BRK2 COMP2 input polarity
        };

    };

    // Basic-timers
    struct TIM6 {
        // control register 1
        struct CR1 : public Register<0x40001000> {
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40001004> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000100c> {
            using UDE = Field<8, 1>;    // Update DMA request enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40001010> {
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40001014> {
            using UG = Field<0, 1>;    // Update generation
        };

        // counter
        struct CNT : public Register<0x40001024> {
            using Field = Field<0, 16>;    // Low counter value
        };

        // prescaler
        struct PSC : public Register<0x40001028> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000102c> {
            using Field = Field<0, 16>;    // Low Auto-reload value
        };

    };

    // Basic-timers
    struct TIM7 {
        // control register 1
        struct CR1 : public Register<0x40001400> {
            using ARPE = Field<7, 1>;    // Auto-reload preload enable
            using OPM = Field<3, 1>;    // One-pulse mode
            using URS = Field<2, 1>;    // Update request source
            using UDIS = Field<1, 1>;    // Update disable
            using CEN = Field<0, 1>;    // Counter enable
        };

        // control register 2
        struct CR2 : public Register<0x40001404> {
            using MMS = Field<4, 3>;    // Master mode selection
        };

        // DMA/Interrupt enable register
        struct DIER : public Register<0x4000140c> {
            using UDE = Field<8, 1>;    // Update DMA request enable
            using UIE = Field<0, 1>;    // Update interrupt enable
        };

        // status register
        struct SR : public Register<0x40001410> {
            using UIF = Field<0, 1>;    // Update interrupt flag
        };

        // event generation register
        struct EGR : public Register<0x40001414> {
            using UG = Field<0, 1>;    // Update generation
        };

        // counter
        struct CNT : public Register<0x40001424> {
            using Field = Field<0, 16>;    // Low counter value
        };

        // prescaler
        struct PSC : public Register<0x40001428> {
            using Field = Field<0, 16>;    // Prescaler value
        };

        // auto-reload register
        struct ARR : public Register<0x4000142c> {
            using Field = Field<0, 16>;    // Low Auto-reload value
        };

    };

    // Low power timer
    struct LPTIM1 {
        // Interrupt and Status Register
        struct ISR : public Register<0x40007c00> {
            using DOWN = Field<6, 1>;    // Counter direction change up to down
            using UP = Field<5, 1>;    // Counter direction change down to up
            using ARROK = Field<4, 1>;    // Autoreload register update OK
            using CMPOK = Field<3, 1>;    // Compare register update OK
            using EXTTRIG = Field<2, 1>;    // External trigger edge event
            using ARRM = Field<1, 1>;    // Autoreload match
            using CMPM = Field<0, 1>;    // Compare match
        };

        // Interrupt Clear Register
        struct ICR : public Register<0x40007c04> {
            using DOWNCF = Field<6, 1>;    // Direction change to down Clear Flag
            using UPCF = Field<5, 1>;    // Direction change to UP Clear Flag
            using ARROKCF = Field<4, 1>;    // Autoreload register update OK Clear Flag
            using CMPOKCF = Field<3, 1>;    // Compare register update OK Clear Flag
            using EXTTRIGCF = Field<2, 1>;    // External trigger valid edge Clear Flag
            using ARRMCF = Field<1, 1>;    // Autoreload match Clear Flag
            using CMPMCF = Field<0, 1>;    // compare match Clear Flag
        };

        // Interrupt Enable Register
        struct IER : public Register<0x40007c08> {
            using DOWNIE = Field<6, 1>;    // Direction change to down Interrupt Enable
            using UPIE = Field<5, 1>;    // Direction change to UP Interrupt Enable
            using ARROKIE = Field<4, 1>;    // Autoreload register update OK Interrupt Enable
            using CMPOKIE = Field<3, 1>;    // Compare register update OK Interrupt Enable
            using EXTTRIGIE = Field<2, 1>;    // External trigger valid edge Interrupt Enable
            using ARRMIE = Field<1, 1>;    // Autoreload match Interrupt Enable
            using CMPMIE = Field<0, 1>;    // Compare match Interrupt Enable
        };

        // Configuration Register
        struct CFGR : public Register<0x40007c0c> {
            using ENC = Field<24, 1>;    // Encoder mode enable
            using COUNTMODE = Field<23, 1>;    // counter mode enabled
            using PRELOAD = Field<22, 1>;    // Registers update mode
            using WAVPOL = Field<21, 1>;    // Waveform shape polarity
            using WAVE = Field<20, 1>;    // Waveform shape
            using TIMOUT = Field<19, 1>;    // Timeout enable
            using TRIGEN = Field<17, 2>;    // Trigger enable and polarity
            using TRIGSEL = Field<13, 3>;    // Trigger selector
            using PRESC = Field<9, 3>;    // Clock prescaler
            using TRGFLT = Field<6, 2>;    // Configurable digital filter for trigger
            using CKFLT = Field<3, 2>;    // Configurable digital filter for external clock
            using CKPOL = Field<1, 2>;    // Clock Polarity
            using CKSEL = Field<0, 1>;    // Clock selector
        };

        // Control Register
        struct CR : public Register<0x40007c10> {
            using CNTSTRT = Field<2, 1>;    // Timer start in continuous mode
            using SNGSTRT = Field<1, 1>;    // LPTIM start in single mode
            using ENABLE = Field<0, 1>;    // LPTIM Enable
        };

        // Compare Register
        struct CMP : public Register<0x40007c14> {
            using Field = Field<0, 16>;    // Compare value
        };

        // Autoreload Register
        struct ARR : public Register<0x40007c18> {
            using Field = Field<0, 16>;    // Auto reload value
        };

        // Counter Register
        struct CNT : public Register<0x40007c1c> {
            using Field = Field<0, 16>;    // Counter value
        };

    };

    // Low power timer
    struct LPTIM2 {
        // Interrupt and Status Register
        struct ISR : public Register<0x40009400> {
            using DOWN = Field<6, 1>;    // Counter direction change up to down
            using UP = Field<5, 1>;    // Counter direction change down to up
            using ARROK = Field<4, 1>;    // Autoreload register update OK
            using CMPOK = Field<3, 1>;    // Compare register update OK
            using EXTTRIG = Field<2, 1>;    // External trigger edge event
            using ARRM = Field<1, 1>;    // Autoreload match
            using CMPM = Field<0, 1>;    // Compare match
        };

        // Interrupt Clear Register
        struct ICR : public Register<0x40009404> {
            using DOWNCF = Field<6, 1>;    // Direction change to down Clear Flag
            using UPCF = Field<5, 1>;    // Direction change to UP Clear Flag
            using ARROKCF = Field<4, 1>;    // Autoreload register update OK Clear Flag
            using CMPOKCF = Field<3, 1>;    // Compare register update OK Clear Flag
            using EXTTRIGCF = Field<2, 1>;    // External trigger valid edge Clear Flag
            using ARRMCF = Field<1, 1>;    // Autoreload match Clear Flag
            using CMPMCF = Field<0, 1>;    // compare match Clear Flag
        };

        // Interrupt Enable Register
        struct IER : public Register<0x40009408> {
            using DOWNIE = Field<6, 1>;    // Direction change to down Interrupt Enable
            using UPIE = Field<5, 1>;    // Direction change to UP Interrupt Enable
            using ARROKIE = Field<4, 1>;    // Autoreload register update OK Interrupt Enable
            using CMPOKIE = Field<3, 1>;    // Compare register update OK Interrupt Enable
            using EXTTRIGIE = Field<2, 1>;    // External trigger valid edge Interrupt Enable
            using ARRMIE = Field<1, 1>;    // Autoreload match Interrupt Enable
            using CMPMIE = Field<0, 1>;    // Compare match Interrupt Enable
        };

        // Configuration Register
        struct CFGR : public Register<0x4000940c> {
            using ENC = Field<24, 1>;    // Encoder mode enable
            using COUNTMODE = Field<23, 1>;    // counter mode enabled
            using PRELOAD = Field<22, 1>;    // Registers update mode
            using WAVPOL = Field<21, 1>;    // Waveform shape polarity
            using WAVE = Field<20, 1>;    // Waveform shape
            using TIMOUT = Field<19, 1>;    // Timeout enable
            using TRIGEN = Field<17, 2>;    // Trigger enable and polarity
            using TRIGSEL = Field<13, 3>;    // Trigger selector
            using PRESC = Field<9, 3>;    // Clock prescaler
            using TRGFLT = Field<6, 2>;    // Configurable digital filter for trigger
            using CKFLT = Field<3, 2>;    // Configurable digital filter for external clock
            using CKPOL = Field<1, 2>;    // Clock Polarity
            using CKSEL = Field<0, 1>;    // Clock selector
        };

        // Control Register
        struct CR : public Register<0x40009410> {
            using CNTSTRT = Field<2, 1>;    // Timer start in continuous mode
            using SNGSTRT = Field<1, 1>;    // LPTIM start in single mode
            using ENABLE = Field<0, 1>;    // LPTIM Enable
        };

        // Compare Register
        struct CMP : public Register<0x40009414> {
            using Field = Field<0, 16>;    // Compare value
        };

        // Autoreload Register
        struct ARR : public Register<0x40009418> {
            using Field = Field<0, 16>;    // Auto reload value
        };

        // Counter Register
        struct CNT : public Register<0x4000941c> {
            using Field = Field<0, 16>;    // Counter value
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART1 {
        // Control register 1
        struct CR1 : public Register<0x40013800> {
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40013804> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x40013808> {
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4001380c> {
            using DIV_Mantissa = Field<4, 12>;    // DIV_Mantissa
            using DIV_Fraction = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40013810> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40013814> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public Register<0x40013818> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public Register<0x4001381c> {
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public Register<0x40013820> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public Register<0x40013824> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40013828> {
            using Field = Field<0, 9>;    // Transmit data value
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART2 {
        // Control register 1
        struct CR1 : public Register<0x40004400> {
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40004404> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x40004408> {
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4000440c> {
            using DIV_Mantissa = Field<4, 12>;    // DIV_Mantissa
            using DIV_Fraction = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40004410> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40004414> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public Register<0x40004418> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public Register<0x4000441c> {
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public Register<0x40004420> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public Register<0x40004424> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40004428> {
            using Field = Field<0, 9>;    // Transmit data value
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct USART3 {
        // Control register 1
        struct CR1 : public Register<0x40004800> {
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40004804> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x40004808> {
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4000480c> {
            using DIV_Mantissa = Field<4, 12>;    // DIV_Mantissa
            using DIV_Fraction = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40004810> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40004814> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public Register<0x40004818> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public Register<0x4000481c> {
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public Register<0x40004820> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public Register<0x40004824> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40004828> {
            using Field = Field<0, 9>;    // Transmit data value
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct UART4 {
        // Control register 1
        struct CR1 : public Register<0x40004c00> {
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40004c04> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x40004c08> {
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x40004c0c> {
            using DIV_Mantissa = Field<4, 12>;    // DIV_Mantissa
            using DIV_Fraction = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40004c10> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40004c14> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public Register<0x40004c18> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public Register<0x40004c1c> {
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public Register<0x40004c20> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public Register<0x40004c24> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40004c28> {
            using Field = Field<0, 9>;    // Transmit data value
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct UART5 {
        // Control register 1
        struct CR1 : public Register<0x40005000> {
            using M1 = Field<28, 1>;    // Word length
            using EOBIE = Field<27, 1>;    // End of Block interrupt enable
            using RTOIE = Field<26, 1>;    // Receiver timeout interrupt enable
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using OVER8 = Field<15, 1>;    // Oversampling mode
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40005004> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using RTOEN = Field<23, 1>;    // Receiver timeout enable
            using ABRMOD1 = Field<22, 1>;    // Auto baud rate mode
            using ABRMOD0 = Field<21, 1>;    // ABRMOD0
            using ABREN = Field<20, 1>;    // Auto baud rate enable
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using LINEN = Field<14, 1>;    // LIN mode enable
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using CPOL = Field<10, 1>;    // Clock polarity
            using CPHA = Field<9, 1>;    // Clock phase
            using LBCL = Field<8, 1>;    // Last bit clock pulse
            using LBDIE = Field<6, 1>;    // LIN break detection interrupt enable
            using LBDL = Field<5, 1>;    // LIN break detection length
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x40005008> {
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using SCARCNT = Field<17, 3>;    // Smartcard auto-retry count
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using ONEBIT = Field<11, 1>;    // One sample bit method enable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using SCEN = Field<5, 1>;    // Smartcard mode enable
            using NACK = Field<4, 1>;    // Smartcard NACK enable
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using IRLP = Field<2, 1>;    // Ir low-power
            using IREN = Field<1, 1>;    // Ir mode enable
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4000500c> {
            using DIV_Mantissa = Field<4, 12>;    // DIV_Mantissa
            using DIV_Fraction = Field<0, 4>;    // DIV_Fraction
        };

        // Guard time and prescaler register
        struct GTPR : public Register<0x40005010> {
            using GT = Field<8, 8>;    // Guard time value
            using PSC = Field<0, 8>;    // Prescaler value
        };

        // Receiver timeout register
        struct RTOR : public Register<0x40005014> {
            using BLEN = Field<24, 8>;    // Block Length
            using RTO = Field<0, 24>;    // Receiver timeout value
        };

        // Request register
        struct RQR : public Register<0x40005018> {
            using TXFRQ = Field<4, 1>;    // Transmit data flush request
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
            using ABRRQ = Field<0, 1>;    // Auto baud rate request
        };

        // Interrupt & status register
        struct ISR : public Register<0x4000501c> {
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using ABRF = Field<15, 1>;    // ABRF
            using ABRE = Field<14, 1>;    // ABRE
            using EOBF = Field<12, 1>;    // EOBF
            using RTOF = Field<11, 1>;    // RTOF
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using LBDF = Field<8, 1>;    // LBDF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public Register<0x40005020> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using EOBCF = Field<12, 1>;    // End of block clear flag
            using RTOCF = Field<11, 1>;    // Receiver timeout clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using LBDCF = Field<8, 1>;    // LIN break detection clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public Register<0x40005024> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40005028> {
            using Field = Field<0, 9>;    // Transmit data value
        };

    };

    // Universal synchronous asynchronous receiver transmitter
    struct LPUART1 {
        // Control register 1
        struct CR1 : public Register<0x40008000> {
            using M1 = Field<28, 1>;    // Word length
            using DEAT4 = Field<25, 1>;    // Driver Enable assertion time
            using DEAT3 = Field<24, 1>;    // DEAT3
            using DEAT2 = Field<23, 1>;    // DEAT2
            using DEAT1 = Field<22, 1>;    // DEAT1
            using DEAT0 = Field<21, 1>;    // DEAT0
            using DEDT4 = Field<20, 1>;    // Driver Enable de-assertion time
            using DEDT3 = Field<19, 1>;    // DEDT3
            using DEDT2 = Field<18, 1>;    // DEDT2
            using DEDT1 = Field<17, 1>;    // DEDT1
            using DEDT0 = Field<16, 1>;    // DEDT0
            using CMIE = Field<14, 1>;    // Character match interrupt enable
            using MME = Field<13, 1>;    // Mute mode enable
            using M0 = Field<12, 1>;    // Word length
            using WAKE = Field<11, 1>;    // Receiver wakeup method
            using PCE = Field<10, 1>;    // Parity control enable
            using PS = Field<9, 1>;    // Parity selection
            using PEIE = Field<8, 1>;    // PE interrupt enable
            using TXEIE = Field<7, 1>;    // interrupt enable
            using TCIE = Field<6, 1>;    // Transmission complete interrupt enable
            using RXNEIE = Field<5, 1>;    // RXNE interrupt enable
            using IDLEIE = Field<4, 1>;    // IDLE interrupt enable
            using TE = Field<3, 1>;    // Transmitter enable
            using RE = Field<2, 1>;    // Receiver enable
            using UESM = Field<1, 1>;    // USART enable in Stop mode
            using UE = Field<0, 1>;    // USART enable
        };

        // Control register 2
        struct CR2 : public Register<0x40008004> {
            using ADD4_7 = Field<28, 4>;    // Address of the USART node
            using ADD0_3 = Field<24, 4>;    // Address of the USART node
            using MSBFIRST = Field<19, 1>;    // Most significant bit first
            using TAINV = Field<18, 1>;    // Binary data inversion
            using TXINV = Field<17, 1>;    // TX pin active level inversion
            using RXINV = Field<16, 1>;    // RX pin active level inversion
            using SWAP = Field<15, 1>;    // Swap TX/RX pins
            using STOP = Field<12, 2>;    // STOP bits
            using CLKEN = Field<11, 1>;    // Clock enable
            using ADDM7 = Field<4, 1>;    // 7-bit Address Detection/4-bit Address Detection
        };

        // Control register 3
        struct CR3 : public Register<0x40008008> {
            using WUFIE = Field<22, 1>;    // Wakeup from Stop mode interrupt enable
            using WUS = Field<20, 2>;    // Wakeup from Stop mode interrupt flag selection
            using DEP = Field<15, 1>;    // Driver enable polarity selection
            using DEM = Field<14, 1>;    // Driver enable mode
            using DDRE = Field<13, 1>;    // DMA Disable on Reception Error
            using OVRDIS = Field<12, 1>;    // Overrun Disable
            using CTSIE = Field<10, 1>;    // CTS interrupt enable
            using CTSE = Field<9, 1>;    // CTS enable
            using RTSE = Field<8, 1>;    // RTS enable
            using DMAT = Field<7, 1>;    // DMA enable transmitter
            using DMAR = Field<6, 1>;    // DMA enable receiver
            using HDSEL = Field<3, 1>;    // Half-duplex selection
            using EIE = Field<0, 1>;    // Error interrupt enable
        };

        // Baud rate register
        struct BRR : public Register<0x4000800c> {
            using Field = Field<0, 20>;    // BRR
        };

        // Request register
        struct RQR : public Register<0x40008018> {
            using RXFRQ = Field<3, 1>;    // Receive data flush request
            using MMRQ = Field<2, 1>;    // Mute mode request
            using SBKRQ = Field<1, 1>;    // Send break request
        };

        // Interrupt & status register
        struct ISR : public Register<0x4000801c> {
            using REACK = Field<22, 1>;    // REACK
            using TEACK = Field<21, 1>;    // TEACK
            using WUF = Field<20, 1>;    // WUF
            using RWU = Field<19, 1>;    // RWU
            using SBKF = Field<18, 1>;    // SBKF
            using CMF = Field<17, 1>;    // CMF
            using BUSY = Field<16, 1>;    // BUSY
            using CTS = Field<10, 1>;    // CTS
            using CTSIF = Field<9, 1>;    // CTSIF
            using TXE = Field<7, 1>;    // TXE
            using TC = Field<6, 1>;    // TC
            using RXNE = Field<5, 1>;    // RXNE
            using IDLE = Field<4, 1>;    // IDLE
            using ORE = Field<3, 1>;    // ORE
            using NF = Field<2, 1>;    // NF
            using FE = Field<1, 1>;    // FE
            using PE = Field<0, 1>;    // PE
        };

        // Interrupt flag clear register
        struct ICR : public Register<0x40008020> {
            using WUCF = Field<20, 1>;    // Wakeup from Stop mode clear flag
            using CMCF = Field<17, 1>;    // Character match clear flag
            using CTSCF = Field<9, 1>;    // CTS clear flag
            using TCCF = Field<6, 1>;    // Transmission complete clear flag
            using IDLECF = Field<4, 1>;    // Idle line detected clear flag
            using ORECF = Field<3, 1>;    // Overrun error clear flag
            using NCF = Field<2, 1>;    // Noise detected clear flag
            using FECF = Field<1, 1>;    // Framing error clear flag
            using PECF = Field<0, 1>;    // Parity error clear flag
        };

        // Receive data register
        struct RDR : public Register<0x40008024> {
            using Field = Field<0, 9>;    // Receive data value
        };

        // Transmit data register
        struct TDR : public Register<0x40008028> {
            using Field = Field<0, 9>;    // Transmit data value
        };

    };

    // Serial peripheral interface/Inter-IC sound
    struct SPI1 {
        // control register 1
        struct CR1 : public Register<0x40013000> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using DFF = Field<11, 1>;    // Data frame format
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40013004> {
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using SSOE = Field<2, 1>;    // SS output enable
            using NSSP = Field<3, 1>;    // NSS pulse management
            using FRF = Field<4, 1>;    // Frame format
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
            using DS = Field<8, 4>;    // Data size
            using FRXTH = Field<12, 1>;    // FIFO reception threshold
            using LDMA_RX = Field<13, 1>;    // Last DMA transfer for reception
            using LDMA_TX = Field<14, 1>;    // Last DMA transfer for transmission
        };

        // status register
        struct SR : public Register<0x40013008> {
            using RXNE = Field<0, 1>;    // Receive buffer not empty
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using CRCERR = Field<4, 1>;    // CRC error flag
            using MODF = Field<5, 1>;    // Mode fault
            using OVR = Field<6, 1>;    // Overrun flag
            using BSY = Field<7, 1>;    // Busy flag
            using TIFRFE = Field<8, 1>;    // TI frame format error
            using FRLVL = Field<9, 2>;    // FIFO reception level
            using FTLVL = Field<11, 2>;    // FIFO transmission level
        };

        // data register
        struct DR : public Register<0x4001300c> {
            using Field = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40013010> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public Register<0x40013014> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public Register<0x40013018> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

    };

    // Serial peripheral interface/Inter-IC sound
    struct SPI2 {
        // control register 1
        struct CR1 : public Register<0x40003800> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using DFF = Field<11, 1>;    // Data frame format
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40003804> {
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using SSOE = Field<2, 1>;    // SS output enable
            using NSSP = Field<3, 1>;    // NSS pulse management
            using FRF = Field<4, 1>;    // Frame format
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
            using DS = Field<8, 4>;    // Data size
            using FRXTH = Field<12, 1>;    // FIFO reception threshold
            using LDMA_RX = Field<13, 1>;    // Last DMA transfer for reception
            using LDMA_TX = Field<14, 1>;    // Last DMA transfer for transmission
        };

        // status register
        struct SR : public Register<0x40003808> {
            using RXNE = Field<0, 1>;    // Receive buffer not empty
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using CRCERR = Field<4, 1>;    // CRC error flag
            using MODF = Field<5, 1>;    // Mode fault
            using OVR = Field<6, 1>;    // Overrun flag
            using BSY = Field<7, 1>;    // Busy flag
            using TIFRFE = Field<8, 1>;    // TI frame format error
            using FRLVL = Field<9, 2>;    // FIFO reception level
            using FTLVL = Field<11, 2>;    // FIFO transmission level
        };

        // data register
        struct DR : public Register<0x4000380c> {
            using Field = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40003810> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public Register<0x40003814> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public Register<0x40003818> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

    };

    // Serial peripheral interface/Inter-IC sound
    struct SPI3 {
        // control register 1
        struct CR1 : public Register<0x40003c00> {
            using BIDIMODE = Field<15, 1>;    // Bidirectional data mode enable
            using BIDIOE = Field<14, 1>;    // Output enable in bidirectional mode
            using CRCEN = Field<13, 1>;    // Hardware CRC calculation enable
            using CRCNEXT = Field<12, 1>;    // CRC transfer next
            using DFF = Field<11, 1>;    // Data frame format
            using RXONLY = Field<10, 1>;    // Receive only
            using SSM = Field<9, 1>;    // Software slave management
            using SSI = Field<8, 1>;    // Internal slave select
            using LSBFIRST = Field<7, 1>;    // Frame format
            using SPE = Field<6, 1>;    // SPI enable
            using BR = Field<3, 3>;    // Baud rate control
            using MSTR = Field<2, 1>;    // Master selection
            using CPOL = Field<1, 1>;    // Clock polarity
            using CPHA = Field<0, 1>;    // Clock phase
        };

        // control register 2
        struct CR2 : public Register<0x40003c04> {
            using RXDMAEN = Field<0, 1>;    // Rx buffer DMA enable
            using TXDMAEN = Field<1, 1>;    // Tx buffer DMA enable
            using SSOE = Field<2, 1>;    // SS output enable
            using NSSP = Field<3, 1>;    // NSS pulse management
            using FRF = Field<4, 1>;    // Frame format
            using ERRIE = Field<5, 1>;    // Error interrupt enable
            using RXNEIE = Field<6, 1>;    // RX buffer not empty interrupt enable
            using TXEIE = Field<7, 1>;    // Tx buffer empty interrupt enable
            using DS = Field<8, 4>;    // Data size
            using FRXTH = Field<12, 1>;    // FIFO reception threshold
            using LDMA_RX = Field<13, 1>;    // Last DMA transfer for reception
            using LDMA_TX = Field<14, 1>;    // Last DMA transfer for transmission
        };

        // status register
        struct SR : public Register<0x40003c08> {
            using RXNE = Field<0, 1>;    // Receive buffer not empty
            using TXE = Field<1, 1>;    // Transmit buffer empty
            using CRCERR = Field<4, 1>;    // CRC error flag
            using MODF = Field<5, 1>;    // Mode fault
            using OVR = Field<6, 1>;    // Overrun flag
            using BSY = Field<7, 1>;    // Busy flag
            using TIFRFE = Field<8, 1>;    // TI frame format error
            using FRLVL = Field<9, 2>;    // FIFO reception level
            using FTLVL = Field<11, 2>;    // FIFO transmission level
        };

        // data register
        struct DR : public Register<0x40003c0c> {
            using Field = Field<0, 16>;    // Data register
        };

        // CRC polynomial register
        struct CRCPR : public Register<0x40003c10> {
            using CRCPOLY = Field<0, 16>;    // CRC polynomial register
        };

        // RX CRC register
        struct RXCRCR : public Register<0x40003c14> {
            using RxCRC = Field<0, 16>;    // Rx CRC register
        };

        // TX CRC register
        struct TXCRCR : public Register<0x40003c18> {
            using TxCRC = Field<0, 16>;    // Tx CRC register
        };

    };

    // Secure digital input/output interface
    struct SDMMC1 {
        // power control register
        struct POWER : public Register<0x50062400> {
            using PWRCTRL = Field<0, 2>;    // PWRCTRL
        };

        // SDI clock control register
        struct CLKCR : public Register<0x50062404> {
            using HWFC_EN = Field<14, 1>;    // HW Flow Control enable
            using NEGEDGE = Field<13, 1>;    // SDIO_CK dephasing selection bit
            using WIDBUS = Field<11, 2>;    // Wide bus mode enable bit
            using BYPASS = Field<10, 1>;    // Clock divider bypass enable bit
            using PWRSAV = Field<9, 1>;    // Power saving configuration bit
            using CLKEN = Field<8, 1>;    // Clock enable bit
            using CLKDIV = Field<0, 8>;    // Clock divide factor
        };

        // argument register
        struct ARG : public Register<0x50062408> {
            using CMDARG = Field<0, 32>;    // Command argument
        };

        // command register
        struct CMD : public Register<0x5006240c> {
            using CE_ATACMD = Field<14, 1>;    // CE-ATA command
            using nIEN = Field<13, 1>;    // not Interrupt Enable
            using ENCMDcompl = Field<12, 1>;    // Enable CMD completion
            using SDIOSuspend = Field<11, 1>;    // SD I/O suspend command
            using CPSMEN = Field<10, 1>;    // Command path state machine (CPSM) Enable bit
            using WAITPEND = Field<9, 1>;    // CPSM Waits for ends of data transfer (CmdPend internal signal)
            using WAITINT = Field<8, 1>;    // CPSM waits for interrupt request
            using WAITRESP = Field<6, 2>;    // Wait for response bits
            using CMDINDEX = Field<0, 6>;    // Command index
        };

        // command response register
        struct RESPCMD : public Register<0x50062410> {
            using Field = Field<0, 6>;    // Response command index
        };

        // response 1..4 register
        struct RESP1 : public Register<0x50062414> {
            using CARDSTATUS1 = Field<0, 32>;    // see Table 132
        };

        // response 1..4 register
        struct RESP2 : public Register<0x50062418> {
            using CARDSTATUS2 = Field<0, 32>;    // see Table 132
        };

        // response 1..4 register
        struct RESP3 : public Register<0x5006241c> {
            using CARDSTATUS3 = Field<0, 32>;    // see Table 132
        };

        // response 1..4 register
        struct RESP4 : public Register<0x50062420> {
            using CARDSTATUS4 = Field<0, 32>;    // see Table 132
        };

        // data timer register
        struct DTIMER : public Register<0x50062424> {
            using DATATIME = Field<0, 32>;    // Data timeout period
        };

        // data length register
        struct DLEN : public Register<0x50062428> {
            using DATALENGTH = Field<0, 25>;    // Data length value
        };

        // data control register
        struct DCTRL : public Register<0x5006242c> {
            using SDIOEN = Field<11, 1>;    // SD I/O enable functions
            using RWMOD = Field<10, 1>;    // Read wait mode
            using RWSTOP = Field<9, 1>;    // Read wait stop
            using RWSTART = Field<8, 1>;    // Read wait start
            using DBLOCKSIZE = Field<4, 4>;    // Data block size
            using DMAEN = Field<3, 1>;    // DMA enable bit
            using DTMODE = Field<2, 1>;    // Data transfer mode selection 1: Stream or SDIO multibyte data transfer
            using DTDIR = Field<1, 1>;    // Data transfer direction selection
            using DTEN = Field<0, 1>;    // DTEN
        };

        // data counter register
        struct DCOUNT : public Register<0x50062430> {
            using DATACOUNT = Field<0, 25>;    // Data count value
        };

        // status register
        struct STA : public Register<0x50062434> {
            using CEATAEND = Field<23, 1>;    // CE-ATA command completion signal received for CMD61
            using SDIOIT = Field<22, 1>;    // SDIO interrupt received
            using RXDAVL = Field<21, 1>;    // Data available in receive FIFO
            using TXDAVL = Field<20, 1>;    // Data available in transmit FIFO
            using RXFIFOE = Field<19, 1>;    // Receive FIFO empty
            using TXFIFOE = Field<18, 1>;    // Transmit FIFO empty
            using RXFIFOF = Field<17, 1>;    // Receive FIFO full
            using TXFIFOF = Field<16, 1>;    // Transmit FIFO full
            using RXFIFOHF = Field<15, 1>;    // Receive FIFO half full: there are at least 8 words in the FIFO
            using TXFIFOHE = Field<14, 1>;    // Transmit FIFO half empty: at least 8 words can be written into the FIFO
            using RXACT = Field<13, 1>;    // Data receive in progress
            using TXACT = Field<12, 1>;    // Data transmit in progress
            using CMDACT = Field<11, 1>;    // Command transfer in progress
            using DBCKEND = Field<10, 1>;    // Data block sent/received (CRC check passed)
            using STBITERR = Field<9, 1>;    // Start bit not detected on all data signals in wide bus mode
            using DATAEND = Field<8, 1>;    // Data end (data counter, SDIDCOUNT, is zero)
            using CMDSENT = Field<7, 1>;    // Command sent (no response required)
            using CMDREND = Field<6, 1>;    // Command response received (CRC check passed)
            using RXOVERR = Field<5, 1>;    // Received FIFO overrun error
            using TXUNDERR = Field<4, 1>;    // Transmit FIFO underrun error
            using DTIMEOUT = Field<3, 1>;    // Data timeout
            using CTIMEOUT = Field<2, 1>;    // Command response timeout
            using DCRCFAIL = Field<1, 1>;    // Data block sent/received (CRC check failed)
            using CCRCFAIL = Field<0, 1>;    // Command response received (CRC check failed)
        };

        // interrupt clear register
        struct ICR : public Register<0x50062438> {
            using CEATAENDC = Field<23, 1>;    // CEATAEND flag clear bit
            using SDIOITC = Field<22, 1>;    // SDIOIT flag clear bit
            using DBCKENDC = Field<10, 1>;    // DBCKEND flag clear bit
            using STBITERRC = Field<9, 1>;    // STBITERR flag clear bit
            using DATAENDC = Field<8, 1>;    // DATAEND flag clear bit
            using CMDSENTC = Field<7, 1>;    // CMDSENT flag clear bit
            using CMDRENDC = Field<6, 1>;    // CMDREND flag clear bit
            using RXOVERRC = Field<5, 1>;    // RXOVERR flag clear bit
            using TXUNDERRC = Field<4, 1>;    // TXUNDERR flag clear bit
            using DTIMEOUTC = Field<3, 1>;    // DTIMEOUT flag clear bit
            using CTIMEOUTC = Field<2, 1>;    // CTIMEOUT flag clear bit
            using DCRCFAILC = Field<1, 1>;    // DCRCFAIL flag clear bit
            using CCRCFAILC = Field<0, 1>;    // CCRCFAIL flag clear bit
        };

        // mask register
        struct MASK : public Register<0x5006243c> {
            using CEATAENDIE = Field<23, 1>;    // CE-ATA command completion signal received interrupt enable
            using SDIOITIE = Field<22, 1>;    // SDIO mode interrupt received interrupt enable
            using RXDAVLIE = Field<21, 1>;    // Data available in Rx FIFO interrupt enable
            using TXDAVLIE = Field<20, 1>;    // Data available in Tx FIFO interrupt enable
            using RXFIFOEIE = Field<19, 1>;    // Rx FIFO empty interrupt enable
            using TXFIFOEIE = Field<18, 1>;    // Tx FIFO empty interrupt enable
            using RXFIFOFIE = Field<17, 1>;    // Rx FIFO full interrupt enable
            using TXFIFOFIE = Field<16, 1>;    // Tx FIFO full interrupt enable
            using RXFIFOHFIE = Field<15, 1>;    // Rx FIFO half full interrupt enable
            using TXFIFOHEIE = Field<14, 1>;    // Tx FIFO half empty interrupt enable
            using RXACTIE = Field<13, 1>;    // Data receive acting interrupt enable
            using TXACTIE = Field<12, 1>;    // Data transmit acting interrupt enable
            using CMDACTIE = Field<11, 1>;    // Command acting interrupt enable
            using DBCKENDIE = Field<10, 1>;    // Data block end interrupt enable
            using STBITERRIE = Field<9, 1>;    // Start bit error interrupt enable
            using DATAENDIE = Field<8, 1>;    // Data end interrupt enable
            using CMDSENTIE = Field<7, 1>;    // Command sent interrupt enable
            using CMDRENDIE = Field<6, 1>;    // Command response received interrupt enable
            using RXOVERRIE = Field<5, 1>;    // Rx FIFO overrun error interrupt enable
            using TXUNDERRIE = Field<4, 1>;    // Tx FIFO underrun error interrupt enable
            using DTIMEOUTIE = Field<3, 1>;    // Data timeout interrupt enable
            using CTIMEOUTIE = Field<2, 1>;    // Command timeout interrupt enable
            using DCRCFAILIE = Field<1, 1>;    // Data CRC fail interrupt enable
            using CCRCFAILIE = Field<0, 1>;    // Command CRC fail interrupt enable
        };

        // FIFO counter register
        struct FIFOCNT : public Register<0x50062448> {
            using FIFOCOUNT = Field<0, 24>;    // Remaining number of words to be written to or read from the FIFO
        };

        // data FIFO register
        struct FIFO : public Register<0x50062480> {
            using FIFOData = Field<0, 32>;    // Receive and transmit FIFO data
        };

    };

    // External interrupt/event controller
    struct EXTI {
        // Interrupt mask register
        struct IMR1 : public Register<0x40010400> {
            using MR0 = Field<0, 1>;    // Interrupt Mask on line 0
            using MR1 = Field<1, 1>;    // Interrupt Mask on line 1
            using MR2 = Field<2, 1>;    // Interrupt Mask on line 2
            using MR3 = Field<3, 1>;    // Interrupt Mask on line 3
            using MR4 = Field<4, 1>;    // Interrupt Mask on line 4
            using MR5 = Field<5, 1>;    // Interrupt Mask on line 5
            using MR6 = Field<6, 1>;    // Interrupt Mask on line 6
            using MR7 = Field<7, 1>;    // Interrupt Mask on line 7
            using MR8 = Field<8, 1>;    // Interrupt Mask on line 8
            using MR9 = Field<9, 1>;    // Interrupt Mask on line 9
            using MR10 = Field<10, 1>;    // Interrupt Mask on line 10
            using MR11 = Field<11, 1>;    // Interrupt Mask on line 11
            using MR12 = Field<12, 1>;    // Interrupt Mask on line 12
            using MR13 = Field<13, 1>;    // Interrupt Mask on line 13
            using MR14 = Field<14, 1>;    // Interrupt Mask on line 14
            using MR15 = Field<15, 1>;    // Interrupt Mask on line 15
            using MR16 = Field<16, 1>;    // Interrupt Mask on line 16
            using MR17 = Field<17, 1>;    // Interrupt Mask on line 17
            using MR18 = Field<18, 1>;    // Interrupt Mask on line 18
            using MR19 = Field<19, 1>;    // Interrupt Mask on line 19
            using MR20 = Field<20, 1>;    // Interrupt Mask on line 20
            using MR21 = Field<21, 1>;    // Interrupt Mask on line 21
            using MR22 = Field<22, 1>;    // Interrupt Mask on line 22
            using MR23 = Field<23, 1>;    // Interrupt Mask on line 23
            using MR24 = Field<24, 1>;    // Interrupt Mask on line 24
            using MR25 = Field<25, 1>;    // Interrupt Mask on line 25
            using MR26 = Field<26, 1>;    // Interrupt Mask on line 26
            using MR27 = Field<27, 1>;    // Interrupt Mask on line 27
            using MR28 = Field<28, 1>;    // Interrupt Mask on line 28
            using MR29 = Field<29, 1>;    // Interrupt Mask on line 29
            using MR30 = Field<30, 1>;    // Interrupt Mask on line 30
            using MR31 = Field<31, 1>;    // Interrupt Mask on line 31
        };

        // Event mask register
        struct EMR1 : public Register<0x40010404> {
            using MR0 = Field<0, 1>;    // Event Mask on line 0
            using MR1 = Field<1, 1>;    // Event Mask on line 1
            using MR2 = Field<2, 1>;    // Event Mask on line 2
            using MR3 = Field<3, 1>;    // Event Mask on line 3
            using MR4 = Field<4, 1>;    // Event Mask on line 4
            using MR5 = Field<5, 1>;    // Event Mask on line 5
            using MR6 = Field<6, 1>;    // Event Mask on line 6
            using MR7 = Field<7, 1>;    // Event Mask on line 7
            using MR8 = Field<8, 1>;    // Event Mask on line 8
            using MR9 = Field<9, 1>;    // Event Mask on line 9
            using MR10 = Field<10, 1>;    // Event Mask on line 10
            using MR11 = Field<11, 1>;    // Event Mask on line 11
            using MR12 = Field<12, 1>;    // Event Mask on line 12
            using MR13 = Field<13, 1>;    // Event Mask on line 13
            using MR14 = Field<14, 1>;    // Event Mask on line 14
            using MR15 = Field<15, 1>;    // Event Mask on line 15
            using MR16 = Field<16, 1>;    // Event Mask on line 16
            using MR17 = Field<17, 1>;    // Event Mask on line 17
            using MR18 = Field<18, 1>;    // Event Mask on line 18
            using MR19 = Field<19, 1>;    // Event Mask on line 19
            using MR20 = Field<20, 1>;    // Event Mask on line 20
            using MR21 = Field<21, 1>;    // Event Mask on line 21
            using MR22 = Field<22, 1>;    // Event Mask on line 22
            using MR23 = Field<23, 1>;    // Event Mask on line 23
            using MR24 = Field<24, 1>;    // Event Mask on line 24
            using MR25 = Field<25, 1>;    // Event Mask on line 25
            using MR26 = Field<26, 1>;    // Event Mask on line 26
            using MR27 = Field<27, 1>;    // Event Mask on line 27
            using MR28 = Field<28, 1>;    // Event Mask on line 28
            using MR29 = Field<29, 1>;    // Event Mask on line 29
            using MR30 = Field<30, 1>;    // Event Mask on line 30
            using MR31 = Field<31, 1>;    // Event Mask on line 31
        };

        // Rising Trigger selection register
        struct RTSR1 : public Register<0x40010408> {
            using TR0 = Field<0, 1>;    // Rising trigger event configuration of line 0
            using TR1 = Field<1, 1>;    // Rising trigger event configuration of line 1
            using TR2 = Field<2, 1>;    // Rising trigger event configuration of line 2
            using TR3 = Field<3, 1>;    // Rising trigger event configuration of line 3
            using TR4 = Field<4, 1>;    // Rising trigger event configuration of line 4
            using TR5 = Field<5, 1>;    // Rising trigger event configuration of line 5
            using TR6 = Field<6, 1>;    // Rising trigger event configuration of line 6
            using TR7 = Field<7, 1>;    // Rising trigger event configuration of line 7
            using TR8 = Field<8, 1>;    // Rising trigger event configuration of line 8
            using TR9 = Field<9, 1>;    // Rising trigger event configuration of line 9
            using TR10 = Field<10, 1>;    // Rising trigger event configuration of line 10
            using TR11 = Field<11, 1>;    // Rising trigger event configuration of line 11
            using TR12 = Field<12, 1>;    // Rising trigger event configuration of line 12
            using TR13 = Field<13, 1>;    // Rising trigger event configuration of line 13
            using TR14 = Field<14, 1>;    // Rising trigger event configuration of line 14
            using TR15 = Field<15, 1>;    // Rising trigger event configuration of line 15
            using TR16 = Field<16, 1>;    // Rising trigger event configuration of line 16
            using TR18 = Field<18, 1>;    // Rising trigger event configuration of line 18
            using TR19 = Field<19, 1>;    // Rising trigger event configuration of line 19
            using TR20 = Field<20, 1>;    // Rising trigger event configuration of line 20
            using TR21 = Field<21, 1>;    // Rising trigger event configuration of line 21
            using TR22 = Field<22, 1>;    // Rising trigger event configuration of line 22
        };

        // Falling Trigger selection register
        struct FTSR1 : public Register<0x4001040c> {
            using TR0 = Field<0, 1>;    // Falling trigger event configuration of line 0
            using TR1 = Field<1, 1>;    // Falling trigger event configuration of line 1
            using TR2 = Field<2, 1>;    // Falling trigger event configuration of line 2
            using TR3 = Field<3, 1>;    // Falling trigger event configuration of line 3
            using TR4 = Field<4, 1>;    // Falling trigger event configuration of line 4
            using TR5 = Field<5, 1>;    // Falling trigger event configuration of line 5
            using TR6 = Field<6, 1>;    // Falling trigger event configuration of line 6
            using TR7 = Field<7, 1>;    // Falling trigger event configuration of line 7
            using TR8 = Field<8, 1>;    // Falling trigger event configuration of line 8
            using TR9 = Field<9, 1>;    // Falling trigger event configuration of line 9
            using TR10 = Field<10, 1>;    // Falling trigger event configuration of line 10
            using TR11 = Field<11, 1>;    // Falling trigger event configuration of line 11
            using TR12 = Field<12, 1>;    // Falling trigger event configuration of line 12
            using TR13 = Field<13, 1>;    // Falling trigger event configuration of line 13
            using TR14 = Field<14, 1>;    // Falling trigger event configuration of line 14
            using TR15 = Field<15, 1>;    // Falling trigger event configuration of line 15
            using TR16 = Field<16, 1>;    // Falling trigger event configuration of line 16
            using TR18 = Field<18, 1>;    // Falling trigger event configuration of line 18
            using TR19 = Field<19, 1>;    // Falling trigger event configuration of line 19
            using TR20 = Field<20, 1>;    // Falling trigger event configuration of line 20
            using TR21 = Field<21, 1>;    // Falling trigger event configuration of line 21
            using TR22 = Field<22, 1>;    // Falling trigger event configuration of line 22
        };

        // Software interrupt event register
        struct SWIER1 : public Register<0x40010410> {
            using SWIER0 = Field<0, 1>;    // Software Interrupt on line 0
            using Field = Field<1, 1>;    // Software Interrupt on line 1
            using SWIER2 = Field<2, 1>;    // Software Interrupt on line 2
            using SWIER3 = Field<3, 1>;    // Software Interrupt on line 3
            using SWIER4 = Field<4, 1>;    // Software Interrupt on line 4
            using SWIER5 = Field<5, 1>;    // Software Interrupt on line 5
            using SWIER6 = Field<6, 1>;    // Software Interrupt on line 6
            using SWIER7 = Field<7, 1>;    // Software Interrupt on line 7
            using SWIER8 = Field<8, 1>;    // Software Interrupt on line 8
            using SWIER9 = Field<9, 1>;    // Software Interrupt on line 9
            using SWIER10 = Field<10, 1>;    // Software Interrupt on line 10
            using SWIER11 = Field<11, 1>;    // Software Interrupt on line 11
            using SWIER12 = Field<12, 1>;    // Software Interrupt on line 12
            using SWIER13 = Field<13, 1>;    // Software Interrupt on line 13
            using SWIER14 = Field<14, 1>;    // Software Interrupt on line 14
            using SWIER15 = Field<15, 1>;    // Software Interrupt on line 15
            using SWIER16 = Field<16, 1>;    // Software Interrupt on line 16
            using SWIER18 = Field<18, 1>;    // Software Interrupt on line 18
            using SWIER19 = Field<19, 1>;    // Software Interrupt on line 19
            using SWIER20 = Field<20, 1>;    // Software Interrupt on line 20
            using SWIER21 = Field<21, 1>;    // Software Interrupt on line 21
            using SWIER22 = Field<22, 1>;    // Software Interrupt on line 22
        };

        // Pending register
        struct PR1 : public Register<0x40010414> {
            using PR0 = Field<0, 1>;    // Pending bit 0
            using Field = Field<1, 1>;    // Pending bit 1
            using PR2 = Field<2, 1>;    // Pending bit 2
            using PR3 = Field<3, 1>;    // Pending bit 3
            using PR4 = Field<4, 1>;    // Pending bit 4
            using PR5 = Field<5, 1>;    // Pending bit 5
            using PR6 = Field<6, 1>;    // Pending bit 6
            using PR7 = Field<7, 1>;    // Pending bit 7
            using PR8 = Field<8, 1>;    // Pending bit 8
            using PR9 = Field<9, 1>;    // Pending bit 9
            using PR10 = Field<10, 1>;    // Pending bit 10
            using PR11 = Field<11, 1>;    // Pending bit 11
            using PR12 = Field<12, 1>;    // Pending bit 12
            using PR13 = Field<13, 1>;    // Pending bit 13
            using PR14 = Field<14, 1>;    // Pending bit 14
            using PR15 = Field<15, 1>;    // Pending bit 15
            using PR16 = Field<16, 1>;    // Pending bit 16
            using PR18 = Field<18, 1>;    // Pending bit 18
            using PR19 = Field<19, 1>;    // Pending bit 19
            using PR20 = Field<20, 1>;    // Pending bit 20
            using PR21 = Field<21, 1>;    // Pending bit 21
            using PR22 = Field<22, 1>;    // Pending bit 22
        };

        // Interrupt mask register
        struct IMR2 : public Register<0x40010420> {
            using MR32 = Field<0, 1>;    // Interrupt Mask on external/internal line 32
            using MR33 = Field<1, 1>;    // Interrupt Mask on external/internal line 33
            using MR34 = Field<2, 1>;    // Interrupt Mask on external/internal line 34
            using MR35 = Field<3, 1>;    // Interrupt Mask on external/internal line 35
            using MR36 = Field<4, 1>;    // Interrupt Mask on external/internal line 36
            using MR37 = Field<5, 1>;    // Interrupt Mask on external/internal line 37
            using MR38 = Field<6, 1>;    // Interrupt Mask on external/internal line 38
            using MR39 = Field<7, 1>;    // Interrupt Mask on external/internal line 39
        };

        // Event mask register
        struct EMR2 : public Register<0x40010424> {
            using MR32 = Field<0, 1>;    // Event mask on external/internal line 32
            using MR33 = Field<1, 1>;    // Event mask on external/internal line 33
            using MR34 = Field<2, 1>;    // Event mask on external/internal line 34
            using MR35 = Field<3, 1>;    // Event mask on external/internal line 35
            using MR36 = Field<4, 1>;    // Event mask on external/internal line 36
            using MR37 = Field<5, 1>;    // Event mask on external/internal line 37
            using MR38 = Field<6, 1>;    // Event mask on external/internal line 38
            using MR39 = Field<7, 1>;    // Event mask on external/internal line 39
        };

        // Rising Trigger selection register
        struct RTSR2 : public Register<0x40010428> {
            using RT35 = Field<3, 1>;    // Rising trigger event configuration bit of line 35
            using RT36 = Field<4, 1>;    // Rising trigger event configuration bit of line 36
            using RT37 = Field<5, 1>;    // Rising trigger event configuration bit of line 37
            using RT38 = Field<6, 1>;    // Rising trigger event configuration bit of line 38
        };

        // Falling Trigger selection register
        struct FTSR2 : public Register<0x4001042c> {
            using FT35 = Field<3, 1>;    // Falling trigger event configuration bit of line 35
            using FT36 = Field<4, 1>;    // Falling trigger event configuration bit of line 36
            using FT37 = Field<5, 1>;    // Falling trigger event configuration bit of line 37
            using FT38 = Field<6, 1>;    // Falling trigger event configuration bit of line 38
        };

        // Software interrupt event register
        struct SWIER2 : public Register<0x40010430> {
            using SWI35 = Field<3, 1>;    // Software interrupt on line 35
            using SWI36 = Field<4, 1>;    // Software interrupt on line 36
            using SWI37 = Field<5, 1>;    // Software interrupt on line 37
            using SWI38 = Field<6, 1>;    // Software interrupt on line 38
        };

        // Pending register
        struct PR2 : public Register<0x40010434> {
            using PIF35 = Field<3, 1>;    // Pending interrupt flag on line 35
            using PIF36 = Field<4, 1>;    // Pending interrupt flag on line 36
            using PIF37 = Field<5, 1>;    // Pending interrupt flag on line 37
            using PIF38 = Field<6, 1>;    // Pending interrupt flag on line 38
        };

    };

    // Voltage reference buffer
    struct VREFBUF {
        // VREF control and status register
        struct CSR : public Register<0x40010030> {
            using ENVR = Field<0, 1>;    // Voltage reference buffer enable
            using HIZ = Field<1, 1>;    // High impedance mode
            using VRS = Field<2, 1>;    // Voltage reference scale
            using VRR = Field<3, 1>;    // Voltage reference buffer ready
        };

        // calibration control register
        struct CCR : public Register<0x40010034> {
            using TRIM = Field<0, 6>;    // Trimming code
        };

    };

    // Controller area network
    struct CAN1 {
        // master control register
        struct MCR : public Register<0x40006400> {
            using DBF = Field<16, 1>;    // DBF
            using RESET = Field<15, 1>;    // RESET
            using TTCM = Field<7, 1>;    // TTCM
            using ABOM = Field<6, 1>;    // ABOM
            using AWUM = Field<5, 1>;    // AWUM
            using NART = Field<4, 1>;    // NART
            using RFLM = Field<3, 1>;    // RFLM
            using TXFP = Field<2, 1>;    // TXFP
            using SLEEP = Field<1, 1>;    // SLEEP
            using INRQ = Field<0, 1>;    // INRQ
        };

        // master status register
        struct MSR : public Register<0x40006404> {
            using RX = Field<11, 1>;    // RX
            using SAMP = Field<10, 1>;    // SAMP
            using RXM = Field<9, 1>;    // RXM
            using TXM = Field<8, 1>;    // TXM
            using SLAKI = Field<4, 1>;    // SLAKI
            using WKUI = Field<3, 1>;    // WKUI
            using ERRI = Field<2, 1>;    // ERRI
            using SLAK = Field<1, 1>;    // SLAK
            using INAK = Field<0, 1>;    // INAK
        };

        // transmit status register
        struct TSR : public Register<0x40006408> {
            using LOW2 = Field<31, 1>;    // Lowest priority flag for mailbox 2
            using LOW1 = Field<30, 1>;    // Lowest priority flag for mailbox 1
            using LOW0 = Field<29, 1>;    // Lowest priority flag for mailbox 0
            using TME2 = Field<28, 1>;    // Lowest priority flag for mailbox 2
            using TME1 = Field<27, 1>;    // Lowest priority flag for mailbox 1
            using TME0 = Field<26, 1>;    // Lowest priority flag for mailbox 0
            using CODE = Field<24, 2>;    // CODE
            using ABRQ2 = Field<23, 1>;    // ABRQ2
            using TERR2 = Field<19, 1>;    // TERR2
            using ALST2 = Field<18, 1>;    // ALST2
            using TXOK2 = Field<17, 1>;    // TXOK2
            using RQCP2 = Field<16, 1>;    // RQCP2
            using ABRQ1 = Field<15, 1>;    // ABRQ1
            using TERR1 = Field<11, 1>;    // TERR1
            using ALST1 = Field<10, 1>;    // ALST1
            using TXOK1 = Field<9, 1>;    // TXOK1
            using RQCP1 = Field<8, 1>;    // RQCP1
            using ABRQ0 = Field<7, 1>;    // ABRQ0
            using TERR0 = Field<3, 1>;    // TERR0
            using ALST0 = Field<2, 1>;    // ALST0
            using TXOK0 = Field<1, 1>;    // TXOK0
            using RQCP0 = Field<0, 1>;    // RQCP0
        };

        // receive FIFO 0 register
        struct RF0R : public Register<0x4000640c> {
            using RFOM0 = Field<5, 1>;    // RFOM0
            using FOVR0 = Field<4, 1>;    // FOVR0
            using FULL0 = Field<3, 1>;    // FULL0
            using FMP0 = Field<0, 2>;    // FMP0
        };

        // receive FIFO 1 register
        struct RF1R : public Register<0x40006410> {
            using RFOM1 = Field<5, 1>;    // RFOM1
            using FOVR1 = Field<4, 1>;    // FOVR1
            using FULL1 = Field<3, 1>;    // FULL1
            using FMP1 = Field<0, 2>;    // FMP1
        };

        // interrupt enable register
        struct IER : public Register<0x40006414> {
            using SLKIE = Field<17, 1>;    // SLKIE
            using WKUIE = Field<16, 1>;    // WKUIE
            using ERRIE = Field<15, 1>;    // ERRIE
            using LECIE = Field<11, 1>;    // LECIE
            using BOFIE = Field<10, 1>;    // BOFIE
            using EPVIE = Field<9, 1>;    // EPVIE
            using EWGIE = Field<8, 1>;    // EWGIE
            using FOVIE1 = Field<6, 1>;    // FOVIE1
            using FFIE1 = Field<5, 1>;    // FFIE1
            using FMPIE1 = Field<4, 1>;    // FMPIE1
            using FOVIE0 = Field<3, 1>;    // FOVIE0
            using FFIE0 = Field<2, 1>;    // FFIE0
            using FMPIE0 = Field<1, 1>;    // FMPIE0
            using TMEIE = Field<0, 1>;    // TMEIE
        };

        // interrupt enable register
        struct ESR : public Register<0x40006418> {
            using REC = Field<24, 8>;    // REC
            using TEC = Field<16, 8>;    // TEC
            using LEC = Field<4, 3>;    // LEC
            using BOFF = Field<2, 1>;    // BOFF
            using EPVF = Field<1, 1>;    // EPVF
            using EWGF = Field<0, 1>;    // EWGF
        };

        // bit timing register
        struct BTR : public Register<0x4000641c> {
            using SILM = Field<31, 1>;    // SILM
            using LBKM = Field<30, 1>;    // LBKM
            using SJW = Field<24, 2>;    // SJW
            using TS2 = Field<20, 3>;    // TS2
            using TS1 = Field<16, 4>;    // TS1
            using BRP = Field<0, 10>;    // BRP
        };

        // TX mailbox identifier register
        struct TI0R : public Register<0x40006580> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
            using TXRQ = Field<0, 1>;    // TXRQ
        };

        // mailbox data length control and time stamp register
        struct TDT0R : public Register<0x40006584> {
            using TIME = Field<16, 16>;    // TIME
            using TGT = Field<8, 1>;    // TGT
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data low register
        struct TDL0R : public Register<0x40006588> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct TDH0R : public Register<0x4000658c> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // mailbox identifier register
        struct TI1R : public Register<0x40006590> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
            using TXRQ = Field<0, 1>;    // TXRQ
        };

        // mailbox data length control and time stamp register
        struct TDT1R : public Register<0x40006594> {
            using TIME = Field<16, 16>;    // TIME
            using TGT = Field<8, 1>;    // TGT
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data low register
        struct TDL1R : public Register<0x40006598> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct TDH1R : public Register<0x4000659c> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // mailbox identifier register
        struct TI2R : public Register<0x400065a0> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
            using TXRQ = Field<0, 1>;    // TXRQ
        };

        // mailbox data length control and time stamp register
        struct TDT2R : public Register<0x400065a4> {
            using TIME = Field<16, 16>;    // TIME
            using TGT = Field<8, 1>;    // TGT
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data low register
        struct TDL2R : public Register<0x400065a8> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct TDH2R : public Register<0x400065ac> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // receive FIFO mailbox identifier register
        struct RI0R : public Register<0x400065b0> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
        };

        // mailbox data high register
        struct RDT0R : public Register<0x400065b4> {
            using TIME = Field<16, 16>;    // TIME
            using FMI = Field<8, 8>;    // FMI
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data high register
        struct RDL0R : public Register<0x400065b8> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // receive FIFO mailbox data high register
        struct RDH0R : public Register<0x400065bc> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // mailbox data high register
        struct RI1R : public Register<0x400065c0> {
            using STID = Field<21, 11>;    // STID
            using EXID = Field<3, 18>;    // EXID
            using IDE = Field<2, 1>;    // IDE
            using RTR = Field<1, 1>;    // RTR
        };

        // mailbox data high register
        struct RDT1R : public Register<0x400065c4> {
            using TIME = Field<16, 16>;    // TIME
            using FMI = Field<8, 8>;    // FMI
            using DLC = Field<0, 4>;    // DLC
        };

        // mailbox data high register
        struct RDL1R : public Register<0x400065c8> {
            using DATA3 = Field<24, 8>;    // DATA3
            using DATA2 = Field<16, 8>;    // DATA2
            using DATA1 = Field<8, 8>;    // DATA1
            using DATA0 = Field<0, 8>;    // DATA0
        };

        // mailbox data high register
        struct RDH1R : public Register<0x400065cc> {
            using DATA7 = Field<24, 8>;    // DATA7
            using DATA6 = Field<16, 8>;    // DATA6
            using DATA5 = Field<8, 8>;    // DATA5
            using DATA4 = Field<0, 8>;    // DATA4
        };

        // filter master register
        struct FMR : public Register<0x40006600> {
            using FINIT = Field<0, 1>;    // Filter initialization mode
            using CANSB = Field<8, 6>;    // CAN start bank
        };

        // filter mode register
        struct FM1R : public Register<0x40006604> {
            using FBM0 = Field<0, 1>;    // Filter mode
            using FBM1 = Field<1, 1>;    // Filter mode
            using FBM2 = Field<2, 1>;    // Filter mode
            using FBM3 = Field<3, 1>;    // Filter mode
            using FBM4 = Field<4, 1>;    // Filter mode
            using FBM5 = Field<5, 1>;    // Filter mode
            using FBM6 = Field<6, 1>;    // Filter mode
            using FBM7 = Field<7, 1>;    // Filter mode
            using FBM8 = Field<8, 1>;    // Filter mode
            using FBM9 = Field<9, 1>;    // Filter mode
            using FBM10 = Field<10, 1>;    // Filter mode
            using FBM11 = Field<11, 1>;    // Filter mode
            using FBM12 = Field<12, 1>;    // Filter mode
            using FBM13 = Field<13, 1>;    // Filter mode
            using FBM14 = Field<14, 1>;    // Filter mode
            using FBM15 = Field<15, 1>;    // Filter mode
            using FBM16 = Field<16, 1>;    // Filter mode
            using FBM17 = Field<17, 1>;    // Filter mode
            using FBM18 = Field<18, 1>;    // Filter mode
            using FBM19 = Field<19, 1>;    // Filter mode
            using FBM20 = Field<20, 1>;    // Filter mode
            using FBM21 = Field<21, 1>;    // Filter mode
            using FBM22 = Field<22, 1>;    // Filter mode
            using FBM23 = Field<23, 1>;    // Filter mode
            using FBM24 = Field<24, 1>;    // Filter mode
            using FBM25 = Field<25, 1>;    // Filter mode
            using FBM26 = Field<26, 1>;    // Filter mode
            using FBM27 = Field<27, 1>;    // Filter mode
        };

        // filter scale register
        struct FS1R : public Register<0x4000660c> {
            using FSC0 = Field<0, 1>;    // Filter scale configuration
            using FSC1 = Field<1, 1>;    // Filter scale configuration
            using FSC2 = Field<2, 1>;    // Filter scale configuration
            using FSC3 = Field<3, 1>;    // Filter scale configuration
            using FSC4 = Field<4, 1>;    // Filter scale configuration
            using FSC5 = Field<5, 1>;    // Filter scale configuration
            using FSC6 = Field<6, 1>;    // Filter scale configuration
            using FSC7 = Field<7, 1>;    // Filter scale configuration
            using FSC8 = Field<8, 1>;    // Filter scale configuration
            using FSC9 = Field<9, 1>;    // Filter scale configuration
            using FSC10 = Field<10, 1>;    // Filter scale configuration
            using FSC11 = Field<11, 1>;    // Filter scale configuration
            using FSC12 = Field<12, 1>;    // Filter scale configuration
            using FSC13 = Field<13, 1>;    // Filter scale configuration
            using FSC14 = Field<14, 1>;    // Filter scale configuration
            using FSC15 = Field<15, 1>;    // Filter scale configuration
            using FSC16 = Field<16, 1>;    // Filter scale configuration
            using FSC17 = Field<17, 1>;    // Filter scale configuration
            using FSC18 = Field<18, 1>;    // Filter scale configuration
            using FSC19 = Field<19, 1>;    // Filter scale configuration
            using FSC20 = Field<20, 1>;    // Filter scale configuration
            using FSC21 = Field<21, 1>;    // Filter scale configuration
            using FSC22 = Field<22, 1>;    // Filter scale configuration
            using FSC23 = Field<23, 1>;    // Filter scale configuration
            using FSC24 = Field<24, 1>;    // Filter scale configuration
            using FSC25 = Field<25, 1>;    // Filter scale configuration
            using FSC26 = Field<26, 1>;    // Filter scale configuration
            using FSC27 = Field<27, 1>;    // Filter scale configuration
        };

        // filter FIFO assignment register
        struct FFA1R : public Register<0x40006614> {
            using FFA0 = Field<0, 1>;    // Filter FIFO assignment for filter 0
            using FFA1 = Field<1, 1>;    // Filter FIFO assignment for filter 1
            using FFA2 = Field<2, 1>;    // Filter FIFO assignment for filter 2
            using FFA3 = Field<3, 1>;    // Filter FIFO assignment for filter 3
            using FFA4 = Field<4, 1>;    // Filter FIFO assignment for filter 4
            using FFA5 = Field<5, 1>;    // Filter FIFO assignment for filter 5
            using FFA6 = Field<6, 1>;    // Filter FIFO assignment for filter 6
            using FFA7 = Field<7, 1>;    // Filter FIFO assignment for filter 7
            using FFA8 = Field<8, 1>;    // Filter FIFO assignment for filter 8
            using FFA9 = Field<9, 1>;    // Filter FIFO assignment for filter 9
            using FFA10 = Field<10, 1>;    // Filter FIFO assignment for filter 10
            using FFA11 = Field<11, 1>;    // Filter FIFO assignment for filter 11
            using FFA12 = Field<12, 1>;    // Filter FIFO assignment for filter 12
            using FFA13 = Field<13, 1>;    // Filter FIFO assignment for filter 13
            using FFA14 = Field<14, 1>;    // Filter FIFO assignment for filter
            using FFA15 = Field<15, 1>;    // Filter FIFO assignment for filter
            using FFA16 = Field<16, 1>;    // Filter FIFO assignment for filter
            using FFA17 = Field<17, 1>;    // Filter FIFO assignment for filter
            using FFA18 = Field<18, 1>;    // Filter FIFO assignment for filter
            using FFA19 = Field<19, 1>;    // Filter FIFO assignment for filter
            using FFA20 = Field<20, 1>;    // Filter FIFO assignment for filter
            using FFA21 = Field<21, 1>;    // Filter FIFO assignment for filter
            using FFA22 = Field<22, 1>;    // Filter FIFO assignment for filter
            using FFA23 = Field<23, 1>;    // Filter FIFO assignment for filter
            using FFA24 = Field<24, 1>;    // Filter FIFO assignment for filter
            using FFA25 = Field<25, 1>;    // Filter FIFO assignment for filter
            using FFA26 = Field<26, 1>;    // Filter FIFO assignment for filter
            using FFA27 = Field<27, 1>;    // Filter FIFO assignment for filter
        };

        // filter activation register
        struct FA1R : public Register<0x4000661c> {
            using FACT0 = Field<0, 1>;    // Filter active
            using FACT1 = Field<1, 1>;    // Filter active
            using FACT2 = Field<2, 1>;    // Filter active
            using FACT3 = Field<3, 1>;    // Filter active
            using FACT4 = Field<4, 1>;    // Filter active
            using FACT5 = Field<5, 1>;    // Filter active
            using FACT6 = Field<6, 1>;    // Filter active
            using FACT7 = Field<7, 1>;    // Filter active
            using FACT8 = Field<8, 1>;    // Filter active
            using FACT9 = Field<9, 1>;    // Filter active
            using FACT10 = Field<10, 1>;    // Filter active
            using FACT11 = Field<11, 1>;    // Filter active
            using FACT12 = Field<12, 1>;    // Filter active
            using FACT13 = Field<13, 1>;    // Filter active
            using FACT14 = Field<14, 1>;    // Filter active
            using FACT15 = Field<15, 1>;    // Filter active
            using FACT16 = Field<16, 1>;    // Filter active
            using FACT17 = Field<17, 1>;    // Filter active
            using FACT18 = Field<18, 1>;    // Filter active
            using FACT19 = Field<19, 1>;    // Filter active
            using FACT20 = Field<20, 1>;    // Filter active
            using FACT21 = Field<21, 1>;    // Filter active
            using FACT22 = Field<22, 1>;    // Filter active
            using FACT23 = Field<23, 1>;    // Filter active
            using FACT24 = Field<24, 1>;    // Filter active
            using FACT25 = Field<25, 1>;    // Filter active
            using FACT26 = Field<26, 1>;    // Filter active
            using FACT27 = Field<27, 1>;    // Filter active
        };

        // Filter bank 0 register 1
        struct F0R1 : public Register<0x40006640> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 0 register 2
        struct F0R2 : public Register<0x40006644> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 1 register 1
        struct F1R1 : public Register<0x40006648> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 1 register 2
        struct F1R2 : public Register<0x4000664c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 2 register 1
        struct F2R1 : public Register<0x40006650> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 2 register 2
        struct F2R2 : public Register<0x40006654> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 3 register 1
        struct F3R1 : public Register<0x40006658> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 3 register 2
        struct F3R2 : public Register<0x4000665c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 4 register 1
        struct F4R1 : public Register<0x40006660> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 4 register 2
        struct F4R2 : public Register<0x40006664> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 5 register 1
        struct F5R1 : public Register<0x40006668> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 5 register 2
        struct F5R2 : public Register<0x4000666c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 6 register 1
        struct F6R1 : public Register<0x40006670> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 6 register 2
        struct F6R2 : public Register<0x40006674> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 7 register 1
        struct F7R1 : public Register<0x40006678> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 7 register 2
        struct F7R2 : public Register<0x4000667c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 8 register 1
        struct F8R1 : public Register<0x40006680> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 8 register 2
        struct F8R2 : public Register<0x40006684> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 9 register 1
        struct F9R1 : public Register<0x40006688> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 9 register 2
        struct F9R2 : public Register<0x4000668c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 10 register 1
        struct F10R1 : public Register<0x40006690> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 10 register 2
        struct F10R2 : public Register<0x40006694> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 11 register 1
        struct F11R1 : public Register<0x40006698> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 11 register 2
        struct F11R2 : public Register<0x4000669c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 4 register 1
        struct F12R1 : public Register<0x400066a0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 12 register 2
        struct F12R2 : public Register<0x400066a4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 13 register 1
        struct F13R1 : public Register<0x400066a8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 13 register 2
        struct F13R2 : public Register<0x400066ac> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 14 register 1
        struct F14R1 : public Register<0x400066b0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 14 register 2
        struct F14R2 : public Register<0x400066b4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 15 register 1
        struct F15R1 : public Register<0x400066b8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 15 register 2
        struct F15R2 : public Register<0x400066bc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 16 register 1
        struct F16R1 : public Register<0x400066c0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 16 register 2
        struct F16R2 : public Register<0x400066c4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 17 register 1
        struct F17R1 : public Register<0x400066c8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 17 register 2
        struct F17R2 : public Register<0x400066cc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 18 register 1
        struct F18R1 : public Register<0x400066d0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 18 register 2
        struct F18R2 : public Register<0x400066d4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 19 register 1
        struct F19R1 : public Register<0x400066d8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 19 register 2
        struct F19R2 : public Register<0x400066dc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 20 register 1
        struct F20R1 : public Register<0x400066e0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 20 register 2
        struct F20R2 : public Register<0x400066e4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 21 register 1
        struct F21R1 : public Register<0x400066e8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 21 register 2
        struct F21R2 : public Register<0x400066ec> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 22 register 1
        struct F22R1 : public Register<0x400066f0> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 22 register 2
        struct F22R2 : public Register<0x400066f4> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 23 register 1
        struct F23R1 : public Register<0x400066f8> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 23 register 2
        struct F23R2 : public Register<0x400066fc> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 24 register 1
        struct F24R1 : public Register<0x40006700> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 24 register 2
        struct F24R2 : public Register<0x40006704> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 25 register 1
        struct F25R1 : public Register<0x40006708> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 25 register 2
        struct F25R2 : public Register<0x4000670c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 26 register 1
        struct F26R1 : public Register<0x40006710> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 26 register 2
        struct F26R2 : public Register<0x40006714> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 27 register 1
        struct F27R1 : public Register<0x40006718> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

        // Filter bank 27 register 2
        struct F27R2 : public Register<0x4000671c> {
            using FB0 = Field<0, 1>;    // Filter bits
            using FB1 = Field<1, 1>;    // Filter bits
            using FB2 = Field<2, 1>;    // Filter bits
            using FB3 = Field<3, 1>;    // Filter bits
            using FB4 = Field<4, 1>;    // Filter bits
            using FB5 = Field<5, 1>;    // Filter bits
            using FB6 = Field<6, 1>;    // Filter bits
            using FB7 = Field<7, 1>;    // Filter bits
            using FB8 = Field<8, 1>;    // Filter bits
            using FB9 = Field<9, 1>;    // Filter bits
            using FB10 = Field<10, 1>;    // Filter bits
            using FB11 = Field<11, 1>;    // Filter bits
            using FB12 = Field<12, 1>;    // Filter bits
            using FB13 = Field<13, 1>;    // Filter bits
            using FB14 = Field<14, 1>;    // Filter bits
            using FB15 = Field<15, 1>;    // Filter bits
            using FB16 = Field<16, 1>;    // Filter bits
            using FB17 = Field<17, 1>;    // Filter bits
            using FB18 = Field<18, 1>;    // Filter bits
            using FB19 = Field<19, 1>;    // Filter bits
            using FB20 = Field<20, 1>;    // Filter bits
            using FB21 = Field<21, 1>;    // Filter bits
            using FB22 = Field<22, 1>;    // Filter bits
            using FB23 = Field<23, 1>;    // Filter bits
            using FB24 = Field<24, 1>;    // Filter bits
            using FB25 = Field<25, 1>;    // Filter bits
            using FB26 = Field<26, 1>;    // Filter bits
            using FB27 = Field<27, 1>;    // Filter bits
            using FB28 = Field<28, 1>;    // Filter bits
            using FB29 = Field<29, 1>;    // Filter bits
            using FB30 = Field<30, 1>;    // Filter bits
            using FB31 = Field<31, 1>;    // Filter bits
        };

    };

    // Real-time clock
    struct RTC {
        // time register
        struct TR : public Register<0x40002800> {
            using PM = Field<22, 1>;    // AM/PM notation
            using HT = Field<20, 2>;    // Hour tens in BCD format
            using HU = Field<16, 4>;    // Hour units in BCD format
            using MNT = Field<12, 3>;    // Minute tens in BCD format
            using MNU = Field<8, 4>;    // Minute units in BCD format
            using ST = Field<4, 3>;    // Second tens in BCD format
            using SU = Field<0, 4>;    // Second units in BCD format
        };

        // date register
        struct DR : public Register<0x40002804> {
            using YT = Field<20, 4>;    // Year tens in BCD format
            using YU = Field<16, 4>;    // Year units in BCD format
            using WDU = Field<13, 3>;    // Week day units
            using MT = Field<12, 1>;    // Month tens in BCD format
            using MU = Field<8, 4>;    // Month units in BCD format
            using DT = Field<4, 2>;    // Date tens in BCD format
            using DU = Field<0, 4>;    // Date units in BCD format
        };

        // control register
        struct CR : public Register<0x40002808> {
            using WCKSEL = Field<0, 3>;    // Wakeup clock selection
            using TSEDGE = Field<3, 1>;    // Time-stamp event active edge
            using REFCKON = Field<4, 1>;    // Reference clock detection enable (50 or 60 Hz)
            using BYPSHAD = Field<5, 1>;    // Bypass the shadow registers
            using FMT = Field<6, 1>;    // Hour format
            using ALRAE = Field<8, 1>;    // Alarm A enable
            using ALRBE = Field<9, 1>;    // Alarm B enable
            using WUTE = Field<10, 1>;    // Wakeup timer enable
            using TSE = Field<11, 1>;    // Time stamp enable
            using ALRAIE = Field<12, 1>;    // Alarm A interrupt enable
            using ALRBIE = Field<13, 1>;    // Alarm B interrupt enable
            using WUTIE = Field<14, 1>;    // Wakeup timer interrupt enable
            using TSIE = Field<15, 1>;    // Time-stamp interrupt enable
            using ADD1H = Field<16, 1>;    // Add 1 hour (summer time change)
            using SUB1H = Field<17, 1>;    // Subtract 1 hour (winter time change)
            using BKP = Field<18, 1>;    // Backup
            using COSEL = Field<19, 1>;    // Calibration output selection
            using POL = Field<20, 1>;    // Output polarity
            using OSEL = Field<21, 2>;    // Output selection
            using COE = Field<23, 1>;    // Calibration output enable
            using ITSE = Field<24, 1>;    // timestamp on internal event enable
        };

        // initialization and status register
        struct ISR : public Register<0x4000280c> {
            using ALRAWF = Field<0, 1>;    // Alarm A write flag
            using ALRBWF = Field<1, 1>;    // Alarm B write flag
            using WUTWF = Field<2, 1>;    // Wakeup timer write flag
            using SHPF = Field<3, 1>;    // Shift operation pending
            using INITS = Field<4, 1>;    // Initialization status flag
            using RSF = Field<5, 1>;    // Registers synchronization flag
            using INITF = Field<6, 1>;    // Initialization flag
            using INIT = Field<7, 1>;    // Initialization mode
            using ALRAF = Field<8, 1>;    // Alarm A flag
            using ALRBF = Field<9, 1>;    // Alarm B flag
            using WUTF = Field<10, 1>;    // Wakeup timer flag
            using TSF = Field<11, 1>;    // Time-stamp flag
            using TSOVF = Field<12, 1>;    // Time-stamp overflow flag
            using TAMP1F = Field<13, 1>;    // Tamper detection flag
            using TAMP2F = Field<14, 1>;    // RTC_TAMP2 detection flag
            using TAMP3F = Field<15, 1>;    // RTC_TAMP3 detection flag
            using RECALPF = Field<16, 1>;    // Recalibration pending Flag
        };

        // prescaler register
        struct PRER : public Register<0x40002810> {
            using PREDIV_A = Field<16, 7>;    // Asynchronous prescaler factor
            using PREDIV_S = Field<0, 15>;    // Synchronous prescaler factor
        };

        // wakeup timer register
        struct WUTR : public Register<0x40002814> {
            using WUT = Field<0, 16>;    // Wakeup auto-reload value bits
        };

        // alarm A register
        struct ALRMAR : public Register<0x4000281c> {
            using MSK4 = Field<31, 1>;    // Alarm A date mask
            using WDSEL = Field<30, 1>;    // Week day selection
            using DT = Field<28, 2>;    // Date tens in BCD format
            using DU = Field<24, 4>;    // Date units or day in BCD format
            using MSK3 = Field<23, 1>;    // Alarm A hours mask
            using PM = Field<22, 1>;    // AM/PM notation
            using HT = Field<20, 2>;    // Hour tens in BCD format
            using HU = Field<16, 4>;    // Hour units in BCD format
            using MSK2 = Field<15, 1>;    // Alarm A minutes mask
            using MNT = Field<12, 3>;    // Minute tens in BCD format
            using MNU = Field<8, 4>;    // Minute units in BCD format
            using MSK1 = Field<7, 1>;    // Alarm A seconds mask
            using ST = Field<4, 3>;    // Second tens in BCD format
            using SU = Field<0, 4>;    // Second units in BCD format
        };

        // alarm B register
        struct ALRMBR : public Register<0x40002820> {
            using MSK4 = Field<31, 1>;    // Alarm B date mask
            using WDSEL = Field<30, 1>;    // Week day selection
            using DT = Field<28, 2>;    // Date tens in BCD format
            using DU = Field<24, 4>;    // Date units or day in BCD format
            using MSK3 = Field<23, 1>;    // Alarm B hours mask
            using PM = Field<22, 1>;    // AM/PM notation
            using HT = Field<20, 2>;    // Hour tens in BCD format
            using HU = Field<16, 4>;    // Hour units in BCD format
            using MSK2 = Field<15, 1>;    // Alarm B minutes mask
            using MNT = Field<12, 3>;    // Minute tens in BCD format
            using MNU = Field<8, 4>;    // Minute units in BCD format
            using MSK1 = Field<7, 1>;    // Alarm B seconds mask
            using ST = Field<4, 3>;    // Second tens in BCD format
            using SU = Field<0, 4>;    // Second units in BCD format
        };

        // write protection register
        struct WPR : public Register<0x40002824> {
            using KEY = Field<0, 8>;    // Write protection key
        };

        // sub second register
        struct SSR : public Register<0x40002828> {
            using SS = Field<0, 16>;    // Sub second value
        };

        // shift control register
        struct SHIFTR : public Register<0x4000282c> {
            using ADD1S = Field<31, 1>;    // Add one second
            using SUBFS = Field<0, 15>;    // Subtract a fraction of a second
        };

        // time stamp time register
        struct TSTR : public Register<0x40002830> {
            using SU = Field<0, 4>;    // Second units in BCD format
            using ST = Field<4, 3>;    // Second tens in BCD format
            using MNU = Field<8, 4>;    // Minute units in BCD format
            using MNT = Field<12, 3>;    // Minute tens in BCD format
            using HU = Field<16, 4>;    // Hour units in BCD format
            using HT = Field<20, 2>;    // Hour tens in BCD format
            using PM = Field<22, 1>;    // AM/PM notation
        };

        // time stamp date register
        struct TSDR : public Register<0x40002834> {
            using WDU = Field<13, 3>;    // Week day units
            using MT = Field<12, 1>;    // Month tens in BCD format
            using MU = Field<8, 4>;    // Month units in BCD format
            using DT = Field<4, 2>;    // Date tens in BCD format
            using DU = Field<0, 4>;    // Date units in BCD format
        };

        // timestamp sub second register
        struct TSSSR : public Register<0x40002838> {
            using SS = Field<0, 16>;    // Sub second value
        };

        // calibration register
        struct CALR : public Register<0x4000283c> {
            using CALP = Field<15, 1>;    // Increase frequency of RTC by 488.5 ppm
            using CALW8 = Field<14, 1>;    // Use an 8-second calibration cycle period
            using CALW16 = Field<13, 1>;    // Use a 16-second calibration cycle period
            using CALM = Field<0, 9>;    // Calibration minus
        };

        // tamper configuration register
        struct TAMPCR : public Register<0x40002840> {
            using TAMP1E = Field<0, 1>;    // Tamper 1 detection enable
            using TAMP1TRG = Field<1, 1>;    // Active level for tamper 1
            using TAMPIE = Field<2, 1>;    // Tamper interrupt enable
            using TAMP2E = Field<3, 1>;    // Tamper 2 detection enable
            using TAMP2TRG = Field<4, 1>;    // Active level for tamper 2
            using TAMP3E = Field<5, 1>;    // Tamper 3 detection enable
            using TAMP3TRG = Field<6, 1>;    // Active level for tamper 3
            using TAMPTS = Field<7, 1>;    // Activate timestamp on tamper detection event
            using TAMPFREQ = Field<8, 3>;    // Tamper sampling frequency
            using TAMPFLT = Field<11, 2>;    // Tamper filter count
            using TAMPPRCH = Field<13, 2>;    // Tamper precharge duration
            using TAMPPUDIS = Field<15, 1>;    // TAMPER pull-up disable
            using TAMP1IE = Field<16, 1>;    // Tamper 1 interrupt enable
            using TAMP1NOERASE = Field<17, 1>;    // Tamper 1 no erase
            using TAMP1MF = Field<18, 1>;    // Tamper 1 mask flag
            using TAMP2IE = Field<19, 1>;    // Tamper 2 interrupt enable
            using TAMP2NOERASE = Field<20, 1>;    // Tamper 2 no erase
            using TAMP2MF = Field<21, 1>;    // Tamper 2 mask flag
            using TAMP3IE = Field<22, 1>;    // Tamper 3 interrupt enable
            using TAMP3NOERASE = Field<23, 1>;    // Tamper 3 no erase
            using TAMP3MF = Field<24, 1>;    // Tamper 3 mask flag
        };

        // alarm A sub second register
        struct ALRMASSR : public Register<0x40002844> {
            using MASKSS = Field<24, 4>;    // Mask the most-significant bits starting at this bit
            using SS = Field<0, 15>;    // Sub seconds value
        };

        // alarm B sub second register
        struct ALRMBSSR : public Register<0x40002848> {
            using MASKSS = Field<24, 4>;    // Mask the most-significant bits starting at this bit
            using SS = Field<0, 15>;    // Sub seconds value
        };

        // option register
        struct OR : public Register<0x4000284c> {
            using RTC_ALARM_TYPE = Field<0, 1>;    // RTC_ALARM on PC13 output type
            using RTC_OUT_RMP = Field<1, 1>;    // RTC_OUT remap
        };

        // backup register
        struct BKP0R : public Register<0x40002850> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP1R : public Register<0x40002854> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP2R : public Register<0x40002858> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP3R : public Register<0x4000285c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP4R : public Register<0x40002860> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP5R : public Register<0x40002864> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP6R : public Register<0x40002868> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP7R : public Register<0x4000286c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP8R : public Register<0x40002870> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP9R : public Register<0x40002874> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP10R : public Register<0x40002878> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP11R : public Register<0x4000287c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP12R : public Register<0x40002880> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP13R : public Register<0x40002884> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP14R : public Register<0x40002888> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP15R : public Register<0x4000288c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP16R : public Register<0x40002890> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP17R : public Register<0x40002894> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP18R : public Register<0x40002898> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP19R : public Register<0x4000289c> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP20R : public Register<0x400028a0> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP21R : public Register<0x400028a4> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP22R : public Register<0x400028a8> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP23R : public Register<0x400028ac> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP24R : public Register<0x400028b0> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP25R : public Register<0x400028b4> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP26R : public Register<0x400028b8> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP27R : public Register<0x400028bc> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP28R : public Register<0x400028c0> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP29R : public Register<0x400028c4> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP30R : public Register<0x400028c8> {
            using BKP = Field<0, 32>;    // BKP
        };

        // backup register
        struct BKP31R : public Register<0x400028cc> {
            using BKP = Field<0, 32>;    // BKP
        };

    };

    // USB on the go full speed
    struct OTG_FS_GLOBAL {
        // OTG_FS control and status register (OTG_FS_GOTGCTL)
        struct FS_GOTGCTL : public Register<0x50000000> {
            using SRQSCS = Field<0, 1>;    // Session request success
            using SRQ = Field<1, 1>;    // Session request
            using HNGSCS = Field<8, 1>;    // Host negotiation success
            using HNPRQ = Field<9, 1>;    // HNP request
            using HSHNPEN = Field<10, 1>;    // Host set HNP enable
            using DHNPEN = Field<11, 1>;    // Device HNP enabled
            using CIDSTS = Field<16, 1>;    // Connector ID status
            using DBCT = Field<17, 1>;    // Long/short debounce time
            using ASVLD = Field<18, 1>;    // A-session valid
            using BSVLD = Field<19, 1>;    // B-session valid
        };

        // OTG_FS interrupt register (OTG_FS_GOTGINT)
        struct FS_GOTGINT : public Register<0x50000004> {
            using SEDET = Field<2, 1>;    // Session end detected
            using SRSSCHG = Field<8, 1>;    // Session request success status change
            using HNSSCHG = Field<9, 1>;    // Host negotiation success status change
            using HNGDET = Field<17, 1>;    // Host negotiation detected
            using ADTOCHG = Field<18, 1>;    // A-device timeout change
            using DBCDNE = Field<19, 1>;    // Debounce done
        };

        // OTG_FS AHB configuration register (OTG_FS_GAHBCFG)
        struct FS_GAHBCFG : public Register<0x50000008> {
            using GINT = Field<0, 1>;    // Global interrupt mask
            using TXFELVL = Field<7, 1>;    // TxFIFO empty level
            using PTXFELVL = Field<8, 1>;    // Periodic TxFIFO empty level
        };

        // OTG_FS USB configuration register (OTG_FS_GUSBCFG)
        struct FS_GUSBCFG : public Register<0x5000000c> {
            using TOCAL = Field<0, 3>;    // FS timeout calibration
            using PHYSEL = Field<6, 1>;    // Full Speed serial transceiver select
            using SRPCAP = Field<8, 1>;    // SRP-capable
            using HNPCAP = Field<9, 1>;    // HNP-capable
            using TRDT = Field<10, 4>;    // USB turnaround time
            using FHMOD = Field<29, 1>;    // Force host mode
            using FDMOD = Field<30, 1>;    // Force device mode
            using CTXPKT = Field<31, 1>;    // Corrupt Tx packet
        };

        // OTG_FS reset register (OTG_FS_GRSTCTL)
        struct FS_GRSTCTL : public Register<0x50000010> {
            using CSRST = Field<0, 1>;    // Core soft reset
            using HSRST = Field<1, 1>;    // HCLK soft reset
            using FCRST = Field<2, 1>;    // Host frame counter reset
            using RXFFLSH = Field<4, 1>;    // RxFIFO flush
            using TXFFLSH = Field<5, 1>;    // TxFIFO flush
            using TXFNUM = Field<6, 5>;    // TxFIFO number
            using AHBIDL = Field<31, 1>;    // AHB master idle
        };

        // OTG_FS core interrupt register (OTG_FS_GINTSTS)
        struct FS_GINTSTS : public Register<0x50000014> {
            using CMOD = Field<0, 1>;    // Current mode of operation
            using MMIS = Field<1, 1>;    // Mode mismatch interrupt
            using OTGINT = Field<2, 1>;    // OTG interrupt
            using SOF = Field<3, 1>;    // Start of frame
            using RXFLVL = Field<4, 1>;    // RxFIFO non-empty
            using NPTXFE = Field<5, 1>;    // Non-periodic TxFIFO empty
            using GINAKEFF = Field<6, 1>;    // Global IN non-periodic NAK effective
            using GOUTNAKEFF = Field<7, 1>;    // Global OUT NAK effective
            using ESUSP = Field<10, 1>;    // Early suspend
            using USBSUSP = Field<11, 1>;    // USB suspend
            using USBRST = Field<12, 1>;    // USB reset
            using ENUMDNE = Field<13, 1>;    // Enumeration done
            using ISOODRP = Field<14, 1>;    // Isochronous OUT packet dropped interrupt
            using EOPF = Field<15, 1>;    // End of periodic frame interrupt
            using IEPINT = Field<18, 1>;    // IN endpoint interrupt
            using OEPINT = Field<19, 1>;    // OUT endpoint interrupt
            using IISOIXFR = Field<20, 1>;    // Incomplete isochronous IN transfer
            using IPXFR_INCOMPISOOUT = Field<21, 1>;    // Incomplete periodic transfer(Host mode)/Incomplete isochronous OUT transfer(Device mode)
            using HPRTINT = Field<24, 1>;    // Host port interrupt
            using HCINT = Field<25, 1>;    // Host channels interrupt
            using PTXFE = Field<26, 1>;    // Periodic TxFIFO empty
            using CIDSCHG = Field<28, 1>;    // Connector ID status change
            using DISCINT = Field<29, 1>;    // Disconnect detected interrupt
            using SRQINT = Field<30, 1>;    // Session request/new session detected interrupt
            using WKUPINT = Field<31, 1>;    // Resume/remote wakeup detected interrupt
        };

        // OTG_FS interrupt mask register (OTG_FS_GINTMSK)
        struct FS_GINTMSK : public Register<0x50000018> {
            using MMISM = Field<1, 1>;    // Mode mismatch interrupt mask
            using OTGINT = Field<2, 1>;    // OTG interrupt mask
            using SOFM = Field<3, 1>;    // Start of frame mask
            using RXFLVLM = Field<4, 1>;    // Receive FIFO non-empty mask
            using NPTXFEM = Field<5, 1>;    // Non-periodic TxFIFO empty mask
            using GINAKEFFM = Field<6, 1>;    // Global non-periodic IN NAK effective mask
            using GONAKEFFM = Field<7, 1>;    // Global OUT NAK effective mask
            using ESUSPM = Field<10, 1>;    // Early suspend mask
            using USBSUSPM = Field<11, 1>;    // USB suspend mask
            using USBRST = Field<12, 1>;    // USB reset mask
            using ENUMDNEM = Field<13, 1>;    // Enumeration done mask
            using ISOODRPM = Field<14, 1>;    // Isochronous OUT packet dropped interrupt mask
            using EOPFM = Field<15, 1>;    // End of periodic frame interrupt mask
            using EPMISM = Field<17, 1>;    // Endpoint mismatch interrupt mask
            using IEPINT = Field<18, 1>;    // IN endpoints interrupt mask
            using OEPINT = Field<19, 1>;    // OUT endpoints interrupt mask
            using IISOIXFRM = Field<20, 1>;    // Incomplete isochronous IN transfer mask
            using IPXFRM_IISOOXFRM = Field<21, 1>;    // Incomplete periodic transfer mask(Host mode)/Incomplete isochronous OUT transfer mask(Device mode)
            using PRTIM = Field<24, 1>;    // Host port interrupt mask
            using HCIM = Field<25, 1>;    // Host channels interrupt mask
            using PTXFEM = Field<26, 1>;    // Periodic TxFIFO empty mask
            using CIDSCHGM = Field<28, 1>;    // Connector ID status change mask
            using DISCINT = Field<29, 1>;    // Disconnect detected interrupt mask
            using SRQIM = Field<30, 1>;    // Session request/new session detected interrupt mask
            using WUIM = Field<31, 1>;    // Resume/remote wakeup detected interrupt mask
        };

        // OTG_FS Receive status debug read(Device mode)
        struct FS_GRXSTSR_Device : public Register<0x5000001c> {
            using EPNUM = Field<0, 4>;    // Endpoint number
            using BCNT = Field<4, 11>;    // Byte count
            using DPID = Field<15, 2>;    // Data PID
            using PKTSTS = Field<17, 4>;    // Packet status
            using FRMNUM = Field<21, 4>;    // Frame number
        };

        // OTG_FS Receive status debug read(Host mode)
        struct FS_GRXSTSR_Host : public Register<0x5000001c> {
            using EPNUM = Field<0, 4>;    // Endpoint number
            using BCNT = Field<4, 11>;    // Byte count
            using DPID = Field<15, 2>;    // Data PID
            using PKTSTS = Field<17, 4>;    // Packet status
            using FRMNUM = Field<21, 4>;    // Frame number
        };

        // OTG_FS Receive FIFO size register (OTG_FS_GRXFSIZ)
        struct FS_GRXFSIZ : public Register<0x50000024> {
            using RXFD = Field<0, 16>;    // RxFIFO depth
        };

        // OTG_FS non-periodic transmit FIFO size register (Device mode)
        struct FS_GNPTXFSIZ_Device : public Register<0x50000028> {
            using TX0FSA = Field<0, 16>;    // Endpoint 0 transmit RAM start address
            using TX0FD = Field<16, 16>;    // Endpoint 0 TxFIFO depth
        };

        // OTG_FS non-periodic transmit FIFO size register (Host mode)
        struct FS_GNPTXFSIZ_Host : public Register<0x50000028> {
            using NPTXFSA = Field<0, 16>;    // Non-periodic transmit RAM start address
            using NPTXFD = Field<16, 16>;    // Non-periodic TxFIFO depth
        };

        // OTG_FS non-periodic transmit FIFO/queue status register (OTG_FS_GNPTXSTS)
        struct FS_GNPTXSTS : public Register<0x5000002c> {
            using NPTXFSAV = Field<0, 16>;    // Non-periodic TxFIFO space available
            using NPTQXSAV = Field<16, 8>;    // Non-periodic transmit request queue space available
            using NPTXQTOP = Field<24, 7>;    // Top of the non-periodic transmit request queue
        };

        // OTG_FS general core configuration register (OTG_FS_GCCFG)
        struct FS_GCCFG : public Register<0x50000038> {
            using PWRDWN = Field<16, 1>;    // Power down
            using VBUSASEN = Field<18, 1>;    // Enable the VBUS sensing device
            using VBUSBSEN = Field<19, 1>;    // Enable the VBUS sensing device
            using SOFOUTEN = Field<20, 1>;    // SOF output enable
        };

        // core ID register
        struct FS_CID : public Register<0x5000003c> {
            using PRODUCT_ID = Field<0, 32>;    // Product ID field
        };

        // OTG_FS Host periodic transmit FIFO size register (OTG_FS_HPTXFSIZ)
        struct FS_HPTXFSIZ : public Register<0x50000100> {
            using PTXSA = Field<0, 16>;    // Host periodic TxFIFO start address
            using PTXFSIZ = Field<16, 16>;    // Host periodic TxFIFO depth
        };

        // OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF2)
        struct FS_DIEPTXF1 : public Register<0x50000104> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFO2 transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF3)
        struct FS_DIEPTXF2 : public Register<0x50000108> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFO3 transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

        // OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF4)
        struct FS_DIEPTXF3 : public Register<0x5000010c> {
            using INEPTXSA = Field<0, 16>;    // IN endpoint FIFO4 transmit RAM start address
            using INEPTXFD = Field<16, 16>;    // IN endpoint TxFIFO depth
        };

    };

    // USB on the go full speed
    struct OTG_FS_HOST {
        // OTG_FS host configuration register (OTG_FS_HCFG)
        struct FS_HCFG : public Register<0x50000400> {
            using FSLSPCS = Field<0, 2>;    // FS/LS PHY clock select
            using FSLSS = Field<2, 1>;    // FS- and LS-only support
        };

        // OTG_FS Host frame interval register
        struct HFIR : public Register<0x50000404> {
            using FRIVL = Field<0, 16>;    // Frame interval
        };

        // OTG_FS host frame number/frame time remaining register (OTG_FS_HFNUM)
        struct FS_HFNUM : public Register<0x50000408> {
            using FRNUM = Field<0, 16>;    // Frame number
            using FTREM = Field<16, 16>;    // Frame time remaining
        };

        // OTG_FS_Host periodic transmit FIFO/queue status register (OTG_FS_HPTXSTS)
        struct FS_HPTXSTS : public Register<0x50000410> {
            using PTXFSAVL = Field<0, 16>;    // Periodic transmit data FIFO space available
            using PTXQSAV = Field<16, 8>;    // Periodic transmit request queue space available
            using PTXQTOP = Field<24, 8>;    // Top of the periodic transmit request queue
        };

        // OTG_FS Host all channels interrupt register
        struct HAINT : public Register<0x50000414> {
            using Field = Field<0, 16>;    // Channel interrupts
        };

        // OTG_FS host all channels interrupt mask register
        struct HAINTMSK : public Register<0x50000418> {
            using HAINTM = Field<0, 16>;    // Channel interrupt mask
        };

        // OTG_FS host port control and status register (OTG_FS_HPRT)
        struct FS_HPRT : public Register<0x50000440> {
            using PCSTS = Field<0, 1>;    // Port connect status
            using PCDET = Field<1, 1>;    // Port connect detected
            using PENA = Field<2, 1>;    // Port enable
            using PENCHNG = Field<3, 1>;    // Port enable/disable change
            using POCA = Field<4, 1>;    // Port overcurrent active
            using POCCHNG = Field<5, 1>;    // Port overcurrent change
            using PRES = Field<6, 1>;    // Port resume
            using PSUSP = Field<7, 1>;    // Port suspend
            using PRST = Field<8, 1>;    // Port reset
            using PLSTS = Field<10, 2>;    // Port line status
            using PPWR = Field<12, 1>;    // Port power
            using PTCTL = Field<13, 4>;    // Port test control
            using PSPD = Field<17, 2>;    // Port speed
        };

        // OTG_FS host channel-0 characteristics register (OTG_FS_HCCHAR0)
        struct FS_HCCHAR0 : public Register<0x50000500> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-1 characteristics register (OTG_FS_HCCHAR1)
        struct FS_HCCHAR1 : public Register<0x50000520> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-2 characteristics register (OTG_FS_HCCHAR2)
        struct FS_HCCHAR2 : public Register<0x50000540> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-3 characteristics register (OTG_FS_HCCHAR3)
        struct FS_HCCHAR3 : public Register<0x50000560> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-4 characteristics register (OTG_FS_HCCHAR4)
        struct FS_HCCHAR4 : public Register<0x50000580> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-5 characteristics register (OTG_FS_HCCHAR5)
        struct FS_HCCHAR5 : public Register<0x500005a0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-6 characteristics register (OTG_FS_HCCHAR6)
        struct FS_HCCHAR6 : public Register<0x500005c0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-7 characteristics register (OTG_FS_HCCHAR7)
        struct FS_HCCHAR7 : public Register<0x500005e0> {
            using MPSIZ = Field<0, 11>;    // Maximum packet size
            using EPNUM = Field<11, 4>;    // Endpoint number
            using EPDIR = Field<15, 1>;    // Endpoint direction
            using LSDEV = Field<17, 1>;    // Low-speed device
            using EPTYP = Field<18, 2>;    // Endpoint type
            using MCNT = Field<20, 2>;    // Multicount
            using DAD = Field<22, 7>;    // Device address
            using ODDFRM = Field<29, 1>;    // Odd frame
            using CHDIS = Field<30, 1>;    // Channel disable
            using CHENA = Field<31, 1>;    // Channel enable
        };

        // OTG_FS host channel-0 interrupt register (OTG_FS_HCINT0)
        struct FS_HCINT0 : public Register<0x50000508> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-1 interrupt register (OTG_FS_HCINT1)
        struct FS_HCINT1 : public Register<0x50000528> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-2 interrupt register (OTG_FS_HCINT2)
        struct FS_HCINT2 : public Register<0x50000548> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-3 interrupt register (OTG_FS_HCINT3)
        struct FS_HCINT3 : public Register<0x50000568> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-4 interrupt register (OTG_FS_HCINT4)
        struct FS_HCINT4 : public Register<0x50000588> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-5 interrupt register (OTG_FS_HCINT5)
        struct FS_HCINT5 : public Register<0x500005a8> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-6 interrupt register (OTG_FS_HCINT6)
        struct FS_HCINT6 : public Register<0x500005c8> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-7 interrupt register (OTG_FS_HCINT7)
        struct FS_HCINT7 : public Register<0x500005e8> {
            using XFRC = Field<0, 1>;    // Transfer completed
            using CHH = Field<1, 1>;    // Channel halted
            using STALL = Field<3, 1>;    // STALL response received interrupt
            using NAK = Field<4, 1>;    // NAK response received interrupt
            using ACK = Field<5, 1>;    // ACK response received/transmitted interrupt
            using TXERR = Field<7, 1>;    // Transaction error
            using BBERR = Field<8, 1>;    // Babble error
            using FRMOR = Field<9, 1>;    // Frame overrun
            using DTERR = Field<10, 1>;    // Data toggle error
        };

        // OTG_FS host channel-0 mask register (OTG_FS_HCINTMSK0)
        struct FS_HCINTMSK0 : public Register<0x5000050c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-1 mask register (OTG_FS_HCINTMSK1)
        struct FS_HCINTMSK1 : public Register<0x5000052c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-2 mask register (OTG_FS_HCINTMSK2)
        struct FS_HCINTMSK2 : public Register<0x5000054c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-3 mask register (OTG_FS_HCINTMSK3)
        struct FS_HCINTMSK3 : public Register<0x5000056c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-4 mask register (OTG_FS_HCINTMSK4)
        struct FS_HCINTMSK4 : public Register<0x5000058c> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-5 mask register (OTG_FS_HCINTMSK5)
        struct FS_HCINTMSK5 : public Register<0x500005ac> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-6 mask register (OTG_FS_HCINTMSK6)
        struct FS_HCINTMSK6 : public Register<0x500005cc> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-7 mask register (OTG_FS_HCINTMSK7)
        struct FS_HCINTMSK7 : public Register<0x500005ec> {
            using XFRCM = Field<0, 1>;    // Transfer completed mask
            using CHHM = Field<1, 1>;    // Channel halted mask
            using STALLM = Field<3, 1>;    // STALL response received interrupt mask
            using NAKM = Field<4, 1>;    // NAK response received interrupt mask
            using ACKM = Field<5, 1>;    // ACK response received/transmitted interrupt mask
            using NYET = Field<6, 1>;    // response received interrupt mask
            using TXERRM = Field<7, 1>;    // Transaction error mask
            using BBERRM = Field<8, 1>;    // Babble error mask
            using FRMORM = Field<9, 1>;    // Frame overrun mask
            using DTERRM = Field<10, 1>;    // Data toggle error mask
        };

        // OTG_FS host channel-0 transfer size register
        struct FS_HCTSIZ0 : public Register<0x50000510> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-1 transfer size register
        struct FS_HCTSIZ1 : public Register<0x50000530> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-2 transfer size register
        struct FS_HCTSIZ2 : public Register<0x50000550> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-3 transfer size register
        struct FS_HCTSIZ3 : public Register<0x50000570> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-x transfer size register
        struct FS_HCTSIZ4 : public Register<0x50000590> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-5 transfer size register
        struct FS_HCTSIZ5 : public Register<0x500005b0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-6 transfer size register
        struct FS_HCTSIZ6 : public Register<0x500005d0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

        // OTG_FS host channel-7 transfer size register
        struct FS_HCTSIZ7 : public Register<0x500005f0> {
            using XFRSIZ = Field<0, 19>;    // Transfer size
            using PKTCNT = Field<19, 10>;    // Packet count
            using DPID = Field<29, 2>;    // Data PID
        };

    };

    // USB on the go full speed
    struct OTG_FS_DEVICE {
        // OTG_FS device configuration register (OTG_FS_DCFG)
        struct FS_DCFG : public Register<0x50000800> {
            using DSPD = Field<0, 2>;    // Device speed
            using NZLSOHSK = Field<2, 1>;    // Non-zero-length status OUT handshake
            using DAD = Field<4, 7>;    // Device address
            using PFIVL = Field<11, 2>;    // Periodic frame interval
        };

        // OTG_FS device control register (OTG_FS_DCTL)
        struct FS_DCTL : public Register<0x50000804> {
            using RWUSIG = Field<0, 1>;    // Remote wakeup signaling
            using SDIS = Field<1, 1>;    // Soft disconnect
            using GINSTS = Field<2, 1>;    // Global IN NAK status
            using GONSTS = Field<3, 1>;    // Global OUT NAK status
            using TCTL = Field<4, 3>;    // Test control
            using SGINAK = Field<7, 1>;    // Set global IN NAK
            using CGINAK = Field<8, 1>;    // Clear global IN NAK
            using SGONAK = Field<9, 1>;    // Set global OUT NAK
            using CGONAK = Field<10, 1>;    // Clear global OUT NAK
            using POPRGDNE = Field<11, 1>;    // Power-on programming done
        };

        // OTG_FS device status register (OTG_FS_DSTS)
        struct FS_DSTS : public Register<0x50000808> {
            using SUSPSTS = Field<0, 1>;    // Suspend status
            using ENUMSPD = Field<1, 2>;    // Enumerated speed
            using EERR = Field<3, 1>;    // Erratic error
            using FNSOF = Field<8, 14>;    // Frame number of the received SOF
        };

        // OTG_FS device IN endpoint common interrupt mask register (OTG_FS_DIEPMSK)
        struct FS_DIEPMSK : public Register<0x50000810> {
            using XFRCM = Field<0, 1>;    // Transfer completed interrupt mask
            using EPDM = Field<1, 1>;    // Endpoint disabled interrupt mask
            using TOM = Field<3, 1>;    // Timeout condition mask (Non-isochronous endpoints)
            using ITTXFEMSK = Field<4, 1>;    // IN token received when TxFIFO empty mask
            using INEPNMM = Field<5, 1>;    // IN token received with EP mismatch mask
            using INEPNEM = Field<6, 1>;    // IN endpoint NAK effective mask
        };

        // OTG_FS device OUT endpoint common interrupt mask register (OTG_FS_DOEPMSK)
        struct FS_DOEPMSK : public Register<0x50000814> {
            using XFRCM = Field<0, 1>;    // Transfer completed interrupt mask
            using EPDM = Field<1, 1>;    // Endpoint disabled interrupt mask
            using STUPM = Field<3, 1>;    // SETUP phase done mask
            using OTEPDM = Field<4, 1>;    // OUT token received when endpoint disabled mask
        };

        // OTG_FS device all endpoints interrupt register (OTG_FS_DAINT)
        struct FS_DAINT : public Register<0x50000818> {
            using IEPINT = Field<0, 16>;    // IN endpoint interrupt bits
            using OEPINT = Field<16, 16>;    // OUT endpoint interrupt bits
        };

        // OTG_FS all endpoints interrupt mask register (OTG_FS_DAINTMSK)
        struct FS_DAINTMSK : public Register<0x5000081c> {
            using IEPM = Field<0, 16>;    // IN EP interrupt mask bits
            using OEPINT = Field<16, 16>;    // OUT endpoint interrupt bits
        };

        // OTG_FS device VBUS discharge time register
        struct DVBUSDIS : public Register<0x50000828> {
            using VBUSDT = Field<0, 16>;    // Device VBUS discharge time
        };

        // OTG_FS device VBUS pulsing time register
        struct DVBUSPULSE : public Register<0x5000082c> {
            using DVBUSP = Field<0, 12>;    // Device VBUS pulsing time
        };

        // OTG_FS device IN endpoint FIFO empty interrupt mask register
        struct DIEPEMPMSK : public Register<0x50000834> {
            using INEPTXFEM = Field<0, 16>;    // IN EP Tx FIFO empty interrupt mask bits
        };

        // OTG_FS device control IN endpoint 0 control register (OTG_FS_DIEPCTL0)
        struct FS_DIEPCTL0 : public Register<0x50000900> {
            using MPSIZ = Field<0, 2>;    // Maximum packet size
            using USBAEP = Field<15, 1>;    // USB active endpoint
            using NAKSTS = Field<17, 1>;    // NAK status
            using EPTYP = Field<18, 2>;    // Endpoint type
            using STALL = Field<21, 1>;    // STALL handshake
            using TXFNUM = Field<22, 4>;    // TxFIFO number
            using CNAK = Field<26, 1>;    // Clear NAK
            using SNAK = Field<27, 1>;    // Set NAK
            using EPDIS = Field<30, 1>;    // Endpoint disable
            using EPENA = Field<31, 1>;    // Endpoint enable
        };

        // OTG device endpoint-1 control register
        struct DIEPCTL1 : public Register<0x50000920> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SODDFRM_SD1PID = Field<29, 1>;    // SODDFRM/SD1PID
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID/SEVNFRM
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using TXFNUM = Field<22, 4>;    // TXFNUM
            using Stall = Field<21, 1>;    // Stall
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EONUM_DPID = Field<16, 1>;    // EONUM/DPID
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 11>;    // MPSIZ
        };

        // OTG device endpoint-2 control register
        struct DIEPCTL2 : public Register<0x50000940> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID/SEVNFRM
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using TXFNUM = Field<22, 4>;    // TXFNUM
            using Stall = Field<21, 1>;    // Stall
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EONUM_DPID = Field<16, 1>;    // EONUM/DPID
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 11>;    // MPSIZ
        };

        // OTG device endpoint-3 control register
        struct DIEPCTL3 : public Register<0x50000960> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID/SEVNFRM
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using TXFNUM = Field<22, 4>;    // TXFNUM
            using Stall = Field<21, 1>;    // Stall
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EONUM_DPID = Field<16, 1>;    // EONUM/DPID
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 11>;    // MPSIZ
        };

        // device endpoint-0 control register
        struct DOEPCTL0 : public Register<0x50000b00> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using Stall = Field<21, 1>;    // Stall
            using SNPM = Field<20, 1>;    // SNPM
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 2>;    // MPSIZ
        };

        // device endpoint-1 control register
        struct DOEPCTL1 : public Register<0x50000b20> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID/SEVNFRM
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using Stall = Field<21, 1>;    // Stall
            using SNPM = Field<20, 1>;    // SNPM
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EONUM_DPID = Field<16, 1>;    // EONUM/DPID
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 11>;    // MPSIZ
        };

        // device endpoint-2 control register
        struct DOEPCTL2 : public Register<0x50000b40> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID/SEVNFRM
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using Stall = Field<21, 1>;    // Stall
            using SNPM = Field<20, 1>;    // SNPM
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EONUM_DPID = Field<16, 1>;    // EONUM/DPID
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 11>;    // MPSIZ
        };

        // device endpoint-3 control register
        struct DOEPCTL3 : public Register<0x50000b60> {
            using EPENA = Field<31, 1>;    // EPENA
            using EPDIS = Field<30, 1>;    // EPDIS
            using SODDFRM = Field<29, 1>;    // SODDFRM
            using SD0PID_SEVNFRM = Field<28, 1>;    // SD0PID/SEVNFRM
            using SNAK = Field<27, 1>;    // SNAK
            using CNAK = Field<26, 1>;    // CNAK
            using Stall = Field<21, 1>;    // Stall
            using SNPM = Field<20, 1>;    // SNPM
            using EPTYP = Field<18, 2>;    // EPTYP
            using NAKSTS = Field<17, 1>;    // NAKSTS
            using EONUM_DPID = Field<16, 1>;    // EONUM/DPID
            using USBAEP = Field<15, 1>;    // USBAEP
            using MPSIZ = Field<0, 11>;    // MPSIZ
        };

        // device endpoint-x interrupt register
        struct DIEPINT0 : public Register<0x50000908> {
            using TXFE = Field<7, 1>;    // TXFE
            using INEPNE = Field<6, 1>;    // INEPNE
            using ITTXFE = Field<4, 1>;    // ITTXFE
            using TOC = Field<3, 1>;    // TOC
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-1 interrupt register
        struct DIEPINT1 : public Register<0x50000928> {
            using TXFE = Field<7, 1>;    // TXFE
            using INEPNE = Field<6, 1>;    // INEPNE
            using ITTXFE = Field<4, 1>;    // ITTXFE
            using TOC = Field<3, 1>;    // TOC
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-2 interrupt register
        struct DIEPINT2 : public Register<0x50000948> {
            using TXFE = Field<7, 1>;    // TXFE
            using INEPNE = Field<6, 1>;    // INEPNE
            using ITTXFE = Field<4, 1>;    // ITTXFE
            using TOC = Field<3, 1>;    // TOC
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-3 interrupt register
        struct DIEPINT3 : public Register<0x50000968> {
            using TXFE = Field<7, 1>;    // TXFE
            using INEPNE = Field<6, 1>;    // INEPNE
            using ITTXFE = Field<4, 1>;    // ITTXFE
            using TOC = Field<3, 1>;    // TOC
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-0 interrupt register
        struct DOEPINT0 : public Register<0x50000b08> {
            using B2BSTUP = Field<6, 1>;    // B2BSTUP
            using OTEPDIS = Field<4, 1>;    // OTEPDIS
            using STUP = Field<3, 1>;    // STUP
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-1 interrupt register
        struct DOEPINT1 : public Register<0x50000b28> {
            using B2BSTUP = Field<6, 1>;    // B2BSTUP
            using OTEPDIS = Field<4, 1>;    // OTEPDIS
            using STUP = Field<3, 1>;    // STUP
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-2 interrupt register
        struct DOEPINT2 : public Register<0x50000b48> {
            using B2BSTUP = Field<6, 1>;    // B2BSTUP
            using OTEPDIS = Field<4, 1>;    // OTEPDIS
            using STUP = Field<3, 1>;    // STUP
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-3 interrupt register
        struct DOEPINT3 : public Register<0x50000b68> {
            using B2BSTUP = Field<6, 1>;    // B2BSTUP
            using OTEPDIS = Field<4, 1>;    // OTEPDIS
            using STUP = Field<3, 1>;    // STUP
            using EPDISD = Field<1, 1>;    // EPDISD
            using XFRC = Field<0, 1>;    // XFRC
        };

        // device endpoint-0 transfer size register
        struct DIEPTSIZ0 : public Register<0x50000910> {
            using PKTCNT = Field<19, 2>;    // Packet count
            using XFRSIZ = Field<0, 7>;    // Transfer size
        };

        // device OUT endpoint-0 transfer size register
        struct DOEPTSIZ0 : public Register<0x50000b10> {
            using STUPCNT = Field<29, 2>;    // SETUP packet count
            using PKTCNT = Field<19, 1>;    // Packet count
            using XFRSIZ = Field<0, 7>;    // Transfer size
        };

        // device endpoint-1 transfer size register
        struct DIEPTSIZ1 : public Register<0x50000930> {
            using MCNT = Field<29, 2>;    // Multi count
            using PKTCNT = Field<19, 10>;    // Packet count
            using XFRSIZ = Field<0, 19>;    // Transfer size
        };

        // device endpoint-2 transfer size register
        struct DIEPTSIZ2 : public Register<0x50000950> {
            using MCNT = Field<29, 2>;    // Multi count
            using PKTCNT = Field<19, 10>;    // Packet count
            using XFRSIZ = Field<0, 19>;    // Transfer size
        };

        // device endpoint-3 transfer size register
        struct DIEPTSIZ3 : public Register<0x50000970> {
            using MCNT = Field<29, 2>;    // Multi count
            using PKTCNT = Field<19, 10>;    // Packet count
            using XFRSIZ = Field<0, 19>;    // Transfer size
        };

        // OTG_FS device IN endpoint transmit FIFO status register
        struct DTXFSTS0 : public Register<0x50000918> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space available
        };

        // OTG_FS device IN endpoint transmit FIFO status register
        struct DTXFSTS1 : public Register<0x50000938> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space available
        };

        // OTG_FS device IN endpoint transmit FIFO status register
        struct DTXFSTS2 : public Register<0x50000958> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space available
        };

        // OTG_FS device IN endpoint transmit FIFO status register
        struct DTXFSTS3 : public Register<0x50000978> {
            using INEPTFSAV = Field<0, 16>;    // IN endpoint TxFIFO space available
        };

        // device OUT endpoint-1 transfer size register
        struct DOEPTSIZ1 : public Register<0x50000b30> {
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
            using PKTCNT = Field<19, 10>;    // Packet count
            using XFRSIZ = Field<0, 19>;    // Transfer size
        };

        // device OUT endpoint-2 transfer size register
        struct DOEPTSIZ2 : public Register<0x50000b50> {
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
            using PKTCNT = Field<19, 10>;    // Packet count
            using XFRSIZ = Field<0, 19>;    // Transfer size
        };

        // device OUT endpoint-3 transfer size register
        struct DOEPTSIZ3 : public Register<0x50000b70> {
            using RXDPID_STUPCNT = Field<29, 2>;    // Received data PID/SETUP packet count
            using PKTCNT = Field<19, 10>;    // Packet count
            using XFRSIZ = Field<0, 19>;    // Transfer size
        };

    };

    // USB on the go full speed
    struct OTG_FS_PWRCLK {
        // OTG_FS power and clock gating control register (OTG_FS_PCGCCTL)
        struct FS_PCGCCTL : public Register<0x50000e00> {
            using STPPCLK = Field<0, 1>;    // Stop PHY clock
            using GATEHCLK = Field<1, 1>;    // Gate HCLK
            using PHYSUSP = Field<4, 1>;    // PHY Suspended
        };

    };

    // Single Wire Protocol Master Interface
    struct SWPMI1 {
        // SWPMI Configuration/Control register
        struct CR : public Register<0x40008800> {
            using RXDMA = Field<0, 1>;    // Reception DMA enable
            using TXDMA = Field<1, 1>;    // Transmission DMA enable
            using RXMODE = Field<2, 1>;    // Reception buffering mode
            using TXMODE = Field<3, 1>;    // Transmission buffering mode
            using LPBK = Field<4, 1>;    // Loopback mode enable
            using SWPME = Field<5, 1>;    // Single wire protocol master interface enable
            using DEACT = Field<10, 1>;    // Single wire protocol master interface deactivate
        };

        // SWPMI Bitrate register
        struct BRR : public Register<0x40008804> {
            using BR = Field<0, 6>;    // Bitrate prescaler
        };

        // SWPMI Interrupt and Status register
        struct ISR : public Register<0x4000880c> {
            using RXBFF = Field<0, 1>;    // Receive buffer full flag
            using TXBEF = Field<1, 1>;    // Transmit buffer empty flag
            using RXBERF = Field<2, 1>;    // Receive CRC error flag
            using RXOVRF = Field<3, 1>;    // Receive overrun error flag
            using TXUNRF = Field<4, 1>;    // Transmit underrun error flag
            using RXNE = Field<5, 1>;    // Receive data register not empty
            using TXE = Field<6, 1>;    // Transmit data register empty
            using TCF = Field<7, 1>;    // Transfer complete flag
            using SRF = Field<8, 1>;    // Slave resume flag
            using SUSP = Field<9, 1>;    // SUSPEND flag
            using DEACTF = Field<10, 1>;    // DEACTIVATED flag
        };

        // SWPMI Interrupt Flag Clear register
        struct ICR : public Register<0x40008810> {
            using CRXBFF = Field<0, 1>;    // Clear receive buffer full flag
            using CTXBEF = Field<1, 1>;    // Clear transmit buffer empty flag
            using CRXBERF = Field<2, 1>;    // Clear receive CRC error flag
            using CRXOVRF = Field<3, 1>;    // Clear receive overrun error flag
            using CTXUNRF = Field<4, 1>;    // Clear transmit underrun error flag
            using CTCF = Field<7, 1>;    // Clear transfer complete flag
            using CSRF = Field<8, 1>;    // Clear slave resume flag
        };

        // SWPMI Interrupt Enable register
        struct IER : public Register<0x40008814> {
            using RXBFIE = Field<0, 1>;    // Receive buffer full interrupt enable
            using TXBEIE = Field<1, 1>;    // Transmit buffer empty interrupt enable
            using RXBERIE = Field<2, 1>;    // Receive CRC error interrupt enable
            using RXOVRIE = Field<3, 1>;    // Receive overrun error interrupt enable
            using TXUNRIE = Field<4, 1>;    // Transmit underrun error interrupt enable
            using RIE = Field<5, 1>;    // Receive interrupt enable
            using TIE = Field<6, 1>;    // Transmit interrupt enable
            using TCIE = Field<7, 1>;    // Transmit complete interrupt enable
            using SRIE = Field<8, 1>;    // Slave resume interrupt enable
        };

        // SWPMI Receive Frame Length register
        struct RFL : public Register<0x40008818> {
            using Field = Field<0, 5>;    // Receive frame length
        };

        // SWPMI Transmit data register
        struct TDR : public Register<0x4000881c> {
            using TD = Field<0, 32>;    // Transmit data
        };

        // SWPMI Receive data register
        struct RDR : public Register<0x40008820> {
            using RD = Field<0, 32>;    // received data
        };

    };

    // Operational amplifiers
    struct OPAMP {
        // OPAMP1 control/status register
        struct OPAMP1_CSR : public Register<0x40007800> {
            using OPAEN = Field<0, 1>;    // Operational amplifier Enable
            using OPALPM = Field<1, 1>;    // Operational amplifier Low Power Mode
            using OPAMODE = Field<2, 2>;    // Operational amplifier PGA mode
            using PGA_GAIN = Field<4, 2>;    // Operational amplifier Programmable amplifier gain value
            using VM_SEL = Field<8, 2>;    // Inverting input selection
            using VP_SEL = Field<10, 1>;    // Non inverted input selection
            using CALON = Field<12, 1>;    // Calibration mode enabled
            using CALSEL = Field<13, 1>;    // Calibration selection
            using USERTRIM = Field<14, 1>;    // allows to switch from AOP offset trimmed values to AOP offset
            using CALOUT = Field<15, 1>;    // Operational amplifier calibration output
            using OPA_RANGE = Field<31, 1>;    // Operational amplifier power supply range for stability
        };

        // OPAMP1 offset trimming register in normal mode
        struct OPAMP1_OTR : public Register<0x40007804> {
            using TRIMOFFSETN = Field<0, 5>;    // Trim for NMOS differential pairs
            using TRIMOFFSETP = Field<8, 5>;    // Trim for PMOS differential pairs
        };

        // OPAMP1 offset trimming register in low-power mode
        struct OPAMP1_LPOTR : public Register<0x40007808> {
            using TRIMLPOFFSETN = Field<0, 5>;    // Trim for NMOS differential pairs
            using TRIMLPOFFSETP = Field<8, 5>;    // Trim for PMOS differential pairs
        };

        // OPAMP2 control/status register
        struct OPAMP2_CSR : public Register<0x40007810> {
            using OPAEN = Field<0, 1>;    // Operational amplifier Enable
            using OPALPM = Field<1, 1>;    // Operational amplifier Low Power Mode
            using OPAMODE = Field<2, 2>;    // Operational amplifier PGA mode
            using PGA_GAIN = Field<4, 2>;    // Operational amplifier Programmable amplifier gain value
            using VM_SEL = Field<8, 2>;    // Inverting input selection
            using VP_SEL = Field<10, 1>;    // Non inverted input selection
            using CALON = Field<12, 1>;    // Calibration mode enabled
            using CALSEL = Field<13, 1>;    // Calibration selection
            using USERTRIM = Field<14, 1>;    // allows to switch from AOP offset trimmed values to AOP offset
            using CALOUT = Field<15, 1>;    // Operational amplifier calibration output
        };

        // OPAMP2 offset trimming register in normal mode
        struct OPAMP2_OTR : public Register<0x40007814> {
            using TRIMOFFSETN = Field<0, 5>;    // Trim for NMOS differential pairs
            using TRIMOFFSETP = Field<8, 5>;    // Trim for PMOS differential pairs
        };

        // OPAMP2 offset trimming register in low-power mode
        struct OPAMP2_LPOTR : public Register<0x40007818> {
            using TRIMLPOFFSETN = Field<0, 5>;    // Trim for NMOS differential pairs
            using TRIMLPOFFSETP = Field<8, 5>;    // Trim for PMOS differential pairs
        };

    };

    // Flexible memory controller
    struct FMC {
        // SRAM/NOR-Flash chip-select control register 1
        struct BCR1 : public Register<0xa0000000> {
            using MBKEN = Field<0, 1>;    // MBKEN
            using MUXEN = Field<1, 1>;    // MUXEN
            using MTYP = Field<2, 2>;    // MTYP
            using MWID = Field<4, 2>;    // MWID
            using FACCEN = Field<6, 1>;    // FACCEN
            using BURSTEN = Field<8, 1>;    // BURSTEN
            using WAITPOL = Field<9, 1>;    // WAITPOL
            using WAITCFG = Field<11, 1>;    // WAITCFG
            using WREN = Field<12, 1>;    // WREN
            using WAITEN = Field<13, 1>;    // WAITEN
            using EXTMOD = Field<14, 1>;    // EXTMOD
            using ASYNCWAIT = Field<15, 1>;    // ASYNCWAIT
            using CBURSTRW = Field<19, 1>;    // CBURSTRW
            using CCLKEN = Field<20, 1>;    // CCLKEN
            using WFDIS = Field<21, 1>;    // Write FIFO Disable
        };

        // SRAM/NOR-Flash chip-select timing register 1
        struct BTR1 : public Register<0xa0000004> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // SRAM/NOR-Flash chip-select control register 2
        struct BCR2 : public Register<0xa0000008> {
            using CBURSTRW = Field<19, 1>;    // CBURSTRW
            using ASYNCWAIT = Field<15, 1>;    // ASYNCWAIT
            using EXTMOD = Field<14, 1>;    // EXTMOD
            using WAITEN = Field<13, 1>;    // WAITEN
            using WREN = Field<12, 1>;    // WREN
            using WAITCFG = Field<11, 1>;    // WAITCFG
            using WRAPMOD = Field<10, 1>;    // WRAPMOD
            using WAITPOL = Field<9, 1>;    // WAITPOL
            using BURSTEN = Field<8, 1>;    // BURSTEN
            using FACCEN = Field<6, 1>;    // FACCEN
            using MWID = Field<4, 2>;    // MWID
            using MTYP = Field<2, 2>;    // MTYP
            using MUXEN = Field<1, 1>;    // MUXEN
            using MBKEN = Field<0, 1>;    // MBKEN
        };

        // SRAM/NOR-Flash chip-select timing register 2
        struct BTR2 : public Register<0xa000000c> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // SRAM/NOR-Flash chip-select control register 3
        struct BCR3 : public Register<0xa0000010> {
            using CBURSTRW = Field<19, 1>;    // CBURSTRW
            using ASYNCWAIT = Field<15, 1>;    // ASYNCWAIT
            using EXTMOD = Field<14, 1>;    // EXTMOD
            using WAITEN = Field<13, 1>;    // WAITEN
            using WREN = Field<12, 1>;    // WREN
            using WAITCFG = Field<11, 1>;    // WAITCFG
            using WRAPMOD = Field<10, 1>;    // WRAPMOD
            using WAITPOL = Field<9, 1>;    // WAITPOL
            using BURSTEN = Field<8, 1>;    // BURSTEN
            using FACCEN = Field<6, 1>;    // FACCEN
            using MWID = Field<4, 2>;    // MWID
            using MTYP = Field<2, 2>;    // MTYP
            using MUXEN = Field<1, 1>;    // MUXEN
            using MBKEN = Field<0, 1>;    // MBKEN
        };

        // SRAM/NOR-Flash chip-select timing register 3
        struct BTR3 : public Register<0xa0000014> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // SRAM/NOR-Flash chip-select control register 4
        struct BCR4 : public Register<0xa0000018> {
            using CBURSTRW = Field<19, 1>;    // CBURSTRW
            using ASYNCWAIT = Field<15, 1>;    // ASYNCWAIT
            using EXTMOD = Field<14, 1>;    // EXTMOD
            using WAITEN = Field<13, 1>;    // WAITEN
            using WREN = Field<12, 1>;    // WREN
            using WAITCFG = Field<11, 1>;    // WAITCFG
            using WRAPMOD = Field<10, 1>;    // WRAPMOD
            using WAITPOL = Field<9, 1>;    // WAITPOL
            using BURSTEN = Field<8, 1>;    // BURSTEN
            using FACCEN = Field<6, 1>;    // FACCEN
            using MWID = Field<4, 2>;    // MWID
            using MTYP = Field<2, 2>;    // MTYP
            using MUXEN = Field<1, 1>;    // MUXEN
            using MBKEN = Field<0, 1>;    // MBKEN
        };

        // SRAM/NOR-Flash chip-select timing register 4
        struct BTR4 : public Register<0xa000001c> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using BUSTURN = Field<16, 4>;    // BUSTURN
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // PC Card/NAND Flash control register 3
        struct PCR : public Register<0xa0000080> {
            using ECCPS = Field<17, 3>;    // ECCPS
            using TAR = Field<13, 4>;    // TAR
            using TCLR = Field<9, 4>;    // TCLR
            using ECCEN = Field<6, 1>;    // ECCEN
            using PWID = Field<4, 2>;    // PWID
            using PTYP = Field<3, 1>;    // PTYP
            using PBKEN = Field<2, 1>;    // PBKEN
            using PWAITEN = Field<1, 1>;    // PWAITEN
        };

        // FIFO status and interrupt register 3
        struct SR : public Register<0xa0000084> {
            using FEMPT = Field<6, 1>;    // FEMPT
            using IFEN = Field<5, 1>;    // IFEN
            using ILEN = Field<4, 1>;    // ILEN
            using IREN = Field<3, 1>;    // IREN
            using IFS = Field<2, 1>;    // IFS
            using ILS = Field<1, 1>;    // ILS
            using IRS = Field<0, 1>;    // IRS
        };

        // Common memory space timing register 3
        struct PMEM : public Register<0xa0000088> {
            using MEMHIZx = Field<24, 8>;    // MEMHIZx
            using MEMHOLDx = Field<16, 8>;    // MEMHOLDx
            using MEMWAITx = Field<8, 8>;    // MEMWAITx
            using MEMSETx = Field<0, 8>;    // MEMSETx
        };

        // Attribute memory space timing register 3
        struct PATT : public Register<0xa000008c> {
            using ATTHIZx = Field<24, 8>;    // ATTHIZx
            using ATTHOLDx = Field<16, 8>;    // ATTHOLDx
            using ATTWAITx = Field<8, 8>;    // ATTWAITx
            using ATTSETx = Field<0, 8>;    // ATTSETx
        };

        // ECC result register 3
        struct ECCR : public Register<0xa0000094> {
            using ECCx = Field<0, 32>;    // ECCx
        };

        // SRAM/NOR-Flash write timing registers 1
        struct BWTR1 : public Register<0xa0000104> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // SRAM/NOR-Flash write timing registers 2
        struct BWTR2 : public Register<0xa000010c> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // SRAM/NOR-Flash write timing registers 3
        struct BWTR3 : public Register<0xa0000114> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

        // SRAM/NOR-Flash write timing registers 4
        struct BWTR4 : public Register<0xa000011c> {
            using ACCMOD = Field<28, 2>;    // ACCMOD
            using DATLAT = Field<24, 4>;    // DATLAT
            using CLKDIV = Field<20, 4>;    // CLKDIV
            using DATAST = Field<8, 8>;    // DATAST
            using ADDHLD = Field<4, 4>;    // ADDHLD
            using ADDSET = Field<0, 4>;    // ADDSET
        };

    };

    // Nested Vectored Interrupt Controller
    struct NVIC {
        // Interrupt Set-Enable Register
        struct ISER0 : public Register<0xe000e100> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Set-Enable Register
        struct ISER1 : public Register<0xe000e104> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Set-Enable Register
        struct ISER2 : public Register<0xe000e108> {
            using SETENA = Field<0, 32>;    // SETENA
        };

        // Interrupt Clear-Enable Register
        struct ICER0 : public Register<0xe000e180> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Clear-Enable Register
        struct ICER1 : public Register<0xe000e184> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Clear-Enable Register
        struct ICER2 : public Register<0xe000e188> {
            using CLRENA = Field<0, 32>;    // CLRENA
        };

        // Interrupt Set-Pending Register
        struct ISPR0 : public Register<0xe000e200> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Set-Pending Register
        struct ISPR1 : public Register<0xe000e204> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Set-Pending Register
        struct ISPR2 : public Register<0xe000e208> {
            using SETPEND = Field<0, 32>;    // SETPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR0 : public Register<0xe000e280> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR1 : public Register<0xe000e284> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Clear-Pending Register
        struct ICPR2 : public Register<0xe000e288> {
            using CLRPEND = Field<0, 32>;    // CLRPEND
        };

        // Interrupt Active Bit Register
        struct IABR0 : public Register<0xe000e300> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Active Bit Register
        struct IABR1 : public Register<0xe000e304> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Active Bit Register
        struct IABR2 : public Register<0xe000e308> {
            using ACTIVE = Field<0, 32>;    // ACTIVE
        };

        // Interrupt Priority Register
        struct IPR0 : public Register<0xe000e400> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR1 : public Register<0xe000e404> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR2 : public Register<0xe000e408> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR3 : public Register<0xe000e40c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR4 : public Register<0xe000e410> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR5 : public Register<0xe000e414> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR6 : public Register<0xe000e418> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR7 : public Register<0xe000e41c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR8 : public Register<0xe000e420> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR9 : public Register<0xe000e424> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR10 : public Register<0xe000e428> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR11 : public Register<0xe000e42c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR12 : public Register<0xe000e430> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR13 : public Register<0xe000e434> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR14 : public Register<0xe000e438> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR15 : public Register<0xe000e43c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR16 : public Register<0xe000e440> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR17 : public Register<0xe000e444> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR18 : public Register<0xe000e448> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR19 : public Register<0xe000e44c> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

        // Interrupt Priority Register
        struct IPR20 : public Register<0xe000e450> {
            using IPR_N0 = Field<0, 8>;    // IPR_N0
            using IPR_N1 = Field<8, 8>;    // IPR_N1
            using IPR_N2 = Field<16, 8>;    // IPR_N2
            using IPR_N3 = Field<24, 8>;    // IPR_N3
        };

    };

    // Clock recovery system
    struct CRS {
        // control register
        struct CR : public Register<0x40006000> {
            using TRIM = Field<8, 6>;    // HSI48 oscillator smooth trimming
            using SWSYNC = Field<7, 1>;    // Generate software SYNC event
            using AUTOTRIMEN = Field<6, 1>;    // Automatic trimming enable
            using CEN = Field<5, 1>;    // Frequency error counter enable
            using ESYNCIE = Field<3, 1>;    // Expected SYNC interrupt enable
            using ERRIE = Field<2, 1>;    // Synchronization or trimming error interrupt enable
            using SYNCWARNIE = Field<1, 1>;    // SYNC warning interrupt enable
            using SYNCOKIE = Field<0, 1>;    // SYNC event OK interrupt enable
        };

        // configuration register
        struct CFGR : public Register<0x40006004> {
            using SYNCPOL = Field<31, 1>;    // SYNC polarity selection
            using SYNCSRC = Field<28, 2>;    // SYNC signal source selection
            using SYNCDIV = Field<24, 3>;    // SYNC divider
            using FELIM = Field<16, 8>;    // Frequency error limit
            using RELOAD = Field<0, 16>;    // Counter reload value
        };

        // interrupt and status register
        struct ISR : public Register<0x40006008> {
            using FECAP = Field<16, 16>;    // Frequency error capture
            using FEDIR = Field<15, 1>;    // Frequency error direction
            using TRIMOVF = Field<10, 1>;    // Trimming overflow or underflow
            using SYNCMISS = Field<9, 1>;    // SYNC missed
            using SYNCERR = Field<8, 1>;    // SYNC error
            using ESYNCF = Field<3, 1>;    // Expected SYNC flag
            using ERRF = Field<2, 1>;    // Error flag
            using SYNCWARNF = Field<1, 1>;    // SYNC warning flag
            using SYNCOKF = Field<0, 1>;    // SYNC event OK flag
        };

        // interrupt flag clear register
        struct ICR : public Register<0x4000600c> {
            using ESYNCC = Field<3, 1>;    // Expected SYNC clear flag
            using ERRC = Field<2, 1>;    // Error clear flag
            using SYNCWARNC = Field<1, 1>;    // SYNC warning clear flag
            using SYNCOKC = Field<0, 1>;    // SYNC event OK clear flag
        };

    };

    // Digital camera interface
    struct DCMI {
        // control register 1
        struct CR : public Register<0x50050000> {
            using ENABLE = Field<14, 1>;    // DCMI enable
            using EDM = Field<10, 2>;    // Extended data mode
            using FCRC = Field<8, 2>;    // Frame capture rate control
            using VSPOL = Field<7, 1>;    // Vertical synchronization polarity
            using HSPOL = Field<6, 1>;    // Horizontal synchronization polarity
            using PCKPOL = Field<5, 1>;    // Pixel clock polarity
            using ESS = Field<4, 1>;    // Embedded synchronization select
            using JPEG = Field<3, 1>;    // JPEG format
            using CROP = Field<2, 1>;    // Crop feature
            using CM = Field<1, 1>;    // Capture mode
            using CAPTURE = Field<0, 1>;    // Capture enable
            using OELS = Field<20, 1>;    // Odd/Even Line Select (Line Select Start)
            using LSM = Field<19, 1>;    // Line Select mode
            using OEBS = Field<18, 1>;    // Odd/Even Byte Select (Byte Select Start)
            using BSM = Field<16, 2>;    // Byte Select mode
        };

        // status register
        struct SR : public Register<0x50050004> {
            using FNE = Field<2, 1>;    // FIFO not empty
            using VSYNC = Field<1, 1>;    // VSYNC
            using HSYNC = Field<0, 1>;    // HSYNC
        };

        // raw interrupt status register
        struct RIS : public Register<0x50050008> {
            using LINE_RIS = Field<4, 1>;    // Line raw interrupt status
            using VSYNC_RIS = Field<3, 1>;    // VSYNC raw interrupt status
            using ERR_RIS = Field<2, 1>;    // Synchronization error raw interrupt status
            using OVR_RIS = Field<1, 1>;    // Overrun raw interrupt status
            using FRAME_RIS = Field<0, 1>;    // Capture complete raw interrupt status
        };

        // interrupt enable register
        struct IER : public Register<0x5005000c> {
            using LINE_IE = Field<4, 1>;    // Line interrupt enable
            using VSYNC_IE = Field<3, 1>;    // VSYNC interrupt enable
            using ERR_IE = Field<2, 1>;    // Synchronization error interrupt enable
            using OVR_IE = Field<1, 1>;    // Overrun interrupt enable
            using FRAME_IE = Field<0, 1>;    // Capture complete interrupt enable
        };

        // masked interrupt status register
        struct MIS : public Register<0x50050010> {
            using LINE_MIS = Field<4, 1>;    // Line masked interrupt status
            using VSYNC_MIS = Field<3, 1>;    // VSYNC masked interrupt status
            using ERR_MIS = Field<2, 1>;    // Synchronization error masked interrupt status
            using OVR_MIS = Field<1, 1>;    // Overrun masked interrupt status
            using FRAME_MIS = Field<0, 1>;    // Capture complete masked interrupt status
        };

        // interrupt clear register
        struct ICR : public Register<0x50050014> {
            using LINE_ISC = Field<4, 1>;    // line interrupt status clear
            using VSYNC_ISC = Field<3, 1>;    // Vertical synch interrupt status clear
            using ERR_ISC = Field<2, 1>;    // Synchronization error interrupt status clear
            using OVR_ISC = Field<1, 1>;    // Overrun interrupt status clear
            using FRAME_ISC = Field<0, 1>;    // Capture complete interrupt status clear
        };

        // embedded synchronization code register
        struct ESCR : public Register<0x50050018> {
            using FEC = Field<24, 8>;    // Frame end delimiter code
            using LEC = Field<16, 8>;    // Line end delimiter code
            using LSC = Field<8, 8>;    // Line start delimiter code
            using FSC = Field<0, 8>;    // Frame start delimiter code
        };

        // embedded synchronization unmask register
        struct ESUR : public Register<0x5005001c> {
            using FEU = Field<24, 8>;    // Frame end delimiter unmask
            using LEU = Field<16, 8>;    // Line end delimiter unmask
            using LSU = Field<8, 8>;    // Line start delimiter unmask
            using FSU = Field<0, 8>;    // Frame start delimiter unmask
        };

        // crop window start
        struct CWSTRT : public Register<0x50050020> {
            using VST = Field<16, 13>;    // Vertical start line count
            using HOFFCNT = Field<0, 14>;    // Horizontal offset count
        };

        // crop window size
        struct CWSIZE : public Register<0x50050024> {
            using VLINE = Field<16, 14>;    // Vertical line count
            using CAPCNT = Field<0, 14>;    // Capture count
        };

        // data register
        struct DR : public Register<0x50050028> {
            using Byte3 = Field<24, 8>;    // Data byte 3
            using Byte2 = Field<16, 8>;    // Data byte 2
            using Byte1 = Field<8, 8>;    // Data byte 1
            using Byte0 = Field<0, 8>;    // Data byte 0
        };

    };

    // Hash processor
    struct HASH {
        // control register
        struct CR : public Register<0x50060400> {
            using INIT = Field<2, 1>;    // Initialize message digest calculation
            using DMAE = Field<3, 1>;    // DMA enable
            using DATATYPE = Field<4, 2>;    // Data type selection
            using MODE = Field<6, 1>;    // Mode selection
            using ALGO0 = Field<7, 1>;    // Algorithm selection
            using NBW = Field<8, 4>;    // Number of words already pushed
            using DINNE = Field<12, 1>;    // DIN not empty
            using MDMAT = Field<13, 1>;    // Multiple DMA Transfers
            using LKEY = Field<16, 1>;    // Long key selection
            using ALGO1 = Field<18, 1>;    // ALGO
        };

        // data input register
        struct DIN : public Register<0x50060404> {
            using DATAIN = Field<0, 32>;    // Data input
        };

        // start register
        struct STR : public Register<0x50060408> {
            using DCAL = Field<8, 1>;    // Digest calculation
            using NBLW = Field<0, 5>;    // Number of valid bits in the last word of the message
        };

        // digest registers
        struct HR0 : public Register<0x5006040c> {
            using H0 = Field<0, 32>;    // H0
        };

        // interrupt enable register
        struct IMR : public Register<0x50060420> {
            using DCIE = Field<1, 1>;    // Digest calculation completion interrupt enable
            using DINIE = Field<0, 1>;    // Data input interrupt enable
        };

        // status register
        struct SR : public Register<0x50060424> {
            using BUSY = Field<3, 1>;    // Busy bit
            using DMAS = Field<2, 1>;    // DMA Status
            using DCIS = Field<1, 1>;    // Digest calculation completion interrupt status
            using DINIS = Field<0, 1>;    // Data input interrupt status
        };

        // context swap registers
        struct CSR0 : public Register<0x500604f8> {
            using Field = Field<0, 32>;    // CSR0
        };

        // context swap registers
        struct CSR1 : public Register<0x500604fc> {
            using Field = Field<0, 32>;    // CSR1
        };

        // context swap registers
        struct CSR2 : public Register<0x50060500> {
            using Field = Field<0, 32>;    // CSR2
        };

        // context swap registers
        struct CSR3 : public Register<0x50060504> {
            using Field = Field<0, 32>;    // CSR3
        };

        // context swap registers
        struct CSR4 : public Register<0x50060508> {
            using Field = Field<0, 32>;    // CSR4
        };

        // context swap registers
        struct CSR5 : public Register<0x5006050c> {
            using Field = Field<0, 32>;    // CSR5
        };

        // context swap registers
        struct CSR6 : public Register<0x50060510> {
            using Field = Field<0, 32>;    // CSR6
        };

        // context swap registers
        struct CSR7 : public Register<0x50060514> {
            using Field = Field<0, 32>;    // CSR7
        };

        // context swap registers
        struct CSR8 : public Register<0x50060518> {
            using Field = Field<0, 32>;    // CSR8
        };

        // context swap registers
        struct CSR9 : public Register<0x5006051c> {
            using Field = Field<0, 32>;    // CSR9
        };

        // context swap registers
        struct CSR10 : public Register<0x50060520> {
            using Field = Field<0, 32>;    // CSR10
        };

        // context swap registers
        struct CSR11 : public Register<0x50060524> {
            using Field = Field<0, 32>;    // CSR11
        };

        // context swap registers
        struct CSR12 : public Register<0x50060528> {
            using Field = Field<0, 32>;    // CSR12
        };

        // context swap registers
        struct CSR13 : public Register<0x5006052c> {
            using Field = Field<0, 32>;    // CSR13
        };

        // context swap registers
        struct CSR14 : public Register<0x50060530> {
            using Field = Field<0, 32>;    // CSR14
        };

        // context swap registers
        struct CSR15 : public Register<0x50060534> {
            using Field = Field<0, 32>;    // CSR15
        };

        // context swap registers
        struct CSR16 : public Register<0x50060538> {
            using Field = Field<0, 32>;    // CSR16
        };

        // context swap registers
        struct CSR17 : public Register<0x5006053c> {
            using Field = Field<0, 32>;    // CSR17
        };

        // context swap registers
        struct CSR18 : public Register<0x50060540> {
            using Field = Field<0, 32>;    // CSR18
        };

        // context swap registers
        struct CSR19 : public Register<0x50060544> {
            using Field = Field<0, 32>;    // CSR19
        };

        // context swap registers
        struct CSR20 : public Register<0x50060548> {
            using Field = Field<0, 32>;    // CSR20
        };

        // context swap registers
        struct CSR21 : public Register<0x5006054c> {
            using Field = Field<0, 32>;    // CSR21
        };

        // context swap registers
        struct CSR22 : public Register<0x50060550> {
            using Field = Field<0, 32>;    // CSR22
        };

        // context swap registers
        struct CSR23 : public Register<0x50060554> {
            using Field = Field<0, 32>;    // CSR23
        };

        // context swap registers
        struct CSR24 : public Register<0x50060558> {
            using Field = Field<0, 32>;    // CSR24
        };

        // context swap registers
        struct CSR25 : public Register<0x5006055c> {
            using Field = Field<0, 32>;    // CSR25
        };

        // context swap registers
        struct CSR26 : public Register<0x50060560> {
            using Field = Field<0, 32>;    // CSR26
        };

        // context swap registers
        struct CSR27 : public Register<0x50060564> {
            using Field = Field<0, 32>;    // CSR27
        };

        // context swap registers
        struct CSR28 : public Register<0x50060568> {
            using Field = Field<0, 32>;    // CSR28
        };

        // context swap registers
        struct CSR29 : public Register<0x5006056c> {
            using Field = Field<0, 32>;    // CSR29
        };

        // context swap registers
        struct CSR30 : public Register<0x50060570> {
            using Field = Field<0, 32>;    // CSR30
        };

        // context swap registers
        struct CSR31 : public Register<0x50060574> {
            using Field = Field<0, 32>;    // CSR31
        };

        // context swap registers
        struct CSR32 : public Register<0x50060578> {
            using Field = Field<0, 32>;    // CSR32
        };

        // context swap registers
        struct CSR33 : public Register<0x5006057c> {
            using Field = Field<0, 32>;    // CSR33
        };

        // context swap registers
        struct CSR34 : public Register<0x50060580> {
            using Field = Field<0, 32>;    // CSR34
        };

        // context swap registers
        struct CSR35 : public Register<0x50060584> {
            using Field = Field<0, 32>;    // CSR35
        };

        // context swap registers
        struct CSR36 : public Register<0x50060588> {
            using Field = Field<0, 32>;    // CSR36
        };

        // context swap registers
        struct CSR37 : public Register<0x5006058c> {
            using Field = Field<0, 32>;    // CSR37
        };

        // context swap registers
        struct CSR38 : public Register<0x50060590> {
            using Field = Field<0, 32>;    // CSR38
        };

        // context swap registers
        struct CSR39 : public Register<0x50060594> {
            using Field = Field<0, 32>;    // CSR39
        };

        // context swap registers
        struct CSR40 : public Register<0x50060598> {
            using Field = Field<0, 32>;    // CSR40
        };

        // context swap registers
        struct CSR41 : public Register<0x5006059c> {
            using Field = Field<0, 32>;    // CSR41
        };

        // context swap registers
        struct CSR42 : public Register<0x500605a0> {
            using Field = Field<0, 32>;    // CSR42
        };

        // context swap registers
        struct CSR43 : public Register<0x500605a4> {
            using Field = Field<0, 32>;    // CSR43
        };

        // context swap registers
        struct CSR44 : public Register<0x500605a8> {
            using Field = Field<0, 32>;    // CSR44
        };

        // context swap registers
        struct CSR45 : public Register<0x500605ac> {
            using Field = Field<0, 32>;    // CSR45
        };

        // context swap registers
        struct CSR46 : public Register<0x500605b0> {
            using Field = Field<0, 32>;    // CSR46
        };

        // context swap registers
        struct CSR47 : public Register<0x500605b4> {
            using Field = Field<0, 32>;    // CSR47
        };

        // context swap registers
        struct CSR48 : public Register<0x500605b8> {
            using Field = Field<0, 32>;    // CSR48
        };

        // context swap registers
        struct CSR49 : public Register<0x500605bc> {
            using Field = Field<0, 32>;    // CSR49
        };

        // context swap registers
        struct CSR50 : public Register<0x500605c0> {
            using Field = Field<0, 32>;    // CSR50
        };

        // context swap registers
        struct CSR51 : public Register<0x500605c4> {
            using Field = Field<0, 32>;    // CSR51
        };

        // context swap registers
        struct CSR52 : public Register<0x500605c8> {
            using Field = Field<0, 32>;    // CSR52
        };

        // context swap registers
        struct CSR53 : public Register<0x500605cc> {
            using Field = Field<0, 32>;    // CSR53
        };

        // HASH digest register
        struct HASH_HR0 : public Register<0x50060710> {
            using H0 = Field<0, 32>;    // H0
        };

        // read-only
        struct HASH_HR1 : public Register<0x50060714> {
            using H1 = Field<0, 32>;    // H1
        };

        // read-only
        struct HASH_HR2 : public Register<0x50060718> {
            using H2 = Field<0, 32>;    // H2
        };

        // read-only
        struct HASH_HR3 : public Register<0x5006071c> {
            using H3 = Field<0, 32>;    // H3
        };

        // read-only
        struct HASH_HR4 : public Register<0x50060720> {
            using H4 = Field<0, 32>;    // H4
        };

        // read-only
        struct HASH_HR5 : public Register<0x50060724> {
            using H5 = Field<0, 32>;    // H5
        };

        // read-only
        struct HASH_HR6 : public Register<0x50060728> {
            using H6 = Field<0, 32>;    // H6
        };

        // read-only
        struct HASH_HR7 : public Register<0x5006072c> {
            using H7 = Field<0, 32>;    // H7
        };

    };

    // DMA2D controller
    struct DMA2D {
        // control register
        struct CR : public Register<0x4002b000> {
            using MODE = Field<16, 2>;    // DMA2D mode
            using CEIE = Field<13, 1>;    // Configuration Error Interrupt Enable
            using CTCIE = Field<12, 1>;    // CLUT transfer complete interrupt enable
            using CAEIE = Field<11, 1>;    // CLUT access error interrupt enable
            using TWIE = Field<10, 1>;    // Transfer watermark interrupt enable
            using TCIE = Field<9, 1>;    // Transfer complete interrupt enable
            using TEIE = Field<8, 1>;    // Transfer error interrupt enable
            using ABORT = Field<2, 1>;    // Abort
            using SUSP = Field<1, 1>;    // Suspend
            using START = Field<0, 1>;    // Start
        };

        // Interrupt Status Register
        struct ISR : public Register<0x4002b004> {
            using CEIF = Field<5, 1>;    // Configuration error interrupt flag
            using CTCIF = Field<4, 1>;    // CLUT transfer complete interrupt flag
            using CAEIF = Field<3, 1>;    // CLUT access error interrupt flag
            using TWIF = Field<2, 1>;    // Transfer watermark interrupt flag
            using TCIF = Field<1, 1>;    // Transfer complete interrupt flag
            using TEIF = Field<0, 1>;    // Transfer error interrupt flag
        };

        // interrupt flag clear register
        struct IFCR : public Register<0x4002b008> {
            using CCEIF = Field<5, 1>;    // Clear configuration error interrupt flag
            using CCTCIF = Field<4, 1>;    // Clear CLUT transfer complete interrupt flag
            using CAECIF = Field<3, 1>;    // Clear CLUT access error interrupt flag
            using CTWIF = Field<2, 1>;    // Clear transfer watermark interrupt flag
            using CTCIF = Field<1, 1>;    // Clear transfer complete interrupt flag
            using CTEIF = Field<0, 1>;    // Clear Transfer error interrupt flag
        };

        // foreground memory address register
        struct FGMAR : public Register<0x4002b00c> {
            using MA = Field<0, 32>;    // Memory address
        };

        // foreground offset register
        struct FGOR : public Register<0x4002b010> {
            using LO = Field<0, 14>;    // Line offset
        };

        // background memory address register
        struct BGMAR : public Register<0x4002b014> {
            using MA = Field<0, 32>;    // Memory address
        };

        // background offset register
        struct BGOR : public Register<0x4002b018> {
            using LO = Field<0, 14>;    // Line offset
        };

        // foreground PFC control register
        struct FGPFCCR : public Register<0x4002b01c> {
            using ALPHA = Field<24, 8>;    // Alpha value
            using AM = Field<16, 2>;    // Alpha mode
            using CS = Field<8, 8>;    // CLUT size
            using START = Field<5, 1>;    // Start
            using CCM = Field<4, 1>;    // CLUT color mode
            using CM = Field<0, 4>;    // Color mode
            using RBS = Field<21, 1>;    // Red Blue Swap
            using AI = Field<20, 1>;    // Alpha Inverted
        };

        // foreground color register
        struct FGCOLR : public Register<0x4002b020> {
            using RED = Field<16, 8>;    // Red Value
            using GREEN = Field<8, 8>;    // Green Value
            using BLUE = Field<0, 8>;    // Blue Value
        };

        // background PFC control register
        struct BGPFCCR : public Register<0x4002b024> {
            using ALPHA = Field<24, 8>;    // Alpha value
            using AM = Field<16, 2>;    // Alpha mode
            using CS = Field<8, 8>;    // CLUT size
            using START = Field<5, 1>;    // Start
            using CCM = Field<4, 1>;    // CLUT Color mode
            using CM = Field<0, 4>;    // Color mode
            using RBS = Field<21, 1>;    // Red Blue Swap
            using AI = Field<20, 1>;    // Alpha Inverted
        };

        // background color register
        struct BGCOLR : public Register<0x4002b028> {
            using RED = Field<16, 8>;    // Red Value
            using GREEN = Field<8, 8>;    // Green Value
            using BLUE = Field<0, 8>;    // Blue Value
        };

        // foreground CLUT memory address register
        struct FGCMAR : public Register<0x4002b02c> {
            using MA = Field<0, 32>;    // Memory Address
        };

        // background CLUT memory address register
        struct BGCMAR : public Register<0x4002b030> {
            using MA = Field<0, 32>;    // Memory address
        };

        // output PFC control register
        struct OPFCCR : public Register<0x4002b034> {
            using CM = Field<0, 3>;    // Color mode
            using RBS = Field<21, 1>;    // Red Blue Swap
            using AI = Field<20, 1>;    // Alpha Inverted
        };

        // output color register
        struct OCOLR : public Register<0x4002b038> {
            using APLHA = Field<24, 8>;    // Alpha Channel Value
            using RED = Field<16, 8>;    // Red Value
            using GREEN = Field<8, 8>;    // Green Value
            using BLUE = Field<0, 8>;    // Blue Value
        };

        // output memory address register
        struct OMAR : public Register<0x4002b03c> {
            using MA = Field<0, 32>;    // Memory Address
        };

        // output offset register
        struct OOR : public Register<0x4002b040> {
            using LO = Field<0, 14>;    // Line Offset
        };

        // number of line register
        struct NLR : public Register<0x4002b044> {
            using PL = Field<16, 14>;    // Pixel per lines
            using NL = Field<0, 16>;    // Number of lines
        };

        // line watermark register
        struct LWR : public Register<0x4002b048> {
            using LW = Field<0, 16>;    // Line watermark
        };

        // AHB master timer configuration register
        struct AMTCR : public Register<0x4002b04c> {
            using DT = Field<8, 8>;    // Dead Time
            using EN = Field<0, 1>;    // Enable
        };

        // FGCLUT
        struct FGCLUT : public Register<0x4002b400> {
            using APLHA = Field<24, 8>;    // APLHA
            using RED = Field<16, 8>;    // RED
            using GREEN = Field<8, 8>;    // GREEN
            using BLUE = Field<0, 8>;    // BLUE
        };

        // BGCLUT
        struct BGCLUT : public Register<0x4002b800> {
            using APLHA = Field<24, 8>;    // APLHA
            using RED = Field<16, 8>;    // RED
            using GREEN = Field<8, 8>;    // GREEN
            using BLUE = Field<0, 8>;    // BLUE
        };

    };

    // DSI Host
    struct DSI {
        // DSI Host Version Register
        struct DSI_VR : public Register<0x40016c00> {
            using VERSION = Field<0, 32>;    // Version of the DSI Host
        };

        // DSI Host Control Register
        struct DSI_CR : public Register<0x40016c04> {
            using EN = Field<0, 1>;    // Enable
        };

        // DSI HOST Clock Control Register
        struct DSI_CCR : public Register<0x40016c08> {
            using TXECKDIV = Field<0, 8>;    // TX Escape Clock Division
            using TOCKDIV = Field<8, 8>;    // Timeout Clock Division
        };

        // DSI Host LTDC VCID Register
        struct DSI_LVCIDR : public Register<0x40016c0c> {
            using VCID = Field<0, 2>;    // Virtual Channel ID
        };

        // DSI Host LTDC Color Coding Register
        struct DSI_LCOLCR : public Register<0x40016c10> {
            using COLC = Field<0, 4>;    // Color Coding
            using LPE = Field<8, 1>;    // Loosely Packet Enable
        };

        // DSI Host LTDC Polarity Configuration Register
        struct DSI_LPCR : public Register<0x40016c14> {
            using DEP = Field<0, 1>;    // Data Enable Polarity
            using VSP = Field<1, 1>;    // VSYNC Polarity
            using HSP = Field<2, 1>;    // HSYNC Polarity
        };

        // DSI Host Low-Power mode Configuration Register
        struct DSI_LPMCR : public Register<0x40016c18> {
            using VLPSIZE = Field<0, 8>;    // VACT Largest Packet Size
            using LPSIZE = Field<16, 8>;    // Largest Packet Size
        };

        // DSI Host Protocol Configuration Register
        struct DSI_PCR : public Register<0x40016c1c> {
            using ETTXE = Field<0, 1>;    // EoTp Transmission Enable
            using ETRXE = Field<1, 1>;    // EoTp Reception Enable
            using BTAE = Field<2, 1>;    // Bus Turn Around Enable
            using ECCRXE = Field<3, 1>;    // ECC Reception Enable
            using CRCRXE = Field<4, 1>;    // CRC Reception Enable
        };

        // DSI Host Generic VCID Register
        struct DSI_GVCIDR : public Register<0x40016c20> {
            using VCID = Field<0, 2>;    // Virtual Channel ID
        };

        // DSI Host mode Configuration Register
        struct DSI_MCR : public Register<0x40016c24> {
            using CMDM = Field<0, 1>;    // Command mode
        };

        // DSI Host Video mode Configuration Register
        struct DSI_VMCR : public Register<0x40016c28> {
            using VMT = Field<0, 2>;    // Video mode Type
            using LPVSAE = Field<8, 1>;    // Low-Power Vertical Sync Active Enable
            using LPVBPE = Field<9, 1>;    // Low-power Vertical Back-Porch Enable
            using LPVFPE = Field<10, 1>;    // Low-power Vertical Front-porch Enable
            using LPVAE = Field<11, 1>;    // Low-Power Vertical Active Enable
            using LPHBPE = Field<12, 1>;    // Low-Power Horizontal Back-Porch Enable
            using LPHFPE = Field<13, 1>;    // Low-Power Horizontal Front-Porch Enable
            using FBTAAE = Field<14, 1>;    // Frame Bus-Turn-Around Acknowledge Enable
            using LPCE = Field<15, 1>;    // Low-Power Command Enable
            using PGE = Field<16, 1>;    // Pattern Generator Enable
            using PGM = Field<20, 1>;    // Pattern Generator mode
            using PGO = Field<24, 1>;    // Pattern Generator Orientation
        };

        // DSI Host Video Packet Configuration Register
        struct DSI_VPCR : public Register<0x40016c2c> {
            using VPSIZE = Field<0, 14>;    // Video Packet Size
        };

        // DSI Host Video Chunks Configuration Register
        struct DSI_VCCR : public Register<0x40016c30> {
            using NUMC = Field<0, 13>;    // Number of Chunks
        };

        // DSI Host Video Null Packet Configuration Register
        struct DSI_VNPCR : public Register<0x40016c34> {
            using NPSIZE = Field<0, 13>;    // Null Packet Size
        };

        // DSI Host Video HSA Configuration Register
        struct DSI_VHSACR : public Register<0x40016c38> {
            using HSA = Field<0, 12>;    // Horizontal Synchronism Active duration
        };

        // DSI Host Video HBP Configuration Register
        struct DSI_VHBPCR : public Register<0x40016c3c> {
            using HBP = Field<0, 12>;    // Horizontal Back-Porch duration
        };

        // DSI Host Video Line Configuration Register
        struct DSI_VLCR : public Register<0x40016c40> {
            using HLINE = Field<0, 15>;    // Horizontal Line duration
        };

        // DSI Host Video VSA Configuration Register
        struct DSI_VVSACR : public Register<0x40016c44> {
            using VSA = Field<0, 10>;    // Vertical Synchronism Active duration
        };

        // DSI Host Video VBP Configuration Register
        struct DSI_VVBPCR : public Register<0x40016c48> {
            using VBP = Field<0, 10>;    // Vertical Back-Porch duration
        };

        // DSI Host Video VFP Configuration Register
        struct DSI_VVFPCR : public Register<0x40016c4c> {
            using VFP = Field<0, 10>;    // Vertical Front-Porch duration
        };

        // DSI Host Video VA Configuration Register
        struct DSI_VVACR : public Register<0x40016c50> {
            using VA = Field<0, 14>;    // Vertical Active duration
        };

        // DSI Host LTDC Command Configuration Register
        struct DSI_LCCR : public Register<0x40016c54> {
            using CMDSIZE = Field<0, 16>;    // Command Size
        };

        // DSI Host Command mode Configuration Register
        struct DSI_CMCR : public Register<0x40016c58> {
            using TEARE = Field<0, 1>;    // Tearing Effect Acknowledge Request Enable
            using ARE = Field<1, 1>;    // Acknowledge Request Enable
            using GSW0TX = Field<8, 1>;    // Generic Short Write Zero parameters Transmission
            using GSW1TX = Field<9, 1>;    // Generic Short Write One parameters Transmission
            using GSW2TX = Field<10, 1>;    // Generic Short Write Two parameters Transmission
            using GSR0TX = Field<11, 1>;    // Generic Short Read Zero parameters Transmission
            using GSR1TX = Field<12, 1>;    // Generic Short Read One parameters Transmission
            using GSR2TX = Field<13, 1>;    // Generic Short Read Two parameters Transmission
            using GLWTX = Field<14, 1>;    // Generic Long Write Transmission
            using DSW0TX = Field<16, 1>;    // DCS Short Write Zero parameter Transmission
            using DSW1TX = Field<17, 1>;    // DCS Short Read One parameter Transmission
            using DSR0TX = Field<18, 1>;    // DCS Short Read Zero parameter Transmission
            using DLWTX = Field<19, 1>;    // DCS Long Write Transmission
            using MRDPS = Field<24, 1>;    // Maximum Read Packet Size
        };

        // DSI Host Generic Header Configuration Register
        struct DSI_GHCR : public Register<0x40016c5c> {
            using DT = Field<0, 6>;    // Type
            using VCID = Field<6, 2>;    // Channel
            using WCLSB = Field<8, 8>;    // WordCount LSB
            using WCMSB = Field<16, 8>;    // WordCount MSB
        };

        // DSI Host Generic Payload Data Register
        struct DSI_GPDR : public Register<0x40016c60> {
            using DATA1 = Field<0, 8>;    // Payload Byte 1
            using DATA2 = Field<8, 8>;    // Payload Byte 2
            using DATA3 = Field<16, 8>;    // Payload Byte 3
            using DATA4 = Field<24, 8>;    // Payload Byte 4
        };

        // DSI Host Generic Packet Status Register
        struct DSI_GPSR : public Register<0x40016c64> {
            using CMDFE = Field<0, 1>;    // Command FIFO Empty
            using CMDFF = Field<1, 1>;    // Command FIFO Full
            using PWRFE = Field<2, 1>;    // Payload Write FIFO Empty
            using PWRFF = Field<3, 1>;    // Payload Write FIFO Full
            using PRDFE = Field<4, 1>;    // Payload Read FIFO Empty
            using PRDFF = Field<5, 1>;    // Payload Read FIFO Full
            using RCB = Field<6, 1>;    // Read Command Busy
        };

        // DSI Host Timeout Counter Configuration Register 0
        struct DSI_TCCR0 : public Register<0x40016c68> {
            using LPRX_TOCNT = Field<0, 16>;    // Low-power Reception Timeout Counter
            using HSTX_TOCNT = Field<16, 16>;    // High-Speed Transmission Timeout Counter
        };

        // DSI Host Timeout Counter Configuration Register 1
        struct DSI_TCCR1 : public Register<0x40016c6c> {
            using HSRD_TOCNT = Field<0, 16>;    // High-Speed Read Timeout Counter
        };

        // DSI Host Timeout Counter Configuration Register 2
        struct DSI_TCCR2 : public Register<0x40016c70> {
            using LPRD_TOCNT = Field<0, 16>;    // Low-Power Read Timeout Counter
        };

        // DSI Host Timeout Counter Configuration Register 3
        struct DSI_TCCR3 : public Register<0x40016c74> {
            using HSWR_TOCNT = Field<0, 16>;    // High-Speed Write Timeout Counter
            using PM = Field<24, 1>;    // Presp mode
        };

        // DSI Host Timeout Counter Configuration Register 4
        struct DSI_TCCR4 : public Register<0x40016c78> {
            using LSWR_TOCNT = Field<0, 16>;    // Low-Power Write Timeout Counter
        };

        // DSI Host Timeout Counter Configuration Register 5
        struct DSI_TCCR5 : public Register<0x40016c7c> {
            using BTA_TOCNT = Field<0, 16>;    // Bus-Turn-Around Timeout Counter
        };

        // DSI Host Clock Lane Configuration Register
        struct DSI_CLCR : public Register<0x40016c80> {
            using DPCC = Field<0, 1>;    // D-PHY Clock Control
            using ACR = Field<1, 1>;    // Automatic Clock lane Control
        };

        // DSI Host Clock Lane Timer Configuration Register
        struct DSI_CLTCR : public Register<0x40016c84> {
            using LP2HS_TIME = Field<0, 10>;    // Low-Power to High-Speed Time
            using HS2LP_TIME = Field<16, 10>;    // High-Speed to Low-Power Time
        };

        // DSI Host Data Lane Timer Configuration Register
        struct DSI_DLTRC : public Register<0x40016c88> {
            using MRD_TIME = Field<0, 15>;    // Maximum Read Time
            using LP2HS_TIME = Field<16, 8>;    // Low-Power To High-Speed Time
            using HS2LP_TIME = Field<24, 8>;    // High-Speed To Low-Power Time
        };

        // DSI Host PHY Control Register
        struct DSI_PCTLR : public Register<0x40016c8c> {
            using DEN = Field<1, 1>;    // Digital Enable
            using CKE = Field<2, 1>;    // Clock Enable
        };

        // DSI Host PHY Configuration Register
        struct DSI_PCONFR : public Register<0x40016c90> {
            using NL = Field<0, 2>;    // Number of Lanes
            using SW_TIME = Field<8, 8>;    // Stop Wait Time
        };

        // DSI Host PHY ULPS Control Register
        struct DSI_PUCR : public Register<0x40016c94> {
            using URCL = Field<0, 1>;    // ULPS Request on Clock Lane
            using UECL = Field<1, 1>;    // ULPS Exit on Clock Lane
            using URDL = Field<2, 1>;    // ULPS Request on Data Lane
            using UEDL = Field<3, 1>;    // ULPS Exit on Data Lane
        };

        // DSI Host PHY TX Triggers Configuration Register
        struct DSI_PTTCR : public Register<0x40016c98> {
            using TX_TRIG = Field<0, 4>;    // Transmission Trigger
        };

        // DSI Host PHY Status Register
        struct DSI_PSR : public Register<0x40016c9c> {
            using PD = Field<1, 1>;    // PHY Direction
            using PSSC = Field<2, 1>;    // PHY Stop State Clock lane
            using UANC = Field<3, 1>;    // ULPS Active Not Clock lane
            using PSS0 = Field<4, 1>;    // PHY Stop State lane 0
            using UAN0 = Field<5, 1>;    // ULPS Active Not lane 1
            using RUE0 = Field<6, 1>;    // RX ULPS Escape lane 0
            using PSS1 = Field<7, 1>;    // PHY Stop State lane 1
            using UAN1 = Field<8, 1>;    // ULPS Active Not lane 1
        };

        // DSI Host Interrupt & Status Register 0
        struct DSI_ISR0 : public Register<0x40016ca0> {
            using AE0 = Field<0, 1>;    // Acknowledge Error 0
            using AE1 = Field<1, 1>;    // Acknowledge Error 1
            using AE2 = Field<2, 1>;    // Acknowledge Error 2
            using AE3 = Field<3, 1>;    // Acknowledge Error 3
            using AE4 = Field<4, 1>;    // Acknowledge Error 4
            using AE5 = Field<5, 1>;    // Acknowledge Error 5
            using AE6 = Field<6, 1>;    // Acknowledge Error 6
            using AE7 = Field<7, 1>;    // Acknowledge Error 7
            using AE8 = Field<8, 1>;    // Acknowledge Error 8
            using AE9 = Field<9, 1>;    // Acknowledge Error 9
            using AE10 = Field<10, 1>;    // Acknowledge Error 10
            using AE11 = Field<11, 1>;    // Acknowledge Error 11
            using AE12 = Field<12, 1>;    // Acknowledge Error 12
            using AE13 = Field<13, 1>;    // Acknowledge Error 13
            using AE14 = Field<14, 1>;    // Acknowledge Error 14
            using AE15 = Field<15, 1>;    // Acknowledge Error 15
            using PE0 = Field<16, 1>;    // PHY Error 0
            using PE1 = Field<17, 1>;    // PHY Error 1
            using PE2 = Field<18, 1>;    // PHY Error 2
            using PE3 = Field<19, 1>;    // PHY Error 3
            using PE4 = Field<20, 1>;    // PHY Error 4
        };

        // DSI Host Interrupt & Status Register 1
        struct DSI_ISR1 : public Register<0x40016ca4> {
            using TOHSTX = Field<0, 1>;    // Timeout High-Speed Transmission
            using TOLPRX = Field<1, 1>;    // Timeout Low-Power Reception
            using ECCSE = Field<2, 1>;    // ECC Single-bit Error
            using ECCME = Field<3, 1>;    // ECC Multi-bit Error
            using CRCE = Field<4, 1>;    // CRC Error
            using PSE = Field<5, 1>;    // Packet Size Error
            using EOTPE = Field<6, 1>;    // EoTp Error
            using LPWRE = Field<7, 1>;    // LTDC Payload Write Error
            using GCWRE = Field<8, 1>;    // Generic Command Write Error
            using GPWRE = Field<9, 1>;    // Generic Payload Write Error
            using GPTXE = Field<10, 1>;    // Generic Payload Transmit Error
            using GPRDE = Field<11, 1>;    // Generic Payload Read Error
            using GPRXE = Field<12, 1>;    // Generic Payload Receive Error
        };

        // DSI Host Interrupt Enable Register 0
        struct DSI_IER0 : public Register<0x40016ca8> {
            using AE0IE = Field<0, 1>;    // Acknowledge Error 0 Interrupt Enable
            using AE1IE = Field<1, 1>;    // Acknowledge Error 1 Interrupt Enable
            using AE2IE = Field<2, 1>;    // Acknowledge Error 2 Interrupt Enable
            using AE3IE = Field<3, 1>;    // Acknowledge Error 3 Interrupt Enable
            using AE4IE = Field<4, 1>;    // Acknowledge Error 4 Interrupt Enable
            using AE5IE = Field<5, 1>;    // Acknowledge Error 5 Interrupt Enable
            using AE6IE = Field<6, 1>;    // Acknowledge Error 6 Interrupt Enable
            using AE7IE = Field<7, 1>;    // Acknowledge Error 7 Interrupt Enable
            using AE8IE = Field<8, 1>;    // Acknowledge Error 8 Interrupt Enable
            using AE9IE = Field<9, 1>;    // Acknowledge Error 9 Interrupt Enable
            using AE10IE = Field<10, 1>;    // Acknowledge Error 10 Interrupt Enable
            using AE11IE = Field<11, 1>;    // Acknowledge Error 11 Interrupt Enable
            using AE12IE = Field<12, 1>;    // Acknowledge Error 12 Interrupt Enable
            using AE13IE = Field<13, 1>;    // Acknowledge Error 13 Interrupt Enable
            using AE14IE = Field<14, 1>;    // Acknowledge Error 14 Interrupt Enable
            using AE15IE = Field<15, 1>;    // Acknowledge Error 15 Interrupt Enable
            using PE0IE = Field<16, 1>;    // PHY Error 0 Interrupt Enable
            using PE1IE = Field<17, 1>;    // PHY Error 1 Interrupt Enable
            using PE2IE = Field<18, 1>;    // PHY Error 2 Interrupt Enable
            using PE3IE = Field<19, 1>;    // PHY Error 3 Interrupt Enable
            using PE4IE = Field<20, 1>;    // PHY Error 4 Interrupt Enable
        };

        // DSI Host Interrupt Enable Register 1
        struct DSI_IER1 : public Register<0x40016cac> {
            using TOHSTXIE = Field<0, 1>;    // Timeout High-Speed Transmission Interrupt Enable
            using TOLPRXIE = Field<1, 1>;    // Timeout Low-Power Reception Interrupt Enable
            using ECCSEIE = Field<2, 1>;    // ECC Single-bit Error Interrupt Enable
            using ECCMEIE = Field<3, 1>;    // ECC Multi-bit Error Interrupt Enable
            using CRCEIE = Field<4, 1>;    // CRC Error Interrupt Enable
            using PSEIE = Field<5, 1>;    // Packet Size Error Interrupt Enable
            using EOTPEIE = Field<6, 1>;    // EoTp Error Interrupt Enable
            using LPWREIE = Field<7, 1>;    // LTDC Payload Write Error Interrupt Enable
            using GCWREIE = Field<8, 1>;    // Generic Command Write Error Interrupt Enable
            using GPWREIE = Field<9, 1>;    // Generic Payload Write Error Interrupt Enable
            using GPTXEIE = Field<10, 1>;    // Generic Payload Transmit Error Interrupt Enable
            using GPRDEIE = Field<11, 1>;    // Generic Payload Read Error Interrupt Enable
            using GPRXEIE = Field<12, 1>;    // Generic Payload Receive Error Interrupt Enable
        };

        // DSI Host Force Interrupt Register 0
        struct DSI_FIR0 : public Register<0x40016cb0> {
            using FAE0 = Field<0, 1>;    // Force Acknowledge Error 0
            using FAE1 = Field<1, 1>;    // Force Acknowledge Error 1
            using FAE2 = Field<2, 1>;    // Force Acknowledge Error 2
            using FAE3 = Field<3, 1>;    // Force Acknowledge Error 3
            using FAE4 = Field<4, 1>;    // Force Acknowledge Error 4
            using FAE5 = Field<5, 1>;    // Force Acknowledge Error 5
            using FAE6 = Field<6, 1>;    // Force Acknowledge Error 6
            using FAE7 = Field<7, 1>;    // Force Acknowledge Error 7
            using FAE8 = Field<8, 1>;    // Force Acknowledge Error 8
            using FAE9 = Field<9, 1>;    // Force Acknowledge Error 9
            using FAE10 = Field<10, 1>;    // Force Acknowledge Error 10
            using FAE11 = Field<11, 1>;    // Force Acknowledge Error 11
            using FAE12 = Field<12, 1>;    // Force Acknowledge Error 12
            using FAE13 = Field<13, 1>;    // Force Acknowledge Error 13
            using FAE14 = Field<14, 1>;    // Force Acknowledge Error 14
            using FAE15 = Field<15, 1>;    // Force Acknowledge Error 15
            using FPE0 = Field<16, 1>;    // Force PHY Error 0
            using FPE1 = Field<17, 1>;    // Force PHY Error 1
            using FPE2 = Field<18, 1>;    // Force PHY Error 2
            using FPE3 = Field<19, 1>;    // Force PHY Error 3
            using FPE4 = Field<20, 1>;    // Force PHY Error 4
        };

        // DSI Host Force Interrupt Register 1
        struct DSI_FIR1 : public Register<0x40016cb4> {
            using FTOHSTX = Field<0, 1>;    // Force Timeout High-Speed Transmission
            using FTOLPRX = Field<1, 1>;    // Force Timeout Low-Power Reception
            using FECCSE = Field<2, 1>;    // Force ECC Single-bit Error
            using FECCME = Field<3, 1>;    // Force ECC Multi-bit Error
            using FCRCE = Field<4, 1>;    // Force CRC Error
            using FPSE = Field<5, 1>;    // Force Packet Size Error
            using FEOTPE = Field<6, 1>;    // Force EoTp Error
            using FLPWRE = Field<7, 1>;    // Force LTDC Payload Write Error
            using FGCWRE = Field<8, 1>;    // Force Generic Command Write Error
            using FGPWRE = Field<9, 1>;    // Force Generic Payload Write Error
            using FGPTXE = Field<10, 1>;    // Force Generic Payload Transmit Error
            using FGPRDE = Field<11, 1>;    // Force Generic Payload Read Error
            using FGPRXE = Field<12, 1>;    // Force Generic Payload Receive Error
        };

        // DSI Host Video Shadow Control Register
        struct DSI_VSCR : public Register<0x40016cb8> {
            using EN = Field<0, 1>;    // Enable
            using UR = Field<8, 1>;    // Update Register
        };

        // DSI Host LTDC Current VCID Register
        struct DSI_LCVCIDR : public Register<0x40016cbc> {
            using VCID = Field<0, 2>;    // Virtual Channel ID
        };

        // DSI Host LTDC Current Color Coding Register
        struct DSI_LCCCR : public Register<0x40016cc0> {
            using COLC = Field<0, 4>;    // Color Coding
            using LPE = Field<8, 1>;    // Loosely Packed Enable
        };

        // DSI Host Low-Power mode Current Configuration Register
        struct DSI_LPMCCR : public Register<0x40016cc4> {
            using VLPSIZE = Field<0, 8>;    // VACT Largest Packet Size
            using LPSIZE = Field<16, 8>;    // Largest Packet Size
        };

        // DSI Host Video mode Current Configuration Register
        struct DSI_VMCCR : public Register<0x40016cc8> {
            using VMT = Field<0, 2>;    // Video mode Type
            using LPVSAE = Field<2, 1>;    // Low-Power Vertical Sync time Enable
            using LPVBPE = Field<3, 1>;    // Low-power Vertical Back-Porch Enable
            using LPVFPE = Field<4, 1>;    // Low-power Vertical Front-Porch Enable
            using LPVAE = Field<5, 1>;    // Low-Power Vertical Active Enable
            using LPHBPE = Field<6, 1>;    // Low-power Horizontal Back-Porch Enable
            using LPHFE = Field<7, 1>;    // Low-Power Horizontal Front-Porch Enable
            using FBTAAE = Field<8, 1>;    // Frame BTA Acknowledge Enable
            using LPCE = Field<9, 1>;    // Low-Power Command Enable
        };

        // DSI Host Video Packet Current Configuration Register
        struct DSI_VPCCR : public Register<0x40016ccc> {
            using VPSIZE = Field<0, 14>;    // Video Packet Size
        };

        // DSI Host Video Chunks Current Configuration Register
        struct DSI_VCCCR : public Register<0x40016cd0> {
            using NUMC = Field<0, 13>;    // Number of Chunks
        };

        // DSI Host Video Null Packet Current Configuration Register
        struct DSI_VNPCCR : public Register<0x40016cd4> {
            using NPSIZE = Field<0, 13>;    // Null Packet Size
        };

        // DSI Host Video HSA Current Configuration Register
        struct DSI_VHSACCR : public Register<0x40016cd8> {
            using HSA = Field<0, 12>;    // Horizontal Synchronism Active duration
        };

        // DSI Host Video HBP Current Configuration Register
        struct DSI_VHBPCCR : public Register<0x40016cdc> {
            using HBP = Field<0, 12>;    // Horizontal Back-Porch duration
        };

        // DSI Host Video Line Current Configuration Register
        struct DSI_VLCCR : public Register<0x40016ce0> {
            using HLINE = Field<0, 15>;    // Horizontal Line duration
        };

        // DSI Host Video VSA Current Configuration Register
        struct DSI_VVSACCR : public Register<0x40016ce4> {
            using VSA = Field<0, 10>;    // Vertical Synchronism Active duration
        };

        // DSI Host Video VBP Current Configuration Register
        struct DSI_VVBPCCR : public Register<0x40016ce8> {
            using VBP = Field<0, 10>;    // Vertical Back-Porch duration
        };

        // DSI Host Video VFP Current Configuration Register
        struct DSI_VVFPCCR : public Register<0x40016cec> {
            using VFP = Field<0, 10>;    // Vertical Front-Porch duration
        };

        // DSI Host Video VA Current Configuration Register
        struct DSI_VVACCR : public Register<0x40016cf0> {
            using VA = Field<0, 14>;    // Vertical Active duration
        };

        // DSI Wrapper Configuration Register
        struct DSI_WCFGR : public Register<0x40017000> {
            using VSPOL = Field<7, 1>;    // VSync Polarity
            using AR = Field<6, 1>;    // Automatic Refresh
            using TEPOL = Field<5, 1>;    // TE Polarity
            using TESRC = Field<4, 1>;    // TE Source
            using COLMUX = Field<1, 3>;    // Color Multiplexing
            using DSIM = Field<0, 1>;    // DSI Mode
        };

        // DSI Wrapper Control Register
        struct DSI_WCR : public Register<0x40017004> {
            using DSIEN = Field<3, 1>;    // DSI Enable
            using LTDCEN = Field<2, 1>;    // LTDC Enable
            using SHTDN = Field<1, 1>;    // Shutdown
            using COLM = Field<0, 1>;    // Color Mode
        };

        // DSI Wrapper Interrupt Enable Register
        struct DSI_WIER : public Register<0x40017008> {
            using RRIE = Field<13, 1>;    // Regulator Ready Interrupt Enable
            using PLLUIE = Field<10, 1>;    // PLL Unlock Interrupt Enable
            using PLLLIE = Field<9, 1>;    // PLL Lock Interrupt Enable
            using ERIE = Field<1, 1>;    // End of Refresh Interrupt Enable
            using TEIE = Field<0, 1>;    // Tearing Effect Interrupt Enable
        };

        // DSI Wrapper Interrupt & Status Register
        struct DSI_WISR : public Register<0x4001700c> {
            using RRIF = Field<13, 1>;    // Regulator Ready Interrupt Flag
            using RRS = Field<12, 1>;    // Regulator Ready Status
            using PLLUIF = Field<10, 1>;    // PLL Unlock Interrupt Flag
            using PLLLIF = Field<9, 1>;    // PLL Lock Interrupt Flag
            using PLLLS = Field<8, 1>;    // PLL Lock Status
            using BUSY = Field<2, 1>;    // Busy Flag
            using ERIF = Field<1, 1>;    // End of Refresh Interrupt Flag
            using TEIF = Field<0, 1>;    // Tearing Effect Interrupt Flag
        };

        // DSI Wrapper Interrupt Flag Clear Register
        struct DSI_WIFCR : public Register<0x40017010> {
            using CRRIF = Field<13, 1>;    // Clear Regulator Ready Interrupt Flag
            using CPLLUIF = Field<10, 1>;    // Clear PLL Unlock Interrupt Flag
            using CPLLLIF = Field<9, 1>;    // Clear PLL Lock Interrupt Flag
            using CERIF = Field<1, 1>;    // Clear End of Refresh Interrupt Flag
            using CTEIF = Field<0, 1>;    // Clear Tearing Effect Interrupt Flag
        };

        // DSI Wrapper PHY Configuration Register 1
        struct DSI_WPCR1 : public Register<0x40017018> {
            using TCLKPOSTEN = Field<27, 1>;    // custom time for tCLK-POST Enable
            using TLPXCEN = Field<26, 1>;    // custom time for tLPX for Clock lane Enable
            using THSEXITEN = Field<25, 1>;    // custom time for tHS-EXIT Enable
            using TLPXDEN = Field<24, 1>;    // custom time for tLPX for Data lanes Enable
            using THSZEROEN = Field<23, 1>;    // custom time for tHS-ZERO Enable
            using THSTRAILEN = Field<22, 1>;    // custom time for tHS-TRAIL Enable
            using THSPREPEN = Field<21, 1>;    // custom time for tHS-PREPARE Enable
            using TCLKZEROEN = Field<20, 1>;    // custom time for tCLK-ZERO Enable
            using TCLKPREPEN = Field<19, 1>;    // custom time for tCLK-PREPARE Enable
            using PDEN = Field<18, 1>;    // Pull-Down Enable
            using TDDL = Field<16, 1>;    // Turn Disable Data Lanes
            using CDOFFDL = Field<14, 1>;    // Contention Detection OFF on Data Lanes
            using FTXSMDL = Field<13, 1>;    // Force in TX Stop Mode the Data Lanes
            using FTXSMCL = Field<12, 1>;    // Force in TX Stop Mode the Clock Lane
            using HSIDL1 = Field<11, 1>;    // Invert the High-Speed data signal on Data Lane 1
            using HSIDL0 = Field<10, 1>;    // Invert the Hight-Speed data signal on Data Lane 0
            using HSICL = Field<9, 1>;    // Invert Hight-Speed data signal on Clock Lane
            using SWDL1 = Field<8, 1>;    // Swap Data Lane 1 pins
            using SWDL0 = Field<7, 1>;    // Swap Data Lane 0 pins
            using SWCL = Field<6, 1>;    // Swap Clock Lane pins
            using UIX4 = Field<0, 6>;    // Unit Interval multiplied by 4
        };

        // DSI Wrapper PHY Configuration Register 2
        struct DSI_WPCR2 : public Register<0x4001701c> {
            using LPRXFT = Field<25, 2>;    // Low-Power RX low-pass Filtering Tuning
            using FLPRXLPM = Field<22, 1>;    // Forces LP Receiver in Low-Power Mode
            using HSTXSRCDL = Field<18, 2>;    // High-Speed Transmission Slew Rate Control on Data Lanes
            using HSTXSRCCL = Field<16, 2>;    // High-Speed Transmission Slew Rate Control on Clock Lane
            using SDCC = Field<12, 1>;    // SDD Control
            using LPSRDL = Field<8, 2>;    // Low-Power transmission Slew Rate Compensation on Data Lanes
            using LPSRCL = Field<6, 2>;    // Low-Power transmission Slew Rate Compensation on Clock Lane
            using HSTXDLL = Field<2, 2>;    // High-Speed Transmission Delay on Data Lanes
            using HSTXDCL = Field<0, 2>;    // High-Speed Transmission Delay on Clock Lane
        };

        // DSI Wrapper PHY Configuration Register 3
        struct DSI_WPCR3 : public Register<0x40017020> {
            using THSTRAIL = Field<24, 8>;    // tHSTRAIL
            using THSPREP = Field<16, 8>;    // tHS-PREPARE
            using TCLKZEO = Field<8, 8>;    // tCLK-ZERO
            using TCLKPREP = Field<0, 8>;    // tCLK-PREPARE
        };

        // DSI_WPCR4
        struct DSI_WPCR4 : public Register<0x40017024> {
            using TLPXC = Field<24, 8>;    // tLPXC for Clock lane
            using THSEXIT = Field<16, 8>;    // tHSEXIT
            using TLPXD = Field<8, 8>;    // tLPX for Data lanes
            using THSZERO = Field<0, 8>;    // tHS-ZERO
        };

        // DSI Wrapper PHY Configuration Register 5
        struct DSI_WPCR5 : public Register<0x40017028> {
            using THSZERO = Field<0, 8>;    // tCLK-POST
        };

        // DSI Wrapper Regulator and PLL Control Register
        struct DSI_WRPCR : public Register<0x40017030> {
            using REGEN = Field<24, 1>;    // Regulator Enable
            using ODF = Field<16, 2>;    // PLL Output Division Factor
            using IDF = Field<11, 4>;    // PLL Input Division Factor
            using NDIV = Field<2, 7>;    // PLL Loop Division Factor
            using PLLEN = Field<0, 1>;    // PLL Enable
        };

    };

    // Graphic MMU
    struct GFXMMU {
        // Graphic MMU configuration register
        struct CR : public Register<0x4002c000> {
            using B0OIE = Field<0, 1>;    // Buffer 0 overflow interrupt enable
            using B1OIE = Field<1, 1>;    // Buffer 1 overflow interrupt enable
            using B2OIE = Field<2, 1>;    // Buffer 2 overflow interrupt enable
            using B3OIE = Field<3, 1>;    // Buffer 3 overflow interrupt enable
            using AMEIE = Field<4, 1>;    // AHB master error interrupt enable
            using BM192 = Field<6, 1>;    // 192 Block mode
        };

        // Graphic MMU status register
        struct SR : public Register<0x4002c004> {
            using B0OF = Field<0, 1>;    // Buffer 0 overflow flag
            using B1OF = Field<1, 1>;    // Buffer 1 overflow flag
            using B2OF = Field<2, 1>;    // Buffer 2 overflow flag
            using B3OF = Field<3, 1>;    // Buffer 3 overflow flag
            using AMEF = Field<4, 1>;    // AHB master error flag
        };

        // Graphic MMU flag clear register
        struct FCR : public Register<0x4002c008> {
            using CB0OF = Field<0, 1>;    // Clear buffer 0 overflow flag
            using CB1OF = Field<1, 1>;    // Clear buffer 1 overflow flag
            using CB2OF = Field<2, 1>;    // Clear buffer 2 overflow flag
            using CB3OF = Field<3, 1>;    // Clear buffer 3 overflow flag
            using CAMEF = Field<4, 1>;    // Clear AHB master error flag
        };

        // Graphic MMU default value register
        struct DVR : public Register<0x4002c010> {
            using DV = Field<0, 32>;    // Default value
        };

        // Graphic MMU buffer 0 configuration register
        struct B0CR : public Register<0x4002c020> {
            using PBO = Field<4, 19>;    // Physical buffer offset
            using PBBA = Field<23, 9>;    // Physical buffer base address
        };

        // Graphic MMU buffer 1 configuration register
        struct B1CR : public Register<0x4002c024> {
            using PBO = Field<4, 19>;    // Physical buffer offset
            using PBBA = Field<23, 9>;    // Physical buffer base address
        };

        // Graphic MMU buffer 2 configuration register
        struct B2CR : public Register<0x4002c028> {
            using PBO = Field<4, 19>;    // Physical buffer offset
            using PBBA = Field<23, 9>;    // Physical buffer base address
        };

        // Graphic MMU buffer 3 configuration register
        struct B3CR : public Register<0x4002c02c> {
            using PBO = Field<4, 19>;    // Physical buffer offset
            using PBBA = Field<23, 9>;    // Physical buffer base address
        };

        // Graphic MMU version register
        struct VERR : public Register<0x4002cff4> {
            using MINREV = Field<0, 4>;    // Minor revision
            using MAJREV = Field<4, 4>;    // Major revision
        };

        // Graphic MMU identification register
        struct IPIDR : public Register<0x4002cff8> {
            using ID = Field<0, 32>;    // Identification Code
        };

        // Graphic MMU size identification register
        struct SIDR : public Register<0x4002cffc> {
            using SID = Field<0, 32>;    // Size and ID
        };

        // Graphic MMU LUT entry 0 low
        struct LUT0L : public Register<0x4002d000> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1 low
        struct LUT1L : public Register<0x4002d008> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 2 low
        struct LUT2L : public Register<0x4002d010> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 3 low
        struct LUT3L : public Register<0x4002d018> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 4 low
        struct LUT4L : public Register<0x4002d020> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 5 low
        struct LUT5L : public Register<0x4002d028> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 6 low
        struct LUT6L : public Register<0x4002d030> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 7 low
        struct LUT7L : public Register<0x4002d038> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 8 low
        struct LUT8L : public Register<0x4002d040> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 9 low
        struct LUT9L : public Register<0x4002d048> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 10 low
        struct LUT10L : public Register<0x4002d050> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 11 low
        struct LUT11L : public Register<0x4002d058> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 12 low
        struct LUT12L : public Register<0x4002d060> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 13 low
        struct LUT13L : public Register<0x4002d068> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 14 low
        struct LUT14L : public Register<0x4002d070> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 15 low
        struct LUT15L : public Register<0x4002d078> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 16 low
        struct LUT16L : public Register<0x4002d080> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 17 low
        struct LUT17L : public Register<0x4002d088> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 18 low
        struct LUT18L : public Register<0x4002d090> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 19 low
        struct LUT19L : public Register<0x4002d098> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 20 low
        struct LUT20L : public Register<0x4002d0a0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 21 low
        struct LUT21L : public Register<0x4002d0a8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 22 low
        struct LUT22L : public Register<0x4002d0b0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 23 low
        struct LUT23L : public Register<0x4002d0b8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 24 low
        struct LUT24L : public Register<0x4002d0c0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 25 low
        struct LUT25L : public Register<0x4002d0c8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 26 low
        struct LUT26L : public Register<0x4002d0d0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 27 low
        struct LUT27L : public Register<0x4002d0d8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 28 low
        struct LUT28L : public Register<0x4002d0e0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 29 low
        struct LUT29L : public Register<0x4002d0e8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 30 low
        struct LUT30L : public Register<0x4002d0f0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 31 low
        struct LUT31L : public Register<0x4002d0f8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 32 low
        struct LUT32L : public Register<0x4002d100> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 33 low
        struct LUT33L : public Register<0x4002d108> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 34 low
        struct LUT34L : public Register<0x4002d110> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 35 low
        struct LUT35L : public Register<0x4002d118> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 36 low
        struct LUT36L : public Register<0x4002d120> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 37 low
        struct LUT37L : public Register<0x4002d128> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 38 low
        struct LUT38L : public Register<0x4002d130> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 39 low
        struct LUT39L : public Register<0x4002d138> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 40 low
        struct LUT40L : public Register<0x4002d140> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 41 low
        struct LUT41L : public Register<0x4002d148> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 42 low
        struct LUT42L : public Register<0x4002d150> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 43 low
        struct LUT43L : public Register<0x4002d158> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 44 low
        struct LUT44L : public Register<0x4002d160> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 45 low
        struct LUT45L : public Register<0x4002d168> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 46 low
        struct LUT46L : public Register<0x4002d170> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 47 low
        struct LUT47L : public Register<0x4002d178> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 48 low
        struct LUT48L : public Register<0x4002d180> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 49 low
        struct LUT49L : public Register<0x4002d188> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 50 low
        struct LUT50L : public Register<0x4002d190> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 51 low
        struct LUT51L : public Register<0x4002d198> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 52 low
        struct LUT52L : public Register<0x4002d1a0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 53 low
        struct LUT53L : public Register<0x4002d1a8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 54 low
        struct LUT54L : public Register<0x4002d1b0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 55 low
        struct LUT55L : public Register<0x4002d1b8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 56 low
        struct LUT56L : public Register<0x4002d1c0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 57 low
        struct LUT57L : public Register<0x4002d1c8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 58 low
        struct LUT58L : public Register<0x4002d1d0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 59 low
        struct LUT59L : public Register<0x4002d1d8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 60 low
        struct LUT60L : public Register<0x4002d1e0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 61 low
        struct LUT61L : public Register<0x4002d1e8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 62 low
        struct LUT62L : public Register<0x4002d1f0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 63 low
        struct LUT63L : public Register<0x4002d1f8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 64 low
        struct LUT64L : public Register<0x4002d200> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 65 low
        struct LUT65L : public Register<0x4002d208> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 66 low
        struct LUT66L : public Register<0x4002d210> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 67 low
        struct LUT67L : public Register<0x4002d218> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 68 low
        struct LUT68L : public Register<0x4002d220> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 69 low
        struct LUT69L : public Register<0x4002d228> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 70 low
        struct LUT70L : public Register<0x4002d230> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 71 low
        struct LUT71L : public Register<0x4002d238> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 72 low
        struct LUT72L : public Register<0x4002d240> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 73 low
        struct LUT73L : public Register<0x4002d248> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 74 low
        struct LUT74L : public Register<0x4002d250> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 75 low
        struct LUT75L : public Register<0x4002d258> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 76 low
        struct LUT76L : public Register<0x4002d260> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 77 low
        struct LUT77L : public Register<0x4002d268> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 78 low
        struct LUT78L : public Register<0x4002d270> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 79 low
        struct LUT79L : public Register<0x4002d278> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 80 low
        struct LUT80L : public Register<0x4002d280> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 81 low
        struct LUT81L : public Register<0x4002d288> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 82 low
        struct LUT82L : public Register<0x4002d290> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 83 low
        struct LUT83L : public Register<0x4002d298> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 84 low
        struct LUT84L : public Register<0x4002d2a0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 85 low
        struct LUT85L : public Register<0x4002d2a8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 86 low
        struct LUT86L : public Register<0x4002d2b0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 87 low
        struct LUT87L : public Register<0x4002d2b8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 88 low
        struct LUT88L : public Register<0x4002d2c0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 89 low
        struct LUT89L : public Register<0x4002d2c8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 90 low
        struct LUT90L : public Register<0x4002d2d0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 91 low
        struct LUT91L : public Register<0x4002d2d8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 92 low
        struct LUT92L : public Register<0x4002d2e0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 93 low
        struct LUT93L : public Register<0x4002d2e8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 94 low
        struct LUT94L : public Register<0x4002d2f0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 95 low
        struct LUT95L : public Register<0x4002d2f8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 96 low
        struct LUT96L : public Register<0x4002d300> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 97 low
        struct LUT97L : public Register<0x4002d308> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 98 low
        struct LUT98L : public Register<0x4002d310> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 99 low
        struct LUT99L : public Register<0x4002d318> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 100 low
        struct LUT100L : public Register<0x4002d320> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 101 low
        struct LUT101L : public Register<0x4002d328> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 102 low
        struct LUT102L : public Register<0x4002d330> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 103 low
        struct LUT103L : public Register<0x4002d338> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 104 low
        struct LUT104L : public Register<0x4002d340> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 105 low
        struct LUT105L : public Register<0x4002d348> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 106 low
        struct LUT106L : public Register<0x4002d350> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 107 low
        struct LUT107L : public Register<0x4002d358> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 108 low
        struct LUT108L : public Register<0x4002d360> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 109 low
        struct LUT109L : public Register<0x4002d368> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 110 low
        struct LUT110L : public Register<0x4002d370> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 111 low
        struct LUT111L : public Register<0x4002d378> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 112 low
        struct LUT112L : public Register<0x4002d380> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 113 low
        struct LUT113L : public Register<0x4002d388> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 114 low
        struct LUT114L : public Register<0x4002d390> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 115 low
        struct LUT115L : public Register<0x4002d398> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 116 low
        struct LUT116L : public Register<0x4002d3a0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 117 low
        struct LUT117L : public Register<0x4002d3a8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 118 low
        struct LUT118L : public Register<0x4002d3b0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 119 low
        struct LUT119L : public Register<0x4002d3b8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 120 low
        struct LUT120L : public Register<0x4002d3c0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 121 low
        struct LUT121L : public Register<0x4002d3c8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 122 low
        struct LUT122L : public Register<0x4002d3d0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 123 low
        struct LUT123L : public Register<0x4002d3d8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 124 low
        struct LUT124L : public Register<0x4002d3e0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 125 low
        struct LUT125L : public Register<0x4002d3e8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 126 low
        struct LUT126L : public Register<0x4002d3f0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 127 low
        struct LUT127L : public Register<0x4002d3f8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 128 low
        struct LUT128L : public Register<0x4002d400> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 129 low
        struct LUT129L : public Register<0x4002d408> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 130 low
        struct LUT130L : public Register<0x4002d410> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 131 low
        struct LUT131L : public Register<0x4002d418> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 132 low
        struct LUT132L : public Register<0x4002d420> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 133 low
        struct LUT133L : public Register<0x4002d428> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 134 low
        struct LUT134L : public Register<0x4002d430> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 135 low
        struct LUT135L : public Register<0x4002d438> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 136 low
        struct LUT136L : public Register<0x4002d440> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 137 low
        struct LUT137L : public Register<0x4002d448> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 138 low
        struct LUT138L : public Register<0x4002d450> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 139 low
        struct LUT139L : public Register<0x4002d458> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 140 low
        struct LUT140L : public Register<0x4002d460> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 141 low
        struct LUT141L : public Register<0x4002d468> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 142 low
        struct LUT142L : public Register<0x4002d470> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 143 low
        struct LUT143L : public Register<0x4002d478> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 144 low
        struct LUT144L : public Register<0x4002d480> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 145 low
        struct LUT145L : public Register<0x4002d488> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 146 low
        struct LUT146L : public Register<0x4002d490> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 147 low
        struct LUT147L : public Register<0x4002d498> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 148 low
        struct LUT148L : public Register<0x4002d4a0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 149 low
        struct LUT149L : public Register<0x4002d4a8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 150 low
        struct LUT150L : public Register<0x4002d4b0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 151 low
        struct LUT151L : public Register<0x4002d4b8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 152 low
        struct LUT152L : public Register<0x4002d4c0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 153 low
        struct LUT153L : public Register<0x4002d4c8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 154 low
        struct LUT154L : public Register<0x4002d4d0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 155 low
        struct LUT155L : public Register<0x4002d4d8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 156 low
        struct LUT156L : public Register<0x4002d4e0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 157 low
        struct LUT157L : public Register<0x4002d4e8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 158 low
        struct LUT158L : public Register<0x4002d4f0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 159 low
        struct LUT159L : public Register<0x4002d4f8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 160 low
        struct LUT160L : public Register<0x4002d500> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 161 low
        struct LUT161L : public Register<0x4002d508> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 162 low
        struct LUT162L : public Register<0x4002d510> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 163 low
        struct LUT163L : public Register<0x4002d518> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 164 low
        struct LUT164L : public Register<0x4002d520> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 165 low
        struct LUT165L : public Register<0x4002d528> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 166 low
        struct LUT166L : public Register<0x4002d530> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 167 low
        struct LUT167L : public Register<0x4002d538> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 168 low
        struct LUT168L : public Register<0x4002d540> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 169 low
        struct LUT169L : public Register<0x4002d548> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 170 low
        struct LUT170L : public Register<0x4002d550> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 171 low
        struct LUT171L : public Register<0x4002d558> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 172 low
        struct LUT172L : public Register<0x4002d560> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 173 low
        struct LUT173L : public Register<0x4002d568> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 174 low
        struct LUT174L : public Register<0x4002d570> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 175 low
        struct LUT175L : public Register<0x4002d578> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 176 low
        struct LUT176L : public Register<0x4002d580> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 177 low
        struct LUT177L : public Register<0x4002d588> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 178 low
        struct LUT178L : public Register<0x4002d590> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 179 low
        struct LUT179L : public Register<0x4002d598> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 180 low
        struct LUT180L : public Register<0x4002d5a0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 181 low
        struct LUT181L : public Register<0x4002d5a8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 182 low
        struct LUT182L : public Register<0x4002d5b0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 183 low
        struct LUT183L : public Register<0x4002d5b8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 184 low
        struct LUT184L : public Register<0x4002d5c0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 185 low
        struct LUT185L : public Register<0x4002d5c8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 186 low
        struct LUT186L : public Register<0x4002d5d0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 187 low
        struct LUT187L : public Register<0x4002d5d8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 188 low
        struct LUT188L : public Register<0x4002d5e0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 189 low
        struct LUT189L : public Register<0x4002d5e8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 190 low
        struct LUT190L : public Register<0x4002d5f0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 191 low
        struct LUT191L : public Register<0x4002d5f8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 192 low
        struct LUT192L : public Register<0x4002d600> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 193 low
        struct LUT193L : public Register<0x4002d608> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 194 low
        struct LUT194L : public Register<0x4002d610> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 195 low
        struct LUT195L : public Register<0x4002d618> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 196 low
        struct LUT196L : public Register<0x4002d620> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 197 low
        struct LUT197L : public Register<0x4002d628> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 198 low
        struct LUT198L : public Register<0x4002d630> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 199 low
        struct LUT199L : public Register<0x4002d638> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 200 low
        struct LUT200L : public Register<0x4002d640> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 201 low
        struct LUT201L : public Register<0x4002d648> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 202 low
        struct LUT202L : public Register<0x4002d650> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 203 low
        struct LUT203L : public Register<0x4002d658> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 204 low
        struct LUT204L : public Register<0x4002d660> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 205 low
        struct LUT205L : public Register<0x4002d668> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 206 low
        struct LUT206L : public Register<0x4002d670> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 207 low
        struct LUT207L : public Register<0x4002d678> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 208 low
        struct LUT208L : public Register<0x4002d680> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 209 low
        struct LUT209L : public Register<0x4002d688> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 210 low
        struct LUT210L : public Register<0x4002d690> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 211 low
        struct LUT211L : public Register<0x4002d698> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 212 low
        struct LUT212L : public Register<0x4002d6a0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 213 low
        struct LUT213L : public Register<0x4002d6a8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 214 low
        struct LUT214L : public Register<0x4002d6b0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 215 low
        struct LUT215L : public Register<0x4002d6b8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 216 low
        struct LUT216L : public Register<0x4002d6c0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 217 low
        struct LUT217L : public Register<0x4002d6c8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 218 low
        struct LUT218L : public Register<0x4002d6d0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 219 low
        struct LUT219L : public Register<0x4002d6d8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 220 low
        struct LUT220L : public Register<0x4002d6e0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 221 low
        struct LUT221L : public Register<0x4002d6e8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 222 low
        struct LUT222L : public Register<0x4002d6f0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 223 low
        struct LUT223L : public Register<0x4002d6f8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 224 low
        struct LUT224L : public Register<0x4002d700> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 225 low
        struct LUT225L : public Register<0x4002d708> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 226 low
        struct LUT226L : public Register<0x4002d710> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 227 low
        struct LUT227L : public Register<0x4002d718> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 228 low
        struct LUT228L : public Register<0x4002d720> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 229 low
        struct LUT229L : public Register<0x4002d728> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 230 low
        struct LUT230L : public Register<0x4002d730> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 231 low
        struct LUT231L : public Register<0x4002d738> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 232 low
        struct LUT232L : public Register<0x4002d740> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 233 low
        struct LUT233L : public Register<0x4002d748> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 234 low
        struct LUT234L : public Register<0x4002d750> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 235 low
        struct LUT235L : public Register<0x4002d758> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 236 low
        struct LUT236L : public Register<0x4002d760> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 237 low
        struct LUT237L : public Register<0x4002d768> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 238 low
        struct LUT238L : public Register<0x4002d770> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 239 low
        struct LUT239L : public Register<0x4002d778> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 240 low
        struct LUT240L : public Register<0x4002d780> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 241 low
        struct LUT241L : public Register<0x4002d788> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 242 low
        struct LUT242L : public Register<0x4002d790> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 243 low
        struct LUT243L : public Register<0x4002d798> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 244 low
        struct LUT244L : public Register<0x4002d7a0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 245 low
        struct LUT245L : public Register<0x4002d7a8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 246 low
        struct LUT246L : public Register<0x4002d7b0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 247 low
        struct LUT247L : public Register<0x4002d7b8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 248 low
        struct LUT248L : public Register<0x4002d7c0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 249 low
        struct LUT249L : public Register<0x4002d7c8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 250 low
        struct LUT250L : public Register<0x4002d7d0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 251 low
        struct LUT251L : public Register<0x4002d7d8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 252 low
        struct LUT252L : public Register<0x4002d7e0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 253 low
        struct LUT253L : public Register<0x4002d7e8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 254 low
        struct LUT254L : public Register<0x4002d7f0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 255 low
        struct LUT255L : public Register<0x4002d7f8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 256 low
        struct LUT256L : public Register<0x4002d800> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 257 low
        struct LUT257L : public Register<0x4002d808> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 258 low
        struct LUT258L : public Register<0x4002d810> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 259 low
        struct LUT259L : public Register<0x4002d818> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 260 low
        struct LUT260L : public Register<0x4002d820> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 261 low
        struct LUT261L : public Register<0x4002d828> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 262 low
        struct LUT262L : public Register<0x4002d830> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 263 low
        struct LUT263L : public Register<0x4002d838> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 264 low
        struct LUT264L : public Register<0x4002d840> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 265 low
        struct LUT265L : public Register<0x4002d848> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 266 low
        struct LUT266L : public Register<0x4002d850> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 267 low
        struct LUT267L : public Register<0x4002d858> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 268 low
        struct LUT268L : public Register<0x4002d860> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 269 low
        struct LUT269L : public Register<0x4002d868> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 270 low
        struct LUT270L : public Register<0x4002d870> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 271 low
        struct LUT271L : public Register<0x4002d878> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 272 low
        struct LUT272L : public Register<0x4002d880> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 273 low
        struct LUT273L : public Register<0x4002d888> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 274 low
        struct LUT274L : public Register<0x4002d890> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 275 low
        struct LUT275L : public Register<0x4002d898> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 276 low
        struct LUT276L : public Register<0x4002d8a0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 277 low
        struct LUT277L : public Register<0x4002d8a8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 278 low
        struct LUT278L : public Register<0x4002d8b0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 279 low
        struct LUT279L : public Register<0x4002d8b8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 280 low
        struct LUT280L : public Register<0x4002d8c0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 281 low
        struct LUT281L : public Register<0x4002d8c8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 282 low
        struct LUT282L : public Register<0x4002d8d0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 283 low
        struct LUT283L : public Register<0x4002d8d8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 284 low
        struct LUT284L : public Register<0x4002d8e0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 285 low
        struct LUT285L : public Register<0x4002d8e8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 286 low
        struct LUT286L : public Register<0x4002d8f0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 287 low
        struct LUT287L : public Register<0x4002d8f8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 288 low
        struct LUT288L : public Register<0x4002d900> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 289 low
        struct LUT289L : public Register<0x4002d908> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 290 low
        struct LUT290L : public Register<0x4002d910> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 291 low
        struct LUT291L : public Register<0x4002d918> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 292 low
        struct LUT292L : public Register<0x4002d920> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 293 low
        struct LUT293L : public Register<0x4002d928> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 294 low
        struct LUT294L : public Register<0x4002d930> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 295 low
        struct LUT295L : public Register<0x4002d938> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 296 low
        struct LUT296L : public Register<0x4002d940> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 297 low
        struct LUT297L : public Register<0x4002d948> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 298 low
        struct LUT298L : public Register<0x4002d950> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 299 low
        struct LUT299L : public Register<0x4002d958> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 300 low
        struct LUT300L : public Register<0x4002d960> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 301 low
        struct LUT301L : public Register<0x4002d968> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 302 low
        struct LUT302L : public Register<0x4002d970> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 303 low
        struct LUT303L : public Register<0x4002d978> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 304 low
        struct LUT304L : public Register<0x4002d980> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 305 low
        struct LUT305L : public Register<0x4002d988> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 306 low
        struct LUT306L : public Register<0x4002d990> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 307 low
        struct LUT307L : public Register<0x4002d998> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 308 low
        struct LUT308L : public Register<0x4002d9a0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 309 low
        struct LUT309L : public Register<0x4002d9a8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 310 low
        struct LUT310L : public Register<0x4002d9b0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 311 low
        struct LUT311L : public Register<0x4002d9b8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 312 low
        struct LUT312L : public Register<0x4002d9c0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 313 low
        struct LUT313L : public Register<0x4002d9c8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 314 low
        struct LUT314L : public Register<0x4002d9d0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 315 low
        struct LUT315L : public Register<0x4002d9d8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 316 low
        struct LUT316L : public Register<0x4002d9e0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 317 low
        struct LUT317L : public Register<0x4002d9e8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 318 low
        struct LUT318L : public Register<0x4002d9f0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 319 low
        struct LUT319L : public Register<0x4002d9f8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 320 low
        struct LUT320L : public Register<0x4002da00> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 321 low
        struct LUT321L : public Register<0x4002da08> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 322 low
        struct LUT322L : public Register<0x4002da10> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 323 low
        struct LUT323L : public Register<0x4002da18> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 324 low
        struct LUT324L : public Register<0x4002da20> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 325 low
        struct LUT325L : public Register<0x4002da28> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 326 low
        struct LUT326L : public Register<0x4002da30> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 327 low
        struct LUT327L : public Register<0x4002da38> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 328 low
        struct LUT328L : public Register<0x4002da40> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 329 low
        struct LUT329L : public Register<0x4002da48> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 330 low
        struct LUT330L : public Register<0x4002da50> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 331 low
        struct LUT331L : public Register<0x4002da58> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 332 low
        struct LUT332L : public Register<0x4002da60> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 333 low
        struct LUT333L : public Register<0x4002da68> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 334 low
        struct LUT334L : public Register<0x4002da70> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 335 low
        struct LUT335L : public Register<0x4002da78> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 336 low
        struct LUT336L : public Register<0x4002da80> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 337 low
        struct LUT337L : public Register<0x4002da88> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 338 low
        struct LUT338L : public Register<0x4002da90> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 339 low
        struct LUT339L : public Register<0x4002da98> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 340 low
        struct LUT340L : public Register<0x4002daa0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 341 low
        struct LUT341L : public Register<0x4002daa8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 342 low
        struct LUT342L : public Register<0x4002dab0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 343 low
        struct LUT343L : public Register<0x4002dab8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 344 low
        struct LUT344L : public Register<0x4002dac0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 345 low
        struct LUT345L : public Register<0x4002dac8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 346 low
        struct LUT346L : public Register<0x4002dad0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 347 low
        struct LUT347L : public Register<0x4002dad8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 348 low
        struct LUT348L : public Register<0x4002dae0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 349 low
        struct LUT349L : public Register<0x4002dae8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 350 low
        struct LUT350L : public Register<0x4002daf0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 351 low
        struct LUT351L : public Register<0x4002daf8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 352 low
        struct LUT352L : public Register<0x4002db00> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 353 low
        struct LUT353L : public Register<0x4002db08> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 354 low
        struct LUT354L : public Register<0x4002db10> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 355 low
        struct LUT355L : public Register<0x4002db18> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 356 low
        struct LUT356L : public Register<0x4002db20> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 357 low
        struct LUT357L : public Register<0x4002db28> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 358 low
        struct LUT358L : public Register<0x4002db30> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 359 low
        struct LUT359L : public Register<0x4002db38> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 360 low
        struct LUT360L : public Register<0x4002db40> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 361 low
        struct LUT361L : public Register<0x4002db48> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 362 low
        struct LUT362L : public Register<0x4002db50> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 363 low
        struct LUT363L : public Register<0x4002db58> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 364 low
        struct LUT364L : public Register<0x4002db60> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 365 low
        struct LUT365L : public Register<0x4002db68> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 366 low
        struct LUT366L : public Register<0x4002db70> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 367 low
        struct LUT367L : public Register<0x4002db78> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 368 low
        struct LUT368L : public Register<0x4002db80> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 369 low
        struct LUT369L : public Register<0x4002db88> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 370 low
        struct LUT370L : public Register<0x4002db90> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 371 low
        struct LUT371L : public Register<0x4002db98> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 372 low
        struct LUT372L : public Register<0x4002dba0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 373 low
        struct LUT373L : public Register<0x4002dba8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 374 low
        struct LUT374L : public Register<0x4002dbb0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 375 low
        struct LUT375L : public Register<0x4002dbb8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 376 low
        struct LUT376L : public Register<0x4002dbc0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 377 low
        struct LUT377L : public Register<0x4002dbc8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 378 low
        struct LUT378L : public Register<0x4002dbd0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 379 low
        struct LUT379L : public Register<0x4002dbd8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 380 low
        struct LUT380L : public Register<0x4002dbe0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 381 low
        struct LUT381L : public Register<0x4002dbe8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 382 low
        struct LUT382L : public Register<0x4002dbf0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 383 low
        struct LUT383L : public Register<0x4002dbf8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 384 low
        struct LUT384L : public Register<0x4002dc00> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 385 low
        struct LUT385L : public Register<0x4002dc08> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 386 low
        struct LUT386L : public Register<0x4002dc10> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 387 low
        struct LUT387L : public Register<0x4002dc18> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 388 low
        struct LUT388L : public Register<0x4002dc20> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 389 low
        struct LUT389L : public Register<0x4002dc28> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 390 low
        struct LUT390L : public Register<0x4002dc30> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 391 low
        struct LUT391L : public Register<0x4002dc38> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 392 low
        struct LUT392L : public Register<0x4002dc40> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 393 low
        struct LUT393L : public Register<0x4002dc48> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 394 low
        struct LUT394L : public Register<0x4002dc50> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 395 low
        struct LUT395L : public Register<0x4002dc58> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 396 low
        struct LUT396L : public Register<0x4002dc60> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 397 low
        struct LUT397L : public Register<0x4002dc68> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 398 low
        struct LUT398L : public Register<0x4002dc70> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 399 low
        struct LUT399L : public Register<0x4002dc78> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 400 low
        struct LUT400L : public Register<0x4002dc80> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 401 low
        struct LUT401L : public Register<0x4002dc88> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 402 low
        struct LUT402L : public Register<0x4002dc90> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 403 low
        struct LUT403L : public Register<0x4002dc98> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 404 low
        struct LUT404L : public Register<0x4002dca0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 405 low
        struct LUT405L : public Register<0x4002dca8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 406 low
        struct LUT406L : public Register<0x4002dcb0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 407 low
        struct LUT407L : public Register<0x4002dcb8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 408 low
        struct LUT408L : public Register<0x4002dcc0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 409 low
        struct LUT409L : public Register<0x4002dcc8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 410 low
        struct LUT410L : public Register<0x4002dcd0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 411 low
        struct LUT411L : public Register<0x4002dcd8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 412 low
        struct LUT412L : public Register<0x4002dce0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 413 low
        struct LUT413L : public Register<0x4002dce8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 414 low
        struct LUT414L : public Register<0x4002dcf0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 415 low
        struct LUT415L : public Register<0x4002dcf8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 416 low
        struct LUT416L : public Register<0x4002dd00> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 417 low
        struct LUT417L : public Register<0x4002dd08> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 418 low
        struct LUT418L : public Register<0x4002dd10> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 419 low
        struct LUT419L : public Register<0x4002dd18> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 420 low
        struct LUT420L : public Register<0x4002dd20> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 421 low
        struct LUT421L : public Register<0x4002dd28> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 422 low
        struct LUT422L : public Register<0x4002dd30> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 423 low
        struct LUT423L : public Register<0x4002dd38> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 424 low
        struct LUT424L : public Register<0x4002dd40> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 425 low
        struct LUT425L : public Register<0x4002dd48> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 426 low
        struct LUT426L : public Register<0x4002dd50> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 427 low
        struct LUT427L : public Register<0x4002dd58> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 428 low
        struct LUT428L : public Register<0x4002dd60> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 429 low
        struct LUT429L : public Register<0x4002dd68> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 430 low
        struct LUT430L : public Register<0x4002dd70> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 431 low
        struct LUT431L : public Register<0x4002dd78> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 432 low
        struct LUT432L : public Register<0x4002dd80> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 433 low
        struct LUT433L : public Register<0x4002dd88> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 434 low
        struct LUT434L : public Register<0x4002dd90> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 435 low
        struct LUT435L : public Register<0x4002dd98> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 436 low
        struct LUT436L : public Register<0x4002dda0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 437 low
        struct LUT437L : public Register<0x4002dda8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 438 low
        struct LUT438L : public Register<0x4002ddb0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 439 low
        struct LUT439L : public Register<0x4002ddb8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 440 low
        struct LUT440L : public Register<0x4002ddc0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 441 low
        struct LUT441L : public Register<0x4002ddc8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 442 low
        struct LUT442L : public Register<0x4002ddd0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 443 low
        struct LUT443L : public Register<0x4002ddd8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 444 low
        struct LUT444L : public Register<0x4002dde0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 445 low
        struct LUT445L : public Register<0x4002dde8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 446 low
        struct LUT446L : public Register<0x4002ddf0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 447 low
        struct LUT447L : public Register<0x4002ddf8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 448 low
        struct LUT448L : public Register<0x4002de00> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 449 low
        struct LUT449L : public Register<0x4002de08> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 450 low
        struct LUT450L : public Register<0x4002de10> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 451 low
        struct LUT451L : public Register<0x4002de18> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 452 low
        struct LUT452L : public Register<0x4002de20> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 453 low
        struct LUT453L : public Register<0x4002de28> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 454 low
        struct LUT454L : public Register<0x4002de30> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 455 low
        struct LUT455L : public Register<0x4002de38> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 456 low
        struct LUT456L : public Register<0x4002de40> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 457 low
        struct LUT457L : public Register<0x4002de48> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 458 low
        struct LUT458L : public Register<0x4002de50> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 459 low
        struct LUT459L : public Register<0x4002de58> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 460 low
        struct LUT460L : public Register<0x4002de60> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 461 low
        struct LUT461L : public Register<0x4002de68> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 462 low
        struct LUT462L : public Register<0x4002de70> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 463 low
        struct LUT463L : public Register<0x4002de78> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 464 low
        struct LUT464L : public Register<0x4002de80> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 465 low
        struct LUT465L : public Register<0x4002de88> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 466 low
        struct LUT466L : public Register<0x4002de90> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 467 low
        struct LUT467L : public Register<0x4002de98> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 468 low
        struct LUT468L : public Register<0x4002dea0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 469 low
        struct LUT469L : public Register<0x4002dea8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 470 low
        struct LUT470L : public Register<0x4002deb0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 471 low
        struct LUT471L : public Register<0x4002deb8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 472 low
        struct LUT472L : public Register<0x4002dec0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 473 low
        struct LUT473L : public Register<0x4002dec8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 474 low
        struct LUT474L : public Register<0x4002ded0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 475 low
        struct LUT475L : public Register<0x4002ded8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 476 low
        struct LUT476L : public Register<0x4002dee0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 477 low
        struct LUT477L : public Register<0x4002dee8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 478 low
        struct LUT478L : public Register<0x4002def0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 479 low
        struct LUT479L : public Register<0x4002def8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 480 low
        struct LUT480L : public Register<0x4002df00> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 481 low
        struct LUT481L : public Register<0x4002df08> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 482 low
        struct LUT482L : public Register<0x4002df10> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 483 low
        struct LUT483L : public Register<0x4002df18> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 484 low
        struct LUT484L : public Register<0x4002df20> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 485 low
        struct LUT485L : public Register<0x4002df28> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 486 low
        struct LUT486L : public Register<0x4002df30> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 487 low
        struct LUT487L : public Register<0x4002df38> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 488 low
        struct LUT488L : public Register<0x4002df40> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 489 low
        struct LUT489L : public Register<0x4002df48> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 490 low
        struct LUT490L : public Register<0x4002df50> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 491 low
        struct LUT491L : public Register<0x4002df58> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 492 low
        struct LUT492L : public Register<0x4002df60> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 493 low
        struct LUT493L : public Register<0x4002df68> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 494 low
        struct LUT494L : public Register<0x4002df70> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 495 low
        struct LUT495L : public Register<0x4002df78> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 496 low
        struct LUT496L : public Register<0x4002df80> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 497 low
        struct LUT497L : public Register<0x4002df88> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 498 low
        struct LUT498L : public Register<0x4002df90> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 499 low
        struct LUT499L : public Register<0x4002df98> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 500 low
        struct LUT500L : public Register<0x4002dfa0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 501 low
        struct LUT501L : public Register<0x4002dfa8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 502 low
        struct LUT502L : public Register<0x4002dfb0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 503 low
        struct LUT503L : public Register<0x4002dfb8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 504 low
        struct LUT504L : public Register<0x4002dfc0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 505 low
        struct LUT505L : public Register<0x4002dfc8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 506 low
        struct LUT506L : public Register<0x4002dfd0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 507 low
        struct LUT507L : public Register<0x4002dfd8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 508 low
        struct LUT508L : public Register<0x4002dfe0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 509 low
        struct LUT509L : public Register<0x4002dfe8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 510 low
        struct LUT510L : public Register<0x4002dff0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 511 low
        struct LUT511L : public Register<0x4002dff8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 512 low
        struct LUT512L : public Register<0x4002e000> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 513 low
        struct LUT513L : public Register<0x4002e008> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 514 low
        struct LUT514L : public Register<0x4002e010> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 515 low
        struct LUT515L : public Register<0x4002e018> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 516 low
        struct LUT516L : public Register<0x4002e020> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 517 low
        struct LUT517L : public Register<0x4002e028> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 518 low
        struct LUT518L : public Register<0x4002e030> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 519 low
        struct LUT519L : public Register<0x4002e038> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 520 low
        struct LUT520L : public Register<0x4002e040> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 521 low
        struct LUT521L : public Register<0x4002e048> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 522 low
        struct LUT522L : public Register<0x4002e050> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 523 low
        struct LUT523L : public Register<0x4002e058> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 524 low
        struct LUT524L : public Register<0x4002e060> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 525 low
        struct LUT525L : public Register<0x4002e068> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 526 low
        struct LUT526L : public Register<0x4002e070> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 527 low
        struct LUT527L : public Register<0x4002e078> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 528 low
        struct LUT528L : public Register<0x4002e080> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 529 low
        struct LUT529L : public Register<0x4002e088> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 530 low
        struct LUT530L : public Register<0x4002e090> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 531 low
        struct LUT531L : public Register<0x4002e098> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 532 low
        struct LUT532L : public Register<0x4002e0a0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 533 low
        struct LUT533L : public Register<0x4002e0a8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 534 low
        struct LUT534L : public Register<0x4002e0b0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 535 low
        struct LUT535L : public Register<0x4002e0b8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 536 low
        struct LUT536L : public Register<0x4002e0c0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 537 low
        struct LUT537L : public Register<0x4002e0c8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 538 low
        struct LUT538L : public Register<0x4002e0d0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 539 low
        struct LUT539L : public Register<0x4002e0d8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 540 low
        struct LUT540L : public Register<0x4002e0e0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 541 low
        struct LUT541L : public Register<0x4002e0e8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 542 low
        struct LUT542L : public Register<0x4002e0f0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 543 low
        struct LUT543L : public Register<0x4002e0f8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 544 low
        struct LUT544L : public Register<0x4002e100> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 545 low
        struct LUT545L : public Register<0x4002e108> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 546 low
        struct LUT546L : public Register<0x4002e110> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 547 low
        struct LUT547L : public Register<0x4002e118> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 548 low
        struct LUT548L : public Register<0x4002e120> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 549 low
        struct LUT549L : public Register<0x4002e128> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 550 low
        struct LUT550L : public Register<0x4002e130> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 551 low
        struct LUT551L : public Register<0x4002e138> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 552 low
        struct LUT552L : public Register<0x4002e140> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 553 low
        struct LUT553L : public Register<0x4002e148> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 554 low
        struct LUT554L : public Register<0x4002e150> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 555 low
        struct LUT555L : public Register<0x4002e158> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 556 low
        struct LUT556L : public Register<0x4002e160> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 557 low
        struct LUT557L : public Register<0x4002e168> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 558 low
        struct LUT558L : public Register<0x4002e170> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 559 low
        struct LUT559L : public Register<0x4002e178> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 560 low
        struct LUT560L : public Register<0x4002e180> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 561 low
        struct LUT561L : public Register<0x4002e188> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 562 low
        struct LUT562L : public Register<0x4002e190> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 563 low
        struct LUT563L : public Register<0x4002e198> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 564 low
        struct LUT564L : public Register<0x4002e1a0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 565 low
        struct LUT565L : public Register<0x4002e1a8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 566 low
        struct LUT566L : public Register<0x4002e1b0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 567 low
        struct LUT567L : public Register<0x4002e1b8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 568 low
        struct LUT568L : public Register<0x4002e1c0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 569 low
        struct LUT569L : public Register<0x4002e1c8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 570 low
        struct LUT570L : public Register<0x4002e1d0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 571 low
        struct LUT571L : public Register<0x4002e1d8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 572 low
        struct LUT572L : public Register<0x4002e1e0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 573 low
        struct LUT573L : public Register<0x4002e1e8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 574 low
        struct LUT574L : public Register<0x4002e1f0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 575 low
        struct LUT575L : public Register<0x4002e1f8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 576 low
        struct LUT576L : public Register<0x4002e200> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 577 low
        struct LUT577L : public Register<0x4002e208> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 578 low
        struct LUT578L : public Register<0x4002e210> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 579 low
        struct LUT579L : public Register<0x4002e218> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 580 low
        struct LUT580L : public Register<0x4002e220> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 581 low
        struct LUT581L : public Register<0x4002e228> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 582 low
        struct LUT582L : public Register<0x4002e230> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 583 low
        struct LUT583L : public Register<0x4002e238> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 584 low
        struct LUT584L : public Register<0x4002e240> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 585 low
        struct LUT585L : public Register<0x4002e248> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 586 low
        struct LUT586L : public Register<0x4002e250> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 587 low
        struct LUT587L : public Register<0x4002e258> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 588 low
        struct LUT588L : public Register<0x4002e260> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 589 low
        struct LUT589L : public Register<0x4002e268> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 590 low
        struct LUT590L : public Register<0x4002e270> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 591 low
        struct LUT591L : public Register<0x4002e278> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 592 low
        struct LUT592L : public Register<0x4002e280> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 593 low
        struct LUT593L : public Register<0x4002e288> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 594 low
        struct LUT594L : public Register<0x4002e290> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 595 low
        struct LUT595L : public Register<0x4002e298> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 596 low
        struct LUT596L : public Register<0x4002e2a0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 597 low
        struct LUT597L : public Register<0x4002e2a8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 598 low
        struct LUT598L : public Register<0x4002e2b0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 599 low
        struct LUT599L : public Register<0x4002e2b8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 600 low
        struct LUT600L : public Register<0x4002e2c0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 601 low
        struct LUT601L : public Register<0x4002e2c8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 602 low
        struct LUT602L : public Register<0x4002e2d0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 603 low
        struct LUT603L : public Register<0x4002e2d8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 604 low
        struct LUT604L : public Register<0x4002e2e0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 605 low
        struct LUT605L : public Register<0x4002e2e8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 606 low
        struct LUT606L : public Register<0x4002e2f0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 607 low
        struct LUT607L : public Register<0x4002e2f8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 608 low
        struct LUT608L : public Register<0x4002e300> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 609 low
        struct LUT609L : public Register<0x4002e308> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 610 low
        struct LUT610L : public Register<0x4002e310> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 611 low
        struct LUT611L : public Register<0x4002e318> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 612 low
        struct LUT612L : public Register<0x4002e320> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 613 low
        struct LUT613L : public Register<0x4002e328> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 614 low
        struct LUT614L : public Register<0x4002e330> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 615 low
        struct LUT615L : public Register<0x4002e338> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 616 low
        struct LUT616L : public Register<0x4002e340> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 617 low
        struct LUT617L : public Register<0x4002e348> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 618 low
        struct LUT618L : public Register<0x4002e350> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 619 low
        struct LUT619L : public Register<0x4002e358> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 620 low
        struct LUT620L : public Register<0x4002e360> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 621 low
        struct LUT621L : public Register<0x4002e368> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 622 low
        struct LUT622L : public Register<0x4002e370> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 623 low
        struct LUT623L : public Register<0x4002e378> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 624 low
        struct LUT624L : public Register<0x4002e380> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 625 low
        struct LUT625L : public Register<0x4002e388> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 626 low
        struct LUT626L : public Register<0x4002e390> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 627 low
        struct LUT627L : public Register<0x4002e398> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 628 low
        struct LUT628L : public Register<0x4002e3a0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 629 low
        struct LUT629L : public Register<0x4002e3a8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 630 low
        struct LUT630L : public Register<0x4002e3b0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 631 low
        struct LUT631L : public Register<0x4002e3b8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 632 low
        struct LUT632L : public Register<0x4002e3c0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 633 low
        struct LUT633L : public Register<0x4002e3c8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 634 low
        struct LUT634L : public Register<0x4002e3d0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 635 low
        struct LUT635L : public Register<0x4002e3d8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 636 low
        struct LUT636L : public Register<0x4002e3e0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 637 low
        struct LUT637L : public Register<0x4002e3e8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 638 low
        struct LUT638L : public Register<0x4002e3f0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 639 low
        struct LUT639L : public Register<0x4002e3f8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 640 low
        struct LUT640L : public Register<0x4002e400> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 641 low
        struct LUT641L : public Register<0x4002e408> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 642 low
        struct LUT642L : public Register<0x4002e410> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 643 low
        struct LUT643L : public Register<0x4002e418> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 644 low
        struct LUT644L : public Register<0x4002e420> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 645 low
        struct LUT645L : public Register<0x4002e428> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 646 low
        struct LUT646L : public Register<0x4002e430> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 647 low
        struct LUT647L : public Register<0x4002e438> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 648 low
        struct LUT648L : public Register<0x4002e440> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 649 low
        struct LUT649L : public Register<0x4002e448> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 650 low
        struct LUT650L : public Register<0x4002e450> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 651 low
        struct LUT651L : public Register<0x4002e458> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 652 low
        struct LUT652L : public Register<0x4002e460> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 653 low
        struct LUT653L : public Register<0x4002e468> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 654 low
        struct LUT654L : public Register<0x4002e470> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 655 low
        struct LUT655L : public Register<0x4002e478> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 656 low
        struct LUT656L : public Register<0x4002e480> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 657 low
        struct LUT657L : public Register<0x4002e488> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 658 low
        struct LUT658L : public Register<0x4002e490> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 659 low
        struct LUT659L : public Register<0x4002e498> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 660 low
        struct LUT660L : public Register<0x4002e4a0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 661 low
        struct LUT661L : public Register<0x4002e4a8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 662 low
        struct LUT662L : public Register<0x4002e4b0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 663 low
        struct LUT663L : public Register<0x4002e4b8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 664 low
        struct LUT664L : public Register<0x4002e4c0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 665 low
        struct LUT665L : public Register<0x4002e4c8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 666 low
        struct LUT666L : public Register<0x4002e4d0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 667 low
        struct LUT667L : public Register<0x4002e4d8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 668 low
        struct LUT668L : public Register<0x4002e4e0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 669 low
        struct LUT669L : public Register<0x4002e4e8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 670 low
        struct LUT670L : public Register<0x4002e4f0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 671 low
        struct LUT671L : public Register<0x4002e4f8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 672 low
        struct LUT672L : public Register<0x4002e500> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 673 low
        struct LUT673L : public Register<0x4002e508> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 674 low
        struct LUT674L : public Register<0x4002e510> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 675 low
        struct LUT675L : public Register<0x4002e518> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 676 low
        struct LUT676L : public Register<0x4002e520> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 677 low
        struct LUT677L : public Register<0x4002e528> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 678 low
        struct LUT678L : public Register<0x4002e530> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 679 low
        struct LUT679L : public Register<0x4002e538> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 680 low
        struct LUT680L : public Register<0x4002e540> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 681 low
        struct LUT681L : public Register<0x4002e548> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 682 low
        struct LUT682L : public Register<0x4002e550> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 683 low
        struct LUT683L : public Register<0x4002e558> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 684 low
        struct LUT684L : public Register<0x4002e560> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 685 low
        struct LUT685L : public Register<0x4002e568> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 686 low
        struct LUT686L : public Register<0x4002e570> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 687 low
        struct LUT687L : public Register<0x4002e578> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 688 low
        struct LUT688L : public Register<0x4002e580> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 689 low
        struct LUT689L : public Register<0x4002e588> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 690 low
        struct LUT690L : public Register<0x4002e590> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 691 low
        struct LUT691L : public Register<0x4002e598> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 692 low
        struct LUT692L : public Register<0x4002e5a0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 693 low
        struct LUT693L : public Register<0x4002e5a8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 694 low
        struct LUT694L : public Register<0x4002e5b0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 695 low
        struct LUT695L : public Register<0x4002e5b8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 696 low
        struct LUT696L : public Register<0x4002e5c0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 697 low
        struct LUT697L : public Register<0x4002e5c8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 698 low
        struct LUT698L : public Register<0x4002e5d0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 699 low
        struct LUT699L : public Register<0x4002e5d8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 700 low
        struct LUT700L : public Register<0x4002e5e0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 701 low
        struct LUT701L : public Register<0x4002e5e8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 702 low
        struct LUT702L : public Register<0x4002e5f0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 703 low
        struct LUT703L : public Register<0x4002e5f8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 704 low
        struct LUT704L : public Register<0x4002e600> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 705 low
        struct LUT705L : public Register<0x4002e608> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 706 low
        struct LUT706L : public Register<0x4002e610> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 707 low
        struct LUT707L : public Register<0x4002e618> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 708 low
        struct LUT708L : public Register<0x4002e620> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 709 low
        struct LUT709L : public Register<0x4002e628> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 710 low
        struct LUT710L : public Register<0x4002e630> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 711 low
        struct LUT711L : public Register<0x4002e638> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 712 low
        struct LUT712L : public Register<0x4002e640> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 713 low
        struct LUT713L : public Register<0x4002e648> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 714 low
        struct LUT714L : public Register<0x4002e650> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 715 low
        struct LUT715L : public Register<0x4002e658> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 716 low
        struct LUT716L : public Register<0x4002e660> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 717 low
        struct LUT717L : public Register<0x4002e668> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 718 low
        struct LUT718L : public Register<0x4002e670> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 719 low
        struct LUT719L : public Register<0x4002e678> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 720 low
        struct LUT720L : public Register<0x4002e680> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 721 low
        struct LUT721L : public Register<0x4002e688> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 722 low
        struct LUT722L : public Register<0x4002e690> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 723 low
        struct LUT723L : public Register<0x4002e698> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 724 low
        struct LUT724L : public Register<0x4002e6a0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 725 low
        struct LUT725L : public Register<0x4002e6a8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 726 low
        struct LUT726L : public Register<0x4002e6b0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 727 low
        struct LUT727L : public Register<0x4002e6b8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 728 low
        struct LUT728L : public Register<0x4002e6c0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 729 low
        struct LUT729L : public Register<0x4002e6c8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 730 low
        struct LUT730L : public Register<0x4002e6d0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 731 low
        struct LUT731L : public Register<0x4002e6d8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 732 low
        struct LUT732L : public Register<0x4002e6e0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 733 low
        struct LUT733L : public Register<0x4002e6e8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 734 low
        struct LUT734L : public Register<0x4002e6f0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 735 low
        struct LUT735L : public Register<0x4002e6f8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 736 low
        struct LUT736L : public Register<0x4002e700> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 737 low
        struct LUT737L : public Register<0x4002e708> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 738 low
        struct LUT738L : public Register<0x4002e710> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 739 low
        struct LUT739L : public Register<0x4002e718> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 740 low
        struct LUT740L : public Register<0x4002e720> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 741 low
        struct LUT741L : public Register<0x4002e728> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 742 low
        struct LUT742L : public Register<0x4002e730> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 743 low
        struct LUT743L : public Register<0x4002e738> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 744 low
        struct LUT744L : public Register<0x4002e740> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 745 low
        struct LUT745L : public Register<0x4002e748> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 746 low
        struct LUT746L : public Register<0x4002e750> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 747 low
        struct LUT747L : public Register<0x4002e758> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 748 low
        struct LUT748L : public Register<0x4002e760> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 749 low
        struct LUT749L : public Register<0x4002e768> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 750 low
        struct LUT750L : public Register<0x4002e770> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 751 low
        struct LUT751L : public Register<0x4002e778> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 752 low
        struct LUT752L : public Register<0x4002e780> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 753 low
        struct LUT753L : public Register<0x4002e788> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 754 low
        struct LUT754L : public Register<0x4002e790> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 755 low
        struct LUT755L : public Register<0x4002e798> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 756 low
        struct LUT756L : public Register<0x4002e7a0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 757 low
        struct LUT757L : public Register<0x4002e7a8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 758 low
        struct LUT758L : public Register<0x4002e7b0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 759 low
        struct LUT759L : public Register<0x4002e7b8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 760 low
        struct LUT760L : public Register<0x4002e7c0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 761 low
        struct LUT761L : public Register<0x4002e7c8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 762 low
        struct LUT762L : public Register<0x4002e7d0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 763 low
        struct LUT763L : public Register<0x4002e7d8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 764 low
        struct LUT764L : public Register<0x4002e7e0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 765 low
        struct LUT765L : public Register<0x4002e7e8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 766 low
        struct LUT766L : public Register<0x4002e7f0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 767 low
        struct LUT767L : public Register<0x4002e7f8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 768 low
        struct LUT768L : public Register<0x4002e800> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 769 low
        struct LUT769L : public Register<0x4002e808> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 770 low
        struct LUT770L : public Register<0x4002e810> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 771 low
        struct LUT771L : public Register<0x4002e818> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 772 low
        struct LUT772L : public Register<0x4002e820> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 773 low
        struct LUT773L : public Register<0x4002e828> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 774 low
        struct LUT774L : public Register<0x4002e830> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 775 low
        struct LUT775L : public Register<0x4002e838> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 776 low
        struct LUT776L : public Register<0x4002e840> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 777 low
        struct LUT777L : public Register<0x4002e848> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 778 low
        struct LUT778L : public Register<0x4002e850> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 779 low
        struct LUT779L : public Register<0x4002e858> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 780 low
        struct LUT780L : public Register<0x4002e860> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 781 low
        struct LUT781L : public Register<0x4002e868> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 782 low
        struct LUT782L : public Register<0x4002e870> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 783 low
        struct LUT783L : public Register<0x4002e878> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 784 low
        struct LUT784L : public Register<0x4002e880> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 785 low
        struct LUT785L : public Register<0x4002e888> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 786 low
        struct LUT786L : public Register<0x4002e890> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 787 low
        struct LUT787L : public Register<0x4002e898> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 788 low
        struct LUT788L : public Register<0x4002e8a0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 789 low
        struct LUT789L : public Register<0x4002e8a8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 790 low
        struct LUT790L : public Register<0x4002e8b0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 791 low
        struct LUT791L : public Register<0x4002e8b8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 792 low
        struct LUT792L : public Register<0x4002e8c0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 793 low
        struct LUT793L : public Register<0x4002e8c8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 794 low
        struct LUT794L : public Register<0x4002e8d0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 795 low
        struct LUT795L : public Register<0x4002e8d8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 796 low
        struct LUT796L : public Register<0x4002e8e0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 797 low
        struct LUT797L : public Register<0x4002e8e8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 798 low
        struct LUT798L : public Register<0x4002e8f0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 799 low
        struct LUT799L : public Register<0x4002e8f8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 800 low
        struct LUT800L : public Register<0x4002e900> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 801 low
        struct LUT801L : public Register<0x4002e908> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 802 low
        struct LUT802L : public Register<0x4002e910> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 803 low
        struct LUT803L : public Register<0x4002e918> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 804 low
        struct LUT804L : public Register<0x4002e920> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 805 low
        struct LUT805L : public Register<0x4002e928> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 806 low
        struct LUT806L : public Register<0x4002e930> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 807 low
        struct LUT807L : public Register<0x4002e938> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 808 low
        struct LUT808L : public Register<0x4002e940> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 809 low
        struct LUT809L : public Register<0x4002e948> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 810 low
        struct LUT810L : public Register<0x4002e950> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 811 low
        struct LUT811L : public Register<0x4002e958> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 812 low
        struct LUT812L : public Register<0x4002e960> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 813 low
        struct LUT813L : public Register<0x4002e968> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 814 low
        struct LUT814L : public Register<0x4002e970> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 815 low
        struct LUT815L : public Register<0x4002e978> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 816 low
        struct LUT816L : public Register<0x4002e980> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 817 low
        struct LUT817L : public Register<0x4002e988> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 818 low
        struct LUT818L : public Register<0x4002e990> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 819 low
        struct LUT819L : public Register<0x4002e998> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 820 low
        struct LUT820L : public Register<0x4002e9a0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 821 low
        struct LUT821L : public Register<0x4002e9a8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 822 low
        struct LUT822L : public Register<0x4002e9b0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 823 low
        struct LUT823L : public Register<0x4002e9b8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 824 low
        struct LUT824L : public Register<0x4002e9c0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 825 low
        struct LUT825L : public Register<0x4002e9c8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 826 low
        struct LUT826L : public Register<0x4002e9d0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 827 low
        struct LUT827L : public Register<0x4002e9d8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 828 low
        struct LUT828L : public Register<0x4002e9e0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 829 low
        struct LUT829L : public Register<0x4002e9e8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 830 low
        struct LUT830L : public Register<0x4002e9f0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 831 low
        struct LUT831L : public Register<0x4002e9f8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 832 low
        struct LUT832L : public Register<0x4002ea00> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 833 low
        struct LUT833L : public Register<0x4002ea08> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 834 low
        struct LUT834L : public Register<0x4002ea10> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 835 low
        struct LUT835L : public Register<0x4002ea18> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 836 low
        struct LUT836L : public Register<0x4002ea20> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 837 low
        struct LUT837L : public Register<0x4002ea28> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 838 low
        struct LUT838L : public Register<0x4002ea30> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 839 low
        struct LUT839L : public Register<0x4002ea38> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 840 low
        struct LUT840L : public Register<0x4002ea40> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 841 low
        struct LUT841L : public Register<0x4002ea48> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 842 low
        struct LUT842L : public Register<0x4002ea50> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 843 low
        struct LUT843L : public Register<0x4002ea58> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 844 low
        struct LUT844L : public Register<0x4002ea60> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 845 low
        struct LUT845L : public Register<0x4002ea68> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 846 low
        struct LUT846L : public Register<0x4002ea70> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 847 low
        struct LUT847L : public Register<0x4002ea78> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 848 low
        struct LUT848L : public Register<0x4002ea80> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 849 low
        struct LUT849L : public Register<0x4002ea88> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 850 low
        struct LUT850L : public Register<0x4002ea90> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 851 low
        struct LUT851L : public Register<0x4002ea98> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 852 low
        struct LUT852L : public Register<0x4002eaa0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 853 low
        struct LUT853L : public Register<0x4002eaa8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 854 low
        struct LUT854L : public Register<0x4002eab0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 855 low
        struct LUT855L : public Register<0x4002eab8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 856 low
        struct LUT856L : public Register<0x4002eac0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 857 low
        struct LUT857L : public Register<0x4002eac8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 858 low
        struct LUT858L : public Register<0x4002ead0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 859 low
        struct LUT859L : public Register<0x4002ead8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 860 low
        struct LUT860L : public Register<0x4002eae0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 861 low
        struct LUT861L : public Register<0x4002eae8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 862 low
        struct LUT862L : public Register<0x4002eaf0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 863 low
        struct LUT863L : public Register<0x4002eaf8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 864 low
        struct LUT864L : public Register<0x4002eb00> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 865 low
        struct LUT865L : public Register<0x4002eb08> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 866 low
        struct LUT866L : public Register<0x4002eb10> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 867 low
        struct LUT867L : public Register<0x4002eb18> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 868 low
        struct LUT868L : public Register<0x4002eb20> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 869 low
        struct LUT869L : public Register<0x4002eb28> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 870 low
        struct LUT870L : public Register<0x4002eb30> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 871 low
        struct LUT871L : public Register<0x4002eb38> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 872 low
        struct LUT872L : public Register<0x4002eb40> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 873 low
        struct LUT873L : public Register<0x4002eb48> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 874 low
        struct LUT874L : public Register<0x4002eb50> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 875 low
        struct LUT875L : public Register<0x4002eb58> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 876 low
        struct LUT876L : public Register<0x4002eb60> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 877 low
        struct LUT877L : public Register<0x4002eb68> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 878 low
        struct LUT878L : public Register<0x4002eb70> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 879 low
        struct LUT879L : public Register<0x4002eb78> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 880 low
        struct LUT880L : public Register<0x4002eb80> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 881 low
        struct LUT881L : public Register<0x4002eb88> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 882 low
        struct LUT882L : public Register<0x4002eb90> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 883 low
        struct LUT883L : public Register<0x4002eb98> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 884 low
        struct LUT884L : public Register<0x4002eba0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 885 low
        struct LUT885L : public Register<0x4002eba8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 886 low
        struct LUT886L : public Register<0x4002ebb0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 887 low
        struct LUT887L : public Register<0x4002ebb8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 888 low
        struct LUT888L : public Register<0x4002ebc0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 889 low
        struct LUT889L : public Register<0x4002ebc8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 890 low
        struct LUT890L : public Register<0x4002ebd0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 891 low
        struct LUT891L : public Register<0x4002ebd8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 892 low
        struct LUT892L : public Register<0x4002ebe0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 893 low
        struct LUT893L : public Register<0x4002ebe8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 894 low
        struct LUT894L : public Register<0x4002ebf0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 895 low
        struct LUT895L : public Register<0x4002ebf8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 896 low
        struct LUT896L : public Register<0x4002ec00> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 897 low
        struct LUT897L : public Register<0x4002ec08> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 898 low
        struct LUT898L : public Register<0x4002ec10> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 899 low
        struct LUT899L : public Register<0x4002ec18> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 900 low
        struct LUT900L : public Register<0x4002ec20> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 901 low
        struct LUT901L : public Register<0x4002ec28> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 902 low
        struct LUT902L : public Register<0x4002ec30> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 903 low
        struct LUT903L : public Register<0x4002ec38> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 904 low
        struct LUT904L : public Register<0x4002ec40> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 905 low
        struct LUT905L : public Register<0x4002ec48> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 906 low
        struct LUT906L : public Register<0x4002ec50> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 907 low
        struct LUT907L : public Register<0x4002ec58> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 908 low
        struct LUT908L : public Register<0x4002ec60> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 909 low
        struct LUT909L : public Register<0x4002ec68> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 910 low
        struct LUT910L : public Register<0x4002ec70> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 911 low
        struct LUT911L : public Register<0x4002ec78> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 912 low
        struct LUT912L : public Register<0x4002ec80> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 913 low
        struct LUT913L : public Register<0x4002ec88> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 914 low
        struct LUT914L : public Register<0x4002ec90> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 915 low
        struct LUT915L : public Register<0x4002ec98> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 916 low
        struct LUT916L : public Register<0x4002eca0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 917 low
        struct LUT917L : public Register<0x4002eca8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 918 low
        struct LUT918L : public Register<0x4002ecb0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 919 low
        struct LUT919L : public Register<0x4002ecb8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 920 low
        struct LUT920L : public Register<0x4002ecc0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 921 low
        struct LUT921L : public Register<0x4002ecc8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 922 low
        struct LUT922L : public Register<0x4002ecd0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 923 low
        struct LUT923L : public Register<0x4002ecd8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 924 low
        struct LUT924L : public Register<0x4002ece0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 925 low
        struct LUT925L : public Register<0x4002ece8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 926 low
        struct LUT926L : public Register<0x4002ecf0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 927 low
        struct LUT927L : public Register<0x4002ecf8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 928 low
        struct LUT928L : public Register<0x4002ed00> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 929 low
        struct LUT929L : public Register<0x4002ed08> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 930 low
        struct LUT930L : public Register<0x4002ed10> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 931 low
        struct LUT931L : public Register<0x4002ed18> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 932 low
        struct LUT932L : public Register<0x4002ed20> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 933 low
        struct LUT933L : public Register<0x4002ed28> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 934 low
        struct LUT934L : public Register<0x4002ed30> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 935 low
        struct LUT935L : public Register<0x4002ed38> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 936 low
        struct LUT936L : public Register<0x4002ed40> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 937 low
        struct LUT937L : public Register<0x4002ed48> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 938 low
        struct LUT938L : public Register<0x4002ed50> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 939 low
        struct LUT939L : public Register<0x4002ed58> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 940 low
        struct LUT940L : public Register<0x4002ed60> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 941 low
        struct LUT941L : public Register<0x4002ed68> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 942 low
        struct LUT942L : public Register<0x4002ed70> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 943 low
        struct LUT943L : public Register<0x4002ed78> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 944 low
        struct LUT944L : public Register<0x4002ed80> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 945 low
        struct LUT945L : public Register<0x4002ed88> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 946 low
        struct LUT946L : public Register<0x4002ed90> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 947 low
        struct LUT947L : public Register<0x4002ed98> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 948 low
        struct LUT948L : public Register<0x4002eda0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 949 low
        struct LUT949L : public Register<0x4002eda8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 950 low
        struct LUT950L : public Register<0x4002edb0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 951 low
        struct LUT951L : public Register<0x4002edb8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 952 low
        struct LUT952L : public Register<0x4002edc0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 953 low
        struct LUT953L : public Register<0x4002edc8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 954 low
        struct LUT954L : public Register<0x4002edd0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 955 low
        struct LUT955L : public Register<0x4002edd8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 956 low
        struct LUT956L : public Register<0x4002ede0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 957 low
        struct LUT957L : public Register<0x4002ede8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 958 low
        struct LUT958L : public Register<0x4002edf0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 959 low
        struct LUT959L : public Register<0x4002edf8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 960 low
        struct LUT960L : public Register<0x4002ee00> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 961 low
        struct LUT961L : public Register<0x4002ee08> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 962 low
        struct LUT962L : public Register<0x4002ee10> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 963 low
        struct LUT963L : public Register<0x4002ee18> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 964 low
        struct LUT964L : public Register<0x4002ee20> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 965 low
        struct LUT965L : public Register<0x4002ee28> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 966 low
        struct LUT966L : public Register<0x4002ee30> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 967 low
        struct LUT967L : public Register<0x4002ee38> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 968 low
        struct LUT968L : public Register<0x4002ee40> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 969 low
        struct LUT969L : public Register<0x4002ee48> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 970 low
        struct LUT970L : public Register<0x4002ee50> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 971 low
        struct LUT971L : public Register<0x4002ee58> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 972 low
        struct LUT972L : public Register<0x4002ee60> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 973 low
        struct LUT973L : public Register<0x4002ee68> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 974 low
        struct LUT974L : public Register<0x4002ee70> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 975 low
        struct LUT975L : public Register<0x4002ee78> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 976 low
        struct LUT976L : public Register<0x4002ee80> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 977 low
        struct LUT977L : public Register<0x4002ee88> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 978 low
        struct LUT978L : public Register<0x4002ee90> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 979 low
        struct LUT979L : public Register<0x4002ee98> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 980 low
        struct LUT980L : public Register<0x4002eea0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 981 low
        struct LUT981L : public Register<0x4002eea8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 982 low
        struct LUT982L : public Register<0x4002eeb0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 983 low
        struct LUT983L : public Register<0x4002eeb8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 984 low
        struct LUT984L : public Register<0x4002eec0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 985 low
        struct LUT985L : public Register<0x4002eec8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 986 low
        struct LUT986L : public Register<0x4002eed0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 987 low
        struct LUT987L : public Register<0x4002eed8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 988 low
        struct LUT988L : public Register<0x4002eee0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 989 low
        struct LUT989L : public Register<0x4002eee8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 990 low
        struct LUT990L : public Register<0x4002eef0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 991 low
        struct LUT991L : public Register<0x4002eef8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 992 low
        struct LUT992L : public Register<0x4002ef00> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 993 low
        struct LUT993L : public Register<0x4002ef08> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 994 low
        struct LUT994L : public Register<0x4002ef10> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 995 low
        struct LUT995L : public Register<0x4002ef18> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 996 low
        struct LUT996L : public Register<0x4002ef20> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 997 low
        struct LUT997L : public Register<0x4002ef28> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 998 low
        struct LUT998L : public Register<0x4002ef30> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 999 low
        struct LUT999L : public Register<0x4002ef38> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1000 low
        struct LUT1000L : public Register<0x4002ef40> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1001 low
        struct LUT1001L : public Register<0x4002ef48> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1002 low
        struct LUT1002L : public Register<0x4002ef50> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1003 low
        struct LUT1003L : public Register<0x4002ef58> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1004 low
        struct LUT1004L : public Register<0x4002ef60> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1005 low
        struct LUT1005L : public Register<0x4002ef68> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1006 low
        struct LUT1006L : public Register<0x4002ef70> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1007 low
        struct LUT1007L : public Register<0x4002ef78> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1008 low
        struct LUT1008L : public Register<0x4002ef80> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1009 low
        struct LUT1009L : public Register<0x4002ef88> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1010 low
        struct LUT1010L : public Register<0x4002ef90> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1011 low
        struct LUT1011L : public Register<0x4002ef98> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1012 low
        struct LUT1012L : public Register<0x4002efa0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1013 low
        struct LUT1013L : public Register<0x4002efa8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1014 low
        struct LUT1014L : public Register<0x4002efb0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1015 low
        struct LUT1015L : public Register<0x4002efb8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1016 low
        struct LUT1016L : public Register<0x4002efc0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1017 low
        struct LUT1017L : public Register<0x4002efc8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1018 low
        struct LUT1018L : public Register<0x4002efd0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1019 low
        struct LUT1019L : public Register<0x4002efd8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1020 low
        struct LUT1020L : public Register<0x4002efe0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1021 low
        struct LUT1021L : public Register<0x4002efe8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1022 low
        struct LUT1022L : public Register<0x4002eff0> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 1023 low
        struct LUT1023L : public Register<0x4002eff8> {
            using EN = Field<0, 1>;    // Enable
            using FVB = Field<8, 8>;    // First Valid Block
            using LVB = Field<16, 8>;    // Last Valid Block
        };

        // Graphic MMU LUT entry 0 high
        struct LUT0H : public Register<0x4002d004> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1 high
        struct LUT1H : public Register<0x4002d00c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 2 high
        struct LUT2H : public Register<0x4002d014> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 3 high
        struct LUT3H : public Register<0x4002d01c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 4 high
        struct LUT4H : public Register<0x4002d024> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 5 high
        struct LUT5H : public Register<0x4002d02c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 6 high
        struct LUT6H : public Register<0x4002d034> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 7 high
        struct LUT7H : public Register<0x4002d03c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 8 high
        struct LUT8H : public Register<0x4002d044> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 9 high
        struct LUT9H : public Register<0x4002d04c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 10 high
        struct LUT10H : public Register<0x4002d054> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 11 high
        struct LUT11H : public Register<0x4002d05c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 12 high
        struct LUT12H : public Register<0x4002d064> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 13 high
        struct LUT13H : public Register<0x4002d06c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 14 high
        struct LUT14H : public Register<0x4002d074> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 15 high
        struct LUT15H : public Register<0x4002d07c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 16 high
        struct LUT16H : public Register<0x4002d084> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 17 high
        struct LUT17H : public Register<0x4002d08c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 18 high
        struct LUT18H : public Register<0x4002d094> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 19 high
        struct LUT19H : public Register<0x4002d09c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 20 high
        struct LUT20H : public Register<0x4002d0a4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 21 high
        struct LUT21H : public Register<0x4002d0ac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 22 high
        struct LUT22H : public Register<0x4002d0b4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 23 high
        struct LUT23H : public Register<0x4002d0bc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 24 high
        struct LUT24H : public Register<0x4002d0c4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 25 high
        struct LUT25H : public Register<0x4002d0cc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 26 high
        struct LUT26H : public Register<0x4002d0d4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 27 high
        struct LUT27H : public Register<0x4002d0dc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 28 high
        struct LUT28H : public Register<0x4002d0e4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 29 high
        struct LUT29H : public Register<0x4002d0ec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 30 high
        struct LUT30H : public Register<0x4002d0f4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 31 high
        struct LUT31H : public Register<0x4002d0fc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 32 high
        struct LUT32H : public Register<0x4002d104> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 33 high
        struct LUT33H : public Register<0x4002d10c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 34 high
        struct LUT34H : public Register<0x4002d114> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 35 high
        struct LUT35H : public Register<0x4002d11c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 36 high
        struct LUT36H : public Register<0x4002d124> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 37 high
        struct LUT37H : public Register<0x4002d12c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 38 high
        struct LUT38H : public Register<0x4002d134> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 39 high
        struct LUT39H : public Register<0x4002d13c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 40 high
        struct LUT40H : public Register<0x4002d144> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 41 high
        struct LUT41H : public Register<0x4002d14c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 42 high
        struct LUT42H : public Register<0x4002d154> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 43 high
        struct LUT43H : public Register<0x4002d15c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 44 high
        struct LUT44H : public Register<0x4002d164> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 45 high
        struct LUT45H : public Register<0x4002d16c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 46 high
        struct LUT46H : public Register<0x4002d174> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 47 high
        struct LUT47H : public Register<0x4002d17c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 48 high
        struct LUT48H : public Register<0x4002d184> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 49 high
        struct LUT49H : public Register<0x4002d18c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 50 high
        struct LUT50H : public Register<0x4002d194> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 51 high
        struct LUT51H : public Register<0x4002d19c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 52 high
        struct LUT52H : public Register<0x4002d1a4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 53 high
        struct LUT53H : public Register<0x4002d1ac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 54 high
        struct LUT54H : public Register<0x4002d1b4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 55 high
        struct LUT55H : public Register<0x4002d1bc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 56 high
        struct LUT56H : public Register<0x4002d1c4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 57 high
        struct LUT57H : public Register<0x4002d1cc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 58 high
        struct LUT58H : public Register<0x4002d1d4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 59 high
        struct LUT59H : public Register<0x4002d1dc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 60 high
        struct LUT60H : public Register<0x4002d1e4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 61 high
        struct LUT61H : public Register<0x4002d1ec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 62 high
        struct LUT62H : public Register<0x4002d1f4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 63 high
        struct LUT63H : public Register<0x4002d1fc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 64 high
        struct LUT64H : public Register<0x4002d204> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 65 high
        struct LUT65H : public Register<0x4002d20c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 66 high
        struct LUT66H : public Register<0x4002d214> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 67 high
        struct LUT67H : public Register<0x4002d21c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 68 high
        struct LUT68H : public Register<0x4002d224> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 69 high
        struct LUT69H : public Register<0x4002d22c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 70 high
        struct LUT70H : public Register<0x4002d234> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 71 high
        struct LUT71H : public Register<0x4002d23c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 72 high
        struct LUT72H : public Register<0x4002d244> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 73 high
        struct LUT73H : public Register<0x4002d24c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 74 high
        struct LUT74H : public Register<0x4002d254> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 75 high
        struct LUT75H : public Register<0x4002d25c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 76 high
        struct LUT76H : public Register<0x4002d264> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 77 high
        struct LUT77H : public Register<0x4002d26c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 78 high
        struct LUT78H : public Register<0x4002d274> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 79 high
        struct LUT79H : public Register<0x4002d27c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 80 high
        struct LUT80H : public Register<0x4002d284> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 81 high
        struct LUT81H : public Register<0x4002d28c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 82 high
        struct LUT82H : public Register<0x4002d294> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 83 high
        struct LUT83H : public Register<0x4002d29c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 84 high
        struct LUT84H : public Register<0x4002d2a4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 85 high
        struct LUT85H : public Register<0x4002d2ac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 86 high
        struct LUT86H : public Register<0x4002d2b4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 87 high
        struct LUT87H : public Register<0x4002d2bc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 88 high
        struct LUT88H : public Register<0x4002d2c4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 89 high
        struct LUT89H : public Register<0x4002d2cc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 90 high
        struct LUT90H : public Register<0x4002d2d4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 91 high
        struct LUT91H : public Register<0x4002d2dc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 92 high
        struct LUT92H : public Register<0x4002d2e4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 93 high
        struct LUT93H : public Register<0x4002d2ec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 94 high
        struct LUT94H : public Register<0x4002d2f4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 95 high
        struct LUT95H : public Register<0x4002d2fc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 96 high
        struct LUT96H : public Register<0x4002d304> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 97 high
        struct LUT97H : public Register<0x4002d30c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 98 high
        struct LUT98H : public Register<0x4002d314> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 99 high
        struct LUT99H : public Register<0x4002d31c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 100 high
        struct LUT100H : public Register<0x4002d324> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 101 high
        struct LUT101H : public Register<0x4002d32c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 102 high
        struct LUT102H : public Register<0x4002d334> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 103 high
        struct LUT103H : public Register<0x4002d33c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 104 high
        struct LUT104H : public Register<0x4002d344> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 105 high
        struct LUT105H : public Register<0x4002d34c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 106 high
        struct LUT106H : public Register<0x4002d354> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 107 high
        struct LUT107H : public Register<0x4002d35c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 108 high
        struct LUT108H : public Register<0x4002d364> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 109 high
        struct LUT109H : public Register<0x4002d36c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 110 high
        struct LUT110H : public Register<0x4002d374> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 111 high
        struct LUT111H : public Register<0x4002d37c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 112 high
        struct LUT112H : public Register<0x4002d384> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 113 high
        struct LUT113H : public Register<0x4002d38c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 114 high
        struct LUT114H : public Register<0x4002d394> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 115 high
        struct LUT115H : public Register<0x4002d39c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 116 high
        struct LUT116H : public Register<0x4002d3a4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 117 high
        struct LUT117H : public Register<0x4002d3ac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 118 high
        struct LUT118H : public Register<0x4002d3b4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 119 high
        struct LUT119H : public Register<0x4002d3bc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 120 high
        struct LUT120H : public Register<0x4002d3c4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 121 high
        struct LUT121H : public Register<0x4002d3cc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 122 high
        struct LUT122H : public Register<0x4002d3d4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 123 high
        struct LUT123H : public Register<0x4002d3dc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 124 high
        struct LUT124H : public Register<0x4002d3e4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 125 high
        struct LUT125H : public Register<0x4002d3ec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 126 high
        struct LUT126H : public Register<0x4002d3f4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 127 high
        struct LUT127H : public Register<0x4002d3fc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 128 high
        struct LUT128H : public Register<0x4002d404> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 129 high
        struct LUT129H : public Register<0x4002d40c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 130 high
        struct LUT130H : public Register<0x4002d414> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 131 high
        struct LUT131H : public Register<0x4002d41c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 132 high
        struct LUT132H : public Register<0x4002d424> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 133 high
        struct LUT133H : public Register<0x4002d42c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 134 high
        struct LUT134H : public Register<0x4002d434> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 135 high
        struct LUT135H : public Register<0x4002d43c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 136 high
        struct LUT136H : public Register<0x4002d444> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 137 high
        struct LUT137H : public Register<0x4002d44c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 138 high
        struct LUT138H : public Register<0x4002d454> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 139 high
        struct LUT139H : public Register<0x4002d45c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 140 high
        struct LUT140H : public Register<0x4002d464> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 141 high
        struct LUT141H : public Register<0x4002d46c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 142 high
        struct LUT142H : public Register<0x4002d474> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 143 high
        struct LUT143H : public Register<0x4002d47c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 144 high
        struct LUT144H : public Register<0x4002d484> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 145 high
        struct LUT145H : public Register<0x4002d48c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 146 high
        struct LUT146H : public Register<0x4002d494> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 147 high
        struct LUT147H : public Register<0x4002d49c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 148 high
        struct LUT148H : public Register<0x4002d4a4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 149 high
        struct LUT149H : public Register<0x4002d4ac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 150 high
        struct LUT150H : public Register<0x4002d4b4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 151 high
        struct LUT151H : public Register<0x4002d4bc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 152 high
        struct LUT152H : public Register<0x4002d4c4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 153 high
        struct LUT153H : public Register<0x4002d4cc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 154 high
        struct LUT154H : public Register<0x4002d4d4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 155 high
        struct LUT155H : public Register<0x4002d4dc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 156 high
        struct LUT156H : public Register<0x4002d4e4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 157 high
        struct LUT157H : public Register<0x4002d4ec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 158 high
        struct LUT158H : public Register<0x4002d4f4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 159 high
        struct LUT159H : public Register<0x4002d4fc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 160 high
        struct LUT160H : public Register<0x4002d504> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 161 high
        struct LUT161H : public Register<0x4002d50c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 162 high
        struct LUT162H : public Register<0x4002d514> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 163 high
        struct LUT163H : public Register<0x4002d51c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 164 high
        struct LUT164H : public Register<0x4002d524> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 165 high
        struct LUT165H : public Register<0x4002d52c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 166 high
        struct LUT166H : public Register<0x4002d534> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 167 high
        struct LUT167H : public Register<0x4002d53c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 168 high
        struct LUT168H : public Register<0x4002d544> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 169 high
        struct LUT169H : public Register<0x4002d54c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 170 high
        struct LUT170H : public Register<0x4002d554> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 171 high
        struct LUT171H : public Register<0x4002d55c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 172 high
        struct LUT172H : public Register<0x4002d564> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 173 high
        struct LUT173H : public Register<0x4002d56c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 174 high
        struct LUT174H : public Register<0x4002d574> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 175 high
        struct LUT175H : public Register<0x4002d57c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 176 high
        struct LUT176H : public Register<0x4002d584> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 177 high
        struct LUT177H : public Register<0x4002d58c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 178 high
        struct LUT178H : public Register<0x4002d594> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 179 high
        struct LUT179H : public Register<0x4002d59c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 180 high
        struct LUT180H : public Register<0x4002d5a4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 181 high
        struct LUT181H : public Register<0x4002d5ac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 182 high
        struct LUT182H : public Register<0x4002d5b4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 183 high
        struct LUT183H : public Register<0x4002d5bc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 184 high
        struct LUT184H : public Register<0x4002d5c4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 185 high
        struct LUT185H : public Register<0x4002d5cc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 186 high
        struct LUT186H : public Register<0x4002d5d4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 187 high
        struct LUT187H : public Register<0x4002d5dc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 188 high
        struct LUT188H : public Register<0x4002d5e4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 189 high
        struct LUT189H : public Register<0x4002d5ec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 190 high
        struct LUT190H : public Register<0x4002d5f4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 191 high
        struct LUT191H : public Register<0x4002d5fc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 192 high
        struct LUT192H : public Register<0x4002d604> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 193 high
        struct LUT193H : public Register<0x4002d60c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 194 high
        struct LUT194H : public Register<0x4002d614> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 195 high
        struct LUT195H : public Register<0x4002d61c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 196 high
        struct LUT196H : public Register<0x4002d624> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 197 high
        struct LUT197H : public Register<0x4002d62c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 198 high
        struct LUT198H : public Register<0x4002d634> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 199 high
        struct LUT199H : public Register<0x4002d63c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 200 high
        struct LUT200H : public Register<0x4002d644> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 201 high
        struct LUT201H : public Register<0x4002d64c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 202 high
        struct LUT202H : public Register<0x4002d654> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 203 high
        struct LUT203H : public Register<0x4002d65c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 204 high
        struct LUT204H : public Register<0x4002d664> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 205 high
        struct LUT205H : public Register<0x4002d66c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 206 high
        struct LUT206H : public Register<0x4002d674> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 207 high
        struct LUT207H : public Register<0x4002d67c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 208 high
        struct LUT208H : public Register<0x4002d684> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 209 high
        struct LUT209H : public Register<0x4002d68c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 210 high
        struct LUT210H : public Register<0x4002d694> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 211 high
        struct LUT211H : public Register<0x4002d69c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 212 high
        struct LUT212H : public Register<0x4002d6a4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 213 high
        struct LUT213H : public Register<0x4002d6ac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 214 high
        struct LUT214H : public Register<0x4002d6b4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 215 high
        struct LUT215H : public Register<0x4002d6bc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 216 high
        struct LUT216H : public Register<0x4002d6c4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 217 high
        struct LUT217H : public Register<0x4002d6cc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 218 high
        struct LUT218H : public Register<0x4002d6d4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 219 high
        struct LUT219H : public Register<0x4002d6dc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 220 high
        struct LUT220H : public Register<0x4002d6e4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 221 high
        struct LUT221H : public Register<0x4002d6ec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 222 high
        struct LUT222H : public Register<0x4002d6f4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 223 high
        struct LUT223H : public Register<0x4002d6fc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 224 high
        struct LUT224H : public Register<0x4002d704> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 225 high
        struct LUT225H : public Register<0x4002d70c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 226 high
        struct LUT226H : public Register<0x4002d714> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 227 high
        struct LUT227H : public Register<0x4002d71c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 228 high
        struct LUT228H : public Register<0x4002d724> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 229 high
        struct LUT229H : public Register<0x4002d72c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 230 high
        struct LUT230H : public Register<0x4002d734> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 231 high
        struct LUT231H : public Register<0x4002d73c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 232 high
        struct LUT232H : public Register<0x4002d744> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 233 high
        struct LUT233H : public Register<0x4002d74c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 234 high
        struct LUT234H : public Register<0x4002d754> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 235 high
        struct LUT235H : public Register<0x4002d75c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 236 high
        struct LUT236H : public Register<0x4002d764> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 237 high
        struct LUT237H : public Register<0x4002d76c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 238 high
        struct LUT238H : public Register<0x4002d774> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 239 high
        struct LUT239H : public Register<0x4002d77c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 240 high
        struct LUT240H : public Register<0x4002d784> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 241 high
        struct LUT241H : public Register<0x4002d78c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 242 high
        struct LUT242H : public Register<0x4002d794> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 243 high
        struct LUT243H : public Register<0x4002d79c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 244 high
        struct LUT244H : public Register<0x4002d7a4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 245 high
        struct LUT245H : public Register<0x4002d7ac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 246 high
        struct LUT246H : public Register<0x4002d7b4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 247 high
        struct LUT247H : public Register<0x4002d7bc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 248 high
        struct LUT248H : public Register<0x4002d7c4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 249 high
        struct LUT249H : public Register<0x4002d7cc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 250 high
        struct LUT250H : public Register<0x4002d7d4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 251 high
        struct LUT251H : public Register<0x4002d7dc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 252 high
        struct LUT252H : public Register<0x4002d7e4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 253 high
        struct LUT253H : public Register<0x4002d7ec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 254 high
        struct LUT254H : public Register<0x4002d7f4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 255 high
        struct LUT255H : public Register<0x4002d7fc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 256 high
        struct LUT256H : public Register<0x4002d804> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 257 high
        struct LUT257H : public Register<0x4002d80c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 258 high
        struct LUT258H : public Register<0x4002d814> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 259 high
        struct LUT259H : public Register<0x4002d81c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 260 high
        struct LUT260H : public Register<0x4002d824> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 261 high
        struct LUT261H : public Register<0x4002d82c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 262 high
        struct LUT262H : public Register<0x4002d834> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 263 high
        struct LUT263H : public Register<0x4002d83c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 264 high
        struct LUT264H : public Register<0x4002d844> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 265 high
        struct LUT265H : public Register<0x4002d84c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 266 high
        struct LUT266H : public Register<0x4002d854> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 267 high
        struct LUT267H : public Register<0x4002d85c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 268 high
        struct LUT268H : public Register<0x4002d864> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 269 high
        struct LUT269H : public Register<0x4002d86c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 270 high
        struct LUT270H : public Register<0x4002d874> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 271 high
        struct LUT271H : public Register<0x4002d87c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 272 high
        struct LUT272H : public Register<0x4002d884> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 273 high
        struct LUT273H : public Register<0x4002d88c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 274 high
        struct LUT274H : public Register<0x4002d894> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 275 high
        struct LUT275H : public Register<0x4002d89c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 276 high
        struct LUT276H : public Register<0x4002d8a4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 277 high
        struct LUT277H : public Register<0x4002d8ac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 278 high
        struct LUT278H : public Register<0x4002d8b4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 279 high
        struct LUT279H : public Register<0x4002d8bc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 280 high
        struct LUT280H : public Register<0x4002d8c4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 281 high
        struct LUT281H : public Register<0x4002d8cc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 282 high
        struct LUT282H : public Register<0x4002d8d4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 283 high
        struct LUT283H : public Register<0x4002d8dc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 284 high
        struct LUT284H : public Register<0x4002d8e4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 285 high
        struct LUT285H : public Register<0x4002d8ec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 286 high
        struct LUT286H : public Register<0x4002d8f4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 287 high
        struct LUT287H : public Register<0x4002d8fc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 288 high
        struct LUT288H : public Register<0x4002d904> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 289 high
        struct LUT289H : public Register<0x4002d90c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 290 high
        struct LUT290H : public Register<0x4002d914> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 291 high
        struct LUT291H : public Register<0x4002d91c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 292 high
        struct LUT292H : public Register<0x4002d924> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 293 high
        struct LUT293H : public Register<0x4002d92c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 294 high
        struct LUT294H : public Register<0x4002d934> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 295 high
        struct LUT295H : public Register<0x4002d93c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 296 high
        struct LUT296H : public Register<0x4002d944> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 297 high
        struct LUT297H : public Register<0x4002d94c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 298 high
        struct LUT298H : public Register<0x4002d954> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 299 high
        struct LUT299H : public Register<0x4002d95c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 300 high
        struct LUT300H : public Register<0x4002d964> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 301 high
        struct LUT301H : public Register<0x4002d96c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 302 high
        struct LUT302H : public Register<0x4002d974> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 303 high
        struct LUT303H : public Register<0x4002d97c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 304 high
        struct LUT304H : public Register<0x4002d984> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 305 high
        struct LUT305H : public Register<0x4002d98c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 306 high
        struct LUT306H : public Register<0x4002d994> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 307 high
        struct LUT307H : public Register<0x4002d99c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 308 high
        struct LUT308H : public Register<0x4002d9a4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 309 high
        struct LUT309H : public Register<0x4002d9ac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 310 high
        struct LUT310H : public Register<0x4002d9b4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 311 high
        struct LUT311H : public Register<0x4002d9bc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 312 high
        struct LUT312H : public Register<0x4002d9c4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 313 high
        struct LUT313H : public Register<0x4002d9cc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 314 high
        struct LUT314H : public Register<0x4002d9d4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 315 high
        struct LUT315H : public Register<0x4002d9dc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 316 high
        struct LUT316H : public Register<0x4002d9e4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 317 high
        struct LUT317H : public Register<0x4002d9ec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 318 high
        struct LUT318H : public Register<0x4002d9f4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 319 high
        struct LUT319H : public Register<0x4002d9fc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 320 high
        struct LUT320H : public Register<0x4002da04> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 321 high
        struct LUT321H : public Register<0x4002da0c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 322 high
        struct LUT322H : public Register<0x4002da14> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 323 high
        struct LUT323H : public Register<0x4002da1c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 324 high
        struct LUT324H : public Register<0x4002da24> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 325 high
        struct LUT325H : public Register<0x4002da2c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 326 high
        struct LUT326H : public Register<0x4002da34> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 327 high
        struct LUT327H : public Register<0x4002da3c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 328 high
        struct LUT328H : public Register<0x4002da44> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 329 high
        struct LUT329H : public Register<0x4002da4c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 330 high
        struct LUT330H : public Register<0x4002da54> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 331 high
        struct LUT331H : public Register<0x4002da5c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 332 high
        struct LUT332H : public Register<0x4002da64> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 333 high
        struct LUT333H : public Register<0x4002da6c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 334 high
        struct LUT334H : public Register<0x4002da74> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 335 high
        struct LUT335H : public Register<0x4002da7c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 336 high
        struct LUT336H : public Register<0x4002da84> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 337 high
        struct LUT337H : public Register<0x4002da8c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 338 high
        struct LUT338H : public Register<0x4002da94> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 339 high
        struct LUT339H : public Register<0x4002da9c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 340 high
        struct LUT340H : public Register<0x4002daa4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 341 high
        struct LUT341H : public Register<0x4002daac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 342 high
        struct LUT342H : public Register<0x4002dab4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 343 high
        struct LUT343H : public Register<0x4002dabc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 344 high
        struct LUT344H : public Register<0x4002dac4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 345 high
        struct LUT345H : public Register<0x4002dacc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 346 high
        struct LUT346H : public Register<0x4002dad4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 347 high
        struct LUT347H : public Register<0x4002dadc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 348 high
        struct LUT348H : public Register<0x4002dae4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 349 high
        struct LUT349H : public Register<0x4002daec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 350 high
        struct LUT350H : public Register<0x4002daf4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 351 high
        struct LUT351H : public Register<0x4002dafc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 352 high
        struct LUT352H : public Register<0x4002db04> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 353 high
        struct LUT353H : public Register<0x4002db0c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 354 high
        struct LUT354H : public Register<0x4002db14> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 355 high
        struct LUT355H : public Register<0x4002db1c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 356 high
        struct LUT356H : public Register<0x4002db24> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 357 high
        struct LUT357H : public Register<0x4002db2c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 358 high
        struct LUT358H : public Register<0x4002db34> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 359 high
        struct LUT359H : public Register<0x4002db3c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 360 high
        struct LUT360H : public Register<0x4002db44> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 361 high
        struct LUT361H : public Register<0x4002db4c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 362 high
        struct LUT362H : public Register<0x4002db54> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 363 high
        struct LUT363H : public Register<0x4002db5c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 364 high
        struct LUT364H : public Register<0x4002db64> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 365 high
        struct LUT365H : public Register<0x4002db6c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 366 high
        struct LUT366H : public Register<0x4002db74> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 367 high
        struct LUT367H : public Register<0x4002db7c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 368 high
        struct LUT368H : public Register<0x4002db84> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 369 high
        struct LUT369H : public Register<0x4002db8c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 370 high
        struct LUT370H : public Register<0x4002db94> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 371 high
        struct LUT371H : public Register<0x4002db9c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 372 high
        struct LUT372H : public Register<0x4002dba4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 373 high
        struct LUT373H : public Register<0x4002dbac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 374 high
        struct LUT374H : public Register<0x4002dbb4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 375 high
        struct LUT375H : public Register<0x4002dbbc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 376 high
        struct LUT376H : public Register<0x4002dbc4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 377 high
        struct LUT377H : public Register<0x4002dbcc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 378 high
        struct LUT378H : public Register<0x4002dbd4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 379 high
        struct LUT379H : public Register<0x4002dbdc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 380 high
        struct LUT380H : public Register<0x4002dbe4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 381 high
        struct LUT381H : public Register<0x4002dbec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 382 high
        struct LUT382H : public Register<0x4002dbf4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 383 high
        struct LUT383H : public Register<0x4002dbfc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 384 high
        struct LUT384H : public Register<0x4002dc04> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 385 high
        struct LUT385H : public Register<0x4002dc0c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 386 high
        struct LUT386H : public Register<0x4002dc14> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 387 high
        struct LUT387H : public Register<0x4002dc1c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 388 high
        struct LUT388H : public Register<0x4002dc24> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 389 high
        struct LUT389H : public Register<0x4002dc2c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 390 high
        struct LUT390H : public Register<0x4002dc34> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 391 high
        struct LUT391H : public Register<0x4002dc3c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 392 high
        struct LUT392H : public Register<0x4002dc44> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 393 high
        struct LUT393H : public Register<0x4002dc4c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 394 high
        struct LUT394H : public Register<0x4002dc54> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 395 high
        struct LUT395H : public Register<0x4002dc5c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 396 high
        struct LUT396H : public Register<0x4002dc64> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 397 high
        struct LUT397H : public Register<0x4002dc6c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 398 high
        struct LUT398H : public Register<0x4002dc74> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 399 high
        struct LUT399H : public Register<0x4002dc7c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 400 high
        struct LUT400H : public Register<0x4002dc84> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 401 high
        struct LUT401H : public Register<0x4002dc8c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 402 high
        struct LUT402H : public Register<0x4002dc94> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 403 high
        struct LUT403H : public Register<0x4002dc9c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 404 high
        struct LUT404H : public Register<0x4002dca4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 405 high
        struct LUT405H : public Register<0x4002dcac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 406 high
        struct LUT406H : public Register<0x4002dcb4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 407 high
        struct LUT407H : public Register<0x4002dcbc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 408 high
        struct LUT408H : public Register<0x4002dcc4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 409 high
        struct LUT409H : public Register<0x4002dccc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 410 high
        struct LUT410H : public Register<0x4002dcd4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 411 high
        struct LUT411H : public Register<0x4002dcdc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 412 high
        struct LUT412H : public Register<0x4002dce4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 413 high
        struct LUT413H : public Register<0x4002dcec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 414 high
        struct LUT414H : public Register<0x4002dcf4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 415 high
        struct LUT415H : public Register<0x4002dcfc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 416 high
        struct LUT416H : public Register<0x4002dd04> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 417 high
        struct LUT417H : public Register<0x4002dd0c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 418 high
        struct LUT418H : public Register<0x4002dd14> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 419 high
        struct LUT419H : public Register<0x4002dd1c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 420 high
        struct LUT420H : public Register<0x4002dd24> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 421 high
        struct LUT421H : public Register<0x4002dd2c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 422 high
        struct LUT422H : public Register<0x4002dd34> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 423 high
        struct LUT423H : public Register<0x4002dd3c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 424 high
        struct LUT424H : public Register<0x4002dd44> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 425 high
        struct LUT425H : public Register<0x4002dd4c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 426 high
        struct LUT426H : public Register<0x4002dd54> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 427 high
        struct LUT427H : public Register<0x4002dd5c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 428 high
        struct LUT428H : public Register<0x4002dd64> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 429 high
        struct LUT429H : public Register<0x4002dd6c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 430 high
        struct LUT430H : public Register<0x4002dd74> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 431 high
        struct LUT431H : public Register<0x4002dd7c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 432 high
        struct LUT432H : public Register<0x4002dd84> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 433 high
        struct LUT433H : public Register<0x4002dd8c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 434 high
        struct LUT434H : public Register<0x4002dd94> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 435 high
        struct LUT435H : public Register<0x4002dd9c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 436 high
        struct LUT436H : public Register<0x4002dda4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 437 high
        struct LUT437H : public Register<0x4002ddac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 438 high
        struct LUT438H : public Register<0x4002ddb4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 439 high
        struct LUT439H : public Register<0x4002ddbc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 440 high
        struct LUT440H : public Register<0x4002ddc4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 441 high
        struct LUT441H : public Register<0x4002ddcc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 442 high
        struct LUT442H : public Register<0x4002ddd4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 443 high
        struct LUT443H : public Register<0x4002dddc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 444 high
        struct LUT444H : public Register<0x4002dde4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 445 high
        struct LUT445H : public Register<0x4002ddec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 446 high
        struct LUT446H : public Register<0x4002ddf4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 447 high
        struct LUT447H : public Register<0x4002ddfc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 448 high
        struct LUT448H : public Register<0x4002de04> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 449 high
        struct LUT449H : public Register<0x4002de0c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 450 high
        struct LUT450H : public Register<0x4002de14> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 451 high
        struct LUT451H : public Register<0x4002de1c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 452 high
        struct LUT452H : public Register<0x4002de24> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 453 high
        struct LUT453H : public Register<0x4002de2c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 454 high
        struct LUT454H : public Register<0x4002de34> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 455 high
        struct LUT455H : public Register<0x4002de3c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 456 high
        struct LUT456H : public Register<0x4002de44> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 457 high
        struct LUT457H : public Register<0x4002de4c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 458 high
        struct LUT458H : public Register<0x4002de54> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 459 high
        struct LUT459H : public Register<0x4002de5c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 460 high
        struct LUT460H : public Register<0x4002de64> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 461 high
        struct LUT461H : public Register<0x4002de6c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 462 high
        struct LUT462H : public Register<0x4002de74> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 463 high
        struct LUT463H : public Register<0x4002de7c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 464 high
        struct LUT464H : public Register<0x4002de84> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 465 high
        struct LUT465H : public Register<0x4002de8c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 466 high
        struct LUT466H : public Register<0x4002de94> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 467 high
        struct LUT467H : public Register<0x4002de9c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 468 high
        struct LUT468H : public Register<0x4002dea4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 469 high
        struct LUT469H : public Register<0x4002deac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 470 high
        struct LUT470H : public Register<0x4002deb4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 471 high
        struct LUT471H : public Register<0x4002debc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 472 high
        struct LUT472H : public Register<0x4002dec4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 473 high
        struct LUT473H : public Register<0x4002decc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 474 high
        struct LUT474H : public Register<0x4002ded4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 475 high
        struct LUT475H : public Register<0x4002dedc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 476 high
        struct LUT476H : public Register<0x4002dee4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 477 high
        struct LUT477H : public Register<0x4002deec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 478 high
        struct LUT478H : public Register<0x4002def4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 479 high
        struct LUT479H : public Register<0x4002defc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 480 high
        struct LUT480H : public Register<0x4002df04> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 481 high
        struct LUT481H : public Register<0x4002df0c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 482 high
        struct LUT482H : public Register<0x4002df14> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 483 high
        struct LUT483H : public Register<0x4002df1c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 484 high
        struct LUT484H : public Register<0x4002df24> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 485 high
        struct LUT485H : public Register<0x4002df2c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 486 high
        struct LUT486H : public Register<0x4002df34> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 487 high
        struct LUT487H : public Register<0x4002df3c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 488 high
        struct LUT488H : public Register<0x4002df44> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 489 high
        struct LUT489H : public Register<0x4002df4c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 490 high
        struct LUT490H : public Register<0x4002df54> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 491 high
        struct LUT491H : public Register<0x4002df5c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 492 high
        struct LUT492H : public Register<0x4002df64> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 493 high
        struct LUT493H : public Register<0x4002df6c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 494 high
        struct LUT494H : public Register<0x4002df74> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 495 high
        struct LUT495H : public Register<0x4002df7c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 496 high
        struct LUT496H : public Register<0x4002df84> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 497 high
        struct LUT497H : public Register<0x4002df8c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 498 high
        struct LUT498H : public Register<0x4002df94> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 499 high
        struct LUT499H : public Register<0x4002df9c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 500 high
        struct LUT500H : public Register<0x4002dfa4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 501 high
        struct LUT501H : public Register<0x4002dfac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 502 high
        struct LUT502H : public Register<0x4002dfb4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 503 high
        struct LUT503H : public Register<0x4002dfbc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 504 high
        struct LUT504H : public Register<0x4002dfc4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 505 high
        struct LUT505H : public Register<0x4002dfcc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 506 high
        struct LUT506H : public Register<0x4002dfd4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 507 high
        struct LUT507H : public Register<0x4002dfdc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 508 high
        struct LUT508H : public Register<0x4002dfe4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 509 high
        struct LUT509H : public Register<0x4002dfec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 510 high
        struct LUT510H : public Register<0x4002dff4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 511 high
        struct LUT511H : public Register<0x4002dffc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 512 high
        struct LUT512H : public Register<0x4002e004> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 513 high
        struct LUT513H : public Register<0x4002e00c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 514 high
        struct LUT514H : public Register<0x4002e014> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 515 high
        struct LUT515H : public Register<0x4002e01c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 516 high
        struct LUT516H : public Register<0x4002e024> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 517 high
        struct LUT517H : public Register<0x4002e02c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 518 high
        struct LUT518H : public Register<0x4002e034> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 519 high
        struct LUT519H : public Register<0x4002e03c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 520 high
        struct LUT520H : public Register<0x4002e044> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 521 high
        struct LUT521H : public Register<0x4002e04c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 522 high
        struct LUT522H : public Register<0x4002e054> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 523 high
        struct LUT523H : public Register<0x4002e05c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 524 high
        struct LUT524H : public Register<0x4002e064> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 525 high
        struct LUT525H : public Register<0x4002e06c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 526 high
        struct LUT526H : public Register<0x4002e074> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 527 high
        struct LUT527H : public Register<0x4002e07c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 528 high
        struct LUT528H : public Register<0x4002e084> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 529 high
        struct LUT529H : public Register<0x4002e08c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 530 high
        struct LUT530H : public Register<0x4002e094> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 531 high
        struct LUT531H : public Register<0x4002e09c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 532 high
        struct LUT532H : public Register<0x4002e0a4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 533 high
        struct LUT533H : public Register<0x4002e0ac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 534 high
        struct LUT534H : public Register<0x4002e0b4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 535 high
        struct LUT535H : public Register<0x4002e0bc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 536 high
        struct LUT536H : public Register<0x4002e0c4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 537 high
        struct LUT537H : public Register<0x4002e0cc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 538 high
        struct LUT538H : public Register<0x4002e0d4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 539 high
        struct LUT539H : public Register<0x4002e0dc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 540 high
        struct LUT540H : public Register<0x4002e0e4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 541 high
        struct LUT541H : public Register<0x4002e0ec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 542 high
        struct LUT542H : public Register<0x4002e0f4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 543 high
        struct LUT543H : public Register<0x4002e0fc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 544 high
        struct LUT544H : public Register<0x4002e104> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 545 high
        struct LUT545H : public Register<0x4002e10c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 546 high
        struct LUT546H : public Register<0x4002e114> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 547 high
        struct LUT547H : public Register<0x4002e11c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 548 high
        struct LUT548H : public Register<0x4002e124> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 549 high
        struct LUT549H : public Register<0x4002e12c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 550 high
        struct LUT550H : public Register<0x4002e134> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 551 high
        struct LUT551H : public Register<0x4002e13c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 552 high
        struct LUT552H : public Register<0x4002e144> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 553 high
        struct LUT553H : public Register<0x4002e14c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 554 high
        struct LUT554H : public Register<0x4002e154> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 555 high
        struct LUT555H : public Register<0x4002e15c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 556 high
        struct LUT556H : public Register<0x4002e164> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 557 high
        struct LUT557H : public Register<0x4002e16c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 558 high
        struct LUT558H : public Register<0x4002e174> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 559 high
        struct LUT559H : public Register<0x4002e17c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 560 high
        struct LUT560H : public Register<0x4002e184> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 561 high
        struct LUT561H : public Register<0x4002e18c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 562 high
        struct LUT562H : public Register<0x4002e194> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 563 high
        struct LUT563H : public Register<0x4002e19c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 564 high
        struct LUT564H : public Register<0x4002e1a4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 565 high
        struct LUT565H : public Register<0x4002e1ac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 566 high
        struct LUT566H : public Register<0x4002e1b4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 567 high
        struct LUT567H : public Register<0x4002e1bc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 568 high
        struct LUT568H : public Register<0x4002e1c4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 569 high
        struct LUT569H : public Register<0x4002e1cc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 570 high
        struct LUT570H : public Register<0x4002e1d4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 571 high
        struct LUT571H : public Register<0x4002e1dc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 572 high
        struct LUT572H : public Register<0x4002e1e4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 573 high
        struct LUT573H : public Register<0x4002e1ec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 574 high
        struct LUT574H : public Register<0x4002e1f4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 575 high
        struct LUT575H : public Register<0x4002e1fc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 576 high
        struct LUT576H : public Register<0x4002e204> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 577 high
        struct LUT577H : public Register<0x4002e20c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 578 high
        struct LUT578H : public Register<0x4002e214> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 579 high
        struct LUT579H : public Register<0x4002e21c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 580 high
        struct LUT580H : public Register<0x4002e224> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 581 high
        struct LUT581H : public Register<0x4002e22c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 582 high
        struct LUT582H : public Register<0x4002e234> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 583 high
        struct LUT583H : public Register<0x4002e23c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 584 high
        struct LUT584H : public Register<0x4002e244> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 585 high
        struct LUT585H : public Register<0x4002e24c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 586 high
        struct LUT586H : public Register<0x4002e254> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 587 high
        struct LUT587H : public Register<0x4002e25c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 588 high
        struct LUT588H : public Register<0x4002e264> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 589 high
        struct LUT589H : public Register<0x4002e26c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 590 high
        struct LUT590H : public Register<0x4002e274> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 591 high
        struct LUT591H : public Register<0x4002e27c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 592 high
        struct LUT592H : public Register<0x4002e284> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 593 high
        struct LUT593H : public Register<0x4002e28c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 594 high
        struct LUT594H : public Register<0x4002e294> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 595 high
        struct LUT595H : public Register<0x4002e29c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 596 high
        struct LUT596H : public Register<0x4002e2a4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 597 high
        struct LUT597H : public Register<0x4002e2ac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 598 high
        struct LUT598H : public Register<0x4002e2b4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 599 high
        struct LUT599H : public Register<0x4002e2bc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 600 high
        struct LUT600H : public Register<0x4002e2c4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 601 high
        struct LUT601H : public Register<0x4002e2cc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 602 high
        struct LUT602H : public Register<0x4002e2d4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 603 high
        struct LUT603H : public Register<0x4002e2dc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 604 high
        struct LUT604H : public Register<0x4002e2e4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 605 high
        struct LUT605H : public Register<0x4002e2ec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 606 high
        struct LUT606H : public Register<0x4002e2f4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 607 high
        struct LUT607H : public Register<0x4002e2fc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 608 high
        struct LUT608H : public Register<0x4002e304> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 609 high
        struct LUT609H : public Register<0x4002e30c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 610 high
        struct LUT610H : public Register<0x4002e314> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 611 high
        struct LUT611H : public Register<0x4002e31c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 612 high
        struct LUT612H : public Register<0x4002e324> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 613 high
        struct LUT613H : public Register<0x4002e32c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 614 high
        struct LUT614H : public Register<0x4002e334> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 615 high
        struct LUT615H : public Register<0x4002e33c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 616 high
        struct LUT616H : public Register<0x4002e344> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 617 high
        struct LUT617H : public Register<0x4002e34c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 618 high
        struct LUT618H : public Register<0x4002e354> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 619 high
        struct LUT619H : public Register<0x4002e35c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 620 high
        struct LUT620H : public Register<0x4002e364> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 621 high
        struct LUT621H : public Register<0x4002e36c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 622 high
        struct LUT622H : public Register<0x4002e374> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 623 high
        struct LUT623H : public Register<0x4002e37c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 624 high
        struct LUT624H : public Register<0x4002e384> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 625 high
        struct LUT625H : public Register<0x4002e38c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 626 high
        struct LUT626H : public Register<0x4002e394> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 627 high
        struct LUT627H : public Register<0x4002e39c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 628 high
        struct LUT628H : public Register<0x4002e3a4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 629 high
        struct LUT629H : public Register<0x4002e3ac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 630 high
        struct LUT630H : public Register<0x4002e3b4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 631 high
        struct LUT631H : public Register<0x4002e3bc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 632 high
        struct LUT632H : public Register<0x4002e3c4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 633 high
        struct LUT633H : public Register<0x4002e3cc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 634 high
        struct LUT634H : public Register<0x4002e3d4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 635 high
        struct LUT635H : public Register<0x4002e3dc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 636 high
        struct LUT636H : public Register<0x4002e3e4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 637 high
        struct LUT637H : public Register<0x4002e3ec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 638 high
        struct LUT638H : public Register<0x4002e3f4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 639 high
        struct LUT639H : public Register<0x4002e3fc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 640 high
        struct LUT640H : public Register<0x4002e404> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 641 high
        struct LUT641H : public Register<0x4002e40c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 642 high
        struct LUT642H : public Register<0x4002e414> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 643 high
        struct LUT643H : public Register<0x4002e41c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 644 high
        struct LUT644H : public Register<0x4002e424> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 645 high
        struct LUT645H : public Register<0x4002e42c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 646 high
        struct LUT646H : public Register<0x4002e434> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 647 high
        struct LUT647H : public Register<0x4002e43c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 648 high
        struct LUT648H : public Register<0x4002e444> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 649 high
        struct LUT649H : public Register<0x4002e44c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 650 high
        struct LUT650H : public Register<0x4002e454> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 651 high
        struct LUT651H : public Register<0x4002e45c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 652 high
        struct LUT652H : public Register<0x4002e464> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 653 high
        struct LUT653H : public Register<0x4002e46c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 654 high
        struct LUT654H : public Register<0x4002e474> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 655 high
        struct LUT655H : public Register<0x4002e47c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 656 high
        struct LUT656H : public Register<0x4002e484> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 657 high
        struct LUT657H : public Register<0x4002e48c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 658 high
        struct LUT658H : public Register<0x4002e494> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 659 high
        struct LUT659H : public Register<0x4002e49c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 660 high
        struct LUT660H : public Register<0x4002e4a4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 661 high
        struct LUT661H : public Register<0x4002e4ac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 662 high
        struct LUT662H : public Register<0x4002e4b4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 663 high
        struct LUT663H : public Register<0x4002e4bc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 664 high
        struct LUT664H : public Register<0x4002e4c4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 665 high
        struct LUT665H : public Register<0x4002e4cc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 666 high
        struct LUT666H : public Register<0x4002e4d4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 667 high
        struct LUT667H : public Register<0x4002e4dc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 668 high
        struct LUT668H : public Register<0x4002e4e4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 669 high
        struct LUT669H : public Register<0x4002e4ec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 670 high
        struct LUT670H : public Register<0x4002e4f4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 671 high
        struct LUT671H : public Register<0x4002e4fc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 672 high
        struct LUT672H : public Register<0x4002e504> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 673 high
        struct LUT673H : public Register<0x4002e50c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 674 high
        struct LUT674H : public Register<0x4002e514> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 675 high
        struct LUT675H : public Register<0x4002e51c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 676 high
        struct LUT676H : public Register<0x4002e524> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 677 high
        struct LUT677H : public Register<0x4002e52c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 678 high
        struct LUT678H : public Register<0x4002e534> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 679 high
        struct LUT679H : public Register<0x4002e53c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 680 high
        struct LUT680H : public Register<0x4002e544> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 681 high
        struct LUT681H : public Register<0x4002e54c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 682 high
        struct LUT682H : public Register<0x4002e554> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 683 high
        struct LUT683H : public Register<0x4002e55c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 684 high
        struct LUT684H : public Register<0x4002e564> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 685 high
        struct LUT685H : public Register<0x4002e56c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 686 high
        struct LUT686H : public Register<0x4002e574> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 687 high
        struct LUT687H : public Register<0x4002e57c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 688 high
        struct LUT688H : public Register<0x4002e584> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 689 high
        struct LUT689H : public Register<0x4002e58c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 690 high
        struct LUT690H : public Register<0x4002e594> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 691 high
        struct LUT691H : public Register<0x4002e59c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 692 high
        struct LUT692H : public Register<0x4002e5a4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 693 high
        struct LUT693H : public Register<0x4002e5ac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 694 high
        struct LUT694H : public Register<0x4002e5b4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 695 high
        struct LUT695H : public Register<0x4002e5bc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 696 high
        struct LUT696H : public Register<0x4002e5c4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 697 high
        struct LUT697H : public Register<0x4002e5cc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 698 high
        struct LUT698H : public Register<0x4002e5d4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 699 high
        struct LUT699H : public Register<0x4002e5dc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 700 high
        struct LUT700H : public Register<0x4002e5e4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 701 high
        struct LUT701H : public Register<0x4002e5ec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 702 high
        struct LUT702H : public Register<0x4002e5f4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 703 high
        struct LUT703H : public Register<0x4002e5fc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 704 high
        struct LUT704H : public Register<0x4002e604> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 705 high
        struct LUT705H : public Register<0x4002e60c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 706 high
        struct LUT706H : public Register<0x4002e614> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 707 high
        struct LUT707H : public Register<0x4002e61c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 708 high
        struct LUT708H : public Register<0x4002e624> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 709 high
        struct LUT709H : public Register<0x4002e62c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 710 high
        struct LUT710H : public Register<0x4002e634> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 711 high
        struct LUT711H : public Register<0x4002e63c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 712 high
        struct LUT712H : public Register<0x4002e644> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 713 high
        struct LUT713H : public Register<0x4002e64c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 714 high
        struct LUT714H : public Register<0x4002e654> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 715 high
        struct LUT715H : public Register<0x4002e65c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 716 high
        struct LUT716H : public Register<0x4002e664> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 717 high
        struct LUT717H : public Register<0x4002e66c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 718 high
        struct LUT718H : public Register<0x4002e674> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 719 high
        struct LUT719H : public Register<0x4002e67c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 720 high
        struct LUT720H : public Register<0x4002e684> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 721 high
        struct LUT721H : public Register<0x4002e68c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 722 high
        struct LUT722H : public Register<0x4002e694> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 723 high
        struct LUT723H : public Register<0x4002e69c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 724 high
        struct LUT724H : public Register<0x4002e6a4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 725 high
        struct LUT725H : public Register<0x4002e6ac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 726 high
        struct LUT726H : public Register<0x4002e6b4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 727 high
        struct LUT727H : public Register<0x4002e6bc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 728 high
        struct LUT728H : public Register<0x4002e6c4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 729 high
        struct LUT729H : public Register<0x4002e6cc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 730 high
        struct LUT730H : public Register<0x4002e6d4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 731 high
        struct LUT731H : public Register<0x4002e6dc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 732 high
        struct LUT732H : public Register<0x4002e6e4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 733 high
        struct LUT733H : public Register<0x4002e6ec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 734 high
        struct LUT734H : public Register<0x4002e6f4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 735 high
        struct LUT735H : public Register<0x4002e6fc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 736 high
        struct LUT736H : public Register<0x4002e704> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 737 high
        struct LUT737H : public Register<0x4002e70c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 738 high
        struct LUT738H : public Register<0x4002e714> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 739 high
        struct LUT739H : public Register<0x4002e71c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 740 high
        struct LUT740H : public Register<0x4002e724> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 741 high
        struct LUT741H : public Register<0x4002e72c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 742 high
        struct LUT742H : public Register<0x4002e734> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 743 high
        struct LUT743H : public Register<0x4002e73c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 744 high
        struct LUT744H : public Register<0x4002e744> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 745 high
        struct LUT745H : public Register<0x4002e74c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 746 high
        struct LUT746H : public Register<0x4002e754> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 747 high
        struct LUT747H : public Register<0x4002e75c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 748 high
        struct LUT748H : public Register<0x4002e764> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 749 high
        struct LUT749H : public Register<0x4002e76c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 750 high
        struct LUT750H : public Register<0x4002e774> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 751 high
        struct LUT751H : public Register<0x4002e77c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 752 high
        struct LUT752H : public Register<0x4002e784> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 753 high
        struct LUT753H : public Register<0x4002e78c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 754 high
        struct LUT754H : public Register<0x4002e794> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 755 high
        struct LUT755H : public Register<0x4002e79c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 756 high
        struct LUT756H : public Register<0x4002e7a4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 757 high
        struct LUT757H : public Register<0x4002e7ac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 758 high
        struct LUT758H : public Register<0x4002e7b4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 759 high
        struct LUT759H : public Register<0x4002e7bc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 760 high
        struct LUT760H : public Register<0x4002e7c4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 761 high
        struct LUT761H : public Register<0x4002e7cc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 762 high
        struct LUT762H : public Register<0x4002e7d4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 763 high
        struct LUT763H : public Register<0x4002e7dc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 764 high
        struct LUT764H : public Register<0x4002e7e4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 765 high
        struct LUT765H : public Register<0x4002e7ec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 766 high
        struct LUT766H : public Register<0x4002e7f4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 767 high
        struct LUT767H : public Register<0x4002e7fc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 768 high
        struct LUT768H : public Register<0x4002e804> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 769 high
        struct LUT769H : public Register<0x4002e80c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 770 high
        struct LUT770H : public Register<0x4002e814> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 771 high
        struct LUT771H : public Register<0x4002e81c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 772 high
        struct LUT772H : public Register<0x4002e824> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 773 high
        struct LUT773H : public Register<0x4002e82c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 774 high
        struct LUT774H : public Register<0x4002e834> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 775 high
        struct LUT775H : public Register<0x4002e83c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 776 high
        struct LUT776H : public Register<0x4002e844> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 777 high
        struct LUT777H : public Register<0x4002e84c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 778 high
        struct LUT778H : public Register<0x4002e854> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 779 high
        struct LUT779H : public Register<0x4002e85c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 780 high
        struct LUT780H : public Register<0x4002e864> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 781 high
        struct LUT781H : public Register<0x4002e86c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 782 high
        struct LUT782H : public Register<0x4002e874> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 783 high
        struct LUT783H : public Register<0x4002e87c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 784 high
        struct LUT784H : public Register<0x4002e884> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 785 high
        struct LUT785H : public Register<0x4002e88c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 786 high
        struct LUT786H : public Register<0x4002e894> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 787 high
        struct LUT787H : public Register<0x4002e89c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 788 high
        struct LUT788H : public Register<0x4002e8a4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 789 high
        struct LUT789H : public Register<0x4002e8ac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 790 high
        struct LUT790H : public Register<0x4002e8b4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 791 high
        struct LUT791H : public Register<0x4002e8bc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 792 high
        struct LUT792H : public Register<0x4002e8c4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 793 high
        struct LUT793H : public Register<0x4002e8cc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 794 high
        struct LUT794H : public Register<0x4002e8d4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 795 high
        struct LUT795H : public Register<0x4002e8dc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 796 high
        struct LUT796H : public Register<0x4002e8e4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 797 high
        struct LUT797H : public Register<0x4002e8ec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 798 high
        struct LUT798H : public Register<0x4002e8f4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 799 high
        struct LUT799H : public Register<0x4002e8fc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 800 high
        struct LUT800H : public Register<0x4002e904> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 801 high
        struct LUT801H : public Register<0x4002e90c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 802 high
        struct LUT802H : public Register<0x4002e914> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 803 high
        struct LUT803H : public Register<0x4002e91c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 804 high
        struct LUT804H : public Register<0x4002e924> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 805 high
        struct LUT805H : public Register<0x4002e92c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 806 high
        struct LUT806H : public Register<0x4002e934> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 807 high
        struct LUT807H : public Register<0x4002e93c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 808 high
        struct LUT808H : public Register<0x4002e944> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 809 high
        struct LUT809H : public Register<0x4002e94c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 810 high
        struct LUT810H : public Register<0x4002e954> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 811 high
        struct LUT811H : public Register<0x4002e95c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 812 high
        struct LUT812H : public Register<0x4002e964> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 813 high
        struct LUT813H : public Register<0x4002e96c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 814 high
        struct LUT814H : public Register<0x4002e974> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 815 high
        struct LUT815H : public Register<0x4002e97c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 816 high
        struct LUT816H : public Register<0x4002e984> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 817 high
        struct LUT817H : public Register<0x4002e98c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 818 high
        struct LUT818H : public Register<0x4002e994> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 819 high
        struct LUT819H : public Register<0x4002e99c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 820 high
        struct LUT820H : public Register<0x4002e9a4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 821 high
        struct LUT821H : public Register<0x4002e9ac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 822 high
        struct LUT822H : public Register<0x4002e9b4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 823 high
        struct LUT823H : public Register<0x4002e9bc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 824 high
        struct LUT824H : public Register<0x4002e9c4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 825 high
        struct LUT825H : public Register<0x4002e9cc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 826 high
        struct LUT826H : public Register<0x4002e9d4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 827 high
        struct LUT827H : public Register<0x4002e9dc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 828 high
        struct LUT828H : public Register<0x4002e9e4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 829 high
        struct LUT829H : public Register<0x4002e9ec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 830 high
        struct LUT830H : public Register<0x4002e9f4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 831 high
        struct LUT831H : public Register<0x4002e9fc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 832 high
        struct LUT832H : public Register<0x4002ea04> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 833 high
        struct LUT833H : public Register<0x4002ea0c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 834 high
        struct LUT834H : public Register<0x4002ea14> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 835 high
        struct LUT835H : public Register<0x4002ea1c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 836 high
        struct LUT836H : public Register<0x4002ea24> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 837 high
        struct LUT837H : public Register<0x4002ea2c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 838 high
        struct LUT838H : public Register<0x4002ea34> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 839 high
        struct LUT839H : public Register<0x4002ea3c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 840 high
        struct LUT840H : public Register<0x4002ea44> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 841 high
        struct LUT841H : public Register<0x4002ea4c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 842 high
        struct LUT842H : public Register<0x4002ea54> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 843 high
        struct LUT843H : public Register<0x4002ea5c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 844 high
        struct LUT844H : public Register<0x4002ea64> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 845 high
        struct LUT845H : public Register<0x4002ea6c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 846 high
        struct LUT846H : public Register<0x4002ea74> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 847 high
        struct LUT847H : public Register<0x4002ea7c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 848 high
        struct LUT848H : public Register<0x4002ea84> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 849 high
        struct LUT849H : public Register<0x4002ea8c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 850 high
        struct LUT850H : public Register<0x4002ea94> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 851 high
        struct LUT851H : public Register<0x4002ea9c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 852 high
        struct LUT852H : public Register<0x4002eaa4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 853 high
        struct LUT853H : public Register<0x4002eaac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 854 high
        struct LUT854H : public Register<0x4002eab4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 855 high
        struct LUT855H : public Register<0x4002eabc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 856 high
        struct LUT856H : public Register<0x4002eac4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 857 high
        struct LUT857H : public Register<0x4002eacc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 858 high
        struct LUT858H : public Register<0x4002ead4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 859 high
        struct LUT859H : public Register<0x4002eadc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 860 high
        struct LUT860H : public Register<0x4002eae4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 861 high
        struct LUT861H : public Register<0x4002eaec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 862 high
        struct LUT862H : public Register<0x4002eaf4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 863 high
        struct LUT863H : public Register<0x4002eafc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 864 high
        struct LUT864H : public Register<0x4002eb04> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 865 high
        struct LUT865H : public Register<0x4002eb0c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 866 high
        struct LUT866H : public Register<0x4002eb14> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 867 high
        struct LUT867H : public Register<0x4002eb1c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 868 high
        struct LUT868H : public Register<0x4002eb24> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 869 high
        struct LUT869H : public Register<0x4002eb2c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 870 high
        struct LUT870H : public Register<0x4002eb34> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 871 high
        struct LUT871H : public Register<0x4002eb3c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 872 high
        struct LUT872H : public Register<0x4002eb44> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 873 high
        struct LUT873H : public Register<0x4002eb4c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 874 high
        struct LUT874H : public Register<0x4002eb54> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 875 high
        struct LUT875H : public Register<0x4002eb5c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 876 high
        struct LUT876H : public Register<0x4002eb64> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 877 high
        struct LUT877H : public Register<0x4002eb6c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 878 high
        struct LUT878H : public Register<0x4002eb74> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 879 high
        struct LUT879H : public Register<0x4002eb7c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 880 high
        struct LUT880H : public Register<0x4002eb84> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 881 high
        struct LUT881H : public Register<0x4002eb8c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 882 high
        struct LUT882H : public Register<0x4002eb94> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 883 high
        struct LUT883H : public Register<0x4002eb9c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 884 high
        struct LUT884H : public Register<0x4002eba4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 885 high
        struct LUT885H : public Register<0x4002ebac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 886 high
        struct LUT886H : public Register<0x4002ebb4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 887 high
        struct LUT887H : public Register<0x4002ebbc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 888 high
        struct LUT888H : public Register<0x4002ebc4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 889 high
        struct LUT889H : public Register<0x4002ebcc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 890 high
        struct LUT890H : public Register<0x4002ebd4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 891 high
        struct LUT891H : public Register<0x4002ebdc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 892 high
        struct LUT892H : public Register<0x4002ebe4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 893 high
        struct LUT893H : public Register<0x4002ebec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 894 high
        struct LUT894H : public Register<0x4002ebf4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 895 high
        struct LUT895H : public Register<0x4002ebfc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 896 high
        struct LUT896H : public Register<0x4002ec04> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 897 high
        struct LUT897H : public Register<0x4002ec0c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 898 high
        struct LUT898H : public Register<0x4002ec14> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 899 high
        struct LUT899H : public Register<0x4002ec1c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 900 high
        struct LUT900H : public Register<0x4002ec24> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 901 high
        struct LUT901H : public Register<0x4002ec2c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 902 high
        struct LUT902H : public Register<0x4002ec34> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 903 high
        struct LUT903H : public Register<0x4002ec3c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 904 high
        struct LUT904H : public Register<0x4002ec44> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 905 high
        struct LUT905H : public Register<0x4002ec4c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 906 high
        struct LUT906H : public Register<0x4002ec54> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 907 high
        struct LUT907H : public Register<0x4002ec5c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 908 high
        struct LUT908H : public Register<0x4002ec64> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 909 high
        struct LUT909H : public Register<0x4002ec6c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 910 high
        struct LUT910H : public Register<0x4002ec74> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 911 high
        struct LUT911H : public Register<0x4002ec7c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 912 high
        struct LUT912H : public Register<0x4002ec84> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 913 high
        struct LUT913H : public Register<0x4002ec8c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 914 high
        struct LUT914H : public Register<0x4002ec94> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 915 high
        struct LUT915H : public Register<0x4002ec9c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 916 high
        struct LUT916H : public Register<0x4002eca4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 917 high
        struct LUT917H : public Register<0x4002ecac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 918 high
        struct LUT918H : public Register<0x4002ecb4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 919 high
        struct LUT919H : public Register<0x4002ecbc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 920 high
        struct LUT920H : public Register<0x4002ecc4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 921 high
        struct LUT921H : public Register<0x4002eccc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 922 high
        struct LUT922H : public Register<0x4002ecd4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 923 high
        struct LUT923H : public Register<0x4002ecdc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 924 high
        struct LUT924H : public Register<0x4002ece4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 925 high
        struct LUT925H : public Register<0x4002ecec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 926 high
        struct LUT926H : public Register<0x4002ecf4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 927 high
        struct LUT927H : public Register<0x4002ecfc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 928 high
        struct LUT928H : public Register<0x4002ed04> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 929 high
        struct LUT929H : public Register<0x4002ed0c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 930 high
        struct LUT930H : public Register<0x4002ed14> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 931 high
        struct LUT931H : public Register<0x4002ed1c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 932 high
        struct LUT932H : public Register<0x4002ed24> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 933 high
        struct LUT933H : public Register<0x4002ed2c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 934 high
        struct LUT934H : public Register<0x4002ed34> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 935 high
        struct LUT935H : public Register<0x4002ed3c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 936 high
        struct LUT936H : public Register<0x4002ed44> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 937 high
        struct LUT937H : public Register<0x4002ed4c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 938 high
        struct LUT938H : public Register<0x4002ed54> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 939 high
        struct LUT939H : public Register<0x4002ed5c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 940 high
        struct LUT940H : public Register<0x4002ed64> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 941 high
        struct LUT941H : public Register<0x4002ed6c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 942 high
        struct LUT942H : public Register<0x4002ed74> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 943 high
        struct LUT943H : public Register<0x4002ed7c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 944 high
        struct LUT944H : public Register<0x4002ed84> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 945 high
        struct LUT945H : public Register<0x4002ed8c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 946 high
        struct LUT946H : public Register<0x4002ed94> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 947 high
        struct LUT947H : public Register<0x4002ed9c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 948 high
        struct LUT948H : public Register<0x4002eda4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 949 high
        struct LUT949H : public Register<0x4002edac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 950 high
        struct LUT950H : public Register<0x4002edb4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 951 high
        struct LUT951H : public Register<0x4002edbc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 952 high
        struct LUT952H : public Register<0x4002edc4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 953 high
        struct LUT953H : public Register<0x4002edcc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 954 high
        struct LUT954H : public Register<0x4002edd4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 955 high
        struct LUT955H : public Register<0x4002eddc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 956 high
        struct LUT956H : public Register<0x4002ede4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 957 high
        struct LUT957H : public Register<0x4002edec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 958 high
        struct LUT958H : public Register<0x4002edf4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 959 high
        struct LUT959H : public Register<0x4002edfc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 960 high
        struct LUT960H : public Register<0x4002ee04> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 961 high
        struct LUT961H : public Register<0x4002ee0c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 962 high
        struct LUT962H : public Register<0x4002ee14> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 963 high
        struct LUT963H : public Register<0x4002ee1c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 964 high
        struct LUT964H : public Register<0x4002ee24> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 965 high
        struct LUT965H : public Register<0x4002ee2c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 966 high
        struct LUT966H : public Register<0x4002ee34> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 967 high
        struct LUT967H : public Register<0x4002ee3c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 968 high
        struct LUT968H : public Register<0x4002ee44> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 969 high
        struct LUT969H : public Register<0x4002ee4c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 970 high
        struct LUT970H : public Register<0x4002ee54> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 971 high
        struct LUT971H : public Register<0x4002ee5c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 972 high
        struct LUT972H : public Register<0x4002ee64> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 973 high
        struct LUT973H : public Register<0x4002ee6c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 974 high
        struct LUT974H : public Register<0x4002ee74> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 975 high
        struct LUT975H : public Register<0x4002ee7c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 976 high
        struct LUT976H : public Register<0x4002ee84> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 977 high
        struct LUT977H : public Register<0x4002ee8c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 978 high
        struct LUT978H : public Register<0x4002ee94> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 979 high
        struct LUT979H : public Register<0x4002ee9c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 980 high
        struct LUT980H : public Register<0x4002eea4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 981 high
        struct LUT981H : public Register<0x4002eeac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 982 high
        struct LUT982H : public Register<0x4002eeb4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 983 high
        struct LUT983H : public Register<0x4002eebc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 984 high
        struct LUT984H : public Register<0x4002eec4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 985 high
        struct LUT985H : public Register<0x4002eecc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 986 high
        struct LUT986H : public Register<0x4002eed4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 987 high
        struct LUT987H : public Register<0x4002eedc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 988 high
        struct LUT988H : public Register<0x4002eee4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 989 high
        struct LUT989H : public Register<0x4002eeec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 990 high
        struct LUT990H : public Register<0x4002eef4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 991 high
        struct LUT991H : public Register<0x4002eefc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 992 high
        struct LUT992H : public Register<0x4002ef04> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 993 high
        struct LUT993H : public Register<0x4002ef0c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 994 high
        struct LUT994H : public Register<0x4002ef14> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 995 high
        struct LUT995H : public Register<0x4002ef1c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 996 high
        struct LUT996H : public Register<0x4002ef24> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 997 high
        struct LUT997H : public Register<0x4002ef2c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 998 high
        struct LUT998H : public Register<0x4002ef34> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 999 high
        struct LUT999H : public Register<0x4002ef3c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1000 high
        struct LUT1000H : public Register<0x4002ef44> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1001 high
        struct LUT1001H : public Register<0x4002ef4c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1002 high
        struct LUT1002H : public Register<0x4002ef54> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1003 high
        struct LUT1003H : public Register<0x4002ef5c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1004 high
        struct LUT1004H : public Register<0x4002ef64> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1005 high
        struct LUT1005H : public Register<0x4002ef6c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1006 high
        struct LUT1006H : public Register<0x4002ef74> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1007 high
        struct LUT1007H : public Register<0x4002ef7c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1008 high
        struct LUT1008H : public Register<0x4002ef84> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1009 high
        struct LUT1009H : public Register<0x4002ef8c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1010 high
        struct LUT1010H : public Register<0x4002ef94> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1011 high
        struct LUT1011H : public Register<0x4002ef9c> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1012 high
        struct LUT1012H : public Register<0x4002efa4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1013 high
        struct LUT1013H : public Register<0x4002efac> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1014 high
        struct LUT1014H : public Register<0x4002efb4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1015 high
        struct LUT1015H : public Register<0x4002efbc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1016 high
        struct LUT1016H : public Register<0x4002efc4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1017 high
        struct LUT1017H : public Register<0x4002efcc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1018 high
        struct LUT1018H : public Register<0x4002efd4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1019 high
        struct LUT1019H : public Register<0x4002efdc> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1020 high
        struct LUT1020H : public Register<0x4002efe4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1021 high
        struct LUT1021H : public Register<0x4002efec> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1022 high
        struct LUT1022H : public Register<0x4002eff4> {
            using LO = Field<4, 18>;    // Line offset
        };

        // Graphic MMU LUT entry 1023 high
        struct LUT1023H : public Register<0x4002effc> {
            using LO = Field<4, 18>;    // Line offset
        };

    };

    // OctoSPI IO Manager
    struct OCTOSPIM {
        // OctoSPI IO Manager Port 1 Configuration Register
        struct P1CR : public Register<0x50061c04> {
            using CLKEN = Field<0, 1>;    // CLK/CLK Enable for Port
            using CLKSRC = Field<1, 1>;    // CLK/CLK Source for Port
            using DQSEN = Field<4, 1>;    // DQS Enable for Port
            using DQSSRC = Field<5, 1>;    // DQS Source for Port
            using NCSEN = Field<8, 1>;    // CS Enable for Port
            using NCSSRC = Field<9, 1>;    // CS Source for Port
            using IOLEN = Field<16, 1>;    // Enable for Port
            using IOLSRC = Field<17, 2>;    // Source for Port
            using IOHEN = Field<24, 1>;    // Enable for Port n
            using IOHSRC = Field<25, 2>;    // Source for Port
        };

        // OctoSPI IO Manager Port 2 Configuration Register
        struct P2CR : public Register<0x50061c08> {
            using CLKEN = Field<0, 1>;    // CLK/CLK Enable for Port
            using CLKSRC = Field<1, 1>;    // CLK/CLK Source for Port
            using DQSEN = Field<4, 1>;    // DQS Enable for Port
            using DQSSRC = Field<5, 1>;    // DQS Source for Port
            using NCSEN = Field<8, 1>;    // CS Enable for Port
            using NCSSRC = Field<9, 1>;    // CS Source for Port
            using IOLEN = Field<16, 1>;    // Enable for Port
            using IOLSRC = Field<17, 2>;    // Source for Port
            using IOHEN = Field<24, 1>;    // Enable for Port n
            using IOHSRC = Field<25, 2>;    // Source for Port
        };

    };

    // Floting point unit
    struct FPU {
        // Floating-point context control register
        struct FPCCR : public Register<0xe000ef34> {
            using LSPACT = Field<0, 1>;    // LSPACT
            using USER = Field<1, 1>;    // USER
            using THREAD = Field<3, 1>;    // THREAD
            using HFRDY = Field<4, 1>;    // HFRDY
            using MMRDY = Field<5, 1>;    // MMRDY
            using BFRDY = Field<6, 1>;    // BFRDY
            using MONRDY = Field<8, 1>;    // MONRDY
            using LSPEN = Field<30, 1>;    // LSPEN
            using ASPEN = Field<31, 1>;    // ASPEN
        };

        // Floating-point context address register
        struct FPCAR : public Register<0xe000ef38> {
            using ADDRESS = Field<3, 29>;    // Location of unpopulated floating-point
        };

        // Floating-point status control register
        struct FPSCR : public Register<0xe000ef3c> {
            using IOC = Field<0, 1>;    // Invalid operation cumulative exception bit
            using DZC = Field<1, 1>;    // Division by zero cumulative exception bit.
            using OFC = Field<2, 1>;    // Overflow cumulative exception bit
            using UFC = Field<3, 1>;    // Underflow cumulative exception bit
            using IXC = Field<4, 1>;    // Inexact cumulative exception bit
            using IDC = Field<7, 1>;    // Input denormal cumulative exception bit.
            using RMode = Field<22, 2>;    // Rounding Mode control field
            using FZ = Field<24, 1>;    // Flush-to-zero mode control bit:
            using DN = Field<25, 1>;    // Default NaN mode control bit
            using AHP = Field<26, 1>;    // Alternative half-precision control bit
            using V = Field<28, 1>;    // Overflow condition code flag
            using C = Field<29, 1>;    // Carry condition code flag
            using Z = Field<30, 1>;    // Zero condition code flag
            using N = Field<31, 1>;    // Negative condition code flag
        };

    };

    // Memory protection unit
    struct MPU {
        // MPU type register
        struct MPU_TYPER : public Register<0xe000ed90> {
            using SEPARATE = Field<0, 1>;    // Separate flag
            using DREGION = Field<8, 8>;    // Number of MPU data regions
            using IREGION = Field<16, 8>;    // Number of MPU instruction regions
        };

        // MPU control register
        struct MPU_CTRL : public Register<0xe000ed94> {
            using ENABLE = Field<0, 1>;    // Enables the MPU
            using HFNMIENA = Field<1, 1>;    // Enables the operation of MPU during hard fault
            using PRIVDEFENA = Field<2, 1>;    // Enable priviliged software access to default memory map
        };

        // MPU region number register
        struct MPU_RNR : public Register<0xe000ed98> {
            using REGION = Field<0, 8>;    // MPU region
        };

        // MPU region base address register
        struct MPU_RBAR : public Register<0xe000ed9c> {
            using REGION = Field<0, 4>;    // MPU region field
            using VALID = Field<4, 1>;    // MPU region number valid
            using ADDR = Field<5, 27>;    // Region base address field
        };

        // MPU region attribute and size register
        struct MPU_RASR : public Register<0xe000eda0> {
            using ENABLE = Field<0, 1>;    // Region enable bit.
            using SIZE = Field<1, 5>;    // Size of the MPU protection region
            using SRD = Field<8, 8>;    // Subregion disable bits
            using B = Field<16, 1>;    // memory attribute
            using C = Field<17, 1>;    // memory attribute
            using S = Field<18, 1>;    // Shareable memory attribute
            using TEX = Field<19, 3>;    // memory attribute
            using AP = Field<24, 3>;    // Access permission
            using XN = Field<28, 1>;    // Instruction access disable bit
        };

    };

    // SysTick timer
    struct STK {
        // SysTick control and status register
        struct CTRL : public Register<0xe000e010> {
            using ENABLE = Field<0, 1>;    // Counter enable
            using TICKINT = Field<1, 1>;    // SysTick exception request enable
            using CLKSOURCE = Field<2, 1>;    // Clock source selection
            using COUNTFLAG = Field<16, 1>;    // COUNTFLAG
        };

        // SysTick reload value register
        struct LOAD : public Register<0xe000e014> {
            using RELOAD = Field<0, 24>;    // RELOAD value
        };

        // SysTick current value register
        struct VAL : public Register<0xe000e018> {
            using CURRENT = Field<0, 24>;    // Current counter value
        };

        // SysTick calibration value register
        struct CALIB : public Register<0xe000e01c> {
            using TENMS = Field<0, 24>;    // Calibration value
            using SKEW = Field<30, 1>;    // SKEW flag: Indicates whether the TENMS value is exact
            using NOREF = Field<31, 1>;    // NOREF flag. Reads as zero
        };

    };

    // System control block
    struct SCB {
        // CPUID base register
        struct CPUID : public Register<0xe000ed00> {
            using Revision = Field<0, 4>;    // Revision number
            using PartNo = Field<4, 12>;    // Part number of the processor
            using Constant = Field<16, 4>;    // Reads as 0xF
            using Variant = Field<20, 4>;    // Variant number
            using Implementer = Field<24, 8>;    // Implementer code
        };

        // Interrupt control and state register
        struct ICSR : public Register<0xe000ed04> {
            using VECTACTIVE = Field<0, 9>;    // Active vector
            using RETTOBASE = Field<11, 1>;    // Return to base level
            using VECTPENDING = Field<12, 7>;    // Pending vector
            using ISRPENDING = Field<22, 1>;    // Interrupt pending flag
            using PENDSTCLR = Field<25, 1>;    // SysTick exception clear-pending bit
            using PENDSTSET = Field<26, 1>;    // SysTick exception set-pending bit
            using PENDSVCLR = Field<27, 1>;    // PendSV clear-pending bit
            using PENDSVSET = Field<28, 1>;    // PendSV set-pending bit
            using NMIPENDSET = Field<31, 1>;    // NMI set-pending bit.
        };

        // Vector table offset register
        struct VTOR : public Register<0xe000ed08> {
            using TBLOFF = Field<9, 21>;    // Vector table base offset field
        };

        // Application interrupt and reset control register
        struct AIRCR : public Register<0xe000ed0c> {
            using VECTRESET = Field<0, 1>;    // VECTRESET
            using VECTCLRACTIVE = Field<1, 1>;    // VECTCLRACTIVE
            using SYSRESETREQ = Field<2, 1>;    // SYSRESETREQ
            using PRIGROUP = Field<8, 3>;    // PRIGROUP
            using ENDIANESS = Field<15, 1>;    // ENDIANESS
            using VECTKEYSTAT = Field<16, 16>;    // Register key
        };

        // System control register
        struct SCR : public Register<0xe000ed10> {
            using SLEEPONEXIT = Field<1, 1>;    // SLEEPONEXIT
            using SLEEPDEEP = Field<2, 1>;    // SLEEPDEEP
            using SEVEONPEND = Field<4, 1>;    // Send Event on Pending bit
        };

        // Configuration and control register
        struct CCR : public Register<0xe000ed14> {
            using NONBASETHRDENA = Field<0, 1>;    // Configures how the processor enters Thread mode
            using USERSETMPEND = Field<1, 1>;    // USERSETMPEND
            using UNALIGN__TRP = Field<3, 1>;    // UNALIGN_ TRP
            using DIV_0_TRP = Field<4, 1>;    // DIV_0_TRP
            using BFHFNMIGN = Field<8, 1>;    // BFHFNMIGN
            using STKALIGN = Field<9, 1>;    // STKALIGN
        };

        // System handler priority registers
        struct SHPR1 : public Register<0xe000ed18> {
            using PRI_4 = Field<0, 8>;    // Priority of system handler 4
            using PRI_5 = Field<8, 8>;    // Priority of system handler 5
            using PRI_6 = Field<16, 8>;    // Priority of system handler 6
        };

        // System handler priority registers
        struct SHPR2 : public Register<0xe000ed1c> {
            using PRI_11 = Field<24, 8>;    // Priority of system handler 11
        };

        // System handler priority registers
        struct SHPR3 : public Register<0xe000ed20> {
            using PRI_14 = Field<16, 8>;    // Priority of system handler 14
            using PRI_15 = Field<24, 8>;    // Priority of system handler 15
        };

        // System handler control and state register
        struct SHCRS : public Register<0xe000ed24> {
            using MEMFAULTACT = Field<0, 1>;    // Memory management fault exception active bit
            using BUSFAULTACT = Field<1, 1>;    // Bus fault exception active bit
            using USGFAULTACT = Field<3, 1>;    // Usage fault exception active bit
            using SVCALLACT = Field<7, 1>;    // SVC call active bit
            using MONITORACT = Field<8, 1>;    // Debug monitor active bit
            using PENDSVACT = Field<10, 1>;    // PendSV exception active bit
            using SYSTICKACT = Field<11, 1>;    // SysTick exception active bit
            using USGFAULTPENDED = Field<12, 1>;    // Usage fault exception pending bit
            using MEMFAULTPENDED = Field<13, 1>;    // Memory management fault exception pending bit
            using BUSFAULTPENDED = Field<14, 1>;    // Bus fault exception pending bit
            using SVCALLPENDED = Field<15, 1>;    // SVC call pending bit
            using MEMFAULTENA = Field<16, 1>;    // Memory management fault enable bit
            using BUSFAULTENA = Field<17, 1>;    // Bus fault enable bit
            using USGFAULTENA = Field<18, 1>;    // Usage fault enable bit
        };

        // Configurable fault status register
        struct CFSR_UFSR_BFSR_MMFSR : public Register<0xe000ed28> {
            using IACCVIOL = Field<1, 1>;    // Instruction access violation flag
            using MUNSTKERR = Field<3, 1>;    // Memory manager fault on unstacking for a return from exception
            using MSTKERR = Field<4, 1>;    // Memory manager fault on stacking for exception entry.
            using MLSPERR = Field<5, 1>;    // MLSPERR
            using MMARVALID = Field<7, 1>;    // Memory Management Fault Address Register (MMAR) valid flag
            using IBUSERR = Field<8, 1>;    // Instruction bus error
            using PRECISERR = Field<9, 1>;    // Precise data bus error
            using IMPRECISERR = Field<10, 1>;    // Imprecise data bus error
            using UNSTKERR = Field<11, 1>;    // Bus fault on unstacking for a return from exception
            using STKERR = Field<12, 1>;    // Bus fault on stacking for exception entry
            using LSPERR = Field<13, 1>;    // Bus fault on floating-point lazy state preservation
            using BFARVALID = Field<15, 1>;    // Bus Fault Address Register (BFAR) valid flag
            using UNDEFINSTR = Field<16, 1>;    // Undefined instruction usage fault
            using INVSTATE = Field<17, 1>;    // Invalid state usage fault
            using INVPC = Field<18, 1>;    // Invalid PC load usage fault
            using NOCP = Field<19, 1>;    // No coprocessor usage fault.
            using UNALIGNED = Field<24, 1>;    // Unaligned access usage fault
            using DIVBYZERO = Field<25, 1>;    // Divide by zero usage fault
        };

        // Hard fault status register
        struct HFSR : public Register<0xe000ed2c> {
            using VECTTBL = Field<1, 1>;    // Vector table hard fault
            using FORCED = Field<30, 1>;    // Forced hard fault
            using DEBUG_VT = Field<31, 1>;    // Reserved for Debug use
        };

        // Memory management fault address register
        struct MMFAR : public Register<0xe000ed34> {
            using Field = Field<0, 32>;    // Memory management fault address
        };

        // Bus fault address register
        struct BFAR : public Register<0xe000ed38> {
            using Field = Field<0, 32>;    // Bus fault address
        };

        // Auxiliary fault status register
        struct AFSR : public Register<0xe000ed3c> {
            using IMPDEF = Field<0, 32>;    // Implementation defined
        };

    };

    // Nested vectored interrupt controller
    struct NVIC_STIR {
        // Software trigger interrupt register
        struct STIR : public Register<0xe000ef00> {
            using INTID = Field<0, 9>;    // Software generated interrupt ID
        };

    };

    // Floating point unit CPACR
    struct FPU_CPACR {
        // Coprocessor access control register
        struct CPACR : public Register<0xe000ed88> {
            using CP = Field<20, 4>;    // CP
        };

    };

    // System control block ACTLR
    struct SCB_ACTRL {
        // Auxiliary control register
        struct ACTRL : public Register<0xe000e008> {
            using DISMCYCINT = Field<0, 1>;    // DISMCYCINT
            using DISDEFWBUF = Field<1, 1>;    // DISDEFWBUF
            using DISFOLD = Field<2, 1>;    // DISFOLD
            using DISFPCA = Field<8, 1>;    // DISFPCA
            using DISOOFP = Field<9, 1>;    // DISOOFP
        };

    };

};
